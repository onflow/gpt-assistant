---
sidebar_position: 1
---

# Account Abstraction

Flow provides native support for key use cases that are enabled by Account Abstraction, empowering developers to deliver mainstream-ready user experiences. With Cadence, Flow was designed with these use cases in mind through the separation of the contract and transaction layers. This guide demonstrates how Flow supports key use cases that are made possible with Account Abstraction.

## Multi-sig Transactions

Since accounts are smart contracts, they can be defined in order to require multiple signatures in order to execute a transaction, which unlocks a range of new users that improve the user experience for Web3 apps.

| Account Abstraction                                                                                                                                                         | Flow                                                                                                                                                                                                                                                                          |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| The move from from Externally-Owned Accounts (EOAs) to smart contract accounts enables developers to build in logic to require multiple signatures to execute transactions. | Flow has native support for multi-sig transactions since all accounts are defined as smart contracts. Flow provides [support for multiple keys](../basics/accounts.md#account-keys) to be added to an account and weights can be applied to denote relative priority. |

## Sponsored Transactions

The concept of paying fees to execute transactions in order to use Web3 apps can be a hurdle for newcomers as they begin to explore these experiences. In order to remove this significant point of friction in requiring newcomers to acquire crypto before they can get started with an app, developers can subsidize these costs on behalf of users.

| Account Abstraction                                                                                                                                                                                         | Flow                                                                                                                                                                             |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| The ERC-4337 standard introduces the concept of [paymasters](https://eips.ethereum.org/EIPS/eip-4337#extension-paymasters), which can enable a developer to pay the fees for a transaction for their users. | Flow has built-in support for [3 different roles](../basics/transactions.md#signer-roles) for transactions which provides native support for sponsored transactions. |

## Bundled Transactions

Developers can deliver a more streamlined user experience that reduces the amount of interruptions in the form of transaction approvals by bundling multiple transactions together into a single transaction that executes the set of operations with one signature.

| Account Abstraction                                                                                                                                                                                                                                                        | Flow                                                                                                                                                                                   |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| The ERC-4337 standard outlines support for bundled transactions through a new mempool that holds user operations from smart wallets. Bundlers package sets of these user operations into a single transaction on the blockchain and return the result back to each wallet. | Since Cadence has an explicit separation of contracts and transactions, Flow has protocol-level support for bundling transactions across multiple contracts into a single transaction. |

## Account Recovery

Account Abstraction enables developers to build more robust account management features for users, addressing the major pain point of losing access to assets forever if the user loses their keys to their account. Apps can enable users to recover access to their accounts and enclosed assets through social recovery or pre-approved accounts.

| Account Abstraction                                                                                                                                                                          | Flow                                                                                                                                                                 |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Smart contract accounts can be defined to include account recovery logic that enables users to define custom recovery methods that can rely on specific accounts or other validated sources. | Since all accounts are smart contracts, Flow has native support for account recovery and cycling of keys to help users regain access to accounts in a secure manner. |

## Multi-factor Authentication

Multi-factor authentication is a broadly accepted concept in Web2 apps for secure access to accounts and Account Abstraction enables developers to deliver the same benefits to Web3 users.

| Account Abstraction                                                                                                                                                       | Flow                                                                                                                                                                   |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Smart contract accounts can require a secondary factor to confirm transactions which can be delivered in the form of familiar confirmation channels such as email or SMS. | Since all accounts are smart contracts, Flow has native support for multi-factor authentication as developers can implement these security mechanisms for their users. |

## Seamless Experience

Account Abstraction brings the potential for dramatic improvements to the user experience of Web3 apps. Developers can introduce conditions under which a user can grant a smart contract account to pre-approve transactions under certain conditions, reducing interruptions for the user to explicitly sign each transaction.

These improvements are especially notable on mobile, where users are typically met with the jarring experience of switching between apps in approve transactions.

| Account Abstraction                                                                                                                                                                                                           | Flow                                                                                                                                                                       |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Developers can build new features that streamline the user experience of Web3 apps, such as ‘session keys’ that pre-approve transactions for a period of time or setting custom limits on transaction volume or network fees. | Since all accounts are smart contracts, Flow has support for these new controls that enable apps to sign pre-approved transactions based on user controls and preferences. |
---
title: Building Walletless Applications Using Child Accounts
sidebar_position: 1
---

In this doc, we’ll dive into a progressive onboarding flow, including the Cadence scripts & transactions that go into
its implementation in your app. These components will enable any implementing app to create a custodial account,
mediate the user’s onchain actions on their behalf, and later delegate access of that app-created account to the
user’s wallet. We’ll refer to this custodial pattern as the Hybrid Custody Model and the process of delegating control
of the app account as Account Linking.

## Objectives

- Create a [walletless onboarding](https://flow.com/post/flow-blockchain-mainstream-adoption-easy-onboarding-wallets)
  transaction
- Link an existing app account as a child to a newly authenticated parent account
- Get your app to recognize “parent” accounts along with any associated “child” accounts
- Put it all together to create a blockchain-native onboarding transaction
- View fungible and non-fungible Token metadata relating to assets across all of a user’s associated accounts - their
  wallet-mediated “parent” account and any “child” accounts
- Facilitate transactions acting on assets in child accounts

## Point of Clarity

Before diving in, let's make a distinction between **"account linking"** and **"linking accounts"**.

### Account Linking

<Callout type="info">

Note that since account linking is a sensitive action, transactions where an account may be linked are designated by a
topline pragma `#allowAccountLinking`. This lets wallet providers inform users that their account may be linked in the
signed transaction.

</Callout>

Very simply, account linking is a [feature in Cadence](https://github.com/onflow/flips/pull/53) that let's an
[AuthAccount](https://cadence-lang.org/docs/language/accounts#authaccount) create a
[Capability](https://cadence-lang.org/docs/language/capabilities) on itself. You can do so in the following
transaction:

```cadence link_account.cdc
#allowAccountLinking

transaction(linkPathSuffix: String) {
    prepare(account: AuthAccount) {
        // Create the PrivatePath where we'll create the link
        let linkPath = PrivatePath(identifier: linkPathSuffix)
            ?? panic("Could not construct PrivatePath from given identifier: ".concat(linkPathSuffix))
        // Check if an AuthAccount Capability already exists at the specified path
        if !account.getCapability<&AuthAccount>(linkPath).check() {
            // If not, unlink anything that may be there and link the AuthAccount Capability
            account.unlink(linkpath)
            account.linkAccount(linkPath)
        }
    }
}
```

From there, the signing account can retrieve the privately linked AuthAccount Capability and delegate it to another
account, unlinking the Capability if they wish to revoke delegated access.

Note that in order to link an account, a transaction must state the `#allowAccountLinking` pragma in the top line of the
transaction. This is an interim safety measure so that wallet providers can notify users they're about to sign a
transaction that may create a Capability on their AuthAccount.

### Linking Accounts

Linking accounts leverages this account link, otherwise known as an **AuthAccount Capability**, and encapsulates it. The
[components and actions](https://github.com/onflow/flips/pull/72) involved in this process - what the Capability is
encapsulated in, the collection that holds those encapsulations, etc. is what we'll dive into in this doc.

## Terminology

**Parent-Child accounts** - For the moment, we’ll call the account created by the app the “child” account and the
account receiving its AuthAccount Capability the “parent” account. Existing methods of account access & delegation (i.e.
keys) still imply ownership over the account, but insofar as linked accounts are concerned, the account to which both
the user and the app share access via AuthAccount Capability will be considered the “child” account.

**Walletless onboarding** - An onboarding flow whereby an app creates an account for a user, onboarding them to the
app, obviating the need for user wallet authentication.

**Blockchain-native onboarding** - Similar to the already familiar Web3 onboarding flow where a user authenticates with
their existing wallet, an app onboards a user via wallet authentication while additionally creating an app account and
linking it with the authenticated account, resulting in a hybrid custody model.

**Hybrid Custody Model** - A custodial pattern in which an app and a user maintain access to an app created account and
user access to that account has been mediated by account linking.

**Account Linking** - Technically speaking, account linking in our context consists of giving some other account an
AuthAccount Capability from the granting account. This Capability is maintained in standardized resource called a
`HybridCustody.Manager`, providing its owning user access to any and all of their linked accounts.

**Progressive Onboarding** - An onboarding flow that walks a user up to self-custodial ownership, starting with
walletless onboarding and later linking the app account with the user’s authenticated wallet once the user chooses to
do so.

**Restricted Child Account** - An account delegation where the access on the delegating account is restricted according
to rules set by the linking child account. The distinctions between this and the subsequent term ("owned" account) will
be expanding on later.

**Owned Account** - An account delegation where the delegatee has unrestricted access on the delegating child account,
thereby giving the delegatee presiding authority superseding any other "restricted" parent accounts.

## Account Linking

Linking an account is the process of delegating account access via AuthAccount Capability. Of course, we want to do this
in a way that allows the receiving account to maintain that Capability and allows easy identification of the accounts on
either end of the linkage - the user's main "parent" account and the linked "child" account. This is accomplished in the
(still in flux) `HybridCustody` contract which we'll continue to use in this guidance.

### Pre-requisites

Since account delegation is mediated by developer-defined rules, you should make sure to first configure the resources
that contain those rules. Contracts involved in defining and enforcing this ruleset are
[`CapabilityFilter`](https://github.com/onflow/hybrid-custody/blob/main/contracts/CapabilityFilter.cdc) and
[`CapabilityFactory`](https://github.com/onflow/hybrid-custody/blob/main/contracts/CapabilityFactory.cdc).
The former enumerates those types that are/aren't accessible from a child account while the latter enables the access of
those allowable Capabilities such that the returned values can be properly typed - e.g. retrieving a Capability that can
be cast to `Capability<&NonFungibleToken.Collection>` for example.

Here's how you would configure an `AllowlistFilter` and add allowed types to it:

```cadence setup_allow_all_filter.cdc
import "CapabilityFilter"

transaction(identifiers: [String]) {
    prepare(acct: AuthAccount) {
        // Setup the AllowlistFilter
        if acct.borrow<&CapabilityFilter.AllowlistFilter>(from: CapabilityFilter.StoragePath) == nil {
            acct.save(<-CapabilityFilter.create(Type<@CapabilityFilter.AllowlistFilter>()), to: CapabilityFilter.StoragePath)
        }

        // Ensure the AllowlistFilter is linked to the expected PublicPath
        acct.unlink(CapabilityFilter.PublicPath)
        acct.link<&CapabilityFilter.AllowlistFilter{CapabilityFilter.Filter}>(CapabilityFilter.PublicPath, target: CapabilityFilter.StoragePath)

        // Get a reference to the filter
        let filter = acct.borrow<&CapabilityFilter.AllowlistFilter>(from: CapabilityFilter.StoragePath)
            ?? panic("filter does not exist")

        // Add the given type identifiers to the AllowlistFilter
        // **Note:** the whole transaction fails if any of the given identifiers are malformed
        for identifier in identifiers {
            let c = CompositeType(identifier)!
            filter.addType(c)
        }
    }
}
```

And the following transaction configures a `CapabilityFactory.Manager`, adding NFT-related `Factory` objects:

<Callout type="info">

Note that the Manager configured here enables retrieval of castable Capabilities. It's recommended that you implement
Factory resource definitions to support any NFT Collections related with the use of your application so that users can
retrieve Typed Capabilities from accounts linked from your app.

</Callout>

```cadence setup_factory.cdc
import "CapabilityFactory"
import "NFTCollectionPublicFactory"
import "NFTProviderAndCollectionFactory"
import "NFTProviderFactory"

import "NonFungibleToken"

transaction {

    prepare(acct: AuthAccount) {
        // Check for a stored Manager, saving if not found
        if acct.borrow<&AnyResource>(from: CapabilityFactory.StoragePath) == nil {
            let f <- CapabilityFactory.createFactoryManager()
            acct.save(<-f, to: CapabilityFactory.StoragePath)
        }
        // Check for Capabilities where expected, linking if not found
        if !acct.getCapability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>(CapabilityFactory.PrivatePath).check() {
            acct.unlink(CapabilityFactory.PublicPath)
            acct.link<&CapabilityFactory.Manager{CapabilityFactory.Getter}>(CapabilityFactory.PublicPath, target: CapabilityFactory.StoragePath)
        }

        assert(
            acct.getCapability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>(CapabilityFactory.PublicPath).check(),
            message: "CapabilityFactory is not setup properly"
        )

        let manager = acct.borrow<&CapabilityFactory.Manager>(from: CapabilityFactory.StoragePath)
            ?? panic("manager not found")

        /// Add generic NFT-related Factory implementations to enable castable Capabilities from this Manager
        manager.addFactory(Type<&{NonFungibleToken.CollectionPublic}>(), NFTCollectionPublicFactory.Factory())
        manager.addFactory(Type<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(), NFTProviderAndCollectionFactory.Factory())
        manager.addFactory(Type<&{NonFungibleToken.Provider}>(), NFTProviderFactory.Factory())
    }
}
```

![resources/hybrid_custody_high_level](./resources/hybrid_custody_high_level.png)

*In this scenario, a user custodies a key for their main account which maintains access to a wrapped AuthAccount
Capability, providing the user restricted access on the app account. The app maintains custodial access to the account
and regulates the access restrictions to delegatee "parent" accounts.*

Linking accounts can be done in one of two ways. Put simply, the child account needs to get the parent account an
`AuthAccount` Capability, and the parent needs to save that Capability so they can retain access in a manner that also
represents each side of the link and safeguards the integrity of any access restrictions an application puts in place on
delegated access.

We can achieve issuance from the child account and claim from the parent account pattern in either:

1. We can leverage [Cadence’s `AuthAccount.Inbox`](https://cadence-lang.org/docs/language/accounts#account-inbox) to publish the
   Capability from the child account & have the parent claim the Capability in a separate transaction.
1. Multi-party signed transaction, signed by both the the accounts on either side of the link

Let’s take a look at both.

<Callout type="info">

You'll want to consider whether you would like the parent account to be configured with some app-specific resources or
Capabilities and compose you multisig or claim transactions to include such configurations. <br/>

For example, if your app deals with specific NFTs, you may want to configure the parent account with Collections for
those NFTs so the user can easily transfer them between their linked accounts.

</Callout>

### Publish & Claim

#### Publish

Here, the account delegating access to itself links its AuthAccount Capability, and publishes it to be claimed by the
account it will be linked to.

```cadence publish_to_parent.cdc
import "HybridCustody"
import "CapabilityFactory"
import "CapabilityFilter"
import "CapabilityDelegator"

transaction(parent: Address, factoryAddress: Address, filterAddress: Address) {
    prepare(acct: AuthAccount) {
        let owned = acct.borrow<&HybridCustody.OwnedAccount>(from: HybridCustody.OwnedAccountStoragePath)
            ?? panic("owned account not found")

        let factory = getAccount(factoryAddress).getCapability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>(CapabilityFactory.PublicPath)
        assert(factory.check(), message: "factory address is not configured properly")

        let filter = getAccount(filterAddress).getCapability<&{CapabilityFilter.Filter}>(CapabilityFilter.PublicPath)
        assert(filter.check(), message: "capability filter is not configured properly")

        owned.publishToParent(parentAddress: parent, factory: factory, filter: filter)
    }
}
```

#### Claim

On the other side, the receiving account claims the published `ChildAccount` Capability, adding it to the signer's
`HybridCustody.Manager.childAccounts` indexed on the child account's Address.

```cadence redeem_account.cdc
import "MetadataViews"

import "HybridCustody"
import "CapabilityFilter"

transaction(childAddress: Address, filterAddress: Address?, filterPath: PublicPath?) {
    prepare(acct: AuthAccount) {
        var filter: Capability<&{CapabilityFilter.Filter}>? = nil
        if filterAddress != nil && filterPath != nil {
            filter = getAccount(filterAddress!).getCapability<&{CapabilityFilter.Filter}>(filterPath!)
        }

        if acct.borrow<&HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath) == nil {
            let m <- HybridCustody.createManager(filter: filter)
            acct.save(<- m, to: HybridCustody.ManagerStoragePath)

            acct.unlink(HybridCustody.ManagerPublicPath)
            acct.unlink(HybridCustody.ManagerPrivatePath)

            acct.link<&HybridCustody.Manager{HybridCustody.ManagerPrivate, HybridCustody.ManagerPublic}>(
                HybridCustody.ManagerPrivatePath,
                target: HybridCustody.ManagerStoragePath
            )
            acct.link<&HybridCustody.Manager{HybridCustody.ManagerPublic}>(
                HybridCustody.ManagerPublicPath,
                target: HybridCustody.ManagerStoragePath
            )
        }

        let inboxName = HybridCustody.getChildAccountIdentifier(acct.address)
        let cap = acct.inbox.claim<&HybridCustody.ChildAccount{HybridCustody.AccountPrivate, HybridCustody.AccountPublic, MetadataViews.Resolver}>(
                inboxName,
                provider: childAddress
            ) ?? panic("child account cap not found")

        let manager = acct.borrow<&HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
            ?? panic("manager no found")

        manager.addAccount(cap: cap)
    }
}
```

### Multi-Signed Transaction

We can combine the two transactions in [Publish](#publish) and [Claim](#claim) into a single multi-signed transaction to
achieve Hybrid Custody in a single step.

<Callout type="info">

Note that while the following code links both accounts in a single transaction, in practicality you may find it easier
to execute publish and claim transactions separately depending on your custodial infrastructure.

</Callout>

```cadence setup_multi_sig.cdc
#allowAccountLinking

import "HybridCustody"

import "CapabilityFactory"
import "CapabilityDelegator"
import "CapabilityFilter"

import "MetadataViews"

transaction(parentFilterAddress: Address?, childAccountFactoryAddress: Address, childAccountFilterAddress: Address) {
    prepare(childAcct: AuthAccount, parentAcct: AuthAccount) {
        // --------------------- Begin setup of child account ---------------------
        var acctCap = childAcct.getCapability<&AuthAccount>(HybridCustody.LinkedAccountPrivatePath)
        if !acctCap.check() {
            acctCap = childAcct.linkAccount(HybridCustody.LinkedAccountPrivatePath)!
        }

        if childAcct.borrow<&HybridCustody.OwnedAccount>(from: HybridCustody.OwnedAccountStoragePath) == nil {
            let ownedAccount <- HybridCustody.createOwnedAccount(acct: acctCap)
            childAcct.save(<-ownedAccount, to: HybridCustody.OwnedAccountStoragePath)
        }

        // check that paths are all configured properly
        childAcct.unlink(HybridCustody.OwnedAccountPrivatePath)
        childAcct.link<&HybridCustody.OwnedAccount{HybridCustody.BorrowableAccount, HybridCustody.OwnedAccountPublic, MetadataViews.Resolver}>(
            HybridCustody.OwnedAccountPrivatePath,
            target: HybridCustody.OwnedAccountStoragePath
        )

        childAcct.unlink(HybridCustody.OwnedAccountPublicPath)
        childAcct.link<&HybridCustody.OwnedAccount{HybridCustody.OwnedAccountPublic, MetadataViews.Resolver}>(
            HybridCustody.OwnedAccountPublicPath,
            target: HybridCustody.OwnedAccountStoragePath
        )
        // --------------------- End setup of child account ---------------------

        // --------------------- Begin setup of parent account ---------------------
        var filter: Capability<&{CapabilityFilter.Filter}>? = nil
        if parentFilterAddress != nil {
            filter = getAccount(parentFilterAddress!).getCapability<&{CapabilityFilter.Filter}>(CapabilityFilter.PublicPath)
        }

        if parentAcct.borrow<&HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath) == nil {
            let m <- HybridCustody.createManager(filter: filter)
            parentAcct.save(<- m, to: HybridCustody.ManagerStoragePath)
        }

        parentAcct.unlink(HybridCustody.ManagerPublicPath)
        parentAcct.unlink(HybridCustody.ManagerPrivatePath)

        parentAcct.link<&HybridCustody.Manager{HybridCustody.ManagerPrivate, HybridCustody.ManagerPublic}>(
            HybridCustody.OwnedAccountPrivatePath,
            target: HybridCustody.ManagerStoragePath
        )
        parentAcct.link<&HybridCustody.Manager{HybridCustody.ManagerPublic}>(
            HybridCustody.OwnedAccountPublicPath,
            target: HybridCustody.ManagerStoragePath
        )
        // --------------------- End setup of parent account ---------------------

        // Publish account to parent
        let owned = childAcct.borrow<&HybridCustody.OwnedAccount>(from: HybridCustody.OwnedAccountStoragePath)
            ?? panic("owned account not found")

        let factory = getAccount(childAccountFactoryAddress)
            .getCapability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>(CapabilityFactory.PublicPath)
        assert(factory.check(), message: "factory address is not configured properly")

        let filterForChild = getAccount(childAccountFilterAddress).getCapability<&{CapabilityFilter.Filter}>(CapabilityFilter.PublicPath)
        assert(filterForChild.check(), message: "capability filter is not configured properly")

        owned.publishToParent(parentAddress: parentAcct.address, factory: factory, filter: filterForChild)

        // claim the account on the parent
        let inboxName = HybridCustody.getChildAccountIdentifier(parentAcct.address)
        let cap = parentAcct.inbox.claim<&HybridCustody.ChildAccount{HybridCustody.AccountPrivate, HybridCustody.AccountPublic, MetadataViews.Resolver}>(
                inboxName,
                provider: childAcct.address
            ) ?? panic("child account cap not found")

        let manager = parentAcct.borrow<&HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
            ?? panic("manager no found")

        manager.addAccount(cap: cap)
    }
}
```

## Onboarding Flows

Given the ability to establish an account and later delegate access to a user, apps are freed from the constraints of
dichotomous custodial & self-custodial paradigms. A developer can choose to onboard a user via traditional Web2 identity
and later delegate access to the user’s wallet account. Alternatively, an app can enable wallet authentication at the
outset, creating an app-specific account & linking with the user’s wallet account. As specified above, these two flows
are known as walletless and blockchain-native onboarding respectively. Developers can choose to implement one for
simplicity or both for maximum flexibility.

### Walletless Onboarding

The following transaction creates an account, funding creation via the signer and adding the provided public key. You'll
notice this transaction is pretty much your standard account creation. The magic for you will be how you custody the key
for this account (locally, KMS, wallet service, etc.) in a manner that allows your app to mediate onchain interactions
on behalf of your user.

```cadence walletless_onboarding
import "FungibleToken"
import "FlowToken"

transaction(pubKey: String, initialFundingAmt: UFix64) {

	prepare(signer: AuthAccount) {

		/* --- Account Creation --- */
		// **NOTE:** your app may choose to separate creation depending on your custodial model)
		//
		// Create the child account, funding via the signer
		let newAccount = AuthAccount(payer: signer)
		// Create a public key for the new account from string value in the provided arg
		// **NOTE:** You may want to specify a different signature algo for your use case
		let key = PublicKey(
			publicKey: pubKey.decodeHex(),
			signatureAlgorithm: SignatureAlgorithm.ECDSA_P256
		)
		// Add the key to the new account
		// **NOTE:** You may want to specify a different hash algo & weight best for your use case
		newAccount.keys.add(
			publicKey: key,
			hashAlgorithm: HashAlgorithm.SHA3_256,
			weight: 1000.0
		)

		/* --- (Optional) Additional Account Funding --- */
		//
		// Fund the new account if specified
		if initialFundingAmt > 0.0 {
			// Get a vault to fund the new account
			let fundingProvider = signer.borrow<&FlowToken.Vault{FungibleToken.Provider}>(
					from: /storage/flowTokenVault
				)!
			// Fund the new account with the initialFundingAmount specified
			newAccount.getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(
				/public/flowTokenReceiver
			).borrow()!
			.deposit(
				from: <-fundingProvider.withdraw(
					amount: initialFundingAmt
				)
			)
		}

		/* --- Continue with use case specific setup --- */
		//
		// At this point, the newAccount can further be configured as suitable for
		// use in your app (e.g. Setup a Collection, Mint NFT, Configure Vault, etc.)
		// ...
	}
}
```

### Blockchain-Native Onboarding

This onboarding flow is really a single-transaction composition of the steps covered above. This is a testament to the
power of the complex transactions you can compose on Flow with Cadence!

<Callout type="info">

Recall the [pre-requisites](#pre-requisites) needed to be satisfied before linking an account: <br/>

1. CapabilityFilter Filter saved and linked <br/>
1. CapabilityFactory Manager saved and linked as well as Factory implementations supporting the Capability Types you'll
   want accessible from linked child accounts as Typed Capabilities.

</Callout>

#### Account Creation & Linking

Compared to walletless onboarding where a user does not have a Flow account, blockchain-native onboarding assumes a user
already has a wallet configured and immediately links it with a newly created app account. This enables the app to
sign transactions on the user's behalf via the new child account while immediately delegating control of that account to
the onboarding user's main account.

After this transaction, both the custodial party (presumably the client/app) and the signing parent account will have
access to the newly created account - the custodial party via key access and the parent account via their
`HybridCustody.Manager` maintaining the new account's `ChildAccount` Capability.

```cadence blockchain_native_onboarding.cdc
#allowAccountLinking

import "FungibleToken"
import "FlowToken"
import "MetadataViews"

import "HybridCustody"
import "CapabilityFactory"
import "CapabilityFilter"
import "CapabilityDelegator"

transaction(
    pubKey: String,
    initialFundingAmt: UFix64,
    factoryAddress: Address,
    filterAddress: Address
) {

    prepare(parent: AuthAccount, app: AuthAccount) {
        /* --- Account Creation --- */
        //
        // Create the child account, funding via the signing app account
        let newAccount = AuthAccount(payer: app)
        // Create a public key for the child account from string value in the provided arg
        // **NOTE:** You may want to specify a different signature algo for your use case
        let key = PublicKey(
            publicKey: pubKey.decodeHex(),
            signatureAlgorithm: SignatureAlgorithm.ECDSA_P256
        )
        // Add the key to the new account
        // **NOTE:** You may want to specify a different hash algo & weight best for your use case
        newAccount.keys.add(
            publicKey: key,
            hashAlgorithm: HashAlgorithm.SHA3_256,
            weight: 1000.0
        )

        /* --- (Optional) Additional Account Funding --- */
        //
        // Fund the new account if specified
        if initialFundingAmt > 0.0 {
            // Get a vault to fund the new account
            let fundingProvider = app.borrow<&FlowToken.Vault{FungibleToken.Provider}>(
                    from: /storage/flowTokenVault
                )!
            // Fund the new account with the initialFundingAmount specified
            newAccount.getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver)
                .borrow()!
                .deposit(
                    from: <-fundingProvider.withdraw(
                        amount: initialFundingAmt
                    )
                )
        }

        /* Continue with use case specific setup */
        //
        // At this point, the newAccount can further be configured as suitable for
        // use in your app (e.g. Setup a Collection, Mint NFT, Configure Vault, etc.)
        // ...

        /* --- Link the AuthAccount Capability --- */
        //
        var acctCap = newAccount.linkAccount(HybridCustody.LinkedAccountPrivatePath)
            ?? panic("problem linking account Capability for new account")

        // Create a OwnedAccount & link Capabilities
        let ownedAccount <- HybridCustody.createOwnedAccount(acct: acctCap)
        newAccount.save(<-ownedAccount, to: HybridCustody.OwnedAccountStoragePath)
        newAccount
            .link<&HybridCustody.OwnedAccount{HybridCustody.BorrowableAccount, HybridCustody.OwnedAccountPublic, MetadataViews.Resolver}>(
                HybridCustody.OwnedAccountPrivatePath,
                target: HybridCustody.OwnedAccountStoragePath
            )
        newAccount
            .link<&HybridCustody.OwnedAccount{HybridCustody.OwnedAccountPublic}>(
                HybridCustody.OwnedAccountPublicPath,
                target: HybridCustody.OwnedAccountStoragePath
            )

        // Get a reference to the OwnedAccount resource
        let owned = newAccount.borrow<&HybridCustody.OwnedAccount>(from: HybridCustody.OwnedAccountStoragePath)!

        // Get the CapabilityFactory.Manager Capability
        let factory = getAccount(factoryAddress)
            .getCapability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>(
                CapabilityFactory.PublicPath
            )
        assert(factory.check(), message: "factory address is not configured properly")

        // Get the CapabilityFilter.Filter Capability
        let filter = getAccount(filterAddress).getCapability<&{CapabilityFilter.Filter}>(CapabilityFilter.PublicPath)
        assert(filter.check(), message: "capability filter is not configured properly")

        // Configure access for the delegatee parent account
        owned.publishToParent(parentAddress: parent.address, factory: factory, filter: filter)

        /* --- Add delegation to parent account --- */
        //
        // Configure HybridCustody.Manager if needed
        if parent.borrow<&HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath) == nil {
            let m <- HybridCustody.createManager(filter: filter)
            parent.save(<- m, to: HybridCustody.ManagerStoragePath)
        }

        // Link Capabilities
        parent.unlink(HybridCustody.ManagerPublicPath)
        parent.unlink(HybridCustody.ManagerPrivatePath)
        parent.link<&HybridCustody.Manager{HybridCustody.ManagerPrivate, HybridCustody.ManagerPublic}>(
            HybridCustody.ManagerPrivatePath,
            target: HybridCustody.ManagerStoragePath
        )
        parent.link<&HybridCustody.Manager{HybridCustody.ManagerPublic}>(
            HybridCustody.ManagerPublicPath,
            target: HybridCustody.ManagerStoragePath
        )

        // Claim the ChildAccount Capability
        let inboxName = HybridCustody.getChildAccountIdentifier(parent.address)
        let cap = parent
            .inbox
            .claim<&HybridCustody.ChildAccount{HybridCustody.AccountPrivate, HybridCustody.AccountPublic, MetadataViews.Resolver}>(
                inboxName,
                provider: newAccount.address
            ) ?? panic("child account cap not found")

        // Get a reference to the Manager and add the account
        let managerRef = parent.borrow<&HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
            ?? panic("manager no found")
        managerRef.addAccount(cap: cap)
    }
}
```

## Funding & Custody Patterns

Aside from implementing onboarding flows & account linking, you'll want to also consider the account funding & custodial
pattern appropriate for the app you're building. The only pattern compatible with walletless onboarding (and therefore
the only one showcased above) is one in which the app custodies the child account's key and funds account creation.

In general, the funding pattern for account creation will determine to some extent the backend infrastructure needed to
support your app and the onboarding flow your app can support. For example, if you want to to create a service-less
client (a totally local app without backend infrastructure), you could forego walletless onboarding in favor of a
user-funded blockchain-native onboarding to achieve a hybrid custody model. Your app maintains the keys to the app
account locally to sign on behalf of the user, and the user funds the creation of the the account, linking to their main
account on account creation. This would be a **user-funded, app custodied** pattern.

Again, custody may deserve some regulatory insight depending on your jurisdiction. If building for production, you'll
likely want to consider these non-technical implications in your technical decision-making. Such is the nature of
building in crypto.

Here are the patterns you might consider:

### App-Funded, App-Custodied

If you want to implement walletless onboarding, you can stop here as this is the only compatible pattern. In this
scenario, a backend app account funds the creation of a new account and the app custodies the key for said account
either on the user's device or some backend KMS.

### App-Funded, User-Custodied

In this case, the backend app account funds account creation, but adds a key to the account which the user custodies.
In order for the app to act on the user's behalf, it has to be delegated access via AuthAccount Capability which the
backend app account would maintain in a `HybridCustody.Manager`. This means that the new account would have two parent
accounts - the user's and the app. While this pattern provides the user maximum ownership and authority over the child
account, this pattern may present unique considerations and edge cases for you as a builder depending on access to the
child account. Also note that this and the following patterns are incompatible with walletless onboarding in that the
user must have a wallet.

### User-Funded, App-Custodied

As mentioned above, this pattern unlocks totally service-less architectures - just a local client & smart contracts. An
authenticated user signs a transaction creating an account, adding the key provided by the client, and linking the
account as a child account. At the end of the transaction, hybrid custody is achieved and the app can sign with the
custodied key on the user's behalf using the newly created account.

### User-Funded, User-Custodied

While perhaps not useful for most apps, this pattern may be desirable for advanced users who wish to create a shared
access account themselves. The user funds account creation, adding keys they custody, and delegates secondary access to
some other account.---
title: Account Linking (FLIP 72)
sidebar_position: 4
---

# Account Linking

Account linking is a unique Flow concept that enables sharing ownership over [accounts](../../basics/accounts.md). In order to understand how we can achieve that we must first understand how accounts on Flow are accessed.

Accounts on flow can be accessed in Cadence through two types, `PublicAccount` and `AuthAccount`. As the name implies the `PublicAccount` type gives access to all public account information such as address, balance, storage capacity, etc., but doesn't allow changes to the account. The `AuthAccount` type allows the same access as `PublicAccount` but also allows changing the account, including adding/revoking account keys, managing the deployed contracts, as well as linking and publishing Capabilities.

![Flow account structure](resources/account.png)

## Accessing AuthAccount

Accessing the auth account allows for account modification, so it's essential to safeguard this access by mandating that transactions are signed by the account being accessed. A transaction can list multiple auth accounts it wants to access as part of the `pre` section of the transaction. Read more about transaction signing in the transaction documentation.

Since access to the `AuthAccount` object enables state change, the idea of account ownership actually translates to the ability to access the auth account. Traditionally, you might consider this the same as having key access on an account, but we'll see in just a minute how programmatic, ownership-level access is unlocked with [Capabilities on Flow](https://cadence-lang.org/docs/language/capabilities).

## AuthAccount Capabilities

Before proceeding the reader will need a clear understanding of [Cadence capabilities](https://developers.flow.com/cadence/language/capabilities.md) to follow this section. Advanced features such as AuthAccount Capabilities are powerful but if used incorrectly can put your app or users at risk.

Cadence allows the creation of capabilities to delegate access to account storage, meaning any account that has a valid capability to another account object in the storage can access it. This is a powerful feature on its own. The access to the object can be limited when creating a capability so only intended functions or fields can be accessed.

Account linking is made possible by the extension of Capabilities on the `AuthAccount` object itself. Similar to how storage capabilities allow access to a value stored in an account's storage, AuthAccount capabilities allow access to an AuthAccount.

### Creating Account Links

When referring to 'account linking' we mean that an AuthAccount capability is created by the parent account and published to another account. The account owning the `AuthAccount` capability which was made available to another account is the parent account. The account in possession of the capability given by the parent account becomes its child account.

![Account linking on Flow](resources/linking.png)

A link between two existing accounts on Flow can be created in two steps:

1. a child account creates an `AuthAccount` capability and publishes it to the parent account.
2. The parent account, claims that capability and can access the child's account through it.

![Account linking steps on Flow](resources/linking-steps.png)

These two steps are implemented in Cadence as two transactions:

************************************Create capability************************************

The account B creates and publishes the `AuthAccount` capability to the account A at the address `0x01`

```json
#allowAccountLinking

transaction {
    prepare(signer: AuthAccount) {
        let capability = signer.linkAccount(/private/accountCapA)!
        signer.inbox.publish(capability, name: "accountCapA", recipient: 0x1)
    }
}
```

****************************Claim capability****************************

The account A claims the capability published by account B.

```json
transaction {
    prepare(signer: AuthAccount) {
        let capability = signer.inbox.claim<&AuthAccount>("accountCapB", provider: 0x2)!
        let accountRef = capability.borrow()!
    }
}
```

## What is account linking most useful for?

Account linking was specifically designed to enable smooth and seamless onboarding of users to your Flow based application without them first requiring a wallet to do so. This pattern overcomes both the technical hurdle, as well as user's reluctance to install a wallet, and opens access to apps on Flow to every user. Users can experience an app without any delay while still offering a path to self-sovreign ownership. 

Naturally, users may expect to use their account with another application, or otherwise move assets stored in that account elsewhere. When an app initially leverages account linking it creates the account instead of the user and is where that user's specific state is stored. At a later point, users can take ownership of the app account providing they possess a full [Flow account](../../basics/accounts.md), typically by installing a wallet app.

Account linking enables users to possess multiple linked child accounts from different apps. Complexities associated with accessing those child accounts are eliminated by abstracting access to them through the user's parent account. Simply put, child accounts are accessed and treated as a seamless part of the parent account.

All assets in the app account can now jump the walled garden to play in the rest of the Flow ecosystem. No transactions are needed to move assets from the child account to the parent account, as the parent account already has full access to the assets in the child account.

![Multiple parent-child accounts on Flow](resources/multiple-accounts.png)

This shared control over the digital items in the in-app account enables users to establish real ownership of the items beyond the context of the app, where they can use their parent account to view inventory, take the items to other apps in the ecosystem, such as a marketplace or a game.

Most importantly, users are able to do this without the need to transfer the digital items between accounts, making it seamless to continue using the original app while also using other apps.

## Security Considerations

Account linking is a _very_ powerful Cadence feature, and thus it must be treated with care. So far in this document, we’ve talked about account linking between two accounts we own, even if the child account is managed by a third-party application. But, we can't make the same trust assumptions about custodial accounts in the real world.

Creating an `AuthAccount` capability and publishing it to an account we don’t own means we are giving that account full access to our account. This should be seen as an anti-pattern.

<Callout type="warning">
❗ Creating an `AuthAccount` capability and sharing it with third-party account is in concept the same as giving that person your account's private keys.

</Callout>

Because pure account linking can be dangerous, Flow introduces the [`HybridCustody` contract](./parent-accounts.md) that helps custodial applications regulate access and parent account manage their many child accounts.

## Hybrid Custody and Account Linking

Apps need assurances that their own resources are safe from malicious actors, so giving out full access might not be the form they want. Using hybrid custody contracts, the app still maintains control of their managed accounts, but they can:

1. Share capabilities freely, with a few built-in controls over the types of capabilities that can be retrieved by parent accounts via helper contracts (the `CapabilityFactory`, and `CapabilityFilter`)
2. Share additional capabilities (public or private) with a parent account via a `CapabilityDelegator` resource

Learn more about it in the [Hybrid Custody documentation](./parent-accounts.md).

### Guides[](https://developers.flow.com/concepts/account-linking#guides)

- [Building Walletless Applications Using Child Accounts](https://developers.flow.com/concepts/account-linking/child-accounts) covers how apps can leverage Account Linking to create a seamless user experience and enable future self-custody.
- [Working With Parent Accounts](https://developers.flow.com/concepts/account-linking/parent-accounts) covers features enabled by the core `HybridCustody` contract to access child account assets from parent accounts. This is useful for apps like marketplaces or wallets that are working with accounts that have potential child accounts.

### Resources[](https://developers.flow.com/concepts/account-linking#resources)

- [Forum Post](https://forum.onflow.org/t/hybrid-custody/4016) where core concepts were introduced and discussed.
- [GitHub repository](https://github.com/onflow/hybrid-custody) where `HybridCustody` core contract is maintained. Check out the repository for more advanced script or transaction examples.
- [Example](https://github.com/jribbink/magic-link-hc-sample/) Account Linking project with [Magic](https://magic.link/).
- [Starter template](https://github.com/Niftory/niftory-samples/tree/main/walletless-onboarding) for [Niftory](https://niftory.com/) Account Linking API.
- [Scaffold](https://github.com/onflow/hybrid-custody-scaffold) to start a new Account Linking project. Check out Flow CLI [Scaffolds](https://developers.flow.com/tooling/flow-cli/super-commands#using-scaffolds) to get started.
- [Wallet API](https://github.com/flow-hydraulics/flow-wallet-api/) is a microservice that enables apps to custody accounts. This is useful if you don't want to use a third-party service to manage user accounts.
- [Walletless Arcade](https://github.com/onflow/walletless-arcade-example) example demonstrates Account Linking with a local key management solution.---
title: Working With Parent Accounts
sidebar_position: 2
---

In this doc, we'll continue from the perspective of a wallet or marketplace app seeking to facilitate a unified account experience,
abstracting away the partitioned access between accounts into a single dashboard for user interactions on all their
owned assets.

## Objectives

- Understand the Hybrid Custody account model
- Differentiate between restricted child accounts and unrestricted owned accounts
- Get your app to recognize “parent” accounts along with any associated “child” accounts
- View Fungible and NonFungible Token metadata relating to assets across all of a user's associated accounts - their
  wallet-mediated “parent” account and any hybrid custody model “child” accounts
- Facilitate transactions acting on assets in child accounts

## Design Overview

<Callout type="info">

TL;DR: An account's [`HybridCustody.Manager`](https://github.com/onflow/hybrid-custody/blob/main/contracts/HybridCustody.cdc)
is the entry point for all of a user's associated accounts.

</Callout>

The basic idea in the [(currently proposed)
standard](https://forum.onflow.org/t/account-linking-authaccount-capabilities-management/4314) is relatively simple. A
parent account is one that has received delegated (albeit restricted) access on another account. The account which has
delegated authority over itself to the parent account is the child account.

In the [Hybrid Custody Model](https://forum.onflow.org/t/hybrid-custody/4016), this child account would have shared
access between the app - the entity which created likely custodies the account - and the linked parent account.

How does this delegation occur? Typically when we think of shared account access in crypto, we think keys. However,
Cadence enables [accounts to link Capabilities to themselves](https://github.com/onflow/cadence/issues/2151) and issue
those Capabilities to other parties (more on [capability-based access
here](https://developers.flow.com/cadence/language/capabilities.md)).

We've leveraged this feature in a (proposed) standard so that apps can implement a hybrid custody model whereby the
app creates an account it controls, then later delegates access on that account to the user once they've authenticated
with their wallet.

All related constructs are used together in the [`HybridCustody`
contract](https://testnet.contractbrowser.com/A.96b15ff6dfde11fe.HybridCustody) to define the standard.

Parent accounts own a `Manager` resource which stores Capabilities to `ChildAccount` (restricted access) and
`OwnedAccount` (unrestricted access) resources, both of which are stored in any given child account.

Therefore, the presence of a `Manager` in an account implies there are potentially associated accounts for which the
owning account has delegated access. This resource is intended to be configured with a public Capability that enables
querying of an account's child account addresses via `getAccountAddresses()` and `getOwnedAccountAddresses()`.As you
can deduce from these two methods, there is a notion of "owned" accounts which we'll expand on in a bit.

A wallet or marketplace wishing to discover all of a user's accounts and assets within them can do so by first looking
to the user's `Manager`.

### Identifying Account Hierarchy

To clarify, insofar as the standard is concerned, an account is a parent account if it contains a `Manager` resource,
and an account is a child account if it contains at minimum an `OwnedAccount` or additionally a `ChildAccount` resource.

Within a user's `Manager`, its mapping of `childAccounts` points to the addresses of its child accounts in each index,
with corresponding values giving the Manager access to those accounts via corresponding`ChildAccount` Capability.

![HybridCustody Conceptual Overview](./resources/hybrid_custody_conceptual_overview.png)

Likewise, the child account's `ChildAccount.parentAddress` (which owns a `Manager`) points to the user's account as its
parent address. This makes it easy to both identify whether an account is a parent, child, or both, and its associated
parent/child account(s).

`OwnedAccount` resources underly all account delegations, so can have multiple parents whereas `ChildAccount`s are 1:1.
This provides more granular revocation as each parent account has its own Capability path on which its access relies.

#### Restricted vs. Owned Accounts

It's worth noting here that `ChildAccount` Capabilities enable access to the underlying account according to rules
configured by the child account delegating access. The `ChildAccount` maintains these rules along with an `OwnedAccount`
Capability within which the `AuthAccount` Capability is stored. Anyone with access to the surface level `ChildAccount`
can then access the underlying `AuthAccount`, but only according the pre-defined rule set. These rules are fundamentally
a list of Types that can/cannot be retrieved from an account.

The app developer can codify these rule sets on allowable Capability types in a
[`CapabilityFilter`](https://testnet.contractbrowser.com/A.96b15ff6dfde11fe.CapabilityFilter) along with a
[`CapabilityFactory`](https://testnet.contractbrowser.com/A.96b15ff6dfde11fe.CapabilityFactory) defining retrieval
patterns for those Capabilities. When delegation occurs, the developer would provide the `CapabilityFilter` and
`CapabilityFactory` Capabilities to an `OwnedAccount` resource which stores them in a `ChildAccount` resource.  Then,
capabilities are created for the `OwnedAccount` and `ChildAccount` resource and are given to the specified parent
account.

So, if an app developer wants to enable Hybrid Custody but doesn't want to allow parent accounts to access FungibleToken
Vaults, for example, the app developer can codify rule sets enumerating allowable Capability types in a
`CapabilityFilter` along with a `CapabilityFactory` defining retrieval patterns for those Capabilities.

When delegation occurs, they would provide the `CapabilityFilter` and `CapabilityFactory` Capabilities to an
`OwnedAccount`. This `OwnedAccount` then wraps the given filter & factory Capabilities in a `ChildAccount` along with a
Capability to itself before publishing the new `ChildAccount` Capability for the specified parent account to claim.

<Callout type="info">

Note that by enumerating allowable Types in your `CapabilityFilter.Filter` implementation, you're by default excluding
access to anything other than the Types you declare as allowable.

</Callout>

As mentioned earlier, `Manager`s also maintain access to "owned" accounts - accounts which define unrestricted access as
they allow direct retrieval of encapsulated AuthAccount objects. These owned accounts, found in `Manager.ownedAccounts`,
are simply `OwnedAccount` Capabilities instead of `ChildAccount` Capabilities.

![HybridCustody Total Overview](./resources/hybrid_custody_low_level.png)


### Considerations

Do note that this construction does not prevent an account from having multiple parent accounts or a child account from
being the parent to other accounts. While initial intuition might lead one to believe that account associations are a
tree with the user at the root, the graph of associated accounts among child accounts may lead to cycles of association.

We believe it would be unlikely for a use case to demand a user delegates authority over their main account (in fact
we'd discourage such constructions), but delegating access between child accounts could be useful. As an example,
consider a set of local game clients across mobile and web platforms, each with self-custodied app accounts having
delegated authority to each other while both are child accounts of the user's main account.

Ultimately, it will be up to the implementing wallet/marketplace how far down the graph of account associations they'd
want to traverse and display to the user.

## Implementation

From the perspective of a wallet or marketplace app, some relevant things to know about the user are:

- Does this account have associated linked (child) accounts?
- What are those associated linked accounts, if any?
- What NFTs are owned by this user across all associated accounts?
- What are the balances of all FungibleTokens across all associated accounts?

And with respect to acting on the assets of child accounts and managing child accounts themselves:

- Accessing an NFT from a linked account's Collection
- Removing a linked account

## Examples

### Query Whether an Address Has Associated Accounts

This script will return `true` if a `HybridCustody.Manager` is stored and `false` otherwise

```cadence get_child_addresses.cdc
import "HybridCustody"

pub fun main(parent: Address): Bool {
    let acct = getAuthAccount(parent)
    if let manager = acct.borrow<&HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath) {
        return manager.getChildAddresses().length > 0
    }
    return false
}
```

### Query All Accounts Associated with Address

The following script will return an array of addresses associated with a given account's address, inclusive of the
provided address.

```cadence get_child_addresses.cdc
import "HybridCustody"

pub fun main(parent: Address): [Address] {
    let acct = getAuthAccount(parent)
    let manager = acct.borrow<&HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
        ?? panic("manager not found")
    return manager.getChildAddresses() // Could also call getOwnedAddresses() for owned account addresses
}
```

### Query All Owned NFT Metadata

While it is possible to iterate over the storage of all associated accounts in a single script, memory limits prevent
this approach from scaling well.

Since some accounts hold thousands of NFTs, we recommend breaking up iteration, utilizing several queries to iterate
over accounts and the storage of each account. Batching queries on individual accounts may even be required based on the
number of NFTs held.

1. Get all associated account addresses (see above)
2. Looping over each associated account address client-side, get each address's owned NFT metadata

For simplicity, we'll show a condensed query, returning NFT display views from all accounts associated with a given
address for a specified NFT Collection path.

```cadence get_nft_display_view_from_public.cdc
import "NonFungibleToken"
import "MetadataViews"
import "HybridCustody"

/// Returns resolved Display from given address at specified path for each ID or nil if ResolverCollection is not found
///
pub fun getViews(_ address: Address, _ resolverCollectionPath: PublicPath): {UInt64: MetadataViews.Display} {

    let account: PublicAccount = getAccount(address)
    let views: {UInt64: MetadataViews.Display} = {}

    // Borrow the Collection
    if let collection = account
        .getCapability<&{NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}>(resolverCollectionPath).borrow() {
        // Iterate over IDs & resolve the view
        for id in collection.getIDs() {
            if let display = collection.borrowViewResolver(id: id).resolveView(Type<MetadataViews.Display>()) as? MetadataViews.Display {
                views.insert(key: id, display)
            }
        }
    }

    return views
}

/// Queries for MetadataViews.Display each NFT across all associated accounts from Collections at the provided
/// PublicPath
///
pub fun main(address: Address, resolverCollectionPath: PublicPath): {Address: {UInt64: MetadataViews.Display}} {

    let allViews: {Address: {UInt64: MetadataViews.Display}} = {address: getViews(address, resolverCollectionPath)}
    let seen: [Address] = [address]

    /* Iterate over any associated accounts */
    //
    if let managerRef = getAuthAccount(address).borrow<&HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath) {

        for childAccount in managerRef.getChildAddresses() {
            allViews.insert(key: childAccount, getViews(address, resolverCollectionPath))
            seen.append(childAccount)
        }

        for ownedAccount in managerRef.getOwnedAddresses() {
            if seen.contains(ownedAccount) == false {
                allViews.insert(key: ownedAccount, getViews(address, resolverCollectionPath))
                seen.append(ownedAccount)
            }
        }
    }

    return allViews
}
```

At the end of this query, the caller will have a mapping of `Display` views indexed on the NFT ID and grouped by account
Address. Note that this script does not take batching into consideration and assumes that each NFT resolves the
`MetadataViews.Display` view type.

### Query All Account FungibleToken Balances

Similar to the previous example, we recommend breaking up this task due to memory limits.

1. Get all linked account addresses (see above)
2. Looping over each associated account address client-side, get each address's owned FungibleToken Vault metadata

However, we'll condense both of these steps down into one script for simplicity:

```cadence get_all_vault_bal_from_storage.cdc
import "FungibleToken"
import "MetadataViews"
import "HybridCustody"

/// Returns a mapping of balances indexed on the Type of resource containing the balance
///
pub fun getAllBalancesInStorage(_ address: Address): {Type: UFix64} {
    // Get the account
    let account: AuthAccount = getAuthAccount(address)
    // Init for return value
    let balances: {Type: UFix64} = {}
    // Track seen Types in array
    let seen: [Type] = []
    // Assign the type we'll need
    let balanceType: Type = Type<@{FungibleToken.Balance}>()
    // Iterate over all stored items & get the path if the type is what we're looking for
    account.forEachStored(fun (path: StoragePath, type: Type): Bool {
        if type.isInstance(balanceType) || type.isSubtype(of: balanceType) {
            // Get a reference to the resource & its balance
            let vaultRef = account.borrow<&{FungibleToken.Balance}>(from: path)!
            // Insert a new values if it's the first time we've seen the type
            if !seen.contains(type) {
                balances.insert(key: type, vaultRef.balance)
            } else {
                // Otherwise just update the balance of the vault (unlikely we'll see the same type twice in
                // the same account, but we want to cover the case)
                balances[type] = balances[type]! + vaultRef.balance
            }
        }
        return true
    })
    return balances
}

/// Queries for FT.Vault balance of all FT.Vaults in the specified account and all of its associated accounts
///
pub fun main(address: Address): {Address: {Type: UFix64}} {

    // Get the balance for the given address
    let balances: {Address: {Type: UFix64}} = { address: getAllBalancesInStorage(address) }
    // Tracking Addresses we've come across to prevent overwriting balances (more efficient than checking dict entries (?))
    let seen: [Address] = [address]

    /* Iterate over any associated accounts */
    //
    if let managerRef = getAuthAccount(address)
        .borrow<&HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath) {

        for childAccount in managerRef.getChildAddresses() {
            balances.insert(key: childAccount, getAllBalancesInStorage(address))
            seen.append(childAccount)
        }

        for ownedAccount in managerRef.getOwnedAddresses() {
            if seen.contains(ownedAccount) == false {
                balances.insert(key: ownedAccount, getAllBalancesInStorage(address))
                seen.append(ownedAccount)
            }
        }
    }

    return balances
}
```

The above script returns a dictionary of balances indexed on the type and further grouped by account Address.

The returned data at the end of address iteration should be sufficient to achieve a unified balance of all Vaults of
similar types across all of a user's associated account as well as a more granular per account view.

You might consider resolving
[`FungibleTokenMetadataViews`](https://github.com/onflow/flow-ft/blob/master/contracts/FungibleTokenMetadataViews.cdc)
to aggregate more information about the underlying Vaults.

### Access NFT in Child Account from Parent Account

A user with NFTs in their child accounts will likely want to utilize said NFTs. In this example, the user will sign a
transaction a transaction with their authenticated account that retrieves a reference to a child account's
`NonFungibleToken.Provider`, enabling withdrawal from the child account having signed with the parent account.

```cadence withdraw_nft_from_child.cdc
import "NonFungibleToken"
import "FlowToken"
import "HybridCustody"

transaction(childAddress: Address, providerPath: PrivatePath, withdrawID: UInt64) {

    let providerRef: &{NonFungibleToken.Provider}

    prepare(signer: AuthAccount) {
        // Get a reference to the signer's HybridCustody.Manager from storage
        let managerRef: &HybridCustody.Manager = signer.borrow<&HybridCustody.Manager>(
                from: HybridCustody.ManagerStoragePath
            ) ?? panic("Could not borrow reference to HybridCustody.Manager in signer's account at expected path!")

        // Borrow a reference to the signer's specified child account
        let account: &{AccountPrivate, AccountPublic, MetadataViews.Resolver}? = managerRef
            .borrowAccount(addr: childAddress)
            ?? panic("Signer does not have access to specified child account")

        // Get a reference to the child NFT Provider and assign to the transaction scope variable
        let cap: Capability = account.getCapability(
                path: providerPath,
                type: Type<&{NonFungibleToken.Provider}>()
            ) ?? panic("Cannot access NonFungibleToken.Provider from this child account")

        // We'll need to cast the Capability - this is possible thanks to CapabilityFactory, though we'll rely on the relevant
        // Factory having been configured for this Type or it won't be castable
        self.providerRef = cap as! Capability<&{NonFungibleToken.Provider}>
    }

    execute {
        // Withdraw the NFT from the Collection
        let nft <- self.providerRef.withdraw(withdrawID: withdrawID)
        // Do stuff with the NFT
        // ...
    }
}

```

At the end of this transaction, you withdrew an NFT from the specified account using an NFT `Provider` Capability. A
similar approach could get you any allowable Capabilities from a signer's child account.

### Revoking Secondary Access on a Linked Account

The expected uses of child accounts for progressive onboarding implies that they will be accounts with shared access. A
user may decide that they no longer want secondary parties to have access to the child account.

There are two ways a party can have delegated access to an account - keys and AuthAccount Capability. With
`ChildAccount` mediated access, a user wouldn't be able to revoke anyone's access except for their own. With
unrestricted access via `OwnedAccount`, one could remove parents (`OwnedAccount.removeParent(parent: Address)`) thereby
unlinking relevant Capabilities and further destroying their `ChildAccount` and `CapabilityDelegator` resources.

Ultimately, things are not entirely straightforward with respect to `AuthAccount` Capabilities, at least not until
Capability Controllers enter the picture. This is discussed in more detail in [the
Flip](https://forum.onflow.org/t/account-linking-authaccount-capabilities-management/4314). For now, we recommend that
if users want to revoke secondary access, they transfer any assets from the relevant child account and remove it from
their `Manager` altogether.

### Remove a Child Account

As mentioned above, if a user no longer wishes to share access with another party, it's recommended that desired assets
be transferred from that account to either their main account or other linked accounts and the linked account be removed
from their `HybridCustody.Manager`. Let's see how to complete that removal.

```cadence remove_child_account.cdc
import "HybridCustody"

transaction(child: Address) {
    prepare (acct: AuthAccount) {
        let manager = acct.borrow<&HybridCustody.Manager>(from: HybridCustody.ManagerStoragePath)
            ?? panic("manager not found")
        manager.removeChild(addr: child)
    }
}
```

After removal, the signer no longer has delegated access to the removed account via their `Manager` and the caller is
removed as a parent of the removed child.

Note also that it's possible for a child account to remove a parent. This is necessary to give application developers
and ultimately the owners of these child accounts the ability to revoke secondary access on owned accounts.
---
sidebar_position: 3
---

# FLIX (FLIP 934)

This FLIP (Flow Improvement Proposal) proposes a new standard for how contract developers, wallets, users, auditors, and applications can create, audit, and verify the intent, security, and metadata of Flow scripts and transactions, with the goal to improve the understandability and security of authorizing transactions and promote patterns for change resilient composability of applications on Flow.

FLIX provides a way to reuse scripts and transactions as well as to provide more metadata about the scripts themselves, such as a human-readable description of what the transaction or script will do, which can be used by the developer as well as the user of the dApp. 

By using FLIX transactions and scripts we don’t have to write our own for common operations. Many interactions aim to achieve the same class of action according to how that action must be performed with a certain project. Classes of interactions may be things like: "Transfer", "Mint", "Bid", "List", "Destroy" etc.

[**FLIX was defined as part of the FLIP 934**](https://github.com/onflow/flips/blob/main/application/20220503-interaction-templates.md)

## Running FLIX

Flow provides an implementation of the Flow interaction template service as an open-source project. This gives developers a way to obtain current transactions and scripts as well as extend on the collection. You can find the repository here: https://github.com/onflow/flow-interaction-template-service

### Clients

There are currently two clients integrating FLIX APIs you can use in your code. 
**Go client** [https://github.com/onflow/flixkit-go](https://github.com/onflow/flixkit-go)

**FCL client you** read how to get started [tools/clients/fcl-js/interaction-templates](../../tools/clients/fcl-js/interaction-templates.mdx)
---
title: Flow Verifiable Random Function (VRF)
sidebar_label: Flow VRF
---

# Flow Verifiable Random Function (VRF)

Flow enhances blockchain functionality and eliminates reliance on external oracles by providing native onchain randomness at the protocol level. This secure, decentralized feature empowers developers to build a variety of applications with truly unpredictable, transparent, and fair outcomes, achieved with greater efficiency.

Flow’s onchain randomness delivers immediate random values within smart contracts, bypassing the latency and complexity of oracle integration. Developers can obtain verifiably random results with a single line of Cadence code, streamlining the development process and enhancing the performance of decentralized applications.

## Use Cases of Onchain Randomness

- **Gaming:** Integrates fairness and unpredictability into gameplay, enhancing user engagement without delays.
- **NFTs:** Facilitates the creation of uniquely randomized traits in NFTs quickly, adding to their rarity and value.
- **Lotteries & Draws:** Offers instant and verifiably fair random selection for lotteries, solidifying trust in real-time.
- **DeFi Protocols:** Enables rapid and innovative random reward systems within decentralized finance.
- **DAOs:** Assists in unbiased voting and task assignments through immediate randomness.
- **Broad Applications:** Extends to any domain requiring impartial randomization, from asset distribution to security mechanisms, all with the added benefit of on-demand availability.

## History of the Distributed Random Beacon

Within the Flow protocol, the heart of randomness generation lies in the "Distributed Random Beacon." 
This module generates randomness that is distributed across the network while adhering to established cryptographic and security standards. 
The output from the randomness beacon is a sequence of random bytes that are unpredictable and impartial.

For over three years, the beacon has ensured protocol security by selecting which consensus node gets to propose the next block and assigning verification nodes to oversee block computations. For those interested in a more detailed exploration of the randomness beacon and its inner workings, you can read [the technical deep dive on the Flow forum](https://forum.flow.com/t/secure-random-number-generator-for-flow-s-smart-contracts/5110).

### The History and Limitations of `unsafeRandom` (Now Deprecated)

Cadence has historically provided the `unsafeRandom` function to return a pseudo-random number. The stream of random numbers produced was potentially unsafe in the following two regards:

1. The sequence of random numbers is potentially predictable by transactions within the same block and by other smart contracts calling into your smart contract.
2. A transaction calling into your smart contract can potentially bias the sequence of random numbers which your smart contract internally generates. Currently, the block hash seeds `unsafeRandom`. Consensus nodes can *easily* bias the block hash and **influence the seed for `unsafeRandom`**.

<Callout type="warning">
⚠️ Note `unsafeRandom` will be deprecated in the next Cadence release. **Developers are advised to refrain from using `unsafeRandom.`**
</Callout>

## Guidelines for Safe Usage

For usage of randomness where result abortion is not an issue, it is recommended to use the Cadence built-in function `revertibleRandom.` `revertibleRandom` returns a pseudo-random number and is also based on the Distributed Random Beacon.

```cadence
// Language reference:
// https://developers.flow.com/cadence/language/built-in-functions#revertiblerandom
// Run the snippet here: https://academy.ecdao.org/en/snippets/cadence-random
access(all) fun main(): UInt64 {
	// Simple assignment using revertibleRandom - keep reading docs for safe usage!	
	let rand: UInt64 = revertibleRandom()
	return rand
}
```

It is notable that the random number generation process is unpredictable (for miners unpredictable at block construction time and for cadence logic unpredictable at time of call), verifiable, uniform, as well as safe from bias by miners and previously-running Cadence code.

Although Cadence exposes safe randomness generated by the Flow protocol via `revertibleRandom`, there is an additional safety-relevant aspect that developers need to be mindful about.

The `revertibleRandom` function can be used safely in some applications where the transaction results are _not_ deliberately reverted after the random number is revealed (i.e. a contract distributing random NFTs to registered users or onchain lucky draw).
However, if applications require a non-trusted party (for instance app users) to submit a transaction calling a randomized (non-deterministic) contract, the developer must explicitly protect the stream of random numbers to not break the security guarantees:

<Callout type="warning">
🚨 A transaction can atomically revert all its action during its runtime and abort. Therefore, it is possible for a transaction calling into your smart contract to post-select favorable results and revert the transaction for unfavorable results.
</Callout>

In other words, transactions submitted by a non-trusted party are able to reject their results after the random is revealed.

<Callout type="info">
💡 **Post-selection** - the ability for transactions to reject results they don't like - is inherent to any smart contract platform that allows transactions to roll back atomically. See this very similar [Ethereum example](https://consensys.github.io/smart-contract-best-practices/development-recommendations/general/public-data/).
</Callout>

The central aspect that a contract developer needs to think about is the following scenario:

- Imagine an adversarial user that is sending a transaction that calls your smart contract.
- The transaction includes code that runs after your smart contract returns and inspects the outcome.
- If the outcome is unfavorable (based on some criteria codified in the transaction), the transaction aborts itself.

As an example, consider a simple coin toss randomized contract where users can bet any amount of tokens against a random binary output. If the coin toss contract outputs `1`, the user doubles their bet. If the coin toss contract outputs `0`, the user loses their bet in favor of the coin toss.

Although the user (or the honest coin toss contract) cannot predict or bias the outcome, the user transaction can check the randomized result and cancel the transaction if they are losing their bet. This can be done by calling an exception causing the transaction to error. All temporary state changes are cancelled and the user can repeat the process till they double their bet.

## Commit-Reveal Scheme

The recommended way to mitigate the problems above is via a commit-reveal scheme. The scheme involves two steps: commit and reveal. During the commit phase, the user transaction commits to accepting the future output of a smart contract where the last remaining input is an unknown stream of random numbers. The smart contract stores this commitment on the blockchain. At the current level of optimization, the reveal phase can start as early as the next block, when the beacon's source of randomness becomes available. With a second transaction, the smart contract can be executed to explicitly generate the output now that the stream of random numbers can be seeded (plus suitable salt).

There are ideas how to further optimize the developer experience in the future. For example, a transaction could delegate part of its gas to an independent transaction it spawns. Conceptually, also this future solution would be a commit-and-reveal scheme, just immediately happening within the same block. Until we eventually get to this next level, developers may need to implement their own commit-reveal. In Cadence, it is clean and short.

Protocol improvements (documented in [FLIP 120](https://github.com/onflow/flips/blob/main/cadence/20230713-random-function.md))
expose the random beacon to the FVM and Cadence where it can be used to seed pseudo-random number generators [PRNGs] for smart contracts.

While both are backed by Flow's Random Beacon it is important for developers to mindfully choose between `revertibleRandom` or
seeding their own PRNG utilizing the `RandomBeaconHistory` smart contract:

- Under the hood, the FVM also just instantiates a PRNG for each transaction that `revertibleRandom` draws from.
  Though, with `revertibleRandom` a developer is calling the PRNG that is controlled by the transaction,
  which also has the power to abort and revert if it doesn't like `revertibleRandom`'s outputs.
  `revertibleRandom` is only suitable for smart contract functions that exclusively run within the trusted transactions.
- In contrast, using the `RandomBeaconHistory` means to use a deterministically-seeded PRNG.
  The `RandomBeaconHistory` is key for effectively implementing a commit-and-reveal scheme.
  During the commit phase, the user commits to proceed with a future source of randomness,
  which is revealed after the commit transaction concluded.
  For each block, the `RandomBeaconHistory` automatically stores the subsequently generated source of randomness.

Adding a safe pattern to reveal randomness without the possibility of conditional transaction reversion unlocks applications relying on randomness. By providing examples of commit-reveal implementations we hope to foster a more secure ecosystem of decentralized applications and encourage developers to build with best practices.

In simpler terms, the native secure randomness provided by the protocol can now be safely utilized within Cadence smart contracts
and is available to all developers on Flow and the FVM.

## FLIP 123

On Flow, we have absorbed all security complexity into the platform.

[FLIP 123: On-chain Random beacon history for commit-reveal schemes](https://github.com/onflow/flips/blob/main/protocol/20230728-commit-reveal.md#flip-123-on-chain-random-beacon-history-for-commit-reveal-schemes) was introduced to provide a safe pattern to use randomness in transactions so that it's not possible to revert unfavorable randomized transaction results.
We recommend this approach as a best-practice example for implementing a commit-reveal-recover scheme in Cadence. The `RandomBeaconHistory` contract provides a convenient archive, where for each past block height (starting Nov 2023) the respective “source of randomness” can be retrieved. The `RandomBeaconHistory` contract is automatically executed by the system at each block to store the next source of randomness value.

<Callout type="info">
💡 While the commit-and-reveal scheme mitigates post-selection of results by adversarial clients, Flow’s secure randomness additionally protects against any pre-selection vulnerabilities (like biasing attacks by byzantine miners).
</Callout>

A commit-reveal scheme can be implemented as follows. The coin toss example described earlier will be used for illustration:

- When a user submits a bidding transaction, the bid amount is transferred to the coin toss contract, and the block height where the bid was made is stored. This is a commitment by the user to use the SoR at the current block. Note that the current block's `SoR_A` isn't known to the transaction execution environment, and therefore the transaction has no way to inspect the random outcome and predict the coin toss result. The current block's `SoR_A` is only available once added to the history core-contract, which only happens at the end of the block's execution. The user may also commit to using an SoR of some future block, which is equally unknown at the time the bid is made.
- The coin toss contract may grant the user a limited window of time (i.e a block height range) to send a second transaction for resolving the results and claim any winnings. Failing to do so, the bid amount remains in the coin toss contract.
- Within that reveal transaction, the user calls the coin toss contract, looks us up the block height at which the block was committed and checks that it has already passed. The contract queries that block's `SoR_A` from the core-contract `RandomBeaconHistory` via block height.
- The coin toss contract uses a PRG seeded with the queried `SoR_A` and diversified using a specific information to the use-case (a user ID or resource ID for instance). Diversification does not add new entropy, but it avoids generating the same outcome for different use-cases. If a diversifier (or salt) isn't used, all users that committed a bid on the same block would either win or lose.
- The PRG is used to generate the random result and resolve the bid. Note that the user can make the transaction abort after inspecting a losing result. However, the bid amount would be lost anyway when the allocated window expires.

The following lines of code illustrate a random coin toss that cannot be gamed or biased. The reveal-and-commit scheme prevent clients from post-selecting favorable outcomes.

```cadence
// The code below is taken from the example CoinToss contract found in this project repo
// Source: https://github.com/onflow/random-coin-toss 

/// --- Commit ---
/// In this method, the caller commits a bet. The contract takes note of the
/// block height and bet amount, returning a Receipt resource which is used
/// by the better to reveal the coin toss result and determine their winnings.
access(all) fun commitCoinToss(bet: @FungibleToken.Vault): @Receipt {
    let receipt <- create Receipt(
            betAmount: bet.balance
        )
    // commit the bet
    // `self.reserve` is a `@FungibleToken.Vault` field defined on the app contract
    //  and represents a pool of funds
    self.reserve.deposit(from: <-bet)
    
    emit CoinTossBet(betAmount: receipt.betAmount, commitBlock: receipt.commitBlock, receiptID: receipt.uuid)
    
    return <- receipt
}

/// --- Reveal ---
/// Here the caller provides the Receipt given to them at commitment. The contract
/// then "flips a coin" with randomCoin(), providing the committed block height
/// and salting with the Receipts unique identifier.
/// If result is 1, user loses, if it's 0 the user doubles their bet.
/// Note that the caller could condition the revealing transaction, but they've
/// already provided their bet amount so there's no loss for the contract if
/// they do
access(all) fun revealCoinToss(receipt: @Receipt): @FungibleToken.Vault {
    pre {
        receipt.commitBlock <= getCurrentBlock().height: "Cannot reveal before commit block"
    }

    let betAmount = receipt.betAmount
    let commitBlock = receipt.commitBlock
    let receiptID = receipt.uuid
		// self.randomCoin() errors if commitBlock <= current block height in call to
		// RandomBeaconHistory.sourceOfRandomness()
    let coin = self.randomCoin(atBlockHeight: receipt.commitBlock, salt: receipt.uuid)

    destroy receipt

    if coin == 1 {
        emit CoinTossReveal(betAmount: betAmount, winningAmount: 0.0, commitBlock: commitBlock, receiptID: receiptID)
        return <- FlowToken.createEmptyVault()
    }
    
    let reward <- self.reserve.withdraw(amount: betAmount * 2.0)
    
    emit CoinTossReveal(betAmount: betAmount, winningAmount: reward.balance, commitBlock: commitBlock, receiptID: receiptID)
    
    return <- reward
}
```

## An Invitation to Build

Flow's onchain randomness opens new doors for innovation in web3, offering developers the tools to create fair and transparent decentralized applications. With this feature, new possibilities emerge—from enhancing gameplay in decentralized gaming to ensuring the integrity of smart contract-driven lotteries or introducing novel mechanisms in DeFi. 

This is an invitation for builders and creators: leverage Flow's onchain randomness to distinguish your projects and push the boundaries of what's possible. Your imagination and code have the potential to forge new paths in the web3 landscape. So go ahead and build; the community awaits the next big thing that springs from true randomness.

## Learn More

If you’d like to dive deeper into Flow’s onchain randomness, here’s a list of resources:

- To learn more about how randomness works under the hood, see [the forum post](https://forum.flow.com/t/secure-random-number-generator-for-flow-s-smart-contracts/5110).
- These documents provide a more in-depth technical understanding of the updates and enhancements to the Flow blockchain.
    - **[FLIP 120: Update unsafeRandom function](https://github.com/onflow/flips/blob/main/cadence/20230713-random-function.md#flip-120-update-unsaferandom-function)**
    - **[FLIP 123: On-chain Random beacon history for commit-reveal schemes](https://github.com/onflow/flips/blob/main/protocol/20230728-commit-reveal.md#flip-123-on-chain-random-beacon-history-for-commit-reveal-schemes)**
- To see working Cadence code, explore the [coin toss example on GitHub](https://github.com/onflow/random-coin-toss/tree/update-prg-impl).---
title: Understanding Transaction Time
sidebar_label: Understanding Transaction Time
sidebar_position: 2
---

# Understanding Transaction Time

Understanding how transaction times work across different blockchains is crucial for developers and users to optimize their operations and expectations. Flow’s multi-node architecture allows for some of the fastest transaction times and finality times across chains. Read on for more detail on how it works and what it means for developers and users.

## Two Key Transaction Questions

Whenever a transaction is processed, two primary questions come to mind:

1. **Inclusion**: Will this transaction be included in the final chain?
2. **Result**: What is the outcome of the transaction?

Different blockchains tackle these questions in varied sequences. For instance, Bitcoin and Ethereum provide answers simultaneously. Layer 2 solutions (L2s) can sometimes address the outcome before confirming inclusion. But there's a catch: you can have an answer to those questions that might be wrong. Flow, on the other hand, prioritizes the inclusion question.

## **Transaction Finality Explained**

Drawing a parallel to traditional finance, a vendor might instantly know if Visa approves a transaction, but the possibility of chargebacks lingers for weeks. This uncertainty introduces the concept of "finality" in blockchain transactions.

In the dominant Proof-of-Stake (PoS) environment, which includes most chains except for Bitcoin, there are three key finality stages:

- **Preliminary result**: It's an initial answer to the aforementioned questions. The preliminary result doesn’t ensure correctness, and there are no economic penalties (like "slashing") if the informant provides false information.
- **Soft economic finality**: This stage provides an answer backed by cryptographic proof. If the informant is deceptive, they face economic repercussions or "slashing."
- **Hard economic finality**: The provided answer either holds true, or the entire blockchain requires a restart. The latter case sees at least one-third of the nodes facing economic penalties.

## Chain Comparisons

### Solana
Solana offers a preliminary result within approximately 100ms but takes around 30 seconds to achieve hard finality.

### Ethereum
Ethereum takes about 15 seconds to provide a preliminary result, reaching hard finality in approximately 15 minutes.

### Flow

Flow bypasses preliminary results entirely. It reaches soft finality ("Executed") in about 6 seconds and hard finality ("Sealed") in around 20 seconds. If an Access Node on Flow states a transaction has occurred, it's either correct or cryptographic proof exists that can lead to the node's slashing.

![transaction-time.png](./resources/chain-comparison.png)

## Efficiency + Speed + Finality

Many blockchains offer quick preliminary results before achieving hard finality. Flow's unique multi-node architecture ensures it can process and finalize transactions more efficiently than many other blockchains. By separating tasks among specialized nodes, Flow can achieve faster transaction times, reaching soft finality in mere seconds and hard finality shortly thereafter.---
sidebar_position: 2
---

# Accounts

An account on Flow is a record in the chain state that holds the following information:
- Address: unique identifier for the account
- Public Keys: public keys authorized on the account
- Code: Cadence contracts deployed to the account
- Storage: area of the account used to store resource assets.

Accounts and their keys are needed to sign transactions that change the Flow blockchain state. To execute a transaction, a small amount of Flow, called a [“Fee”](./fees.md) must be paid by the account or subsidized by a wallet or service. Flow allocates a fixed amount of storage to each account for saving data structures and Resources. Flow allocates a [fixed amount of storage](./fees.md#storage) to each account for saving data structures and Resources.
An account may also contain contract code which transactions and scripts can interact with to query or mutate the state of the blockchain.

A simple representation of an account:

![Screenshot 2023-08-16 at 16.43.07.png](_accounts_images/Screenshot_2023-08-16_at_16.43.07.png)

**Address**

A Flow address is represented as 16 hex-encoded characters (usually prefixed with `0x` to indicate hex encoding). Unlike Bitcoin and Ethereum, Flow addresses are not derived from cryptographic public keys. Instead, each Flow address is assigned by the Flow protocol using an on-chain deterministic sequence. The sequence uses an error detection code to guarantee that all addresses differ with at least 2 hex characters. This makes typos resulting in accidental loss of assets not possible.

This decoupling is a unique advantage of Flow, allowing for multiple public keys to be associated with one account, or for a single public key to be used across several accounts.

**Balance**

Each Flow account created on Mainnet will by default [hold a Flow vault that holds a balance and is part of the FungibleToken standard](./flow-token.md). This balance is used to pay for [transaction fees and storage fees](./fees.md). More on that in the fees document.

<Callout type="warning">
The minimum amount of FLOW an account can have is **0.001**.
</Callout>

This minimum storage fee is provided by the account creator and covers the cost of storing up to 100kB of data in perpetuity. This fee is applied only once and can be "topped up" to add additional storage to an account. The minimum account reservation ensures that most accounts won't run out of storage capacity if anyone deposits anything (like an NFT) to the account. 

**Contracts**

An account can optionally store multiple [Cadence contracts](https://cadence-lang.org/docs/language/contracts). The code is stored as a human-readable UTF-8 encoded string which makes it easy for anyone to inspect the contents.

**Storage**

Each Flow account has an associated storage and capacity. The account's storage used is the byte size of all the data stored in the account's storage. An account's [storage capacity is directly tied to the balance of Flow tokens](./fees.md#storage) an account has. An account can, without any additional cost, use any amount of storage up to its storage capacity. If a transaction puts an account over storage capacity or drops an account's balance below the minimum 0.001 Flow tokens, that transaction fails and is reverted.

## Account **Keys**

Flow accounts can be configured with multiple public keys that are used to control access. Owners of the associated private keys can sign transactions to mutate the account's state.

During account creation, public keys can be provided which will be used when interacting with the account. Account keys can be added, removed, or revoked by sending a transaction. This is radically different from blockchains like Ethereum where an account is tied to a single public/private key pair.

Each account key has a weight that determines the signing power it holds.

<Callout type="warning">
A transaction is not authorized to access an account unless it has a total signature weight greater than or equal to **1000**, the weight threshold.
</Callout>

For example, an account might contain 3 keys, each with 500 weight:

![Screenshot 2023-08-16 at 16.28.58.png](_accounts_images/Screenshot_2023-08-16_at_16.28.58.png)

This represents a 2-of-3 multi-sig quorum, in which a transaction is authorized to access the account if it receives signatures from *at least* 2 out of 3 keys.

An account key contains the following attributes:

- **ID** used to identify keys within an account
- **Public Key** raw public key (encoded as bytes)
- **Signature algorithm** (see below)
- **Hash algorithm** (see below)
- **Weight** integer between 0-1000
- **Revoked** whether the key has been revoked or it’s active
- **Sequence Number** is a number that increases with each submitted transaction signed by this key

### Signature and Hash Algorithms

The signature and hashing algorithms are used during the transaction signing process and can be set to certain predefined values.

There are two curves commonly used with the ECDSA algorithm, secp256r1 ([OID 1.2.840.10045.3.1.7](http://oid-info.com/get/1.2.840.10045.3.1.7), also called the "NIST P-256." this curve is common for mobile secure enclave support), and secp256k1 ([OID 1.3.132.0.10](http://oid-info.com/get/1.3.132.0.10), the curve used by "Bitcoin"). Please be sure to double-check which parameters you are using before registering a key, as presenting a key using one of the curves under the code and format of the other will generate an error.

| Algorithm | Curve     | ID              | Code |
| --------- | --------- | --------------- | ---- |
| ECDSA     | P-256     | ECDSA_P256      | 2    |
| ECDSA     | secp256k1 | ECDSA_secp256k1 | 3    |

*Please note that the codes listed here are for the signature algorithms as used by the node API, and they are different from the ones [defined in Cadence](https://cadence-lang.org/docs/language/crypto#signing-algorithms)*

| Algorithm | Output Size | ID       | Code |
| --------- | ----------- | -------- | ---- |
| SHA-2     | 256         | SHA2_256 | 1    |
| SHA-3     | 256         | SHA3_256 | 3    |

Both hashing and signature algorithms are compatible with each other, so you can freely choose from the set.

### **Locked / Keyless Accounts**

An account on Flow doesn’t require keys in order to exist, but this makes the account immutable since no transaction can be signed that can change the account. This can be useful if we want to freeze an account contract code and it elegantly solves the problem of having multiple account types (as that is the case for Ethereum).

![Screenshot 2023-08-16 at 18.59.10.png](_accounts_images/Screenshot_2023-08-16_at_18.59.10.png)

You can achieve keyless accounts by either removing an existing public key from an account signing with that same key and repeating that action until an account has no keys left, or you can create a new account that has no keys assigned. With account linking you can also have a child account that has no keys but is controlled by the parent.

<Callout type="danger">
Be careful when removing keys from an existing account, because once an account’s total key weights sum to less than 1000, it can no longer be modified.

</Callout>

### **Multi-Sig Accounts**

Creating a multi-signature account is easily done by managing the account keys and their corresponding weight. To repeat, in order to sign a transaction the keys used to sign it must have weights that sum up to at least 1000. Using this information we can easily see how we can achieve the following cases:

#### 2-of-3 multi-sig quorum

![Screenshot 2023-08-16 at 19.34.44.png](_accounts_images/Screenshot_2023-08-16_at_19.34.44.png)

#### 3-of-3 multi-sig quorum

![Screenshot 2023-08-16 at 19.34.55.png](_accounts_images/Screenshot_2023-08-16_at_19.34.55.png)

#### 1-of-2 signature

![Screenshot 2023-08-16 at 19.34.51.png](_accounts_images/Screenshot_2023-08-16_at_19.34.51.png)

### Key Format

We are supporting ECDSA with the curves `P-256` and `secp256k1`. For these curves, the public key is encoded into 64 bytes as `X||Y` where `||` is the concatenation operator.

- `X` is 32 bytes and is the big endian byte encoding of the `x`-coordinate of the public key padded to 32, i.e. `X=x_31||x_30||...||x_0` or `X = x_31*256^31 + ... + x_i*256^i + ... + x_0`.
- `Y` is 32 bytes and is the big endian byte encoding of the `y`-coordinate of the public key padded to 32, i.e. `Y=y_31||y_30||...||y_0` or `Y = y_31*256^31 + ... + y_i*256^i + ... + y_0`


## Account Creation

Accounts are created on the Flow blockchain by calling a special [create account Cadence function](https://cadence-lang.org/docs/language/accounts#account-creation). Once an account is created we can associate a new key with that account. Of course, all that can be done within a single transaction. Keep in mind that there is an account creation fee that needs to be paid. Account creation fees are relatively low, and we expect that wallet providers and exchanges will cover the cost when a user converts fiat to crypto for the first time.

For development purposes, [you can use Flow CLI to easily create emulator, testnet and mainnet accounts.](../../tools/flow-cli/accounts/create-accounts.md) The account creation fee is paid by a funding wallet so you don’t need a pre-existing account to create it.

### **Key Generation**

Keys should be generated in a secure manner. Depending on the purpose of the keys different levels of caution need to be taken.

<Callout type="warning">
Anyone obtaining access to a private key can modify the account the key is associated with (assuming it has enough weight). Be very careful how you store the keys.

</Callout>

For secure production keys, we suggest using key management services such as [Google key management](https://cloud.google.com/security-key-management) or [Amazon KMS](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Overview.Encryption.Keys.html), which are also supported by our CLI and SDKs. Those services are mostly great when integrated into your application. However, for personal use, you can securely use any [existing wallets](../../community-resources/wallets.md) as well as a [hardware Ledger wallet](../../community-resources/wallets.md).

## Service Accounts

### Flow Service Account
The Service Account is a special account in Flow that has special permissions to manage system contracts. It is able to mint tokens, set fees, and update network-level contracts.

### Tokens & Fees
The Service Account has administrator access to the FLOW token smart contract, so it has authorization to mint and burn tokens. It also has access to the transaction fee smart contract and can adjust the fees charged for transactions execution on Flow.

### Network Management
The Service Account administers other smart contracts that manage various aspects of the Flow network, such as epochs and (in the future) validator staking auctions.

### Governance
Besides its special permissions, the Service Account is an account like any other in Flow. During the early phases of Flow's development, the account will be controlled by keys held by Dapper Labs. As Flow matures, the service account will transition to being controlled by a smart contract governed by the Flow community.


## Accounts Retrieval

You can use the Flow CLI to get account data by running:

```sh
flow accounts get 0xf919ee77447b7497 -n mainnet
```

Find [more about the command in the CLI docs](../../tools/flow-cli/accounts/get-accounts.md).

Accounts can be obtained from the access node APIs, currently, there are two gRPC and REST APIs. You can find more information about them here:

**gRPC API** [building-on-flow/nodes/access-api#accounts](../../references/run-and-secure/nodes/access-api.mdx#accounts)

**REST API** [http-api#tag/Accounts](/http-api#tag/Accounts)

There are multiple SDKs implementing the above APIs for different languages:

**Javascript SDK** [tools/clients/fcl-js](../../tools/clients/fcl-js/index.md)

**Go SDK** [tools/clients/flow-go-sdk](../../tools/clients/flow-go-sdk/index.mdx)

Find a list of all SDKs here: [tools/clients](../../tools/clients/index.md)
---
sidebar_position: 1
---

# Blocks

## Overview

Blocks are entities that make up the Flow blockchain. Each block contains a list of [transactions](./transactions.md) that were executed and as a result, changed the global blockchain state. Each block is identified by a unique ID which is a cryptographic hash of the block contents. Block also includes a link to the parent block ID creating a linked list of blocks called the Flow blockchain. 

The unique block ID serves as proof of the block contents which can be independently validated by any observer. Interesting cryptographic properties of the hash that make up the block ID guarantee that if any change is made to the block data it would produce a different hash and because blocks are linked, a different hash would break the link as it would no longer be referenced in the next block.

A very basic representation of blocks is:

![Screenshot 2023-08-16 at 15.16.38.png](_blocks_images/Screenshot_2023-08-16_at_15.16.38.png)

Blocks are ordered starting from the genesis block 0 up to the latest block. Each block contains an ordered list of transactions. This is how the Flow blockchain preserves the complete history of all the changes made to the state from the beginning to the current state. 

Each block contains more data which is divided into **block header** and **block payload**. There are many representations of block data within the Flow protocol. APIs, node types, and specific components within the node may view a block from differing perspectives. For the purpose of this documentation, we will talk about block data we expose through APIs to the clients.

![Screenshot 2023-08-16 at 10.50.53.png](_blocks_images/Screenshot_2023-08-16_at_10.50.53.png)

### Block Header

The Block header contains the following fields:

- **ID** represents the block's unique identifier, which is derived from the hashing block header including the payload hash. The algorithm used on Flow to hash the content and get an identifier is SHA3 256. This ID is a commitment to all the values in the block staying the same.
- **Parent ID** is a link to the previous block ID in the list making up the blockchain.
- **Height** is the block sequence number, where block 0 was the first block produced, and each next block increments the value by 1.
- **Timestamp** is the timestamp at which this block was proposed by the consensus node. Depending on your use case this time might not be accurate enough, [read more about measuring time on the Flow blockchain](https://cadence-lang.org/docs/measuring-time#time-on-the-flow-blockchain).
- **Payload Hash** represents the payload hash that is included when producing the ID of the block. Payload hash is calculated by taking Merkle root hashes of collection guarantees, seals, execution receipts, and execution results and hashing them together. More on each of the values in the block payload section.

### Block Payload

The block payload contains the following fields:

- **Collection Guarantees** is a list of collection IDs with the signatures from the collection nodes that produced the collections. This acts as a guarantee by collection nodes that [transaction data](./transactions.md) in the collection will be available on the collection node if requested by other nodes at a later time. Flow purposely skips including transaction data in a block, making blocks as small as possible, and the production of new blocks by consensus nodes fast, that is because consensus nodes have to sync the proposed block between nodes, and that data should be the smallest possible. The consensus nodes don’t really care what will a transaction do as long as it’s valid, they only need to define an order of those transactions in a block.
- **Block Seals** is the attestation by verification nodes that the transactions in a previously executed block have been verified. This seals a previous block referenced by the block ID. It also references the result ID and execution root hash. It contains signatures of the verification nodes that produced the seal.

## Lifecycle and Status

Block status is not a value stored inside the block itself but it represents the lifecycle of a block. We derive this value based on the block inclusion in the Flow blockchain and present it to the user as it acts as an important indicator of the finality of the changes the block contains. 

Here we’ll give an overview of the different phases a block goes through. [More details can be found in the whitepaper](https://flow.com/technical-paper). Also, a lot of the block states are not necessarily important to the developer but only important to the functioning of the Flow blockchain. 

New blocks are constantly being proposed even if no new transactions are submitted to the network. Consensus nodes are in charge of producing blocks. They use a consensus algorithm (an implementation of HotStuff) to agree on what the new block will be. A block contains the ordered list of collections and each collection contains an ordered list of transactions. This is an important fact to reiterate. A block serves as a list of transitions to the Flow state machine. It documents, as an ordered list, all the changes transactions will make to the state. 

A block that is [agreed upon by the consensus nodes using an implementation of HotStuff consensus algorithm](https://arxiv.org/pdf/2002.07403.pdf) to be the next block is **finalized**. This means the block won’t change anymore and it will next be executed by the execution node. Please be careful because until a block is **sealed** the changes are not to be trusted. After verification nodes validate and agree on the correctness of execution results, a block is sealed and consensus nodes will include these seals in the new block.

In summary, a block can be either **finalized** which guarantees transactions included in the block will stay the same and will be executed, and **sealed** which means the block execution was verified. 

![Screenshot 2023-08-16 at 10.48.26.png](_blocks_images/Screenshot_2023-08-16_at_10.48.26.png)

## Block Retrieval

You can use the Flow CLI to get the block data by running:

```sh
flow blocks get latest -network mainnet
```

Find [more about the command in the CLI docs](../../tools/flow-cli/get-flow-data/get-blocks.md).

Blocks can be obtained from the access node APIs, currently, there are two gRPC and REST APIs. You can find more information about them here:

[**gRPC Block API**](../../references/run-and-secure/nodes/access-api.mdx#blocks)

[**REST Block API**](/http-api#tag/Blocks)

There are multiple SDKs implementing the above APIs for different languages:

[**Javascript SDK**](../../tools/clients/fcl-js/index.md)

[**Go SDK**](../../tools/clients/flow-go-sdk/index.mdx)

Find a list of all SDKs [here](../../tools/clients/index.md)
---
sidebar_position: 1
---

# Collections

Collections link blocks and transactions together. Collection node clusters make these collections (using the HotStuff consensus algorithm), made up of an ordered list of one or more hashes of [signed transactions](./transactions.md). In order to optimize data, blocks don’t contain transactions (as they do on Ethereum). The benefits are transaction data does not get transferred to consensus nodes on the network which optimizes transfer speed and this architecture allows scaling of ingestion speed by adding collection clusters. Consensus nodes need to only agree on the order of transactions to be executed, they don’t need to know the transaction payload, thus making blocks and collections lightweight. Collection nodes hold transaction payloads for anyone who requests them (e.g. execution nodes). 

![Screenshot 2023-08-17 at 19.50.39.png](_collection_images/Screenshot_2023-08-17_at_19.50.39.png)

## Collection Retrieval

You can use the Flow CLI to get the collection data by running:

```sh
flow collections get caff1a7f4a85534e69badcda59b73428a6824ef8103f09cb9eaeaa216c7d7d3f -n mainnet
```

Find [more about the command in the CLI docs](../../tools/flow-cli/get-flow-data/get-collections.md).

Collections can be obtained from the access node APIs, currently, there are two gRPC and REST APIs. You can find more information about them here:

[**gRPC Collection API**](../../references/run-and-secure/nodes/access-api.mdx#collections)

[**REST Collection API**](/http-api#tag/Collections)

There are multiple SDKs implementing the above APIs for different languages:

[**Javascript SDK**](../../tools/clients/fcl-js/index.md)

[**Go SDK**](../../tools/clients/flow-go-sdk/index.mdx)

Find a list of all SDKs [here](../../tools/clients/index.md)
---
sidebar_position: 6
---

# Events

Flow events are special values that are emitted on the network during the execution of a Cadence program and can be observed by off-chain observers.

Events are defined as Cadence code and you should [read Cadence documentation](https://cadence-lang.org/docs/language/events) to understand how to define them. 

Since transactions don’t have return values you can leverage events to broadcast certain changes the transaction caused. Clients listening on Flow networks (apps) can listen to these events being emitted and react. 

![Screenshot 2023-08-18 at 14.09.33.png](_events_images/Screenshot_2023-08-18_at_14.09.33.png)

There are two types of events emitted on the Flow network:

- Core events
- User-defined events

Events consist of the **event name** and an optional **payload**.

![Screenshot 2023-08-18 at 13.59.01.png](_events_images/Screenshot_2023-08-18_at_13.59.01.png)

## Core Events

Core events are events emitted directly from the FVM (Flow Virtual Machine). The events have the same name on all networks and do not follow the same naming as user-defined events (they have no address).

A list of events that are emitted by the Flow network is:

| Event Name                   | Description                                                             |
| ---------------------------- | ------------------------------------------------------------------------|
| flow.AccountCreated          | Event that is emitted when a new account gets created.                  |
| flow.AccountKeyAdded         | Event that is emitted when a key gets added to an account.              |
| flow.AccountKeyRemoved       | Event that is emitted when a key gets removed from an account.          |
| flow.AccountContractAdded    | Event that is emitted when a contract gets deployed to an account.      |
| flow.AccountContractUpdated  | Event that is emitted when a contract gets updated on an account.       |
| flow.AccountContractRemoved  | Event that is emitted when a contract gets removed from an account.     |
| flow.InboxValuePublished     | Event that is emitted when a Capability is published from an account.   |
| flow.InboxValueUnpublished   | Event that is emitted when a Capability is unpublished from an account. |
| flow.InboxValueClaimed1      | Event that is emitted when a Capability is claimed by an account.       |

For more details [on the core events, you can read Cadence reference documentation](https://cadence-lang.org/docs/language/core-events).

## User-defined events

Events that are defined inside contracts and when emitted follow a common naming schema. The schema consists of 4 parts: 

```cadence
A.{contract address}.{contract name}.{event type}
```

An example event would look like:

![Screenshot 2023-08-18 at 14.30.36.png](_events_images/Screenshot_2023-08-18_at_14.30.36.png)

The first `A` means the event is originating from a contract, which will always be the case for user-defined events. The contract address as the name implies is the location of a contract deployed on the Flow network. Next, is the name of the contracted event originates from, and last is the event type defined in the contract.

There is an unlimited amount of events that can be defined on Flow, but you should know about the most common ones. 

### FLOW Token Events

The FLOW Token contract uses the [fungible token standard on Flow](../../references/core-contracts/03-flow-token.md) and is the contract that issues a core FLOW token. As with any contract, it can emit events when interacted with. When we transfer the FLOW token, events are emitted. You can find a lot of details on the events emitted in the [FLOW Token documentation](../../references/core-contracts/03-flow-token.md). 

The most common events are when tokens are transferred which is accomplished with two actions: withdrawing tokens from the payer and depositing tokens in the receiver. Each of those action has a corresponding event:

**Withdraw Tokens**

Event name: `TokensWithdrawn`

Mainnet event: `A.1654653399040a61.FlowToken.TokensWithdrawn`

Testnet event: `A.7e60df042a9c0868.FlowToken.TokensWithdrawn`

**Deposit Tokens**

Event name: `TokensDeposited`

Mainnet event: `A.1654653399040a61.FlowToken.TokensDeposited`

Testnet event: `A.7e60df042a9c0868.FlowToken.TokensDeposited`

### **Fee Events**

Since fees are governed by a contract deployed on the Flow network, that contract also emits events when fees are deducted. 

Charging fees consists of a couple of steps:

- Calculate and deduct fees
- Withdraw Flow tokens from the payer account
- Deposit Flow tokens to the fees contract

These events are very common since they accommodate all transactions on Flow. Each fee deduction will result in three events: the withdrawal of Flow tokens, the deposit of Flow tokens, and the fee deduction. 

An example of fee events:

```yml
Events:
  - Index: 0
    Type:  A.1654653399040a61.FlowToken.TokensWithdrawn
    Tx ID: 1ec90051e3bc74fc36cbd16fc83df08e463dda8f92e8e2193e061f9d41b2ad92
    Values:
      - amount (UFix64): 0.00000100
      - from (Address?): 0xb30eb2755dca4572

  - Index: 1
    Type:  A.1654653399040a61.FlowToken.TokensDeposited
    Tx ID: 1ec90051e3bc74fc36cbd16fc83df08e463dda8f92e8e2193e061f9d41b2ad92
    Values:
      - amount (UFix64): 0.00000100
      - to (Address?): 0xf919ee77447b7497

  - Index: 2
    Type:  A.f919ee77447b7497.FlowFees.FeesDeducted
    Tx ID: 1ec90051e3bc74fc36cbd16fc83df08e463dda8f92e8e2193e061f9d41b2ad92
    Values:
      - amount (UFix64): 0.00000100
      - inclusionEffort (UFix64): 1.00000000
      - executionEffort (UFix64): 0.00000000
```
---
sidebar_position: 5
---

# Fees

## Transaction Fees

A transaction fee is a cost paid in Flow by the payer account and is required for a transaction to be included in the Flow blockchain. Fees are necessary for protecting the network against spam, and infinite running transactions and to provide monetary incentives for participants that make up the Flow network.

A transaction fee is paid regardless of whether a transaction succeeds or fails. If the payer account doesn't have sufficient Flow balance to pay for the transaction fee, the transaction will fail. We can limit the transaction fee to some extent by providing the gas limit value when submitting the transaction.

### Understanding the need for transaction fees

Segmented transaction fees are essential to ensure fair pricing based on the impact on the network. For instance, more heavy operations will require more resources to process and propagate transactions. Common operations, however, will stay reasonably priced.

Fees will improve the overall security of the network by making malicious actions (eg spam) on the network less viable.

The unique Flow architecture is targeted at high throughput. It makes it easier to have slack in the system, so short spikes can be handled more gracefully.


### **Fee Structure**

Each transaction fee consists of three components: execution fee, inclusion fee, and network surge factor.

![Screenshot 2023-08-17 at 17.16.32.png](_fees_images/Screenshot_2023-08-17_at_17.16.32.png)

**Execution Fee**

The execution effort for a transaction is determined by the code path the transaction takes and the actions it does. The actions that have an associated execution effort cost can be separated into four broad buckets:

- Normal lines of cadence, loops, or function calls
- Reading data from storage, charged per byte read
- Writing data to storage, charged per byte written
- Account creation

| Transaction Type                                   | Estimated cost (FLOW) |
| -------------------------------------------------- | --------------------- |
| FT transfer                                        | 0.00000185            |
| Mint a small NFT (heavily depends on the NFT size) | 0.0000019             |
| Empty Transaction                                  | 0.000001              |
| Add key to an account                              | 0.000001              |
| Create 1 Account                                   | 0.00000315            |
| Create 10 accounts                                 | 0.00002261            |
| Deploying a contract that is ~50kb                 | 0.00002965            |

**Inclusion Fee**

The inclusion effort of a transaction represents the work needed for:

- Including the transaction in a block
- Transporting the transaction information from node to node
- Verifying transaction signatures

Right now, the inclusion effort is always 1.0 and the inclusion effort cost is fixed to `0.000001`. 

**Surge Factor**

In the future, a network surge will be applied when the network is busy due to an increased influx of transactions required to be processed or a decrease in the ability to process transactions. Right now, the network surge is fixed to `1.0`.

Currently, both the inclusion fee and surge factor don’t represent any significant Flow fees. Keep in mind this can change in the future.

**Estimating transaction costs**

Cost estimation is a two-step process. First, you need to gather the execution effort with either the emulator, on testnet, or on mainnet. Second, you use the execution effort for a transaction to calculate the final fees using one of the JavaScript or Go FCL SDKs.

## Storage

Each Flow account has associated storage used. The account's storage used is the byte size of all the data stored in the account's storage. Accounts also have a storage capacity, which is directly tied to the amount of Flow tokens an account has. The account can, without any additional cost, use any amount of storage up to its storage capacity. 

<Callout type="warning">
If a transaction puts an account over storage capacity, that transaction fails and is reverted. Likewise, if a transaction would drop an account's balance below 0.001 Flow tokens, which is the minimum an account can have, the transaction would also fail.

</Callout>

**Storage Capacity**

The storage capacity of an account is dictated by the amount of FLOW it has. 

<Callout type="danger">
The **minimum amount of FLOW an account can have is 0.001**. This minimum is provided by the account creator at account creation.

</Callout>

The minimum account reservation ensures that most accounts won't run out of storage capacity if anyone deposits anything (like an NFT) to the account.

Currently, the amount required to store 100 MB in account storage is 1 Flow. 

![Screenshot 2023-08-17 at 17.27.50.png](_fees_images/Screenshot_2023-08-17_at_17.27.50.png)

Please note that storing data in an account on Flow doesn't charge tokens from the account, it just makes sure you will keep the tokens as a reserve. Once the storage is freed up you can transfer the Flow tokens. 

### Storage Capacity of the Payer

The storage capacity of the Payer of a transaction is generally computed the same way as the capacity of any other account, however, the system needs to account for the transaction fees the payer will incur at the end of the transaction. The final transaction fee amount is not fully known at this step, only when accounts are checked for storage compliance. If their storage used is more than their storage capacity, the transaction will fail.

Because of this, the payer's balance is conservatively considered to be lower by the maximum possible transaction fees, when checking for storage compliance. The maximum transaction fee of a specific transaction is the transaction fee as if the transaction would have used up all of its execution effort limit.

### Storage Used

All data that is in an account's storage counts towards storage used. Even when an account is newly created it is not empty. There are already some items in its storage:

- Metadata that marks that the account exists.
- An empty FLOW vault, and stored receiver capability.
- Public keys to the account if the account was created with keys.
- Smart contracts deployed on the account if the account was created with contracts.
- The value of the account’s storage used as an unsigned integer.

Adding additional keys, smart contracts, capabilities, resources, etc. to the account counts towards storage used.

Data stored on the Flow blockchain is stored in a key-value ledger. Each item’s key contains the address that owns the item and the path to the item. An account can have many keys, therefore flow considers the account key items are stored with. This means that the storage used by each item is the byte length of the item plus the byte length of the item’s key.


## Practical Understanding of Fees

**Using Flow Emulator**

You can start the [emulator using the Flow CLI](../../tools/emulator/index.md#running-the-emulator-with-the-flow-cli). Run your transaction and take a look at the events emitted:

```shell
0|emulator | time="2022-04-06T17:13:22-07:00" level=info msg="⭐  Transaction executed" computationUsed=3 txID=a782c2210c0c1f2a6637b20604d37353346bd5389005e4bff6ec7bcf507fac06
```

You should see the `computationUsed` field. Take a note of the value, you will use it in the next step.

**On testnet or mainnet**

Once a transaction is completed, you can use an explorer like [Flowdiver](https://flowdiver.io/) to review the transaction details and events emitted. For Flowdiver, you can open the transaction in question and look for the event `FeesDeducted` from the [`FlowFees`](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowFees.cdc) contract:

![flowscan-fees](./_fees_images/flowscan-fees.png)

In the event data on the right side, you will see a set of fields representing [FeeParameters](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowFees.cdc#L58):

- surgeFactor
- inclusionEffort
- executionEffort

Take a note of the last value in the list - the `executionEffort` value. You will use it in the next step.

### Calculating final costs

The cost for transactions can be calculated using the following FCL scripts on mainnet/testnet respectively.

**On mainnet**

```cadence
import FlowFees from 0xf919ee77447b7497
pub fun main(
  inclusionEffort: UFix64,
  executionEffort: UFix64
): UFix64 {
  return FlowFees.computeFees(inclusionEffort: inclusionEffort, executionEffort: executionEffort)
}
```

**On testnet**

```cadence
import FlowFees from 0x912d5440f7e3769e
pub fun main(
  inclusionEffort: UFix64,
  executionEffort: UFix64
): UFix64 {
  return FlowFees.computeFees(inclusionEffort: inclusionEffort, executionEffort: executionEffort)
}
```

## Configuring execution limits

FCL SDKs allow you to set the execution effort limit for each transaction. Based on the execution effort limit determined in the previous step, you should set a reasonable maximum to avoid unexpected behavior and protect your users. The final transaction fee is computed from the actual execution effort used up to this maximum.

> **Note**: Keep in mind that the limits are not for the final fees that the user will have to pay. The limits are for the execution efforts specifically.

It is important to set a limit that isn’t too high or too low. If it is set too high, the payer needs to have more funds in their account before sending the transaction. If it is too low, the execution could fail and all state changes are dropped.

**Using FCL JS SDK**

You need to set the `limit` parameter for the `mutate` function, for example:

```js
import * as fcl from "@onflow/fcl"

const transactionId = await fcl.mutate({
  cadence: `
    transaction {
      execute {
        log("Hello from execute")
      }
    }
  `,
  proposer: fcl.currentUser,
  payer: fcl.currentUser,
  limit: 100
})

const transaction = await fcl.tx(transactionId).onceSealed();
console.log(transaction;)
```

**Using FCL Go SDK**

You need to call the `SetComputeLimit` method to set the fee limit, for example:

```go
import (
    "github.com/onflow/flow-go-sdk"
    "github.com/onflow/flow-go-sdk/crypto"
)

var (
    myAddress    flow.Address
    myAccountKey flow.AccountKey
    myPrivateKey crypto.PrivateKey
)

tx := flow.NewTransaction().
    SetScript([]byte("transaction { execute { log(\"Hello, World!\") } }")).
    SetComputeLimit(100).
    SetProposalKey(myAddress, myAccountKey.Index, myAccountKey.SequenceNumber).
    SetPayer(myAddress)
```

### Maximum transaction fees of a transaction

The maximum possible fee imposed on the payer for a transaction can be calculated as the **inclusion cost plus the execution cost**. The execution cost is the fee calculated for running the transaction based on the [execution effort limit maximum specified](#configuring-execution-limits). 

The payer will never pay more than this amount for the transaction.

## Optimizing Cadence code to reduce effort

Several optimizations can lead to reduced execution time of transactions. Below is a list of some practices. This list is not exhaustive but rather exemplary.

**Limit functions calls**

Whenever you make function calls, make sure these are absolutely required. In some cases, you might be able to check prerequisites and avoid additional calls:

```cadence
for obj in sampleList {
   /// check if call is required
   if obj.id != nil {
      functionCall(obj)
   }
}
```

**Limit loops and iterations**

Whenever you want to iterate over a list, make sure it is necessary to iterate through all elements as opposed to a subset. Avoid loops to grow in size too much over time. Limit loops when possible.

```cadence
// Iterating over long lists can be costly
pub fun sum(list: [Int]): Int {
 var total = 0
 var i = 0
 // if list grows too large, this might not be possible anymore
 while i < list.length {
   total = total + list[i]
 }
 return total
}

// Consider designing transactions (and scripts) in a way where work can be "chunked" into smaller pieces
pub fun partialSum(list: [Int], start: Int, end: Int): Int {
 var partialTotal = 0
 var i = start
 while i < end {
   partialTotal = partialTotal + list[i]
 }
 return partialTotal
}
```

**Understand the impact of function calls**

Some functions will require more execution efforts than others. You should carefully review what function calls are made and what execution they involve.

```cadence
// be aware functions that call a lot of other functions
// (or call themselves) might cost a lot
pub fun fib(_ x: Int): Int {
 if x == 1 || x== 0 {
   return x
 }
 // + 2 function calls each recursion
 return fib(x-1) + fib(x-2)
}

// consider inlining functions with single statements, to reduce costs
pub fun add(_ a: Int, _ b: Int): Int {
 // single statement; worth inlining
 return a + b
}
```

**Avoid excessive load and save operations**

Avoid costly loading and storage operations and [borrow references](https://cadence-lang.org/docs/design-patterns#avoid-excessive-load-and-save-storage-operations-prefer-in-place-mutations) where possible, for example:

```cadence
transaction {

    prepare(acct: AuthAccount) {

        // Borrows a reference to the stored vault, much less costly operation that removing the vault from storage
        let vault <- acct.borrow<&ExampleToken.Vault>(from: /storage/exampleToken)

        let burnVault <- vault.withdraw(amount: 10)

        destroy burnVault

        // No `save` required because we only used a reference
    }
}
```

> **Note**: If the requested resource does not exist, no reading costs are charged.

**Limit accounts created per transaction**

Creating accounts and adding keys are associated with costs. Try to only create accounts and keys when necessary.

**Check user’s balance before executing transactions**

You should ensure that the user’s balance has enough balance to cover the highest possible fees. For FT transfers, you need to cover the amount to transfer in addition to the highest possible fees.

## Educating users

Wallets will handle the presentation of the final transaction costs but you can still facilitate the user experience by educating them within your application.

If your user is using self-custody wallets, they may have to pay the transaction and want to understand the fees. Here are some suggestions.

**Explain that costs can vary depending on the network usage**

Suggested message: “Fees improve the security of the network. They are flexible to ensure fair pricing based on the impact on the network.”

**Explain that waiting for the network surge to pass is an option**

Inevitably, network surges will cause higher fees. Users who might want to submit a transaction while the network usage is surging should consider sending the transaction at a later time to reduce costs.

**Explain that the wallet might not allow the transaction due to a lack of funds**

If dynamic fees increase to the highest possible level, the user’s fund might not be enough to execute the transaction. Let the users know that they should either add funds or try when the network is less busy.

## How to learn more

There are several places to learn more about transaction fees:

- [FLIP-660](https://github.com/onflow/flow/pull/660)
- [FLIP-753](https://github.com/onflow/flow/pull/753)
- [Flow Fees Contract](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowFees.cdc)

> **Note**: If you have thoughts on the implementation of transaction fees on Flow, you can [leave feedback on this forum post](https://forum.onflow.org/t/variable-transaction-fees-are-coming-to-flow/2941).

## FAQs

**When will the fee update go into effect?**

The updates were rolled out with the [Spork on April 6, 2022](../../references/run-and-secure/node-operation/past-sporks.mdx#mainnet-17), and were enabled on [June 1st](https://forum.onflow.org/t/permissionless-contract-deployment-progress/2981) during the [weekly epoch transition](https://github.com/onflow/service-account/tree/main/transactions/set-execution-effort-weights/2022/jun-1).

**Why are fees collected even when transactions fail?**

Broadcasting and verifying a transaction requires execution, so costs are deducted appropriately.

**What execution costs are considered above average?**

There is no average for execution costs. Every function will vary significantly based on the logic implemented. You should review the optimization best practices to determine if you could reduce your costs.

**Do hardware wallets like Ledger support segmented fees?**

Yes.

**What is the lowest execution cost?**

The lowest execution cost is 1. This means your transaction included one function call or loop that didn't read or write any date.

**Can I determine how much a transaction will cost on mainnet without actually paying?**

You can estimate the costs in a two-way process: 1) determine execution costs for transactions (emulator or testnet) and 2) use an FCL SDK method to calculate the final transaction fees.

**How accurate will testnet fees be to mainnet fees?**

Final fees are determined by the surge factor on the network. The surge factor for the testnet will be different from the factor for the mainnet, so you need to expect a variation between mainnet and testnet estimates.

**I use Blocto and I haven't paid any fees yet. Why is that?**

That is because Blocto is acting as the payer for transactions. Self-custody wallets may have the user pay the transaction. Additionally, apps can sponsor the transaction if they choose.
---
title: FLOW Token
sidebar_position: 10
---

## Introduction

This section contains information about the FLOW token for individual backers, wallet providers, custodians and node operators.

### FLOW as a Native Token

FLOW is the default token for the Flow protocol, meaning it is used for all protocol-level fee payments,
rewards and staking transactions. FLOW implements the standard [Flow Fungible Token interface](https://github.com/onflow/flow-ft),
which all other on-chain fungible tokens also conform to. This interface is defined in Cadence,
Flow's native smart-contract programming language, which makes it easy to write applications that
interact with FLOW.

## How to Get FLOW

There are two ways to acquire FLOW tokens as yield:

1. [Earn FLOW as a Validator or Delegator](../../references/run-and-secure/staking/06-technical-overview.mdx): Receive newly-minted FLOW as a reward for running a node.
1. [Earn FLOW as a Community Contributor](https://github.com/onflow/developer-grants): Flow offers grants for selected proposals as well as RFPs for teams to submit proposals for funded development

## How to Use FLOW

With FLOW, you can:

- Spend
- Stake
- Delegate
- Hold
- Vote
- Send and share
- Create, develop, and grow your dapp

### Spending FLOW

All you need to spend Flow is an account and a tool for signing transactions
(a wallet, custodian, or other signing service).
The FCL (Flow Client Library) makes it super duper easy to go to any dapp,
login with your account, have a great time,
and then sign with the wallet of your choice only once you decide to make a purchase.

### Staking FLOW

[You can use FLOW to operate a staked node.](../../references/run-and-secure/staking/06-technical-overview.mdx) Node operators receive newly-minted FLOW
as a reward for helping to secure the network.

### Delegating FLOW

[You can use FLOW for stake delegation.](../../references/run-and-secure/staking/06-technical-overview.mdx) Delegators receive newly-minted FLOW
as a reward for helping to secure the network.

### Holding FLOW

If you have already purchased FLOW and wish to hold it, you have a couple of options:

- For relatively small, short term holdings - most people use a wallet.
  Wallets are used to help you sign transactions (verify your actions) when using your FLOW tokens.

- For larger, long term holdings - you may want to use a custody provider to keep your funds safe.

You can find wallets and custodians supporting Flow in the [Flow Port](https://port.onflow.org/)

### Voting with FLOW

Participating in the Flow community is more than just running a node or building a dapp.
It's also about engaging in discussion, debate, and decision making about the protocol,
the content on it, and the people impacted by it.
You can use your Flow account to submit votes to community polls and other governance related activities.

### Sending and Sharing FLOW

If you simply want to share the love and bring your friends to Flow, it's easier than an edible arrangement.

It is possible to use the Flow blockchain without holding any FLOW tokens yourself.
Free to play games, trials, community polls,
and other community activities can all take place with only an account
(which may be created on a person's behalf)
and a small fixed fee which may be paid by a user agent.

The protocol requires some FLOW tokens to process these transactions,
but (and this is the cool part!) a product can support users who do not themselves hold FLOW
while still providing that user with all the underlying security guarantees the Flow protocol provides.

Transferring FLOW, creating accounts, and updating keys are all actions made easy on [Flow Port](https://port.onflow.org/)

### Submitting Transactions and Updating Users

Transactions are submitted using a Flow SDK via the Access API.

On Flow, a transaction is identified by its hash - the hash that exists as soon as that transaction is signed and submitted to an Access or Collection node.
Results of transactions can be queried by transaction hash through the Access API.
A user can check the status of a transaction at any time via the [Flow Block Explorer](https://flow.bigdipper.live/).

To expose these results natively in your app, you can use a Flow SDK to fetch transaction results,
[for example using the Flow Go SDK](https://github.com/onflow/flow-go-sdk#querying-transaction-results).

Using a Flow SDK you can also fetch account state by address from a Flow Access API,
[for example using the Flow Go SDK](https://github.com/onflow/flow-go-sdk#querying-accounts).

Once the transaction is sealed, an event is emitted and you will be able to read transaction events and update the user.

The Flow SDKs also allow polling for events using the Flow Access API,
[for example using the Flow Go SDK](https://github.com/onflow/flow-go-sdk#querying-events).

## How to Build with FLOW

To get started building on Flow, please read the [Flow Developer Onboarding guide](../../tutorials/intro.md).
---
sidebar_position: 4
---

# Scripts

A script is executable Cadence code that queries the Flow network but does not modify it. Unlike Flow transactions, they don’t need signing and they can return a value. You can think of executing scripts as a read-only operation. 

Scripts are executed on Access Nodes, Archive Nodes, or Execution Nodes. 

Scripts are defined by following the Cadence code and we can only execute one at a time.

```cadence
pub fun main() {}
```

Scripts can return a typed value:

```cadence
pub fun main(): Int {
	return 1 + 2
}
```

Scripts can call contract functions and query the state of a contract. To call a function on another contract, import it from its address and invoke the function:

```cadence
import World from 0x01

pub fun main(): String {
	return World.hello()
}
```

## Executing Scripts

You can execute a script by using the Flow CLI:

```sh
flow scripts execute ./helloWorld.cdc
```

A user can define their own scripts or can use already defined scripts by the contract authors that can be found by using the FLIX service.

Scripts can be run against previous blocks, allowing you to query historic data from the Flow network. This is particularly useful for retrieving historical states of contracts or tracking changes over time.

Scripts are executed by being submitted to the Access Node APIs. Currently, there’s support for two APIs:

[**gRPC Script API**](../../references/run-and-secure/nodes/access-api.mdx#scripts)

[**REST Script API**](/http-api#tag/Scripts)

There are multiple SDKs implementing the above APIs for different languages:

[**Javascript SDK**](../../tools/clients/fcl-js/index.md)

[**Go SDK**](../../tools/clients/flow-go-sdk/index.mdx)

Find a list of all SDKs [here](../../tools/clients/index.md)
---
sidebar_position: 3
---

# Transactions

Transactions are cryptographically signed data messages that contain a set of instructions that update the Flow state. They are a basic unit of computation that gets executed by execution nodes. In order for a transaction to be included in the Flow blockchain a fee is required from the payer. 

![Screenshot 2023-08-17 at 13.57.36.png](_transactions_images/Screenshot_2023-08-17_at_13.57.36.png)

<Callout type="tip">
Transactions on Flow are fundamentally different from those on Ethereum. The main purpose of a transaction is not to send funds but to contain code that gets executed. This makes transactions very flexible and powerful. In addition to being able to access the authorizing accounts private assets, transactions can also read and call functions in public contracts, and access public domains in other users' accounts Transactions on Flow also feature different roles, such as defining third-party payer accounts, proposer accounts, and authorizers, which we will talk about in detail soon.

</Callout>

In order for a transaction to be valid and executed it must contain signatures from accounts involved as well as some other information, let’s take a look at all the required fields.

![Screenshot 2023-08-17 at 14.52.56.png](_transactions_images/Screenshot_2023-08-17_at_14.52.56.png)

**Script**

The script section contains instructions for transaction execution. This is a Cadence program in source code form (human-readable), and encoded as UTF-8. The transaction program must contain a `transaction` declaration. 

A transaction includes multiple optional phases `prepare`, `pre`, `execute`, and `post` phase. You can read more about it in the [Cadence reference document on transactions](https://cadence-lang.org/docs/language/transactions). Each phase has a purpose, the two most important phases are `prepare` and `execute`. 

In the `prepare` phase, we have access to `AuthAccount` objects, which gives us the power to interact with those accounts. The accounts are called authorizers of transactions, so each account we want to interact with in the `prepare` phase must sign the transaction as an authorizer. 
The `execute` phase does exactly what it says, it executes the main logic of the transaction. This phase is optional, but it is a best practice to add your main transaction logic in the section, so it is explicit. 

Again make sure to read Cadence [documentation on transactions](https://cadence-lang.org/docs/language/transactions)

This is an example of a transaction script:

```cadence
transaction(greeting: String) {
  execute {
    log(greeting.concat(", World!"))
  }
}
```

**Arguments**

Transactions may declare parameters it needs during execution, these must be provided as input arguments when sending a transaction. You can think of them as function arguments. Currently, we provide [arguments in the JSON-Cadence Data Interchange Format](https://cadence-lang.org/docs/json-cadence-spec#docusaurus_skipToContent_fallback). Which is a human-readable JSON format. The sample script from above accepts a single `String` argument.

**Reference Block**

A reference to a recent block used for expiry. A transaction is considered expired if it is submitted to Flow after reference block height + N, where N is a constant defined by the network. On mainnet current setting for N is 600 which amounts to approximately 10 minutes for expiry (please note this is subject to change).

**Gas Limit**

When a transaction is executed each operation consumes a predefined amount of computational units (we define more about that in the Fees documentation). This defines the maximum amount of computation that is allowed to be done during this transaction. If a transaction completes execution using fewer computational units than the limit, it remains unaffected. However, if it hits this limit during execution, the transaction will fail, its changes will be reverted, but fees will still be applied. The maximum computational limit for Flow mainnet is currently at 9999, but this might change. The maximum network limit is defined to protect the network from transactions that would run forever. 

**Proposal Key**

Each transaction must declare a proposal key, which can be an account key from any Flow account (App, User or Wallet). The account that owns the proposal key is referred to as the *proposer*. 

Proposer is a role in a transaction that defines who is proposing the transaction, the effect of the transaction being submitted on the proposer is that it will increment the sequence number for the provided proposer key. This is done to ensure transactions are not resubmitted (replay attack) and thus sequencing actions. 

A proposal key definition declares the address, key ID, and up-to-date sequence number for the account key. A single proposer can have many transactions executed in parallel only limited by the key they use to propose the transaction.

![Screenshot 2023-08-17 at 15.10.33.png](_transactions_images/Screenshot_2023-08-17_at_15.10.33.png)

- Address identifies the account that will act as a proposer of this transaction.
- Key ID is an index number (starting at 0) that identifies the key on the account provided in the address.
- Sequence Number is a number on each key that increments by 1 with each transaction. This ensures that each transaction executes at most once and prevents many unwanted situations, such as [transaction replay attacks](https://en.wikipedia.org/wiki/Replay_attack). Each key in an account has a dedicated sequence number associated with it. Unlike Ethereum, there is no sequence number for the entire account.

**Authorizers**

Authorizers are accounts that authorize a transaction to read and mutate their state. A transaction can specify zero or more authorizers, depending on how many accounts the transaction needs to access.

The number of authorizers on the transaction must match the number of AuthAccount parameters declared in the prepare statement of the Cadence script.

Example transaction with multiple authorizers:

```cadence
transaction {
  prepare(authorizer1: AuthAccount, authorizer2: AuthAccount) { }
}
```

Each account defined as an authorizer must sign the transaction with its own key, and by doing so it acknowledges the transaction it signed will have access to that account and may modify it. How it will modify it is understood from reading the transaction script.

**Payer**

A payer is the account that pays the fees for the transaction. A transaction must specify exactly one payer. The payer is only responsible for paying the network and gas fees; the transaction is not authorized to access resources or code stored in the payer account. 

By explicitly specifying a payer a transaction can be paid by third-party services such as wallet providers.

## Transaction Lifecycle

Once a transaction has been submitted to the Flow network using the Access node APIs, it will begin its lifecycle and eventually reach a finality. Each submitted transaction can be identified with an ID. 

**Transaction ID**

A transaction ID is a hash of the encoded transaction payload and can be calculated at any time. We don’t submit transaction ID as part of the transaction payload as it can be derived from the data and thus would mean duplication of data.

### Transaction Status

The transaction status represents the state of a transaction on the Flow blockchain. Some statuses are mutable and some are immutable, they usually follow a timeline like so:

![Screenshot 2023-08-17 at 16.08.18.png](_transactions_images/Screenshot_2023-08-17_at_16.08.18.png)

- Unknown - The transaction has not yet been seen by the section of the network you communicate with.
- Pending - The transaction has been received by a collection node but has not yet been finalized in a block.
- Finalized - The consensus nodes have included the transaction in a block, but it has not been executed by execution nodes.
- Executed - Execution nodes have produced a result for the transaction. 
- Sealed - The verification nodes have verified and agreed on the result of the transaction and the consensus node has included the seal in the latest block.
- Expired - The transaction was submitted past its expiration block height.

<Callout type="danger">
It is **important to differentiate the transaction status and transaction result**. Transaction status will only provide you with information about the inclusion of the transaction in the blockchain, not whether the transaction was executed the way you intended. **A transaction can still fail to execute the way you intended and be sealed.**

</Callout>

### Transaction Result

Once a transaction is executed, its result will be available, providing details on its success or any errors encountered during execution. It also includes events the transaction may have emitted. 

![Screenshot 2023-08-17 at 16.29.30.png](_transactions_images/Screenshot_2023-08-17_at_16.29.30.png)

<Callout type="danger">
From a developer perspective, a transaction is only successful if:

- It is sealed
- It didn’t encounter errors
</Callout>

## Signing a Transaction

Due to the existence of **weighted keys** and **split signing roles**, Flow transactions sometimes need to be signed multiple times by one or more parties. That is, multiple unique signatures may be needed to authorize a single transaction.

A transaction can contain two types of signatures: **payload signatures** and **envelope signatures**.

![Screenshot 2023-08-17 at 14.52.51.png](_transactions_images/Screenshot_2023-08-17_at_14.52.51.png)

### Signer Roles
- **Proposer**: the account that specifies a proposal key.
- **Payer**: the account paying for the transaction fees.
- **Authorizers**: zero or more accounts authorizing the transaction to mutate their state.

### Payload

The transaction payload is the innermost portion of a transaction and contains the data that uniquely identifies the operations applied by the transaction as we have defined them above. In Flow, two transactions with the same payload will never be executed more than once.

<Callout type="warning">
⚠️ The transaction proposer and authorizer are only required to sign the transaction payload. These signatures are the payload signatures.

</Callout>

### Authorization Envelope

The transaction authorization envelope contains both the transaction payload and the payload signatures.

The transaction payer is required to sign the authorization envelope. These signatures are **envelope signatures**.

<Callout type="danger">
Special case: if an account is both the payer and either a proposer or authorizer, it is required only to sign the envelope.

</Callout>

### Payment Envelope

The outermost portion of the transaction, which contains the payload and envelope signatures, is referred to as the payment envelope.

<Callout type="danger">
Special case: if an account is both the payer and either a proposer or authorizer, it is required only to sign the envelope.

</Callout>

### Payer Signs Last

The payer must sign the portion of the transaction that contains the payload signatures, which means that the payer must always sign last. This ensures the payer that they are signing a valid transaction with all of the required payload signatures.

<Callout type="danger">
Special case: if an account is both the payer and either a proposer or authorizer, it is required only to sign the envelope.

</Callout>

### Signature Structure

A transaction signature is a composite structure containing three fields:

- Address
- Key ID
- Signature Data

The *address* and *key ID* fields declare the account key that generated the signature, which is required in order to verify the signature against the correct public key.

### Sequence Numbers

Flow uses sequence numbers to ensure that each transaction executes at most once. This prevents many unwanted situations such as [transaction replay attacks](https://en.wikipedia.org/wiki/Replay_attack).

Sequence numbers work similarly to transaction nonces in Ethereum, but with several key differences:

- **Each key in an account has a dedicated sequence number** associated with it. Unlike Ethereum, there is no sequence number for the entire account.
- When creating a transaction, only the **proposer must specify a sequence number**. Payers and authorizers are not required to.

<Callout type="tip">
The transaction proposer is only required to specify a sequence number for a single account key, even if it signs with multiple keys. This key is referred to as the proposal key.

</Callout>

Each time an account key is used as a proposal key, its sequence number is incremented by 1. The sequence number is updated after execution, even if the transaction fails (reverts) during execution.

A transaction is failed if its proposal key does not specify a sequence number equal to the sequence number stored on the account *at execution time.*

## Common Signing Scenarios

Below are several scenarios in which different signature combinations are required to authorize a transaction.

### Single party, single signature

The simplest Flow transaction declares a single account as the proposer, payer and authorizer. In this case, the account can sign the transaction with a single signature.

This scenario is only possible if the signature is generated by a key with full signing weight.

| Account | Key ID | Weight |
| ------- | ------ | ------ |
| 0x01    | 1      | 1000   |

```json
{	
  "payload": {
    "proposalKey": {
      "address": "0x01",
      "keyId": 1,
      "sequenceNumber": 42
    },
    "payer": "0x01",
    "authorizers": [ "0x01" ]
  },
  "payloadSignatures": [], // 0x01 is the payer, so only needs to sign envelope
  "envelopeSignatures": [
    {
      "address": "0x01",
      "keyId": 1,
      "sig": "0xabc123"
    }
  ]
}
```

### Single party, multiple signatures

A transaction that declares a single account as the proposer, payer and authorizer may still specify multiple signatures if the account uses weighted keys to achieve multi-sig functionality.

| Account | Key ID | Weight |
| ------- | ------ | ------ |
| 0x01    | 1      | 500    |
| 0x01    | 2      | 500    |

```json
{	
  "payload": {
    "proposalKey": {
      "address": "0x01",
      "keyId": 1,
      "sequenceNumber": 42
    },
    "payer": "0x01",
    "authorizers": [ "0x01" ]
  },
  "payloadSignatures": [], // 0x01 is the payer, so only needs to sign envelope
  "envelopeSignatures": [
    {
      "address": "0x01",
      "keyId": 1,
      "sig": "0xabc123"
    },
    {
      "address": "0x01",
      "keyId": 2,
      "sig": "0xdef456"
    }
  ]
}
```

### Multiple parties

A transaction that declares different accounts for each signing role will require at least one signature from each account.

| Account | Key ID | Weight |
| --- | --- | --- |
| 0x01 | 1 | 1000 |
| 0x02 | 1 | 1000 |

```json
{	
  "payload": {
    "proposalKey": {
      "address": "0x01",
      "keyId": 1,
      "sequenceNumber": 42
    },
    "payer": "0x02",
    "authorizers": [ "0x01" ]
  },
  "payloadSignatures": [
    {
      "address": "0x01", // 0x01 is not payer, so only signs payload
      "keyId": 1,
      "sig": "0xabc123"
    }
  ],
  "envelopeSignatures": [
    {
      "address": "0x02",
      "keyId": 1,
      "sig": "0xdef456"
    },
  ]
}
```

### Multiple parties, multiple signatures

A transaction that declares different accounts for each signing role may require more than one signature per account if those accounts use weighted keys to achieve multi-sig functionality.

| Account | Key ID | Weight |
| --- | --- | --- |
| 0x01 | 1 | 500 |
| 0x01 | 2 | 500 |
| 0x02 | 1 | 500 |
| 0x02 | 2 | 500 |

```json
{	
  "payload": {
    "proposalKey": {
      "address": "0x01",
      "keyId": 1,
      "sequenceNumber": 42
    },
    "payer": "0x02",
    "authorizers": [ "0x01" ]
  },
  "payloadSignatures": [
    {
      "address": "0x01", // 0x01 is not payer, so only signs payload
      "keyId": 1,
      "sig": "0xabc123"
    },
        {
      "address": "0x01", // 0x01 is not payer, so only signs payload
      "keyId": 2,
      "sig": "0x123abc"
    }
  ],
  "envelopeSignatures": [
    {
      "address": "0x02",
      "keyId": 1,
      "sig": "0xdef456"
    },
    {
      "address": "0x02",
      "keyId": 2,
      "sig": "0x456def"
    },
  ]
}
```

## Transaction Submission and Retrieval

You can use the Flow CLI to get an existing transaction by ID:

```sh
flow transactions get 1ec90051e3bc74fc36cbd16fc83df08e463dda8f92e8e2193e061f9d41b2ad92 -n mainnet
```

Find [more about the command in the CLI docs](../../tools/flow-cli/get-flow-data/get-blocks.md).

A user can define their own transactions or it can use already defined transactions by the contract authors that can be found by using the FLIX service.

Transactions can be submitted and obtained from the access node APIs, currently, there are two gRPC and REST APIs. You can find more information about them here:

[**gRPC Transaction API**](../../references/run-and-secure/nodes/access-api.mdx#transactions)

[**REST Transaction API**](/http-api#tag/Transactions)

There are multiple SDKs implementing the above APIs for different languages:

[**Javascript SDK**](../../tools/clients/fcl-js/index.md)

[**Go SDK**](../../tools/clients/flow-go-sdk/index.mdx)

Find a list of all SDKs [here](../../tools/clients/index.md)
---
sidebar_position: 4
title: Differences vs. Other Blockchains
sidebar_custom_props:
  icon: ↔️
---

This document summarizes the differences you might encounter between building on Flow vs. other blockchains, especially Ethereum. This will be most useful to developers who are already familiar with building on a blockchain system. Check out [Introduction to Flow](./flow.md) for a more beginner-friendly overview of the Flow blockchain.

Summary of key differences covered:

- The Flow account model
- Smart contracts
    - The Cadence language
    - Transactions and Scripts
    - Events
- Nodes
- SDKs and Tools

## The Flow Account Model

Key pairs establish ownership on blockchains. In other blockchains (e.g. Bitcoin), the user’s address is also calculated based on their public key, making a unique one-to-one relationship between accounts (addresses) and public keys. This also means there is no concrete “account creation” process other than generating a valid key pair. With the advent of smart contracts, Ethereum introduced a new account type for deploying contracts that can use storage space (i.e., to store contract bytecode). You can learn more about the distinction between EOA and Contract accounts on Ethereum [here](https://ethereum.org/en/developers/docs/accounts/).

Flow combines the concepts of EOAs and Contract Accounts into a single account model and decouples accounts and public keys. Flow accounts are associated with one or more public keys of varying weights that specify interested parties that need to produce valid cryptographic signatures for each transaction authorized by that account.

![Screenshot 2023-08-16 at 16.43.07.png](./basics/_accounts_images/Screenshot_2023-08-16_at_16.43.07.png)

This natively enables interesting use cases, like key revocation, rotation, and multi-signature transactions. All Flow accounts can use network storage (e.g., for deploying contracts and storing resources like NFTs) based on the number of FLOW tokens they hold.

<Callout type="info">

You must run an explicit account creation transaction on Flow to create a new account. [Flow CLI](../tools/flow-cli/accounts/create-accounts.md) can create an account on any network with a given public key.

</Callout>

Check out the [Accounts](./basics/accounts.md) concept document to learn more about Flow accounts.

## Smart Contracts

On Flow, smart contracts are written in Cadence. Cadence syntax is user-friendly and inspired by modern languages like Swift. Notable features of Cadence that make it unique and the key power of the Flow blockchain are:

- **Resource-oriented**: Cadence introduces a new type called Resources. Resources enable onchain representation of digital assets natively and securely. Resources can only exist in one location at a time and are strictly controlled by the execution environment to avoid common mishandling mistakes. Each resource has a unique `uuid` associated with it on the blockchain. Examples of usage are fungible tokens, NFTs, or any custom data structure representing a real-world asset. Check out [Resources](https://cadence-lang.org/docs/language/resources) to learn more.
- **Capability-based**: Cadence offers a [Capability-based Security](https://en.wikipedia.org/wiki/Capability-based_security) model. This also enables the use of Resources as structures to build access control. Capabilities can provide fine-grained access to the underlying objects for better security. For example, when users list an NFT on a Flow marketplace, they create a new Capability to the stored NFT in their account so the buyer can withdraw the asset when they provide the tokens. Check out [Capability-based Access Control](https://cadence-lang.org/docs/language/capabilities) to learn more about Capabilities on Cadence.

<Callout type="info">

Cadence is not compiled. All contracts are open source on Flow.

</Callout>

Check out the [Cadence website](https://cadencelang.dev/) to learn more about Cadence.

If you’re already familiar with smart contracts, here are some resources that can help you get started with Cadence:

- [The Cadence tutorial](https://cadence-lang.org/docs/tutorial/first-steps)
- [Guide for Solidity Developers](https://cadence-lang.org/docs/solidity-to-cadence)
- ERC-20 equivalent on Flow is the Flow Fungible Token Standard
    - [Repository](https://github.com/onflow/flow-ft)
    - [Tutorial](https://cadence-lang.org/docs/tutorial/fungible-tokens)
- ERC-721 equivalent on Flow is the Flow Non-Fungible Token Standard
    - [Repository](https://github.com/onflow/flow-nft)
    - [Tutorial](https://cadence-lang.org/docs/tutorial/non-fungible-tokens-1)
- Asset marketplaces with Cadence
    - [Tutorial](https://cadence-lang.org/docs/tutorial/marketplace-setup)
    - [NFT Storefront](https://github.com/onflow/nft-storefront/) is an example marketplace standard

### Transactions and Scripts

You can interact with the state on most other blockchains by cryptographically authorizing smart contract function calls. On Flow, transactions are more complex and are pieces of Cadence code. This means that any number of contracts and function calls can be composed together atomically to mutate the blockchain state.

Here is a sample transaction that mints an NFT from `ExampleNFT` contract on Testnet:

```cadence
import NonFungibleToken from 0x631e88ae7f1d7c20
import ExampleNFT from 0x2bd9d8989a3352a1

/// Mints a new ExampleNFT into recipient's account

transaction(recipient: Address) {

    /// Reference to the receiver's collection
    let recipientCollectionRef: &{NonFungibleToken.CollectionPublic}

    /// Previous NFT ID before the transaction executes
    let mintingIDBefore: UInt64

    prepare(signer: AuthAccount) {

        self.mintingIDBefore = ExampleNFT.totalSupply

        // Borrow the recipient's public NFT collection reference
        self.recipientCollectionRef = getAccount(recipient)
            .getCapability(ExampleNFT.CollectionPublicPath)
            .borrow<&{NonFungibleToken.CollectionPublic}>()
            ?? panic("Could not get receiver reference to the NFT Collection")

    }

    execute {

        let currentIDString = self.mintingIDBefore.toString()

        // Mint the NFT and deposit it to the recipient's collection
        ExampleNFT.mintNFT(
            recipient: self.recipientCollectionRef,
            name: "Example NFT #".concat(currentIDString),
            description: "Example description for #".concat(currentIDString),
            thumbnail: "https://robohash.org/".concat(currentIDString),
            royalties: []
        )
    }

    post {
        self.recipientCollectionRef.getIDs().contains(self.mintingIDBefore): "The next NFT ID should have been minted and delivered"
        ExampleNFT.totalSupply == self.mintingIDBefore + 1: "The total supply should have been increased by 1"
    }
}
```

Authorizing transactions is also more complex on Flow involving multiple roles:

- Accounts can have multiple keys with varying weights
- Multiple accounts can sign a single transaction (`prepare` takes any number of arguments)
- Transaction computation fees can be paid by a different account, called the `Payer` account.
- The transaction [nonce](https://ethereum.org/en/developers/docs/accounts/#an-account-examined) is provided by the `Proposer` account. This enables rate control and order to be dictated by a different party if needed.
- All of the above roles can be the same account.

The same powerful concept also exists for querying the blockchain state using Scripts. Here is a sample script that fetches the `ExampleNFT` IDs owned by a given account on Testnet:

```cadence
/// Script to get NFT IDs in an account's collection

import NonFungibleToken from 0x631e88ae7f1d7c20
import ExampleNFT from 0x2bd9d8989a3352a1

pub fun main(address: Address, collectionPublicPath: PublicPath): [UInt64] {

    let account = getAccount(address)

    let collectionRef = account
        .getCapability(collectionPublicPath)
        .borrow<&{NonFungibleToken.CollectionPublic}>()
        ?? panic("Could not borrow capability from public collection at specified path")

    return collectionRef.getIDs()

}
```

Check out [Transactions](./basics/transactions.md) and [Scripts](./basics/scripts.md) to learn more about the concepts. You can also read the Cadence language reference on [Transactions](https://cadence-lang.org/docs/language/transactions) to dive deeper.

## Flow Nodes

Developers need a blockchain node to send transactions and fetch state. Flow is based on a multi-node architecture that separates roles like consensus and computation. You can learn more about the Flow architecture [here](https://flow.com/primer#primer-how-flow-works).

Access Nodes are the node type that are most useful for developers, as they provide access to the Flow network via an API. Flow provides public access nodes for multiple networks. They provide two flavours of APIs:

- [HTTP API](https://developers.flow.com/http-api)
- gRPC
    - Mainnet: `access.mainnet.nodes.onflow.org:9000`
    - Testnet: `access.devnet.nodes.onflow.org:9000`
    - [Specification](../references/run-and-secure/nodes/access-api.mdx)

### Running Your Own Node

If you’re getting started you don’t need to run your own node and you can use the above public nodes. The public access nodes are rate-limited, so as your product matures you might want to run your own node. There are multiple options available:

- Start with a [Light (Observer) Node](../references/run-and-secure/node-operation/observer-node.mdx).
- You can also use a third-party provider like [Quicknode](https://www.quicknode.com/docs/flow).

Check out [Running a Node](../references/run-and-secure/node-operation/observer-node.mdx) for more information.

## SDKs and Tools

If you’re already familiar with blockchain development, here's a comparison between popular software packages and Flow's tooling:

- [hardhat](https://hardhat.org/) / [Truffle](https://trufflesuite.com/) / [Foundry](https://github.com/foundry-rs/foundry)
    - [Flow CLI](https://github.com/onflow/flow-cli/) provides local development tools and the [Flow Emulator](https://github.com/onflow/flow-emulator)
- [OpenZeppelin](https://www.openzeppelin.com/)
    - [Emerald OZ](https://oz.ecdao.org/overview)
- [go-ethereum](https://geth.ethereum.org/)
    - [Flow Go SDK](https://github.com/onflow/flow-go-sdk/)
    - [FCL](https://github.com/onflow/fcl-js/) also provides Backend API for Flow in JS
- [web3.js](https://github.com/web3/web3.js)
    - [FCL](https://github.com/onflow/fcl-js/)
    - [flow-cadut](https://github.com/onflow/flow-cadut) provides more utilities for using Flow on Web
- [Remix](https://remix.ethereum.org/)
    - [Flow Playground](https://play.flow.com/) provides basic experimentation on the web
    - [Cadence VSCode Extension](https://marketplace.visualstudio.com/items?itemName=onflow.cadence) is strongly suggested to install for local development
- [Testing Smart Contracts](https://ethereum.org/en/developers/docs/smart-contracts/testing/)
    - [Cadence testing framework](https://cadence-lang.org/docs/testing-framework) enables native tests in Cadence.
    - [overflow](https://github.com/bjartek/overflow) for testing in Go.
    - [js-testing](https://github.com/onflow/flow-js-testing) for testing in JS.---
title: Why Flow
sidebar_label: Why Flow
sidebar_position: 1
---

# Why Flow

Flow is a fast, decentralized, and developer-friendly blockchain designed to be the foundation for a new generation of games, apps, and the [digital assets](https://www.onflow.org/post/flow-blockchain-cadence-programming-language-resources-assets) that power them. It is based on a unique, [multi-role architecture](https://www.onflow.org/primer), and designed to [scale without sharding](https://www.onflow.org/post/flow-blockchain-multi-node-architecture-advantages), allowing for massive improvements in speed and throughput while preserving a developer-friendly, ACID-compliant environment.

## What Makes Flow Unique

- **Multi-role architecture:** Flow's node architecture allows the network to scale to serve billions of users without sharding or reducing the decentralization of consensus.
- **Resource-oriented programming:** Smart contracts on Flow are written in Cadence, an easier and safer programming language for crypto assets and apps.
- **Developer ergonomics:** This network is designed to maximize developer productivity. Examples range from upgradeable smart contracts and built-in logging support to the Flow Emulator.
- **Consumer onboarding:** Flow was designed for mainstream consumers, with payment onramps catalyzing a safe and low-friction path from fiat to crypto.

The following chapters summarize the content in this section. Read on more for details.

## App Development

The [development guide](../tutorials/intro.md) covers the Flow core concepts, including:

- **App Client:** The app client is the interface through which users interact with your app. Web and mobile applications are typical examples of app clients.
- **Smart Contract:** A smart contract is a collection of code deployed to a permanent location on the blockchain that defines the core logic for a dApp.
- **User Account:** A user account is a record on the blockchain that stores the digital assets owned by a single user.
- **Transaction:** A transaction is a code submitted to the blockchain that mutates the state of one or more user accounts and smart contracts.
- **User Wallet:** A user wallet is software or hardware that controls access to a user's account on the blockchain.
- **Script:** A script is a request made to the blockchain that returns information about the state of your dApp's smart contracts.
- **Flow Client Library (FCL):** The Flow Client Library is a framework that provides a standard interface to connect client applications and user wallets.

## Core Contracts

The Flow blockchain implements core functionality using its own smart contract language, [Cadence](https://cadence-lang.org/docs/language/). The core functionality is split into a set of contracts, so-called [core contracts](../references/core-contracts/index.md):

- **Fungible Token:** The FungibleToken contract implements the Fungible Token Standard. It is the second contract ever deployed on Flow.
- **Flow Token:** The FlowToken contract defines the FLOW network token.
- **Flow Fees:** The FlowFees contract is where all the collected flow fees are gathered.
- **Service Account:** tracks transaction fees and deployment permissions and provides convenient methods for Flow Token operations.
- **Staking Table:** The FlowIDTableStaking contract is the central table that manages staked nodes, delegation, and rewards.
- **Epoch Contract:** The FlowEpoch contract is the state machine that manages Epoch phases and emits service events.

## FLOW Token

The [FLOW](../references/core-contracts/03-flow-token.md) token is the native currency for the Flow network. Developers and users can use FLOW to transact on the network. Developers can integrate FLOW directly into their apps for peer-to-peer payments, service charges, or consumer rewards. FLOW can be held, transferred, or transacted peer-to-peer.


## Technical Background

- The [Flow Technical Primer](https://www.onflow.org/primer) is a great place to start to understand how Flow works.
- The [Three technical whitepapers](https://www.onflow.org/technical-paper) are covering the unique innovation behind the Flow blockchain network in-depth.

## Tokenomics

- To understand more about Flow's Token Economics, and the **FLOW token**, you can read the [Flow Token Economics](https://www.onflow.org/flow-token-economics) guide.
- FLOW tokens are Flow's native Fungible Token. To learn more about how to work with them in your applications, go [here](../references/core-contracts/03-flow-token.md).

## More Concepts

If you're a developer, looking to get a better understanding of working with Flow in your applications,
use the 👈 left-hand navigation to explore the concepts pages.---
sidebar_position: 2
title: App Architecture
description: Describes building self-custody and app custody applications on Flow Blockchain.
sidebar_custom_props:
  icon: 🏗️
---

# App Architecture on Flow Blockchain

The Flow blockchain, with its focus on scalability and user-centric design, offers a unique environment for app development. Designed from the ground up, Flow prioritizes user experience, aiming to bridge the gap to mainstream adoption without compromising on decentralization or security.

While the Flow blockchain offers various architectural patterns, the recommended approaches for developers are **Self-Custody** and **App Custody**. These choices align with Flow's ethos of user-centric design and flexibility.

### **Self-Custody Architecture**

In a self-custody architecture, users retain direct control over their private keys and assets. This model emphasizes user sovereignty and decentralization, placing the responsibility of asset management squarely on the user's shoulders. While it offers the highest degree of control, it also demands a certain level of technical knowledge and awareness from the user, which can sometimes lead to a more complex user experience.

![self-custody.png](self-custody.png)

**Architectural Elements**:

- **Wallet**: A wallet where users store their private keys and sign transactions.
- **Frontend**: Interfaces directly with the user and their wallet for signing transactions.
- **Method of Talking to Chain**: Through FCL directly.

**Benefits**:

- **Control**: Users maintain full ownership of their assets and transactions.
- **Security**: Direct management of private keys reduces potential points of failure.

**Considerations**:

- **User Experience**: The direct control model can lead to a more complex user experience, especially for those unfamiliar with blockchain. Typically, all transactions must be approved by the user, which can be cumbersome.
- **Key Management**: Users are solely responsible for managing, backing up, and ensuring the safe generation and storage of their keys.

**Ideal Use Cases**:

- **Decentralized Finance (DeFi)**: Users interacting with financial protocols while maintaining full control.
- **Web3 Native Users**: Those familiar with blockchain technology and key management.

### **App Custody Architecture**

App custody on Flow offers a unique approach to key management and user experience. Unlike traditional app custody solutions on other blockchains, Flow's App Custody architecture introduces features like **[account linking](../../advanced-concepts/account-linking/index.md)** and **[walletless onboarding](../../advanced-concepts/account-linking/child-accounts.md)**. These features ensure that while users enjoy a seamless experience, they still have the option to link their accounts and move their assets freely around the Flow ecosystem, providing a balanced approach to key management.

![app-custody.png](app-custody.png)

**Architectural Elements**:

- **Wallet**: Both user custody and app custody wallets coexist.
- **Frontend**: Interfaces for both wallet types and features for account linking and walletless onboarding.
- **Backend**: Manages app-custody user keys and assets.  Also supports direct blockchain interactions.
- **Method of Interacting with the Chain**: Both direct FCL calls and backend-managed interactions.
- **Payment Rails**: Flexible methods, accommodating both direct and managed transactions.

**Benefits**:

- **Walletless Onboarding**: Users can start interacting with the app using traditional, familiar web2 mechanics without the initial need for a blockchain wallet.
- **Streamlined Experience**: Transactions can be processed without constant user approval, offering a smoother user journey.
- **Open Ecosystem with Account Linking**: Users can link their accounts, ensuring they can move their assets freely around the Flow ecosystem without being locked into a single application.
- **Flexibility**: Cater to both tech-savvy users and newcomers without compromising on security.
- **Platform Versatility**: The abstraction of the user wallet allows for integration with various platforms, including Unity games, consoles, and mobile applications.

**Considerations**:

- **Complexity**: Implementing app custody can be more intricate.
- **Trust**: Users need to trust the dApp with certain aspects of their data and assets.
- **Legal Implications**: Operating with app custody may come with legal considerations, depending on jurisdiction and the nature of the dApp. It's essential to consult with legal professionals to ensure compliance.

**Ideal Use Cases**:

- **Gaming**: Seamless gaming without constant transaction approvals.
- **Social Media Platforms**: Earning tokens for content without initial blockchain familiarity.
- **Loyalty Programs**: Earning rewards without deep blockchain setup.

## Wrapping Up

Selecting the right architecture is crucial when developing an app on the Flow blockchain. Your choice will influence not only the technical aspects but also the user experience and overall trust in your application. While Flow offers the tools and flexibility to cater to various needs, it's up to developers to harness these capabilities effectively. Whether you opt for a self-custody or app custody approach, ensure that your decision aligns with the core objectives of your app and the expectations of your users. Making informed architectural decisions will lay a strong foundation for your app's success.
---
title: Explore More
sidebar_label: Explore More
description: Explore more of the Flow blockchain
sidebar_position: 999
---

import DocCardList from '@theme/DocCardList';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome'
import { faWindowMaximize, faCoins, faGem, faBook } from '@fortawesome/free-solid-svg-icons'


Below are some additional tutorials to help you get started with Flow:

<DocCardList items={[
  {
    type: 'link',
    label: 'Flow App Quickstart',
    href: '/build/guides/flow-app-quickstart',
    description: 'Simple walkthrough building a web3 app using the Flow Client Library (FCL)',
    customProps: {
      icon: <FontAwesomeIcon icon={faWindowMaximize} className="h-16" />,
      author: {
        name: 'Flow Blockchain',
        profileImage:
          'https://avatars.githubusercontent.com/u/62387156?s=200&v=4',
      },
    },
  },
  {
    type: 'link',
    label: 'Fungible Token Guide',
    href: '/build/guides/fungible-token',
    description: 'Steps to create, deploy, mint, and transfer fungible tokens on Flow',
    customProps: {
      icon: <FontAwesomeIcon icon={faCoins} className="h-16" />,
      author: {
        name: 'Flow Blockchain',
        profileImage:
          'https://avatars.githubusercontent.com/u/62387156?s=200&v=4',
      },
    },
  },
  {
    type: 'link',
    label: 'NFT Guide',
    href: 'https://academy.ecdao.org/en/quickstarts/1-non-fungible-token',
    description: 'A DApp that lets users create an empty collection, mint some pre-loaded NFTs, and transfer them to another account on Flow testnet.',
    customProps: {
      icon: <FontAwesomeIcon icon={faGem} className="h-16" />,
      author: {
        name: 'Emerald City DAO',
        profileImage:
          'https://pbs.twimg.com/profile_images/1687225095557632005/tUCmv8_P_400x400.jpg',
      },
    },
  },
  {
    type: 'link',
    label: 'Walkthrough Guides',
    href: '/build/guides/flow-app-quickstart',
    description: 'Longer form guides to help you get started with Flow',
    customProps: {
      icon: <FontAwesomeIcon icon={faBook} className="h-16" />,
      author: {
        name: 'Flow Blockchain',
        profileImage:
          'https://avatars.githubusercontent.com/u/62387156?s=200&v=4',
      },
    },
  },
  {
    type: 'link',
    label: 'Emerald Academy',
    href: 'https://academy.ecdao.org/en/quickstarts',
    description: 'Quickstart Tutorials for Flow created by Emerald City Dao',
    customProps: {
      icon: '/images/logos/ea-logo.png',
      author: {
        name: 'Emerald City DAO',
        profileImage:
          'https://pbs.twimg.com/profile_images/1687225095557632005/tUCmv8_P_400x400.jpg',
      },
    },
  }
]} />
---
sidebar_position: 3
---

# Hello World Pt. 3 - Interacting with the Blockchain

Flow Client Library (FCL), is a JavaScript library developed to facilitate interactions with the Flow blockchain. It provides developers with tools to build, integrate, and interact with Flow directly from web applications. This web app quickstart will get you interacting with a contract already deployed to Flow.

For this tutorial, we're going to be making a [React](https://react.dev/learn) app with [Create React App](https://create-react-app.dev/). We'll try and keep the code as simple as possible in case you're coming from another framework.

First, let's create our app and then navigate to it with the following terminal commands:

```
npx create-react-app fcl-app-quickstart
cd fcl-app-quickstart
```

It comes with a default layout, but let's remove it in `src/App.js` with something simple. Copy and paste this:

```
// src/App.js

import './App.css';

function App() {
    return (
        <div className="App">
            <div>FCL App Quickstart</div>
        </div>
    );
}

export default App;
```

Now let's run our app with the following `npm` command:

```
npm start
```

## Setting Up FCL

In order to use FCL, we need to install it. Let's run the following to download the library and set it as a dependency in our project:

```
npm install @onflow/fcl --save
```

Next we'll want to add to our FCL configuration. There's a lot you can do here, but for this simple example, let's configure `accessNode.api` to talk to the Testnet Flow Access Node. An Access Node serves as the primary point of interaction for clients, such as wallets, dapps, and other services, to communicate with the Flow network. It provides a gateway for these clients to submit transactions, query data, and retrieve information without having to connect to the entire network or maintain a full copy of the blockchain.

For our example, we are going to point at a free Access Node provided by Flow. Add the following config code to your `src/App.js`

```
// src/App.js

import * as fcl from '@onflow/fcl'

fcl.config({
  'accessNode.api': 'https://rest-testnet.onflow.org'
})
```

## Querying the Chain

On Flow, you can interact with a contract by reading from the chain with a script or changing its state with a transaction. Reading is free and is done with FCL by passing a Cadence (the smart contract language of Flow) script to `fcl.query`. For our example we are going to read from a `HelloWorld` contract deployed to the account `0x9dca641e9a4b691b` on `testnet` (you can [view the contract here](https://f.dnz.dev/0x9dca641e9a4b691b/HelloWorld) to see what it looks like).

In the same `src/App.js` file, let's create app state to store our greeting and query the chain when the component renders in order to fetch the greeting state from the `HelloWorld` contract.

```
const [greeting, setGreeting] = useState("");

useEffect(() => {
  const queryChain = async () => {
    const res = await fcl.query({
      cadence: `
        import HelloWorld from 0x9dca641e9a4b691b

        pub fun main(): String {
          return HelloWorld.greeting
        }
    `
    });

    console.log(res);
    setGreeting(res);
  }

  queryChain();
}, []);
```

At this point our entire `src/App.js` file should look like this:

```
import { useEffect, useState } from 'react';
import './App.css';
import * as fcl from '@onflow/fcl';

fcl.config({
    'accessNode.api': 'https://rest-testnet.onflow.org'
});

function App() {
    const [greeting, setGreeting] = useState("");

    useEffect(() => {
        const queryChain = async () => {
            const res = await fcl.query({
                cadence: `
                    import HelloWorld from 0x9dca641e9a4b691b

                    pub fun main(): String {
                        return HelloWorld.greeting
                    }
                `
            });

            console.log(res);
            setGreeting(res);
        };

        queryChain();
    }, []);

    return (
        <div className="App">
            <div>FCL App Quickstart</div>
            <div>{greeting}</div>
        </div>
    );
}

export default App;
```

You just built an app on Flow!

## Mutating Chain State and More

For a deeper dive into writing an FCL app, such as how to change the chain state with FCL, check out [this guide](../../guides/flow-app-quickstart.md) or the [FCL documentation](../../../tools/clients/fcl-js/index.md).---
sidebar_position: 2
---

# Hello World Pt. 2 - Local Development

The Flow Command Line Interface (CLI) is a set of tools that developers can use to interact with the Flow blockchain by managing accounts, sending transactions, deploying smart contracts, running the emulator, and more. This quickstart will get you familiar with its main concepts and functionality.

## Installation

The first thing you'll need to do is install the Flow CLI. If you have [homebrew](https://brew.sh/) installed you can run:

```
brew install flow-cli
```

For other ways of installing, please [refer to the installation guide](../../../tools/flow-cli/install.md).

## Configuration

Let's first create a directory, then set up a project.

```
mkdir cli-quickstart
```

And then let's navigate to our new directory:

```
cd cli-quickstart
```

Let's first create a `flow.json` file for our project. We'll use this in a later step, but this is a good spot to bring it up. The `flow.json` file is a configuration file used by the Flow CLI when interacting with the Flow blockchain. It helps manage various project-specific settings, such as network configurations, account details, contract names and source files, and deployment targets. To create one, run:

```
flow init
```

If you look at `flow.json` now, you'll see its listed access nodes for networks and accounts. The default `emulator-account` create will come in handy when we want to run the emulator.

## Running Scripts

On Flow, scripts are used to read data from the Flow blockchain. There is no state modification. In our case, we are going to read a greeting from a contract deployed to `testnet` called `HelloWorld`. (You can [view the contract here](https://f.dnz.dev/0x9dca641e9a4b691b/HelloWorld))

Let's create a script file:

```
touch script.cdc
```

Then in the script file, let's put the following code:

```
import HelloWorld from 0x9dca641e9a4b691b

pub fun main(): String {
  return HelloWorld.greeting
}

```

In the above example, `0x9dca641e9a4b691b` is the address where the `HelloWorld` contract has been deployed to on `testnet`. (Note: if you'll like to learn more about writing scripts, please [read here](../../basics/scripts.md)).

To run the script, we'll run this from the CLI:

```
flow scripts execute script.cdc --network testnet
```

You should see the result of the greeting. `Result: "Hello, world!"`

## Running the Contract Locally on Emulator

The Flow Emulator is a local, lightweight, and standalone version of the Flow blockchain. It's designed to provide developers with a local environment for testing and development purposes without having to interact with the `mainnet` or `testnet`. This makes it easier and faster to develop, test, and debug smart contracts and apps.

In order to use it, let's update our project configuration. 

Let's create a local version of the HelloWorld contract. We'll deploy it to the emulator, Run:

```
touch HelloWorld.cdc
```

Copy the contract to `HelloWorld.cdc`. Then let's add the contract into our project by updating `flow.json`. 

```
pub contract HelloWorld {

  pub var greeting: String

  pub fun changeGreeting(newGreeting: String) {
    self.greeting = newGreeting
  }

  init() {
    self.greeting = "Hello, World!"
  }
}

```

Next we'll add a contracts section to our `flow.json` configuration that will describe our project setup. We'll state the contract file location lives with `source` and then define `aliases` for the addresses of the deployed contracts.

```
// flow.json

{
...
"contracts": {
  "HelloWorld": {
    "source": "HelloWorld.cdc",
    "aliases": {
      "testnet": "0x9dca641e9a4b691b"
    }
  }
}
...
}
```

We're also going to change the imports of our script so that there are no hardcoded network specific addresses. The CLI can figure out how to interact with the network (i.e. emulator, testnet or mainnet) based on our configuration.

```
// script.cdc

import "HelloWorld"

pub fun main(): String {
  return HelloWorld.greeting
}

```

Next, we'll add a deployments section to `flow.json` and define what account we'd like what contract deployed to and on what network. In this case, let's deploy the `HelloWorld` contract to the `emulator` network and on `emulator-account` provided.

```
// flow.json

{
...
"deployments": {
  "emulator": {
    "emulator-account": ["HelloWorld"]
}
...
}
```

Next let's run the emulator in a new terminal with:

```
flow emulator start
```

And then deploy the contract with:

```
flow project deploy
```

Now if we run the following script we should see the result of the script against our emulator deployed contract.

```
flow scripts execute script.cdc --network emulator
```

## Creating an Account and Running a Transaction

To change state on the Flow Blockchain, you need to run a transaction. Let's create a simple transaction file. We can use to modify the `greeting` on the `HelloWorld` contract.

First, create a file called `transaction.cdc` from the root of your project:

```
touch transaction.cdc
```

Then copy the following code:

```
import "HelloWorld"

transaction(greeting: String) {

  prepare(acct: AuthAccount) {
    log(acct.address)
  }

  execute {
    HelloWorld.changeGreeting(newGreeting: greeting)
  }
}
```

This will log the account signing the transaction, call the `changeGreeting` method of the `HelloWorld` contract, and pass in the new greeting. (If you want to learn more about writing transactions, please [read here](../../basics/transactions.md)).

In order to run a transaction, the signing account needs to pay for it. We could run a transaction on emulator using the default `emulator-account` account. Let's learn one more command for creating accounts.

The easiest way to create an account using CLI is by running (remember, your emulator should still be running at this point in another terminal):

```
flow accounts create
```

Once that runs, select `Emulator` as the network and give your account the name `emulator-tester`. You'll now see this account in your `flow.json`.

To run a transaction with this new account, you can run the following:

```
flow transactions send ./transaction.cdc "Hello, me" --signer emulator-tester --network emulator
```

You've just modified the state of the Flow Blockchain!

## Next Steps

Dive deeper by checking out the scaffolds generated by the Flow CLI. They can serve as a great starting point for any project you're trying to create. See how to [create a scaffold here](../../../tools/flow-cli/index.md).---
sidebar_position: 1
---
import VerticalSplit from "./vertical-split.svg"

# Hello World Pt. 1 - Basics

Welcome to the Flow blockchain! In this quickstart guide, you'll interact with your first smart contract on our `Testnet`. For those unfamiliar, the Testnet is a public instance of the Flow blockchain designed for experimentation. Here, you can deploy and invoke smart contracts without incurring any real-world costs. 

Smart contracts on Flow are permanent code that live on the blockchain, allowing you to encode business logic, define digital assets, and much more.


## Calling a contract

The `HelloWorld` contract exposes a public variable named `greeting`. We can retrieve its value using a simple script written in the Cadence programming language.

```
import HelloWorld from 0x9dca641e9a4b691b

pub fun main(): String {
  return HelloWorld.greeting
}
```
 - `Click` <VerticalSplit /> To vertically orient Flow Runner editor. 
 - `Copy` the script above into Flow Runner input area and click "Run". 
 - See the output returned by the script. 

<iframe sandbox className="flow-runner-iframe" src="https://run.dnz.dev/" width="100%" height="400px"></iframe>

## Contract on Testnet

Below is the source code for the HelloWorld contract. As you continue through the next few tutorials, you'll discover how to invoke the `changeGreeting` function to modify the greeting value. Do take note, however, that only the contract's `owner` or permitted accounts can modify the greeting.
```
pub contract HelloWorld {

  pub var greeting: String

  access(account) fun changeGreeting(newGreeting: String) {
    self.greeting = newGreeting
  }

  init() {
    self.greeting = "Hello, World!"
  }
}

```
<Callout type="info">
There are no `read` costs associated with calling contracts. 
</Callout>

Continue to create your own contracts and get them deployed live with Flow CLI!

---
title: Flow App Quickstart
sidebar_label: Flow App Quickstart
description: Building an application on Flow
sidebar_position: 4
sidebar_custom_props:
  icon: 🏗️
---

# Flow App Quickstart

---

This guide is a simple walkthrough to get started building a web3 app using the Flow Client Library (FCL).

<Callout type="info">
If you are looking for a scalfolds, check out [scaffolds available in the Flow CLI](../../tools/flow-cli/super-commands.md#using-scaffolds).
</Callout>

This simple guide uses the "Hello World" scaffold, it is meant to provide all the code needed to get a web application up and running.

## Introduction

![Flow app anatomy](flow-dapp-anatomy.png)

<Callout type="info">
FCL (aka Flow Client Library) wraps the logic needed to communicate with the Flow blockchain. It's a npm package, [More Information](../../tools/clients/fcl-js)
</Callout>

This guide assumes a good understanding of React. The concepts are easy to understand and apply to other libraries and framework. A strong understanding of Cadence (Flow's smart contract language) is not required. More information on Cadence, [learning the Cadence language](./smart-contracts/cadence.md).

### FCL concepts covered:

- [Installation](#installation)
- [Configuration](#configuration)
- [Authenticate a user](#authenticate-a-user)
- [Deploy contracts](#deploy-contracts)
- [Query the Blockchain](#query-the-blockchain)
- [Mutate the Blockchain](#mutate-the-blockchain)

For more help, [Discord](https://discord.gg/flow). See links at the end of this article for diving deeper into building on Flow.

## Installation

Make sure you have Flow CLI installed. [installation instructions](../../tools/flow-cli/install.md).

## Configuration

### Setting up Flow

Using the Flow CLI scaffold, create a basic hello world web project with `Web Scaffolds` -> `[5] FCL Web Dapp`. This will create a new `flow.json` file in the `hello-world` folder. This file will contain the Flow configuration for your project.

```sh
flow setup hello-world --scaffold
# select scaffold 5
cd hello-world
npm install
# run the app in a later step
```

We don't recommend keeping private keys in your `flow.json`, notice that Flow CLI already moved the emulator private key to a `emulator.key` file and point to it using the [key/location pattern](../../tools/flow-cli/flow.json/security.md#private-account-configuration-file). This file should be added to your `.gitignore` file, so it won't be committed to your repository. 

We won't be using emulator and running contracts locally in this quickstart, but FCL will complain if it finds private keys in your `flow.json` file.

Your `flow.json` file should look like this:

```
{
	"networks": {
		"emulator": "127.0.0.1:3569",
		"mainnet": "access.mainnet.nodes.onflow.org:9000",
		"sandboxnet": "access.sandboxnet.nodes.onflow.org:9000",
		"testnet": "access.devnet.nodes.onflow.org:9000"
	},
	"accounts": {
		"emulator-account": {
			"address": "f8d6e0586b0a20c7",
			"key": {
				"type": "file",
				"location": "./emulator.key"
			}
		}
	}
}
```

<Callout type="info">
The `flow.json` file is used to keep track of deployed contracts and accounts. [More Information](../../tools/clients/fcl-js/api#using-flowjson)
</Callout>


### Configuring FCL

Next, notice `@onflow/fcl` has been added to the `package.json` and the web application is ready to be run. 

<Callout type="info">
There are a lot of benefits to getting familiar with existing Flow CLI scaffolds. For example the `hello-world` scaffold already has fcl configuration settings to run on local emulator. 
</Callout>


The `hello-world` web application comes with convenience npm commands to facilitate a quick start. The following command will preform: 
  1. Start emulator
  2. Start dev wallet
  3. Start web app

<Callout type="info">
Emulator is a local blockchain [More Information](../../tools/emulator/index.md). Emulator has all the features as testnet and mainnet blockchains 
</Callout>

```sh
npm run dev:local
```

Now that your app is running. FCL loads the configuration in `config/fcl.ts` This file contains configuration information for FCL, such as what Access Node and wallet discovery endpoint and which network to use (e.g. testnet or a local emulator). 

- `accessNode.api` key specifies the address of a Flow access node. There are publically available access nodes, but have to rate limit. Alternatively, applications might want to run an Observer node [Run a Node](../../references/run-and-secure/node-operation/observer-node.mdx).
- `discovery.wallet` is an address that points to a service that lists FCL compatible wallets. Flow's FCL Discovery service is a service that FCL wallet providers can be added to, and be made 'discoverable' to any application that uses the `discovery.wallet` endpoint.

Also, notice that `package.json` uses `NEXT_PUBLIC_FLOW_NETWORK=local` for `dev` command, this is used to set the network in `config/fcl.ts`.
<Callout type="info">
Learn more about [configuring Discovery](../../tools/clients/fcl-js/discovery.mdx) or [setting configuration values](../../tools/clients/fcl-js/api.md#setting-configuration-values).
</Callout>

The main Next.js app component is located in `pages/_app.tsx`. It should import the config file `config/fcl.ts` already and should look like this:

```jsx
import '../styles/globals.css'
import DefaultLayout from '../layouts/DefaultLayout'

// Import FCL config
import '../config/fcl'

function MyApp({ Component, pageProps }) {
  return (
    <DefaultLayout>
      <Component {...pageProps} />
    </DefaultLayout>
  )
}

export default MyApp

```

The main page for the Next.js app is located in `pages/index.tsx`. It should contain some basic UI and should look like this:

```jsx
import Head from 'next/head'
import styles from '../styles/Home.module.css'
import Links from '../components/Links'
import Container from '../components/Container'
import useCurrentUser from '../hooks/useCurrentUser'

export default function Home() {
  const { loggedIn } = useCurrentUser()

  return (
    <div className={styles.container}>

      <Head>
        <title>FCL Next Scaffold</title>
        <meta name="description" content="FCL Next Scaffold for the Flow Blockchain" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className={styles.main}>
        <h1 className={styles.title}>
          <a href="https://developers.flow.com/tools/fcl-js">FCL</a> Next Scaffold
        </h1>

        <p className={styles.description}>
          For the Flow Blockchain
        </p>

        {loggedIn && <Container />}

        <Links />

      </main>
    </div>
  )
}

```

Now we're ready to start talking to Flow! 
<Callout type="warning">
The web app will run, but there are no contracts deployed to local emulator. This is a step in [Query the Blockchain](#query-the-blockchain) section. 
</Callout>

## Authenticate a User

![User Login](./user-login-hello-world.gif)

Note: in the code above `useCurrentUser` is used to determine if there is a logged in user. 

There are two methods to allow the user to login. `fcl.logIn()` or `fcl.authenticate()` [More Information on, authenticate](../../tools/clients/fcl-js/api#authenticate)

In `components/Navbar.tsx` a button wires up the authentication method `fcl.authenticate()`. It is used to bring up the list of supported wallets. See below

Once authenticated, FCL uses a hook `const user = useCurrentUser()` to get the user data, when user is signed in `user.loggedIn` flag is `true`. For more information on the `currentUser`, read more [here](../../tools/clients/fcl-js/api.md#current-user).

```jsx
import Head from 'next/head'
import * as fcl from '@onflow/fcl'
import useCurrentUser from '../hooks/useCurrentUser'
import navbarStyles from '../styles/Navbar.module.css'
import elementStyles from '../styles/Elements.module.css'

export default function Navbar() {
  const user = useCurrentUser()

  return (
    <div className={navbarStyles.navbar}>
      {!user.loggedIn && 
        <button 
          onClick={fcl.authenticate} 
          className={elementStyles.button}>
          Log In With Wallet
        </button>
      }
      {user.loggedIn && 
        (
          <>
            <div className={navbarStyles.address}>{ user?.addr }</div>
            <button 
              onClick={fcl.unauthenticate} 
              className={elementStyles.button}>
              Log Out
            </button>
          </>
        )
      }
    </div>
  )
}

```

You should now be able to log in or sign up users and unauthenticate them. Upon logging in or signing up your users will see a popup where they can choose between wallet providers. Choose the `dev wallet` to use the same account that deployed the `HelloWorld` contract, this is needed for mutation. Upon completing authentication, you'll see the component change and the user's wallet address appear on the screen if you've completed this properly.

<Callout type="info">
More on wallets, [Flow Core wallet](https://core.flow.com/) is a Reference Flow wallet. 
</Callout>

## Deploy contracts

Hello World scaffold does come with a Cadence contract. You will notice `HelloWorld.cdc` has been deployed when running `npm run dev:local`. Look at hello-world `package.json` to see the commands that get run, `flow dev` deploys contracts to the emulator.
In the `flow.json` make sure the emulator endpoint is correct. Look at the terminal the emulator is running, 

![Emulator Output](./emulator-output.png)

1. Make sure the emulator is using the same port as `gRPC` and 
2. The `deployment` section of `flow.json` should look something like this: 
```json
  ...
	"networks": {
		"emulator": "127.0.0.1:3569",
    ...
  },
	"deployments": {
		"emulator": {
			"default": [
				"HelloWorld"
			]
		}	
}	

```

Verify that `flow.json` updates with HelloWorld contract information, `contracts` has the `HelloWorld` contract and `deployments` shows that `HelloWorld` has been deployed.


```json
{
	"contracts": {
		"HelloWorld": "cadence/contracts/HelloWorld.cdc"
	},
	"networks": {
		"emulator": "127.0.0.1:3569",
		"mainnet": "access.mainnet.nodes.onflow.org:9000",
		"testnet": "access.devnet.nodes.onflow.org:9000"
	},
	"accounts": {
		"default": {
			"address": "01cf0e2f2f715450",
			"key": "..."
		},
		"emulator-account": {
			"address": "f8d6e0586b0a20c7",
			"key": {
				"type": "file",
				"location": "./emulator.key"
			}
		}
	},
	"deployments": {
		"emulator": {
			"default": [
				"HelloWorld"
			]
		}
	}
}
```

For more information on deployments check [Flow CLI](../../tools/flow-cli/flow.json/manage-configuration.md) documentation

## Query the Blockchain

Now that all pieces are in place. UI can query `HelloWorld` contract.


![Query HelloWorld Contract](./query-helloWorld-contract.gif)


The script that queries the Hello World contract is located `hello-world/cadence/scripts/ReadHelloWorld.cdc`

```cadence
import "HelloWorld"

pub fun main(): String {
  return HelloWorld.greeting
}
```

In `components/Container.tsx` file, `fcl.query` is used to set the Cadence script and query the contract.

```jsx

  const queryChain = async () => {
    const res = await fcl.query({
      cadence: ReadHelloWorld
    })

    setChainGreeting(res)
  }
```

It is that simple!

## Mutate the Blockchain

Update the `HelloWorld` contract greeting. Notice that Greeting gets changed when the transaction gets processed.

![Update contract](./hello-world-update-contract.gif)


In `components/Container.tsx` file, the `mutateGreeting` method `fcl.mutate` sends `UpdateHelloWorld` cadence which triggers a transaction that the user signs.

```javascript
 const mutateGreeting = async (event) => {
    event.preventDefault()

    if (!userGreetingInput.length) {
      throw new Error('Please add a new greeting string.')
    }

    const transactionId = await fcl.mutate({
      cadence: UpdateHelloWorld,
      args: (arg, t) => [arg(userGreetingInput, t.String)],
    })

    setLastTransactionId(transactionId)
  }

```

## More information

That's it! You now have Flow app that uses auth, query and mutate the chain. This is just the beginning. There is so much more to know. Next steps:

**Cadence**
- [Cadence Playground Tutorials](https://cadence-lang.org/docs/tutorial/first-steps)
- [Cadence Hello World Video](https://www.youtube.com/watch?v=pRz7EzrWchs)
- [Why Cadence?](https://www.onflow.org/post/flow-blockchain-cadence-programming-language-resources-assets)

**FCL Scaffolds**
- [FCL Next TypeScript Scaffold](https://github.com/chasefleming/fcl-next-scaffold)
- [FCL React Native Scaffold](https://github.com/jribbink/fcl-react-native-scaffold)

**Full Stack NFT Marketplace Example**
- [Beginner Example: CryptoDappy](https://github.com/bebner/crypto-dappy)

**More FCL**
- [FCL API Quick Reference](../../tools/clients/fcl-js/api)
- [More on Scripts](../../tools/clients/fcl-js/scripts.mdx)
- [More on Transactions](../../tools/clients/fcl-js/transactions.mdx)
- [User Signatures](../../tools/clients/fcl-js/user-signatures.mdx)
- [Proving Account Ownership](../../tools/clients/fcl-js/proving-authentication.mdx)

**Other**
- [Flow Developer Onboarding Guide](../../tutorials/intro.md)
---
title: Flow CLI
sidebar_label: Install Flow CLI
description: Guide to installing and using Flow CLI
sidebar_position: 5
---

## MacOS

### Homebrew

```sh
brew install flow-cli
```

### From a pre-built binary

_This installation method only works on x86-64._

This script downloads and installs the appropriate binary for your system:

```sh
sh -ci "$(curl -fsSL https://raw.githubusercontent.com/onflow/flow-cli/master/install.sh)"
```

To update, simply re-run the installation command above.

It is currently not possible to install earlier versions of the Flow CLI with Homebrew.

## Linux

### From a pre-built binary

_This installation method only works on x86-64._

This script downloads and installs the appropriate binary for your system:

```sh
sh -ci "$(curl -fsSL https://raw.githubusercontent.com/onflow/flow-cli/master/install.sh)"
```

To update, simply re-run the installation command above.

### Install a specific version

To install a specific version of Flow CLI newer than v0.42.0, append the version tag to the command (e.g. the command below installs CLI version v0.44.0).

```sh
sh -ci "$(curl -fsSL https://raw.githubusercontent.com/onflow/flow-cli/master/install.sh)" -- v0.44.0
```

To install a version older than v0.42.0, refer to [Installing versions before 0.42.0](../../tools/flow-cli/install.md#installing-versions-before-0420) below.

## Windows

### From a pre-built binary

_This installation method only works on Windows 10, 8.1, or 7 (SP1, with [PowerShell 3.0](https://www.microsoft.com/en-ca/download/details.aspx?id=34595)), on x86-64._

1. Open PowerShell ([Instructions](https://docs.microsoft.com/en-us/powershell/scripting/install/installing-windows-powershell?view=powershell-7#finding-powershell-in-windows-10-81-80-and-7))
2. In PowerShell, run:

    ```powershell
    iex "& { $(irm 'https://raw.githubusercontent.com/onflow/flow-cli/master/install.ps1') }"
    ```

To update, simply re-run the installation command above.


## Create your first project
With the Flow CLI super commands, initiating your new project becomes effortless. Execute the flow setup 
command and make a selection from a variety of accessible scaffolds:
```
> flow setup hello-world --scaffold

🔨 General Scaffolds
   [1] Empty Cadence Project - Empty project containing only basic folder structure and flow.json configuration.
   [2] Simple Cadence Project - Scaffold contains required folder structure as well as some example Cadence code.
   [3] Cadence NFT Project - Scaffold contains the ExampleNFT sample NFT contract.
   [4] Hybrid Custody Project - Starter for exploring & implementing Hybrid Custody.

💻 Web Scaffolds
   [5] FCL Web Dapp - Simple TypeScript web application using next.js, FCL, and Cadence.

📱 Mobile Scaffolds
   [6] Swift iOS simple example - iOS example demonstrating usage of FCL and Flow interactions.
   [7] Android simple example - Android example demonstrating usage of FCL and Flow interactions.
   [8] FCL React Native Mobile Dapp - React Native (Expo) mobile dapp example demonstrating FCL and Flow interactions.

🏀 Unity Scaffolds
   [9] Simple Unity - Simple example demonstrating how to interact with the Flow network using Unity SDK.
   [10] Mobile Unity Game - Example words game built on Flow using the Unity SDK.
```

After you have created your new project, you can proceed to writing contracts. Once your contracts have been written, run the `flow dev` command the CLI will deploy them to the Flow emulator. Flow emulator is 
a simplified version of Flow network that runs locally. It makes writing, deploying and testing contracts easier.

So proceed by starting the emulator: 

```
> flow emulator
```

And then the flow dev:
```
> flow dev
```

### Next steps

As part of the next steps you can read more about [flow dev command](../../tools/flow-cli/super-commands.md).
---
title: How to Create a Fungible Token on Flow
sidebar_label: Create a Fungible Token
description: Guide to creating a fungible token on Flow with the Flow CLI and Cadence.
sidebar_position: 2
---

This article will guide you through the steps to create, deploy, mint, and transfer fungible tokens on Flow.

## What are Fungible Tokens?

Fungible tokens are digital assets that are interchangeable and indistinguishable with other tokens of the same type. This means that each token is identical in specification to every other token in circulation. Think of them like traditional money; every dollar bill has the same value as every other dollar bill. Fungible tokens play a crucial role in web3 ecosystems, serving as both a means of payment and an incentive for network participation. They can take on various roles including currencies, structured financial instruments, shares of index funds, and even voting rights in decentralized autonomous organizations.

## Vaults on Flow

On the Flow blockchain, fungible tokens are stored in structures called vaults. Think of a vault as a digital piggy bank. When you transfer tokens from one vault to another:

1. A temporary vault (or a temporary piggy bank) is created holding the transfer amount.
2. The original vault's balance decreases by the transfer amount.
3. The recipient's vault receives the tokens from the temporary vault.
4. The temporary vault is then deleted.

This process ensures secure and accurate token transfers on the Flow blockchain.

## Fungible Token Standard

The [Fungible Token Standard](https://github.com/onflow/flow-ft) defines what a fungible token should look like on Flow. Wallets and other platforms need to recognize these tokens, so they adhere to a specific interface, which defines fields like balance, totalSupply, withdraw functionality, and more. This interface ensures that all fungible tokens on Flow have a consistent structure and behavior. [Learn more about interfaces here](https://developers.flow.com/cadence/language/interfaces).

## Creating Our Project

To get started making our fungible token, let's first create a project directory in our terminal and go to it. We'll call it FooToken.

```bash
mkdir FooToken
cd FooToken
```

Next, we'll initialize a project using the Flow CLI, which will create a configuration file named **`flow.json`**. This file configures the Flow CLI for the Flow blockchain, handling settings such as network details, accounts, and contracts. 

If you haven't installed the Flow CLI yet and have [homebrew](https://brew.sh/) installed you can run `brew install flow-cli`. If you don’t have homebrew, please follow [the installation guide here](https://developers.flow.com/tools/flow-cli/install).

```bash
flow init
```

In our `flow.json` for the network we want to use, we are going to state the address the Fungible Token is deployed to via `aliases` in a new `contracts` section. Since it is a standard contract, it has already been deployed to the emulator, a tool that runs and emulates a local development version of the Flow Blockchain, for us. You can find addresses for other networks, like Testnet and Mainnet, on the [Fungible Token Standard repo](https://github.com/onflow/flow-ft).

```json
"contracts": {
  "FungibleToken": {
    "aliases": {
      "emulator": "0xee82856bf20e2aa6"
    }
  }
}
```

## Writing Our Token Contract

Next let's create a directory and a file for our new FooToken contract.

```bash
mkdir cadence
mkdir cadence/contracts
touch cadence/contracts/FooToken.cdc
```

In this contract file, we want to import our `FungibleToken` contract that we've defined in `flow.json`.

```cadence
import "FungibleToken"
```

In this same file, let's create our contract which implements the `FungibleToken` contract Interface (it does so by setting it following the `FooToken:`). In our `init` — which runs on the contracts first deployment and is used to set initial values — let’s set an starting total supply of 1,000 tokens for this example.

```cadence
// ...previous code

pub contract FooToken: FungibleToken {
  pub var totalSupply: UFix64

  init() {
    self.totalSupply = 1000.0
  }
}
```

### Creating a Vault

Inside of this contract, we'll need to create a resource for a Vault. A resource is a special type to Cadence (our smart contract language) which represents a unique value. We also want to have it implement the Provider, Receiver, and Balance sections of the FungibleToken contract, as well as allow us to set the initial balance of the vault.

```cadence
import "FungibleToken"

pub contract FooToken: FungibleToken {
    // ...totalSupply code

    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {
        pub var balance: UFix64

        init(balance: UFix64) {
            self.balance = balance
        }
    }

    // ...init code
}
```

In order to give an account a vault, we need to create a function that creates a vault of our FooToken type and returns it to the account.

```cadence
import "FungibleToken"

pub contract FooToken: FungibleToken {
    // ...other code

    pub fun createEmptyVault(): @FooToken.Vault {
        return <- create Vault(balance: 0.0)
    }

    // ...init code
}
```

The standard also wants us to implement the events required for creating a token. These will tell us when a token has been initialized, withdrawn, or deposited. Let's add these to the top of the contract.

```cadence
import "FungibleToken"

pub contract FooToken: FungibleToken {
    
    pub event TokensInitialized(initialSupply: UFix64)
    pub event TokensWithdrawn(amount: UFix64, from: Address?)
    pub event TokensDeposited(amount: UFix64, to: Address?)

    // ...all other code
}
```

Inside our `Vault` resource, we also need a way to withdraw balances. To do that, we need to create a new vault with the transfer amount and decrement the existing balance. Let’s also emit an event for this action:

```cadence
import "FungibleToken"

pub contract FooToken: FungibleToken {

    // ...previous code

    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {

        // ...other vault code

        pub fun withdraw(amount: UFix64): @Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)
            return <- create Vault(balance: amount)
        }

        // ...vault init code

    }

    // ...additional code
}
```

In addition to withdrawing, the vault also needs a way to deposit. We'll again emit the appropriate event, as well as [typecast](https://developers.flow.com/cadence/language/operators#casting-operators) to make sure we are dealing with the correct token, update the vault balance, and destroy the vault. We also need to set the balance to 0 in the current vault so that the destroy method is not triggered. Add this code to your resource:

```cadence
import "FungibleToken"

pub contract FooToken: FungibleToken {

    // ...previous code

    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {

        // ...other vault code

        pub fun deposit(from: @FungibleToken.Vault) {
            let vault <- from as! @FooToken.Vault // typecast to make sure we are using the correct token type

            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)

            self.balance = self.balance + vault.balance
            vault.balance = 0.0 // Before the vault is destroyed, set the balance to zero so the totalSupply isn't affected in the destroy method
            destroy vault
        }

        // ...vault init

    }

    // ...additional code
}
```

The destroy call is an important thing to handle though since if anyone ever does destroy their vault, we'll want to change the total supply of the token. You can add this inside of your `Vault` resource as well.

```cadence
import "FungibleToken"

pub contract FooToken: FungibleToken {

    // ...previous code

    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {

        // ...other vault code

        destroy() {
            FooToken.totalSupply = FooToken.totalSupply - self.balance
        }

    }

    // ...additional code
}
```

### Creating a Minter

Let's create a minter resource which is used to mint vaults that have tokens in them. We can keep track of tokens we are minting with totalSupply

If we want the ability to create new tokens, we'll need a way to mint them. To do that, let's create another resource on the `FooToken` contract.  This will have a `mintToken`function which can increase the total supply of the token.

```cadence
import "FungibleToken"

pub contract FooToken: FungibleToken {

    // ...additional contract code

    pub resource Minter {
        pub fun mintToken(amount: UFix64): @FungibleToken.Vault {
            FooToken.totalSupply = FooToken.totalSupply + amount
            return <- create Vault(balance: amount)
        }

        init() {}
    }

    // ...additional contract code
}
```

We also want to decide which account/s we want to give this ability to. In our example, we'll give it to the account where the contract is deployed. We can set this in the contract init function below the setting of total supply so that when the contract is created the minter is stored on the same account.

```cadence
import "FungibleToken"

pub contract FooToken: FungibleToken {

    // ...additional contract code

    init() {
        self.totalSupply = 1000.0 // existed before
        self.account.save(<- create Minter(), to: /storage/Minter)
    }
}
```

After each of these steps, your `FooToken.cdc` contract file should now look like this:

```cadence
import "FungibleToken"

pub contract FooToken: FungibleToken {

    pub event TokensInitialized(initialSupply: UFix64)
    pub event TokensWithdrawn(amount: UFix64, from: Address?)
    pub event TokensDeposited(amount: UFix64, to: Address?)
    pub var totalSupply: UFix64

    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {
        pub var balance: UFix64

        pub fun deposit(from: @FungibleToken.Vault) {
            let vault <- from as! @FooToken.Vault
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)
            self.balance = self.balance + vault.balance
            vault.balance = 0.0
            destroy vault
        }

        pub fun withdraw(amount: UFix64): @Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)
            return <- create Vault(balance: amount)
        }

        destroy() {
            FooToken.totalSupply = FooToken.totalSupply - self.balance
        }

        init(balance: UFix64) {
            self.balance = balance
        }
    }

    pub resource Minter {
        pub fun mintToken(amount: UFix64): @FungibleToken.Vault {
            FooToken.totalSupply = FooToken.totalSupply + amount
            return <- create Vault(balance: amount)
        }

        init(){}
    }

    pub fun createEmptyVault(): @FooToken.Vault {
        return <- create Vault(balance: 0.0)
    }

    init() {
        self.totalSupply = 1000.0
        self.account.save(<- create Minter(), to: /storage/Minter)
    }
}
```

## Deploying the Contract

In order to use the contract, we need to deploy it to the network we want to use it on. In our case we are going to deploy it to emulator while developing.

Back in our `flow.json`, let's add our `FooToken` to the `contracts` after `FungibleToken` with the path of the source code:

```json
"FooToken": "cadence/contracts/FooToken.cdc"
```

Let's also add a new `deployments` section to `flow.json` with the network we want to deploy it to, `emulator`, the account we want it deployed to `emulator-account`, and the list of contracts we want deployed in the array.

```json
"deployments": {
  "emulator": {
    "emulator-account": ["FooToken"]
  }
}
```

Next, using the Flow CLI, we will start the emulator. As mentioned, this will give us a local development environment for the Flow Blockchain.

```bash
flow emulator start
```

Open a new terminal and run the following to deploy your project:

```bash
flow project deploy
```

Congrats, you've deployed your contract to the Flow Blockchain emulator. To read more about deploying your project to other environments, see the [CLI docs](https://developers.flow.com/tools/flow-cli/deployment/deploy-project-contracts).

## Reading the Token’s Total Supply

Let's now check that our total supply was initialized with 1,000 FooTokens. Go ahead and create a new directory and script file called `TotalSupply.cdc`.

```bash
mkdir cadence/scripts
touch cadence/scripts/TotalSupply.cdc
```

In `TotalSupply.cdc`, let's add this code which will log the `totalSupply` value from the `FooToken` contract:

```cadence
import "FooToken"

pub fun main() {
  log(FooToken.totalSupply)
}
```

To run this using the CLI, enter this in your terminal:

```bash
flow scripts execute cadence/scripts/TotalSupply.cdc
```

In the terminal where you started the emulator, you should see `1000.0`

To learn more about running scripts using Flow CLI, [see the docs](https://developers.flow.com/tools/flow-cli/scripts/execute-scripts).

## Giving Accounts the Ability to Receive Tokens

On Flow, newly created accounts cannot receive arbitrary assets. They need to be initialized to receive resources. In our case, we want to give accounts tokens and we’ll need to create a `Vault` (which acts as a receiver) on each account that we want to have the ability to receive tokens. To do this, we'll need to run a transaction which will create the vault and set it in their storage using the `createEmptyVault` function we created earlier on the contract.

Let's first create the file for this transaction called `CreateVault.cdc`:

```bash
mkdir cadence/transactions
touch cadence/transactions/CreateVault.cdc
```

Then add this code to it. This will call the `createEmptyVault` function, save it in storage, and create a capability for the vault which will later allow us to read from it (To learn more about capabilities, see [the Cadence docs here](https://developers.flow.com/cadence/language/capabilities)).

```cadence
import "FooToken"
import "FungibleToken"

transaction {
	prepare(acct: AuthAccount) {
	  acct.save(<- FooToken.createEmptyVault(), to: /storage/Vault)
	  acct.link<&FooToken.Vault{FungibleToken.Balance, FungibleToken.Receiver}>(/public/Vault, target: /storage/Vault)
	}

	execute {
		log("Created")
	}
}
```

Next let's create a new emulator account using the CLI. We'll use this account to create a new vault and mint tokens into it. Run:

```bash
flow accounts create
```

Let's call it `test-acct` and select "Emulator" for the network:

```bash
test-acct
```

This will have added a new account, called `test-acct` to your `flow.json`.

To call our create vault transaction from the CLI, we'll run the following:

```bash
flow transactions send ./cadence/transactions/CreateVault.cdc --signer test-acct --network emulator
```

To learn more about running transactions using CLI, [see the docs](https://developers.flow.com/tools/flow-cli/transactions/send-transactions).

## Reading a Vault’s Balance

Let's now read the balance of the newly created account (`test-acct`) to check it's zero.

Create this new script file `ReadVaultBalance.cdc`:

```bash
touch cadence/scripts/ReadVaultBalance.cdc
```

Add this code which attempts to borrow the capability from the account requested and logs the vault balance if permitted:

```cadence
import "FooToken"
import "FungibleToken"

pub fun main(account: Address) {
  let vault = getAccount(account).getCapability(/public/Vault)
	  .borrow<&FooToken.Vault{FungibleToken.Balance}>()
	  ?? panic("Can't borrow public Vault")

  log(vault.balance)
}
```

To run this script using the CLI, enter the following in your terminal. Note: you'll need to replace `123` with the address created by CLI in your `flow.json` for the `test-acct` address.

```bash
flow scripts execute cadence/scripts/ReadVaultBalance.cdc 123 // change "123" to test-acct address
```

You should see a balance of zero logged.

## Minting More Tokens

Now that we have an account with a vault, let's mint some tokens into it using the Minter we created on the contract account.

To do this, let's create a new transaction file called `Minter.cdc`:

```bash
touch cadence/transactions/Minter.cdc
```

Next, let's add the following code to the `Minter.cdc` file. This code will attempt to borrow the minting capability and mint 20 new tokens into the receivers account.

```cadence
import "FooToken"
import "FungibleToken"

transaction(receiverAccount: Address) {
	prepare(acct: AuthAccount) {
	  let minter = acct.borrow<&FooToken.Minter>(from: /storage/Minter)
		  ?? panic("Can't borrow Minter")

		let newVault <- minter.mintToken(amount: 20.0)

		let receiverVault = getAccount(receiverAccount).getCapability(/public/Vault)
			.borrow<&FooToken.Vault{FungibleToken.Receiver}>()
			?? panic("Could not get public Vault")

		receiverVault.deposit(from: <- newVault)
	}

	execute {}
}
```

To run this transaction, enter this in your terminal. Note: `123` should be replaced with address of `test-acct` found in your `flow.json`. This command also states to sign with our `emulator-account` on the Emulator network.

```bash
flow transactions send ./cadence/transactions/Minter.cdc 123 --signer emulator-account --network emulator
```

Let's go ahead and read the vault again. Remember to replace `123` with the correct address.

```bash
flow scripts execute cadence/scripts/ReadVaultBalance.cdc 123
```

It should now say 20 tokens are in the vault.

## Transferring Tokens Between Accounts

The final functionality we'll add is the ability to transfer tokens from one account to another.

To do that, create a new `Transfer.cdc` transaction file:

```bash
touch cadence/transactions/Transfer.cdc
```

Let's add the code which states that the signer of the transaction will withdraw from their vault and put it into the receiver's vault which will be passed as a transaction argument.

```cadence
import "FooToken"
import "FungibleToken"

transaction(receiverAccount: Address, amount: UFix64) {
	prepare(acct: AuthAccount) {
	  let signerVault = acct.borrow<&FooToken.Vault>(from: /storage/Vault)
		  ?? panic("Couldn't get signer's Vault")

	let receiverVault = getAccount(receiverAccount).getCapability(/public/Vault)
			.borrow<&FooToken.Vault{FungibleToken.Receiver}>()
			?? panic("Could not get public Vault")

	  receiverVault.deposit(from: <- signerVault.withdraw(amount: amount))
	}

	execute {
		log("Transferred")
	}
}
```

To send our tokens, we'll need to create a new account to send them to. Let's make one more account on emulator. Run:

```bash
flow accounts create
```

And pick the name:

```bash
test-acct-2
```

Make sure to select Emulator as the network.

Don't forget the new account will need a vault added, so let's run the following transaction to add one:

```bash
flow transactions send ./cadence/transactions/CreateVault.cdc --signer test-acct-2 --network emulator
```

Now, let's send 1 token from our earlier account to the new account. Remember to replace `123` with account address of `test-acct-2`.

```bash
flow transactions send ./cadence/transactions/Transfer.cdc 123 "1.0" --signer test-acct --network emulator
```

After that, read the balance of `test-acct-2` (replace the address `123`).

```bash
flow scripts execute cadence/scripts/ReadVaultBalance.cdc 123
```

You should now see 1 token in `test-acct-2` account!

## More

- [View a repo of this example code](https://github.com/chasefleming/FooToken)
- [Watch a video on how to create a fungible token on Playground](https://www.youtube.com/watch?v=Yq_sUARMQ4E)
- [Review an `ExampleToken` contract implementing all of the remaining FungibleToken interface](https://github.com/onflow/flow-ft/blob/master/contracts/ExampleToken.cdc)
- [View the Flow Token Standard](https://github.com/onflow/flow-ft/blob/master/contracts/FungibleToken.cdc)
---
title: How to Create an NFT Project on Flow
sidebar_label: Create an NFT Project
description: Guide to creating an NFT Project with the Flow CLI and Cadence.
sidebar_position: 3
---

This tutorial dives into the technical steps required to craft an NFT on the Flow blockchain, providing developers with a clear roadmap from setup to deployment.

## What are NFTs

NFTs, or Non-Fungible Tokens, represent a unique digital asset verified using blockchain technology. Unlike cryptocurrencies such as Bitcoin, which are fungible and can be exchanged on a one-for-one basis, NFTs are distinct and cannot be exchanged on a like-for-like basis. This uniqueness and indivisibility make them ideal for representing rare and valuable items like art, collectibles, tickets and even real estate. Their blockchain-backed nature ensures the authenticity and ownership of these digital assets.

## Setting Up a Project

To start creating an NFT on the Flow blockchain, you'll first need some tools and configurations in place.

### Installing Flow CLI

The **Flow CLI** (Command Line Interface) provides a suite of tools that allow developers to interact seamlessly with the Flow blockchain.

If you haven't installed the Flow CLI yet and have [Homebrew](https://brew.sh/) installed, you can run `brew install flow-cli`. If you don’t have Homebrew, please follow [the installation guide here](https://developers.flow.com/tools/flow-cli/install).

### Initializing a New Project


> 💡 Note: Here is [a link to the completed code](https://github.com/chasefleming/foobar-nft) if you want to skip ahead or reference as you follow along.

Once you have the Flow CLI installed, you can set up a new project using the `flow setup` command. This command initializes the necessary directory structure and a `flow.json` configuration file (a way to configure your project for contract sources, deployments, accounts, and more):

```bash
flow setup foobar-nft
```

Upon execution, the command will generate the following directory structure:

```
/cadence
    /contracts
    /scripts
    /transactions
    /tests
flow.json
```

Now, navigate into the project directory:

```bash
cd foobar-nft
```

To begin, let's create a contract file named `FooBar` for the `FooBar` token, which will be the focus of this tutorial:

```bash
touch cadence/contracts/FooBar.cdc
```

With the contract file in place, you can now set up the basic contract structure:

```cadence
pub contract FooBar {
    init() {}
}
```

## Setting Up Our NFT on the Contract

### Understanding Resources

On the Flow blockchain, "[Resources](https://developers.flow.com/cadence/tutorial/resources-compose)" are a key feature of the Cadence programming language. They represent unique, non-duplicable assets, ensuring that they can only exist in one place at a time. This concept is crucial for representing NFTs on Flow, as it guarantees their uniqueness.

To begin, let's define a basic `NFT` resource. This resource requires an `init` method, which is invoked when the resource is instantiated:

```cadence
pub contract FooBar {

    pub resource NFT {
        init() {}
    }

    init() {}
}
```

Every resource in Cadence has a unique identifier assigned to it. We can use it to set an ID for our NFT. Here's how you can do that:

```cadence
pub contract FooBar {

    pub resource NFT {
        pub let id: UInt64

        init() {
            self.id = self.uuid
        }
    }

    init() {}
}
```

We also need to keep track of the total supply of NFTs in existance. To do this let’s create a `totalSupply` variable on our contract and increase it by one whenever a new NFT is created. We can set this on the initialization of the NFT using the resource `init` function:

```cadence
pub contract FooBar {
    pub var totalSupply: UInt64

    pub resource NFT {
        pub let id: UInt64

        init() {
            self.id = self.uuid
            FooBar.totalSupply = FooBar.totalSupply + 1
        }
    }

    init() {
        self.totalSupply = 0
    }
}
```

To control the creation of NFTs, it's essential to have a mechanism that restricts their minting. This ensures that not just anyone can create an NFT and inflate its supply. To achieve this, you can introduce an `NFTMinter` resource that contains a `createNFT` function:

```cadence
pub contract FooBar {

    // ...[previous code]...

    pub resource NFTMinter {
        pub fun createNFT(): @NFT {
            return <-create NFT()
        }

        init() {}
    }

    init() {
        self.totalSupply = 0
    }
}
```

In this example, the `NFTMinter` resource will be stored on the contract account's storage. This means that only the contract account will have the ability to mint new NFTs. To set this up, add the following line to the contract's `init` function:

```cadence
pub contract FooBar {

    // ...[previous code]...

    init() {
        self.totalSupply = 0
        self.account.save(<- create NFTMinter(), to: /storage/NFTMinter)
    }
}
```

### Setting Up an NFT Collection

Storing individual NFTs directly in an account's storage can cause issues, especially if you want to store multiple NFTs. Instead, it's required to create a collection that can hold multiple NFTs. This collection can then be stored in the account's storage.

Start by creating a new resource named `Collection`. This resource will act as a container for your NFTs, storing them in a dictionary indexed by their IDs. Additionally, to ensure that all NFTs within a collection are destroyed when the collection itself is destroyed, you can add a `destroy` function:

```cadence
pub contract FooBar {

    // ...[NFT resource code]...

    pub resource Collection {
        pub var ownedNFTs: @{UInt64: NFT}

        init() {
            self.ownedNFTs <- {}
        }

        destroy () {
            destroy self.ownedNFTs
        }
    }

    // ...[NFTMinter code]...
}
```

To allow accounts to create their own collections, add a function in the main contract that creates a new `Collection` and returns it:

```cadence
pub contract FooBar {

    pub var ownedNFTs: @{UInt64: NFT}

    pub fun createEmptyCollection(): @Collection {
        return <-create Collection()
    }

    // ...[following code]...
}
```

To manage the NFTs within a collection, you'll need functions to deposit and withdraw NFTs. Here's how you can add a `deposit` function:

```cadence
pub resource Collection {

    pub var ownedNFTs: @{UInt64: NFT}

    pub fun deposit(token: @NFT) {
        let tokenID = token.id
        self.ownedNFTs[token.id] <-! token
    }

    // ...[following code]...
}
```

Similarly, you can add a `withdraw` function to remove an NFT from the collection:

```cadence
pub resource Collection {
    // ...[deposit code]...

    pub fun withdraw(withdrawID: UInt64): @NFT {
        let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("Token not in collection")
        return <- token
    }

    // ...[createEmptyCollection code]...
}
```

To facilitate querying, you'll also want a function to retrieve all the NFT IDs within a collection:

```cadence
pub resource Collection {
    // ...[withdraw code]...

    pub fun getIDs(): [UInt64] {
        return self.ownedNFTs.keys
    }

    // ...[createEmptyCollection code]...
}
```

For security reasons, you might not want to expose all the functions of the Collection to everyone. Instead, you can create an [interface](https://developers.flow.com/cadence/language/interfaces) that exposes only the methods you want to make public. In Cadence, interfaces act as a blueprint for resources and structures, ensuring that certain methods or properties exist. By leveraging these interfaces, you establish clear boundaries and standardized interactions. In this case, you might want to expose only the `deposit` and `getIDs` methods. This interface can then be used to create capabilities, ensuring that only the allowed methods are accessible.

```cadence
pub contract FooBar {

    // ...[previous code]...

    pub resource interface CollectionPublic {
        pub fun deposit(token: @NFT)
        pub fun getIDs(): [UInt64]
    }

    pub resource Collection: CollectionPublic {
        // ...[Collection code]...
    }

    // ...[following code]...
}
```

## Fitting the Flow NFT Standard

To ensure compatibility and interoperability within the Flow ecosystem, it's crucial that your NFT contract adheres to the [Flow NFT standard](https://github.com/onflow/flow-nft). This standard defines the events, functions, resources, and other elements that a contract should have. By following this standard, your NFTs will be compatible with various marketplaces, apps, and other services within the Flow ecosystem.

### Applying the Standard

To start, you need to inform the Flow blockchain that your contract will implement the `NonFungibleToken` standard. Since it's a standard, there's no need for deployment. It's already available on the Emulator, Testnet, and Mainnet for the community's benefit.

Begin by importing the token standard into your contract:

```cadence
import "NonFungibleToken"

pub contract FooBar: NonFungibleToken {

    // ...[rest of code]...

}
```

### Adding Standard Events

To ensure interoperability, the Flow NFT standard requires certain events to be emitted during specific operations.

### Adding ContractInitialized Event

For instance, when the contract is initialized, a `ContractInitialized` event should be emitted:

```cadence
import "NonFungibleToken"

pub contract FooBar: NonFungibleToken {

    pub event ContractInitialized()

    // ...[rest of code]...

    init() {
        self.totalSupply = 0
        emit ContractInitialized()
        self.account.save(<- create NFTMinter(), to: /storage/NFTMinter)
    }
}
```

### Adding Withdraw and Deposit Events

Additionally, when NFTs are withdrawn or deposited, corresponding events should be emitted:

```cadence
import "NonFungibleToken"

pub contract FooBar: NonFungibleToken {

     pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)

    // ...[rest of code]...
}
```

You can then update your `deposit` and `withdraw` functions to emit these events:

```cadence
pub fun deposit(token: @NFT) {
    let tokenID = token.id
    self.ownedNFTs[token.id] <-! token
    emit Deposit(id: tokenID, to: self.owner?.address) // new
}

pub fun withdraw(withdrawID: UInt64): @NFT {
    let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("Token not in collection")
    emit Withdraw(id: token.id, from: self.owner?.address) // new
    return <- token
}
```

### Update NFT Resource

The `NFT` resource should also be updated to implement the `NonFungibleToken.INFT` interface:

```cadence
pub resource NFT: NonFungibleToken.INFT {
    pub let id: UInt64

    init() {
        self.id = self.uuid
        FooBar.totalSupply = FooBar.totalSupply + 1
    }
}
```

### Adding Provider, Receiver, CollectionPublic

Your `Collection` resource should also implement the `Provider`, `Receiver`, and `CollectionPublic` interfaces from the standard:

```cadence
pub resource Collection: NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic {
    // ...[rest of code]...
}
```

With these implementations, you can now remove your custom `CollectionPublic` interface since the standard already provides it.

To ensure users can access a read-only reference to an NFT in the collection without actually removing it, introduce the **`borrowNFT`** function.

```cadence
pub resource Collection: NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic {

    // ...[getIDs code]...

    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
        return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
    }

    // ...[rest of code]...
}
```

Lastly, update the `ownedNFTs`, `deposit`, and `withdraw` variables/methods to use the `NonFungibleToken.NFT` type:

```cadence
pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

pub fun deposit(token: @NonFungibleToken.NFT) {
    //...[deposit code]...
}

pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
    //...[withdraw code]...
}
```

## Deploying the Contract

With your contract ready, it's time to deploy it. First, add the `FooBar` contract to the `flow.json` configuration file:

```bash
flow config add contract
```

When prompted, enter the following name and location (press `Enter` to skip alias questions):

```
Enter name: FooBar
Enter contract file location: cadence/contracts/FooBar.cdc
```

Next, configure the deployment settings by running the following command:

```bash
flow config add deployment
```

Choose the `emulator` for the network and `emulator-account` for the account to deploy to. Then, select the `FooBar` contract (you may need to scroll down). This will update your `flow.json` configuration. After that, you can select `No` when asked to deploy another contract.

To start the Flow emulator, run (you may need to approve a prompt to allow connection the first time):

```bash
flow emulator start
```

In a separate terminal or command prompt, deploy the contract:

```bash
flow project deploy
```

You’ll then see a message that says `All contracts deployed successfully`.

## Creating an NFTCollection

To manage multiple NFTs, you'll need an NFT collection. Start by creating a transaction file for this purpose:

```bash
touch cadence/transactions/CreateCollection.cdc
```

Transactions, on the other hand, are pieces of Cadence code that can mutate the state of the blockchain. Transactions need to be signed by one or more accounts, and they can have multiple phases, represented by different blocks of code.

In this file, import the necessary contracts and define a transaction to create a new collection, storing it in the account's storage. Additionally, for the **`CollectionPublic`** interface, create a capability that allows others to read from its methods. This capability ensures secure, restricted access to specific functionalities or information within a resource.

```cadence
import "FooBar"
import "NonFungibleToken"

transaction {
    prepare(acct: AuthAccount) {
        acct.save(<- FooBar.createEmptyCollection(), to: /storage/FooBarCollection)
        acct.link<&FooBar.Collection{NonFungibleToken.CollectionPublic}>(/public/FooBarCollection, target: /storage/FooBarCollection)
    }

    execute {
        log("NFT collection created")
    }
}
```

To store this new NFT collection, create a new account:

```bash
flow accounts create
```

Name it `test-acct` and select `emulator` as the network. Then, using the Flow CLI, run the transaction:

```bash
flow transactions send cadence/transactions/CreateCollection.cdc --signer test-acct --network emulator
```

Congratulations! You've successfully created an NFT collection for the `test-acct`.

## Get an Account's NFTs

To retrieve the NFTs associated with an account, you'll need a script. Scripts are read-only operations that allow you to query the blockchain. They don't modify the blockchain's state, and therefore, they don't require gas fees or signatures (read more about scripts here).

Start by creating a script file:

```bash
touch cadence/scripts/GetNFTs.cdc
```

In this script, import the necessary contracts and define a function that retrieves the NFT IDs associated with a given account:

```cadence
import "FooBar"
import "NonFungibleToken"

pub fun main(account: Address): [UInt64] {
    let publicReference = getAccount(account).getCapability(/public/FooBarCollection)
        .borrow<&FooBar.Collection{NonFungibleToken.CollectionPublic}>()
        ?? panic("Could not borrow public reference to FooBar")

    return publicReference.getIDs()
}
```

To check the NFTs associated with the `test-acct`, run the script (note: replace `0x123` with the address for `test-acct` from `flow.json`):

```bash
flow scripts execute cadence/scripts/GetNFTs.cdc 0x123
```

Since you haven't added any NFTs to the collection yet, the result will be an empty array.

## Minting and Depositing an NFT to a Collection

To mint and deposit an NFT into a collection, create a new transaction file:

```bash
touch cadence/transactions/DepositNFT.cdc
```

In this file, define a transaction that takes a recipient's address as an argument. This transaction will borrow the minting capability from the contract account, borrow the recipient's collection capability, create a new NFT using the minter, and deposit it into the recipient's collection:

```cadence
import "FooBar"
import "NonFungibleToken"
transaction(recipient: Address) {
    prepare(acct: AuthAccount) {
        let nftMinter = acct.borrow<&FooBar.NFTMinter>(from: /storage/NFTMinter)
            ?? panic("Could not borrow a reference to the NFTMinter")
        let recipientReference = getAccount(recipient).getCapability(/public/FooBarCollection)
            .borrow<&FooBar.Collection{NonFungibleToken.CollectionPublic}>()
            ?? panic("Could not borrow a reference to the recipient's collection")
        recipientReference.deposit(token: <- nftMinter.createNFT())
    }
    execute {
        log("New NFT deposited into collection")
    }
}
```

To run this transaction, use the Flow CLI. Remember, the contract account (which has the minting resource) should be the one signing the transaction. Pass the test account's address (from the `flow.json` file) as the recipient argument (note: replace `0x123` with the address for `test-acct` from `flow.json`):

```bash
flow transactions send cadence/transactions/DepositNFT.cdc 0x123 --signer emulator-account --network emulator
```

After executing the transaction, you can run the earlier script to verify that the NFT was added to the `test-acct`'s collection (remember to replace `0x123`):

```bash
flow scripts execute cadence/scripts/GetNFTs.cdc 0x123
```

You should now see a value in the `test-acct`'s collection array!

## Transferring an NFT to Another Account

To transfer an NFT to another account, create a new transaction file:

```bash
touch cadence/transactions/TransferNFT.cdc
```

In this file, define a transaction that takes a recipient's address and the ID of the NFT you want to transfer as arguments. This transaction will borrow the sender's collection, get the recipient's capability, withdraw the NFT from the sender's collection, and deposit it into the recipient's collection:

```cadence
import "FooBar"

transaction(recipient: Address, id: UInt64) {
    prepare(acct: AuthAccount) {
        let collection = acct.borrow<&FooBar.Collection>(from: /storage/FooBarCollection)!
        let recipientReference = getAccount(recipient).getCapability(/public/FooBarCollection)
            .borrow<&FooBar.Collection{FooBar.CollectionPublic}>()
            ?? panic("Could not borrow a reference to the recipient's collection")
        recipientReference.deposit(token: <- collection.withdraw(withdrawID: id))
    }

    execute {
        log("NFT transferred to another collection")
    }
}
```

To transfer the NFT, first create a new account:

```bash
flow accounts create
```

Name it `test-acct-2` and select `Emulator` as the network. Next, create a collection for this new account:

```bash
flow transactions send cadence/transactions/CreateCollection.cdc --signer test-acct-2 --network emulator
```

Now, run the transaction to transfer the NFT from `test-acct` to `test-acct-2` using the addresses from the `flow.json` file (replace `0x124` with `test-acct-2`'s address. Also note that `0` is the `id` of the `NFT` we'll be transferring):

```bash
flow transactions send cadence/transactions/TransferNFT.cdc 0x124 0 --signer test-acct --network emulator
```

To verify the transfer, you can run the earlier script for `test-acct-2` (replace `0x124`):

```bash
flow scripts execute cadence/scripts/GetNFTs.cdc 0x123
```

## Adding MetadataViews

Many NFT projects include metadata associated with the NFT, such as a name, description, or image. However, different projects might store this metadata in various formats. To ensure compatibility across the Flow ecosystem, Flow uses `MetadataViews` to standardize the representation of this metadata.

There are two types of Metadata Views: NFT level and contract level. In this guide, we’ll show you how to implement the most basic display, but for a deeper dive into what is possible, check out the [MetadataViews API doc](https://developers.flow.com/references/core-contracts/flow-nft/MetdataViews/MetadataViews).

### NFT Metadata

For the NFT metadata, you'll add a simple `MetadataView` called `Display`, which includes a `name`, `description`, and `thumbnail`. This format is common for many NFT projects. (For more details, refer to the [Display documentation](https://developers.flow.com/references/core-contracts/flow-nft/MetdataViews/MetadataViews#display)).

Start by importing the `MetadataViews` contract into your `FooBar` contract:

```cadence
import "MetadataViews"
```

Because this is already deployed to Emulator and our `flow setup` command added it to our `flow.json`, there is no more configuration we need to do.

Update the `NFT` resource to implement the `[ViewResolver` interface](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L20) provided by the MetadataViews contract. This interface specifies that a `getViews` function and a `resolveView` function should exist. Then, add fields for `name`, `thumbnail`, and `description`:

```cadence
pub resource NFT: NonFungibleToken.INFT, MetadataViews.ViewResolver {
    pub let id: UInt64
    pub let name: String
    pub let description: String
    pub let thumbnail: String

    // ...[rest of NFT code]...
}
```

Now, add the methods from the `ViewResolver` interface to the `NFT` resource. These methods will return the metadata in the standardized `Display` format:

```cadence
pub resource NFT: NonFungibleToken.INFT, ViewResolver {
    // ...[NFT code]...

    pub fun getViews(): [Type] {
        return [Type<MetadataViews.Display>()]
    }

    pub fun resolveView(_ view: Type): AnyStruct? {
        if (view == Type<MetadataViews.Display>()) {
            return MetadataViews.Display(
                name: self.name,
                thumbnail: self.thumbnail,
                description: self.description
            )
        }
        return nil
    }
}
```

Finally, to retrieve our NFT along with its metadata, we currently have a `borrowNFT` function. However, this function only returns a `NonFungibleToken.NFT` with an `id` field. To address this, let's introduce a new function in our collection that borrows the NFT and returns it as a `FooBar` NFT. We'll utilize the `auth` [syntax to downcast](https://developers.flow.com/cadence/language/operators#conditional-downcasting-operator-as) the `NonFungibleToken.NFT` to our specific type.

```cadence
pub fun borrowFooBarNFT(id: UInt64): &FooBar.NFT? {
    if self.ownedNFTs[id] != nil {
        let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
        return ref as! &FooBar.NFT
    }

    return nil
}
```

### Contract Metadata

For the contract level metadata, we need to create an interface that defines the required methods for the contract. Luckily, there is already a commonly used contract interface called `ViewResolver` deployed both to the Emulator and other networks. This interface requires a `getViews` and a `resolveViews` method. It is also deployed on [Testnet](https://testnet.contractbrowser.com/A.631e88ae7f1d7c20.ViewResolver) and [Mainnet](https://contractbrowser.com/A.1d7e57aa55817448.ViewResolver). You can find its address in the `flow.json` we generated with the `setup` command. To use it, return to your `FooBar` contract, import this new contract, and specify that `FooBar` should implement it.


```cadence
import "NonFungibleToken"
import "MetadataViews"
import "ViewResolver"

pub contract FooBar: NonFungibleToken, ViewResolver {
    //...[contract code]...
}
```

Just like the NFT (except at a contract level), we’ll add functions for `getView` which returns the `Display` and `resolveViews` which tells it how to get the `Display` values:

```cadence
pub contract FooBar: NonFungibleToken, ViewResolver {

//...[all code above contract init]...

pub fun getViews(): [Type] {
        return [Type<MetadataViews.Display>()]
    }

    pub fun resolveView(_ view: Type): AnyStruct? {
        switch view {
            case Type<MetadataViews.NFTCollectionData>():
                return MetadataViews.NFTCollectionData(
                    storagePath: /storage/FooBarCollection,
                    publicPath: /public/FooBarCollection,
                    providerPath: /private/FooBarCollection,
                    publicCollection: Type<&FooBar.Collection{NonFungibleToken.CollectionPublic}>(),
                    publicLinkedType: Type<&FooBar.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
                    providerLinkedType: Type<&FooBar.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(),
                    createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                        return <-FooBar.createEmptyCollection()
                    })
                )
        }
        return nil
    }

//...[contract init code]...

}
```

Finally, we need a way to read this data like we did with the NFT. Let’s also make a `borrowViewResolver` function that we add below the `borrowFooBarNFT` method inside of the `Collection`:

```cadence
pub resource Collection: NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {

    // ...[borrowFooBarNFT]...

    pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
        let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
        return ref as! &FooBar.NFT
    }

    // ...[Collection init]...
}
```

Congrats, you did it! You’re now ready to launch the next fun NFT project on Flow.

## More

- Explore [an example NFT repository](https://github.com/nvdtf/flow-nft-scaffold/blob/main/cadence/contracts/exampleNFT/ExampleNFT.cdc)
- Watch a [video tutorial on creating an NFT project in the Flow Playground](https://www.youtube.com/watch?v=bQVXSpg6GE8)
- Dive into the details of [the NFT Standard](https://github.com/onflow/flow-nft)
- For a deeper dive into `MetadataViews`, consult the [API documentation](https://developers.flow.com/references/core-contracts/flow-nft/MetdataViews/MetadataViews#docusaurus_skipToContent_fallback) or [the FLIP that introduced this feature](https://github.com/onflow/flips/blob/main/application/20210916-nft-metadata.md).
- Use a [no code tool for creating NFT projects on Flow](https://www.touchstone.city/)---
sidebar_position: 1
---

# Intro to Cadence

In a blockchain environment like Flow, programs that are stored on-chain in accounts are commonly referred to as smart contracts.
A smart contract is a program that verifies and executes the performance of a contract without the need for a trusted third party.
Programs that run on blockchains are commonly referred to as smart contracts because they mediate important functionality (such as currency)
without having to rely on a central authority (like a bank).

## A New Programming Language

---

Cadence is a resource-oriented programming language that introduces new features to smart contract programming
that help developers ensure that their code is safe, secure, clear, and approachable. Some of these features are:

- Type safety and a strong static type system.
- Resource-oriented programming, a new paradigm that pairs linear types with object capabilities
to create a secure and declarative model for digital ownership by ensuring that resources (which are used to represent scarce digital assets)
can only exist in one location at a time, cannot be copied, and cannot be accidentally lost or deleted.
- Built-in pre-conditions and post-conditions for functions and transactions.
- The utilization of capability-based security, which enforces that access to objects
is restricted to only the owner of the object and those who have a valid reference to it.
This is Cadence's main form of access control.

Cadence’s syntax is inspired by popular modern general-purpose programming languages
like [Swift](https://developer.apple.com/swift/), [Kotlin](https://kotlinlang.org/), and [Rust](https://www.rust-lang.org/).
Its use of resource types maps well to that of [Move](https://medium.com/coinmonks/overview-of-move-programming-language-a860ffd8f55d),
the programming language being developed by the Diem team.

## Cadence's Programming Language Pillars

---

Cadence, a new high-level programming language, observes the following requirements:

- **Safety and Security:** Safety is the underlying reliability of any smart contract (i.e., it’s bug-free and performs its function).
Security is the prevention of attacks on the network or smart contracts (i.e., unauthorized actions by malicious actors).
Safety and security are critical in smart contracts because of the immutable nature of blockchains,
and because they often deal with high-value assets. While auditing and reviewing code will be a crucial part of smart contract development,
Cadence maximizes efficiency while maintaining the highest levels of safety and security.
It accomplishes this via a strong static type system, design by contract, and ownership primitives inspired by linear types (which are useful when dealing with assets).
- **Clarity:** Code needs to be easy to read, and its meaning should be as unambiguous as possible.
It should also be suited for verification so that tooling can help with ensuring safety and security guarantees.
These guarantees can be achieved by making the code declarative and allowing the developer to express their intentions directly.
We make those intentions explicit by design, which, along with readability, make auditing and reviewing more efficient, at a small cost to verbosity.
- **Approachability:** Writing code and creating programs should be as approachable as possible.
Incorporating features from languages like Swift and Rust, developers should find Cadence’s syntax and semantics familiar.
Practical tooling, documentation, and examples enable developers to start creating programs quickly and effectively.
- **Developer Experience:** The developer should be supported throughout the entire development lifecycle, from initial application logic to on-chain bugfixes.
- **Intuiting Ownership with Resources:** Resources are a composite data type, similar to a struct, that expresses direct ownership of assets.
Cadence’s strong static type system ensures that resources can only exist in one location at a time and cannot be copied or lost because of a coding mistake.
Most smart contract languages currently use a ledger-style approach to record ownership,
where an asset like a fungible token is stored in the smart contract as an entry in a central ledger.
Cadence’s resources directly tie an asset’s ownership to the account that owns it by saving the resource in the account’s storage.
As a result, ownership isn’t centralized in a smart contract’s storage. Each account owns its assets,
and the assets can be transferred freely between accounts without the need for arbitration by a central smart contract.

## Addressing Challenges with Existing Languages

---

Other languages pioneered smart contract development, but they lack in areas that affect the long-term viability of next-generation applications.

### Safety

Safety is the reliability of a smart contract to perform its function as intended.
It is heavily influenced by the unchangeable-once-deployed nature of smart contracts:
Developers must take certain precautions in order to avoid introducing any potentially catastrophic vulnerabilities
prior to publishing a smart contract on the blockchain.
It is standard across many blockchains that modifying or updating a smart contract, even to fix a vulnerability, is not allowed.
Thus, any bugs that are present in the smart contract will exist forever.

For example, in 2016, an overlooked vulnerability in an Ethereum DAO smart contract (Decentralized Autonomous Organization)
saw millions of dollars siphoned from a smart contract,
eventually leading to a fork in Ethereum and two separate active blockchains (Ethereum and Ethereum Classic).

Bug fixes are only possible if a smart contract is designed to support changes,
a feature that introduces complexity and security issues.
Lengthy auditing and review processes can ensure a bug-free smart contract.
Still, they add substantial time to the already time-consuming task of getting the smart contract’s core logic working correctly.

Overlooked mistakes cause the most damaging scenarios.
It is easy to lose or duplicate monetary value or assets in existing languages because they don’t check relevant invariants
or make it harder to express them.
For example, a plain number represents a transferred amount that can be accidentally (or maliciously) multiplied or ignored.

Some languages also express behaviors that developers tend to forget about.
For example, a fixed-range type might express monetary value, without considerations for a potential overflow or underflow.
In Solidity, Ethereum's smart contract language, an overflow causes the value to wrap around, as shown [here](https://ethfiddle.com/CAp-kQrDUP).
Solidity also allows contracts to declare variables without initializing them.
If the developer forgets to add an initialization somewhere,
and then tries to read the variable somewhere else in the code expecting it to be a specific value, issues will occur.

Cadence is type safe and has a strong static type system,
which prevents important classes of erroneous or undesirable program behavior at compile-time (i.e., before the program is run on-chain).
Types are checked statically and are not implicitly converted. Cadence also improves the safety of programs by preventing arithmetic underflow and overflow,
introduces optionals to make nil-cases explicit, and always requires variables to be initialized.
This helps ensure the behavior of these smart contracts is apparent and not dependent on context.

### Security

Security, in combination with safety, ensures the successful execution of a smart contract over time
by preventing unsanctioned access and guaranteeing that only authorized actions can be performed in the protocol.
In some languages, functions are public by default, creating vulnerabilities that allow malicious users to find attack vectors.
Cadence utilizes capability-based security, which allows the type system to enforce access control based on rules that users and developers have control over.

Security is a consideration when interacting with other smart contracts. Any external call potentially allows malicious code to be executed.
For example, in Solidity, when the called function signature does not match any of the available ones, it triggers Solidity’s fallback functions.
These functions can be used in malicious ways. Language features such as multiple inheritances and overloading or dispatch can also make it difficult
to determine which code is invoked.

In Cadence, the safety and security of programs are enhanced by **Design By Contract** and **Ownership Primitives.**
Design by contract allows developers to state pre-conditions and post-conditions for functions and interfaces in a declarative manner
so that callers can be certain about the behavior of called code. Ownership primitives are inspired by linear types and increase safety when working with assets.
They ensure that valuable assets are, for example, not accidentally or maliciously lost or duplicated.

### Clarity and Approachability

Implicitness, context-dependability, and expressiveness are language-based challenges that developers often encounter.
They affect the clarity (i.e. the readability of code and the ability to determine its intended function)
and the approachability (i.e. the ability to interpret or write code) of the language and the programs built using it.
For example, in Solidity, storage must be implemented in a low-level key-value manner, which obfuscates the developer’s intentions.
Syntax confusion is another example, with “=+” being legal syntax leading to an assignment instead of a probably-intended increment.
Solidity also has features with uncommon behaviors that can lead to unintended results.
[Multiple inheritance may lead to unexpected behaviours in the program](https://medium.com/consensys-diligence/a-case-against-inheritance-in-smart-contracts-d7f2c738f78e),
and testing and auditing the code is unlikely to identify this issue.

The Ethereum blockchain’s code immutability showcases the need for considerations around extensibility and mechanisms that allow ad-hoc fixes.
Developers using custom-made approaches such as the 'data separation' approach to upgradability
may run into problems with the complexity of data structures,
while developers using ‘delegatecall-based proxies` may run into problems with the consistency of memory layouts.
Either way, these challenges compromise approachability and overall extensibility.
Cadence has [contract upgradability built in by default](https://cadence-lang.org/docs/language/contract-updatability),
and contracts can be made immutable by removing all keys from an account.

Cadence improves the clarity and extensibility of programs by utilizing interfaces to allow extensibility, code reuse, and interoperability between contracts.
Cadence modules also have configurable and transparent upgradeability built-in to enable projects to test and iterate before making their code immutable.

Cadence allows the use of argument labels to describe the meaning of function arguments.
It also provides a rich standard library with useful data structures (e.g., dictionaries, sets) and data types for common use cases,
like fixed-point arithmetic, which helps when working with currencies.

## Intuiting Ownership with Resources

Most smart contract languages currently use a ledger-style approach to record ownership,
where an asset is stored in the smart contract as an entry in a central ledger, and this ledger is the source of truth around asset ownership.
There are many disadvantages to this design, especially when it comes to tracking the ownership of multiple assets belonging to a single account.
To find out all of the assets that an account owns, you would have to enumerate all the possible smart contracts that could potentially include this account
and search to see if the account owns these assets.

In a resource-oriented language like Cadence, resources directly tie an asset to the account that owns it
by saving the resource in the account’s storage. As a result, ownership isn’t centralized in a single, central smart contract’s storage.
Instead, each account owns and stores its own assets, and the assets can be transferred freely between accounts without the need for arbitration by a central smart contract.

Resources are inspired by linear types and increase safety when working with assets, which often have real, intrinsic value.
Resources, as enforced by Cadence’s type system, ensure that assets are correctly manipulated and not abused.

- Every resource has exactly one owner. If a resource is used as a function parameter, an initial value for a variable, or something similar, the object is not copied.
Instead, it is moved to the new location, and the old location is immediately invalidated.
- The language will report an error if ownership of a resource was not properly transferred, i.e.,
when the program attempts to introduce multiple owners for the resource or the resource ends up in a state where it does not have an owner.
For example, a resource can only be assigned to exactly one variable and cannot be passed to functions multiple times.
- Resources cannot go out of scope. If a function or transaction removes a resource from an account’s storage,
it either needs to end the transaction in an account's storage, or it needs to be explicitly and safely deleted. There is no “garbage collection” for resources.

The special status of Resource objects must be enforced by the runtime; if they were just a compiler abstraction it would be easy for malicious code to break the value guarantees.

Resources change how assets are used in a programming environment to better resemble assets in the real world.
Users store their currencies and assets in their own account, in their own wallet storage, and they can do with them as they wish.
Users can define custom logic and structures for resources that give them flexibility with how they are stored.
Additionally, because everyone stores their own assets, the calculation and charging of state rent is fair and balanced across all users in the network.

## An Interpreted Language

---

Currently, Cadence is an interpreted language, as opposed to a compiled language. This means that there is no Cadence Assembly, bytecode, compiler, or Cadence VM.

The structure of the language lends itself well to compilation (for example, static typing),
but using an interpreter for the first version allows us to refine the language features more quickly as we define them.

## Getting Started with Cadence

---

Now that you've learned about the goals and design of Cadence and Flow, you're ready to get started with the Flow emulator and tools!
Go to the [Getting Started](https://cadence-lang.org/docs/tutorial/first-steps) page to work through language fundamentals and tutorials.

## Why Cadence?

### 1. Security and Safety

Cadence provides security and safety guarantees that greatly simplify the development of secure smart contracts. As smart contracts often deal with valuable assets, Cadence provides the resource-oriented programming paradigm, which guarantees that assets can only exist in one location at a time, cannot be copied, and cannot be accidentally lost or deleted.
Cadence includes several language features which prevent entire classes of bugs.
These security and safety features allow smart contract developers to focus on the business logic of their contract instead of preventing accidents and attacks.

### 2. Composability

Cadence enables composability. Resources (which are arbitrary user-defined data types) are stored directly in users’ accounts, and can flow freely between contracts: They can be passed as arguments to functions, returned from functions, or even combined in arbitrary data structures. This makes implementing business logic easier, more natural and promotes reuse of existing logic.

### 3. Simplicity

Cadence’s syntax is inspired by popular modern general-purpose programming languages like [Swift](https://developer.apple.com/swift/), [Kotlin](https://kotlinlang.org/), and [Rust](https://www.rust-lang.org/), so developers will find the syntax and the semantics familiar.
Practical tooling, documentation, and examples enable developers to start creating programs quickly and effectively. Hundreds of developers were able to learn Cadence quickly and develop production-quality smart contracts with it shortly.
---
title: Deploying Contracts
sidebar_label: Deploying Contracts
description: Guidelines for deploying your project's contracts on Flow Mainnet
sidebar_position: 3
sidebar_custom_props:
  icon: 🥇  
---

In order to deploy your smart contracts to the mainnet, you need a funded account. If you want to get started on Testnet, look below for information on how to get started.

<Callout type="info">
Make sure you handle your mainnet account keys appropriately. Using a Key Management Service is the best practice. 
</Callout>

### Creating an Account

There are two simple methods of creating an account on testnet. **Interactive** and **Manual**, both use the Flow CLI. On mainnet you will have to fund your newly created account, there is no faucet.
Make sure to install the Flow CLI. [Flow CLI](../../../tools/flow-cli/accounts/create-accounts) has a interactive mode for generating keys.

<Callout type="success">
Anyone can deploy and update contracts on mainnet. Audits are encouraged but not mandatory to deploying contracts to mainnet. Take every precauction to reduce issues and protect users. 
</Callout>

### Create and deploy a mainnet project
The tool of choice is Flow CLI, there are quickstarts and guides that use Flow CLI, [Getting Started](../../getting-started/quickstarts/flow-cli)
- It is highly encouraged to test your contracts, transactions and scripts on Testnet, have strong smart contract test coverage and follow any additional guidelines set out here: [Smart Contract Testing Guidelines](./testing.md). 
- Follow the Flow CLI instructions to [Create a Project](../../../tools/flow-cli/index.md). You have the Flow CLI installed and ran `flow init` or `flow setup` in your project folder and generating a `flow.json` file
- Mainnet account: You completed the mainnet account setup, (see above) and have your key pair and mainnet address ready.
- [Deploy your project](../../../tools/flow-cli/deployment/deploy-project-contracts.md), notice that your account now has contracts deployed on mainnet.
- [Deploy a contract](../../../tools/flow-cli/accounts/account-add-contract.md) to mainnet. You can deploy contracts individually using the `account-add-contract` command.

<Callout type="info">
All your contract deployment addresses are stored in `flow.json`. Mainnet, Testnet and local (emulator) are stored as well.
</Callout>

### Deploy updated contracts on mainnet

Contracts can be updated and retain the contract address. You can use the [Flow CLI contract update command](../../../tools/flow-cli/accounts/account-update-contract.md) to re-deploy an updated version of your contract:

<Callout type="warning">
If you see `Error Code: 1103`, your new account does not have enough funds to complete the transaction. Make sure you have enough FLOW and your account is set up correctly, check [Flowdiver](https://flowdiver.io/) to verify.
</Callout>

Once all your contracts are deployed, you can visit [flow-view-source](https://flow-view-source.com/) or run the [Flow CLI get account command](../../../tools/flow-cli/accounts/get-accounts.md) to confirm the deployment.

### Sporks

Currently, **historical event data is not migrated between sporks,** so you'll need to design your application with this in mind. We recognize the usefulness of historical event data and plan on adding a means of accessing it in the near future. Past spork transactional data is available, [See Previous Spork Access Node Info](../../../references/run-and-secure/node-operation/past-sporks)

More Information on [Sporks](../../../references/run-and-secure/node-operation/spork)


### Testnet


The Flow test network, known as Flow Testnet, exists to help developers test their software and smart contracts against a live network. It's also used as a means of releasing and testing new protocol and smart contract features before they are integrated into Flow's main network (Mainnet).

When the Flow protocol is updated or a new version of Cadence is released, those updates will always be made available on the [Flow Emulator](../../../tools/emulator) _before_ they're integrated into Flow Testnet or Flow Mainnet. 

## Getting Started on Testnet

If you need to create a flow.json file to store information about accounts and contracts use the `flow init` command to create a project
<Callout type="info">
To create accounts and generate keys, make sure to install [Flow CLI](../../../tools/flow-cli/install). Flow CLI provides convenient functions to simplifies interacting with the blockchain.
</Callout>


### Creating an Account

There is a simple Flow CLI command to run to create an account. `flow accounts create` command will create a new account and generate a key pair then add the account to your flow.json. The command will try and You can also use the [Testnet Faucet](https://testnet-faucet-v2.onflow.org/) to create and fund an account.

More information about [Flow CLI](../../../tools/flow-cli/accounts/create-accounts) and creating accounts. 

### Creating and deploying a Project

Flow CLI can be used to create a Cadence project and stay organized, [Flow CLI: Create a project](../../../tools/flow-cli). This will make deployment much easiler and help with the iterative development process.

After you have a project created and want to deploy your Cadence; contracts, transactions and scripts. 
`flow accounts add-contract <CONTRACT_PATH> --signer <ACCOUNT_NAME> --network testnet` will deploy your contract to testnet.
More information on how to use Flow CLI to [deploy](../../../tools/flow-cli/deployment/deploy-project-contracts.md).

Make sure Flow project was initialized in the previous step and the `flow.json` is present.


### Making Use of Core Contracts

Flow Testnet comes with some useful contracts already deployed, called **core contracts.** More information and import addresses for the [core contracts](../../../references/core-contracts/index.md).

Once your accounts are set up and you're ready to develop, you can look over [some code examples from the Flow Go SDK](https://github.com/onflow/flow-go-sdk/tree/master/examples).


### Breaking Changes

The Flow blockchain is improved continuously and thus version updates to Cadence, Flow node software, and the Flow SDKs will contain important updates as well as breaking changes.

You should anticipate future updates and join the community ([Forum](https://forum.onflow.org/) or [Discord](https://www.onflow.org/discord)) to stay tuned on important announcements. Notices and guidelines for changes will be provided as early as possible.


### Testnet Sporking

"Sporking" (soft forking) is the process of upgrading the Flow network node software and migrating the chain state from one version to another.

Currently, **historical event data is not migrated between sporks.** You'll need to design your application with this in mind. We recognize the usefulness of historical event data and plan on adding a means of accessing it in the near future. Only one previous spork data is available through old Access Node.


<Callout type="warning">
Flow Testnet is explicitly for experimentation and testing and should not be used to exchange "real value" (e.g. developing a fiat money on/off-ramp for your testnet application).
</Callout>



---
title: Smart Contracts on Flow
sidebar_title: Smart Contracts on Flow
sidebar_position: 2
sidebar_label: Smart Contracts on Flow
sidebar_custom_props:
  icon: 🛠️ 
---

At its core, a decentralized application is defined by the [smart contracts](https://en.wikipedia.org/wiki/Smart_contract) it uses on the blockchain. Rather than relying on centralized application servers and databases, apps model their core application logic using smart contracts, often referred to as the “on-chain” code.

It is therefore helpful to develop a clear model for your app that takes into account the data and logic that will exist in your smart contracts. In particular, it is important to differentiate between the parts of your app that must live on chain and those that should live off chain.

## How to Write Smart Contracts on Flow

Smart contracts on the Flow blockchain are implemented in [Cadence](https://github.com/onflow/cadence), a resource-oriented programming language specifically designed for smart contract development.

### Onboard to Cadence

To get started with Cadence, we recommended covering the introductory tutorials available in the [Flow Playground](https://play.onflow.org/), a simple web IDE designed for learning Cadence.

### Configure Your Local Environment

To build confidently, you will want to set up the appropriate local environment and have an adequate test suite to ensure your smart contracts operate as intended. To do this, familiarize yourself with the following tools:

- [Flow CLI](../../../tools/flow-cli/index.md): A utility to directly interact with the chain and manage accounts and contracts.
- [Flow Emulator](../../../tools/emulator/index.md): A lightweight server that simulates the Flow blockchain (strongly recommended during development).
- [Flow Dev Wallet](https://github.com/onflow/fcl-dev-wallet/): A utility to simulate user wallets in development.
- [Visual Studio Code Extension](../../../tools/vscode-extension/index.mdx): An IDE integration for developing smart contracts.
- [JS Testing Framework](https://github.com/onflow/flow-js-testing): A framework to test your smart contracts.

## Storing Data on Flow

All apps will store important data on the blockchain, and some more than others -- especially NFT apps. You’ll want to consider the following when storing data on the Flow blockchain.

### What does your data need to represent?

Permanence is a key property of blockchains; users trust that the data they store will continue to exist for years to come, and this is a defining characteristic of assets like NFTs. Therefore, well-designed digital assets store the information necessary to retain their value without external dependencies.

### Storage Limits & Fees

However, there are practical constraints to storing data on a blockchain. Developer and user accounts must retain a small amount of FLOW tokens, known as the storage fee, for bytes of data stored in their accounts. The minimum storage fee will grant each account a minimum storage amount. If an account holds assets that demand more bytes of storage, the account will need to retain more FLOW tokens to increase the storage amount according to Flow's [fee schedule](../../basics/fees.md#fees). A more compact data model can keep storage needs down. \
 \
Furthermore, a single Flow transaction has a size limit of 4MB, which limits the rate at which large amounts of data can be transferred to the blockchain.

Lastly, a blockchain is not a content delivery network and therefore cannot serve media assets, such as videos, at the speeds expected by modern applications.

For these reasons, it usually isn’t practical to store large media assets such as videos and high-definition images on the Flow blockchain. Instead, consider using an external storage solution.

### External Storage Networks

Decentralized storage networks such as IPFS allow you to store large digital assets off chain, but without relying on centralized servers. Rather than saving an entire asset to the Flow blockchain, you can save the content hash (known as a CID on IPFS) on the blockchain and then store the source file off-chain. This way, users can verify that the media file matches the digital asset.

IPFS files can be uploaded via a pinning service such as Pinata; see their [NFT tutorial](https://medium.com/pinata/how-to-create-nfts-like-nba-top-shot-with-flow-and-ipfs-701296944bf) for an example of how to use Pinata with Flow.

It’s worth noting that IPFS files are served through [gateways](https://docs.ipfs.io/concepts/ipfs-gateway/), many of which leverage caching to provide fast response times. Cloudflare provides a [public IPFS Gateway](https://developers.cloudflare.com/distributed-web/ipfs-gateway), and Pinata also supports [dedicated gateways with custom domains](https://medium.com/pinata/announcing-dedicated-ipfs-gateways-60f599949ce).

## Using Existing Standards

The Flow blockchain has existing smart contract standards for both fungible and non-fungible tokens that you should implement when building your contracts.

### Non-Fungible Tokens (NFTs)

All NFTs on the Flow blockchain implement the [NonFungibleToken](../../../references/core-contracts/08-non-fungible-token.md) interface, allowing them to be compatible with wallets, marketplaces and other cross-app experiences.

- [Non-Fungible Token (NFT) contract interface](../../../references/core-contracts/08-non-fungible-token.md)

### NFT Sales and Trading

Flow has a standard contract to facilitate both the direct sales and peer-to-peer trading of NFTs. The NFT storefront contract is useful for apps that want to provide an NFT marketplace experience.

- [NFT Storefront contract](https://github.com/onflow/nft-storefront)

### Fungible Tokens

Fungible tokens (i.e. coins, currencies) on the Flow blockchain, including the default cryptocurrency token FLOW, implement the [FungibleToken](../../../references/core-contracts/02-fungible-token.md) interface.

- [Fungible Token contract interface](../../../references/core-contracts/02-fungible-token.md)
---
title: Testing Your Contracts 
sidebar_label: Testing Your Contracts 
description: Testing smart contract Guidelines
sidebar_position: 4
sidebar_custom_props:
  icon: 📝 
---

Testing is an essential part of smart contract development to ensure the correctness and reliability of your code. The Cadence Testing Framework provides a convenient way to write tests for your contracts, scripts and transactions which allows you to verify the functionality and correctness of your smart contracts.

## Install Flow CLI

The [Flow CLI](../../../tools/flow-cli/index.md) is the primary tool for developing, testing, and deploying smart contracts to the Flow network.

If you haven't installed the Flow CLI yet and have [homebrew](https://brew.sh/) installed, simply run `brew install flow-cli`. Alternatively, refer to the Flow CLI [installation instructions](../../../tools/flow-cli/install.md).

## Create a new project

In your preferred code editor, create a new directory for your project and navigate to it in the terminal. Then initialize a new Flow project by running the command `flow init`. This will create a `flow.json` config file that contains the [project's configuration](../../../tools/flow-cli/flow.json/configuration.md).

```bash
mkdir test-cadence
cd test-cadence
flow init
```

## Write a simple smart contract

In your code editor, create a new file called `calculator.cdc` and add the following code:

```cadence calculator.cdc
access(all) contract Calculator {
    access(all)
    fun add(a: Int, b: Int): Int {
        return a + b
    }

    access(all)
    fun subtract(a: Int, b: Int): Int {
        return a - b
    }

    access(all)
    fun multiply(a: Int, b: Int): Int {
        return a * b
    }
}
```

## Add the smart contract to the config

Next up, we need to add our new contract in the `contracts` key in the `flow.json` config file. More specifically, we need to add the contract name, location and an address alias for the `testing` environment.

```json
{
  "contracts": {
    "Calculator": {
      "source": "./calculator.cdc",
      "aliases": {
        "testing": "0x0000000000000007"
      }
    }
  },
  "networks": {...},
  "accounts": {...},
  "deployments": {...}
}
```

For the time being, the address for the `testing` alias, can be one of:
- `0x0000000000000005`
- `0x0000000000000006`
- `0x0000000000000007`
- `0x0000000000000008`
- `0x0000000000000009`
- `0x000000000000000a`
- `0x000000000000000b`
- `0x000000000000000c`
- `0x000000000000000d`
- `0x000000000000000e`

In the next release, there will be `20` addresses for contract deployment during testing.

## Write unit tests

In the same directory, create a new file called `calculator_test.cdc` and add the following code:

```cadence calculator_test.cdc
import Test
import "Calculator" // contract name from the previous step

access(all)
fun setup() {
    let err = Test.deployContract(
        name: "Calculator",
        path: "./calculator.cdc",
        arguments: []
    )
    Test.expect(err, Test.beNil())
}

access(all)
fun testAdd() {
    Test.assertEqual(5, Calculator.add(a: 2, b: 3))
}

access(all)
fun testSubtract() {
    Test.assertEqual(2, Calculator.subtract(a: 5, b: 3))
}
```

This code:
- imports the `Calculator` contract from the `calculator.cdc` file (according to `flow.json`)
- deploys the `Calculator` contract to the address specified in the `testing` alias
- defines two test cases: `testAdd()` and `testSubtract()`
- calls `add()` and `subtract()` methods with different input values respectively.

## Running the test cases

To run the test cases, use the following command in the terminal:

```bash
flow test --cover --covercode="contracts" calculator_test.cdc
```

This command uses the Flow CLI to run the test cases and display the output. You should see the following output:

```bash
Test results: "calculator_test.cdc"
- PASS: testAdd
- PASS: testSubtract
Coverage: 66.7% of statements
```

This output indicates that both test cases ran successfully, and the two smart contract methods are functioning as expected. With the supplied flags (`--cover` & `--covercode="contracts"`), we also get code coverage insights for the contracts under testing. The code coverage percentage is `66.7%`, because we have not added a test case for the `multiply` method. By viewing the auto-generated `coverage.json` file, we see:

```json
{
  "coverage": {
    "A.0000000000000007.Calculator": {
      "line_hits": {
        "14": 0,
        "4": 1,
        "9": 1
      },
      "missed_lines": [
        14
      ],
      "statements": 3,
      "percentage": "66.7%"
    }
  }
}
```

Line 14 from the `Calculator` smart contract is marked as missed. This is the line:

```cadence
return a * b
```
which is the `multiply` method.

By adding a test case for the above method:

```cadence calculator_test.cdc
...

access(all)
fun testMultiply() {
    Test.assertEqual(10, Calculator.multiply(a: 2, b: 5))
}
```

our code coverage percentage goes to `100%`:

```bash
flow test --cover --covercode="contracts" calculator_test.cdc

Test results: "calculator_test.cdc"
- PASS: testAdd
- PASS: testSubtract
- PASS: testMultiply
Coverage: 100.0% of statements
```

## Advanced Testing Techniques

The Cadence testing framework provides various features and techniques for writing comprehensive test scenarios. Some of these include:

- [**Code Coverage**](https://github.com/m-Peter/flow-code-coverage): You can use the `--cover` flag with the `flow test` command to view code coverage results when running your tests. This allows you to identify areas of your code that are not adequately covered by your test inputs.
- **Test Helpers**: Test helpers are reusable functions that help you set up the initial state for your test files. You can define test helpers in a Cadence program and use them in your test files by importing it whenever needed.
- [**Assertions**](https://cadence-lang.org/docs/testing-framework.mdx#assertions): The testing framework provides built-in assertion functions, such as `assertEqual`, `beNil`, `beEmpty`, `contain`, to help you verify the expected behavior of your smart contracts.
- **Test Suites**: You can organize your test files into test suites to improve the readability and maintainability of your test code. Test suites allow you to group related test cases and set up common test helpers for all the tests in the suite.
- [**Integration tests**](https://github.com/bjartek/overflow): In our previous example, we would directly call the available methods on the contract under test. This is generally categorized as unit testing. You can also write integration tests, by executing scripts & transactions to interact with the contracts under testing. If you would like to write your tests in Go, instead of Cadence, you can use [Overflow tool](https://github.com/bjartek/overflow) to run integration tests against either an local emulator, testnet, mainnet or an in memory instance of the flow-emulator.

By leveraging these advanced testing techniques, you can write more robust and reliable smart contracts in Cadence. In this example, we set up a basic testing environment, wrote a simple smart contract in Cadence, and created a test file to verify its functionality. We then used the Flow CLI to run the test file and confirm that the smart contract is working correctly.

This is a basic example, and there are many more advanced features and techniques you can explore when working with the Cadence Testing Framework. 

For more in-depth tutorials and documentation, refer to the official [Cadence language documentation](https://cadence-lang.org/) and the [Flow CLI documentation](../../../tools/flow-cli/index.md).

## Testing Requirements

It is suggested to follow the following best practices:

- Every publicly exposed feature of a contract and its resources should have unit tests that check both for success with correct input _and_ for failure with incorrect input.
  These tests should be capable of being run locally with the Flow emulator, with no or minimal extra resources or configuration, and with a single command.
- Each user story or workflow that uses the smart contracts should have an integration test that ensures that the series of steps required to complete it does so successfully with test data.

Make sure you test all contracts - and the integration into your application extensively before proceeding to the mainnet.
You should aim to replicate all conditions as closely as possible to the usage patterns on mainnet.

## Writing Tests

There are official SDKs/frameworks for Flow in Cadence, Go and JavaScript.

In all three cases, the test code will need to deploy the contracts, configure accounts to interact with them and send transactions to them. It will then have to wait for the transactions to be sealed and check the results by catching exceptions, checking for events, and querying state using scripts.

### Cadence tests

Cadence comes with built-in support for code coverage, as well as a native testing framework which allows developers to write their tests using Cadence.
This framework is bundled with the [Flow CLI](../../../tools/flow-cli/index.md) tool, which includes a dedicated command for running tests (`flow test`).

You can find examples of Cadence tests in the following projects: [hybrid-custody](https://github.com/onflow/hybrid-custody/tree/main/test), [flow-nft](https://github.com/onflow/flow-nft/tree/master/tests), [flow-ft](https://github.com/onflow/flow-ft/tree/master/tests).
Visit the [documentation](https://cadence-lang.org/docs/testing-framework) to view all the available features.

The [Hybrid Custody](https://github.com/onflow/hybrid-custody#readme) project is a prime example which utilizes both the Cadence testing framework and code coverage in its CI.

![Hybrid Custody CI](./hybrid-custody-ci.png)

There is also a [repository](https://github.com/m-Peter/flow-code-coverage#readme) which contains some sample contracts and their tests.

![Automated CI Coverage Report](./codecov-in-pr.png)

![Coverage Report Visualization](./codecov-insights.png)

<Callout type="info">
The Cadence testing framework utilizes the emulator under the hood.
</Callout>

### Go Tests

Tests in Go can be written using [flow-go-sdk](https://github.com/onflow/flow-go-sdk) and the go test command.

You can find examples of Go tests in the following projects: [flow-core-contracts](https://github.com/onflow/flow-core-contracts/tree/master/lib/go/test), [flow-nft](https://github.com/onflow/flow-nft/tree/master/lib/go/test), [flow-ft](https://github.com/onflow/flow-ft/tree/master/lib/go/test).

<Callout type="info">
These tests are tied to the emulator but can be refactored to run on testnet
</Callout>

### JavaScript Tests

Tests in JavaScript can be written using [flow-js-testing](https://github.com/onflow/flow-js-testing).

It is critical to test your applications and contracts thoroughly on the testnet as part of your road to the mainnet. Testing will help you understand how to create stable and robust applications using the Flow development stack.

## Testing Your Application

### Automated Testing of Contract Code

All contracts should include test coverage for _all contract functions_. Make sure you've accounted for success and failure cases appropriately.

Tests should also be runnable in automated environments (CI). You can use the [JavaScript testing framework](https://github.com/onflow/flow-js-testing) to create tests for your smart contract code.

### Stress Testing Live Applications Before Mainnet

Once you deployed your application to the testnet, you should record how your application handles non-trivial amounts of traffic to ensure there are no issues.

<Callout type="success">
Get familiar with the [Cadence anti-patterns](https://cadence-lang.org/docs/anti-patterns) to avoid avoid problematic or unintended behavior.
</Callout>


## References

- [Reference documentation for Cadence testing](https://cadence-lang.org/docs/testing-framework)
- [Overflow](https://github.com/bjartek/overflow) is a powerful Golang-based DSL for efficient testing and execution of blockchain interactions
- projects that have good examples of robust test cases:
  - [hybrid-custody](https://github.com/onflow/hybrid-custody/tree/main/test),
  - [flow-nft](https://github.com/onflow/flow-nft/tree/master/tests),
  - [flow-ft](https://github.com/onflow/flow-ft/tree/master/tests).
---
title: IOS Quickstart
sidebar_label: IOS Quickstart
sidebar_position: 2
---

# Overview

The following documentation aims to educate you on building a native mobile application on Flow. It first presents Monster Maker, a starter project we’ve built to represent simple Flow mobile concepts. Next it presents various developer resources related to building mobile native Flow applications.

# Monster Maker

![monster_maker_logo.png](resources/monster_maker_logo.png)

Monster Maker is a native iOS app that allows users to connect a wallet, sign a transaction to mint an NFT (a monster) and display their collection of NFTs (their monsters) within the app. It’s meant to be a lightweight sample project to exemplify how to build a mobile native Flow project. If you’re looking to build a native mobile application for Flow, exploring the Monster Maker code base first or even building off of it is a great way to get started.

<aside>
👉 ***Note** - We currently only have an iOS project for Monster Maker. That said an Android and web version of the same project is in active development.*

</aside>

## Github Repo

The Monster Maker Github Repo can be found here:

https://github.com/onflow/monster-maker

## Building to Device

Before you run Monster Maker on your device, please make sure you have installed the [Xcode14](https://apps.apple.com/au/app/xcode/id497799835?mt=12) from Mac App Store. Once you clone the repo, open the [MonsterMaker.xcodeproj](https://github.com/onflow/monster-maker/tree/main/iOS/MonsterMaker.xcodeproj) under the iOS folder.

Xcode should automatically setup the project for you. If you do see any error related to dependencies, run `Xcode Menu -> File -> Packages -> Reset Package Cache` to resolve the issue.

In the meantime, you can choose a simulator or your iPhone to run. For more detail here is the [official doc](https://developer.apple.com/documentation/xcode/running-your-app-in-simulator-or-on-a-device).
For run in real device, there are a few steps to deal with signing:

1. Add your apple account to the Xcode which can be accessed from `Xcode Menu -> Settings -> Add account`.
2. Change the Team to your Personal Apple account from the **Signing & Capabilities** under the project target menu. For more detail, please check the screenshot below.

   ![XCode Target Setup](resources/xcode_setup.png)


## Connecting to a Wallet

To connect with wallets, there is native wallet discovery in the app. Once you click on connect, it will bring out the list of the wallets which support `HTTP/POST` or `WC/RPC` method.

### FCL Config

To make sure, the wallet can recognise your dApp, there is a few field you will need to config before connect to a wallet. The account proof config is optional. In addition, you will need to create a project id from [walletconnect](https://cloud.walletconnect.com/app) cloud before you can connect to the `WC/RPC` compatible wallet such as dapper self custody or lilico wallet.

```swift
import FCL

// Config the App
let defaultProvider: FCL.Provider = .dapperPro
let defaultNetwork: Flow.ChainID = .testnet // or .mainnet

// Optinal: Config for account proof
let accountProof = FCL.Metadata.AccountProofConfig(appIdentifier: "Monster Maker")

// Config for WC/RPC compatible wallet
let walletConnect = FCL.Metadata.WalletConnectConfig(urlScheme: "monster-maker://", projectID: "12ed93a2aae83134c4c8473ca97d9399")

// Config basic dApp info
let metadata = FCL.Metadata(appName: "Monster Maker",
                            appDescription: "Monster Maker Demo App for mobile",
                            appIcon: URL(string: "https://i.imgur.com/jscDmDe.png")!,
                            location: URL(string: "https://monster-maker.vercel.app/")!,
                            accountProof: accountProof,
                            walletConnectConfig: walletConnect)
fcl.config(metadata: metadata,
           env: defaultNetwork,
           provider: defaultProvider)

// Import keywords replacement for cadence query and transaction
fcl.config
    .put("0xFungibleToken", value: "0x631e88ae7f1d7c20")
    .put("0xMonsterMaker", value: "0xfd3d8fe2c8056370")
    .put("0xMetadataViews", value: "0x631e88ae7f1d7c20")
    .put("0xTransactionGeneration", value: "0x44051d81c4720882")
```

### Open wallet discovery

![In Monster Maker, the Connect button triggers opening of Wallet Discovery](resources/connect.png)

In Monster Maker, the Connect button triggers opening of Wallet Discovery

For the wallet support `HTTP/POST`, it will use webview to show the following actions.

For the wallet support `WC/RPC`, it will use deep-link to the wallet for actions.

You can open the native wallet discovery to make the selection, but also you can connect to the specific wallet as well.

Here is the code snippet of it:

```swift
import FCL

// Open discovery view
fcl.openDiscovery()

// Or manual connect to specific wallet
try fcl.changeProvider(provider: provider, env: .testnet)
try await fcl.authenticate()
```

## Signing a Transaction

![In Monster Maker, Initializing the NFT collection with the Initialize button triggers a transaction.](resources/initialize.png)

In Monster Maker, Initializing the NFT collection with the Initialize button triggers a transaction.

Similar to what we have on fcl-js, native sdk also use `query` and `mutate` for on-chain interactions. To request a signature from user, you can simply use `fcl.mutate` method. By default, the user will be the payer, proposer and authorizer, if you want to add custom authorizer please refer to the code from [Server](https://github.com/onflow/monster-maker/blob/main/server/pages/api/signAsMinter/index.ts) and [iOS](https://github.com/onflow/monster-maker/blob/main/iOS/MonsterMaker/Flow/MintHelper.swift) end.

```swift
guard let user = fcl.currentUser else {
    // Not signin
    return
}

let txId = try await fcl.mutate(
                            cadence: """
                                    transaction(test: String, testInt: Int) {
                                                   prepare(signer: AuthAccount) {
                                                        log(signer.address)
                                                        log(test)
                                                        log(testInt)
                                                   }
                                               }
                                    """,
                            args: [
														.string("Hello"),
                            .int(10)
                           ],
                            gasLimit: 999,
                            authorizors: [user])

print("txId -> \(txId)")
```

## View NFT

![The View page in Monster Maker exemplifies showing Monster Maker NFTs held by the connected wallet](resources/collection.png)

The View page in Monster Maker exemplifies showing Monster Maker NFTs held by the connected wallet

To view the NFT from an wallet address, first and foremost, we highly recommend you use [NFT-Catalog](https://www.flow-nft-catalog.com/) standard when you are ready. So that it will be easy to allow other platform like marketplace and wallet to recognise and display your NFT collection. However, during development, you always can query your NFT with `fcl.query`. Here is an example:

- Query cadence

    ```swift
    import NonFungibleToken from 0xNonFungibleToken
        import MonsterMaker from 0xMonsterMaker
        import MetadataViews from 0xMetadataViews
        
        pub struct Monster {
            pub let name: String
            pub let description: String
            pub let thumbnail: String
            pub let itemID: UInt64
            pub let resourceID: UInt64
            pub let owner: Address
            pub let component: MonsterMaker.MonsterComponent
    
            init(
                name: String,
                description: String,
                thumbnail: String,
                itemID: UInt64,
                resourceID: UInt64,
                owner: Address,
                component: MonsterMaker.MonsterComponent
            ) {
                self.name = name
                self.description = description
                self.thumbnail = thumbnail
                self.itemID = itemID
                self.resourceID = resourceID
                self.owner = owner
                self.component = component
            }
        }
    
        pub fun getMonsterById(address: Address, itemID: UInt64): Monster? {
    
            if let collection = getAccount(address).getCapability<&MonsterMaker.Collection{NonFungibleToken.CollectionPublic, MonsterMaker.MonsterMakerCollectionPublic}>(MonsterMaker.CollectionPublicPath).borrow() {
                
                if let item = collection.borrowMonsterMaker(id: itemID) {
                    if let view = item.resolveView(Type<MetadataViews.Display>()) {
                        let display = view as! MetadataViews.Display
                        let owner: Address = item.owner!.address!
                        let thumbnail = display.thumbnail as! MetadataViews.HTTPFile
    
                        return Monster(
                            name: display.name,
                            description: display.description,
                            thumbnail: thumbnail.url,
                            itemID: itemID,
                            resourceID: item.uuid,
                            owner: address,
                            component: item.component
                        )
                    }
                }
            }
    
            return nil
        }
    
        pub fun main(address: Address): [Monster] {
            let account = getAccount(address)
            let collectionRef = account.getCapability(MonsterMaker.CollectionPublicPath)!.borrow<&{NonFungibleToken.CollectionPublic}>()
                ?? panic("Could not borrow capability from public collection")
            
            let ids = collectionRef.getIDs()
    
            let monsters : [Monster] = []
    
            for id in ids {
                if let monster = getMonsterById(address: address, itemID: id) {
                    monsters.append(monster)
                }
            }
    
            return monsters
        }
    ```


```swift
let nftList = try await fcl.query(script: cadenceScript, 
																		args: [.address(address)])
														.decode([NFTModel].self)
```

# External Resources

**FCL Swift**

FCL Swift is the iOS native SDK for FCL. This SDK is integrated into the Monster Maker sample.

https://github.com/Outblock/fcl-swift

**FCL Android**

FCL Android is the Android native SDK for FCL.

https://github.com/Outblock/fcl-android

**FCL Wallet Connect 2.0**

One of the easiest ways to connect to a wallet via a mobile native dApp is through Flow’s new support for Wallet Connect 2.0. This is the pattern that Monster Maker uses to connect to the Dapper Self Custody wallet and Lilico. For more information on FCL Wallet Connect 2.0, check out this page:

[FCL Wallet Connect](../../tools/clients/fcl-js/wallet-connect.mdx)


**How to Build a Native iOS Dapp**

The Agile Monkeys has written a very comprehensive guide on how to build a native mobile application on iOS and interface with fcl-swift. Found here:

[How to Build a Native iOS Dapper](https://dev.to/theagilemonkeys/how-to-buid-a-native-ios-dapp-that-uses-the-flow-blockchain-as-the-backend-n9k)
[Source Code](https://github.com/jfsagasti/FlowNotes)
---
title: Overview
sidebar_label: Overview
sidebar_position: 1
---

Building mobile native applications that interact with the blockchain enables a much richer end user experiences and provides access to OS capabilities. With Flow Mobile, developers can build native applications for iOS and Android leveraging SDKs and mobile wallets.

## Why Flow

Millions of users with Flow accounts are exploring the ecosystem and looking for applications. Most of these users purchased Flow NFTs and are comfortable with web3 principles. 

In addition to the existing userbase, developers can tap into smart contracts deployed on the Flow blockchain. These contracts, including their on-chain state, provide unique possibilities to build experiences that enrich applications users are already using.

The following key capabilities make Flow a standout choice for mobile applications:
- On-device key encryption via Secure Enclave & Keychain
- Mobile wallet compabilitity and support for WalletConnect 2.0
- Simple, progressive onboarding experience with postponed account linking
- Seamless in-app experience with on-chain interactions without constant signing requests
- Account flexibility enabling secure account recovery and sharing

## Why Flow Mobile

### Proven 

Flow is built with mainstream adoption in mind. Mobile applications can leverage the best-in-class user experiences millions of users have enjoyed on the web, through applications like NBA TopShot or NFL AllDay.

### Best-in-class UX

Flow's Client Library makes it very intuitive to sign up and sign in with their wallet of choice. For transaction signing, Flow offers human readable security, so users get a clear understanding of what they are approving. An increased sense of trust for Flow applications is the outcome. 

Furthermore, Flow's powerful account model allows for seamless user flows of on-chain operations. Apps can perform transactions on behalf of the users (with their approval) in the background, without the need to switch between apps. The account model also allows apps to pay for transactions to postpone fiat on-ramps to get them to experience the value of an application before committing to buying tokens. 

Last but not least, developers can leverage progressive web3 onboarding, in which any identity provider can be used to authenticate users, without having to deal with keys. Developers can create Flow accounts for the users and link them to a wallet at a later point in time.

### Security first

Flow's mobile SDKs use on-device key encryption via Apple's Secure Enclave and Android's Keystore. The flexible account model makes it possible for an account to have multiple keys with different weights, which enables secure social recovery, account sharing, and much more.

## Smart contract language inspired by mobile languages

Cadence, Flow's smart contract language, will look and feel very familiar to mobile languages developers are already familiar with. Cadence was inspired by Move, Swift, and Kotlin. This reduces the ramp-up period to develop mobile applications leveraging on-chain logic.

## What is available

Developers can leverage the following features to get productive quickly:

- Swift & Kotlin FCL SDKs to auth and interact with the Flow blockchain (query + execute scripts)
- FCL-compatible mobile wallets
- User auth using WalletConnect 2.0 
- Basic mobile sample application (MonsterMaker)

Coming soon:

- Samples for key in-app functionality, like in-app purchasing
- Progressive user onboarding
- React Native SDK
---
title: React Native Quickstart
sidebar_label: React Native Quickstart
sidebar_position: 3
---

**Last Updated:** January 11th 2022

> **Note**: This page will walk you through a very bare bones project to get started building a web3 dapp using the Flow Client Library (FCL). If you are looking for a clonable repo, Flow community members have created quickstart templates for different JavaScript frameworks (e.g. [Next.js](https://github.com/muttoni/fcl-nextjs-quickstart), [SvelteKit](https://github.com/muttoni/fcl-sveltekit-quickstart), [Nuxt](https://github.com/bluesign/nuxt3-fcl)). You can consult the complete list [here](https://github.com/ph0ph0/Get-The-Flow-Down#fcl).

## Introduction

FCL-JS is the easiest way to start building decentralized applications. FCL (aka Flow Client Library) wraps much of the logic you'd have to write yourself on other blockchains. Follow this quick start and you'll have a solid overview of how to build a shippable dapp on Flow.

We're going to make an assumption that you know or understand React; however, the concepts should be easy to understand and transfer to another framework. While this tutorial will make use of Cadence (Flow's smart contract language), you do not need to know it. Instead, we recommend later diving into [learning the Cadence language](../guides/smart-contracts/cadence.md) once you've gotten the core FCL concepts down.

In this tutorial, we are going to interact with an existing smart contract on Flow's testnet known as the [Profile Contract](https://testnet.flowdiver.io/contract/A.ba1132bc08f82fe2.Profile). Using this contract, we will create a new profile and edit the profile information, both via a wallet. In order to do this, the FCL concepts we'll cover are:

- [Installation](#installation)
- [Configuration](#configuration)
- [Authentication](#authentication)
- [Querying the Blockchain](#querying-the-blockchain)
- [Initializing an Account](#initializing-an-account)
- [Mutating the Blockchain](#mutating-the-blockchain)

And if you ever have any questions we're always happy to help on [Discord](https://discord.gg/flow). There are also links at the end of this article for diving deeper into building on Flow.

## Installation

The first step is to generate a React app using Next.js and [create-expo-app](https://docs.expo.dev/get-started/create-a-project/). From your terminal, run the following:

```sh
npx create-expo-app flow-react-native
cd flow-react-native
```

Next, install FCL so we can use it in our app.

```sh
npm install @onflow/fcl@alpha @react-native-async-storage/async-storage expo-web-browser --save
```

Now run the app using the following command in your terminal.

```sh
npm run start
```

You should now see your app running.

## Configuration

Now that your app is running, you can configure FCL. Within the main project directory, create a folder called `flow` and create a file called `config.js`. This file will contain configuration information for FCL, such as what Access Node and wallet discovery endpoint to use (e.g. testnet or a local emulator). Add the following contents to the file:

**Note**: These values are required to use FCL with your app.

> **Create file:** `./flow/config.js`

```javascript ./flow/config.js
import { config } from "@onflow/fcl";

config({
  "accessNode.api": "https://rest-testnet.onflow.org", // Mainnet: "https://rest-mainnet.onflow.org"
  "discovery.wallet": "https://fcl-discovery.onflow.org/testnet/authn", // Mainnet: "https://fcl-discovery.onflow.org/authn"
  "discovery.authn.endpoint": "https://fcl-discovery.onflow.org/api/testnet/authn", // Mainnet: "https://fcl-discovery.onflow.org/api/authn"
})
```
📣 **Tip**: It's recommend to replace these values with environment variables for easy deployments across different environments like development/production or Testnet/Mainnet.

- The `accessNode.api` key specifies the address of a Flow access node. Flow provides these, but in the future access to Flow may be provided by other 3rd parties, through their own access nodes.
- `discovery.wallet` and `discovery.authn.endpoint` are addresses that point to a service that lists FCL compatible wallets. Flow's FCL Discovery service is a service that FCL wallet providers can be added to, and be made 'discoverable' to any application that uses the `discovery.wallet` and `discovery.authn.endpoint`.

> Learn more about [configuring Discovery](../../tools/clients/fcl-js/discovery.mdx) or [setting configuration values](../../tools/clients/fcl-js/api.md#setting-configuration-values).

> If you are running a Wallet Discovery locally and want to use it in the React Native app, change `https://fcl-discovery.onflow.org/` to `http://<LOCAL_IP_ADDRESS>:<PORT>/`
> For Example:
> using local [Wallet Discovery](../../tools/clients/fcl-js/discovery.mdx) and local [Dev Wallet](../../tools/flow-dev-wallet/index.md):
>
> ```javascript ./flow/config.js
> import { config } from "@onflow/fcl";
>
> config({
>   ...
>   "discovery.wallet": "http://10.0.0.1:3002/local/authn",
>   "discovery.authn.endpoint": "http://10.0.0.1:3002/api/local/authn",
>   ...
> })
> ```

The main screen for React Native apps is located in `./App.js` or in `./App.tsx`. So let's finish configuring our dapp by going in the root directory and importing the config file into the top of our `App.js` file. We'll then swap out the default component in `App.js` to look like this:

> **Replace file:** `./App.js`

```jsx ./App.js
import { StatusBar } from 'expo-status-bar';
import { StyleSheet, Text, View } from 'react-native';
import "./flow/config";

export default function App() {
  return (
    <View style={styles.container}>
      <Text>Open up App.js to start working on your app!</Text>
      <StatusBar style="auto" />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
  },
});


```

Now we're ready to start talking to Flow!

## Authentication

To authenticate a user, you'll need to render a `ServiceDiscovery` component provided by `fcl-react-native`. Alternatively you can build your own component using `useServiceDiscovery`.

Unauthenticate is as simple as calling `fcl.unauthenticate()`.  Once authenticated, FCL sets an object called `fcl.currentUser` which exposes methods for watching changes in user data, signing transactions, and more. For more information on the `currentUser`, read more [here](../../tools/clients/fcl-js/api.md#current-user).

Let's add in a few components and buttons buttons for sign up/login and also subscribe to changes on the `currentUser`. When the user is updated (which it will be after authentication), we'll set the user state in our component to reflect this. To demonstrate user authenticated sessions, we'll conditionally render a component based on if the user is or is not logged in.

This is what your file should look like now:

> **Replace file:** `./App.js`

```jsx ./App.js
import { Text, View, Button } from 'react-native';
import "./flow/config";

import { useState, useEffect } from "react";
import * as fcl from "@onflow/fcl/dist/fcl-react-native";

export default function App() {

  const [user, setUser] = useState({loggedIn: null})

  useEffect(() => fcl.currentUser.subscribe(setUser), [])

  const AuthedState = () => {
    return (
      <View>
        <Text>Address: {user?.addr ?? "No Address"}</Text>
        <Button onPress={fcl.unauthenticate} title='Log Out'/>
      </View>
    )
  }

  if (user.loggedIn) {
    return <View style={styles.container}>
       <Text>Flow App</Text>
        <AuthedState />
        <StatusBar style="auto" />
     </View>
  }

  return (
    <fcl.ServiceDiscovery fcl={fcl}/>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
  },
});

```

You should now be able to log in or sign up a user and unauthenticate them. Upon logging in or signing up your users will see a popup where they can choose between wallet providers. Let's select the [Blocto wallet](https://blocto.portto.io/) for this example to create an account. Upon completing authentication, you'll see the component change and the user's wallet address appear on the screen if you've completed this properly.

## Querying the Blockchain

One of the main things you'll often need to do when building a dapp is query the Flow blockchain and the smart contracts deployed on it for data. Since smart contracts will live on both Testnet and Mainnet, let's put the account address where the smart contract lives into the configuration (remember, it's recommended that you change this later to use environment variables). Let's also give it a key of `Profile` and prefix it with `0x` so that the final key is `0xProfile`. The prefix is important because it tells FCL to pull the corresponding addresses needed from the configuration value.

> **Replace file:** `./flow/config.js`

```javascript ./flow/config.js
import { config } from "@onflow/fcl";

config({
 "accessNode.api": "https://rest-testnet.onflow.org", // Mainnet: "https://rest-mainnet.onflow.org"
  "discovery.wallet": "https://fcl-discovery.onflow.org/testnet/authn", // Mainnet: "https://fcl-discovery.onflow.org/authn"
  "discovery.authn.endpoint": "https://fcl-discovery.onflow.org/api/testnet/authn",
  "0xProfile": "0xba1132bc08f82fe2" // The account address where the Profile smart contract lives on Testnet
})
```

If you want to see the on chain smart contract we'll be speaking with next, you can view the [Profile Contract](https://testnet.flowdiver.io/contract/A.ba1132bc08f82fe2.Profile) source code but again for this tutorial it's not necessary you understand it.

**First, lets query the contract to see what the user's profile name is.** 

A few things need to happen in order to do that: 
1. We need to import the contract and pass it the user's account address as an argument.
2. Execute the script using `fcl.query`.
3. Set the result of the script to the app state in React so we can display the profile name in our browser.
4. Display "No Profile" if one was not found.

Take a look at the new code. We'll explain each new piece as we go. Remember, the cadence code is a separate language from JavaScript used to write smart contracts, so you don't need to spend too much time trying to understand it. (Of course, you're more than welcome to, if you want to!)

> **Replace file:** `./App.js`

```jsx ./App.js
import { StatusBar } from 'expo-status-bar';
import { StyleSheet, Text, View, Button } from 'react-native';
import { useEffect, useState } from 'react';
import './flow/config'

import * as fcl from "@onflow/fcl/dist/fcl-react-native";

export default function App() {

  const [user, setUser] = useState({loggedIn: null})
  const [name, setName] = useState('') // NEW

  useEffect(() => fcl.currentUser.subscribe(setUser), [])

  // NEW
  const sendQuery = async () => {
    const profile = await fcl.query({
      cadence: `
        import Profile from 0xProfile

        pub fun main(address: Address): Profile.ReadOnly? {
          return Profile.read(address)
        }
      `,
      args: (arg, t) => [arg(user.addr, t.Address)]
    })

    setName(profile?.name ?? 'No Profile')
  }

  const AuthedState = () => {
    return (
      <View >
        <Text>Address: {user?.addr ?? "No Address"}</Text>{/* NEW */}
        <Text>Profile Name: {name ?? "--"}</Text>{/* NEW */}
        <Button onPress={sendQuery} title='Send Query'/>{/* NEW */}
        <Button onPress={fcl.unauthenticate} title='Log Out'/>
      </View>
    )
  }

  if (user.loggedIn) {
    return <View style={styles.container}>
        <Text>Flow App</Text>
        <AuthedState />
        <StatusBar style="auto" />
     </View>
  }

  return (
    <fcl.ServiceDiscovery fcl={fcl}/>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
  },
});

```

A few things happened. In our `AuthedState` component, we added a button to send a query for the user's profile name and a `Text` to display the result above it. The corresponding `useState` initialization can be seen at the top of the component.

The other thing we did is build out the actual query inside of `sendQuery` method. Let's take a look at it more closely:

```javascript
await fcl.query({
  cadence: `
    import Profile from 0xProfile

    pub fun main(address: Address): Profile.ReadOnly? {
      return Profile.read(address)
    }
  `,
  args: (arg, t) => [arg(user.addr, t.Address)]
});
```

Inside the query you'll see we set two things: `cadence` and `args`. Cadence is Flow's smart contract language we mentioned. For this tutorial, when you look at it you just need to notice that it's importing the `Profile` contract from the account we named `0xProfile` earlier in our config file, then also taking an account address, and reading it. That's it until you're ready to [learn more Cadence](https://cadence-lang.org/docs/tutorial/first-steps).

In the `args` section, we are simply passing it our user's account address from the user we set in state after authentication and giving it a type of `Address`.  For more possible types, [see this reference](../../tools/clients/fcl-js/api.md#ftype).

Go ahead and click the "Send Query" button. You should see "No Profile." That's because we haven't initialized the account yet.

## Initializing the Account

For the Profile contract to store a Profile in a user's account, it does so by initializing what is called a "resource." A resource is an ownable piece of data and functionality that can live in the user's account storage. This paradigm is known is as "resource-oriented-programming", a principle that is core to Cadence and differentiates its ownership model from other smart contract languages, [read more here](../guides/smart-contracts/cadence.md#intuiting-ownership-with-resources). Cadence makes it so that resources can only exist in one place at any time, they must be deliberately created, cannot be copied, and if desired, must be deliberately destroyed.

> There's a lot more to resources in Cadence than we'll cover in this guide, so if you'd like to know more, check out [this Cadence intro](../guides/smart-contracts/cadence.md).

To do this resource initialization on an account, we're going to add another function called `initAccount`. Inside of that function, we're going to add some Cadence code which says, *"Hey, does this account have a profile? If it doesn't, let's add one."* We do that using something called a "transaction." Transactions occur when you want to change the state of the blockchain, in this case, some data in a resource, in a specific account. And there is a cost (transaction fee) in order to do that; unlike a query.

That's where we jump back into FCL code. Instead of `query`, we use `mutate` for transactions. And because there is a cost, we need to add a few fields that tell Flow who is proposing the transaction, who is authorizing it, who is paying for it, and how much they're willing to pay for it. Those fields — not surprisingly — are called: `proposer`, `authorizer`, `payer`, and `limit`. For more information on these signatory roles, check out [this doc](../basics/transactions.md#signer-roles).

Let's take a look at what our account initialization function looks like:

```javascript
const initAccount = async () => {
  const transactionId = await fcl.mutate({
    cadence: `
      import Profile from 0xProfile

      transaction {
        prepare(account: AuthAccount) {
          // Only initialize the account if it hasn't already been initialized
          if (!Profile.check(account.address)) {
            // This creates and stores the profile in the user's account
            account.save(<- Profile.new(), to: Profile.privatePath)

            // This creates the public capability that lets applications read the profile's info
            account.link<&Profile.Base{Profile.Public}>(Profile.publicPath, target: Profile.privatePath)
          }
        }
      }
    `,
    payer: fcl.authz,
    proposer: fcl.authz,
    authorizations: [fcl.authz],
    limit: 50
  })

  const transaction = await fcl.tx(transactionId).onceSealed()
  console.log(transaction)
}
```

You can see the new fields we talked about. You'll also notice `fcl.authz`. That's shorthand for "use the current user to authorize this transaction", (you could also write it as `fcl.currentUser.authorization`). If you want to learn more about transactions and signing transactions, you can [view the docs here](../basics/transactions.md). For this example, we'll keep it simple with the user being each of these roles.

You'll also notice we are awaiting a response with our transaction data by using the syntax `fcl.tx(transactionId).onceSealed()`. This will return when the blockchain has sealed the transaction and it's complete in processing it and verifying it.

Now your `index.js` file should look like this (we also added a button for calling the `initAccount` function in the `AuthedState`):

> **Replace file:** `./App.js`

```jsx ./App.js
import { StatusBar } from 'expo-status-bar';
import { StyleSheet, Text, View, Button } from 'react-native';
import { useEffect, useState } from 'react';
import './flow/config'

import * as fcl from "@onflow/fcl/dist/fcl-react-native";

export default function App() {

  const [user, setUser] = useState({loggedIn: null})
  const [name, setName] = useState('')

  useEffect(() => fcl.currentUser.subscribe(setUser), [])

  const sendQuery = async () => {
    const profile = await fcl.query({
      cadence: `
        import Profile from 0xProfile

        pub fun main(address: Address): Profile.ReadOnly? {
          return Profile.read(address)
        }
      `,
      args: (arg, t) => [arg(user.addr, t.Address)]
    })

    setName(profile?.name ?? 'No Profile')
  }

  // NEW
  const initAccount = async () => {
    const transactionId = await fcl.mutate({
      cadence: `
        import Profile from 0xProfile
  
        transaction {
          prepare(account: AuthAccount) {
            // Only initialize the account if it hasn't already been initialized
            if (!Profile.check(account.address)) {
              // This creates and stores the profile in the user's account
              account.save(<- Profile.new(), to: Profile.privatePath)
  
              // This creates the public capability that lets applications read the profile's info
              account.link<&Profile.Base{Profile.Public}>(Profile.publicPath, target: Profile.privatePath)
            }
          }
        }
      `,
      payer: fcl.authz,
      proposer: fcl.authz,
      authorizations: [fcl.authz],
      limit: 50
    })
  
    const transaction = await fcl.tx(transactionId).onceSealed()
    console.log(transaction)
  }

  const AuthedState = () => {
    return (
      <View >
        <Text>Address: {user?.addr ?? "No Address"}</Text>
        <Text>Profile Name: {name ?? "--"}</Text>
        <Button onPress={sendQuery} title='Send Query'/>
        <Button onPress={initAccount} title='Init Account'/>{/* NEW */}
        <Button onPress={fcl.unauthenticate} title='Log Out'/>
      </View>
    )
  }

  if (user.loggedIn) {
    return <View style={styles.container}>
        <Text>Flow App</Text>
        <AuthedState />
        <StatusBar style="auto" />
     </View>
  }

  return (
    <fcl.ServiceDiscovery fcl={fcl}/>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
  },
});

```

Press the "Init Account" button you should see the wallet ask you to approve a transaction. After approving, you will see a transaction response appear in your console (make sure to have that open). It may take a few moments. With the transaction result printed, you can use the `transactionId` to look up the details of the transaction using a [block explorer](https://testnet.flowdiver.io/).

## Mutating the Blockchain

Now that we have the profile initialized, we are going to want to mutate it some more. In this example, we'll use the same smart contract provided to change the profile name.

To do that, we are going to write another transaction that adds some Cadence code which lets us set the name. Everything else looks the same in the following code except for one thing: we'll subscribe to the status changes instead of waiting for it to be sealed after the mutate function returns.

It looks like this:

```javascript
const executeTransaction = async () => {
  const transactionId = await fcl.mutate({
    cadence: `
      import Profile from 0xProfile

      transaction(name: String) {
        prepare(account: AuthAccount) {
          account
            .borrow<&Profile.Base{Profile.Owner}>(from: Profile.privatePath)!
            .setName(name)
        }
      }
    `,
    args: (arg, t) => [arg("Flow Developer", t.String)],
    payer: fcl.authz,
    proposer: fcl.authz,
    authorizations: [fcl.authz],
    limit: 50
  })

  fcl.tx(transactionId).subscribe(res => setTransactionStatus(res.status))
}
```

Here you can see our argument is "Flow Developer" and at the bottom we've called the `subscribe` method instead of `onceSealed`.

Let's see how that works inside our whole `index.js` file. But, let's also set the statuses to our React component's state so we can see on screen what state we're in.

> **Replace file:** `./App.js`

```jsx ./App.js
import { StatusBar } from 'expo-status-bar';
import { StyleSheet, Text, View, Button } from 'react-native';
import { useEffect, useState } from 'react';
import './flow/config'

import * as fcl from "@onflow/fcl/dist/fcl-react-native";

export default function App() {

  const [user, setUser] = useState({loggedIn: null})
  const [name, setName] = useState('')
  const [transactionStatus, setTransactionStatus] = useState(null) // NEW

  useEffect(() => fcl.currentUser.subscribe(setUser), [])

  const sendQuery = async () => {
    const profile = await fcl.query({
      cadence: `
        import Profile from 0xProfile

        pub fun main(address: Address): Profile.ReadOnly? {
          return Profile.read(address)
        }
      `,
      args: (arg, t) => [arg(user.addr, t.Address)]
    })

    setName(profile?.name ?? 'No Profile')
  }

  const initAccount = async () => {
    const transactionId = await fcl.mutate({
      cadence: `
        import Profile from 0xProfile
  
        transaction {
          prepare(account: AuthAccount) {
            // Only initialize the account if it hasn't already been initialized
            if (!Profile.check(account.address)) {
              // This creates and stores the profile in the user's account
              account.save(<- Profile.new(), to: Profile.privatePath)
  
              // This creates the public capability that lets applications read the profile's info
              account.link<&Profile.Base{Profile.Public}>(Profile.publicPath, target: Profile.privatePath)
            }
          }
        }
      `,
      payer: fcl.authz,
      proposer: fcl.authz,
      authorizations: [fcl.authz],
      limit: 50
    })
  
    const transaction = await fcl.tx(transactionId).onceSealed()
    console.log(transaction)
  }

  // NEW
  const executeTransaction = async () => {
    const transactionId = await fcl.mutate({
      cadence: `
        import Profile from 0xProfile
  
        transaction(name: String) {
          prepare(account: AuthAccount) {
            account
              .borrow<&Profile.Base{Profile.Owner}>(from: Profile.privatePath)!
              .setName(name)
          }
        }
      `,
      args: (arg, t) => [arg("Flow Developer", t.String)],
      payer: fcl.authz,
      proposer: fcl.authz,
      authorizations: [fcl.authz],
      limit: 50
    })
  
    fcl.tx(transactionId).subscribe(res => setTransactionStatus(res.status))
  }

  const AuthedState = () => {
    return (
      <View >
        <Text>Address: {user?.addr ?? "No Address"}</Text>
        <Text>Profile Name: {name ?? "--"}</Text>
        <Text>Transaction Status: {transactionStatus ?? "--"}</Text>{/* NEW */}
        <Button onPress={sendQuery} title='Send Query'/>
        <Button onPress={initAccount} title='Init Account'/>{/* NEW */}
        <Button onPress={executeTransaction} title='Execute Transaction'/>{/* NEW */}
        <Button onPress={fcl.unauthenticate} title='Log Out'/>
      </View>
    )
  }

  if (user.loggedIn) {
    return <View style={styles.container}>
        <Text>Flow App</Text>
        <AuthedState />
        <StatusBar style="auto" />
     </View>
  }

  return (
    <fcl.ServiceDiscovery fcl={fcl}/>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
  },
});

```

Now if you click the "Execute Transaction" button you'll see the statuses update next to "Transaction Status." When you see "4" that means it's sealed! Status code meanings [can be found here](../../tools/clients/fcl-js/api.md#transaction-statuses).
If you query the account profile again, "Profile Name:" should now display "Flow Developer".

That's it! You now have a shippable Flow dapp that can auth, query, init accounts, and mutate the chain. This is just the beginning. There is so much more to know. We have a lot more resources to help you build. To dive deeper, here are a few good places for taking the next steps:

**Cadence**
- [Cadence Playground Tutorials](https://cadence-lang.org/docs/tutorial/first-steps)
- [Cadence Hello World Video](https://www.youtube.com/watch?v=pRz7EzrWchs)
- [Why Cadence?](https://www.onflow.org/post/flow-blockchain-cadence-programming-language-resources-assets)

**Full Stack NFT Marketplace Example**
- [Beginner Example: CryptoDappy](https://github.com/bebner/crypto-dappy)

**More FCL**
- [FCL API Quick Reference](../../tools/clients/fcl-js/api)
- [More on Scripts](../../tools/clients/fcl-js/scripts.mdx)
- [More on Transactions](../../tools/clients/fcl-js/transactions.mdx)
- [User Signatures](../../tools/clients/fcl-js/user-signatures.mdx)
- [Proving Account Ownership](../../tools/clients/fcl-js/proving-authentication.mdx)

**Other**
- [Flow Developer Onboarding Guide](../../tutorials/intro.md)
---
sidebar_position: 2
description: |
  User-friendly online tools that provide visual representations of blockchain data, facilitating easy navigation through transactions, blocks, addresses, and smart contracts while ensuring real-time insights and transparency.
sidebar_custom_props:
  icon: 🔍
---

# Block Explorers
Block explorers are user-friendly online tools that visually present blockchain data, allowing users to easily navigate transactions, blocks, addresses, and smart contracts while providing real-time insights and transparency.

<div id="cards" className="cards">

## Flow Diver

[Flow Diver](https://www.flowdiver.io/) provides various tools to explore the blockchain, including:

- Blocks
- Transactions
- Contracts

It also offers analytics for the mainnet:

- Network activity (transaction count)
- Transaction cost (gas fee)
- Validators information

## Flow View

[Flow View](https://www.flowview.app/) offers comprehensive tools to view accounts' information, including:

- Address, balance, and storage
- Public keys and their weights
- Staking information
- Tokens, collections, and listings
- Deployed smart contracts

Supported networks:

- Mainnet: [https://www.flowview.app/](https://www.flowview.app/)
- Testnet: [https://testnet.flowview.app/](https://testnet.flowview.app/)
- Emulator (local): [https://emulator.flowview.app/](https://emulator.flowview.app/)

## Contract Browser

[Contract Browser](https://contractbrowser.com/) provides tools for viewing deployed smart contracts, their dependencies, and dependents. Features include:

- Search, view, and verify smart contract source code
- Detailed smart contract information

[Testnet Contract Browser](https://testnet.contractbrowser.com/) is also available for `Testnet Flow`.

</div>
---
sidebar_position: 3
description: Mechanisms that connect different blockchain networks, allowing secure and decentralized transfer of assets and data across platforms.
sidebar_custom_props:
  icon: ⛓️
---

# Bridges

Bridges are mechanisms that connect different blockchain networks, enabling secure and decentralized transfers of assets and data across various platforms.

<div id="cards" className="cards">

## Celer cBridge

[Celer cBridge](https://cbridge.celer.network/) is a decentralized and non-custodial asset bridge that supports more than 150 tokens across over 40 blockchains and layer-2 rollups. It is built on top of the [Celer](https://celer.network/) Inter-chain Message Framework. cBridge has facilitated over $13 billion in cross-chain asset transfer volume across 40+ blockchains for more than 350,000 unique users. It is rapidly growing and expanding to support more blockchains and layer-2 solutions.

</div>
---
sidebar_position: 5
description: Get free Flow tokens for testing. Faucets are like taps for tokens, useful for trying Flow without buying tokens.
sidebar_custom_props:
  icon: 💧
---

# Faucets

Network Faucets provide free Flow tokens for testing purposes, functioning like taps that dispense tokens. They are valuable tools for experimenting with Flow without the need to purchase tokens.

<div class="cards">

## Flow Faucet

[Flow Faucet](https://testnet-faucet.onflow.org/) is a dedicated tool that provides a seamless way to acquire small amounts of Flow tokens for testing and development purposes on the Flow blockchain's testnet environment.

### Supported Networks

- Testnet: [https://testnet-faucet.onflow.org/](https://testnet-faucet.onflow.org/)

## LearnWeb3 Flow Faucet

[LearnWeb3 Flow Faucet](https://learnweb3.io/faucets/flow) is a community faucet tool that provides a seamless way to acquire small amounts of Flow tokens for testing and development purposes on the Flow blockchain's testnet environment.

### Supported Networks

- Testnet: [https://learnweb3.io/faucets/flow](https://learnweb3.io/faucets/flow)

</div>
---
sidebar_position: 1
title: Community Resources
description: Access essential tools, knowledge, and community connections for the Flow Blockchain ecosystem.
---

import DocCardList from '@theme/DocCardList';
import { useDocsSidebar, isSamePath } from '@docusaurus/theme-common/internal';
import { useLocation } from '@docusaurus/router';

<DocCardList items={
  [...useDocsSidebar().items.filter(item => !isSamePath(item.href, useLocation().pathname)),
    {
      type: 'link',
      label: 'Flow Forum',
      href: 'https://forum.onflow.org/',
      description: 'Engage with the Flow community, discuss ideas, and seek support on the Flow Blockchain Forum.',
      customProps: {
        icon: "🏛️"
      },
    },
    {
      type: 'link',
      label: 'FLIPs',
      href: 'https://github.com/onflow/flips',
      description: 'Flow Improvement Proposals (FLIPs) serve as a platform for engaging the Flow community in development, harnessing the collective ideas, insights, and expertise of contributors and experts while ensuring widespread communication of design changes.',
      customProps: {
        icon: "📜"
      },
    },
  ]
}/>
---
title: Community Projects
description: Explore the diverse projects and contributions within the Flow Blockchain community.
sidebar_position: 3
sidebar_custom_props:
  icon: 🏟️
---

import DocCardList from '@theme/DocCardList';

Explore an array of exciting, grassroots initiatives, and projects that thrive within the Flow Blockchain community, each contributing to the platform's growth and innovation.
<DocCardList items={[
  {
    type: 'link',
    label: 'DEV.to',
    href: 'https://dev.to/onflow',
    description: 'A constructive and inclusive social network for software developers where you can interact with others in the Flow community',
    customProps: {
      icon: 'https://dev-to-uploads.s3.amazonaws.com/uploads/logos/resized_logo_UQww2soKuUsjaOGNB38o.png',
      author: {
        name: 'Flow Blockchain',
        profileImage:
          'https://avatars.githubusercontent.com/u/62387156?s=200&v=4',
      },
      twitterLink: 'https://twitter.com/flow_blockchain',
      githubLink: 'https://github.com/onflow',
    },
  },
  {
    type: 'link',
    label: 'Emerald City',
    href: 'https://www.ecdao.org/',
    description: 'The first DAO built on the Flow Blockchain',
    customProps: {
      icon: 'https://academy.ecdao.org/ea-logo.png',
      author: {
        name: 'Emerald City DAO',
        profileImage:
          'https://pbs.twimg.com/profile_images/1687225095557632005/tUCmv8_P_400x400.jpg',
      },
      twitterLink: 'https://twitter.com/emerald_dao',
      githubLink: 'https://github.com/emerald-dao',
    }
  },
  {
    type: 'link',
    label: 'FLOAT',
    href: 'https://floats.city/',
    description: 'A Flow enabled proof of attendance platform with over 2.2 million FLOATs claimed and 4600+ events created',
    customProps: {
      icon: 'https://floats.city/float-logo.svg',
      author: {
        name: 'Emerald City DAO',
        profileImage:
          'https://pbs.twimg.com/profile_images/1687225095557632005/tUCmv8_P_400x400.jpg',
      },
      numStars: 0,
      twitterLink: 'https://twitter.com/emerald_dao',
      githubLink: 'https://github.com/emerald-dao/float',
    }
  },
  {
    type: 'link',
    label: 'Flow Ecosystem Fund',
    href: 'https://flow.com/flow-grants',
    description: 'The $725 Million Flow Ecosystem Fund is designed to hypercharge innovation and growth across the Flow community.',
    customProps: {
      icon: 'https://assets.website-files.com/5f734f4dbd95382f4fdfa0ea/627a308f0e66044bed3eb6d2_Flow-Illustration_shoe%201%20(1).png',
      author: {
        name: 'Dapper Labs',
        profileImage:
          'https://pbs.twimg.com/profile_images/1415802673278853123/gTgTeEnZ_400x400.png',
      },
      numStars: 0,
      twitterLink: 'https://twitter.com/flow_blockchain',
      githubLink: 'https://github.com/onflow',
    }
  },
  {
    type: 'link',
    label: 'Flow Bug Bounty Program',
    href: 'https://flow.com/flow-responsible-disclosure',
    description: 'Get rewarded for finding security vulnerabilities in on of our products or platforms.',
    customProps: {
      icon: 'https://assets.website-files.com/5f734f4dbd95382f4fdfa0ea/62763e067575490bc83fe807_Group%20822.svg',
      author: {
        name: 'Flow',
        profileImage:
          'https://avatars.githubusercontent.com/u/62387156?s=200&v=4',
      },
      numStars: 0,
      twitterLink: 'https://twitter.com/flow_blockchain',
    }
  },
  {
    type: 'link',
    label: 'Buildspace',
    href: 'https://buildspace.so/p/nfts-on-flow',
    description: 'Learn how to deploy your first Flow smart contract using Cadence and build a web3 React app to connect it together',
    customProps: {
      icon: '/images/content/buildspace.svg',
      author: {
        name: 'Buildspace',
        profileImage:
          'https://img.api.cryptorank.io/coins/150x150.buildspace1668414728723.png',
      },
      numStars: 0,
      twitterLink: 'https://twitter.com/_buildspace',
      githubLink: 'https://github.com/buildspace',
    }
  },
  {
    type: 'link',
    label: 'Flowverse',
    href: 'https://www.flowverse.co/',
    description: 'Flowverse is the central hub to discover everything on Flow Blockchain',
    customProps: {
      icon: 'https://substackcdn.com/image/fetch/w_170,c_limit,f_auto,q_auto:best,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F9c14b8ac-0937-4fe7-9893-46d907c108b7_899x899.png',
      author: {
        name: 'Flowverse',
        profileImage:
          'https://pbs.twimg.com/profile_images/1480354080123867138/66piiWGx_400x400.jpg',
      },
      numStars: 0,
      twitterLink: 'https://twitter.com/flowverse_',
    }
  },

  {
    type: 'link',
    label: 'Flovatar',
    href: 'https://flovatar.com/',
    description: 'Flovatar is a next generation NFT creativity platform where people can become creator and make their characters with any combination they like.',
    customProps: {
      icon: 'https://pbs.twimg.com/profile_images/1689380364718850049/rCElOZT2_400x400.jpg',
      author: {
        name: 'crash13override',
        profileImage: 'https://avatars.githubusercontent.com/u/1100260?v=4',
      },
      numStars: 0,
      twitterLink: 'https://twitter.com/flovatar',
      githubLink: 'https://github.com/crash13override/flovatar',
    }
  },
  {
    type: 'link',
    label: 'Flowty',
    href: 'https://www.flowty.io/',
    description: 'Flowty is a one-stop shop for all of your NFT needs on the Flow blockchain. From buying and selling to NFT-backed loans to NFT rentals, we have you covered.',
    customProps: {
      icon: 'https://pbs.twimg.com/profile_images/1685696696993341440/Qfh_-K41_400x400.jpg',
      author: {
        name: 'Flowty',
        profileImage:
          'https://pbs.twimg.com/profile_images/1685696696993341440/Qfh_-K41_400x400.jpg',
      },
      numStars: 0,
      twitterLink: 'https://twitter.com/flowty_io',
    }
  },
  {
    type: 'link',
    label: 'Flowser',
    href: 'https://flowser.dev/',
    description: 'Flowser combines all the tools for local development and gives you a clear UI to inspect the local Flow network.',
    customProps: {
      icon: 'https://flowser.dev/icon.png',
      author: {
        name: 'Flowser',
        profileImage:
          'https://flowser.dev/icon.png',
      },
      numStars: 0,
      twitterLink: 'https://twitter.com/onflowser',
      githubLink: 'https://github.com/onflowser/flowser'
    }
  },
  {
    type: 'link',
    label: 'Overflow',
    href: 'https://github.com/bjartek/overflow',
    description: 'Overflow is a Go-based DSL for testing and running interactive stories',
    customProps: {
      icon: '',
      author: {
        name: 'bjartek',
        profileImage:
          'https://avatars.githubusercontent.com/u/10621?v=4',
      },
      discordLink: 'https://discord.gg/t6GEtHnWFh',
      githubLink: 'https://github.com/bjartek/overflow'
    }
  },
  {
    type: 'link',
    label: 'Flowdiver historical API',
    href: 'https://findonflow.github.io/findlabs-api/',
    description: 'It is an Api to allow users to fetch historical data of Flow blockchain from the findlabs database.',
    customProps: {
      icon: '',
      author: {
        name: 'https://github.com/findonflow',
        profileImage:
          'https://avatars.githubusercontent.com/u/92926233?s=200&v=4',
      },
      discordLink: 'htts://discord.gg/findonflow',
      twitterLink: 'https://twitter.com/FindOnFlow',
      githubLink: 'https://github.com/findonflow/findlabs-api'
    }
  }
]} />
---
sidebar_position: 6
description: Store, send, and receive Flow tokens and digital assets securely on the Flow blockchain network. A convenient and safe way to manage and interact with cryptocurrency holdings.
sidebar_custom_props:
  icon: 🔑
---

# Wallets

Store, manage, and interact securely with Flow tokens and digital assets on the Flow blockchain network. Discover a range of wallets that offer convenient ways to handle and safeguard your cryptocurrency holdings, ensuring easy access and enhanced security for your transactions and assets.

<div id="cards" className="cards">

## Flow Reference wallet

[Flow Reference Wallet](https://frw.gitbook.io/) is the first extension wallet on Flow.

https://frw.gitbook.io/

## Blocto

Manage your crypto, dApps, and NFTs all in one place with [Blocto](https://www.blocto.io/), the cross-chain crypto wallet.

https://www.blocto.io/

## Dapper Wallet

[Dapper Wallet](https://www.meetdapper.com/) makes it easy and secure to buy, store, and manage digital assets from innovative Flow apps and games.

https://www.meetdapper.com/

## Ledger

[Ledger](https://www.ledger.com/) is a hardware wallet to secure, buy, exchange, and grow your crypto assets.

https://www.ledger.com/

## NuFi

[NuFi](https://nu.fi/) is Flow's only non-custodial wallet with staking, NFT gallery, dApp connector, and Ledger HW support.

https://nu.fi/

## Magic.link

[Magic](https://magic.link/) is a developer SDK that integrates with your application to enable passwordless Web3 onboarding (no seed phrases) and authentication using magic links (similar to Slack and Medium).

https://magic.link/

## Niftory

[Niftory](https://niftory.com/) is a platform to create, mint, and transfer NFTs.

https://niftory.com/

## Finoa

Safely store and stake your Flow tokens with [Finoa](https://www.finoa.io/).

https://www.finoa.io/flow/

</div>
---
sidebar_position: 1
---

import DocCardList from '@theme/DocCardList';
import { useDocsSidebar, isSamePath } from '@docusaurus/theme-common/internal';
import { useLocation } from '@docusaurus/router';

<DocCardList items={useDocsSidebar().items.filter(item => !isSamePath(item.href, useLocation().pathname))}/>
---
title: Tokens 101
sidebar_position: 1
---

# How to Launch a Fungible Token on Flow

*DISCLAIMER:  PLEASE READ THE ENTIRETY OF THIS "DISCLAIMER" SECTION CAREFULLY BEFORE READING THIS GUIDE.  THE INFORMATION CONTAINED WITHIN IS FOR COMMUNITY DISCUSSION AND CONTAINS GENERAL INFORMATION ONLY.  NOTHING HEREIN CONSTITUTES LEGAL, FINANCIAL, BUSINESS, REGULATORY, OR TAX ADVICE OR GUIDANCE AS TO ANY POTENTIAL TOKEN LAUNCH OR PROJECT IN ANY SPECIFIC JURISDICTION.  ANYONE READING THIS GUIDE MUST CONSULT LEGAL, FINANCIAL, TAX, REGULATORY, AND OTHER PROFESSIONAL ADVISORS OR EXPERTS FOR FURTHER GUIDANCE BEFORE LAUNCHING ANY TOKEN OR TOKEN-RELATED PROJECT.  IT IS IMPERATIVE THAT INDEPENDENT LEGAL ADVICE IS SOUGHT TO DETERMINE THE LEGAL, REGULATORY, SECURITIES, OR OTHER REQUIREMENTS RELATED TO ANY AND ALL JURISDICTIONS WHERE A TOKEN LAUNCH OR SALE MAY OCCUR.*  

## Introduction
Launching a token is no easy feat. There is a lot that goes into bringing a token from nothing to market: strong tokenomics, private or public sale, distribution, and finally an organized launch on centralized and decentralized exchanges. 

Many dApp teams we speak to on a daily basis are somewhat humbled by the magnitude of the work ahead of them. We have spent many hours breaking down this process into manageable chunks and accompanying teams from their tokenomics design to their negotiations with market-makers. This guide is our attempt to make this knowledge more broadly available to help dApps realize their full potential on Flow.

In this guide, we will explore everything you need to know when launching a token, from the why to the how. The guide will be broken down into 4 parts:

1) **Prep work**: what you need to think about before you launch your token.
2) **Token allocation**: the process by which you will decide who gets how many tokens.
3) **Token distribution**: when and how you are going to get your tokens in your community’s hands.
4) **Token launch:** (nearly) everything you need to know to maximize the chances of success of your token listing.

Let’s dive in.

## Step 0: Prep Work

### Define Your Universe

Before launching your token, you will first need to take a step back and take an objective look at your dApp.

**So, what does your dApp do?**
Let’s start with something easy: what is the problem you are trying to solve and how are you solving it? Why is it crucial for your dApp to leverage a blockchain, instead of being a standard web2 application? You should be able to explain what you do in one or two concise sentences.

**Who are your users?**
You may have more than one type of user. Understanding each user’s journey on your dApp will be key in defining incentives that will make each user type “tick”.

For example, your users could be categorized in any of the following, non-exhaustive buckets: 

- Developers / builders
- Creators / content producers
- Curators
- Consumers
- Merchants
- Promoters
- Gamers
- Voters

You can also draw inspiration from this map of the Flow ecosystem. 

![flow ecosystem](./flow-ecosystem.png)

Write down the list that is most relevant to your dApp and for each type of user, outline succinctly what behavior is expected of them, and what will incentivize them to display this behavior. A good way to summarize the way users interact with your dApp (and with one another) is to draw up a flowchart showing the flow of incentives and behaviors for each user type. For now, ignore the token and only focus on the high-level behaviors/incentives.

**What Are Your Token’s Objectives?**

**Why do you need a token for your dApp?**

Not all dApps need a token! In many instances, a token is not necessary for a dApp to be successful. Before you start designing your tokenomics and planning for the token launch, list the problems that your token will help solve.

**How will your token enable network dynamics?**

A successful token should be able to allow network effects to flourish on your dApp. An endless stream of new users buying your token and engaging with your dApp should not be a requisite for your token to succeed, but a consequence of carefully designed tokenomics. 

A simple way to lay out the expected network effects is to draw a flywheel: what would it look like? Which category of user is most crucial for the flywheel to function? 

## Tokenomics

Now that you have a clear understanding of your dApp’s objectives, it’s time to look at how your token will fit into the picture. This is where tokenomics come in. At a high level, tokenomics is the process by which you define the supply and plan for the demand dynamics of your token.

## Supply

A token’s supply, and how that supply evolves over time, is one of the most important factors in your token’s ability to provide and sustain substantial value to your users. Keep in mind that you, as the creator of the dApp, have more or less absolute control over such supply as long as you are transparent from the start over the evolution of such supply. 

A token supply is typically born from:

1) Tokens sold - privately or publicly
2) Tokens given for free - a.k.a. airdropped tokens 
3) Tokens earned - typically from performing certain actions beneficial to the dApp
4) Fixed or growing supply?

One of the first questions you will face when determining your token supply is whether to have a fixed or growing supply.

Let’s take a first look at the pros and cons of each option:


|     |  Fixed Supply   | Variable Supply    |
| --- | --- | --- |
|  Pros   |  <ul><li>A growth of the network value goes directly to existing token holders</li></ul>   | <ul><li>Strong mechanism to onboard new users due to inflation (aka new tokens being created and distributed, usually for free)</li><li>Powerful tool to increase token supply as dApp demand rises</li></ul>     |
|  Cons   |  <ul><li>Token price may become prohibitively high for new entrants, hampering your user growth - may or may not be a problem, depending on how you denominate the assets on your dApp (USD or your token)</li><li>Potential for early adopters to yield an outsized influence</li></ul>   | <ul><li>Potential downward pressure on the value of the token as new demand needs to be created to match the new supply</li><li>Dilutes existing holders</li></ul>     |

Think about the pros and cons of each, as outlined above, and what fits best your dApp’s objectives. 

It has been common to see dApps that did not want to choose between each model and eventually opted for a dual token model: 
- The “in-app currency” token that has an increasing supply
- The “network/governance” token that has a fixed supply and is supposed to capture the network growth

We go into further detail in the section “One Token vs. Two Token Model”.

## Airdrops

Airdrops can be very advantageous in the early days of a token launch, as they reward your community and incentivize early users to start utilizing your token. However, it is not uncommon to see recipients of airdrops simply turn around and liquidate, therefore hurting the token value. To protect against this eventuality, you may want to introduce features that encourage your users to behave in a way that is supportive of the growth of your network. 

Some examples of this include: 

- Limiting your airdropped tokens to **only be used internally within your dApp**, akin to airline miles. A token that is not withdrawable is a token that cannot be sold. This limitation can be lifted once the supply/demand dynamics are more established.
- Introduce a **lockup period or vesting** that users will have to wait out before coming into full possession of their tokens. You can also add a spin to this by tying the unlock to a specific behavior: participation, engagement etc.
- **Dividing your airdrop** into multiple smaller airdrops, and make each airdrop dependent on the previous one. For example, if a user has liquidated tokens from the first airdrop, then they are no longer eligible to receive the second airdrop.

On Flow, creating an airdrop is easy: you can utilize tools like [Drizzle](https://www.drizzle33.app/) to easily airdrop and raffle fungible tokens and NFTs on the Flow blockchain, and even set your own requirements when establishing which users will be able to participate in the drop.

If you are interested in digging in deeper, please check out [Drizzle’s Github page](https://github.com/33-Labs/drizzle) for sample transactions on how to create an airdrop, determine who’s eligible for the drop,  and more.

## Demand

We usually recommend starting the tokenomics work by defining the vectors of demand for your token. ** Creating supply is easy, creating demand is hard.**

_How will you generate sustainable demand for your tokens?_

When thinking about the demand vectors for your token, think about the benefits you are providing with your token, and how your tokens can be used to pay for these benefits. Conceptually, the actions that provide the most value/enjoyment to your users should be where the demand for your token should be the highest. 

Let’s use an example to dig further into this. 

Your dApp is a racing car game. Through user testing, you notice that users spend a lot more time playing the game once they start upgrading their vehicles. Naturally, you decide to require your own token to pay for such upgrades. Did you just create net new demand for your token?

The answer is, it depends on where those spent tokens go:

- If the dApp collects the tokens as payments, and uses those as revenue to finance further development, you have not created any demand. Indeed:
  - The user bought your tokens on an exchange
  - The user sent the dApp the tokens to purchase the upgrades
  - The dApp sold these tokens on an exchange to finance its activity
  - Net net, a token was bought, a token was sold, nothing has changed!

If some or all of the tokens spent by users are destroyed or placed in long-term holds, then you have created net new demand. Remember, the more intense the token supply is, the stronger your demand mechanisms will need to be.

By matching net new supply (aka faucets) with net new demand (aka sink) mechanisms like burning or long-term locking, you will then be able to keep your supply and demand balance in check which will go a long way to reduce the long-term volatility of your token.


## One Token vs. Two Token Model


|     |  One Token Model   | Two Token Model |
| --- | --- | --- |
|  Pros   |  <ul><li>Easier to launch</li><li>Only one supply/demand model to optimize for</li></ul>   | <ul><li>Ability to segregate the distribution strategies to suit the purpose (e.g.,  currency vs governance)</li></ul>     |
|  Cons   |  <ul><li>May limit accessibility of the token to target audience</li></ul>   | <ul><li>Contagion risk: if token1 has poor S/D dynamics, may take token2 with it</li></ul>     |


While a two-token model can work if done properly, many dApps have proven in the past that this is a tough feat to achieve.

As mentioned earlier, dual-token models are made of one currency token for which supply can grow indefinitely and one governance token for which supply is fixed. Dapps often make the mistake to concentrate value capture towards the governance token and consider the currency token as an afterthought. The very real risk of such a construct is that the currency token starts suffering from hyperinflation and enters a death spiral, forming a sort of black hole that swallows everything around it: governance token first, and then currency token after.

However, there are precedents that have launched a dual-token model successfully. MakerDAO, for one, is a great example of this. 

[MakerDAO](https://makerdao.com/en/) is an open-source project on the Ethereum blockchain and DAO (Decentralized Autonomous Organization) that manages the Maker Protocol and the MKR and DAI currencies. While MKR is the governance token that gives holders executive voting and governance polling rights for all things related to the Maker Protocol (and thus the DAI token), the DAI stablecoin acts as a decentralized, unbiased, collateral-backed cryptocurrency that is soft-pegged to the US Dollar. 

MKR holders manage the Maker Protocol and the financial risks of DAI to ensure its stability, transparency, and overall efficiency. MKR voting weight is designed to be proportional to the amount of MKR a voter stakes in the voting contract, and voting rights in return allow holders to decide on key parameters of the DAI stablecoin, like stability fees and collateral types/rates. 

DAI’s first mover status, and its lack of off-market yield opportunities (like the ones offered on UST) have undoubtedly been the bedrock of DAI/MKR success. DAI careful supply scaling - by adding collateral assets slowly and thoughtfully - have allowed DAI to maintain its peg without threatening the stability of its ecosystem.

While designing a successful dual-token model can be challenging, we cannot repeat this enough: if you do not do the necessary prep work on how to best balance your supply and demand, then the market will eventually find this balance for you.

## Step 1: Token Allocation

### Industry Standards
While there are a number of ways you can split your token allocation. We have recorded for you the range we typically see across the industry:

- **Community**: 40-75%
- **Public Sales**: 0-10%
- **Airdrops**: 0-10%
- **Investors**: 5-15%
- **Team**: 5-20%
- **Advisors**: 0-5%

![token allocation](./token-allocation.png)

Importantly, this type of pie chart only captures **half** of the allocation picture. The other half consists of showing how each slice of the pie receives that allocation **over time**. This is where vesting/unlock comes in. Typically we see, an allocation over time that looks something like this:

![token distribution](./token-distribution.png)

In the example above, we’re using a 100 million fixed token supply model, and distributing the tokens on a 6-year timeline. The x-axis represents the years since launch, and the y-axis represents the token supply in circulation. As you can see, the number of tokens in circulating supply increases gradually over time and starts to taper off as we get closer to the 6-year mark. Token allocations for team members, investors, and advisors start vesting a year after launch at the cliff date, while airdrop, public sale, and community allocations unlock right at launch, at year zero.

Keep in mind that this is only an example, and there is no hard requirement to follow cliffs, multi-year unlocks, or any other locking/vesting features. These are just tools at your disposal that will allow you to fine tune the rate at which tokens enter the circulating supply.

## Private vs. Public Sales

A private sale is usually the first way a dApp fundraises, typically before a potential public fundraise. Not anyone can invest in a private sale - usually, anyone participating in these sales have conversed with and have some sort of relationship with the fundraising team. Investors in private sales are usually angel investors, VCs, family offices, or other investment funds.

In private sales, token sales can either take place on their own or alongside equity investments in the dApp. If a token sale is done alongside an equity investment, then a [SAFT](https://www.investopedia.com/terms/s/simple-agreement-future-tokens-saft.asp) (simple agreement for future token) is signed alongside a [SAFE](https://www.finra.org/investors/insights/safe-securities) (simple agreement for future equity). 

With a SAFT, the dApp team is agreeing to allocate a certain amount of tokens to investors alongside with an equity investment. In the case of a pre-existing token, the investor may agree to purchase the tokens at a discounted price. If the token has yet to launch, then both parties can work towards favorable terms.

The reasons for going private before a public sale are two-fold:

1) **Operationally**, it is much easier to handle a small number of investors,
2) **Logistically**, it is much less risky to face a handful of accredited investors than to face a myriad of retail investors located in multiple jurisdictions.

A public sale, on the other hand, is the first time a token can be purchased by the general public. Anyone interested in the token can purchase it through centralized platforms (a.k.a. ICO platforms) such as CoinList or TokenSoft or decentralized platforms (a.k.a. IDO) such as Blocto Launchpad or Metapier.

During a public sale, anyone purchasing a token is basically subscribing to buy a predetermined number of tokens at a specific price and signing a token purchase agreement, which is a contract with future rights to a specific unit of tokens on a future date.

## Token Sale: Dynamic vs. Fixed Price

A question that will invariably come up if you decide to undergo a token sale is what price you should sell your token at. 

There are two avenues you can take when it comes to determining the price at which your token will be sold during such a sale:

1) Dynamic price
2) Fixed price

When you choose to use a dynamic price, you are basically letting the market determine the price of your token. One of the most popular ways to achieve such price discovery is by holding a reverse dutch auction, during which time you are agreeing to sell a set amount of tokens, for which the initial bid price is set by the highest bidder. As bidding progresses, the bid price goes down until there are no more tokens left to sell. The last bid price is the final clearing price of the auction and all bidders receive their tokens at that set clearing price. 

If you choose to go with a fixed price for your launch, then you are setting the initial price. That initial price typical is obtained via a mix of:

  1) Analyzing the tokenomics of dApps with similar business models as yours. What does their market value look like? How does your project compare to it? From there, adjust for differences in market sizes and product offerings to estimate your market value and price.
  2) Using your last fundraise price (if you did conduct a fundraise) to help set your initial token price.

## ICO vs. IDO

An ICO (initial coin offering) is a popular method for fundraising involving the public sale of a token. Usually, in an ICO, tokens are sold to the public in exchange for stablecoins. The  process often involves creating a website for the token that includes the whitepaper and details of the token launch, followed by an intensive period of marketing and community engagement efforts to drum up pre-launch interest. The ICO platform is usually responsible for the operational aspects of the sale (KYC, payment rails, token allocation and tracking), while the dApp is responsible for marketing and community engagement.

An IDO (initial DEX offering), on the other hand, is a public sale that is made via a smart contract. While an IDO is a powerful tool for fundraising, remember that is not the same as getting listed on a DEX, which we will cover in the next section. You can easily organize your own IDO on Flow by using a Launchpad like [Metapier](https://docs.google.com/forms/d/1lP72QLwODk3_Yx5Zcy0LSWFAQ5n5tu6rFAPnTw-E4LU/viewform?edit_requested=true).

To illustrate an example of an IDO, let’s look at the launch of $BLT ([Blocto Token](https://token.blocto.app/)), the [Blocto](https://swap.blocto.app/#/IDO) app’s native token: 

When Blocto was initially launching their $BLT token, they conducted an IDO on their [launchpad](https://swap.blocto.app/#/IDO) that allowed any token buyers to see the terms and requirements for the token sale, and the details (number of tokens offered, sale terms, payment terms, and admission fees). From there, anyone interested in the IDO was able to buy a predetermined amount of $BLT tokens at the specified price. 

Since then, Blocto has [expanded its offerings](https://swap.blocto.app/#/IDO) to include IDOs for other tokens launching on Flow, such as $STARLY in addition to their own $BLT token. Another launchpad option on Flow is [Metapier](https://docs.google.com/forms/d/1lP72QLwODk3_Yx5Zcy0LSWFAQ5n5tu6rFAPnTw-E4LU/viewform?edit_requested=true), built by the team behind the ultra successful DoDo.

## Step 2: Token Distribution

Token distribution describes the process by which tokens allocated to various users during Step 1 get transferred to users’ wallets.

It is a common misconception to think that token distribution has to happen at the same time as token launch (the time at which the token starts trading on a CEX and/or DEX). In fact, we strongly recommend dApps to separate those steps. The logic behind this is that token distribution and token launch are significant events in the life of a dApp that need the full focus of the G2M team. 

Dapps often ask us how to keep distribution and launch separate in a world where anybody can start a new liquidity pool with a dApp token and FLOW. Indeed, the creation of such a liquidity pool would effectively get secondary trading going on the same day as the token distribution, thus preventing the dApp from taking things at their own speed. This is a major risk that can be managed with a bit of planning. Let us show you how.

## On-Chain vs. Off-Chain Distribution

There are two types of distribution you can choose:

1) **On-Chain Distribution**: the traditional way of distributing tokens. Tokens are transferred to users’ wallets on-chain.
2) **Off-Chain Distribution**: a mock distribution where tokens appear in the user’s wallet once they are connected to the dApp, but do not actually exist on-chain. The logic is similar to that of airline miles.

For an off-chain distribution, preventing users from sending their token to a DEX is easy, because tokens do not exist on-chain but only in a database run centrally by the dApp.

For an on-chain distribution, the objective is to let users spend the token on the dApp but forbid them to withdraw to any other address. This can be done on Flow by requiring a certain block height to be reached to unlock tokens on Flow. If interested in learning more about how you can build this into your smart contract, please reach out to the Flow team on [Discord](https://discord.com/invite/flow).  

## Vesting/Unlock Schedules

Distributions do not need to make all tokens allocated available immediately. That is where vesting/unlock schedules come in.

As mentioned in [Step 0: Prep Work](#step-0-prep-work), successful token launches achieve a balance between supply and demand early. Using an intentional vesting schedule for your token will allow you to fine-tune the rate at which new tokens enter the circulating supply, thereby helping you only introduce the quantity needed by your dApp at this point in time. 

How many tokens do you need circulating on the first day of launch to meet the forecasted demand? What about one week, one month, and one year post-launch? Figure out what circulating supply is actually needed by your dApp at these various dates, and from there, walk back the number of tokens that need to enter the circulating supply.

## Step 3: Token Launch

### Launching a Token: What Does It Mean?

Launching a token basically involves everything needed to get a token trading on a CEX and/or a DEX. This means figuring out what type of exchange to list on, what market makers to work with, if any, and plan for the changes for your dApp once your token is freely trading.
Exchange Listings

When it comes to listing on exchanges, you can choose to list on centralized exchanges (CEX), decentralized exchanges (DEX), or both.


|     |  CEX   | DEX |
| --- | --- | --- |
|  Pros   |  <ul><li>Increases the reach of your token</li><li>Easier for non-crypto users to discover and buy your token</li><li>Maximizes trading volumes</li><li>Makes price discovery more efficient</li><li>Brings legitimacy to your dApp</li></ul>   | <ul><li>Fast and easy launch</li><li>Users can buy tokens without KYC/ID verification</li></ul>     |
|  Cons   |  <ul><li>Takes more time to launch on a CEX</li><li>Longer due diligence process</li><li>Usually requires hiring a market maker</li><li>Might require paying a fee to the exchange</li></ul>   | <ul><li>Exposure to impermanent loss</li><li>Lower liquidity requirement compared to CEX</li><li>Lack of demonstrating KYC compliance</li></ul>     |

While listing on a DEX is very fast and easy, it is ultimately more beneficial to line up your listings and launch on CEXs on the same day as DEX launches. 

Being available on a variety of CEXs is very beneficial to increase the reach of your token, CEX makes price discovery more efficient, they also tends to increase trading volumes as CEX and DEX are constantly arbitraged against one another, finally many users look to the list of CEXs a token list on to get a sense of its legitimacy.

## DEX launches

Launching on a DEX simply means creating a liquidity pool that will hold a certain quantity of your token, as well as a certain quantity of another token of your choosing. On Flow, the most logical choice is to take advantage of FLOW’s pre-existing liquidity on BloctoSwap or IncrementFi.

The quantity of your token vs. the quantity of FLOW that you deposit will determine the initial price for your token. This is because liquidity pools assume equal USD value of each token. Thus, if you deposit $50,000 worth of FLOW in the pool and 10,000 of your own token, the initial price will start at $5 per token.

Of course, the price will not stay static! As users buy and sell your token, the inventory of both tokens will change, thereby changing the price of your token. For more details, you can read about AMMs here.

### Liquidity requirements

As described above, the price at which your token will trade will be determined by the quantity available in the pool vs. FLOW. Thus, the lower the quantity of the FLOW used to pair with your token, the more volatility your token will experience.

Let’s go through an example to clarify this, using an imaginary liquidity pool made of FLOW and a new token named TKN:
**FLOW/USD** = $2
**TKN/USD** = $1 

Liquidity pool **FLOW/TKN** is made of 5,000 **FLOW** and 10,000 **TKN**, for a Total Value Locked = 5,000 x $2 + 10,000 x $1 = $20,000

In the case of a constant product AMM, we have **x * y = k**, where **x** and **y** are the quantity of respectively **FLOW** and **TKN** in the liquidity pool.

k = 5,000 x 10,000 = 50,000,000 (k is a constant here).

Alice comes in to buy **TKN** with 2,500 **FLOW** tokens, the new **FLOW** inventory becomes 7,500 **FLOW** (2,500 new **FLOW** tokens + 5,000 original **FLOW** tokens). 

Now, let’s figure out the **TKN** inventory: 

**TKN** inventory = 50,000,000 / 7,500 **FLOW** = 6,666 **TKN** - or 3,334 **TKN** received by Alice in exchange for her 2,500 **FLOW**

This means that the user has paid 2,500 **FLOW** (equivalent to $5,000) to receive 3,334 **TKN**, which means that Alice bought **TKN** at $5,000 / 3,334 = $1.5 per **TKN**. This is 50% higher than the price Alice saw when browsing **TKN** on the DEX!

This price difference is called slippage, and is directly proportional to the size of the TVL in the pool.

As a result, we recommend dApps to launch a liquidity pool with at least $100,000 worth of tokens per side (i.e. a Total Value Locked of $200,000 at minimum). This means that the dApp should come up with $100,000 worth of FLOW prior to listing, which is not a trivial amount. Thankfully, a dApp can easily borrow FLOW while paying an interest rate in their own token using [boolean.xyz](https://docs.google.com/forms/d/e/1FAIpQLSeyMnRWSTtQv0YiK1-Qwc0xoKdBHFhVX3hQZk8s9BsT7-5LCQ/viewform).

### Do you need a Market Maker to be listed on a DEX?
While you do not necessarily need a Market Maker to create a liquidity pool (LP), remember that any liquidity deposited in an LP will have exposure to impermanent loss. And the greater the exposure, the greater the risk of impermanent loss. 

_Ask yourself_: are you okay with taking this risk, and what are the tradeoffs if you do decide to take it? This is a complex topic that will be the subject of a future post.

## CEX launches

### The role of Market-Makers
If you choose to list on a centralized exchange, then you will be required to hire a market maker, whose job will be to populate the order book of the various trading pairs supported on each CEX. Hiring a market-maker typically takes up to 6 weeks. 

### Exchange listing negotiations
Listing on a centralized exchange can take anywhere between 1 to 2 months between initial conversation and full due diligence. Typically exchanges will be interested in seeing your whitepaper, your effective token allocation, the vesting and unlock schedule for each category of holders of your token as well as any metric that captures the vibrancy and engagement of your community.

Some exchanges require payment of listing fees, but many do not. As a result, make sure that before agreeing to a listing fee you have a good understanding of the benefits you will gain from listing on a given exchange.

## Getting your Flow token created

While this guide does not cover the technicals of creating your fungible token, please find a couple of resources that may be helpful as you get ready to launch your token: 

- [Flow Token List](https://github.com/FlowFans/flow-token-list) - How to add a token to the Flow native token list
- [Flowdiver Request Form](https://docs.google.com/forms/d/e/1FAIpQLSdMiIkj2goF3Ib7wJHRb-YNvruwBghq1NP1IOfz4p2smIFp0w/viewform) - Please fill this out to update your token metadata on Flowdiver
- [Flow Developer Portal](/) - Documentation, guides, and resources for developers building on Flow

## Final Words

We have given in this guide a number of guidelines and templates to help you get around the cold start problem. You should not consider them as hard rules that you have to follow to ensure a successful token launch. Web 3.0 allows a near infinite creativity space, and we hope you take maximum advantage of that, especially when designing your tokenomics. If you have an idea that sounds crazy, or that you are concerned it might not work, we would love to hear about it and brainstorm with you.

Building a token on Flow unleashes a world of opportunities - for your users, for your team, and for those that believe in bringing your vision to life in a decentralized, permissionless way. Moreover, creating a token for your community is an incredible opportunity to create a macroeconomic landscape in a micro setting. This is a great way to test out what works best for your community and your product, and put the power back in the hands of your largest supporters. 
---
title: Fungible Token Contract
sidebar_label: Fungible Token
---

The `FungibleToken` contract implements the Fungible Token Standard. It is the second contract ever deployed on Flow.

Source: [FungibleToken.cdc](https://github.com/onflow/flow-ft/blob/master/contracts/FungibleToken.cdc)

| Network         | Contract Address     |
| --------------- | -------------------- |
| Emulator/Canary | `0xee82856bf20e2aa6` |
| Testnet         | `0x9a0766d93b6608b7` |
| Mainnet         | `0xf233dcee88fe0abe` |

---
title: Flow Token Contract
sidebar_title: Flow Token
---

The `FlowToken` contract defines the FLOW network token.

Source: [FlowToken.cdc](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowToken.cdc)

| Network         | Contract Address     |
| --------------- | -------------------- |
| Emulator/Canary | `0x0ae53cb6e3f42a79` |
| Testnet         | `0x7e60df042a9c0868` |
| Mainnet         | `0x1654653399040a61` |

# Transactions

| ID          | Name                     | Source                                                                                                                                        |
| ----------- | ------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------- |
| **`FT.01`** | Transfer FLOW            | [flowToken/transfer_tokens.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/flowToken/transfer_tokens.cdc)         |
| **`FT.02`** | Get an account's balance | [flowToken/scripts/get_balance.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/flowToken/scripts/get_balance.cdc) |
| **`FT.03`** | Get total supply         | [flowToken/scripts/get_supply.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/flowToken/scripts/get_supply.cdc)   |


# Events

Flow relies on a set of core contracts that define key portions of the Flow protocol. Those contracts are core contracts 
and are made to emit the events documented below. You can read about the [core contracts here](./index.md) 
and view their source code and event definitions.

Events emitted from core contracts follow a standard format:

```
A.{contract address}.{contract name}.{event name}
```

The components of the format are:
- `contract address` - the address of the account the contract has been deployed to
- `contract name` - the name of the contract in the source code
- `event name` - the name of the event as declared in the source code

### Flow Token Contract
Description of events emitted from the [FLOW Token contract](./03-flow-token.md). 
The contract defines the fungible FLOW token. Please note that events for the fungible token contracts are the same 
if deployed to a different account but the `contract address` is 
changed to the address of the account the contract has been deployed to.

### Tokens Initialized

Event that is emitted when the contract gets created.

- Event name: `TokensInitialized`
- Mainnet event: `A.1654653399040a61.FlowToken.TokensInitialized`
- Testnet event: `A.7e60df042a9c0868.FlowToken.TokensInitialized`

```cadence
pub event TokensInitialized(initialSupply: UFix64)
```

| Field             | Type   | Description                                                            |
| ----------------- | ------ | ---------------------------------------------------------------------- |
| initialSupply       | UFix64 | The initial supply of the tokens |


### Tokens Withdrawn

Event that is emitted when tokens get withdrawn from a Vault.

- Event name: `TokensWithdrawn`
- Mainnet event: `A.1654653399040a61.FlowToken.TokensWithdrawn`
- Testnet event: `A.7e60df042a9c0868.FlowToken.TokensWithdrawn`

```cadence
pub event TokensWithdrawn(amount: UFix64, from: Address?)
```

| Field             | Type   | Description                                                            |
| ----------------- | ------ | ---------------------------------------------------------------------- |
| amount       | UFix64 | The amount of tokens withdrawn |
| from       | Address? | Optional address of the account that owns the vault where tokens were withdrawn from. `nil` if the vault is not in an account's storage |


### Tokens Deposited

Event that is emitted when tokens get deposited to a Vault.

- Event name: `TokensDeposited`
- Mainnet event: `A.1654653399040a61.FlowToken.TokensDeposited`
- Testnet event: `A.7e60df042a9c0868.FlowToken.TokensDeposited`

```cadence
pub event TokensDeposited(amount: UFix64, to: Address?)
```

| Field             | Type   | Description                                                            |
| ----------------- | ------ | ---------------------------------------------------------------------- |
| amount       | UFix64 | The amount of tokens withdrawn |
| to       | Address? | Optional address of the account that owns the vault where tokens were deposited to. `nil` if the vault is not in an account's storage |

### Tokens Minted

Event that is emitted when new tokens gets minted.

- Event name: `TokensMinted`
- Mainnet event: `A.1654653399040a61.FlowToken.TokensMinted`
- Testnet event: `A.7e60df042a9c0868.FlowToken.TokensMinted`

```cadence
pub event TokensMinted(amount: UFix64)
```

| Field             | Type   | Description                                                            |
| ----------------- | ------ | ---------------------------------------------------------------------- |
| amount       | UFix64 | The amount of tokens to mint |

### Tokens Burned

Event that is emitted when tokens get destroyed.

- Event name: `TokensBurned`
- Mainnet event: `A.1654653399040a61.FlowToken.TokensBurned`
- Testnet event: `A.7e60df042a9c0868.FlowToken.TokensBurned`

```cadence
pub event TokensBurned(amount: UFix64)
```

| Field             | Type   | Description                                                            |
| ----------------- | ------ | ---------------------------------------------------------------------- |
| amount       | UFix64 | The amount of tokens to burn |


### Minter Created

Event that is emitted when a new minter resource gets created.

- Event name: `MinterCreated`
- Mainnet event: `A.1654653399040a61.FlowToken.MinterCreated`
- Testnet event: `A.7e60df042a9c0868.FlowToken.MinterCreated`

```cadence
pub event MinterCreated(allowedAmount: UFix64)
```

| Field             | Type   | Description                                                            |
| ----------------- | ------ | ---------------------------------------------------------------------- |
| allowedAmount       | UFix64 | The amount of tokens that the minter is allowed to mint |

### Burner Created

Event that is emitted when a new burner Resource gets created.

- Event name: `BurnerCreated`
- Mainnet event: `A.1654653399040a61.FlowToken.BurnerCreated`
- Testnet event: `A.7e60df042a9c0868.FlowToken.BurnerCreated`

```cadence
pub event BurnerCreated()
```

### Staking Events
To learn more about staking events, read [staking/events/](../../references/run-and-secure/staking/07-staking-scripts-events.md)

---
title: Service Account Contracts
sidebar_title: Service Account
---

The service account is the account that manages the core protocol requirements of Flow.
There are two contracts deployed to the service account:

- `FlowServiceAccount` tracks transaction fees, deployment permissions, and provides 
some convenience methods for Flow Token operations.

Source: [FlowServiceAccount.cdc](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowServiceAccount.cdc)

| Network         | Contract Address     |
| --------------- | -------------------- |
| Emulator/Canary | `0xf8d6e0586b0a20c7` |
| Testnet         | `0x8c5303eaa26202d6` |
| Mainnet         | `0xe467b9dd11fa00df` |
---
title: Flow Fees Contract
sidebar_title: Flow Fees
---

The `FlowFees` contract is where all the collected flow fees are gathered.

Source: [FlowFees.cdc](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowFees.cdc)

| Network         | Contract Address     |
| --------------- | -------------------- |
| Emulator/Canary | `0xe5a8b7f23e8b548f` |
| Testnet         | `0x912d5440f7e3769e` |
| Mainnet         | `0xf919ee77447b7497` |


The `FlowStorageFees` contract defines the parameters and utility methods for storage fees.

Source: [FlowFees.cdc](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowStorageFees.cdc)

| Network         | Contract Address     |
| --------------- | -------------------- |
| Emulator/Canary | `0xf8d6e0586b0a20c7` |
| Testnet         | `0x8c5303eaa26202d6` |
| Mainnet         | `0xe467b9dd11fa00df` |---
title: Flow Staking Contract Reference
sidebar_label: Staking Table
---

# Contract

The `FlowIDTableStaking` contract is the central table that manages staked nodes, delegation and rewards.

Source: [FlowIDTableStaking.cdc](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowIDTableStaking.cdc)

| Network         | Contract Address     |
| --------------- | -------------------- |
| Emulator/Canary | `0xf8d6e0586b0a20c7` |
| Testnet         | `0x9eca2b38b18b5dfe` |
| Mainnet         | `0x8624b52f9ddcd04a` |

# Transactions

## Getting Staking Info

These scripts are read-only and get info about the current state of the staking contract.

| ID        | Name                                       | Source |
|-----------|--------------------------------------------|--------|
|**`SC.01`**| Get Delegation Cut Percentage              | [idTableStaking/get_cut_percentage.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_cut_percentage.cdc) |
|**`SC.02`**| Get Minimum Stake Requirements             | [idTableStaking/get_stake_requirements.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_stake_requirements.cdc) |
|**`SC.03`**| Get Total Weekly Reward Payout             | [idTableStaking/get_weekly_payout.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_weekly_payout.cdc) |
|**`SC.04`**| Get Current Staked Node Table              | [idTableStaking/get_current_table.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_current_table.cdc) |
|**`SC.05`**| Get Proposed Staked Node Table             | [idTableStaking/get_proposed_table.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_proposed_table.cdc) |
|**`SC.06`**| Get Total Flow Staked                      | [idTableStaking/get_total_staked.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_total_staked.cdc) |
|**`SC.07`**| Get Total Flow Staked by Node Type         | [idTableStaking/get_total_staked_by_type.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_total_staked_by_type.cdc) | 
|**`SC.08`**| Get All Info about a single NodeID         | [idTableStaking/get_node_info.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_node_info.cdc) |
|**`SC.09`**| Get a node's total Commitment (delegators) | [idTableStaking/get_node_total_commitment.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_node_total_commitment.cdc) |
|**`SC.10`**| Get All Info about a single Delegator      | [idTableStaking/delegation/get_delegator_info.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/delegation/get_delegator_info.cdc) |
|**`SC.11`**| Get a node's total Commitment              | [idTableStaking/get_node_total_commitment_without_delegators.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_node_total_commitment_without_delegators.cdc) |

## Delegator Transactions

Documentation for delegating with tokens is described in the staking documentation
for [the staking collection](../../references/run-and-secure/staking/14-staking-collection.mdx)

# Events

The `FlowIDTableStaking` contract emits an event whenever an important action occurs.
See the [staking events Documentation](../../references/run-and-secure/staking/07-staking-scripts-events.md) for more information about each event.

```cadence
    pub event NewEpoch(totalStaked: UFix64, totalRewardPayout: UFix64)

    /// Node Events
    pub event NewNodeCreated(nodeID: String, role: UInt8, amountCommitted: UFix64)
    pub event TokensCommitted(nodeID: String, amount: UFix64)
    pub event TokensStaked(nodeID: String, amount: UFix64)
    pub event TokensUnstaking(nodeID: String, amount: UFix64)
    pub event TokensUnstaked(nodeID: String, amount: UFix64)
    pub event NodeRemovedAndRefunded(nodeID: String, amount: UFix64)
    pub event RewardsPaid(nodeID: String, amount: UFix64)
    pub event UnstakedTokensWithdrawn(nodeID: String, amount: UFix64)
    pub event RewardTokensWithdrawn(nodeID: String, amount: UFix64)

    /// Delegator Events
    pub event NewDelegatorCreated(nodeID: String, delegatorID: UInt32)
    pub event DelegatorTokensCommitted(nodeID: String, delegatorID: UInt32, amount: UFix64)
    pub event DelegatorTokensStaked(nodeID: String, delegatorID: UInt32, amount: UFix64)
    pub event DelegatorTokensUnstaking(nodeID: String, delegatorID: UInt32, amount: UFix64)
    pub event DelegatorTokensUnstaked(nodeID: String, delegatorID: UInt32, amount: UFix64)
    pub event DelegatorRewardsPaid(nodeID: String, delegatorID: UInt32, amount: UFix64)
    pub event DelegatorUnstakedTokensWithdrawn(nodeID: String, delegatorID: UInt32, amount: UFix64)
    pub event DelegatorRewardTokensWithdrawn(nodeID: String, delegatorID: UInt32, amount: UFix64)

    /// Contract Field Change Events
    pub event NewDelegatorCutPercentage(newCutPercentage: UFix64)
    pub event NewWeeklyPayout(newPayout: UFix64)
    pub event NewStakingMinimums(newMinimums: {UInt8: UFix64})
```
---
title: Flow Epoch Contracts Reference
sidebar_title: Epoch Contracts
---

# Contract

The `FlowEpoch` contract is the state machine that manages Epoch phases and emits service events.
The `FlowClusterQC` and `FlowDKG` contracts manage the processes that happen during the Epoch Setup phase.

These contracts are all deployed to the same account as the `FlowIDTableStaking` contract.

Sources: 
- [FlowEpoch.cdc](https://github.com/onflow/flow-core-contracts/blob/master/contracts/epochs/FlowEpoch.cdc)
- [FlowClusterQC.cdc](https://github.com/onflow/flow-core-contracts/blob/master/contracts/epochs/FlowClusterQC.cdc)
- [FlowDKG.cdc](https://github.com/onflow/flow-core-contracts/blob/master/contracts/epochs/FlowDKG.cdc)

| Network         | Contract Address     |
|-----------------|----------------------|
| Emulator/Canary | `0xf8d6e0586b0a20c7` |
| Testnet         | `0x9eca2b38b18b5dfe` |
| Mainnet         | `0x8624b52f9ddcd04a` |

# Transactions

## Getting Epoch Info

These scripts are read-only and get info about the current state of the epoch contract.

| ID        | Name                       | Source |
|-----------|----------------------------|--------|
|**`EP.01`**| Get Epoch Metadata         | [epoch/get_epoch_metadata.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/scripts/get_epoch_metadata.cdc) |
|**`EP.02`**| Get Configurable Metadata  | [epoch/get_config_metadata.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/scripts/get_config_metadata.cdc) |
|**`EP.03`**| Get Epoch Counter          | [epoch/get_epoch_counter.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/scripts/get_epoch_counter.cdc) |
|**`EP.04`**| Get Epoch Phase            | [epoch/get_epoch_phase.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/scripts/get_epoch_phase.cdc) |


## Quorum Certificate Transactions and Scripts

| ID        | Name                    | Source |
|-----------|-------------------------|--------|
|**`QC.01`**| Create QC Voter         | [quorumCertificate/get_epoch_metadata.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/quorumCertificate/create_voter.cdc) |
|**`QC.02`**| Submit QC Vote          | [quorumCertificate/get_config_metadata.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/quorumCertificate/submit_vote.cdc) |
|**`QC.03`**| Get Collector Cluster   | [quorumCertificate/scripts/get_cluster.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/quorumCertificate/scripts/get_cluster.cdc) |
|**`QC.04`**| Get QC Enabled          | [quorumCertificate/scripts/get_qc_enabled.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/quorumCertificate/scripts/get_qc_enabled.cdc) |
|**`QC.05`**| Get Node Has Voted      | [quorumCertificate/scripts/get_node_has_voted.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/quorumCertificate/scripts/get_node_has_voted.cdc) |
|**`QC.06`**| Get QC Voting Complete  | [quorumCertificate/scripts/get_voting_completed.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/quorumCertificate/scripts/get_voting_completed.cdc) |

## DKG Transactions and Scripts

| ID        | Name                       | Source |
|-----------|----------------------------|--------|
|**`DKG.01`**| Create DKG Participant    | [dkg/create_participant.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/create_participant.cdc) |
|**`DKG.02`**| Get Configurable Metadata | [dkg/send_whiteboard_message.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/send_whiteboard_message.cdc) |
|**`DKG.03`**| Send Final Submission        | [dkg/send_final_submission.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/send_final_submission.cdc) |
|**`DKG.04`**| Get DKG Enabled         | [dkg/scripts/get_dkg_enabled.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/scripts/get_dkg_enabled.cdc) |
|**`DKG.05`**| Get DKG Completed          | [dkg/scripts/get_dkg_completed.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/scripts/get_dkg_completed.cdc) |
|**`DKG.06`**| Get Whiteboard Messages         | [dkg/scripts/get_whiteboard_messages.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/scripts/get_whiteboard_messages.cdc) |
|**`DKG.07`**| Get Final Submissions          | [dkg/scripts/get_final_submissions.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/scripts/get_final_submissions.cdc) |
|**`DKG.08`**| Get Node Has Submitted          | [dkg/scripts/get_node_has_submitted.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/dkg/scripts/get_node_has_submitted.cdc) |
---
title: Non-Fungible Token Contract
sidebar_label: Non-Fungible Token
---

The `NonFungibleToken` contract interface implements the Fungible Token Standard.
All NFT contracts are encouraged to import and implement this standard.

Source: [NonFungibleToken.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/NonFungibleToken.cdc)

| Network         | Contract Address     |
| --------------- | -------------------- |
| Emulator/Canary | `0xf8d6e0586b0a20c7` |
| Testnet         | `0x631e88ae7f1d7c20` |
| Mainnet         | `0x1d7e57aa55817448` |
---
title: NFT Metadata Contract
sidebar_title: NFT Metadata
---

The `MetadataViews` contract implements a standard to attach on-chain metadata
to NFTs. This standard was originally proposed in [FLIP-0636](https://github.com/onflow/flips/blob/main/application/20210916-nft-metadata.md).

It is deployed at the same address as the `NonFungibleToken` contract interface.

Source: [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc)

| Network    | Contract Address     |
| ---------- | -------------------- |
| Testnet    | `0x631e88ae7f1d7c20` |
| Mainnet    | `0x1d7e57aa55817448` |

There exists a tool, [Flow NFT Catalog](https://flow-nft-catalog.com), which enables dapp developers the ability to unlock interoperability of your NFT collection across the Flow ecosystem. This will help make your NFT collection’s metadata more discoverable and interoperable.

To optimize your NFT collections for this catalog, you’ll need to:

1. Update your NFT contract to support MetadataView with implementation of the [core NFT views](https://github.com/onflow/flow-nft/pull/103/files#diff-a7af41cf43e29d0e6028827c3d5f305326677661bf65d79539d59ed1056c0a84R38).
2. Deploy the updated contract to both testnet and mainnet.
3. Afterwards, onboard your NFT to the Flow NFT catalog at [https://flow-nft-catalog.com](https://flow-nft-catalog.com).
---
title: NFT Storefront Smart Contract
---

## Primer

The `NFTStorefrontV2` contract lets you create a *non-custodial Resource (NFT) marketplace* on the FLOW blockchain. 

`NFTStorefrontV2` makes it simple for Sellers to list NFTs in dApp specific marketplaces. DApp developers leverage the APIs provided by the contract to manage listings being offered for sale and to transact NFT trades.

![dapps_1](https://user-images.githubusercontent.com/14581509/191749748-714f9d8f-cb41-4be4-a3d2-ec84cb8b5ffb.png)

Developers should use the `NFTStorefrontV2` to create their marketplace and to enable p2p purchases. The diagram below shows how dApps can facilitate the creation of NFT listings for different marketplaces and how marketplaces can filter their listings.

Listings made through a specific dApp storefront can be simultaneously listed on 3rd party marketplaces beyond that dApp. Well known 3rd party marketplaces listen for compatible NFT listing events enabling the automation of listings into their marketplace dashboards.

![dapps_2](https://user-images.githubusercontent.com/14581509/191753605-e1c48a57-0c3c-4509-808b-8fee4e7d32e8.png)

Using the `NFTStorefrontV2`, marketplaces can instantly and easily tap into the vibrant FLOW NFT ecosystem and allow NFT holders to list their NFTs and enables creator royalties.

Marketplaces then process an NFT trade by interacting directly with seller storefronts. Flow's account based model ensures that NFTs listed for sale always reside in the Seller account until traded, regardless of how many listings are posted across any number of marketplaces, for the same NFT.

![marketplace_1](https://user-images.githubusercontent.com/14581509/191755699-fe0570cb-80a3-408c-8eef-4051e3209481.png)

## Functional Overview

A general purpose sale support contract for NFTs implementing the Flow [`NonFungibleToken`](https://github.com/onflow/flow-nft/blob/master/contracts/NonFungibleToken.cdc) standard.
Each account that wants to list NFTs for sale creates a `Storefront` resource to store in their account and lists individual sales within that Storefront as Listings. There is usually one Storefront per account held at the `/storage/NFTStorefrontV2`.

Each listing can define one or more sale cuts taken out of the sale price to go to one or more addresses. Listing fees, royalties, or other considerations can be paid using sale cuts. Also, the listing can include a commission as one of these sale cuts is paid to whoever facilitates the purchase. 

Listings can have an optional list of marketplace [receiver capabilities](https://cadence-lang.org/docs/language/capabilities) used to receive the commission for fulfilling the listing. An NFT may be listed in one or more Listings, and the validity of each listing can easily be checked.

Interested parties can globally track Listing events on-chain and filter by NFT types, IDs and other characteristics to determine which to make available for purchase within their own marketplace UIs."
## Selling NFTs

`NFTStorefrontV2` offers a generic process for creating the listing for an NFT. It provides all the essential APIs to manage those listings independently. 

Many marketplaces create a single storefront resource to manage different individual listings. We recommend creating the listing under the user-owned storefront resource to make it trustless and platform-independent. Users should possess the `Storefront` resource under their account to create the listing using the storefront contract.

## Creating a successful listing using the NFTStorefrontV2 contract.

As recommended above, the first step is to create and store the [Storefront resource](#resource-storefront) in the user account using the [setup_account](https://github.com/onflow/nft-storefront/blob/main/transactions/setup_account.cdc) transaction. 

The next step is to create a listing under the newly created storefront resource. If the user (repetitive) already holds the storefront resource, then use the existing resource. The seller can come with multiple requirements for listing their NFTs, and We try our best to cover most of them below.

### **Scenario 1:** Selling NFTs corresponds to more than one cryptocurrency, i.e. FLOW, USDC etc.

The `NFTStorefrontV2` contract doesn’t support selling an NFT for multiple different currencies with a single listing. However, this can be achieved by creating multiple listings for the same NFT for each different currency.

**Example -** Alice wants to sell a kitty and is open to receiving FLOW and USDC

![scenario_1](./scenario_1.png)

Putting an NFT on sell called listing, seller can create a listing using [sell_item](https://github.com/onflow/nft-storefront/blob/main/transactions/sell_item.cdc) transaction by providing some required details to list an NFT, i.e. Receiving currency type, [Capability](https://cadence-lang.org/docs/language/capabilities) from where NFT will be deducted etc. If interested look [here](#fun-createListing()) for more details. 

To receive a different currency seller has to provide a different __Receiver currency type__ , i.e. `salePaymentVaultType` As depicted in the above diagram, There are two listing formations with almost the same inputs. The only differentiator is the `salePaymentVaultType` parameter that needs to be different when creating duplicate NFT listings with different sale currency types.  

### **Scenario 2:**  Peer-to-Peer (p2p) listing of NFT: A listing anyone can fulfil.

Dapps can leverage the **NFTStorefrontV2** to facilitate the creation of a listing for the seller independent of any marketplace. Dapps or marketplaces can list those listings on their platforms, or seller can settle it p2p.

The seller can use [sell_item](https://github.com/onflow/nft-storefront/blob/main/transactions/sell_item.cdc) transaction to create a p2p listing, providing the `marketplacesAddress` with an empty array. The seller has a choice of providing [commission](#commission) to the facilitator of sale, which can also act as a discount if the facilitator and the purchaser are the same.

### **Scenario 3:** The seller wants to list its NFT in different marketplaces.

`NFTStorefrontV2` offers two different ways of doing it.

- The seller can create a listing and provide the `marketplacesAddress` that it wants to have a listing on using [sell_item](https://github.com/onflow/nft-storefront/blob/main/transactions/sell_item.cdc) transaction.
    
    Marketplaces can listen to `ListingAvailable` events and check whether their address is included in the `commissionReceivers` list; If yes, the marketplace would be rewarded during the successful fulfilment of the listing.
    
    Example - Bob wants to list on marketplace 0xA, 0xB & 0xC and is willing to offer 10% commission on the sale price of the listing to the marketplaces.
    
    ![scenario_3](https://user-images.githubusercontent.com/14581509/190966834-8eda4ec4-e9bf-49ef-9dec-3c47a236d281.png)
    

- Another way to accomplish this is to create separate listings for each marketplace on which a user wants their listing using [sell_item_with_marketplace_cut](https://github.com/onflow/nft-storefront/blob/main/transactions/sell_item_with_marketplace_cut.cdc) transaction. In this case, the marketplace would be incentivized by earning one of the parts of the [`saleCut`](https://github.com/onflow/nft-storefront/blob/160e97aa802405ad26a3164bcaff0fde7ee52ad2/contracts/NFTStorefrontV2.cdc#L104) by appending marketplace saleCut in `saleCuts` array during the creation of the listing.


### Considerations

1. **Ghost listings -** *Ghost listings are listings which don’t have an underlying NFT in the seller’s account. However, the listing is still available for buyers to attempt to purchase*. StorefrontV2 is not immune to ghost listings. Usually, ghost listings will cause a purchaser’s transaction to fail, which is annoying but isn’t a significant problem. Ghost listings become a problem for the seller when the listed NFT comes back to the seller’s account after its original sale. The ghost listing will no longer be invalid when it comes back, and anyone can purchase it even if the seller doesn’t want to sell it at that price anymore.
    
    **Note -** *We recommend that marketplaces and p2p dApps create an off-chain notification service that tells their users (i.e., sellers) to remove the listings if they don’t hold the NFT anymore in the same account.*
    
2. **Expired listings -** `NFTStorefrontV2` introduces a safety measure to specify that a listing will expire after a certain period that can be set during the creation so no one can purchase the listing anymore. It is not a fool-proof safety measure, but it does give some safe ground to the sellers for the ghost listings & stale listings.
    
    **Note -** *We recommended for marketplaces and p2p dApps not to show the expired listings on their dashboards.*

## Purchasing NFTs

Purchasing NFTs through the `NFTStorefrontV2` is simple. The buyer has to provide the payment vault and the `commissionRecipient` , if applicable, during the purchase. p2p dApps don’t need any intermediaries to facilitate the purchase of listings. [`purchase`](#fun-purchase) API offered by the `Listing` resource gets used to facilitate the purchase of NFT.

During the listing purchase all saleCuts are paid automatically. This also includes distributing royalties for that NFT, if applicable. If the vault provided by the buyer lacks sufficient funds then the transaction will fail.

### Considerations

1. **Auto cleanup -** `NFTStorefrontV2` offers a unique ability to do auto cleanup of duplicate listings during a purchase. It comes with a drawback if one NFT has thousands of duplicate listings. It will become the bottleneck during purchasing one of the listings as it will likely trigger an out-of-gas error. 

    **Note -** *We recommended NOT to have more than 50 (TBD) duplicate listings of any given NFT.*

2. **Unsupported receiver capability** - A common pitfall during the purchase of an NFT that some saleCut receivers don’t have a supported receiver capability because that entitled sale cut would transfer to first valid sale cut receiver. However, it can be partially solved by providing the generic receiver using the [`FungibleTokenSwitchboard`](https://github.com/onflow/flow-ft/blob/master/contracts/FungibleTokenSwitchboard.cdc) contract and adding all the currency capabilities the beneficiary wants to receive. More on the `FungibleTokenSwitchboard` can be read [here](https://github.com/onflow/flow-ft#fungible-token-switchboard)


## Enabling creator royalties for NFTs

The `NFTStorefrontV2` contract optionally supports paying royalties to the minter account for secondary resales of that NFT after the original sale. Marketplaces decide for themselves whether to support creator royalties when validating listings for sale eligibility. We encourage all marketplaces to support creator royalties and support community creators in the **FLOW** ecosystem.

Providing that a seller's NFT supports the [Royalty Metadata View](https://github.com/onflow/flow-nft/blob/21c254438910c8a4b5843beda3df20e4e2559625/contracts/MetadataViews.cdc#L335) standard, then marketplaces can honor royalties payments at time of purchase. `NFTStorefrontV2` dynamically calculates the royalties owed at the time of listing creation and applies it as a saleCut of the listing at the time of purchase.

```cadence
// Check whether the NFT implements the MetadataResolver or not.
if nft.getViews().contains(Type<MetadataViews.Royalties>()) {
		// Resolve the royalty view
    let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>())?? panic("Unable to retrieve the royalties")
	  // Fetch the royalties.
		let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()
		// Append the royalties as the salecut
    for royalty in royalties {
        self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))
        totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice
    }
}
```

Complete transaction can be viewed [here](https://github.com/onflow/nft-storefront/blob/main/transactions/sell_item.cdc).

saleCut only supports a single token receiver type and therefore beneficiaries of a `saleCut` can also only receive the token type used for the purchase. To support different token types for saleCuts we recommend using the [FungibleTokenSwitchboard](https://github.com/onflow/flow-ft/blob/master/contracts/FungibleTokenSwitchboard.cdc) contract. The contract defines a generic receiver for fungible tokens which itself handles routing of tokens to the respective vault for that token type. Learn more about this [here](https://github.com/onflow/flow-ft#fungible-token-switchboard).

## Enabling marketplace commissions for NFT sales

`NFTStorefrontV2` enables optional commissions on trades for marketplaces which require it as a condition to list a NFT for sale. Commission & commission receivers are set by the seller during initial listing creation. At time of purchase the commission amount is paid once only to the commission receiver matching the marketplace receiver address which facilitated the sale.

For NFT listings in marketplaces which don't require commission, commission receivers can be set as nil. Setting the buyer of the NFT and `commissionRecipient` to the same has the effect of applying a discount for the buyer.

![scenario_2](https://user-images.githubusercontent.com/14581509/190966499-c176203f-b6a6-4422-860f-1bf6f2bcdbb6.png).

## APIs & Events offered by NFTStorefrontV2

## Resource Interface `ListingPublic`

```cadence
resource interface ListingPublic {
    pub fun borrowNFT(): &NonFungibleToken.NFT?
    pub fun purchase(
          payment: @FungibleToken.Vault, 
          commissionRecipient: Capability<&{FungibleToken.Receiver}>?,
      ): @NonFungibleToken.NFT
    pub fun getDetails(): ListingDetail
    pub fun getAllowedCommissionReceivers(): [Capability<&{FungibleToken.Receiver}>]?
}
```
An interface providing a useful public interface to a Listing.

### Functions

**fun `borrowNFT()`**

```cadence
fun borrowNFT(): &NonFungibleToken.NFT?
```
This will assert in the same way as the NFT standard borrowNFT()
if the NFT is absent, for example if it has been sold via another listing.

---

**fun `purchase()`**

```cadence
fun purchase(payment FungibleToken.Vault, commissionRecipient Capability<&{FungibleToken.Receiver}>?): NonFungibleToken.NFT
```
Facilitates the purchase of the listing by providing the payment vault
and the commission recipient capability if there is a non-zero commission for the given listing.
Respective saleCuts are transferred to beneficiaries and funtion return underlying or listed NFT.

---

**fun `getDetails()`**

```cadence
fun getDetails(): ListingDetails
```
Fetches the details of the listings

---

**fun `getAllowedCommissionReceivers()`**

```cadence
fun getAllowedCommissionReceivers(): [Capability<&{FungibleToken.Receiver}>]?
```
Fetches the allowed marketplaces capabilities or commission receivers for the underlying listing.
If it returns `nil` then commission is up to grab by anyone.

---

## Resource `Storefront`

```cadence
resource Storefront {
    pub fun createListing(
            nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,
            nftType: Type,
            nftID: UInt64,
            salePaymentVaultType: Type,
            saleCuts: [SaleCut],
            marketplacesCapability: [Capability<&{FungibleToken.Receiver}>]?,
            customID: String?,
            commissionAmount: UFix64,
            expiry: UInt64
         ): UInt64
    pub fun removeListing(listingResourceID: UInt64)
    pub fun getListingIDs(): [UInt64]
    pub fun getDuplicateListingIDs(nftType: Type, nftID: UInt64, listingID: UInt64): [UInt64]
    pub fun cleanupExpiredListings(fromIndex: UInt64, toIndex: UInt64)
    pub fun borrowListing(listingResourceID: UInt64): &Listing{ListingPublic}?
}
```
A resource that allows its owner to manage a list of Listings, and anyone to interact with them
in order to query their details and purchase the NFTs that they represent.

Implemented Interfaces:
  - `StorefrontManager`
  - `StorefrontPublic`


### Initializer

```cadence
fun init()
```

### Functions

**fun `createListing()`**

```cadence
fun createListing(nftProviderCapability Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>, nftType Type, nftID UInt64, salePaymentVaultType Type, saleCuts [SaleCut], marketplacesCapability [Capability<&{FungibleToken.Receiver}>]?, customID String?, commissionAmount UFix64, expiry UInt64): UInt64
```
insert
Create and publish a Listing for an NFT.

---

**fun `removeListing()`**

```cadence
fun removeListing(listingResourceID UInt64)
```
removeListing
Remove a Listing that has not yet been purchased from the collection and destroy it.

---

**fun `getListingIDs()`**

```cadence
fun getListingIDs(): [UInt64]
```
getListingIDs
Returns an array of the Listing resource IDs that are in the collection

---

**fun `getDuplicateListingIDs()`**

```cadence
fun getDuplicateListingIDs(nftType Type, nftID UInt64, listingID UInt64): [UInt64]
```
getDuplicateListingIDs
Returns an array of listing IDs that are duplicates of the given `nftType` and `nftID`.

---

**fun `cleanupExpiredListings()`**

```cadence
fun cleanupExpiredListings(fromIndex UInt64, toIndex UInt64)
```
cleanupExpiredListings
Cleanup the expired listing by iterating over the provided range of indexes.

---

**fun `borrowListing()`**

```cadence
fun borrowListing(listingResourceID UInt64): &Listing{ListingPublic}?
```
borrowListing
Returns a read-only view of the listing for the given listingID if it is contained by this collection.

---

## Resource Interface `StorefrontPublic`

```cadence
resource interface StorefrontPublic {
    pub fun getListingIDs(): [UInt64]
    pub fun getDuplicateListingIDs(nftType: Type, nftID: UInt64, listingID: UInt64): [UInt64]
    pub fun cleanupExpiredListings(fromIndex: UInt64, toIndex: UInt64)
    pub fun borrowListing(listingResourceID: UInt64): &Listing{ListingPublic}?
    pub fun cleanupPurchasedListings(listingResourceID: UInt64)
    pub fun getExistingListingIDs(nftType: Type, nftID: UInt64): [UInt64]
}
```

StorefrontPublic
An interface to allow listing and borrowing Listings, and purchasing items via Listings
in a Storefront.

### Functions

**fun `getListingIDs()`**

```cadence
fun getListingIDs(): [UInt64]
```
getListingIDs Returns an array of the Listing resource IDs that are in the collection

---

**fun `getDuplicateListingIDs()`**

```cadence
fun getDuplicateListingIDs(nftType Type, nftID UInt64, listingID UInt64): [UInt64]
```
getDuplicateListingIDs Returns an array of listing IDs that are duplicates of the given nftType and nftID.

---

**fun `borrowListing()`**

```cadence
fun borrowListing(listingResourceID UInt64): &Listing{ListingPublic}?
```
borrowListing Returns a read-only view of the listing for the given listingID if it is contained by this collection.

---

**fun `cleanupExpiredListings()`**

```cadence
fun cleanupExpiredListings(fromIndex UInt64, toIndex UInt64)
```
cleanupExpiredListings Cleanup the expired listing by iterating over the provided range of indexes.

---

**fun `cleanupPurchasedListings()`**

```cadence
fun cleanupPurchasedListings(listingResourceID: UInt64)
```
cleanupPurchasedListings
Allows anyone to remove already purchased listings.

---

**fun `getExistingListingIDs()`**

```cadence
fun getExistingListingIDs(nftType Type, nftID UInt64): [UInt64]
```
getExistingListingIDs
Returns an array of listing IDs of the given `nftType` and `nftID`.

---

## Events

**event `StorefrontInitialized`**

```cadence
event StorefrontInitialized(storefrontResourceID: UInt64)
```
A Storefront resource has been created. Consumers can now expect events from this Storefront. Note that we do not specify an address: we cannot and should not. Created resources do not have an owner address, and may be moved
after creation in ways we cannot check. `ListingAvailable` events can be used to determine the address
of the owner of the Storefront at the time of the listing but only at that precise moment in that precise transaction. If the seller moves the Storefront while the listing is valid, that is on them.

---

**event `StorefrontDestroyed`**

```cadence
event StorefrontDestroyed(storefrontResourceID: UInt64)
```
A Storefront has been destroyed. Event consumers can now stop processing events from this Storefront.
Note - we do not specify an address.

---

**event `ListingAvailable`**

```cadence
event ListingAvailable(storefrontAddress: Address, listingResourceID: UInt64, nftType: Type, nftUUID: UInt64, nftID: UInt64, salePaymentVaultType: Type, salePrice: UFix64, customID: String?, commissionAmount: UFix64, commissionReceivers: [Address]?, expiry: UInt64)
```

Above event gets emitted when a listing has been created and added to a Storefront resource. The Address values here are valid when the event is emitted, but the state of the accounts they refer to may change outside of the
`NFTStorefrontV2` workflow, so be careful to check when using them.

---

**event `ListingCompleted`**

```cadence
event ListingCompleted(listingResourceID: UInt64, storefrontResourceID: UInt64, purchased: Bool, nftType: Type, nftUUID: UInt64, nftID: UInt64, salePaymentVaultType: Type, salePrice: UFix64, customID: String?, commissionAmount: UFix64, commissionReceiver: Address?, expiry: UInt64)
```
The listing has been resolved. It has either been purchased, removed or destroyed.

---

**event `UnpaidReceiver`**

```cadence
event UnpaidReceiver(receiver: Address, entitledSaleCut: UFix64)
```
A entitled receiver has not been paid during the sale of the NFT.

---


**Holistic process flow diagram of NFTStorefrontV2 -** 

![NFT Storefront Process flow](https://user-images.githubusercontent.com/14581509/191960793-ff153e5d-2934-410c-b724-5c5dffd2c20f.png)


## Glossary

SaleCut - A struct consists a recipient and amount of token ,i.e. cut that must be sent to recipient when a NFT get sold.
---
title: Flow Staking Collection Contract Reference
sidebar_label: Staking Collection
---

# Contract

The `FlowStakingCollection` contract is a contract that manages a resource containing a user's stake and delegation objects.

The `FlowStakingCollection` allows a user to manage multiple active nodes or delegators
and interact with node or delegator objects stored in either their optional locked account
or in the StakingCollection itself (stored in the main account).
If a user has locked tokens, StakingCollection allows a user to interact with their locked tokens
to perform staking actions for any of their nodes or delegators.

The staking collection also manages creating a node's machine accounts if they have any collector or consensus nodes.
It also allows them to deposit and withdraw tokens from any of their machine accounts through the staking collection.

See the [Staking Collection Docs](../../references/run-and-secure/staking/14-staking-collection.mdx) for more information on the design of the staking collection contract.

Source: [FlowStakingCollection.cdc](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowStakingCollection.cdc)

| Network    | Contract Address     |
|------------|----------------------|
| Testnet    | `0x95e019a17d0e23d7` |
| Mainnet    | `0x8d0e87b65159ae63` | 

## Transactions

Use the following transactions to interact with the StakingCollection.

_Note: The StakingCollection differentiates between stake and delegation requests through
passing an optional DelegatorID argument. For example, if you wish to Stake New Tokens for an active node,
pass `nil` as the optional DelegatorID argument to the Stake New Tokens transaction.
The same applies for all the other staking operation transactions.

| ID        | Name                                   | Source |
|-----------|----------------------------------------|--------|
|**`SCO.01`**| Setup Staking Collection               | [stakingCollection/setup_staking_collection.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/setup_staking_collection.cdc) |
|**`SCO.02`**| Register Delegator                     | [stakingCollection/register_delegator.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/register_delegator.cdc) |
|**`SCO.03`**| Register Node                          | [stakingCollection/register_node.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/register_node.cdc) |
|**`SCO.04`**| Create Machine Account                 | [stakingCollection/create_machine_account.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/create_machine_account.cdc) |
|**`SCO.05`**| Request Unstaking                      | [stakingCollection/request_unstaking.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/request_unstaking.cdc) |
|**`SCO.06`**| Stake New Tokens                       | [stakingCollection/stake_new_tokens.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/stake_new_tokens.cdc) |
|**`SCO.07`**| Stake Rewarded Tokens                  | [stakingCollection/stake_rewarded_tokens.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/stake_rewarded_tokens.cdc) |
|**`SCO.08`**| Stake Unstaked Tokens                  | [stakingCollection/stake_unstaked_tokens.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/stake_unstaked_tokens.cdc) |
|**`SCO.09`**| Unstake All                            | [stakingCollection/unstake_all.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/unstake_all.cdc) |
|**`SCO.10`**| Withdraw Rewarded Tokens               | [stakingCollection/withdraw_rewarded_tokens.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/withdraw_rewarded_tokens.cdc) |
|**`SCO.11`**| Withdraw Unstaked Tokens               | [stakingCollection/withdraw_unstaked_tokens.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/withdraw_unstaked_tokens.cdc) |
|**`SCO.12`**| Close Stake                            | [stakingCollection/close_stake.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/close_stake.cdc) |
|**`SCO.13`**| Transfer Node                          | [stakingCollection/transfer_node.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/transfer_node.cdc) |
|**`SCO.14`**| Transfer Delegator                     | [stakingCollection/transfer_delegator.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/transfer_delegator.cdc) |
|**`SCO.15`**| Withdraw From Machine Account          | [stakingCollection/withdraw_from_machine_account.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/withdraw_from_machine_account.cdc) |
|**`SCO.22`**| Update Networking Address              | [stakingCollection/update_networking_address.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/update_networking_address.cdc) |

## Scripts

| ID        | Name                                   | Source |
|-----------|----------------------------------------|--------|
|**`SCO.16`**| Get All Delegator Info                 | [stakingCollection/scripts/get_all_delegator_info.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/scripts/get_all_delegator_info.cdc) |
|**`SCO.15`**| Get All Node Info                      | [stakingCollection/scripts/get_all_node_info.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/scripts/get_all_node_info.cdc) |
|**`SCO.16`**| Get Delegator Ids                      | [stakingCollection/scripts/get_delegator_ids.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/scripts/get_delegator_ids.cdc) |
|**`SCO.17`**| Get Node Ids                           | [stakingCollection/scripts/get_node_ids.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/scripts/get_node_ids.cdc) |
|**`SCO.18`**| Get Does Stake Exist                   | [stakingCollection/scripts/get_does_stake_exist.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/scripts/get_does_stake_exist.cdc) |
|**`SCO.19`**| Get Locked Tokens Used                 | [stakingCollection/scripts/get_locked_tokens_used.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/scripts/get_locked_tokens_used.cdc) |
|**`SCO.20`**| Get Unlocked Tokens Used               | [stakingCollection/scripts/get_unlocked_tokens_used.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/scripts/get_unlocked_tokens_used.cdc) |
|**`SCO.21`**| Get Machine Accounts                   | [stakingCollection/scripts/get_machine_accounts.cdc](https://github.com/onflow/flow-core-contracts/blob/master/transactions/stakingCollection/scripts/get_machine_accounts.cdc) |


## Setup Transaction

To setup the Staking Collection for an account, use the `SC.01` transaction.

The setup process finds any node or delegator records already stored in the main account's storage,
as well as any in the associated locked account if an associated locked account exists.
It connects these node and delegator records with the new Staking Collection, allowing them
to be interacted with using the Staking Collection API.

## Events

The `StakingCollection` contract emits an event whenever an important action occurs.

```cadence
    pub event NodeAddedToStakingCollection(nodeID: String, role: UInt8, amountCommitted: UFix64, address: Address?)
    pub event DelegatorAddedToStakingCollection(nodeID: String, delegatorID: UInt32, amountCommitted: UFix64, address: Address?)

    pub event NodeRemovedFromStakingCollection(nodeID: String, role: UInt8, address: Address?)
    pub event DelegatorRemovedFromStakingCollection(nodeID: String, delegatorID: UInt32, address: Address?)

    pub event MachineAccountCreated(nodeID: String, role: UInt8, address: Address)
```# Contract `ExampleToken`

```cadence
contract ExampleToken {

    totalSupply:  UFix64

    VaultStoragePath:  StoragePath

    ReceiverPublicPath:  PublicPath

    VaultPublicPath:  PublicPath

    AdminStoragePath:  StoragePath
}
```


Implemented Interfaces:
  - `FungibleToken`

## Structs & Resources

### resource `Vault`

```cadence
resource Vault {

    balance:  UFix64
}
```
Each user stores an instance of only the Vault in their storage
The functions in the Vault and governed by the pre and post conditions
in FungibleToken when they are called.
The checks happen at runtime whenever a function is called.

Resources can only be created in the context of the contract that they
are defined in, so there is no way for a malicious user to create Vaults
out of thin air. A special Minter resource needs to be defined to mint
new tokens.

[More...](ExampleToken_Vault.md)

---

### resource `Administrator`

```cadence
resource Administrator {
}
```

[More...](ExampleToken_Administrator.md)

---

### resource `Minter`

```cadence
resource Minter {

    allowedAmount:  UFix64
}
```
Resource object that token admin accounts can hold to mint new tokens.

[More...](ExampleToken_Minter.md)

---

### resource `Burner`

```cadence
resource Burner {
}
```
Resource object that token admin accounts can hold to burn tokens.

[More...](ExampleToken_Burner.md)

---
## Functions

### fun `createEmptyVault()`

```cadence
func createEmptyVault(): Vault
```
Function that creates a new Vault with a balance of zero
and returns it to the calling context. A user must call this function
and store the returned Vault in their storage in order to allow their
account to be able to receive deposits of this token type.

Returns: The new Vault resource

---
## Events

### event `TokensInitialized`

```cadence
event TokensInitialized(initialSupply UFix64)
```
The event that is emitted when the contract is created

---

### event `TokensWithdrawn`

```cadence
event TokensWithdrawn(amount UFix64, from Address?)
```
The event that is emitted when tokens are withdrawn from a Vault

---

### event `TokensDeposited`

```cadence
event TokensDeposited(amount UFix64, to Address?)
```
The event that is emitted when tokens are deposited to a Vault

---

### event `TokensMinted`

```cadence
event TokensMinted(amount UFix64)
```
The event that is emitted when new tokens are minted

---

### event `TokensBurned`

```cadence
event TokensBurned(amount UFix64)
```
The event that is emitted when tokens are destroyed

---

### event `MinterCreated`

```cadence
event MinterCreated(allowedAmount UFix64)
```
The event that is emitted when a new minter resource is created

---

### event `BurnerCreated`

```cadence
event BurnerCreated()
```
The event that is emitted when a new burner resource is created

---
# Resource `Administrator`

```cadence
resource Administrator {
}
```

## Functions

### fun `createNewMinter()`

```cadence
func createNewMinter(allowedAmount UFix64): Minter
```
Function that creates and returns a new minter resource

Parameters:
  - allowedAmount : _The maximum quantity of tokens that the minter could create_

Returns: The Minter resource that would allow to mint tokens

---

### fun `createNewBurner()`

```cadence
func createNewBurner(): Burner
```
Function that creates and returns a new burner resource

Returns: The Burner resource

---
# Resource `Burner`

```cadence
resource Burner {
}
```

Resource object that token admin accounts can hold to burn tokens.
## Functions

### fun `burnTokens()`

```cadence
func burnTokens(from FungibleToken.Vault)
```
Function that destroys a Vault instance, effectively burning the tokens.

Note: the burned tokens are automatically subtracted from the
total supply in the Vault destructor.

Parameters:
  - from : _The Vault resource containing the tokens to burn_

---
# Resource `Minter`

```cadence
resource Minter {

    allowedAmount:  UFix64
}
```

Resource object that token admin accounts can hold to mint new tokens.

### Initializer

```cadence
func init(allowedAmount UFix64)
```


## Functions

### fun `mintTokens()`

```cadence
func mintTokens(amount UFix64): ExampleToken.Vault
```
Function that mints new tokens, adds them to the total supply,
and returns them to the calling context.

Parameters:
  - amount : _The quantity of tokens to mint_

Returns: The Vault resource containing the minted tokens

---
# Resource `Vault`

```cadence
resource Vault {

    balance:  UFix64
}
```

Each user stores an instance of only the Vault in their storage
The functions in the Vault and governed by the pre and post conditions
in FungibleToken when they are called.
The checks happen at runtime whenever a function is called.

Resources can only be created in the context of the contract that they
are defined in, so there is no way for a malicious user to create Vaults
out of thin air. A special Minter resource needs to be defined to mint
new tokens.

Implemented Interfaces:
  - `FungibleToken.Provider`
  - `FungibleToken.Receiver`
  - `FungibleToken.Balance`
  - `MetadataViews.Resolver`


### Initializer

```cadence
func init(balance UFix64)
```


## Functions

### fun `withdraw()`

```cadence
func withdraw(amount UFix64): FungibleToken.Vault
```
Function that takes an amount as an argument
and withdraws that amount from the Vault.
It creates a new temporary Vault that is used to hold
the money that is being transferred. It returns the newly
created Vault to the context that called so it can be deposited
elsewhere.

Parameters:
  - amount : _The amount of tokens to be withdrawn from the vault_

Returns: The Vault resource containing the withdrawn funds

---

### fun `deposit()`

```cadence
func deposit(from FungibleToken.Vault)
```
Function that takes a Vault object as an argument and adds
its balance to the balance of the owners Vault.
It is allowed to destroy the sent Vault because the Vault
was a temporary holder of the tokens. The Vault's balance has
been consumed and therefore can be destroyed.

Parameters:
  - from : _The Vault resource containing the funds that will be deposited_

---

### fun `getViews()`

```cadence
func getViews(): [Type]
```
The way of getting all the Metadata Views implemented by ExampleToken

developers to know which parameter to pass to the resolveView() method.

Returns: An array of Types defining the implemented views. This value will be used by

---

### fun `resolveView()`

```cadence
func resolveView(_ Type): AnyStruct?
```
The way of getting a Metadata View out of the ExampleToken

Parameters:
  - view : _The Type of the desired view._

Returns: A structure representing the requested view.

---
# Contract Interface `FungibleToken`

```cadence
contract interface FungibleToken {

    totalSupply:  UFix64
}
```

The interface that Fungible Token contracts implement.
## Interfaces
    
### resource interface `Provider`

```cadence
resource interface Provider {
}
```
The interface that enforces the requirements for withdrawing
tokens from the implementing type.

It does not enforce requirements on `balance` here,
because it leaves open the possibility of creating custom providers
that do not necessarily need their own balance.

[More...](FungibleToken_Provider.md)

---
    
### resource interface `Receiver`

```cadence
resource interface Receiver {
}
```
The interface that enforces the requirements for depositing
tokens into the implementing type.

We do not include a condition that checks the balance because
we want to give users the ability to make custom receivers that
can do custom things with the tokens, like split them up and
send them to different places.

[More...](FungibleToken_Receiver.md)

---
    
### resource interface `Balance`

```cadence
resource interface Balance {

    balance:  UFix64
}
```
The interface that contains the `balance` field of the Vault
and enforces that when new Vaults are created, the balance
is initialized correctly.

[More...](FungibleToken_Balance.md)

---
## Structs & Resources

### resource `Vault`

```cadence
resource Vault {

    balance:  UFix64
}
```
The resource that contains the functions to send and receive tokens.
The declaration of a concrete type in a contract interface means that
every Fungible Token contract that implements the FungibleToken interface
must define a concrete `Vault` resource that conforms to the `Provider`, `Receiver`,
and `Balance` interfaces, and declares their required fields and functions

[More...](FungibleToken_Vault.md)

---
## Functions

### fun `createEmptyVault()`

```cadence
func createEmptyVault(): Vault
```
Allows any user to create a new Vault that has a zero balance

Returns: The new Vault resource

---
## Events

### event `TokensInitialized`

```cadence
event TokensInitialized(initialSupply UFix64)
```
The event that is emitted when the contract is created

---

### event `TokensWithdrawn`

```cadence
event TokensWithdrawn(amount UFix64, from Address?)
```
The event that is emitted when tokens are withdrawn from a Vault

---

### event `TokensDeposited`

```cadence
event TokensDeposited(amount UFix64, to Address?)
```
The event that is emitted when tokens are deposited into a Vault

---
# Resource Interface `Balance`

```cadence
resource interface Balance {

    balance:  UFix64
}
```

The interface that contains the `balance` field of the Vault
and enforces that when new Vaults are created, the balance
is initialized correctly.
## Functions

### fun `getViews()`

```cadence
func getViews(): [Type]
```
Function that returns all the Metadata Views implemented by a Fungible Token

developers to know which parameter to pass to the resolveView() method.

Returns: An array of Types defining the implemented views. This value will be used by

---

### fun `resolveView()`

```cadence
func resolveView(_ Type): AnyStruct?
```
Function that resolves a metadata view for this fungible token by type.

Parameters:
  - view : _The Type of the desired view._

Returns: A structure representing the requested view.

---
# Resource Interface `Provider`

```cadence
resource interface Provider {
}
```

The interface that enforces the requirements for withdrawing
tokens from the implementing type.

It does not enforce requirements on `balance` here,
because it leaves open the possibility of creating custom providers
that do not necessarily need their own balance.
## Functions

### fun `withdraw()`

```cadence
func withdraw(amount UFix64): Vault
```
Subtracts tokens from the owner's Vault
and returns a Vault with the removed tokens.

The function's access level is public, but this is not a problem
because only the owner storing the resource in their account
can initially call this function.

The owner may grant other accounts access by creating a private
capability that allows specific other users to access
the provider resource through a reference.

The owner may also grant all accounts access by creating a public
capability that allows all users to access the provider
resource through a reference.

Parameters:
  - amount : _The amount of tokens to be withdrawn from the vault_

Returns: The Vault resource containing the withdrawn funds

---
# Resource Interface `Receiver`

```cadence
resource interface Receiver {
}
```

The interface that enforces the requirements for depositing
tokens into the implementing type.

We do not include a condition that checks the balance because
we want to give users the ability to make custom receivers that
can do custom things with the tokens, like split them up and
send them to different places.
## Functions

### fun `deposit()`

```cadence
func deposit(from Vault)
```
Takes a Vault and deposits it into the implementing resource type

Parameters:
  - from : _The Vault resource containing the funds that will be deposited_

---
# Resource `Vault`

```cadence
resource Vault {

    balance:  UFix64
}
```

The resource that contains the functions to send and receive tokens.
The declaration of a concrete type in a contract interface means that
every Fungible Token contract that implements the FungibleToken interface
must define a concrete `Vault` resource that conforms to the `Provider`, `Receiver`,
and `Balance` interfaces, and declares their required fields and functions

Implemented Interfaces:
  - `Provider`
  - `Receiver`
  - `Balance`


### Initializer

```cadence
func init(balance UFix64)
```


## Functions

### fun `withdraw()`

```cadence
func withdraw(amount UFix64): Vault
```

---

### fun `deposit()`

```cadence
func deposit(from Vault)
```
Takes a Vault and deposits it into the implementing resource type

Parameters:
  - from : _The Vault resource containing the funds that will be deposited_

---
# Contract `FungibleTokenMetadataViews`

```cadence
contract FungibleTokenMetadataViews {
}
```

This contract implements the metadata standard proposed
in FLIP-1087.

Ref: https://github.com/onflow/flips/blob/main/application/20220811-fungible-tokens-metadata.md

Structs and resources can implement one or more
metadata types, called views. Each view type represents
a different kind of metadata.
## Structs & Resources

### struct `FTView`

```cadence
struct FTView {

    ftDisplay:  FTDisplay?

    ftVaultData:  FTVaultData?
}
```
FTView wraps FTDisplay and FTVaultData, and is used to give a complete
picture of a Fungible Token. Most Fungible Token contracts should
implement this view.

[More...](FungibleTokenMetadataViews_FTView.md)

---

### struct `FTDisplay`

```cadence
struct FTDisplay {

    name:  String

    symbol:  String

    description:  String

    externalURL:  MetadataViews.ExternalURL

    logos:  MetadataViews.Medias

    socials:  {String: MetadataViews.ExternalURL}
}
```
View to expose the information needed to showcase this FT.
This can be used by applications to give an overview and
graphics of the FT.

[More...](FungibleTokenMetadataViews_FTDisplay.md)

---

### struct `FTVaultData`

```cadence
struct FTVaultData {

    storagePath:  StoragePath

    receiverPath:  PublicPath

    metadataPath:  PublicPath

    providerPath:  PrivatePath

    receiverLinkedType:  Type

    metadataLinkedType:  Type

    providerLinkedType:  Type

    createEmptyVault:  ((): @FungibleToken.Vault)
}
```
View to expose the information needed store and interact with a FT vault.
This can be used by applications to setup a FT vault with proper
storage and public capabilities.

[More...](FungibleTokenMetadataViews_FTVaultData.md)

---
## Functions

### fun `getFTView()`

```cadence
func getFTView(viewResolver &{MetadataViews.Resolver}): FTView
```
Helper to get a FT view.

Parameters:
  - viewResolver : _A reference to the resolver resource_

Returns: A FTView struct

---

### fun `getFTDisplay()`

```cadence
func getFTDisplay(_ &{MetadataViews.Resolver}): FTDisplay?
```
Helper to get FTDisplay in a way that will return a typed optional.

Parameters:
  - viewResolver : _A reference to the resolver resource_

Returns: An optional FTDisplay struct

---

### fun `getFTVaultData()`

```cadence
func getFTVaultData(_ &{MetadataViews.Resolver}): FTVaultData?
```
Helper to get FTVaultData in a way that will return a typed Optional.

Parameters:
  - viewResolver : _A reference to the resolver resource_

Returns: A optional FTVaultData struct

---
# Struct `FTDisplay`

```cadence
struct FTDisplay {

    name:  String

    symbol:  String

    description:  String

    externalURL:  MetadataViews.ExternalURL

    logos:  MetadataViews.Medias

    socials:  {String: MetadataViews.ExternalURL}
}
```

View to expose the information needed to showcase this FT.
This can be used by applications to give an overview and
graphics of the FT.

### Initializer

```cadence
func init(name String, symbol String, description String, externalURL MetadataViews.ExternalURL, logos MetadataViews.Medias, socials {String: MetadataViews.ExternalURL})
```


# Struct `FTVaultData`

```cadence
struct FTVaultData {

    storagePath:  StoragePath

    receiverPath:  PublicPath

    metadataPath:  PublicPath

    providerPath:  PrivatePath

    receiverLinkedType:  Type

    metadataLinkedType:  Type

    providerLinkedType:  Type

    createEmptyVault:  ((): @FungibleToken.Vault)
}
```

View to expose the information needed store and interact with a FT vault.
This can be used by applications to setup a FT vault with proper
storage and public capabilities.

### Initializer

```cadence
func init(storagePath StoragePath, receiverPath PublicPath, metadataPath PublicPath, providerPath PrivatePath, receiverLinkedType Type, metadataLinkedType Type, providerLinkedType Type, createEmptyVaultFunction ((): @FungibleToken.Vault))
```


# Struct `FTView`

```cadence
struct FTView {

    ftDisplay:  FTDisplay?

    ftVaultData:  FTVaultData?
}
```

FTView wraps FTDisplay and FTVaultData, and is used to give a complete
picture of a Fungible Token. Most Fungible Token contracts should
implement this view.

### Initializer

```cadence
func init(ftDisplay FTDisplay?, ftVaultData FTVaultData?)
```


# Contract `FungibleTokenSwitchboard`

```cadence
contract FungibleTokenSwitchboard {

    StoragePath:  StoragePath

    PublicPath:  PublicPath

    ReceiverPublicPath:  PublicPath
}
```

The contract that allows an account to receive payments in multiple fungible
tokens using a single `{FungibleToken.Receiver}` capability.
This capability should ideally be stored at the
`FungibleTokenSwitchboard.ReceiverPublicPath = /public/GenericFTReceiver`
but it can be stored anywhere.
## Interfaces
    
### resource interface `SwitchboardPublic`

```cadence
resource interface SwitchboardPublic {
}
```
The interface that enforces the method to allow anyone to check on the
available capabilities of a switchboard resource and also exposes the
deposit methods to deposit funds on it.

[More...](FungibleTokenSwitchboard_SwitchboardPublic.md)

---
## Structs & Resources

### resource `Switchboard`

```cadence
resource Switchboard {

    receiverCapabilities:  {Type: Capability<&{FungibleToken.Receiver}>}
}
```
The resource that stores the multiple fungible token receiver
capabilities, allowing the owner to add and remove them and anyone to
deposit any fungible token among the available types.

[More...](FungibleTokenSwitchboard_Switchboard.md)

---
## Functions

### fun `createSwitchboard()`

```cadence
func createSwitchboard(): Switchboard
```
Function that allows to create a new blank switchboard. A user must call
this function and store the returned resource in their storage.

---
## Events

### event `VaultCapabilityAdded`

```cadence
event VaultCapabilityAdded(type Type, switchboardOwner Address?, capabilityOwner Address?)
```
The event that is emitted when a new vault capability is added to a
switchboard resource.

---

### event `VaultCapabilityRemoved`

```cadence
event VaultCapabilityRemoved(type Type, switchboardOwner Address?, capabilityOwner Address?)
```
The event that is emitted when a vault capability is removed from a
switchboard resource.

---

### event `NotCompletedDeposit`

```cadence
event NotCompletedDeposit(type Type, amount UFix64, switchboardOwner Address?)
```
The event that is emitted when a deposit can not be completed.

---
# Resource `Switchboard`

```cadence
resource Switchboard {

    receiverCapabilities:  {Type: Capability<&{FungibleToken.Receiver}>}
}
```

The resource that stores the multiple fungible token receiver
capabilities, allowing the owner to add and remove them and anyone to
deposit any fungible token among the available types.

Implemented Interfaces:
  - `FungibleToken.Receiver`
  - `SwitchboardPublic`


### Initializer

```cadence
func init()
```


## Functions

### fun `addNewVault()`

```cadence
func addNewVault(capability Capability<&{FungibleToken.Receiver}>)
```
Adds a new fungible token receiver capability to the switchboard
resource.

token vault deposit function through `{FungibleToken.Receiver}` that
will be added to the switchboard.

Parameters:
  - capability : _The capability to expose a certain fungible_

---

### fun `addNewVaultsByPath()`

```cadence
func addNewVaultsByPath(paths [PublicPath], address Address)
```
Adds a number of new fungible token receiver capabilities by using
the paths where they are stored.

Parameters:
  - paths : _The paths where the public capabilities are stored._
  - address : _The address of the owner of the capabilities._

---

### fun `addNewVaultWrapper()`

```cadence
func addNewVaultWrapper(capability Capability<&{FungibleToken.Receiver}>, type Type)
```
Adds a new fungible token receiver capability to the switchboard
resource specifying which `Type`of `@FungibleToken.Vault` can be
deposited to it. Use it to include in your switchboard "wrapper"
receivers such as a `@TokenForwarding.Forwarder`. It can also be
used to overwrite the type attached to a certain capability without
having to remove that capability first.

token vault deposit function through `{FungibleToken.Receiver}` that
will be added to the switchboard.

capability, rather than the `Type` from the reference borrowed from
said capability

Parameters:
  - capability : _The capability to expose a certain fungible_
  - type : _The type of fungible token that can be deposited to that_

---

### fun `removeVault()`

```cadence
func removeVault(capability Capability<&{FungibleToken.Receiver}>)
```
Removes a fungible token receiver capability from the switchboard
resource.

removed from the switchboard.

Parameters:
  - capability : _The capability to a fungible token vault to be_

---

### fun `deposit()`

```cadence
func deposit(from FungibleToken.Vault)
```
Takes a fungible token vault and routes it to the proper fungible
token receiver capability for depositing it.

Parameters:
  - from : _The deposited fungible token vault resource._

---

### fun `safeDeposit()`

```cadence
func safeDeposit(from FungibleToken.Vault): FungibleToken.Vault?
```
Takes a fungible token vault and tries to route it to the proper
fungible token receiver capability for depositing the funds,
avoiding panicking if the vault is not available.

deposited.

funds if the deposit was successful, or still containing the funds
if the reference to the needed vault was not found.

Parameters:
  - vaultType : _The type of the ft vault that wants to be_

Returns: The deposited fungible token vault resource, without the

---

### fun `getVaultTypes()`

```cadence
func getVaultTypes(): [Type]
```
A getter function to know which tokens a certain switchboard
resource is prepared to receive.

`{FungibleToken.Receiver}` capabilities that can be effectively
borrowed.

Returns: The keys from the dictionary of stored

---
# Resource Interface `SwitchboardPublic`

```cadence
resource interface SwitchboardPublic {
}
```

The interface that enforces the method to allow anyone to check on the
available capabilities of a switchboard resource and also exposes the
deposit methods to deposit funds on it.
## Functions

### fun `getVaultTypes()`

```cadence
func getVaultTypes(): [Type]
```

---

### fun `deposit()`

```cadence
func deposit(from FungibleToken.Vault)
```

---

### fun `safeDeposit()`

```cadence
func safeDeposit(from FungibleToken.Vault): FungibleToken.Vault?
```

---
---
title: Fungible Token (FT) Standard
sidebar_position: 1
---

This is a description of the Flow standard for fungible token contracts.  It is meant to contain the minimum requirements to implement a safe, secure, easy to understand, and easy to use fungible token contract. It also includes an example implementation to show how a concrete smart contract would actually implement the interface.

## What is Flow?

Flow is a new blockchain for open worlds. Read more about it [here](https://flow.com/).

## What is Cadence?

Cadence is a new Resource-oriented programming language 
for developing smart contracts for the Flow Blockchain.
Read more about it [here](../../../build/guides/smart-contracts/cadence.md) and see its implementation [here](https://github.com/onflow/cadence)

We recommend that anyone who is reading this should have already
completed the [Cadence Tutorials](https://cadence-lang.org/docs/tutorial/first-steps) 
so they can build a basic understanding of the programming language.

Resource-oriented programming, and by extension Cadence, 
is the perfect programming environment for currencies, because users are able
to store their tokens directly in their accounts and transact
peer-to-peer. Please see the [blog post about resources](https://medium.com/dapperlabs/resource-oriented-programming-bee4d69c8f8e)
to understand why they are perfect for digital assets.

## Feedback

Flow and Cadence are both still in development, so this standard will still 
be going through a lot of changes as the protocol and language evolves, 
and as we receive feedback from the community about the standard.

We'd love to hear from anyone who has feedback. 
Main feedback we are looking for is:

The feedback we are looking for is:

- Are there any features that are missing from the standard?
- Are the features that we have included defined in the best way possible?
- Are there any pre and post conditions for functions that are missing?
- Are the pre and post conditions defined well enough? Error messages?
- Are there any other actions that need an event defined for them?
- Are the current event definitions clear enough and do they provide enough information for apps and other actors a clear look into what is happening?
- Are the variable, function, and parameter names descriptive enough?
- Are there any openings for bugs or vulnerabilities that we are not noticing?
- Is the documentation/comments clear and concise and organized in a coherent manner?

## Basics of the Standard:

The code for the standard is in `contracts/FungibleToken.cdc`. An example implementation of the standard that simulates what a simple token would be like is in `contracts/ExampleToken.cdc`. 

The exact smart contract that is used for the official Flow Network Token is in `contracts/FlowToken.cdc`

Example transactions that users could use to interact with fungible tokens are located in the `transactions/` directory. These templates are mostly generic and can be used with any fungible token implementation by providing the correct addresses, names, and values.

The standard consists of a contract interface called `FungibleToken` that requires implementing contracts to define a `Vault` resource that represents the tokens that an account owns. Each account that owns tokens will have a `Vault` stored in its account storage.  Users call functions on each other's `Vault`s to send and receive tokens.  

Right now we are using unsigned 64-bit fixed point numbers `UFix64` as the type to represent token balance information. This type has 8 decimal places and cannot represent negative numbers.

## Core Features (All contained in the main FungibleToken interface)

1- Getting metadata for the token smart contract via the fields of the contract:

- `pub var totalSupply: UFix64`
    - The only required field of the contract.  It would be incremented when new tokens are minted and decremented when they are destroyed.
- Event that gets emitted when the contract is initialized
    - `pub event TokensInitialized(initialSupply: UFix64)`

2- Retrieving the token fields of a `Vault` in an account that owns tokens.

- Balance interface
    - `pub var balance: UFix64`
        - The only required field of the `Vault` type

3- Withdrawing a specific amount of tokens *amount* using the *withdraw* function of the owner's `Vault`

- Provider interface
    - `pub fun withdraw(amount: UFix64): @FungibleToken.Vault`
        - Conditions
            - the returned Vault's balance must equal the amount withdrawn
            - The amount withdrawn must be less than or equal to the balance
            - The resulting balance must equal the initial balance - amount
    - Users can give other accounts a reference to their `Vault` cast as a `Provider` to allow them to withdraw and send tokens for them.  A contract can define any custom logic to govern the amount of tokens that can be withdrawn at a time with a `Provider`.  This can mimic the `approve`, `transferFrom` functionality of ERC20.
- withdraw event
    - Indicates how much was withdrawn and from what account the `Vault` is stored in.
      If the `Vault` is not in account storage when the event is emitted,
      `from` will be `nil`.
    - `pub event TokensWithdrawn(amount: UFix64, from: Address?)`

4 - Depositing a specific amount of tokens *from* using the *deposit* function of the recipient's `Vault`

- `Receiver` interface
    - `pub fun deposit(from: @FungibleToken.Vault)`
    - Conditions
        - `from` balance must be non-zero
        - The resulting balance must be equal to the initial balance + the balance of `from`
- deposit event
    - Indicates how much was deposited and to what account the `Vault` is stored in.
      If the `Vault` is not in account storage when the event is emitted,
      `to` will be `nil`.
    - `pub event TokensDeposited(amount: UFix64, to: Address?)`
- Users could create custom `Receiver`s to trigger special code when transfers to them happen, like forwarding the tokens
  to another account, splitting them up, and much more.

- It is important that if you are making your own implementation of the fungible token interface that
  you cast the input to `deposit` as the type of your token.
  `let vault <- from as! @ExampleToken.Vault`
  The interface specifies the argument as `@FungibleToken.Vault`, any resource that satisfies this can be sent to the deposit function. The interface checks that the concrete types match, but you'll still need to cast the `Vault` before storing it.

5 - Creating an empty Vault resource

- `pub fun createEmptyVault(): @FungibleToken.Vault`
- Defined in the contract 
  To create an empty `Vault`, the caller calls the function in the contract and stores the Vault in their storage.
- Conditions:
    - the balance of the returned Vault must be 0

6 - Destroying a Vault

If a `Vault` is explicitly destroyed using Cadence's `destroy` keyword, the balance of the destroyed vault must be subracted from the total supply.

7 - Standard for Token Metadata

- not sure what this should be yet
- Could be a dictionary, could be an IPFS hash, could be json, etc.
- need suggestions!


## Comparison to Similar Standards in Ethereum

This spec covers much of the same ground that a spec like ERC-20 covers, but without most of the downsides.  

- Tokens cannot be sent to accounts or contracts that don't have owners or don't understand how to use them, because an account has to have a `Vault` in its storage to receive tokens.  No `safetransfer` is needed.
- If the recipient is a contract that has a stored `Vault`, the tokens can just be deposited to that Vault without having to do a clunky `approve`, `transferFrom`
- Events are defined in the contract for withdrawing and depositing, so a recipient will always be notified that someone has sent them tokens with the deposit event.
- The `approve`, `transferFrom` pattern is not included, so double spends are not permitted
- Transfers can trigger actions because users can define custom `Receivers` to execute certain code when a token is sent.
- Cadence integer types protect against overflow and underflow, so a `SafeMath`-equivalent library is not needed.

### Metadata

A standard for token metadata is still an unsolved problem in the general blockchain world and we are still thinking about ways to solve it in Cadence. We hope to be able to store all metadata on-chain and are open to any ideas or feedback on how this could be implemented.


## Bonus Features

**Minting and Burning are not included in the standard but are included in the FlowToken example contract to illustrate what minting and burning might look like for a token in Flow.**

8 - Minting or Burning a specific amount of tokens using a specific minter resource that an owner can control

- `MintandBurn` Resource
    - function to mintTokens
    - tokens minted event
    - Each minter has a set amount of tokens that they are allowed to mint. This cannot be changed and a new minter needs to be created to add more allowance.
    - function to burnTokens
    - tokens Burnt event
    - Each time tokens are minted or burnt, that value is added or subtracted to or from the total supply.


**The following features could each be defined as a separate interface. It would be good to make standards for these, but not necessary to include in the main standard interface and are not currently defined in this example.**

9 - Withdrawing a specific amount of tokens from someone else's `Vault` by using their `provider` reference.

- approved withdraw event
- Providing a resource that only approves an account to send a specific amount per transaction or per day/month/etc.
- Returning the amount of tokens that an account can send for another account.
- Reading the balance of the account that you have permission to send tokens for
- Owner is able to increase and decrease the approval at will, or revoke it completely
    - This is much harder than anticipated

11 - Pausing Token transfers (maybe a way to prevent the contract from being imported)

12 - Cloning the token to create a new token with the same distribution

13 - Restricted ownership (For accredited investors and such)
- allowlisting
- denylisting

# How to use the Fungible Token contract

To use the Flow Token contract as is, you need to follow these steps:

1. If you are using the Playground, you need to deploy the `FungibleToken` definition to account 1 yourself and import it in `ExampleToken`. It is a predeployed interface in the emulator, testnet, and mainnet and you can import definition from those accounts:
    - `0xee82856bf20e2aa6` on emulator
    - `0x9a0766d93b6608b7` on testnet
    - `0xf233dcee88fe0abe` on mainnet
2. Deploy the `ExampleToken` definition
3. You can use the `get_balance.cdc` or `get_supply.cdc` scripts to read the 
   balance of a user's `Vault` or the total supply of all tokens, respectively.
4. Use the `setupAccount.cdc` on any account to set up the account to be able to
   use `FlowTokens`.
5. Use the `transfer_tokens.cdc` transaction file to send tokens from one user with
   a `Vault` in their account storage to another user with a `Vault` in their account storage.
6. Use the `mint_tokens.cdc` transaction with the admin account to mint new tokens.
7. Use the `burn_tokens.cdc` transaction with the admin account to burn tokens.
8. Use the `create_minter.cdc` transaction to create a new MintandBurn resource
   and store it in a new Admin's account.


# Running Automated Tests

You can find automated tests in the `lib/go/test/token_test.go` file. It uses the transaction templates that are contained in the `lib/go/templates/transaction_templates.go` file. Currently, these rely on a dependency from a private dapper labs repository to run, so external users will not be able to run them. We are working on making all of this public so anyone can run tests, but haven't completed this work yet.

## License 

The works in these folders are under the [Unlicense](https://github.com/onflow/flow-ft/blob/master/LICENSE):

- [/contracts](https://github.com/onflow/flow-ft/blob/master/contracts/)
# Contract `ExampleNFT`

```cadence
contract ExampleNFT {

    totalSupply:  UInt64

    CollectionStoragePath:  StoragePath

    CollectionPublicPath:  PublicPath

    MinterStoragePath:  StoragePath
}
```


Implemented Interfaces:
  - `NonFungibleToken`

## Interfaces
    
### resource interface `ExampleNFTCollectionPublic`

```cadence
resource interface ExampleNFTCollectionPublic {
}
```
Defines the methods that are particular to this NFT contract collection

[More...](ExampleNFT_ExampleNFTCollectionPublic.md)

---
## Structs & Resources

### resource `NFT`

```cadence
resource NFT {

    id:  UInt64

    name:  String

    description:  String

    thumbnail:  String

    royalties:  [MetadataViews.Royalty]

    metadata:  {String: AnyStruct}
}
```
The core resource that represents a Non Fungible Token.
New instances will be created using the NFTMinter resource
and stored in the Collection resource

[More...](ExampleNFT_NFT.md)

---

### resource `Collection`

```cadence
resource Collection {

    ownedNFTs:  {UInt64: NonFungibleToken.NFT}
}
```
The resource that will be holding the NFTs inside any account.
In order to be able to manage NFTs any account will need to create
an empty collection first

[More...](ExampleNFT_Collection.md)

---

### resource `NFTMinter`

```cadence
resource NFTMinter {
}
```
Resource that an admin or something similar would own to be
able to mint new NFTs

[More...](ExampleNFT_NFTMinter.md)

---
## Functions

### fun `createEmptyCollection()`

```cadence
func createEmptyCollection(): NonFungibleToken.Collection
```
Allows anyone to create a new empty collection

Returns: The new Collection resource

---
## Events

### event `ContractInitialized`

```cadence
event ContractInitialized()
```
The event that is emitted when the contract is created

---

### event `Withdraw`

```cadence
event Withdraw(id UInt64, from Address?)
```
The event that is emitted when an NFT is withdrawn from a Collection

---

### event `Deposit`

```cadence
event Deposit(id UInt64, to Address?)
```
The event that is emitted when an NFT is deposited to a Collection

---
# Resource `Collection`

```cadence
resource Collection {

    ownedNFTs:  {UInt64: NonFungibleToken.NFT}
}
```

The resource that will be holding the NFTs inside any account.
In order to be able to manage NFTs any account will need to create
an empty collection first

Implemented Interfaces:
  - `ExampleNFTCollectionPublic`
  - `NonFungibleToken.Provider`
  - `NonFungibleToken.Receiver`
  - `NonFungibleToken.CollectionPublic`
  - `MetadataViews.ResolverCollection`


### Initializer

```cadence
func init()
```


## Functions

### fun `withdraw()`

```cadence
func withdraw(withdrawID UInt64): NonFungibleToken.NFT
```
Removes an NFT from the collection and moves it to the caller

Parameters:
  - withdrawID : _The ID of the NFT that wants to be withdrawn_

Returns: The NFT resource that has been taken out of the collection

---

### fun `deposit()`

```cadence
func deposit(token NonFungibleToken.NFT)
```
Adds an NFT to the collections dictionary and adds the ID to the id array

Parameters:
  - token : _The NFT resource to be included in the collection_

---

### fun `getIDs()`

```cadence
func getIDs(): [UInt64]
```
Helper method for getting the collection IDs

Returns: An array containing the IDs of the NFTs in the collection

---

### fun `borrowNFT()`

```cadence
func borrowNFT(id UInt64): &NonFungibleToken.NFT
```
Gets a reference to an NFT in the collection so that
the caller can read its metadata and call its methods

Parameters:
  - id : _The ID of the wanted NFT_

Returns: A reference to the wanted NFT resource

---

### fun `borrowExampleNFT()`

```cadence
func borrowExampleNFT(id UInt64): &ExampleNFT.NFT?
```
Gets a reference to an NFT in the collection so that
the caller can read its metadata and call its methods

Parameters:
  - id : _The ID of the wanted NFT_

Returns: A reference to the wanted NFT resource

---

### fun `borrowViewResolver()`

```cadence
func borrowViewResolver(id UInt64): &AnyResource{MetadataViews.Resolver}
```
Gets a reference to the NFT only conforming to the `{MetadataViews.Resolver}`
interface so that the caller can retrieve the views that the NFT
is implementing and resolve them

Parameters:
  - id : _The ID of the wanted NFT_

Returns: The resource reference conforming to the Resolver interface

---
# Resource Interface `ExampleNFTCollectionPublic`

```cadence
resource interface ExampleNFTCollectionPublic {
}
```

Defines the methods that are particular to this NFT contract collection
## Functions

### fun `deposit()`

```cadence
func deposit(token NonFungibleToken.NFT)
```

---

### fun `getIDs()`

```cadence
func getIDs(): [UInt64]
```

---

### fun `borrowNFT()`

```cadence
func borrowNFT(id UInt64): &NonFungibleToken.NFT
```

---

### fun `borrowExampleNFT()`

```cadence
func borrowExampleNFT(id UInt64): &ExampleNFT.NFT?
```

---
# Resource `NFT`

```cadence
resource NFT {

    id:  UInt64

    name:  String

    description:  String

    thumbnail:  String

    royalties:  [MetadataViews.Royalty]

    metadata:  {String: AnyStruct}
}
```

The core resource that represents a Non Fungible Token.
New instances will be created using the NFTMinter resource
and stored in the Collection resource

Implemented Interfaces:
  - `NonFungibleToken.INFT`
  - `MetadataViews.Resolver`


### Initializer

```cadence
func init(id UInt64, name String, description String, thumbnail String, royalties [MetadataViews.Royalty], metadata {String: AnyStruct})
```


## Functions

### fun `getViews()`

```cadence
func getViews(): [Type]
```
Function that returns all the Metadata Views implemented by a Non Fungible Token

developers to know which parameter to pass to the resolveView() method.

Returns: An array of Types defining the implemented views. This value will be used by

---

### fun `resolveView()`

```cadence
func resolveView(_ Type): AnyStruct?
```
Function that resolves a metadata view for this token.

Parameters:
  - view : _The Type of the desired view._

Returns: A structure representing the requested view.

---
# Resource `NFTMinter`

```cadence
resource NFTMinter {
}
```

Resource that an admin or something similar would own to be
able to mint new NFTs
## Functions

### fun `mintNFT()`

```cadence
func mintNFT(recipient &{NonFungibleToken.CollectionPublic}, name String, description String, thumbnail String, royalties [MetadataViews.Royalty])
```
Mints a new NFT with a new ID and deposit it in the
recipients collection using their collection reference

Parameters:
  - recipient : _A capability to the collection where the new NFT will be deposited_
  - name : _The name for the NFT metadata_
  - description : _The description for the NFT metadata_
  - thumbnail : _The thumbnail for the NFT metadata_
  - royalties : _An array of Royalty structs, see MetadataViews docs_

---
# Contract `MetadataViews`

```cadence
pub contract MetadataViews {
}
```

This contract implements the metadata standard proposed
in FLIP-0636.

Ref: https://github.com/onflow/flips/blob/main/application/20210916-nft-metadata.md

Structs and resources can implement one or more
metadata types, called views. Each view type represents
a different kind of metadata, such as a creator biography
or a JPEG image file.
## Interfaces
    
### `Resolver`

```cadence
pub resource interface Resolver {
}
```
Provides access to a set of metadata views. A struct or
resource (e.g. an NFT) can implement this interface to provide access to
the views that it supports.

[More...](MetadataViews_Resolver.md)

---
    
### `ResolverCollection`

```cadence
pub resource interface ResolverCollection {
}
```
A group of view resolvers indexed by ID.

[More...](MetadataViews_ResolverCollection.md)

---
    
### `File`

```cadence
pub struct interface File {
}
```
Generic interface that represents a file stored on or off chain. Files
can be used to references images, videos and other media.

[More...](MetadataViews_File.md)

---
## Structs & Resources

### `NFTView`

```cadence
pub struct NFTView {

    pub let id: UInt64

    pub let uuid: UInt64

    pub let display: Display?

    pub let externalURL: ExternalURL?

    pub let collectionData: NFTCollectionData?

    pub let collectionDisplay: NFTCollectionDisplay?

    pub let royalties: Royalties?

    pub let traits: Traits?
}
```
NFTView wraps all Core views along `id` and `uuid` fields, and is used
to give a complete picture of an NFT. Most NFTs should implement this
view.

[More...](MetadataViews_NFTView.md)

---

### `Display`

```cadence
pub struct Display {

    pub let name: String

    pub let description: String

    pub let thumbnail: AnyStruct{File}
}
```
Display is a basic view that includes the name, description and
thumbnail for an object. Most objects should implement this view.

[More...](MetadataViews_Display.md)

---

### `HTTPFile`

```cadence
pub struct HTTPFile {

    pub let url: String
}
```
View to expose a file that is accessible at an HTTP (or HTTPS) URL.

[More...](MetadataViews_HTTPFile.md)

---

### `IPFSFile`

```cadence
pub struct IPFSFile {

    pub let cid: String

    pub let path: String?
}
```
View to expose a file stored on IPFS.
IPFS images are referenced by their content identifier (CID)
rather than a direct URI. A client application can use this CID
to find and load the image via an IPFS gateway.

[More...](MetadataViews_IPFSFile.md)

---

### `Edition`

```cadence
pub struct Edition {

    pub let name: String?

    pub let number: UInt64

    pub let max: UInt64?
}
```
Optional view for collections that issue multiple objects
with the same or similar metadata, for example an X of 100 set. This
information is useful for wallets and marketplaces.
An NFT might be part of multiple editions, which is why the edition
information is returned as an arbitrary sized array

[More...](MetadataViews_Edition.md)

---

### `Editions`

```cadence
pub struct Editions {

    pub let infoList: [Edition]
}
```
Wrapper view for multiple Edition views

[More...](MetadataViews_Editions.md)

---

### `Serial`

```cadence
pub struct Serial {

    pub let number: UInt64
}
```
View representing a project-defined serial number for a specific NFT
Projects have different definitions for what a serial number should be
Some may use the NFTs regular ID and some may use a different
classification system. The serial number is expected to be unique among
other NFTs within that project

[More...](MetadataViews_Serial.md)

---

### `Royalty`

```cadence
pub struct Royalty {

    pub let receiver: Capability<&AnyResource{FungibleToken.Receiver}>

    pub let cut: UFix64

    pub let description: String
}
```
View that defines the composable royalty standard that gives marketplaces a
unified interface to support NFT royalties.

[More...](MetadataViews_Royalty.md)

---

### `Royalties`

```cadence
pub struct Royalties {

    priv let cutInfos: [Royalty]
}
```
Wrapper view for multiple Royalty views.
Marketplaces can query this `Royalties` struct from NFTs
and are expected to pay royalties based on these specifications.

[More...](MetadataViews_Royalties.md)

---

### `Media`

```cadence
pub struct Media {

    pub let file: AnyStruct{File}

    pub let mediaType: String
}
```
View to represent, a file with an correspoiding mediaType.

[More...](MetadataViews_Media.md)

---

### `Medias`

```cadence
pub struct Medias {

    pub let items: [Media]
}
```
Wrapper view for multiple media views

[More...](MetadataViews_Medias.md)

---

### `License`

```cadence
pub struct License {

    pub let spdxIdentifier: String
}
```
View to represent a license according to https://spdx.org/licenses/
This view can be used if the content of an NFT is licensed.

[More...](MetadataViews_License.md)

---

### `ExternalURL`

```cadence
pub struct ExternalURL {

    pub let url: String
}
```
View to expose a URL to this item on an external site.
This can be used by applications like .find and Blocto to direct users
to the original link for an NFT.

[More...](MetadataViews_ExternalURL.md)

---

### `NFTCollectionData`

```cadence
pub struct NFTCollectionData {

    pub let storagePath: StoragePath

    pub let publicPath: PublicPath

    pub let providerPath: PrivatePath

    pub let publicCollection: Type

    pub let publicLinkedType: Type

    pub let providerLinkedType: Type

    pub let createEmptyCollection: ((): @NonFungibleToken.Collection)
}
```
View to expose the information needed store and retrieve an NFT.
This can be used by applications to setup a NFT collection with proper
storage and public capabilities.

[More...](MetadataViews_NFTCollectionData.md)

---

### `NFTCollectionDisplay`

```cadence
pub struct NFTCollectionDisplay {

    pub let name: String

    pub let description: String

    pub let externalURL: ExternalURL

    pub let squareImage: Media

    pub let bannerImage: Media

    pub let socials: {String: ExternalURL}
}
```
View to expose the information needed to showcase this NFT's
collection. This can be used by applications to give an overview and
graphics of the NFT collection this NFT belongs to.

[More...](MetadataViews_NFTCollectionDisplay.md)

---

### `Rarity`

```cadence
pub struct Rarity {

    pub let score: UFix64?

    pub let max: UFix64?

    pub let description: String?
}
```
View to expose rarity information for a single rarity
Note that a rarity needs to have either score or description but it can
have both

[More...](MetadataViews_Rarity.md)

---

### `Trait`

```cadence
pub struct Trait {

    pub let name: String

    pub let value: AnyStruct

    pub let displayType: String?

    pub let rarity: Rarity?
}
```
View to represent a single field of metadata on an NFT.
This is used to get traits of individual key/value pairs along with some
contextualized data about the trait

[More...](MetadataViews_Trait.md)

---

### `Traits`

```cadence
pub struct Traits {

    pub let traits: [Trait]
}
```
Wrapper view to return all the traits on an NFT.
This is used to return traits as individual key/value pairs along with
some contextualized data about each trait.

[More...](MetadataViews_Traits.md)

---
## Functions

### `getNFTView()`

```cadence
fun getNFTView(id: UInt64, viewResolver: &{Resolver}): NFTView
```
Helper to get an NFT view

Parameters:
  - id : _The NFT id_
  - viewResolver : _A reference to the resolver resource_

Returns: A NFTView struct

---

### `getDisplay()`

```cadence
fun getDisplay(_: &{Resolver}): Display?
```
Helper to get Display in a typesafe way

Parameters:
  - viewResolver : _A reference to the resolver resource_

Returns: An optional Display struct

---

### `getEditions()`

```cadence
fun getEditions(_: &{Resolver}): Editions?
```
Helper to get Editions in a typesafe way

Parameters:
  - viewResolver : _A reference to the resolver resource_

Returns: An optional Editions struct

---

### `getSerial()`

```cadence
fun getSerial(_: &{Resolver}): Serial?
```
Helper to get Serial in a typesafe way

Parameters:
  - viewResolver : _A reference to the resolver resource_

Returns: An optional Serial struct

---

### `getRoyalties()`

```cadence
fun getRoyalties(_: &{Resolver}): Royalties?
```
Helper to get Royalties in a typesafe way

Parameters:
  - viewResolver : _A reference to the resolver resource_

Returns: A optional Royalties struct

---

### `getRoyaltyReceiverPublicPath()`

```cadence
fun getRoyaltyReceiverPublicPath(): PublicPath
```
Get the path that should be used for receiving royalties
This is a path that will eventually be used for a generic switchboard receiver,
hence the name but will only be used for royalties for now.

Returns: The PublicPath for the generic FT receiver

---

### `getMedias()`

```cadence
fun getMedias(_: &{Resolver}): Medias?
```
Helper to get Medias in a typesafe way

Parameters:
  - viewResolver : _A reference to the resolver resource_

Returns: A optional Medias struct

---

### `getLicense()`

```cadence
fun getLicense(_: &{Resolver}): License?
```
Helper to get License in a typesafe way

Parameters:
  - viewResolver : _A reference to the resolver resource_

Returns: A optional License struct

---

### `getExternalURL()`

```cadence
fun getExternalURL(_: &{Resolver}): ExternalURL?
```
Helper to get ExternalURL in a typesafe way

Parameters:
  - viewResolver : _A reference to the resolver resource_

Returns: A optional ExternalURL struct

---

### `getNFTCollectionData()`

```cadence
fun getNFTCollectionData(_: &{Resolver}): NFTCollectionData?
```
Helper to get NFTCollectionData in a way that will return an typed Optional

Parameters:
  - viewResolver : _A reference to the resolver resource_

Returns: A optional NFTCollectionData struct

---

### `getNFTCollectionDisplay()`

```cadence
fun getNFTCollectionDisplay(_: &{Resolver}): NFTCollectionDisplay?
```
Helper to get NFTCollectionDisplay in a way that will return a typed
Optional

Parameters:
  - viewResolver : _A reference to the resolver resource_

Returns: A optional NFTCollection struct

---

### `getRarity()`

```cadence
fun getRarity(_: &{Resolver}): Rarity?
```
Helper to get Rarity view in a typesafe way

Parameters:
  - viewResolver : _A reference to the resolver resource_

Returns: A optional Rarity struct

---

### `getTraits()`

```cadence
fun getTraits(_: &{Resolver}): Traits?
```
Helper to get Traits view in a typesafe way

Parameters:
  - viewResolver : _A reference to the resolver resource_

Returns: A optional Traits struct

---

### `dictToTraits()`

```cadence
fun dictToTraits(dict: {String: AnyStruct}, excludedNames: [String]?): Traits
```
Helper function to easily convert a dictionary to traits. For NFT
collections that do not need either of the optional values of a Trait,
this method should suffice to give them an array of valid traits.

keys that are not wanted to become `Traits`

Parameters:
  - dict : _The dictionary to be converted to Traits_
  - excludedNames : _An optional String array specifying the `dict`_

Returns: The generated Traits view

---
# Struct `Display`

```cadence
pub struct Display {

    pub let name: String

    pub let description: String

    pub let thumbnail: AnyStruct{File}
}
```

Display is a basic view that includes the name, description and
thumbnail for an object. Most objects should implement this view.

### Initializer

```cadence
init(name: String, description: String, thumbnail: AnyStruct{File})
```


# Struct `Edition`

```cadence
pub struct Edition {

    pub let name: String?

    pub let number: UInt64

    pub let max: UInt64?
}
```

Optional view for collections that issue multiple objects
with the same or similar metadata, for example an X of 100 set. This
information is useful for wallets and marketplaces.
An NFT might be part of multiple editions, which is why the edition
information is returned as an arbitrary sized array

### Initializer

```cadence
init(name: String?, number: UInt64, max: UInt64?)
```


# Struct `Editions`

```cadence
pub struct Editions {

    pub let infoList: [Edition]
}
```

Wrapper view for multiple Edition views

### Initializer

```cadence
init(_: [Edition])
```


# Struct `ExternalURL`

```cadence
pub struct ExternalURL {

    pub let url: String
}
```

View to expose a URL to this item on an external site.
This can be used by applications like .find and Blocto to direct users
to the original link for an NFT.

### Initializer

```cadence
init(_: String)
```


# Struct Interface `File`

```cadence
pub struct interface File {
}
```

Generic interface that represents a file stored on or off chain. Files
can be used to references images, videos and other media.
## Functions

### `uri()`

```cadence
fun uri(): String
```

---
# Struct `HTTPFile`

```cadence
pub struct HTTPFile {

    pub let url: String
}
```

View to expose a file that is accessible at an HTTP (or HTTPS) URL.

Implemented Interfaces:
  - `File`


### Initializer

```cadence
init(url: String)
```


## Functions

### `uri()`

```cadence
fun uri(): String
```

---
# Struct `IPFSFile`

```cadence
pub struct IPFSFile {

    pub let cid: String

    pub let path: String?
}
```

View to expose a file stored on IPFS.
IPFS images are referenced by their content identifier (CID)
rather than a direct URI. A client application can use this CID
to find and load the image via an IPFS gateway.

Implemented Interfaces:
  - `File`


### Initializer

```cadence
init(cid: String, path: String?)
```


## Functions

### `uri()`

```cadence
fun uri(): String
```
This function returns the IPFS native URL for this file.
Ref: https://docs.ipfs.io/how-to/address-ipfs-on-web/#native-urls

Returns: The string containing the file uri

---
# Struct `License`

```cadence
pub struct License {

    pub let spdxIdentifier: String
}
```

View to represent a license according to https://spdx.org/licenses/
This view can be used if the content of an NFT is licensed.

### Initializer

```cadence
init(_: String)
```


# Struct `Media`

```cadence
pub struct Media {

    pub let file: AnyStruct{File}

    pub let mediaType: String
}
```

View to represent, a file with an correspoiding mediaType.

### Initializer

```cadence
init(file: AnyStruct{File}, mediaType: String)
```


# Struct `Medias`

```cadence
pub struct Medias {

    pub let items: [Media]
}
```

Wrapper view for multiple media views

### Initializer

```cadence
init(_: [Media])
```


# Struct `NFTCollectionData`

```cadence
pub struct NFTCollectionData {

    pub let storagePath: StoragePath

    pub let publicPath: PublicPath

    pub let providerPath: PrivatePath

    pub let publicCollection: Type

    pub let publicLinkedType: Type

    pub let providerLinkedType: Type

    pub let createEmptyCollection: ((): @NonFungibleToken.Collection)
}
```

View to expose the information needed store and retrieve an NFT.
This can be used by applications to setup a NFT collection with proper
storage and public capabilities.

### Initializer

```cadence
init(storagePath: StoragePath, publicPath: PublicPath, providerPath: PrivatePath, publicCollection: Type, publicLinkedType: Type, providerLinkedType: Type, createEmptyCollectionFunction: ((): @NonFungibleToken.Collection))
```


# Struct `NFTCollectionDisplay`

```cadence
pub struct NFTCollectionDisplay {

    pub let name: String

    pub let description: String

    pub let externalURL: ExternalURL

    pub let squareImage: Media

    pub let bannerImage: Media

    pub let socials: {String: ExternalURL}
}
```

View to expose the information needed to showcase this NFT's
collection. This can be used by applications to give an overview and
graphics of the NFT collection this NFT belongs to.

### Initializer

```cadence
init(name: String, description: String, externalURL: ExternalURL, squareImage: Media, bannerImage: Media, socials: {String: ExternalURL})
```


# Struct `NFTView`

```cadence
pub struct NFTView {

    pub let id: UInt64

    pub let uuid: UInt64

    pub let display: Display?

    pub let externalURL: ExternalURL?

    pub let collectionData: NFTCollectionData?

    pub let collectionDisplay: NFTCollectionDisplay?

    pub let royalties: Royalties?

    pub let traits: Traits?
}
```

NFTView wraps all Core views along `id` and `uuid` fields, and is used
to give a complete picture of an NFT. Most NFTs should implement this
view.

### Initializer

```cadence
init(id: UInt64, uuid: UInt64, display: Display?, externalURL: ExternalURL?, collectionData: NFTCollectionData?, collectionDisplay: NFTCollectionDisplay?, royalties: Royalties?, traits: Traits?)
```


# Struct `Rarity`

```cadence
pub struct Rarity {

    pub let score: UFix64?

    pub let max: UFix64?

    pub let description: String?
}
```

View to expose rarity information for a single rarity
Note that a rarity needs to have either score or description but it can
have both

### Initializer

```cadence
init(score: UFix64?, max: UFix64?, description: String?)
```


# Resource Interface `Resolver`

```cadence
pub resource interface Resolver {
}
```

Provides access to a set of metadata views. A struct or
resource (e.g. an NFT) can implement this interface to provide access to
the views that it supports.
## Functions

### `getViews()`

```cadence
fun getViews(): [Type]
```

---

### `resolveView()`

```cadence
fun resolveView(_: Type): AnyStruct?
```

---
# Resource Interface `ResolverCollection`

```cadence
pub resource interface ResolverCollection {
}
```

A group of view resolvers indexed by ID.
## Functions

### `borrowViewResolver()`

```cadence
fun borrowViewResolver(id: UInt64): &{Resolver}
```

---

### `getIDs()`

```cadence
fun getIDs(): [UInt64]
```

---
# Struct `Royalties`

```cadence
pub struct Royalties {

    priv let cutInfos: [Royalty]
}
```

Wrapper view for multiple Royalty views.
Marketplaces can query this `Royalties` struct from NFTs
and are expected to pay royalties based on these specifications.

### Initializer

```cadence
init(_: [Royalty])
```


## Functions

### `getRoyalties()`

```cadence
fun getRoyalties(): [Royalty]
```
Return the cutInfos list

Returns: An array containing all the royalties structs

---
# Struct `Royalty`

```cadence
pub struct Royalty {

    pub let receiver: Capability<&AnyResource{FungibleToken.Receiver}>

    pub let cut: UFix64

    pub let description: String
}
```

View that defines the composable royalty standard that gives marketplaces a
unified interface to support NFT royalties.

### Initializer

```cadence
init(receiver: Capability<&AnyResource{FungibleToken.Receiver}>, cut: UFix64, description: String)
```


# Struct `Serial`

```cadence
pub struct Serial {

    pub let number: UInt64
}
```

View representing a project-defined serial number for a specific NFT
Projects have different definitions for what a serial number should be
Some may use the NFTs regular ID and some may use a different
classification system. The serial number is expected to be unique among
other NFTs within that project

### Initializer

```cadence
init(_: UInt64)
```


# Struct `Trait`

```cadence
pub struct Trait {

    pub let name: String

    pub let value: AnyStruct

    pub let displayType: String?

    pub let rarity: Rarity?
}
```

View to represent a single field of metadata on an NFT.
This is used to get traits of individual key/value pairs along with some
contextualized data about the trait

### Initializer

```cadence
init(name: String, value: AnyStruct, displayType: String?, rarity: Rarity?)
```


# Struct `Traits`

```cadence
pub struct Traits {

    pub let traits: [Trait]
}
```

Wrapper view to return all the traits on an NFT.
This is used to return traits as individual key/value pairs along with
some contextualized data about each trait.

### Initializer

```cadence
init(_: [Trait])
```


## Functions

### `addTrait()`

```cadence
fun addTrait(_: Trait)
```
Adds a single Trait to the Traits view

Parameters:
  - Trait : _The trait struct to be added_

---
# Contract Interface `NonFungibleToken`

```cadence
pub contract interface NonFungibleToken {

    pub var totalSupply: UInt64
}
```

The main NFT contract interface. Other NFT contracts will
import and implement this interface
## Interfaces
    
### `INFT`

```cadence
pub resource interface INFT {

    pub let id: UInt64
}
```
Interface that the NFTs have to conform to
The metadata views methods are included here temporarily
because enforcing the metadata interfaces in the standard
would break many contracts in an upgrade. Those breaking changes
are being saved for the stable cadence milestone

[More...](NonFungibleToken_INFT.md)

---
    
### `Provider`

```cadence
pub resource interface Provider {
}
```
Interface to mediate withdraws from the Collection

[More...](NonFungibleToken_Provider.md)

---
    
### `Receiver`

```cadence
pub resource interface Receiver {
}
```
Interface to mediate deposits to the Collection

[More...](NonFungibleToken_Receiver.md)

---
    
### `CollectionPublic`

```cadence
pub resource interface CollectionPublic {
}
```
Interface that an account would commonly
publish for their collection

[More...](NonFungibleToken_CollectionPublic.md)

---
## Structs & Resources

### `NFT`

```cadence
pub resource NFT {

    pub let id: UInt64
}
```
Requirement that all conforming NFT smart contracts have
to define a resource called NFT that conforms to INFT

[More...](NonFungibleToken_NFT.md)

---

### `Collection`

```cadence
pub resource Collection {

    pub var ownedNFTs: {UInt64: NFT}
}
```
Requirement for the concrete resource type
to be declared in the implementing contract

[More...](NonFungibleToken_Collection.md)

---
## Functions

### `createEmptyCollection()`

```cadence
fun createEmptyCollection(): Collection
```
Creates an empty Collection and returns it to the caller so that they can own NFTs

Returns: A new Collection resource

---
## Events

### `ContractInitialized`

```cadence
pub event ContractInitialized()
```
Event that emitted when the NFT contract is initialized

---

### `Withdraw`

```cadence
pub event Withdraw(id: UInt64, from: Address?)
```
Event that is emitted when a token is withdrawn,
indicating the owner of the collection that it was withdrawn from.

If the collection is not in an account's storage, `from` will be `nil`.

---

### `Deposit`

```cadence
pub event Deposit(id: UInt64, to: Address?)
```
Event that emitted when a token is deposited to a collection.

It indicates the owner of the collection that it was deposited to.

---
# Resource `Collection`

```cadence
pub resource Collection {

    pub var ownedNFTs: {UInt64: NFT}
}
```

Requirement for the concrete resource type
to be declared in the implementing contract

Implemented Interfaces:
  - `Provider`
  - `Receiver`
  - `CollectionPublic`

## Functions

### `withdraw()`

```cadence
fun withdraw(withdrawID: UInt64): NFT
```
Removes an NFT from the collection and moves it to the caller

Parameters:
  - withdrawID : _The ID of the NFT that will be withdrawn_

Returns: The resource containing the desired NFT

---

### `deposit()`

```cadence
fun deposit(token: NFT)
```

---

### `getIDs()`

```cadence
fun getIDs(): [UInt64]
```

---

### `borrowNFT()`

```cadence
fun borrowNFT(id: UInt64): &NFT
```

---
# Resource Interface `CollectionPublic`

```cadence
pub resource interface CollectionPublic {
}
```

Interface that an account would commonly
publish for their collection
## Functions

### `deposit()`

```cadence
fun deposit(token: NFT)
```

---

### `getIDs()`

```cadence
fun getIDs(): [UInt64]
```

---

### `borrowNFT()`

```cadence
fun borrowNFT(id: UInt64): &NFT
```

---

### `borrowNFTSafe()`

```cadence
fun borrowNFTSafe(id: UInt64): &NFT?
```

---
# Resource Interface `INFT`

```cadence
pub resource interface INFT {

    pub let id: UInt64
}
```

Interface that the NFTs have to conform to
The metadata views methods are included here temporarily
because enforcing the metadata interfaces in the standard
would break many contracts in an upgrade. Those breaking changes
are being saved for the stable cadence milestone
## Functions

### `getViews()`

```cadence
fun getViews(): [Type]
```
Function that returns all the Metadata Views implemented by a Non Fungible Token

developers to know which parameter to pass to the resolveView() method.

Returns: An array of Types defining the implemented views. This value will be used by

---

### `resolveView()`

```cadence
fun resolveView(_: Type): AnyStruct?
```
Function that resolves a metadata view for this token.

Parameters:
  - view : _The Type of the desired view._

Returns: A structure representing the requested view.

---
# Resource `NFT`

```cadence
pub resource NFT {

    pub let id: UInt64
}
```

Requirement that all conforming NFT smart contracts have
to define a resource called NFT that conforms to INFT

Implemented Interfaces:
  - `INFT`

# Resource Interface `Provider`

```cadence
pub resource interface Provider {
}
```

Interface to mediate withdraws from the Collection
## Functions

### `withdraw()`

```cadence
fun withdraw(withdrawID: UInt64): NFT
```
Removes an NFT from the resource implementing it and moves it to the caller

Parameters:
  - withdrawID : _The ID of the NFT that will be removed_

Returns: The NFT resource removed from the implementing resource

---
# Resource Interface `Receiver`

```cadence
pub resource interface Receiver {
}
```

Interface to mediate deposits to the Collection
## Functions

### `deposit()`

```cadence
fun deposit(token: NFT)
```
Adds an NFT to the resource implementing it

Parameters:
  - token : _The NFT resource that will be deposited_

---
---
sidebar_position: 1
---
# Flow Non-Fungible Token (NFT) Standard

This standard defines the minimum functionality required to
implement a safe, secure, and easy-to-use non-fungible token
contract on the [Flow blockchain](https://www.onflow.org/).

## What is Cadence?

[Cadence is the resource-oriented programming language](../../../build/guides/smart-contracts/cadence.md)
for developing smart contracts on Flow.

Before reading this standard,
we recommend completing the [Cadence tutorials](https://cadence-lang.org/docs/tutorial/first-steps)
to build a basic understanding of the programming language.

Resource-oriented programming, and by extension Cadence,
provides an ideal programming model for non-fungible tokens (NFTs).
Users are able to store their NFT objects directly in their accounts and transact
peer-to-peer. Learn more in this [blog post about resources](https://medium.com/dapperlabs/resource-oriented-programming-bee4d69c8f8e).

## Core features

The `NonFungibleToken` contract defines the following set of functionality
that must be included in each implementation.

Contracts that implement the `NonFungibleToken` interface are required to implement two resource interfaces:

- `NFT` - A resource that describes the structure of a single NFT.
- `Collection` - A resource that can hold multiple NFTs of the same type.

  Users typically store one collection per NFT type, saved at a well-known location in their account storage.

  For example, all NBA Top Shot Moments owned by a single user are held in a [`TopShot.Collection`](https://github.com/dapperlabs/nba-smart-contracts/blob/master/contracts/TopShot.cdc#L605) stored in their account at the path `/storage/MomentCollection`.

### Create a new NFT collection

Create a new collection using the `createEmptyCollection` function.

This function MUST return an empty collection that contains no NFTs.

Users typically save new collections to a well-known location in their account
and link the `NonFungibleToken.CollectionPublic` interface as a public capability.

```swift
let collection <- ExampleNFT.createEmptyCollection()

account.save(<-collection, to: /storage/ExampleNFTCollection)

// create a public capability for the collection
account.link<&{NonFungibleToken.CollectionPublic}>(
    /public/ExampleNFTCollection,
    target: /storage/ExampleNFTCollection
)
```

### Withdraw an NFT

Withdraw an `NFT` from a `Collection` using the [`withdraw`](https://github.com/onflow/flow-nft/blob/master/contracts/ExampleNFT.cdc#L36-L42) function.
This function emits the [`Withdraw`](https://github.com/onflow/flow-nft/blob/master/contracts/ExampleNFT.cdc#L12) event.

```swift
let collectionRef = account.borrow<&ExampleNFT.Collection>(from: /storage/ExampleNFTCollection)
    ?? panic("Could not borrow a reference to the owner's collection")

// withdraw the NFT from the owner's collection
let nft <- collectionRef.withdraw(withdrawID: 42)
```

### Deposit an NFT

Deposit an `NFT` into a `Collection` using the [`deposit`](https://github.com/onflow/flow-nft/blob/master/contracts/ExampleNFT.cdc#L46-L57) function.
This function emits the [`Deposit`](https://github.com/onflow/flow-nft/blob/master/contracts/ExampleNFT.cdc#L13) event.

This function is available on the `NonFungibleToken.CollectionPublic` interface,
which accounts publish as public capability.
This capability allows anybody to deposit an NFT into a collection
without accessing the entire collection.

```swift
let nft: ExampleNFT.NFT

// ...

let collection = account.getCapability(/public/ExampleNFTCollection)
    .borrow<&{NonFungibleToken.CollectionPublic}>()
    ?? panic("Could not borrow a reference to the receiver's collection")

collection.deposit(token: <-nft)
```

#### ⚠️ Important

In order to comply with the deposit function in the interface,
an implementation MUST take a `@NonFungibleToken.NFT` resource as an argument.
This means that anyone can send a resource object that conforms to `@NonFungibleToken.NFT` to a deposit function.
In an implementation, you MUST cast the `token` as your specific token type before depositing it or you will
deposit another token type into your collection. For example:

```swift
let token <- token as! @ExampleNFT.NFT
```

### List NFTs in an account

Return a list of NFTs in a `Collection` using the [`getIDs`](https://github.com/onflow/flow-nft/blob/master/contracts/ExampleNFT.cdc#L59-L62) function.

This function is available on the `NonFungibleToken.CollectionPublic` interface,
which accounts publish as public capability.

```swift
let collection = account.getCapability(/public/ExampleNFTCollection)
    .borrow<&{NonFungibleToken.CollectionPublic}>()
    ?? panic("Could not borrow a reference to the receiver's collection")

let ids = collection.getIDs()
```

## NFT Metadata

NFT metadata is represented in a flexible and modular way using
the [standard proposed in FLIP-0636](https://github.com/onflow/flips/blob/main/application/20210916-nft-metadata.md).

When writing an NFT contract,
you should implement the [`MetadataViews.Resolver`](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L3-L6)interface,
which allows your NFT to implement one or more metadata types called views.

Each view represents a different type of metadata,
such as an on-chain creator biography or an off-chain video clip.
Views do not specify or require how to store your metadata, they only specify
the format to query and return them, so projects can still be flexible with how they store their data.

### How to read metadata

This example shows how to read basic information about an NFT
including the name, description, image and owner.

**Source: [get_nft_metadata.cdc](https://github.com/onflow/flow-nft/blob/master/scripts/get_nft_metadata.cdc)**

```swift
import ExampleNFT from "..."
import MetadataViews from "..."

// ...

// Get the regular public capability
let collection = account.getCapability(ExampleNFT.CollectionPublicPath)
    .borrow<&{ExampleNFT.ExampleNFTCollectionPublic}>()
    ?? panic("Could not borrow a reference to the collection")

// Borrow a reference to the NFT as usual
let nft = collection.borrowExampleNFT(id: 42)
    ?? panic("Could not borrow a reference to the NFT")

// Call the resolveView method
// Provide the type of the view that you want to resolve
// View types are defined in the MetadataViews contract
// You can see if an NFT supports a specific view type by using the `getViews()` method
if let view = nft.resolveView(Type<MetadataViews.Display>()) {
    let display = view as! MetadataViews.Display

    log(display.name)
    log(display.description)
    log(display.thumbnail)
}

// The owner is stored directly on the NFT object
let owner: Address = nft.owner!.address!

// Inspect the type of this NFT to verify its origin
let nftType = nft.getType()

// `nftType.identifier` is `A.e03daebed8ca0615.ExampleNFT.NFT`
```

### How to implement metadata

The [example NFT contract](https://github.com/onflow/flow-nft/blob/master/contracts/ExampleNFT.cdc) shows how to implement metadata views.

### List of common views

| Name        | Purpose                                    | Status      | Source                                                                                                    |
| ----------- | ------------------------------------------ | ----------- | --------------------------------------------------------------------------------------------------------- |
| `Display`   | Return the basic representation of an NFT. | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L35-L70)   |
| `HTTPFile`  | A file available at an HTTP(S) URL.        | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L80-L92)   |
| `IPFSFile`  | A file stored in IPFS.                     | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L94-L133)  |
| `Royalties` | An array of Royalty Cuts for a given NFT.  | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L136-L208) |

## Royalty View

The `MetadataViews` contract also includes [a standard view for Royalties](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L136-L208).

This view is meant to be used by 3rd party marketplaces to take a cut of the proceeds of an NFT sale
and send it to the author of a certain NFT. Each NFT can have its own royalty view:

```cadence
pub struct Royalties {

    /// Array that tracks the individual royalties
    access(self) let cutInfos: [Royalty]
}
```

and the royalty can indicate whatever fungible token it wants to accept via the type of the generic `{FungibleToken.Reciever}` capability that it specifies:

```cadence
pub struct Royalty {
    /// Generic FungibleToken Receiver for the beneficiary of the royalty
    /// Can get the concrete type of the receiver with receiver.getType()
    /// Recommendation - Users should create a new link for a FlowToken receiver for this using `getRoyaltyReceiverPublicPath()`,
    /// and not use the default FlowToken receiver.
    /// This will allow users to update the capability in the future to use a more generic capability
    pub let receiver: Capability<&AnyResource{FungibleToken.Receiver}>

    /// Multiplier used to calculate the amount of sale value transferred to royalty receiver.
    /// Note - It should be between 0.0 and 1.0
    /// Ex - If the sale value is x and multiplier is 0.56 then the royalty value would be 0.56 * x.
    ///
    /// Generally percentage get represented in terms of basis points
    /// in solidity based smart contracts while cadence offers `UFix64` that already supports
    /// the basis points use case because its operations
    /// are entirely deterministic integer operations and support up to 8 points of precision.
    pub let cut: UFix64
}
```

If someone wants to make a listing for their NFT on a marketplace,
the marketplace can check to see if the royalty receiver accepts the seller's desired fungible token
by checking the concrete type of the reference.
If the concrete type is not the same as the type of token the seller wants to accept,
the marketplace has a few options.
They could either get the address of the receiver by using the
`receiver.owner.address` field and check to see if the account has a receiver for the desired token,
they could perform the sale without a royalty cut, or they could abort the sale
since the token type isn't accepted by the royalty beneficiary.

You can see example implementations of royalties in the `ExampleNFT` contract
and the associated transactions and scripts.

=======
| Name       | Purpose                                    | Status      | Source                                                                                                   |
| ----------- | ------------------------------------------ | ----------- | -------------------------------------------------------------------------------------------------------- |
| `Display`   | Return the basic representation of an NFT. | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L35-L70)  |
| `HTTPFile`  | A file available at an HTTP(S) URL.        | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L80-L92)  |
| `IPFSFile`  | A file stored in IPFS.                     | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L94-L133) |
| `Royalties` | An array of Royalty Cuts for a given NFT.  | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L136-L208) |
| `Edition`  | Return information about one or more editions for an NFT. | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L246-L266) |
| `NFTCollectionData` | Provides storage and retrieval information of an NFT | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L243-L299) |
| `NFTCollectionDisplay` | Returns the basic representation of an NFT's Collection.  | Implemented | [MetadataViews.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L301-L328) |

#### Important Royalty Instructions for Royalty Receivers

If you plan to set your account as a receiver of royalties, you'll likely want to be able to accept
as many token types as possible. This won't be immediately possible at first, but eventually,
we will also design a contract that can act as a sort of switchboard for fungible tokens.
It will accept any generic fungible token and route it to the correct vault in your account. 
This hasn't been built yet, but you can still set up your account to be ready for it in the future.
Therefore, if you want to receive royalties, you should set up your account with the
[`setup_account_to_receive_royalty.cdc` transaction](https://github.com/onflow/flow-nft/blob/c13545c37be4d1e63605c5d76340fb188923d997/transactions/setup_account_to_receive_royalty.cdc).

This will link generic public path from `MetadataViews.getRoyaltyReceiverPublicPath()`
to your chosen fungible token for now. Then, use that public path for your royalty receiver
and in the future, you will be able to easily update the link at that path to use the
fungible token switchboard instead.

## How to propose a new view

Please open a pull request to propose a new metadata view or changes to an existing view.

## Feedback

As Flow and Cadence are still new,
we expect this standard to evolve based on feedback
from both developers and users.

We'd love to hear from anyone who has feedback. For example:

- Are there any features that are missing from the standard?
- Are the current features defined in the best way possible?
- Are there any pre and post conditions that are missing?
- Are the pre and post conditions defined well enough? Error messages?
- Are there any other actions that need an event defined for them?
- Are the current event definitions clear enough and do they provide enough information?
- Are the variable, function, and parameter names descriptive enough?
- Are there any openings for bugs or vulnerabilities that we are not noticing?

Please create an issue in this repository if there is a feature that
you believe needs discussing or changing.

## Comparison to other standards on Ethereum

This standard covers much of the same ground as ERC-721 and ERC-1155,
but without most of the downsides.

- Tokens cannot be sent to contracts that don't understand how to use them, because an account needs to have a `Receiver` or `Collection` in its storage to receive tokens.
- If the recipient is a contract that has a stored `Collection`, the tokens can just be deposited to that Collection without having to do a clunky `approve`, `transferFrom`.
- Events are defined in the contract for withdrawing and depositing, so a recipient will always be notified that someone has sent them tokens with their own deposit event.
- This version can support batch transfers of NFTs. Even though it isn't explicitly defined in the contract, a batch transfer can be done within a transaction by just withdrawing all the tokens to transfer, then depositing them wherever they need to be, all atomically.
- Transfers can trigger actions because users can define custom `Receivers` to execute certain code when a token is sent.
- Easy ownership indexing: rathing than iterating through all tokens to find which ones you own, you have them all stored in your account's collection and can get the list of the ones you own instantly.

## How to test the standard

If you want to test out these contracts, we recommend either testing them
with the [Flow Playground](https://play.onflow.org)
or with the [Visual Studio Code Extension](../../../tools/vscode-extension/index.mdx).

The steps to follow are:

1. Deploy `NonFungibleToken.cdc`
2. Deploy `ExampleNFT.cdc`, importing `NonFungibleToken` from the address you deployed it to.

Then you can experiment with some of the other transactions and scripts in `transactions/`
or even write your own. You'll need to replace some of the import address placeholders with addresses that you deploy to, as well as some of the transaction arguments.

## Running automated tests

You can find automated tests in the `lib/go/test/nft_test.go` file. It uses the transaction templates that are contained in the `lib/go/templates/templates.go` file. 

Tests have also been written in JavaScript and can be found in `lib/js/test/tests/nft_test.js`. Similar to the tests written in Go, test helper functions can be found in `lib/js/test/templates/` directory.

Entering the `make test` command from the root directory will run both Go and JavaScript test suites. If you'd like to run just one test suite, you can run `make test` from the test suite's `test/` directory (e.g. running `make test` from `lib/js/test` will run just your JavaScript tests).

## Bonus features

### NFT Forwarding

While this utility contract is not a standard, it is a demonstration of how an account could be configured to forward NFTs to a specified forwarding recipient's collection.

The NFTForwarder resource itself can be referenced like any `NonFungibleToken.Receiver` resource, allowing a sender to deposit NFT's as they usually would. However, `deposit()` as implemented in this resource forwards the deposited NFT to the designated recipient's collection.

Several transactions are included in this repo to demonstrate how to interact with the `NFTForwarder` resource. Those are:
* `create_forwarder.cdc` - Creates the NFTForwarder resource and links the capability to `ExampleNFT.CollectionPublicPath`, where an Example NFT Collection would expect to be found.
* `transfer_nft_to_receiver.cdc` - Transfers an NFT to the forwarder by way of `deposit()` found in NonFungibleToken.Receiver` interface. By construction of the NFTForwarder resource, the NFT deposited by the signer is further forwarded to the forwarding recipient designated in the NFTForwarder resource.
* `change_forwarder_recipient.cdc` - Changes the designated recipient collection to which NFT will be forwarded.
* `unlink_forwarder_link_collection.cdc` - Unlinks the forwarder resource from `ExampleNFT.CollectionPublicPath`, restoring the accounts CollectionPublic capability.

**(These could each be defined as a separate interface and standard and are probably not part of the main standard) They are not implemented in this repository yet**

10- Withdrawing tokens from someone else's Collection by using their `Provider` reference.

- approved withdraw event
- Providing a resource that only approves an account to withdraw a specific amount per transaction or per day/month/etc.
- Returning the list of tokens that an account can withdraw for another account.
- Reading the balance of the account that you have permission to send tokens for
- Owner is able to increase and decrease the approval at will, or revoke it completely
  - This is much harder than anticipated

11 - Standard for Composability/Extensibility

12 - Minting a specific amount of tokens using a specific minter resource that an owner can control

- tokens minted event
- Setting a cap on the total number of tokens that can be minted at a time or overall
- Setting a time frame where this is allowed

13 - Burning a specific amount of tokens using a specific burner resource that an owner controls

- tokens burnt event
- Setting a cap on the number of tokens that can be burned at a time or overall
- Setting a time frame where this is allowed

14 - Pausing Token transfers (maybe a way to prevent the contract from being imported? probably not a good idea)

15 - Cloning the token to create a new token with the same distribution

## License

The works in these files:

- [ExampleNFT.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/ExampleNFT.cdc)
- [NonFungibleToken.cdc](https://github.com/onflow/flow-nft/blob/master/contracts/NonFungibleToken.cdc)

are under the [Unlicense](https://github.com/onflow/flow-nft/blob/master/LICENSE).

## Deploying updates

### Testnet

```sh
TESTNET_PRIVATE_KEY=xxxx flow project deploy --update --network testnet
```
---
title: Flow Core Contracts
description: The smart contracts that power the Flow protocol
sidebar_title: Core Protocol Smart Contracts
sidebar_position: 3
sidebar_custom_props:
  icon: 📝
  description: Explore the foundational contracts driving the Flow blockchain and learn how to utilize these vital building blocks for your own smart contract development.
---

Flow relies on a set of core contracts that define key portions of the
Flow protocol.

These contracts control the following:

- Standard fungible token behavior. ([FungibleToken](./02-fungible-token.md))
- Flow Protocol Token. ([FlowToken](./03-flow-token.md))
- Flow Service Account. ([ServiceAccount](./04-service-account.md))
- Account, transaction and storage fee payments. ([FlowFees and FlowStorageFees](./05-flow-fees.md))
- Staking and delegation ([FlowIDTableStaking](./06-staking-contract-reference.md))
- Epochs ([FlowEpoch](./07-epoch-contract-reference.md))

There are other important contracts that aren't part of the core protocol
but are nevertheless important to developers on Flow:

- Standard Non-Fungible Token Behavior. ([NonFungibleToken](./08-non-fungible-token.md))
- NFT Metadata Standard. ([MetadataViews](./09-nft-metadata.md))
- Staking Collection. ([StakingCollection](./11-staking-collection.md))
- NFT Storefronts. ([NFTStorefront](./10-nft-storefront.md))
---
title: Flow Mainnet
sidebar_position: 1
description: Guide to mainnet access
---

## Accessing Flow mainnet

The Flow Mainnet is available for access at this URL:

```
access.mainnet.nodes.onflow.org:9000
```

For example, to access the network using the [Flow Go SDK](https://github.com/onflow/flow-go-sdk):

```go
import "github.com/onflow/flow-go-sdk/client"

func main() {
  flowAccessAddress := "access.mainnet.nodes.onflow.org:9000"
  flowClient, _ := client.New(flowAccessAddress, grpc.WithInsecure())
  // ...
}
```

## Account creation

You can follow the [Flow Port account creation steps](../../references/run-and-secure/nodes/flow-port/index.md#blocto) to create a new mainnet account.

If you prefer watching a video, check out this tutorial:

<iframe
  width="560"
  height="315"
  src="https://www.youtube-nocookie.com/embed/vXui7uO4cIQ"
  title="YouTube video player"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowfullscreen
></iframe>

## Generating a non-custodial account

A non-custodial account will make sure you are the only one holding the keys to your account.

You can follow the following steps to add a non-custodial account:

First, generate a new key pair with the [Flow CLI](https://github.com/onflow/flow-cli):

```sh
> flow keys generate --network=mainnet

🔴️ Store private key safely and don't share with anyone!
Private Key      5b438...
Public Key       1bdc5...
```

> **Note**: By default, this command generates an ECDSA key pair on the P-256 curve. Keep in mind the CLI is intended for development purposes only and is not recommended for production use. Handling keys using a Key Management Service is the best practice.

Take a note of the public key and go back to Flow Port. Open the ["Create a new account" page](https://port.onflow.org/transaction?hash=a0a78aa7821144efd5ebb974bb52ba04609ce76c3863af9d45348db93937cf98&showcode=false&weight=1000&halg=3).

On the page, enter your public key from the CLI, ensure the hash algorithm is set to `SHA3_256` and the weight is set to `1000`. Finally, check the box confirming correctness and hit 'Submit'.

> **Important**: Your account needs to have at least 0.002 FLOW for the account creation. More details can be found [in this guide](../../build/basics/fees.md#storage).

Once the transaction is sealed, you should scroll down to the events section and locate the `flow.AccountCreated` event with the newly generated address.

![flow-port-sealed](port-sealed-tx.png)

Make sure to take a note of the address. If you want to verify the public key for this address, you can visit [flow-view-source](https://flow-view-source.com/).

## Important Mainnet Smart Contract Addresses

You can review [all available core contracts](../../references/core-contracts/index.md) deployed to the mainnet to identify which ones you want to import.---
title: Flow Testnet
sidebar_position: 2
description: Guide to Testnet access
---

## About Flow Testnet
Flow Testnet is Flow's official testing and development network. It is intended to provide a staging and testing environment for dApp developers. 
It aims to balance similarity with Mainnet with being a productive development environment, resulting in the following key differences:
- Testnet has significantly fewer validator nodes, resulting in a faster block rate compared to Mainnet
- Testnet is configured with shorter epochs (about 12 hours, compared to 7 days on Mainnet)
- Testnet receives software upgrades up to 2 weeks before Mainnet

## Accessing Flow Testnet

Flow Testnet is available for access at this URL:

```
access.devnet.nodes.onflow.org:9000
```

For example, to access the network using the [Flow Go SDK](https://github.com/onflow/flow-go-sdk):

```go
import "github.com/onflow/flow-go-sdk/client"

func main() {
  flowAccessAddress := "access.devnet.nodes.onflow.org:9000"
  flowClient, _ := client.New(flowAccessAddress, grpc.WithInsecure())
  // ...
}
```

### Generating Testnet key pair

You can generate a new key pair with the [Flow CLI](https://github.com/onflow/flow-cli) as follows:

```sh
> flow keys generate

🙏 If you want to create an account on Testnet with the generated keys use this link:
https://testnet-faucet.onflow.org/?key= cc1c3d72...


🔴️ Store private key safely and don't share with anyone!
Private Key      246256f3...
Public Key       cc1c3d72...
```

**Note: By default, this command generates an ECDSA key pair on the P-256 curve. Keep in mind, the CLI is intended for development purposes only and is not recommended for production use. Handling keys using a Key Management Service is the best practice.**

## Account creation and token funding requests

Accounts and tokens for testing can be obtained through the [testnet faucet](https://testnet-faucet.onflow.org/). If you generated the keypair through the CLI, you can click on the URL provided to create an account and request testnet FLOW tokens.

## Important smart contract addresses

You can review [all available core contracts](../../references/core-contracts/index.md) deployed to the Testnet to identify which ones you want to import.
---
title: Flow Networks
sidebar_position: 2
sidebar_custom_props:
  description: Develop on Flow Testnet and deploy to Mainnet when production ready.
  icon: 🌐
---

# Flow Networks

Other than the Flow mainnet network, Flow testnet can be used to test applications and contracts before deployment to mainnet.

During a round of network upgrade, Flow testnet is updated first. Hence, testnet can be used to test against the latest node software, Cadence and core contract changes which will eventually be available to mainnet.

## How to access these networks?

[Flow Testnet](./accessing-testnet.md)
[Flow Mainnet](./accessing-mainnet.md)
---
title: Governance
description: Learn about Flow's governance model and how it's empowering our community of users and builders.
sidebar_position: 5
sidebar_custom_props:
  icon: 🏛️
---

## Participation

Participating in the governance process can take three forms:

- Being elected as a council member on the governing committee
- Putting forth a proposal for the community to vote on
- Staking to receive voting rights

Votes will be weighted based on locked tokens. All tokens staked by node operators will be eligible for voting, but other users can lock up their tokens to be given voting power. Anyone will be able to stake a Flow token to vote on issues (even if they aren’t participating as a staked node).

## Token Holder Rights

Tokens may be staked for operation or governance rights which gives holders the right to participate in running a node and/or to participate in public votes.

## Process

Proposals can be brought forward on a public forum where they will be evaluated by the governing committee. All decisions are made publicly and any stakeholder has the opportunity to organize grassroots action to veto specific decisions or to vote in or remove council members.

To ensure the progress of the network, the elected council first assesses the proposal and selects an answer they agree to be the "default choice". Voters can freely vote how they choose, but having a well-considered default allows forward progress without being blocked by passive participants. All decisions are voted on by all participants and decisions made by the council must be ratified by a public vote on the network.

### Timing

Vote outcomes and upcoming votes will be published every Friday by 7am PT. All upcoming votes are available for review and voting for at least two weeks following their publication.

## Protocol Set Parameters

The following parameters will be set on the network on day 1 and will not be candidates for a public vote when the network first launches.

- The staking ratio preserved between each node type
- The maximum inflation rate
- The role of FLOW as the main reserve asset for collateralized secondary tokens (e.g. stablecoins)
- The mechanism through which transaction inclusion, computation, and storage fees are determined and paid for

## Early Governance of the Protocol

Once governance is enabled, the community can participate in the following:

- Protocol upgrades, including things like: - the consensus algorithm - the low-level network communication structure - the execution environment - the number of seats available for each node type
- Management of Ecosystem Development Fund, including: - issuance of grants - bug & feature bounties
- Selecting council members
- Committee budgets for each of the operational arms of the Foundation, including the executive, technical, operational, legal, pricing, financial, and marketing branches.
- Management of legal affairs, including: - enforcing license and patent infringements - issuing takedown notices and copyright infringement - freezing accounts if illegal activity occurs - updating the community, security, contribution policies

During the Bootstrapping Phase, anyone may apply online to be set as a Validator by the Company. Approved Validators must then Stake a fixed minimum of FLOWs based on Validator type. Other FLOW holders may become “Delegators” when they dedicate or “Delegate” their FLOWs to approved Node Operators as a signal that they believe that Validator to be an effective and honest participant of the network. Staking and Delegation features are already enabled as of the Effective Date.

Each Validator makes an individual decision of which Protocol Version they choose to use. Since the value of blockchain networks is primarily due to the collectively verified execution state, there is a strong incentive for Validators to choose a Protocol Version that is compatible with the Protocol Version selected by the majority of other Validators. As a practical matter, the Protocol Version chosen by the overwhelming majority of Validators is likely to be the most recent Protocol Version produced and recommended by the Core Team, provided the proposed changes are not contentious. However, if a significant fraction of the community disagrees with any aspect of the most recent Protocol Version, they can band together to use a previous Protocol Version, or some other Protocol Version defined independently from the Core Team. This process of a “contentious forking” is rare, but does have several precedents in other networks (REF: Ethereum Classic, Bitcoin Cash).

The process by which the Core Team chooses the updates for each new Protocol Version follows the open process described above, using GitHub as an open discussion platform to gauge the priorities and needs of the entire Flow ecosystem. The proposed changes by the Core Team will be announced and discussed well before they are implemented, and any community member can propose their own changes or contribute code updates to implement any proposed changes. The details of a new Protocol Version are publicly available no less than 14 days before that version is formally recommended for use by Validators (a “Release”), with the complete implementation source code visible for no less than 7 days before a Release.
---
title: References
sidebar_position: 1
---

# References
Quick references to very helpful parts of developer documentation. Languages to code up your applications and Network access points to pull blockchain data form Flow.
## Languages

- [HTTP API](/http-api) - Access node API
- [FCL JS](../tools/clients/fcl-js/api.md) - Flow Client Library (javascript and typescript)
- Flow SDKs
  - [FCL SDK](../tools/clients/fcl-js/sdk-guidelines.mdx) - Flow Client Library SDK
  - [Flow Go SDK](../tools/clients/flow-go-sdk/index.mdx) - Golang Flow Client SDK
  - [Flow Unity SDK](https://unity-flow-sdk-api-docs.vercel.app/) - For gaming use the Unity SDK
- [Cadence](https://cadence-lang.org/docs/language/functions) - Flow blockchain Smart Contract language, Cadence

## Network
Get Flow blockchain data from Access Nodes, both REST and gRPC endpoints are available. Get the current status of mainnet and testnet networks.

- [Flow Access API](./run-and-secure/nodes/access-api.mdx)
  - [Mainnet](./flow-networks/accessing-mainnet.md): `access.mainnet.nodes.onflow.org:9000`
  - [Testnet](./flow-networks/accessing-testnet.md): `access.devnet.nodes.onflow.org:9000`
- [Status Page](https://status.onflow.org/) - Network status page

---
title: Operator FAQ
---

# Operator FAQ

### Can anybody run a node? What is the approval process?

Anyone can run an [observer node](./observer-node.mdx).

Very soon, Access nodes too will be permissionless and anyone will be able to run one.

For the other node types, individuals can go through an application process that involves asking about their background and experience contributing to decentralized projects. To pursue an application, please visit [the Flow website here to apply](https://www.onflow.org/node-validators).

Pending approval, new node operators will be onboarded and invited to join a webinar to meet the team and share more about how they’ll grow the community. Node Operators are invited to join and participate in Flow's Node Validator Discord channel for setup questions and network announcements.

In the long-term, anyone can run a node validator on Flow.

### How do I generate keys?

Please follow the instructions provided here: [Generate Your Node Keys](./node-bootstrap.mdx#generating-your-node-id)

### How do I check on the status of my node?

Please follow the instructions provided here: [Monitoring nodes](./monitoring-nodes.mdx)

### Can I bootstrap and run a node at any time?

Flow allows nodes to join/leave the network each time a new epoch begins (roughly once per week). 
See [Staking & Epochs](../staking/index.md#epochs) for general information and [Node Setup](./node-bootstrap.mdx#timing) for a guide to running a new node.

### Would it hurt the network to have a node that constantly spins up and down?

All staked nodes except access nodes, have to be online at all time. A staked node, other than an access node, which is not online can cause severe degradation of network performance and will be subjected to slashing of rewards.
A way to prevent this is to check your equipment meets Flow's [recommended requirements](./node-setup.mdx#hardware-requirements), periodically checking for updates and announcements in Discord but also using a node monitoring system for when your node does go offline.

### Does Flow has a regular schedule for Sporks?

Yes, see [Upcoming Sporks](./upcoming-sporks.mdx) for the latest schedule. Currently, Flow has a Mainnet Spork and a Testnet Spork roughly every two months.

### How do I update the Node Software?

One of the reasons for a [spork](./spork.mdx) is to make sure all nodes update to the latest software version. Hence, you should have the latest software update as long as you are participating in each spork.
However, if we do release any software update in between a Spork (e.g. an emergency patch) we will announce it on Discord.

### Is there any way to know if a node is currently online?

To verify if a node is online, please [setup metrics](./FAQ.md#how-do-i-check-on-the-status-of-my-node) for the node.

### Can I migrate a node to a new machine?

Yes, as long as you retain the `boostrap` information which includes the node staking key, networking key, IP address and port from the old node to the new.
More on this [here](./node-migration.mdx)

### Where can I find how many nodes are currently running Flow?

If you are running a node, then you most definitely have this information on your node in the file `<your bootstrap dir>/public-root-information/node-infos.pub.json`. If you are not running a node, you can find this information by using a Cadence script to query the [Staking Smart Contract](../../../references/core-contracts/06-staking-contract-reference.md) (or check [Flowdiver](https://flowdiver.io/staking/overview))

### Why do I need to update my node's ulimit?

Flow nodes create network connections to other nodes on the network to participate in the protocol. The node's operating system represents
these connections as file descriptors, and uses soft and hard limits to control the number of open files. The node software uses these limits
to manage how many connections it will open and accept from other nodes. If the limit is too low, the node will not be able to communicate
with its peers, preventing it from functioning properly.
{
  "label": "Node Operators",
  "position": 6
}---
title: Setting Up a Flow Access Node
sidebar_label: Access Node Setup
---

This guide is for running a permissonless Access node on Flow. If you are planning to run a different type of staked node then see [node bootstrap](./node-bootstrap.mdx).

Permissionless Access nodes allow any operator to run a Flow Access node.
Unlike the other staked nodes, a permissionless access node does not have to be approved by the service account before it can join the network, hence the term "permissionless". The goal is to make all node types permissionless and this is the first step towards achieving that goal.

## Who should run a Permissionless Access node?
dApp developers can choose to run their own private permissionless access node and move away from using the community access nodes. This will also allow them to not be subjected to the API rate limits of the public access nodes.

Node operators can also run their own permissionless access node and provide access to that node as a service.

Chain analytics, audit and exploration applications can run such an access node and do not have to rely on third parties for the state of the network.


## Timing

New nodes are able to join the network each time a new epoch begins.
An epoch is a period of time (approximately one week) when the node operators in the network are constant.
At epoch boundaries, newly staked node operators are able to join the network and existing node operators which have unstaked may exit the network.
You can read more about epochs [here](../staking/03-schedule.mdx).


In order to join the network at epoch N+1, the access node **must** be registered with at least 100 FLOW staked prior to the end of epoch N's Staking Auction Phase.

Currently on mainnet, the staking auction starts every Wednesday at around 20:00 UTC and ends on the next Wednesday at around 12:00 UTC. 
Since this deadline may shift slightly from epoch to epoch, we recommend the node be staked by _Wednesday, 8:00 UTC_ to be able to join the network in the next epoch.

Confirmation of a new node's inclusion in epoch N+1 is included in the [`EpochSetup` event](../staking/05-epoch-scripts-events.md#epochsetup).


![Flow Epoch Schedule](https://storage.googleapis.com/flow-resources/documentation-assets/epoch-startup-order.png)

## Limitations
This is a preliminary implementation of the full permissionless node operation feature and there will be exactly **five** slots in total that will be opened for access nodes.
If there are more than five staked candidate access nodes at the end of the staking phase of the current epoch which ends on Wednesday, 15th Feb, five of those will be selected by an on-chain random selection process and no other permissionless ANs can join until others unstake in a future epoch.

More slots will be opened in the future.

Support for unlimited access nodes requires staking auctions to be implemented, which is still an upgrade planned for the future.

To summarize,

|  **Date**  |  **Time** | **Epoch** |     **Epoch Phase**    |                                                     |
|:----------:|:---------:|:---------:|:----------------------:|:---------------------------------------------------:|
| 02/08/2023 | 20:00 UTC | 63         | Staking auction starts | Stake your access nodes                             |
| 02/15/2023 | 08:00 UTC | 63         | Staking auction ends   | No more access nodes can be staked for epoch 64    |
| 02/15/2023 | 20:00 UTC | 64       | Epoch n+1 starts       | 5 randomly chosen access nodes can join the network |

> Please ensure that you have staked the access node by **15th Feb, 2023 Wednesday 08:00 UTC** if you wish to run the node in the next epoch.

## How to run a Permissionless Access node?

> Note: To run an access node you will need to provision a machine or virtual machine to run your node software. Please follow the [node-provisioning](./node-provisioning.mdx) guide for it.
You can provision the machine before or after your node has been chosen.

At a high level, to run a permissionless Access node, you will have to do the following steps:
1. Generate the node identity (private and public keys, node ID etc.).
2. Stake the node with 100 FLOW by the end of the staking phase of the current epoch (see [timing](#timing)) by providing the node information generated in step 1.
3. You can verify if your node ID was selected by the on-chain random selection process on Wednesday at around 20:00 UTC when the next epoch starts.
4. If your node ID was selected, you can provision and start running the node. If your node wasn't selected, your tokens will have been refunded to your unstaked bucket in the staking smart contract. When the next epoch begins, you can try committing tokens again in a future epoch to get a new spot.

Following is a detail explanation of these four steps.
If you want to run multiple access nodes, you will have to run through these steps for each node.

## Step  1 - Generate node information

### Download the Bootstrapping Kit

```shell
curl -sL -O storage.googleapis.com/flow-genesis-bootstrap/boot-tools.tar
tar -xvf boot-tools.tar
```

```shell CheckSHA256
sha256sum ./boot-tools/bootstrapcmd
a06e3e9b2443c6755214150e9e101b70dd48ae30ffcfcbbcc471ba430cb104bf  ./boot-tools/bootstrapcmd
```

> If you have downloaded the bootstrapping kit previously, ensure the SHA256 hash for it still matches. If not, re-download to ensure you are using the most up-to-date version.

### Generate Your Node Identity

```shell
#########################################################
# Generate Keys
$ mkdir ./bootstrap
# YOUR_NODE_ADDRESS: FQDN associated to your instance
$ ./boot-tools/bootstrapcmd key --address "<YOUR_NODE_ADDRESS_GOES_HERE>:3569" --role access -o ./bootstrap
```

```shell Example
$./boot-tools/bootstrapcmd key --address "flowaccess.mycompany.com:3569" --role access  -o ./bootstrap
<nil> DBG will generate networking key
<nil> INF generated networking key
<nil> DBG will generate staking key
<nil> INF generated staking key
<nil> DBG will generate db encryption key
<nil> INF generated db encryption key
<nil> DBG assembling node information address=flowaccess.mycompany.com:3569
<nil> DBG encoded public staking and network keys networkPubKey=f493a74704f6961ae7903e062ecd58d990672858eff99aece7bfbccf3aa02de8f1a624ecbf21a01e8b2f4a5854c231fbe218edd7762a34fea881f3958a215305 stakingPubKey=ae8dcf81f3a70d72036b7ba2c586ed37ed0eb82b9c0a4aab998a8420f98894f94c14f84fa716e93654d3940fc0c8ff4d19b504c90a5b4918b28f421e9d3659dc2b7e246025ebeffea0d83cceefe315d7ed346dbe412fdac51b64997d97d29f7e
<nil> INF wrote file bootstrap/public-root-information/node-id
<nil> INF wrote file bootstrap/private-root-information/private-node-info_e737ec6efbd26ef43bf676911cdc5a11ba15fc6562d05413e6589fccdd6c06d5/node-info.priv.json
<nil> INF wrote file bootstrap/private-root-information/private-node-info_e737ec6efbd26ef43bf676911cdc5a11ba15fc6562d05413e6589fccdd6c06d5/secretsdb-key
<nil> INF wrote file bootstrap/public-root-information/node-info.pub.e737ec6efbd26ef43bf676911cdc5a11ba15fc6562d05413e6589fccdd6c06d5.json

$tree ./bootstrap/
./bootstrap/
├── private-root-information
│        └── private-node-info_e737ec6efbd26ef43bf676911cdc5a11ba15fc6562d05413e6589fccdd6c06d5
│        ├── node-info.priv.json
│        └── secretsdb-key
└── public-root-information
    ├── node-id
    └── node-info.pub.e737ec6efbd26ef43bf676911cdc5a11ba15fc6562d05413e6589fccdd6c06d5.json

3 directories, 4 files
```

> ⚠️ _Use a fully qualified domain name for the network address. Please also include the port number in the network address e.g. `flowaccess.mycompany.com:3569`_

> ⚠️ _Do not include in `http://` in the network address._

> If you would like to stake multiple access nodes, please ensure you generate a unique identity for each node.

Your node identity has now been generated. Your <b>node ID</b> can be found in the file `./bootstrap/public-root-information/node-id`.

```shell Example
$cat ./bootstrap/public-root-information/node-id
e737ec6efbd26ef43bf676911cdc5a11ba15fc6562d05413e6589fccdd6c06d5
```

> All your private keys should be in the `bootstrap` folder created earlier. Please take a back up of the entire folder.

## Step  2 - Stake the node

You need to now register the node on chain by staking the node via [Flow Port](https://port.onflow.org/).

[Here](../nodes/flow-port/staking-guide.md) is a guide on how to use Flow port if you are not familiar with it.
If you are staking via a custody provider or would like to directly submit a staking transaction instead follow this [guide](../staking/index.md#how-do-i-stake).

Fund you Flow account with at least 100.01 FLOW tokens, which covers the required stake plus the storage deposit.

On Flow port, choose `Stake and Delegate` -> `Start Staking` or `Stake Again` and then choose Access node as the option.

![choose_access_flowport](choose_access_flowport.png)

On the next screen, provide the node details of you node.

Those node details (`Node ID`, `Network Address`, `Networking Key` and `Staking Key`) can be found in the file: `./bootstrap/public-root-information/node-info.pub.<node-id>.json`.

```shell Example
$cat ./bootstrap/public-root-information/node-info.pub. e737ec6efbd26ef43bf676911cdc5a11ba15fc6562d05413e6589fccdd6c06d5.json
{
  "Role": "access",
  "Address": "flowaccess.mycompany.com:3569",
  "NodeID": "e737ec6efbd26ef43bf676911cdc5a11ba15fc6562d05413e6589fccdd6c06d5",
  "Weight": 0,
  "NetworkPubKey": "f493a74704f6961ae7903e062ecd58d990672858eff99aece7bfbccf3aa02de8f1a624ecbf21a01e8b2f4a5854c231fbe218edd7762a34fea881f3958a215305",
  "StakingPubKey": "ae8dcf81f3a70d72036b7ba2c586ed37ed0eb82b9c0a4aab998a8420f98894f94c14f84fa716e93654d3940fc0c8ff4d19b504c90a5b4918b28f421e9d3659dc2b7e246025ebeffea0d83cceefe315d7ed346dbe412fdac51b64997d97d29f7e"
}
```

#### Example

![node_details_permissionless_an](node_details_permissionless_an.png)

On the next screen, ensure that you stake 100 FLOW token.

#### Example

![transaction_register_node_permissionless_an](transaction_register_node_permissionless_an.png)

Submit the Transaction.

## Step 3 - Verify that your node ID was selected

On Wednesday at around 12:00 UTC, the staking auction for the current epoch will end and five nodes from candidate list of nodes will be chosen at random by the staking contract to be part of the next epoch.

>Note: If all 5 slots have been taken from the previous epoch, then no new access nodes will be chosen (see #limitations)

There are several ways to verify whether your node was chosen as explained below.

When you stake the node, the tokens will show up under the `tokensCommitted` bucket. After the staking auction ends, if the node is selected, the tokens remain in the `tokensCommitted` bucket and are moved to the `tokensStaked` bucket at the end of the epoch.
If the node is not selected, the tokens are moved to the `tokensUnstaked` bucket.

### Check using Flow Port
You can check these balances on Flow Port before and after the epoch transition that will occur on Wednesday (see [timing](#Timing)).

When you stake the node, you should see the following on Flow Port under `Stake & Delegate`

![Staked_node](Staked_FlowPort.png)

After the epoch transition, if you see you token balance under the Staked Amount then your node got chosen.

![Staked_node](Selected_FlowPort.png)

Instead, if you see that your token balance is under the Unstaked Amount, then your node did not get chosen.

![Unstaked_node](Unstaked_FlowPort.png)

### Check using FlowCli

You can also check these balance using [Flow Cli](https://github.com/onflow/flow-cli). Once you have downloaded and installed Flow Cli, you can query the account balance using the command,
```shell
flow accounts staking-info <your account address> -n mainnet
```

For Example, the following node was chosen as Tokens staked is 100.

```shell Example
$ flow accounts staking-info 0xefdfb20806315bfa -n testnet

Account staking info:
	ID: 						 "e737ec6efbd26ef43bf676911cdc5a11ba15fc6562d05413e6589fccdd6c06d5"
	Initial Weight: 				 100
	Networking Address: 				 "flowaccess.mycompany.com:3569"
	Networking Key: 				 "f493a74704f6961ae7903e062ecd58d990672858eff99aece7bfbccf3aa02de8f1a624ecbf21a01e8b2f4a5854c231fbe218edd7762a34fea881f3958a215305"
	Role: 						 5
	Staking Key: 					 "ae8dcf81f3a70d72036b7ba2c586ed37ed0eb82b9c0a4aab998a8420f98894f94c14f84fa716e93654d3940fc0c8ff4d19b504c90a5b4918b28f421e9d3659dc2b7e246025ebeffea0d83cceefe315d7ed346dbe412fdac51b64997d97d29f7e"
	Tokens Committed: 				 0.00000000
	Tokens To Unstake: 				 100.00000000
	Tokens Rewarded: 				 0.00000000
	Tokens Staked: 					 100.00000000
	Tokens Unstaked: 				 0.00000000
	Tokens Unstaking: 				 0.00000000
	Node Total Stake (including delegators): 	 0.00000000
```

### Epoch setup event

Alternatively, if you can monitor events, look for [the epoch setup event](../staking/05-epoch-scripts-events.md#epochsetup) that gets emitted by the epoch contract. That event is emitted at the end of epoch N's staking auction and contains a list of node IDs that are confirmed for the next epoch.

## Step 4 - Start your node

If your node was selected as part of Step 3, you can now start your node.

First you'll need to provision a machine or virtual machine to run your node software. Please see follow the [node-provisioning](./node-provisioning.mdx) guide for it.

The access node can be run as a docker container with the following command by replacing `nodeid` with your node ID and adjusting the other parameters as per your setup.

```shell
docker run --rm \
  -v $PWD/bootstrap:/bootstrap:ro  \
  -v $PWD/data:/data:rw \
  --name flow-go \
  --network host \
  gcr.io/flow-container-registry/access:v0.29.8 \
  --nodeid=[Insert you NODE ID here] \
  --bootstrapdir=/bootstrap \
  --datadir=/data/protocol \
  --secretsdir=/data/secrets  \
  --rpc-addr=0.0.0.0:9000 \
  --http-addr=0.0.0.0:8000 \
  --rest-addr=0.0.0.0:80 \
  --rpc-metrics-enabled=true \
  --bind 0.0.0.0:3569 \
  --dynamic-startup-access-address=secure.mainnet.nodes.onflow.org:9001 \
  --dynamic-startup-access-publickey=28a0d9edd0de3f15866dfe4aea1560c4504fe313fc6ca3f63a63e4f98d0e295144692a58ebe7f7894349198613f65b2d960abf99ec2625e247b1c78ba5bf2eae \
  --dynamic-startup-epoch-phase=EpochPhaseStaking \
  --loglevel=error
```

Example, for the Node ID `e737ec6efbd26ef43bf676911cdc5a11ba15fc6562d05413e6589fccdd6c06d5`, the docker command be the following,
```shell Example
docker run --rm \
  -v $PWD/bootstrap:/bootstrap:ro  \
  -v $PWD/data:/data:rw \
  --name flow-go \
  --network host \
  gcr.io/flow-container-registry/access:v0.29.8 \
  --nodeid=e737ec6efbd26ef43bf676911cdc5a11ba15fc6562d05413e6589fccdd6c06d5 \
  --bootstrapdir=/bootstrap \
  --datadir=/data/protocol \
  --secretsdir=/data/secrets  \
  --rpc-addr=0.0.0.0:9000 \
  --http-addr=0.0.0.0:8000 \
  --rest-addr=0.0.0.0:80 \
  --rpc-metrics-enabled=true \
  --bind 0.0.0.0:3569 \
  --dynamic-startup-access-address=secure.mainnet.nodes.onflow.org:9001 \
  --dynamic-startup-access-publickey=28a0d9edd0de3f15866dfe4aea1560c4504fe313fc6ca3f63a63e4f98d0e295144692a58ebe7f7894349198613f65b2d960abf99ec2625e247b1c78ba5bf2eae \
  --dynamic-startup-epoch-phase=EpochPhaseStaking \
  --loglevel=error
```

For a more mature setup, it is recommended that you run the container using systemd as described [here](./node-setup.mdx#systemd)

> 🚀 The access node should now be up and running, and you should be able to query the node using Flow CLI or curl,

```shell Example
flow blocks get latest --host localhost:9000
```

```shell Example
curl http://localhost/v1/blocks?height=sealed
```

## Monitoring and Metrics

The node publishes several Prometheus metrics. See [Monitoring Node Health](./monitoring-nodes.mdx) to setup node monitoring.

### Node Status

The metrics for the node should be able to provide a good overview of the status of the node. If we want to get a quick snapshot of the status of the node, and if it's properly participating in the network, you can check the `consensus_compliance_finalized_height` or `consensus_compliance_sealed_height` metric, and ensure that it is not zero and strictly increasing.

```shell
curl localhost:8080/metrics | grep consensus_compliance_sealed_height

# HELP consensus_compliance_sealed_height the last sealed height
# TYPE consensus_compliance_sealed_height gauge
consensus_compliance_sealed_height 1.132054e+06
```

## FAQs

### Will the access node receive rewards?

No, the access nodes do not receive any rewards.

### Why is there a 100 FLOW token minimum?

As mentioned in the [FLIP](https://github.com/onflow/flips/blob/main/protocol/20220719-automated-slot-assignment.md), the minimum is required to prevent certain vulnerabilities
in the smart contract that are a result of having a zero minimum stake requirement.

### Can the Access node be unstaked?

Yes, like any other staked node, the Access node can be unstaked. The staked tokens will be moved to the unstaked bucket in the subsequent epoch.

### How to see all the access nodes that have staked?

When the nodes are initially staked, they are all added to the candidate list of nodes before the end of the epoch staking phase.
The list can be retrieved from the chain by executing the [get_candidate_nodes](https://github.com/onflow/flow-core-contracts/blob/48ba17d3386023d70817197a20effbc5d16339b3/transactions/idTableStaking/scripts/get_candidate_nodes.cdc) script which returns the candidate list for the current epoch.

```shell
$ flow scripts execute  ./transactions/idTableStaking/scripts/get_candidate_nodes.cdc -n mainnet
```

### How to check the availability of open access nodes slots for the next epoch?

The limits for the open slots are defined in the staking contract and can be queried from the chain by executing the [get_slot_limits](https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_slot_limits.cdc) script.

Node types are defined [here](https://github.com/onflow/flow-core-contracts/blob/5696ec5e3e6aa5fc10762cbfeb42b9c5c0b8ddbe/contracts/FlowIDTableStaking.cdc#L114-L119)

```shell

$ flow scripts execute  ./transactions/idTableStaking/scripts/get_slot_limits.cdc --args-json  '[{ "type":"UInt8", "value":"5"}]'  -n mainnet
Result: 118
```

Currently, there are 113 access nodes already part of the network. Hence, the total number of new nodes that can join are 118 - 113 = 5.
---
title: Byzantine node attack response
sidebar_label: Byzantine attack response
description: How to respond to a byzantine node attack on the network
---

Flow, like most blockchains, forms an open decentralized peer-to-peer network between all of the nodes
on the network. Due to its decentralized nature, there is a potential for nodes to behave maliciously
(byzantine) and intentionally try to harm the network. There are a variety of protections within the
node software to deal with invalid messages - message signatures, sender authorization, payload
validation, etc. These protections guard the network against many types of attacks. However, there
could still be a byzantine node that spams other nodes in the network with invalid messages at volumes
that are intended to impact node performance. While this will not compromise the security of the
network it could impact network liveness.

This guide explains how to detect such a node and what actions you should take as a node operator
to deal with such byzantine nodes.

Responding to an attack from a byzantine node requires the following:

1. Immediate action to block network traffic originating from the byzantine node to your node.
2. Raising a governance FLIP to remove the node from the network as described in this [FLIP](https://github.com/onflow/flips/blob/main/governance/20230105-identify-errant-node.md).
3. A service account transaction to set the node weight to 0.

This guide focuses on the first action.

## Admin server

Flow nodes have an admin server which exposes a simple REST API for interacting with the node.
See the [README](https://github.com/onflow/flow-go/blob/master/admin/README.md) for some useful examples.
It is disabled by default.

### Enable the admin server

To enable to admin server,

1. Add the following option to the node's CLI flags.
```
--admin-addr=localhost:9002
```

> Note: The port does not have to be 9002. You can choose any free port.

> ⚠️ Do NOT expose the port outside the machine and always use <b>localhost</b>:port

2. Reboot the node to apply the new setting. You can then verify it’s working by logging into
the machine via ssh and running,

```
curl localhost:9002
```

This should return a json response message as below.
```
{"code":5,"message":"Not Found","details":[]}
```

If you instead get a connection rejected message then it’s not configured correctly.

## Detecting a byzantine node

There are 2 general categories of byzantine attacks:
1. Safety attacks - are attacks where a node attempts to corrupt or modify the state of the
blockchain outside of normal protocol rules.
2. Liveness attacks - sometimes called spamming attacks, are when a node attempts to disrupt the
network by abusing their access to waste network and node resources. This generally results in
degraded performance.

Flow nodes are protected against safety attacks, but liveness attacks are extremely difficult to
completely prevent. To close the gap, we rely on coordination between node operators to detect
and block abusive nodes.

### Metrics

Flow nodes generate a variety of metrics that can be used to measure the node's performance and
identify abnormal behavior. Most metrics are only useful in the context of "normal" operation,
so it is a good idea to regularly review them to build an understanding of what is "normal".

Metrics to watch:
* CPU, memory, network connections, network I/O, file descriptors
* `network_authorization_*` - counts the number of unauthorized/invalid messages received
* `network_queue_message_queue_size` - measures the number of incoming messages waiting to be processed
* `network_engine_messages_received_total` - measures the number of messages received from the network

There are many other metrics, but these are a good starting point. If you notice any anomalous trends,
review the logs for additional context.

### Logs

Log events related to suspicious activity are logged with the label `"suspicious":true`. This is
helpful to identify the most relevant logs, but there are legitimate cases when these logs are
emitted, so they cannot be used as a definitive indicator of malicious activity. Two examples of
expected log messages are:
* `rejected inbound connection` - You may see this error if an operator unstaked their node between
sporks, but never shut it down. The node will continue to operate as usual, but peers will not have
it in their identity table and will (correctly) reject incoming connections.
* `middleware does not have subscription for the channel ID indicated in the unicast message received` -
This is commonly logged during node startup when receiving messages before all of the components
have finished registering their channels with the network layer. It is NOT expected after startup.

The following is an example of a log message indicating an Access node attempted to send a message it
is not authorized to send:
```
{
    "level": "error",
    "node_role": "collection",
    "node_id": "4a6f7264616e20536368616c6d00a875801849f2b5bea9e9d2c9603f00e5d533",
    "module": "network_slashing_consumer",
    "peer_id": "QmY2kby3xt3ugu2QqJP5w24rP4HSakYgDFpAJy1ifSRkF7",
    "networking_offense": "unauthorized_sender",
    "message_type": "messages.BlockProposal",
    "channel": "sync-committee",
    "protocol": "publish",
    "suspicious": true,
    "role": "access",
    "sender_id": "f9237c896507b8d654165c36b61c9a3080e6dd042dea562a4a494fbd73133634",
    "time": "2023-01-24T21:10:32.74684667Z",
    "message": "potential slashable offense: sender role not authorized to send message on channel"
}
```

### Identifying the source of malicious traffic

Most log messages include either the node ID or peer ID. Peer ID is the ID used to identify nodes on
by the libp2p library. Peer IDs are derived from the node's networking public key, so there is a 1:1
mapping between node ID and peer ID.

The two simplest ways to match a node ID to a peer ID:
1. `inbound connection established` and `outbound connection established` log messages contain both
the node and peer IDs
2. The following admin command will return the node info for a given peer ID:
```
curl localhost:9002/admin/run_command \
  -H 'Content-Type: application/json' \
  -d '{"commandName": "get-latest-identity", "data": { "peer_id": "QmY2kby3xt3ugu2QqJP5w24rP4HSakYgDFpAJy1ifSRkF7" }}'
```

If you cannot find any log messages at the current log level, you may need to enable debug logging.
See the admin server's [README](https://github.com/onflow/flow-go/blob/master/admin/README.md) for
an example.

## Reporting the byzantine node

Report the suspicious node on Discord in the `#flow-validators-alerts` channel along with all the
evidence you have collected (log messages, other networking related metrics, etc).
This will alert other node operators who can review their nodes to corroborate the report. Using
evidence from multiple operators, a consensus can be reached about the suspicious node, and
appropriate action can be taken.

## Blocking a byzantine node

Once a consensus is reached about the suspicious node on Discord among the node operators, the
suspicious node can be blocked using the admin command.

```
curl localhost: 9002/admin/run_command \
  -H 'Content-Type: application/json' \
  -d '{"commandName": "set-config","data": {"network-id-provider-blocklist": ["<suspcious node id>"]}}
```

After blocking the node, all traffic coming from the node will be rejected and you should only see
logs about reject messages and connections for that node ID.

## Unblocking a node

If you need to unblock a node, you can use the same command to remove the node ID from the blocklist.
Simply run it again with an empty list to remove all blocked nodes, or an existing list with the
specific node ID you want to unblock removed.

The following command returns a list of the currently blocked nodes.
```
curl localhost: 9002/admin/run_command \
  -H 'Content-Type: application/json' \
  -d '{"commandName": "get-config", "data": "network-id-provider-blocklist"}
```

After unblocking the node, connections and traffic coming from the node should resume.
---
title: Database Encryption for Existing Node Operators
sidebar_label: Database Encryption for Existing Node Operators
description: Instructions for existing Node Operators to follow to create a machine account for their collection or consensus nodes.
---

In Mainnet14, the DKG (distributed key generation) is turned on, requiring storage of 
dynamically generated confidential data (random beacon keys). These are stored in a
separate database which is new with the Mainnet14 release.

All node operators joining after Mainnet14 will generate encryption keys for this database
through the node bootstrapping and staking process. We strongly recommend all node operators
(especially consensus node operators) generate an encryption key for this database. This
guide demonstrates how to enable encryption for this database for existing operators.

## Downloading Bootstrap Utility

<Callout type="warning">
  If you have downloaded the bootstrapping kit previously, ensure that you do
  this step again to get the latest copy of the bootstrapping kit since there
  have been significant changes to it.
</Callout>

Follow the instructions [here](./node-bootstrap.mdx#download-the-bootstrapping-kit)
to download the latest version of the bootstrapping kit, then return to this page.

## Generate Database Encryption Key

You will need to generate an encryption key for the database using the `bootstrap` utility.

<Callout type="warning">

  Ensure you run the following commands on the machine you use to run your node software.
  The bootstrap directory passed to the `-o` flag must be the same bootstrap directory used by your node.
  The default location is `/var/flow/bootstrap`, but double-check your setup before continuing.

</Callout>

```shell GenerateEncryptionKey
$./boot-tools/bootstrap db-encryption-key -o ./bootstrap
<nil> INF generated db encryption key
<nil> INF wrote file bootstrap/private-root-information/private-node-info_ab6e0b15837de7e5261777cb65665b318cf3f94492dde27c1ea13830e989bbf9secretsdb-key

$tree ./bootstrap/
./bootstrap
├── private-root-information
│   └── private-node-info_ab6e0b15837de7e5261777cb65665b318cf3f94492dde27c1ea13830e989bbf9
│       ├── node-info.priv.json
│       └── secretsdb-key
└── public-root-information
    ├── node-id
    └── node-info.pub.ab6e0b15837de7e5261777cb65665b318cf3f94492dde27c1ea13830e989bbf9.json

3 directories, 4 files
```
{
    "label": "Node Operations Guide"
  }---
title: Genesis Bootstrapping
---


<Admonition type="warning" title="Genesis Only">
  All nodes joining the network in May are required to go through this process as part of the Genesis Bootstrapping.
</Admonition>

## Overview

To kickstart the Flow network and build the first block, all the nodes that will participate in the first round of consensus need to be known and have exchanged some metadata in advance.

This guide will take you through setting up your nodes, running the initial metadata and key generation, exchanging data back and forth with the Flow team, and then finally starting your nodes to join the network.

## Before You Begin

The Flow consensus algorithm depends on there always being a previous block, which means your nodes cannot start until _after_ the Genesis block has been signed. The process of signing that block will be done by the Flow team, and can only be done after every node has completed the first half of the bootstrapping process, which assures that all the identities are included. Since the Flow team needs to wait for metadata from all participants, it will take hours to even days until the Flow network can start.

The bootstrapping process will be in 2 phases, with the Flow team signing the Genesis block between the two.

<Admonition type="info" title="Understanding Keys">
  The bootstrapping process deals with a number of different keys. Make sure you understand their usage and terminology by reviewing the [Node Keys Guide](../node-bootstrap.mdx#generating-your-node-id).
</Admonition>

## Download the Bootstrapping Toolkit

Both phases of the bootstrapping are automated with scripts. Pull a copy onto each of your nodes and extract it.

```shell Pull-boot-tools
~ $ curl -sL -O storage.googleapis.com/flow-genesis-bootstrap/boot-tools.tar
~ $ tar -xvf boot-tools.tar
```

## Generate Your Node Keys

Start the bootstrapping process by generating your Staking Key and Networking Key. Use your Node Address that you generated in [Setting Up a Node](../node-setup.mdx) in the `--address` flag, and the node role.

<Admonition type="warning" title="Node Address">Your Node Address must be a publicly routable IPv4 address or valid DNS name that points to your node. This is how other nodes in the network will communicate with you.</Admonition>

```shell Generate-bootstrap-keys"
~ $ mkdir ./bootstrap
~ $ ./boot-tools/bootstrap key --address \"${YOUR_NODE_ADDRESS}:3569\" --role ${YOUR_NODE_ROLE} -o ./bootstrap
```

<Admonition type="info" title="BYO Entropy">
  By default, the bootstrap script uses the kernel entropy source, either via a `getrandom` syscall or `/dev/urandom`. If you have a more secure source of entropy, like a hardware device, you can specify `--staking-seed` and `--networking-seed`, to provide your own seeds.
  
  Run the `bootstrap` command with no flags to print usage information."
</Admonition>

<Admonition type="danger" title="Protect your keys!">
  The key pairs generated in the bootstrapping process are extremely sensitive and must be managed securely. This guide does not deal with storing the keys in a secure backup or controlling access, as the right approach to this will vary from user to user, but it is something you must consider.
  
  Private keys are suffixed with `.priv.json`, their public counterparts are not sensitive and can be shared freely.
</Admonition>

This command generates two keys, a Staking Key and a Network Key, and stores them both in a `.node-info` file. Both these keys are needed during runtime and must be present as a file to start your flow node.

For more details around all the keys that are needed to run nodes and their usage, see the [Node Keys](../node-bootstrap.mdx#generating-your-node-id) overview.

The bootstrapping process will create a file structure similar to the following

```text bootstrap-directory
~
└──bootstrap
   ├──{id}.node-info.priv.json
   └──{id}.node-info.pub.json",
```

## Upload Public Keys

To mint the Genesis Block, the Flow team will need the public Staking and Network keys from all your nodes.

**If you have previously joined our networks, and you are generating your keys again. Ensure that you take a backup of your keys before generating it again**

To facilitate this, the boot-tools directory comes with a script `push-keys` that will bundle your `*.pub.json` files and send it to the flow team. You can inspect this script to make sure no private key material is being bundled or uploaded. The data not encrypted before being sent as the public keys involved are not sensitive.

In phase 2 of the bootstrapping process, the Flow team will need to securely issue each node a Random Beacon key. This key is again sensitive and unique to your node. To enable this, the `push-keys` script also generates another key pair called the Transit Key. The public key of this pair will be uploaded along with the Staking and Network keys, and your Random Beacon key will be encrypted with it before being sent to you. You must keep your Transit Key until you have received and decrypted your Random Beacon key from the Flow team.

<Admonition type="warning" title="Token Needed">
  The transit script here need a `-t` token parameter flag. This token will have been provided to you by the Flow team out of band. Reach out to your contact if you don't have your token.
</Admonition>

```shell Upload-public-keys
# If you joined our network previously, make sure to take a backup!
cp /path/to/bootstrap /path/to/bootstrap.bak
$ ./boot-tools/transit push -d ./bootstrap -t ${TOKEN} -role ${YOUR_NODE_ROLE}
Running push
Generating keypair
Uploading ...
Uploaded 400 bytes

```

<Admonition type="danger" title="One and Done!">
  Once you've run the bootstrap and are confident in your setup, run the transit push command only once. If you bootstrap again and transit push again with a new node ID, it will count against your quota of Nodes. Exceeding your quota will result in a long back and forth with the Flow team to see which node is the extra one.
</Admonition>

## Update Node Config

As flow node requires a `--nodeid` flag to start. You will need to pass in the contents of the `node-id` into either your container, `runtime-config.env` file, or hard coded into the `systemd` unit file which the flow team provides.

You can get the `node-id` from the metadata that you pulled. It will be at: `/path/to/bootstrap/public-genesis-information/node-id`

### Wait

Now the ball is in the Flow team's court. As soon as all nodes have completed the above steps, the Genesis block will be created and distributed to you.

Join the [Flow discord server](https://chat.onflow.org) if you haven't already and stay tuned for updates. Your nodes need not be online during this waiting period if you want to suspend them to reduce cost, but you must not lose your key material.

<Admonition type="info" title="A Note on Staking">
  For the Genesis Block, your nodes will start pre-staked, which means no action on your part is needed to get your nodes staked.
  
  For more details on staking check the guide on [Staking and Rewards](../../staking/08-staking-rewards.md).
</Admonition>

## Receive Your Random Beacon Keys

When the Flow team gives the go-ahead, your Random Beacon keys will be available for retrieval. Each Node will need to pull their own keys down individually.

```shell Pull-beacon-keys
~ $ ./boot-tools/transit pull -d ./bootstrap -t ${TOKEN} -role ${YOUR_NODE_ROLE}
Fetching keys for node ID FEF5CCFD-DC66-4EF6-8ADB-C93D9B6AE5A4
Decrypting Keys
Keys available
```

Pulling your keys will also pull a bunch of additional metadata needed for the bootstrapping process.
In the end, your bootstrap directory should look like this:

```text bootstrap-directory
~
bootstrap/
├── private-genesis-information
│ └── private-node-info_{node id}
│ ├── node-info.priv.json
│ └── random-beacon.priv.json
├── public-genesis-information
│ ├── dkg-data.pub.json
│ ├── genesis-block.json
│ ├── genesis-cluster-block.{cid}.json
│ ├── genesis-cluster-block.{cid}.json
│ ├── genesis-cluster-qc.{cid}.json
│ ├── genesis-cluster-qc.{cid}.json
│ ├── genesis-commit.json
│ ├── genesis-qc.json
│ ├── node-id
│ ├── node-info.pub.{node id}.json
│ └── node-infos.pub.json
├── <additional files...>
```


<Admonition type="info" title="Why are we generating the beacon keys for you?">
  Unlike staking and account keys, the beacon keys are not randomly generated, and depend on inputs from all consensus nodes on the network. In typical Flow network operation, these keys will be dynamically generated on demand by the consensus nodes communicating. However for genesis, as the consensus nodes aren't communicating yet, the Flow team will generate and distribute them to kickstart the process.
</Admonition>

## Move Genesis Data

This bootstrapping data is needed by your node at each startup, so it must be present on disk.

Where in the filesystem you store this data is up to you, but you may not change the folder structure generated by the bootstrapping process. By default, flow stores this data under `/var/flow/bootstrap`.

## New Images

Once the Genesis block has been minted, it will be included into the official container images so that it's available to all nodes. Pull the new images, which should now be version `v1.0.0`.

## Start Your Nodes

Once every node has puled its keys and fetched the new images, the network is ready to start.

Make sure you're part of the [Discord Chat](https://chat.onflow.org). Once all nodes are ready, updates will be provided to everyone.

Start your systems, let's make some blocks!
---
title: Spork Practice
---

## Sporking

The actual process of Sporking will mostly be covered by the Node Operators Quick Guide, and will not be covered here.

[Spork](../spork.mdx)

Instead, we'll aim to give some instructions for those that want to Practice the process themselves, before joining the Mainnet Spork.

This guide assumes you have access to the Flow-Go repo, which you'll need to build up-to-date containers and run code snippets.

[](https://github.com/onflow/flow-go)

## Local Testnet

One way to get a good feel of the network without too much interaction with infrastructure is to play with the local testnet, which we've named the Flow Local Instrumented Test Environment (FLITE).

[https://github.com/onflow/flow-go/blob/master/integration/localnet/README.md](https://github.com/onflow/flow-go/blob/master/integration/localnet/README.md)

FLITE will allow you to start a full flow network locally, which means starting all 5 roles required for a functioning network. Instructions for initializing and starting the local network are provided in the README above.

When Starting FLITE, it will build all the docker images required for the network. This can also be done manually ahead of time, using `make docker-build-flow` from the root directory of `flow-go`

## Remote Testnet

If you would like more control over the nodes, beyond what docker compose can provide, or you wish to deploy the docker images to separate VMs, to more closely imitate Mainnet, you will have to manually run bootstrapping for a specific configuration of nodes that you would like to test.

[](https://github.com/onflow/flow-go/blob/master/cmd/bootstrap/README.md)

Example files are available in the `cmd/bootstrap/example_files` folder.

Where the `node-config.json` will usually store all flow's nodes, whereas partner node info usually goes into a separate folder. The last file, which will need to be manually populated, is the partner stakes file, which takes the IDs of all the partner nodes and associates a stake. For now, this can be arbitrary.

Once you have all the information, you can make use of the `finalize` command:

[](https://github.com/onflow/flow-go/tree/master/cmd/bootstrap#example-1)

And generate the bootstrapping folder required to start up your nodes.

Once you have the bootstrapping folder, you'll be able to start up all the nodes that were included in the bootstrapping process.

[Node Setup Docker](../node-setup.mdx#docker)

The startup command will look very similar to what is provided in the quick guide. One such example, assuming we named our bootstrap folder `bootstrap`:

```shell
docker run --rm \
    -v /path/to/bootstrap:/bootstrap:ro \
    -v /path/to/data:/data:rw \
    --name flow-go \
    --network host \
    gcr.io/flow-container-registry/execution:latest \
    --nodeid=${FLOW_GO_NODE_ID} \
    --bootstrapdir=/bootstrap \
    --datadir=/data/protocol \
    --rpc-addr=0.0.0.0:9000 \
    --nclusters=${FLOW_NETWORK_COLLECTION_CLUSTER_COUNT} \
    --bind 0.0.0.0:3569 \
    --loglevel=error
```

The two missing pieces of info here are `FLOW_GO_NODE_ID` which will have been generated from the bootstrap process, and will depend on which node you're trying to run, and `FLOW_NETWORK_COLLECTION_CLUSTER_COUNT` which we've been defaulting to `2`

## Practice Testnet

Lastly, if the goal is to practice the entire Sporking procedure, including `transit` of staking and networking keys, and joining a network, we can help spin up a Testnet temporarily for this purpose. This will require quite a bit of coordination, and will basically be the same steps as the Mainnet spork, so please let us know if this is something you'd like to do and we’ll connect to plan accordingly.
---
title: Starting Your Nodes
---

Prior to starting up your nodes make sure you have the following items completed:

1. Bootstrap process completed with the bootstrap directory handy (default: `/var/flow/bootstrap`)
2. Flow `data` directory created (default: `/var/flow/data`)
3. [node config](../node-bootstrap.mdx) ready
4. Firewall exposes TCP/3569, and if you are running `access` node also the GRPC port (default: TCP/9000)

For more details head back to [Setting up your node](../node-setup.mdx#prepare-your-node-to-start)

When you have all the above completed, you can start your Flow node via `systemd` or `docker`.

## systemd

Ensure that you downloaded the systemd unit file. If you haven't, follow the [Set your node to start](../node-setup.mdx#prepare-your-node-to-start) guide to get your unit file and enabled.

Once you have your Flow service enabled you can now start your service: `systemctl start flow`

## Docker

If you don't have have systemd on your system, or prefer not to use systemd, you can run the following `docker` commands for your respective Flow role to start your node!

### Access

```
docker run --rm \
	-v /path/to/bootstrap:/bootstrap:ro \
	-v /path/to/data:/data:rw \
	--name flow-go \
	--network host \
	gcr.io/flow-container-registry/access:v0.0.6-alpha \
	--nodeid=${FLOW_GO_NODE_ID} \
	--bootstrapdir=/bootstrap \
	--datadir=/data/protocol \
	--rpc-addr=0.0.0.0:9000 \
	--ingress-addr=${FLOW_NETWORK_COLLECTION_NODE} \
	--script-addr=${FLOW_NETWORK_EXECUTION_NODE} \
	--bind 0.0.0.0:3569 \
	--loglevel=error
```

### Collection

```
docker run --rm \
	-v /path/to/bootstrap:/bootstrap:ro \
	-v /path/to/data:/data:rw \
	--name flow-go \
	--network host \
	gcr.io/flow-container-registry/collection:v0.0.6-alpha \
	--nodeid=${FLOW_GO_NODE_ID} \
	--bootstrapdir=/bootstrap \
	--datadir=/data/protocol \
	--rpc-addr=0.0.0.0:9000 \
	--nclusters=${FLOW_NETWORK_COLLECTION_CLUSTER_COUNT} \
	--bind 0.0.0.0:3569 \
	--loglevel=error
```

### Consensus

```
docker run --rm \
	-v /path/to/bootstrap:/bootstrap:ro \
	-v /path/to/data:/data:rw \
	--name flow-go \
	--network host \
	gcr.io/flow-container-registry/consensus:v0.0.6-alpha \
	--nodeid=${FLOW_GO_NODE_ID} \
	--bootstrapdir=/bootstrap \
	--datadir=/data/protocol \
	--nclusters=${FLOW_NETWORK_COLLECTION_CLUSTER_COUNT} \
	--bind 0.0.0.0:3569 \
	--loglevel=error
```

### Execution

```
docker run --rm \
	-v /path/to/bootstrap:/bootstrap:ro \
	-v /path/to/data:/data:rw \
	--name flow-go \
	--network host \
	gcr.io/flow-container-registry/execution:v0.0.6-alpha \
	--nodeid=${FLOW_GO_NODE_ID} \
	--bootstrapdir=/bootstrap \
	--datadir=/data/protocol \
	--ingress-addr=0.0.0.0:9000 \
	--nclusters=${FLOW_NETWORK_COLLECTION_CLUSTER_COUNT} \
	--bind 0.0.0.0:3569 \
	--loglevel=error
```

### Verification

```
docker run --rm \
	-v /path/to/bootstrap:/bootstrap:ro \
	-v /path/to/data:/data:rw \
	--name flow-go \
	--network host \
	gcr.io/flow-container-registry/verification:v0.0.6-alpha \
	--nodeid=${FLOW_GO_NODE_ID} \
	--bootstrapdir=/bootstrap \
	--datadir=/data/protocol \
	--nclusters=${FLOW_NETWORK_COLLECTION_CLUSTER_COUNT} \
	--bind 0.0.0.0:3569 \
	--loglevel=error
```

### Additional Flags
#### Networking Layer
All networking layer settings are initialized to default values from the [config/default-config.yml](https://github.com/onflow/flow-go/blob/master/config/default-config.yml) file when the Flow node starts up. Each attribute in this YAML file matches a flag name, allowing you to override the default setting by specifying the corresponding flag in the `docker run` command. For instance, to change the `networking-connection-pruning` setting, use its matching flag name (`networking-connection-pruning`) and desired value in the `docker run` command.

### Archive

```shell
 docker run --rm \
	-v /path/to/data:/data:rw \
	--network host \
	--label=project=flow \
	--label=network=mainnet
	--label=app=dps
	--label=version=v0.26
	--name flow-dps gcr.io/flow-container-registry/flow-dps-live:v0.26.1
	--address 0.0.0.0:5005
	--index /data/index
	--bootstrap /data/bootstrap
	--checkpoint /data/bootstrap/root.checkpoint
	--data /data/protocol
	--level debug
	--metrics 0.0.0.0:8080
	--bucket bucket_name
	--seed-address=access_node_address
	--seed-key=seed_key
```
---
title: Height coordinated upgrade (HCU)
sidebar_title: Height coordinated upgrade
---

## Overview

To enables rapid development of the Flow Protocol, the height coordinated upgrade method is used to roll out non-breaking changes such as bug fixes,
feature implementations and security fixes.

## HCU versus Spork

A [spork](./spork.mdx) requires a coordinated network upgrade process where node operators upgrade their node software and
re-initialize with a consolidated representation of the previous spork's state.
It is used to roll out changes which may be non-backward compatible with respect to the protocol and the execution state.
Spork entails a network downtime as all nodes in the system are upgraded and brought back online.
Sporks are only executed once every quarter.

A height coordinated upgrade (HCU) on the other hand allows the execution and the verification nodes to be upgraded without stopping the network.
There is no network downtime during an HCU but the transaction execution will stop for few minutes while the execution nodes restart.
Currently, an HCU is only used to update the execution and the verification nodes.
For other node types, a simple rolling upgrade is used where operators are asked to upgrade their nodes async.

## HCU process

The HCU is executed in two parts.

The first part is executed by the service committee. In this, the version boundary at which the execution nodes and verification nodes should stop is set on chain by submitting the [set_version_boundary](https://github.com/onflow/flow-core-contracts/blob/master/transactions/nodeVersionBeacon/admin/set_version_boundary.cdc) transaction.
The version boundary includes the block height at which the two node types should stop and the new node software version that the nodes should compare after a restart.


The second part is executed by the node operator. In this the node operator, monitors the execution and verification node that they are running. When the nodes reach the height set on chain, they stop if their version is lower then the version specified in the version boundary.
At this point, the operator should update the node version to the new node software version and start the node again. The node will continue from where it left off.

The block height and the node version will be announced by the Flow team on Discord as well as the [forum page](https://forum.onflow.org/c/mainnet-sporks/36).
It can also be directly queried from the chain using the following script.

```
TODO: insert flow cli command here to query the block version details.
```
---
title: Node Operations
sidebar_position: 1
---

# Hello Node Operator!

Flow nodes are vital components of the Flow blockchain. These nodes are responsible for a variety of network operations to maintain the distributed ledger.

## Why run a node?

---

By running your own node, you have direct access to the evolving state of the network, without having to rely on third parties.
This increases privacy and security, reduces reliance on external servers, and helps balance load distribution.
By running a node, you also directly contribute to the security and decentralization of the whole network.

Flow multirole architecture makes it more scalable and provides several node types that you as a node operator can pick and choose from.


## Which node should you run?

---

The different types of nodes are described [here](./node-roles.mdx). As node operator, you can choose to run any of the different types of node that best fits your needs.

The nodes are classified as follows,

![Flownodesdiagram.png](Flownodesdiagram.png)

## Light node a.k.a. Observer node

---

The light node is one of the easiest nodes to spin up and can be run by Dapp developers who need the latest block data available locally, e.g. a wallet application that needs to track the latest block ID and height.
In addition to supporting dapps, an observer node can also be run by access node operators who want to scale their access nodes' endpoints. Access node operators can spin up geographically dispersed observer nodes which can talk to their staked access nodes and to each other.

The observer node is not staked but still provides the same API as the access node.

<Callout type="info">
  <br />
  To run a light node, follow this [guide](./observer-node.mdx)
  <br />
</Callout>

## Archive node

---

The Archive node provides a scalable and efficient way to access the history of Flow protocol and the execution state for the current spork. Like the observer node, it too can be run by anyone without being staked or added to the approved list of nodes.
The Archive node follows the chain, stores and indexes both protocol and execution state, and allows retrieval of blocks, collections, transactions and events from the genesis of the current spork.

It also allows script execution and other read-only queries that require the execution state to be read. It can answer any queries from past data e.g. “what was the Flow account balance at height X?”, where X is several thousand blocks in the past.

_The archive node is currently in beta and will be available as a GA release in H2 2023 (see [here](https://flow.com/post/flow-blockchain-node-operation-archive-node) for more)._

## Full node

---

In a nutshell, Full Nodes are staked network participants that drive network progress, e.g. by creating and executing new blocks. They are the primary contributors to network safety (all of them validate the correctness of the consensus process and secure the network additionally through their role-specific tasks). In comparison, Light Nodes don't contribute to the networks progress. Though, they help to secure the network by also validating the integrity of the consensus process. 
- The Access node is a full node that serves as an RPC node and acts as a gateway node for the network.
- The Validator node (Collection, Consensus, Verification and Execution) is a full node that plays a role in block generation.


### Access node

---

If you want local access to the protocol state data (blocks, collections, transactions) and do not want to use one of the community access nodes you can run an access node.
Dapp developers, chain explorers, chain analytics etc. who want exclusive access to chain data and not be subject to the rate-limits on the community access node can choose to run an access node.

An access node is minimally staked for network security.
The central goal for Access Nodes is to provide RPC functionality to its node operator.
In comparison, contributing to protocol progress (e.g. routing transactions to collector clusters, relaying blocks to the unstaked peer-to-peer network, etc.) should only take up a marginal fraction an Access Node's computational resources.
Furthermore, Access Node operators can freely rate-limit the amount of resources their Access Node dedicates to supporting the broader ecosystem. Therefore, Access Nodes do not receive staking rewards.

<Callout type="info">
  <br />
  Launch an access node using QuickNode
  <a
    href="https://www.quicknode.com/chains/flow"
    target="_blank"
  >
    https://www.quicknode.com/chains/flow
  </a>
  <br/>
</Callout>


<Callout type="info">
  <br />
  To run a self-hosted access node, follow this [guide](./access-node-setup.md)
  <br />
</Callout>

<Callout type="tip">
  <br />
Alternately, instead of running an access node, you can use the [Flow community](../../../references/run-and-secure/nodes/access-api.mdx) access nodes or the ones run by any of the other node operators.
  <br />
</Callout>

### Validator node

---

You can also be a core participant in running the Flow network and contribute to securing it. Depending on your preference, you could run one or any combination of the following node roles:
- Collection Nodes collaboratively create batches of transactions (in Flow terminology collections).
- Consensus Nodes create blocks, schedule them for asynchronous execution, and commit execution results once they are verified (so called sealing). In addition, they orchestrate the Flow protocol and enforce protocol compliance. 
- Execution Nodes asynchronously execute blocks. They are the power-houses in the protocol, providing the vast computational resources available to Flow transactions. 
- Verification Nodes check the execution results in a distributed manner.

Nodes with these roles are staked and also receive staking rewards.

### Running a staked node

---

To run a staked node (node type access, collection, consensus, verification or execution) the node must:
* be registered with sufficient stake
* be authorized by the governance working group

Before proceeding, ensure you have the stake required for your new node and that your node will be authorized by the governance working group (apply [here](https://github.com/onflow/flow-validator)).

To set up a new staked node after it has been authorized by the Flow governance working group, you will need to complete the following steps:

1. [Provision](./node-setup.mdx) the machine on which your node will run.

2. [Generate and register](./node-bootstrap.mdx) your node identity.

3. [Start](./node-bootstrap.mdx#step-3---start-your-flow-node) your node!
---
title: Machine Accounts for Existing Node Operators
sidebar_label: Machine Accounts for Existing Node Operators
description: Instructions for existing Node Operators to follow to create a machine account for their collection or consensus nodes.
---

The [Flow Epoch Preparation Protocol](../staking/04-epoch-preparation.mdx) requires that 
`collection` and `consensus` nodes use an automated [machine account](../staking/09-qc-dkg.mdx#machine-accounts) 
to participate in important processes required to start the next epoch. (QC and DKG, respectively)

Starting on Thursday, August 26th 2021, all collector and consensus nodes who register with Flow Port will 
automatically create and initialize this machine account as part of their node registration.

If you have an existing `consensus` or `collection` node that you registered with Flow Port before Thursday August 26th,
you will need to create this Machine Account manually in order to participate in epochs.
You will need to create one Machine Account for each `consensus` or `collection` node that you operate.

This guide will walk you through creating a Machine Account and getting it set up.

<Callout type="warning">
  During this process you will generate a new private key which will have sole control over your machine account.
  This private key will be stored on the machine you use to run your node, alongside your staking and networking keys.
  Loss of any of these keys (staking, networking, or machine account) will require you to un-stake your tokens, start a completely new node, and register the new node to continue participating in the Flow network, which takes multiple weeks.
</Callout>

## Downloading Bootstrap Utility

<Callout type="warning">
  If you have downloaded the bootstrapping kit previously, ensure that you do
  this step again to get the latest copy of the bootstrapping kit since there
  have been significant changes to it.
</Callout>

Follow the instructions [here](./node-bootstrap.mdx#download-the-bootstrapping-kit)
to download the latest version of the bootstrapping kit, then return to this page.

## Generate Machine Account key

You will need to generate a Machine account private key using the `bootstrap` utility.

<Callout type="warning">

  Ensure you run the following commands on the machine you use to run your node software.
  The bootstrap directory passed to the `-o` flag must be the same bootstrap directory used by your node.
  The default location is `/var/flow/bootstrap`, but double-check your setup before continuing.

</Callout>

```shell GenerateMachineAccountKey
$./boot-tools/bootstrap machine-account-key -o ./bootstrap
<nil> INF generated machine account private key
<nil> INF encoded machine account public key for entry to Flow Port machineAccountPubKey=f847b84031d9f47b88435e4ea828310529d2c60e806395da50d3dd0dd2f32e2de336fb44eb06488645673850897d7cc017701d7e6272a1ab7f2f125aede46363e973444a02038203e8
<nil> INF wrote file bootstrap/private-root-information/private-node-info_6f6e98c983dbd9aa69320452949b81abeab2ac591a247f55f19f4dbf0b477d26/node-machine-account-key.priv.json

$tree ./bootstrap/
./bootstrap
├── private-root-information
│   └── private-node-info_ab6e0b15837de7e5261777cb65665b318cf3f94492dde27c1ea13830e989bbf9
│       ├── node-info.priv.json
│       └── node-machine-account-key.priv.json
│       └── secretsdb-key
└── public-root-information
    ├── node-id
    └── node-info.pub.ab6e0b15837de7e5261777cb65665b318cf3f94492dde27c1ea13830e989bbf9.json

3 directories, 4 files
```

## Create Machine Account

You will now need to copy the Machine account public key displayed in the terminal output and 
head over to [Flow Port](../../../references/run-and-secure/nodes/flow-port/staking-guide.md#existing-node-operators) to submit a transaction to create a Machine Account. 
For example, from the example above, we would copy `f847...` from this line:

```shell Example
<nil> INF encoded machine account public key for entry to Flow Port machineAccountPubKey=f847b84031d9f47b88435e4ea828310529d2c60e806395da50d3dd0dd2f32e2de336fb44eb06488645673850897d7cc017701d7e6272a1ab7f2f125aede46363e973444a02038203e8
```

This process will create your machine account for you and show you your machine account's address, which you will need to save for the next step.

## Finalize Machine Account setup

You will now need to use the `bootstrap` utility to run `machine-account` with the created address to finalize the set up of your Machine account.

```shell
$ ./boot-tools/bootstrap machine-account --address ${YOUR_MACHINE_ACCOUNT_ADDRESS} -o ./bootstrap
```

```shell Example
$./boot-tools/bootstrap machine-account --address 0x1de23de44985c7e7 -o ./bootstrap
<nil> INF read machine account private key json
<nil> DBG encoded public machine account key machineAccountPubKey=2743786d1ff1bf7d7026d693a774210eaa54728343859baab62e2df7f71a370651f4c7fd239d07af170e484eedd4f3c2df47103f6c39baf2eb2a50f67bbcba6a
<nil> INF wrote file bootstrap/private-root-information/private-node-info_6f6e98c983dbd9aa69320452949b81abeab2ac591a247f55f19f4dbf0b477d26/node-machine-account-info.priv.json

$tree ./bootstrap/
./bootstrap
├── private-root-information
│   └── private-node-info_d60bd55ee616c5c297cae1d5cfb7f65e7e04014d9c4abe595af2fd83f3cfe160
│       ├── node-info.priv.json
│       ├── node-machine-account-info.priv.json
│       └── node-machine-account-key.priv.json
│       └── secretsdb-key
└── public-root-information
    ├── node-id
    └── node-info.pub.d60bd55ee616c5c297cae1d5cfb7f65e7e04014d9c4abe595af2fd83f3cfe160.json

3 directories, 5 files
```

After running this step, you should see the `node-machine-account-info.priv.json` file in your `bootstrap` directory as shown above.

### Verify Machine Account Setup

After finalizing your machine account setup, you should verify its correctness with the `check-machine-account` command:

```shell CheckMachineAccount
$ ./boot-tools/bootstrap check-machine-account --access-address access.mainnet.nodes.onflow.org:9000 -o ./bootstrap
<nil> DBG read machine account info from disk hash_algo=SHA3_256 key_index=0 machine_account_address=0x284463aa6e25877c machine_account_pub_key=f847b84051bad4512101640772bf5e05e8a49868d92eaf9ebed41030881d95485769afd28653c5c53216cdcda4554384bb3ff6396a2ac04842422d55f0562496ad8d952802038203e8 signing_algo=ECDSA_P256
<nil> DBG checking machine account configuration... machine_account_address=0x284463aa6e25877c role=consensus
<nil> DBG machine account balance: 0.10000000
<nil> INF 🤖 machine account is configured correctly
```

This command will detect and provide information about common misconfigurations, or confirm that the machine account is configured correctly.
---
title: Monitoring Node Health
sidebar_label: Node Monitoring
---

A Flow node generates logs and publishes metrics as it runs. These logs and metrics can be used to gain insights into the health of the node.

## Logs

Logs are emitted to `stdout` as JSON formed strings. Where these logs are available on your system depends on how you launch your containers. On `systemd` systems for example, the logs will be sent to the system journal daemon `journald`. Other systems may log to `/var/log`.

## Metrics

Flow nodes produce health metrics in the form of [Prometheus](https://prometheus.io) metrics, exposed from the node software on `/metrics`.

If you wish to make use of these metrics, you'll need to set up a Prometheus server to scrape your Nodes. Alternatively, you can deploy the Prometheus Server on top of your current Flow node to see the metrics without creating an additional server.

> The flow-go application doesn't expose any metrics from the underlying host such as CPU, network, or disk usages. It is recommended you collect these metrics in addition to the ones provided by flow using a tool like node exporter (https://github.com/prometheus/node_exporter)

1. Copy the following Prometheus configuration into your current flow node

   ```yaml
      global:
        scrape_interval: 15s # By default, scrape targets every 15 seconds.

      scrape_configs:
        # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config.
        - job_name: 'prometheus'

        # Override the global default and scrape targets from this job every 5 seconds.
        scrape_interval: 5s

        static_configs:
          - targets: ['localhost:8080']
   ```

2. Start Prometheus server
   ```shell
      docker run \
      --network=host \
      -p 9090:9090 \
      -v /path/to/prometheus.yml:/etc/prometheus/prometheus.yml \
      prom/prometheus"
   ```
3. (optional) Port forward to the node if you are not able to access port 9090 directly via the browser
   `ssh -L 9090:127.0.0.1:9090 YOUR_NODE`

4. Open your browser and go to the URL `http://localhost:9090/graph` to load the Prometheus Dashboard

### Key Metric Overview

The following are some important metrics produced by the node.

| Metric Name                           | Description                                                                                                             |
| ------------------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| go\_\*                                | Go runtime metrics                                                                                                      |
| consensus_compliance_finalized_height | Latest height finalized by this node; should increase at a constant rate.                                               |
| consensus_compliance_sealed_height    | Latest height sealed by this node; should increase at a constant rate.                                                  |
| consensus_hotstuff_cur_view           | Current view of the HotStuff consensus algorith; Consensus/Collection only; should increase at a constant rate.         |
| consensus_hotstuff_timeout_seconds    | How long it takes to timeout failed rounds; Consensus/Collection only; values consistently larger than 5s are abnormal. |

## Monitoring a Flow node using Metrika Monitoring

Metrika has developed the Flow node monitoring service and is the recommended way of monitoring a Flow node.
It is a free tool that uses the logs and metrics published by the node and provides access to private node-specific dashboards.
Follow this [link](https://app.metrika.co/flow/node/install-agent) to setup the Metrika monitoring for your node.
---
title: Node Bootstrap
sidebar_label: Node Bootstrapping
description: How to get started running a node on Flow
---

This guide is for getting a new node staked and running on Flow other than a permissionless Access node. For running a permissionless Access node see [Access node setup](./access-node-setup.md). For sporking documentation for existing node operators, see [Spork Process](./spork.mdx).

## Timing

New nodes are able to join the network each time a new epoch begins.
In order to join the network at epoch N+1, the node must be registered with sufficient stake and
authorized by the service account prior to the end of epoch N's Staking Auction Phase.
Confirmation of a new node's inclusion in epoch N+1 is included in the [`EpochSetup` event](../staking/05-epoch-scripts-events.md#epochsetup).

Nodes registered for epoch N+1 are able to participate in network communication on a limited basis starting in the `Epoch Setup Phase` of epoch N.

![Flow Epoch Schedule](https://storage.googleapis.com/flow-resources/documentation-assets/epoch-startup-order.png)

Once registered and confirmed to join the network at epoch N+1, the node must start up **before** epoch N+1 begins.
* Verification & Access nodes may start up any time during the `Epoch Setup Phase`.
* Consensus & Collection nodes must start up within the first **1000 views (~30mins)**
of the `Epoch Setup Phase` to participate in the [Epoch Preparation Protocol](../staking/04-epoch-preparation.mdx#phase-1-epoch-setup).

## Step 1 - Run Genesis Bootstrap

<Callout type="info">
  You will need to run this process for each node that you are operating
</Callout>

### Download the Bootstrapping Kit

<Callout type="warning">
If you have downloaded the bootstrapping kit previously, ensure you check the hash below still matches. If not, re-download to ensure you are using the most up-to-date version.
</Callout>

```shell
curl -sL -O storage.googleapis.com/flow-genesis-bootstrap/boot-tools.tar
tar -xvf boot-tools.tar
```

```shell CheckSHA256
sha256sum ./boot-tools/bootstrapcmd
bc34a311f934fafed984a195f6bdca659ed21bfe50dd9947a39eb8edca6b10aa  ./boot-tools/bootstrap

sha256sum ./boot-tools/transit
a06e3e9b2443c6755214150e9e101b70dd48ae30ffcfcbbcc471ba430cb104bf  ./boot-tools/transit
```

### Generate Your Node Keys

#### Network Address

<Callout type="info">

Use a fully qualified domain name for the network address. Please also include the port number in the network address e.g. `example.com:3569`

</Callout>

<Callout type="warning">

Do not include in `http://` format.

</Callout>

<Callout type="info">

If you are running multiple nodes, please
ensure you have different addresses for each node.

</Callout>

<Callout type="warning">

All your current keys and Flow genesis files should be in the `bootstrap`
folder created earlier. Please take a back up of the entire folder.

</Callout>


```shell
## Skip this section if this is your first time ##
# If you joined our network previously, make sure to take a backup of your previously generated keys!
cp -r /path/to/bootstrap /path/to/bootstrap.bak
#########################################################
# Generate Keys
$ mkdir ./bootstrap
# YOUR_NODE_ADDRESS: FQDN associated to your instance
# YOUR_NODE_ROLE: The Flow nodes that you wish to run, it should be ONE of the following - [ access, collection, consensus, execution, verification ]
$ ./boot-tools/bootstrap key --address \"${YOUR_NODE_ADDRESS}:3569\" --role ${YOUR_NODE_ROLE} -o ./bootstrap

```

```shell Example
$./boot-tools/bootstrap key --address "consensus-001.nodes.flow.com:3569" --role consensus  -o ./bootstrap
<nil> DBG will generate networking key
<nil> INF generated networking key
<nil> DBG will generate staking key
<nil> INF generated staking key
<nil> DBG will generate db encryption key
<nil> INF generated db encryption key
<nil> DBG assembling node information address=consensus-001.nodes.flow.com:3569
<nil> DBG encoded public staking and network keys networkPubKey=7f31ae79017a2a58a5e59af9184f440d08885a16614b2c4e361019fa72a9a1a42bf85b4e3f9674782f12ca06afd9782e9ccf19496baed069139385b82f8f40f6 stakingPubKey=829d086b292d84de8e7938fd2fafa8f51a6e025f429291835c20e59d9e25665febf24fa59de12a4df08be7e82c5413180cc7b1c73e01f26e05344506aaca4fa9cc009dc1c33f8ba3d7c7509e86d3d3e7341b43b9bf80bb9fba56ae0b3135dd72
<nil> INF wrote file bootstrap/public-root-information/node-id
<nil> INF wrote file bootstrap/private-root-information/private-node-info_ab6e0b15837de7e5261777cb65665b318cf3f94492dde27c1ea13830e989bbf9/node-info.priv.json
<nil> INF wrote file bootstrap/private-root-information/private-node-info_5e44ad5598bb0acb44784f629e84000ffea34d5552427247d9008ccf147fb87f/secretsdb-key
<nil> INF wrote file bootstrap/public-root-information/node-info.pub.ab6e0b15837de7e5261777cb65665b318cf3f94492dde27c1ea13830e989bbf9.json
<nil> DBG will generate machine account key
<nil> INF generated machine account key
<nil> DBG assembling machine account information address=consensus-001.nodes.flow.com:3569
<nil> INF encoded machine account public key for entry to Flow Port machineAccountPubKey=f847b8406e8969b869014cd1684770a8db02d01621dd1846cdf42fc2bca3444d2d55fe7abf740c548639cc8451bcae0cd6a489e6ff59bb6b38c2cfb83e095e81035e507b02038203e8
<nil> INF wrote file bootstrap/private-root-information/private-node-info_ab6e0b15837de7e5261777cb65665b318cf3f94492dde27c1ea13830e989bbf9/node-machine-account-key.priv.json

$tree ./bootstrap/
./bootstrap
├── private-root-information
│   └── private-node-info_ab6e0b15837de7e5261777cb65665b318cf3f94492dde27c1ea13830e989bbf9
│       ├── node-info.priv.json
│       ├── node-machine-account-key.priv.json
│       └── secretsdb-key
└── public-root-information
    ├── node-id
    └── node-info.pub.ab6e0b15837de7e5261777cb65665b318cf3f94492dde27c1ea13830e989bbf9.json

3 directories, 4 files
```

<Callout type="info">

For `consensus` and `collection` node types an additional key will be created for the Machine Account.
For all other node types this will not be needed.

</Callout>

#### Machine Account Creation

If you are running a collection and consensus node, you will have an additional private key file (`node-machine-account-key.priv.json`)
which contains the private key for your node's machine account. You can learn more about machine
accounts [here](../staking/machine-account).

In Step 2 of this guide, when you submit a transaction to stake your node, you will need to provide the
machine account public key, which can be found in the output of the previous `bootstrap key` command.

```shell MachineAccountPublicKey
$./boot-tools/bootstrap key --address ${YOUR_NODE_ADDRESS} --role ${YOUR_NODE_ROLE}  -o ./bootstrap
...
<nil> DBG encoded public machine account key machineAccountPubKey=1b9c00e6f0930792c5738d3397169f8a592416f334cf11e84e6327b98691f2b72158b40886a4c3663696f96cd15bfb5a08730e529f62a00c78e2405013a6016d
<nil> INF wrote file bootstrap/private-root-information/private-node-info_ab6e0b15837de7e5261777cb65665b318cf3f94492dde27c1ea13830e989bbf9/node-machine-account-key.priv.json
```

<Callout type="warning">

Copy the machine account public key somewhere safe. You will need it in a later step.

</Callout>

## Step 2 - Stake Your Node

Stake your node via [Flow Port](https://port.onflow.org/)

The `node details` (`Node ID`, `Network Address`, `Networking Key` and `Staking Key`) that need to be submitted when staking the node on Flow Port, can be found in the file: `./bootstrap/public-root-information/node-info.pub.<node-id>.json`.

```shell Example
$cat ./bootstrap/public-root-information/node-info.pub.39fa54984b8eaa463e129919464f61c8cec3a4389478df79c44eb9bfbf30799a.json
{
  "Role": "consensus",
  "Address": "consensus-001.nodes.flow.com:3569",
  "NodeID": "39fa54984b8eaa463e129919464f61c8cec3a4389478df79c44eb9bfbf30799a",
  "Weight": 1000,
  "NetworkPubKey": "d92e3d5880abe233cf9fe9104db34bbb31251468a541454722b3870c04156a1b0504aef443bcaad124b997384b8fe7052847ce1e6189af1392d865e6be69835b",
  "StakingPubKey": "917826e018f056a00b778a58ae83054906957ffd4b6f1b7da083551f7a9f35e02b76ace50424ed7d2c9fc69207a59f0f08a031048f5641db94e77d0648b24d150dedd54bab7cd44b4aa60cfd54be418647b0b3965f8ae54c0bcb48ae9d705162"
}
```

If you are running a collection or consensus node, you will need to provide an additional field `Machine Account Public Key`.
This value is found in the output of the `bootstrap key` command from Step 1.

<Callout type="info">

Please let us know your node id via discord or email.

</Callout>

### Finalize Machine Account Setup

<Callout type="warning">

If you are not running a collection or consensus node, you can skip this step.

</Callout>

You will now need to use the `bootstrap` utility to run `machine-account` with the created address to finalize the set up of your Machine account.

```shell
$ ./boot-tools/bootstrap machine-account --address ${YOUR_MACHINE_ACCOUNT_ADDRESS} -o ./bootstrap
```

```shell Example
$ ./boot-tools/bootstrap machine-account --address 0x1de23de44985c7e7 -o ./bootstrap
<nil> INF read machine account private key json
<nil> DBG encoded public machine account key machineAccountPubKey=2743786d1ff1bf7d7026d693a774210eaa54728343859baab62e2df7f71a370651f4c7fd239d07af170e484eedd4f3c2df47103f6c39baf2eb2a50f67bbcba6a
<nil> INF wrote file bootstrap/private-root-information/private-node-info_6f6e98c983dbd9aa69320452949b81abeab2ac591a247f55f19f4dbf0b477d26/node-machine-account-info.priv.json

$tree ./bootstrap/
./bootstrap
├── private-root-information
│   └── private-node-info_d60bd55ee616c5c297cae1d5cfb7f65e7e04014d9c4abe595af2fd83f3cfe160
│       ├── node-info.priv.json
│       ├── node-machine-account-info.priv.json
│       ├── node-machine-account-key.priv.json
│       └── secretsdb-key
└── public-root-information
    ├── node-id
    └── node-info.pub.d60bd55ee616c5c297cae1d5cfb7f65e7e04014d9c4abe595af2fd83f3cfe160.json

3 directories, 5 files
```

After running this step, you should see the `node-machine-account-info.priv.json` file in your `bootstrap` directory as shown above.

### Verify Machine Account Setup

After finalizing your machine account setup, you should verify its correctness with the `check-machine-account` command:

```shell CheckMachineAccount
$ ./boot-tools/bootstrap check-machine-account --access-address access.mainnet.nodes.onflow.org:9000 -o ./bootstrap
<nil> DBG read machine account info from disk hash_algo=SHA3_256 key_index=0 machine_account_address=0x284463aa6e25877c machine_account_pub_key=f847b84051bad4512101640772bf5e05e8a49868d92eaf9ebed41030881d95485769afd28653c5c53216cdcda4554384bb3ff6396a2ac04842422d55f0562496ad8d952802038203e8 signing_algo=ECDSA_P256
<nil> DBG checking machine account configuration... machine_account_address=0x284463aa6e25877c role=consensus
<nil> DBG machine account balance: 0.10000000
<nil> INF 🤖 machine account is configured correctly
```

This command will detect and provide information about common misconfigurations, or confirm that the machine account is configured correctly.

### Push transit keys (consensus node only)

If you are running a consensus node, run the following command to push the transit keys. Use the token `mainnet-x-organization` e.g. `mainnet-17-companyname`.

```shell transit
$ ./boot-tools/transit push-transit-key -b ./bootstrap -t mainnet-x-organization
<nil> INF generating transit keys
<nil> INF generating key pair
<nil> INF attempting to push transit public key to the transit servers
<nil> INF successfully pushed transit public key to the transit servers
```

## Step 3 - Start Your Flow Node

Ensure you have configured your node using the [Node Setup guide](./node-setup.mdx).

### Confirming authorization

You can confirm your node's successful registration and authorization by executing a Cadence script to query the [Staking Contract](../../../references/core-contracts/06-staking-contract-reference.md#contract).
At the end of the `Staking Auction Phase`, the members of the Proposed Identity Table are confirmed as authorized participants in the next epoch.
Therefore, if your node ID appears in the Proposed Identity Table during the `Staking Auction Phase`, your node will be a participant in the next epoch.

You can read the current Proposed Identity Table using the [getProposedTable script](https://github.com/onflow/flow-core-contracts/blob/master/transactions/idTableStaking/scripts/get_proposed_table.cdc).

You can read the current epoch phase using the [getEpochPhase script](https://github.com/onflow/flow-core-contracts/blob/master/transactions/epoch/scripts/get_epoch_phase.cdc). (A return value of `0` indicates the `Staking Auction Phase`.)

### Trusted Root Snapshot

Once your node has been registered and authorized by the service account, it will be able to participate in the next epoch.

![Flow Epoch Schedule](https://storage.googleapis.com/flow-resources/documentation-assets/epoch-startup-order.png)

A new node must bootstrap with a trusted root snapshot of the protocol state, where the node is a confirmed participant.
Since new nodes are confirmed at the end of the `Staking Auction Phase`, this means that, if the node is registered to join at epoch `N+1`, it must use a root snapshot from within the `Epoch Setup Phase` of epoch `N`.

### Dynamic Startup

Flow provides a mechanism called Dynamic Startup to simplify the process of obtaining the root snapshot.
When using Dynamic Startup, the node can be started **at any time during the `Staking Auction Phase`**.
The node will wait for the `Epoch Setup Phase` to begin, retrieve a valid root snapshot from a trusted Access Node, then bootstrap its state and join the network.
This is the recommended way to start your node for the first time.

1. Remove any `root-protocol-state-snapshot.json` file from your `bootstrap` folder. (If this file is present the node will attempt to bootstrap with it rather than Dynamic Startup.)
2. Select a trusted Access Node to provide the root snapshot. You will need this node's **secure GRPC server address** and **Networking Public Key**.
3. Configure Dynamic Startup by adding flags:
```shell ExampleDynamicStartupFlags
  ... \
  --dynamic-startup-access-address=secure.mainnet.nodes.onflow.org:9001 \
  --dynamic-startup-access-publickey=28a0d9edd0de3f15866dfe4aea1560c4504fe313fc6ca3f63a63e4f98d0e295144692a58ebe7f7894349198613f65b2d960abf99ec2625e247b1c78ba5bf2eae
```
4. Start your node (see [guide](./node-setup#start-the-node))

<Callout type="info">
Once the node has bootstrapped, these flags may be removed.
</Callout>

### Manually Provisioned Root Snapshot

You can also provision the root snapshot file manually, then start the node without configuring Dynamic Startup.
A snapshot can be obtained from any Access Node using [Flow CLI](../../../tools/flow-cli/index.md).
```shell RetrieveRootSnapshot
flow snapshot save /path/to/root/snapshot --network mainnet
```

<Callout type="warning">

The snapshot must be within the `Epoch Setup Phase`.

</Callout>

<Callout type="warning">

Since Collection and Consensus Nodes must start up in the first ~30mins of the `Epoch Setup Phase` (see [Timing](./node-bootstrap.mdx#timing)),
the snapshot must be provisioned within this time window.

</Callout>

Once a valid root snapshot file is downloaded to the node's bootstrap folder, it can be started (see [guide](./node-setup.mdx#start-the-node))
---
title: Node Migration
description: How to migrate a Flow node from one machine to another
---

There are a few different methods to migrate a running Flow node from one machine to the other.

Choose the method depending upon what part of the staking data of the node is changing.

### Method 1 - No change to the node staking data

If there is no change to the network address or the staking and networking keys and only the hardware the node is running needs to be changed then do the following:
1. Stop the Flow node.
2. Copy over the bootstrap data (typically under `/var/flow/bootstrap`) which contains the node private key to the new machine.
3. Copy over the data folder (typically under `/var/flow/data`) which contains the state data.
4. Start the new node on the same network address as the old one.

<Callout type="warning">
Please ensure that there is minimal downtime during this migration.
</Callout>

<Callout type="warning">
The network address is currently part of the staking data that was submitted for the node. It is how other nodes in the network discover this node.
Hence, the network address of the node must stay the same between epochs otherwise the node will become unreachable for the other nodes and stop functioning.
</Callout>

### Method 2 - Network address change

A change to the node network address (IP or a hostname) can only be done during the spork process.

To change the networking address:
1. A day before the [upcoming mainnet spork](./upcoming-sporks), change the network address for the nodes in Flow Port (using the update network address feature).
The change will not take effect till an epoch transition happens.
2. Change the addresses in the `/var/flow/bootstrap/private-root-information/private-node-info_<nodeid>/node-info.priv.json` json file on the node.
3. A spork also causes an epoch transition, and the new addresses will take effect after the spork immediately.

### Method 3 - Staking or networking key change

If the node after migration will be using new staking or networking keys then it needs to be unstaked and then re-staked with the new keys.

1. Unstake the node via Flow Port.
2. Register the new node via Flow Port with the new staking information.
3. Run the new node with the new keys and network address. It should be able to join the network at the next epoch (see [timing](./node-bootstrap.mdx#timing))

<Callout type="warning">
Unstaking a node will result in the node [not earning rewards](../staking/06-technical-overview.mdx#staking-operations-available-to-all-stakers) for the next epoch.
Delegators to the old node will have their tokens unstaked automatically. They will also stop earning rewards unless they withdraw their unstaked tokens and delegate them to a different node.
</Callout>---
title: Provisioning a Flow node
sidebar_label: Node Provisioning
description: Hardware, networking and Operating system setup for a Flow node
---

## Hardware Requirements

The hardware your Node will need varies depending on the role your Node will play in the Flow network. For an overview of the differences see the [Node Roles Overview](./node-roles.mdx).

| Node Type | CPU | Memory | Disk | Example GCP Instance | Example AWS Instance |
|:----------------:| ---------:| ------:| ------:|:--------------:|:--------------:|
| **Collection**   |  4 cores  | 32 GB  | 200 GB | n2-highmem-4   | r6i.xlarge     |
| **Consensus**    |  2 cores  | 16 GB  | 200 GB | n2-standard-4  | m6a.xlarge     |
| **Execution**    | 64 cores  | 800 GB |  9 TB  | n2-highmem-128 | r6i.32xlarge   |
| **Verification** |  2 cores  | 16 GB  | 200 GB | n2-highmem-2   | r6a.large      |
| **Access**       |  4 cores | 16 GB  | 750 GB | n2-standard-4   | m6i.xlarge     |
| **Observer**     |  2 cores  | 4 GB   | 300 GB | n2-standard-4  | m6i.xlarge     |
| **Archive**      | 32 cores  | 800 GB |  2 TB  | m3-ultramem-32 | x2idn.16xlarge |

_Note: The above numbers represent our current best estimate for the state of the network. These will be actively updated as we continue benchmarking the network's performance._

## Networking Requirements

Most of the load on your nodes will be messages sent back and forth between other nodes on the network. Make sure you have a sufficiently fast connection; we recommend at _least_ 1Gbps, and 5Gbps is better.

Each node will require either a static IPv4 address or a fixed DNS name. Either works, and we'll refer to this more generally as your 'Node Address' from here on out.

<Callout type="info" title="Node Address Requirements">
    Your Node Address must be a publicly routable IPv4 address or valid DNS name
    that points to your node. This is how other nodes in the network will
    communicate with you.
</Callout>

While both a static IPv4 and a domain name are possible, we prefer and recommend that node operators register their node under a domain that they control. This gives the Flow network more options for resiliency and resistance to adverse network conditions.

<Callout type="warning" title="Registering a domain name for your Flow Node">
    Crash recovery and denial of service attacks are two concerns that operators can mitigate relying on each of DNS indirection and IP routing. The later requires more involvement.

    Running a node behind an operator-controlled hostname (rather than "just" an IP) is a simple and cheap measure that:

    - offers additional technical pathways to let operators improve resiliency and security,
    - lets them opt in to those measures as a reaction to an attack,
    - does not preclude any lower-level IP-based resiliency approaches.

</Callout>

Your firewalls must expose **TCP/3569** for Node communication. If you are running an Access Node, you must also expose the GRPC port **9000**.

![Flow Architecture](flow-architecture.png)

## Operating System Requirements

The Flow node code is distributed as a Linux container image, so your node must be running an OS with a container runtime like [docker](https://docker.com) or [containerd](https://containerd.io).

The bootstrapping scripts we'll use later are compiled binaries targeting an `amd64` architecture, so your system must be 64-bit. Some of these scripts are bash based hence a shell interpreter that is bash compatible will also be needed.

Flow also provides `systemd` service and unit files as a template for installation, though `systemd` is not required to run Flow.

<Callout type="info" title="Choose Your Own Adventure">
    Flow is distributed in such a way that makes it very system agnostic. You are
    free to build your own orchestration around how you run your nodes and manage
    your keys.

    For the remainder of this guide, we cover the most simple case, a single node being
    hand deployed. This should give you a good sense of what's needed, and you can
    modify to suit your needs from there.

    The Flow team has tested running nodes on Ubuntu 18.04 and GCP's Container
    Optimized OS, which is based on Chromium OS. If you are unsure where to start,
    those are good choices.
</Callout>

## Time synchronization

You should also ensure you run **time synchronization** on the machine hosting the container, to avoid clock drift. In practice, this means configuring a client for the NTP protocol, and making sure it runs as a daemon. `ntpd` is one recommended example. To configure it, you just have to point it to an NTP server to query periodically. A default from your Linux distribution or cloud operator may already be set, and in the interest of decentralization, our recommendation would be to use it unless you have a specific reason to do otherwise.

<Callout type="info" title="Time synchronization FAQ">

    - **Leap-smearing**: Leap-smearing time servers and non-leap-smearing time servers are both acceptable for the magnitude of our time precision requirements - though considering very few providers offer leap smearing time servers, a "regular" time server helps ensure our pool of time providers is more diverse.

    - **Why not do it in the container itself? Why do we need to do this?**:  Without special privileges and in all major container runtimes, a container will not run with the `CAP_SYS_TIME` capability. For Flow, this means that the node software itself cannot change the time of the host machine, making the in-container use of standard time synchronization protocols ineffective.

    - **Why does time matter in Flow?**: Time information comes up in consensus and in smart contracts. The consensus algorithm of Flow allows nodes to exit the influence of a corrupt or ineffective "leader" node by collectively deciding to switch to the next "phase" of the protocol at the right time. The smart contract language also allows developer access to block time stamps, which provide an approximation of time. To resist manipulation in each case, honest nodes must compute timing values from an aggregate of the information provided by all nodes. That approach, though resilient, is still sensitive to inaccurate time information. In other words, a node subject to clock drift but otherwise honest will not stop the consensus, but might make it slower.

</Callout>

## Setup Data Directories & Disks

Flow stores protocol state on disk, as well as execution state in the case of execution nodes.

Where the data is stored is up to you. By default, the `systemd` files that ship with Flow use `/var/flow/data`.
This is where the vast majority of Flow's disk usage comes from, so you may wish to mount this directory on a separate disk from the OS.
The performance of this disk IO is also a major bottleneck for certain node types.
While all nodes need to make use of this disk, if you are running an execution node, you should make sure this is a high performing SSD.

As a rough benchmark for planning storage capacity, each Flow block will grow the data directory by 3-5KiB.

### Confidential Data & Files

Flow stores dynamically generated confidential data in a separate database. We strongly recommend enabling encryption
for this database - see [this guide](./db-encryption-existing-operator.mdx) for instructions.

Confidential information used by Flow is stored in the `private-root-information` subtree of the `bootstrap` folder.
In particular:
* the staking private key (`node-info.priv.json`)
* the networking private key (`node-info.priv.json`)
* the encryption key for the secrets database (`secretsdb-key`)
* (if applicable) the initial random beacon private key (`random-beacon.priv.json`)

These files contain confidential data, and must be stored and accessed securely.

---
title: Node Roles
---

Unlike most blockchains, not all Flow nodes are equal. Flow nodes all specialize and fulfill a specific role in the operation of the network.
Collection, consensus, execution, verification and access nodes are all staked nodes while the observer node is not staked.

## Collection

Collection nodes are bandwidth-optimized nodes divided by the protocol into several cooperating Clusters. Their first task is managing the transaction pool and collecting well-formed transactions to propose to Consensus nodes. Transactions are assigned to a cluster pseudorandomly by transaction hash. A well-formed transaction must include credentials from the guarantor of the transaction. When a Collection Node sees a well-formed transaction, it hashes the text of that transaction and signs the transaction to indicate two things: first, that it is well-formed; and second, that it will commit to storing the transaction text until the Execution nodes have finished processing it. Each cluster collects transactions, assembles them into Collections and submits a Collection Guarantee signed by a super-majority of the cluster to the Consensus nodes.

Collection nodes are required to stake a minimum of 250,000 FLOW to be a confirmed node operator.

## Consensus

Consensus nodes form and propose blocks in a manner similar to traditionally-structured proof-of-stake blockchains, using the HotStuff consensus algorithm to create a globally consistent chain of blocks. Consensus nodes validate that the signed collection hashes submitted to them by Collection nodes were, in fact, signed by the required majority of Collection nodes. Thereafter, the Consensus nodes assemble the transactions into blocks and finalize them through voting.
The more participants there are in this process, the more decentralized the network. However, consensus algorithms typically bottleneck the limit to the number of participants. The Flow protocol chose the HotStuff algorithm because it is flexible enough to add participants and currently supports about 100 operators. Adding more than 100 participants to the protocol by adapting HotStuff will continue to be an area of active development.

Consensus nodes act as checkpoints against other Collection nodes. They are responsible for checking that a critical number of Collection nodes reviewed and signed for the transaction. Collection nodes are held accountable by Consensus nodes. A common concern with proof-of-work- and proof-of-stake based systems is that a small subset of the population of nodes can control important resources such as the mining or stake needed to produce and vote on blocks, which is a degradation of the security of the system. By lowering the requirements to participate, Flow makes it extremely difficult and expensive to coordinate a Byzantine majority of Consensus nodes.

Consensus nodes have minimal bandwidth and computation requirements, allowing even a modest computing device (any consumer-grade hardware) to participate in the voting process and ensure the safety of the network. Many networks claim open participation, yet substantial resources — stake, computation, or otherwise — are needed to partake. Maintaining such barriers to entry undermines the security of the network. Lowering the participation requirements preserves the security of the network by providing a high degree of byzantine fault tolerance since it becomes exceedingly difficult for a subset of bad actors to subvert the network.

Consensus nodes are required to stake a minimum of 500,000 FLOW to be a confirmed node operator.

## Execution

Execution nodes are the most resource-intensive nodes on the Flow network, responsible for executing transactions and maintaining the Execution State — a cryptographically-verifiable data store for all user accounts and smart contract states — as well as responding to queries related to it. Execution nodes compute the outputs of the blocks they are provided. They then ask the Collection nodes for the collections which contain transactions waiting to be executed. With this data they are able to compute the output, which is later verified by Verification nodes to ensure honesty (allocation of Verification nodes is via a sortition algorithm). The Execution nodes are primarily responsible for Flow's improvements in scale and efficiency because only a very small number of these powerful compute resources are required to compute and store the historical state.

Execution nodes give the Flow network its performance characteristics: highly scalable within a single shared state environment (i.e., no sharding). However, the significant hardware requirements make them the least accessible option for participation as a Validator. Because the revenue pool splits between relatively few nodes, the revenue per-node should more than compensate for the high capital costs of operating this node.

An Execution Node presents a hashed commitment once it has computed the output. The output is only revealed once its co-executors have also submitted their outputs. This is important to ensure nodes aren't spoofing each other's work. Once they've all submitted their answers, the output is revealed and subjected to random queries and checks run by Verification nodes. The Execution nodes have relatively low byzantine fault tolerance. However, this does not compromise the overall security of the system because the process they perform is deterministic -- any bad actor will easily be detected and punished by Verification nodes.

This relatively small group of nodes has the most substantial technical requirements for processor speed and bandwidth because they are tasked with all the computations necessary to determine the output of the network. Allowing for this degree of specialization can reduce computation costs by at least one thousand times, and possibly much more, when compared to Ethereum.

Execution nodes are required to stake a minimum of 1,250,000 FLOW to be a confirmed node operator.

## Verification

Verification nodes are responsible for confirming the correctness of the work done by Execution nodes. Individual Verification nodes only check a small amount of the total computation, but collectively they check every computation many times in parallel. Verification nodes verify Execution Receipts provided by Execution nodes and issue Result Approvals. A sortition algorithm determines which chunks of the Execution Receipt from the Execution nodes the Verification Node must query to check they were computed correctly. Ultimately, these nodes keep the Execution nodes honest; this balance of power maintains the access, security, and verifiability criteria of decentralization. It is highly byzantine fault tolerant because even if there is a substantial number of byzantine errors in the Verification Node
pool, the Consensus nodes are still required to approve that transactions they signed were reviewed by a critical amount of the network.

Verification nodes are required to stake a minimum of 135,000 FLOW to be a confirmed node operator.

## Access

Access nodes act as a proxy to the Flow network. The Access node routes transactions to the correct collection node and routes state queries to execution nodes (while likely caching state to answer queries in a timely manner in the future). Clients submit their transactions to any Access node or run their own if they can't find a service provider they're happy with.

Access nodes are required to stake 100 FLOW to be a confirmed node operator. However, since an access node does not participate in block production, it does not receive any staking rewards.

## Observer

An observer node provides locally accessible, continuously updated, verified copy of the block data. It serves the Access API but unlike an access node, an observer node does not need to be staked, and **anyone** can run it without being added to the approved list of nodes.

[Get started running an observer node](./observer-node.mdx)

## Archive

The Archive node provides a scalable and efficient way to access the history of Flow protocol and the execution state for the current spork.

This node can be run by anyone without being staked or added to the approved list of nodes. The Archive node follows the chain, stores and indexes both protocol and execution state, and allows retrieval of blocks, collections, transactions and events from the genesis of the current spork.

It also allows script execution and other read-only queries that require the execution state to be read.

##

Here is a comparison of the different node roles,

| Role            | Staked  | Recives Rewards | Permissioned |
| :---------------|:---------------:| :---------------:|:---------------:|
| Collection      | Yes             | Yes              | Yes             |
| Consensus       | Yes             | Yes              | Yes             |
| Execution       | Yes             | Yes              | Yes             |
| Verification    | Yes             | Yes              | Yes             |
| Access          | Yes             | No               | No 🆕           |
| Observer        | No              | No               | No              |
| Archive         | No              | No               | No              |
---
title: Setting Up a Flow Node
sidebar_label: Node Setup
description: How to run a Collection, Consensus, Verification and Execution node
---

This guide is for running a Collection, Consensus, Verification and Execution node.
If you are planning to run an Access node then refer to [access node setup](./access-node-setup.md).

First you'll need to provision a machine or virtual machine to run your node software. Please see follow the [node-provisioning](./node-provisioning.mdx) guide for it.

## Pull the Flow Images

The `flow-go` binaries are distributed as container images, and need to be pulled down to your host with your image management tool of choice.

Replace `$ROLE` with the node type you are planning to run. Valid options are:

- collection
- consensus
- execution
- verification
- access

```shell
  # Docker
  docker pull gcr.io/flow-container-registry/${ROLE}:alpha-v0.0.1

  # Containerd
  ctr images pull gcr.io/flow-container-registry/${ROLE}:alpha-v0.0.1",
```

## Prepare Your Node to Start

Your nodes will need to boot at startup, and restart if they crash.

If you are running `systemd` you can use the service files provided by `flow-go`.
Find them in the [Flow Go](https://github.com/onflow/flow-go/tree/master/deploy).

If you are using some other system besides Systemd, you need to ensure that the Flow container is started,
the appropriate key directories are mounted into the container, and that the container will
automatically restart following a crash.

The `systemd` files pull runtime settings from `/etc/flow/runtime-config.env` and any `.env`
files under `/etc/flow/conf.d`. Examples of these files are also available in the github repo.
You will need to modify the runtime config file later.

### Systemd

<Callout type="info">
If you are not using Systemd, you can skip this step
</Callout>

1. Ensure that you pulled the latest changes from [flow-go repository](https://github.com/onflow/flow-go) via `git`

```shell
## Clone the repo if you haven't already done so
git clone https://github.com/onflow/flow-go

## Get latest changes
cd flow-go
git pull origin master
```

2. Copy your respective [systemd unit file](https://github.com/onflow/flow-go/tree/master/deploy/systemd-docker) to: `/etc/systemd/system`
3. Create directory `sudo mkdir /etc/flow`
4. Copy the [runtime-conf.env](https://github.com/onflow/flow-go/blob/master/deploy/systemd-docker/runtime-conf.env) file to: `/etc/flow/`
5. Enable your service `sudo systemctl enable flow-$ROLE.service` (replace `$ROLE` with your node role - eg. `collection`)

### Docker Configuration

If you are not using Systemd, sample commands for running each Docker container are below.
Be sure to replace `/path/to/data` and `/path/to/bootstrap` with the appropriate paths you are using.

<Callout type="warning">
Do not run your node using `docker run` command directly without a mechanism for the node
to automatically restart following a crash.
</Callout>

<Callout type="info">
    The actual Docker image tag can be found [here](./past-sporks.mdx) for appropriate spork.
</Callout>

### System Configuration

Flow nodes create connections to other nodes on the network, which are represented as file descriptors by the OS. Depending on the default
limits for your machine, you may need to increase the soft limit available to the node software.

Make sure the soft limit is at least `8192`.

You can configure the ulimit for the node's docker container. See the [Docker documentation](https://docs.docker.com/engine/reference/commandline/run/#ulimit) for more details.

### Admin Server

Each node can be configured with an admin server, which allows you to control some of the node's configuration, as well as view some of its internal state. You can find
a few of the commands in the Admin Server [README](https://github.com/onflow/flow-go/blob/master/admin/README.md). Two commands to highlight are:

* `list-commands`: which returns a list of all of the available commands for your node
* `set-log-level`: which allows you to change the log level of your node at runtime

You can enable the admin server by passing the `--admin-addr` flag with an interface and port.

> ⚠️ _IMPORANT: The admin server can modify your node's configuration. DO NOT allow access to untrusted clients._

### Access

```shell
docker run --rm \
	-v /path/to/bootstrap:/bootstrap:ro \
	-v /path/to/data:/data:rw \
	--name flow-go \
	--network host \
	--ulimit nofile=8192 \
	gcr.io/flow-container-registry/access:<applicable docker tag> \
	--nodeid=${FLOW_GO_NODE_ID} \
	--bootstrapdir=/bootstrap \
	--datadir=/data/protocol \
	--secretsdir=/data/secrets \
	--execution-data-dir=/data/execution_data \
	--rpc-addr=0.0.0.0:9000 \
	--http-addr=0.0.0.0:8000 \
	--admin-addr=0.0.0.0:9002 \
	--collection-ingress-port=9000 \
	--script-addr=${FLOW_NETWORK_EXECUTION_NODE} \
	--bind 0.0.0.0:3569 \
	--loglevel=error
```

### Collection

```shell
docker run --rm \
	-v /path/to/bootstrap:/bootstrap:ro \
	-v /path/to/data:/data:rw \
	--name flow-go \
	--network host \
	--ulimit nofile=8192 \
	gcr.io/flow-container-registry/collection:<applicable docker tag> \
	--nodeid=${FLOW_GO_NODE_ID} \
	--bootstrapdir=/bootstrap \
	--datadir=/data/protocol \
	--secretsdir=/data/secrets \
	--ingress-addr=0.0.0.0:9000 \
	--admin-addr=0.0.0.0:9002 \
	--bind 0.0.0.0:3569 \
	--loglevel=error
```

### Consensus

```shell
docker run --rm \
	-v /path/to/bootstrap:/bootstrap:ro \
	-v /path/to/data:/data:rw \
	--name flow-go \
	--network host \
	--ulimit nofile=8192 \
	gcr.io/flow-container-registry/consensus:<applicable docker tag> \
	--nodeid=${FLOW_GO_NODE_ID} \
	--bootstrapdir=/bootstrap \
	--datadir=/data/protocol \
	--secretsdir=/data/secrets \
	--admin-addr=0.0.0.0:9002 \
	--bind 0.0.0.0:3569 \
	--loglevel=error
```

### Execution

```shell
docker run --rm \
	-v /path/to/bootstrap:/bootstrap:ro \
	-v /path/to/data:/data:rw \
	--name flow-go \
	--network host \
	--ulimit nofile=500000 \
	gcr.io/flow-container-registry/execution:<applicable docker tag> \
	--nodeid=${FLOW_GO_NODE_ID} \
	--bootstrapdir=/bootstrap \
	--datadir=/data/protocol \
	--secretsdir=/data/secrets \
	--triedir=/data/execution \
	--execution-data-dir=/data/execution_data \
	--rpc-addr=0.0.0.0:9000 \
	--admin-addr=0.0.0.0:9002 \
	--bind 0.0.0.0:3569 \
	--loglevel=error
```

For execution nodes, it is recommend to increase the open files limit in your operating system. To do that, add the following to your `/etc/security/limits.conf` or the equivalent `limits.conf` for your distribution:

```
* hard nofile 500000
* soft nofile 500000
root hard nofile 500000
root soft nofile 500000
```

Restart your machine to apply these changes. To verify that the new limits have been applied, run:

```
ulimit -n
```

### Verification

```shell
docker run --rm \
	-v /path/to/bootstrap:/bootstrap:ro \
	-v /path/to/data:/data:rw \
	--name flow-go \
	--network host \
	--ulimit nofile=8192 \
	gcr.io/flow-container-registry/verification:<applicable docker tag> \
	--nodeid=${FLOW_GO_NODE_ID} \
	--bootstrapdir=/bootstrap \
	--datadir=/data/protocol \
	--secretsdir=/data/secrets \
	--admin-addr=0.0.0.0:9002 \
	--bind 0.0.0.0:3569 \
	--loglevel=error
```

### Archive

```shell
 docker run --rm \
	-v /path/to/data:/data:rw \
	--network host \
	--label=project=flow \
	--label=network=mainnet
	--label=app=dps
	--label=version=v0.26
	--name flow-dps gcr.io/flow-container-registry/flow-dps-live:v0.26.1
	--address 0.0.0.0:5005
	--index /data/index
	--bootstrap /data/bootstrap
	--checkpoint /data/bootstrap/root.checkpoint
	--data /data/protocol
	--level debug
	--metrics 0.0.0.0:8080
	--bucket bucket_name
	--seed-address=access_node_address
	--seed-key=seed_key
```

## Start the Node

Now that your node is provisioned and configured, it can be started.

<Callout type="warning">

Before starting your node, ensure it is [registered](./node-bootstrap.mdx#step-2---stake-your-node) and [authorized](./node-bootstrap.mdx#confirming-authorization).

</Callout>

Ensure you start your node at the appropriate time.
See [Spork Process](./spork.mdx) for when to start up a node following a spork.
See [Node Bootstrap](./node-bootstrap.mdx#timing) for when to start up a newly registered node.

### Systemd

1. Check that your `runtime-conf.env` is at `/etc/flow/runtime-conf.env`
2. Update your environment variables: `source /etc/flow/runtime-conf.env`
3. Start your service: `sudo systemctl start flow`

## Verify your Node is Running


Here are a few handy commands that you can use to check if your Flow node is up and running

### Systemd

- To get Flow logs: `sudo journalctl -u flow-YOUR_ROLE`
- To get the status: `sudo systemctl status flow`

```shell
● flow-verification.service - Flow Access Node running with Docker
Loaded: loaded (/etc/systemd/system/flow-verification.service; enabled; vendor preset: enabled)
Active: active (running) since Wed 2020-05-20 18:18:13 UTC; 1 day 6h ago
Process: 3207 ExecStartPre=/usr/bin/docker pull gcr.io/flow-container-registry/verification:${FLOW_GO_NODE_VERSION} (code=exited, status=0/SUCCESS)
Main PID: 3228 (docker)
Tasks: 10 (limit: 4915)
Memory: 33.0M
CGroup: /system.slice/flow-verification.service
        └─3228 /usr/bin/docker run --rm -v /var/flow/bootstrap:/bootstrap:ro -v /var/flow/data:/data:rw --rm --name flow-go --network host gcr.io/flow-container-registry/verification:candidate8 --nodeid=489f8a4513d5bd8b8b093108fec00327b683db545b37b4ea9153f61b2c0c49dc --bootstrapdir=/bootstrap --datadir=/data/protocol --alpha=1 --bind 0.0.0.0:3569 --loglevel=error
```

### Docker

- To get Flow logs: `sudo docker logs flow-go`
- To get the status: `sudo docker ps`

```shell
$ sudo docker ps
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
1dc5d43385b6 gcr.io/flow-container-registry/verification:candidate8 \"/bin/app --nodeid=4…\" 30 hours ago Up 30 hours flow-go
```

## Monitoring and Metrics

This is intended for operators who would like to see what their Flow nodes are currently doing. Head over to [Monitoring Node Health](./monitoring-nodes.mdx) to get setup.

### Node Status

The metrics for the node should be able to provide a good overview of the status of the node. If we want to get a quick snapshot of the status of the node, and if it's properly participating in the network, you can check the `consensus_compliance_finalized_height` or `consensus_compliance_sealed_height` metric, and ensure that it is not zero and strictly increasing.

```shell
curl localhost:8080/metrics | grep consensus_compliance_sealed_height

# HELP consensus_compliance_sealed_height the last sealed height
# TYPE consensus_compliance_sealed_height gauge
consensus_compliance_sealed_height 1.132054e+06
```
---
title: Light Node a.k.a Observer Node
sidebar_label: Light Node
---

A light node also known as the observer node is similar to an access node and provides a locally accessible, continuously updated, verified copy of the block data. It serves the [gRPC Access API](../../../references/run-and-secure/nodes/access-api.mdx) but unlike an access node, an light node does not need to be staked, and **anyone** can run it without being added to the approved list of nodes.

The light node bootstraps by connecting to an access node and becoming part of the public network comprised of access nodes and other light nodes. It then continuously receives blocks, which the consensus nodes are adding to the chain, either directly from access nodes or from other light nodes that are part of the public network. However, it makes no trust assumption of the upstream access node or the light node which is providing the block and locally verifies that the blocks that are received are the correct extension of the chain e.g. after receiving valid blocks A, B and C when it receives block D, it verifies that block D is indeed signed by the consensus nodes and is a valid next block. The received block data is indexed and made available via the Access API. For Collection, Transactions and Account queries, it delegates those requests to the upstream access node. Similarly, transactions and scripts sent to a light node are also forwarded to the upstream access node. Future versions of the light node will be able to serve this data locally as well.

Since the light node is not staked, it does not produce or execute blocks but instead serves as an _unstaked access node_ that can be easily run on any consumer-grade computer which has enough disk space.

![Observer nodes](observer.png)

## Who should run a light node?

The light node provides an alternative to running an access node. Hence, it is ideal for Dapps that need access to the latest block data locally on a machine they control. Examples include a wallet application that needs to track the latest block ID and height. Alternatively, access node operators that want to scale their access node endpoints geographically can spin up light nodes in different regions, which can talk to their staked access node and to each other.

## Running an light node

### Hardware

In general, any consumer-grade computer with a decent network connection and sufficient disk space should be able to run a light node.

Minimum requirements

- CPU with 2+ cores
- 4 GB RAM minimum
- 300 GB SSD disk
- 10Mbps network connection

### Steps to run a light node

> [Here](https://www.loom.com/share/990a725531754106b91d8ccec6244219) is video walk-though of these 👇 steps.

#### Step 1 - Generate the node directory structure
The light node requires the following directory structure,
```shell
$ tree flow_observer
flow_observer/
├── bootstrap
│         ├── network.key (file containing the node private network key)
│         └── public-root-information
│             └── root-protocol-state-snapshot.json (the genesis data of the current spork)
└── data (directory used by the light node to store block data)
```

Create the parent and the sub-directories
e.g.
```shell
mkdir -p flow_observer/bootstrap/public-root-information
mkdir flow_observer/data
```

#### Step 2 - Generate the network key

Like any other Flow node, the light node also needs a networking [ECDSA key](https://github.com/onflow/flow-go/blob/master/cmd/bootstrap/utils/key_generation.go#L52-L54) to talk to the network.
Download the Bootstrapping kit, and generate the networking key.

```shell
curl -sL -O storage.googleapis.com/flow-genesis-bootstrap/boot-tools.tar
tar -xvf boot-tools.tar
./boot-tools/bootstrap observer-network-key  --output-file  ./flow_observer/bootstrap/network.key
```

_If you are running on a mac, download the boot-tools for mac to generate the key_
```shell
# For M1
curl -sL -O storage.googleapis.com/flow-genesis-bootstrap/boot-tools-m1.tar
# For Intel Mac
curl -sL -O storage.googleapis.com/flow-genesis-bootstrap/boot-tools-intel-mac.tar
```

#### Step 3 - Download the root-protocol-state-snapshot.json file for the current spork

The `root-protocol-state-snapshot.json` is generated for each [spork](./spork.mdx) and contains the genesis data for that spork.
It is published and made available after each spork. The download location is specified [here](https://github.com/onflow/flow/blob/master/sporks.json) under [rootProtocolStateSnapshot](https://github.com/onflow/flow/blob/master/sporks.json#L16) and can be downloaded as follows,

For mainnet find  the latest spork version from [sporks.json](https://github.com/onflow/flow/blob/master/sporks.json) and then download the `root-protocol-state-snapshot.json` and the signature file for it.

```shell
wget -P ./flow_observer/bootstrap/public-root-information https://storage.googleapis.com/flow-genesis-bootstrap/mainnet-<spork version>-execution/public-root-information/root-protocol-state-snapshot.json
wget -P ./flow_observer/bootstrap/public-root-information https://storage.googleapis.com/flow-genesis-bootstrap/mainnet-<spork version>-execution/public-root-information/root-protocol-state-snapshot.json.asc
```

Similarly, for testnet find  the latest spork version from [sporks.json](https://github.com/onflow/flow/blob/master/sporks.json) and then download the `root-protocol-state-snapshot.json` and the signature file for it.
```shell
wget -P ./flow_observer/bootstrap/public-root-information https://storage.googleapis.com/flow-genesis-bootstrap/testnet-<spork version>/public-root-information/root-protocol-state-snapshot.json
wget -P ./flow_observer/bootstrap/public-root-information https://storage.googleapis.com/flow-genesis-bootstrap/testnet-<spork version>/public-root-information/root-protocol-state-snapshot.json.asc
```

##### Verify the PGP signature

Add the `flow-signer@onflow.org` public key
```shell
gpg --keyserver keys.openpgp.org --search-keys flow-signer@onflow.org

gpg: data source: http://keys.openpgp.org:11371
(1)	Flow Team (Flow Full Observer node snapshot verification master key) <
	  256 bit ECDSA key CB5264F7FD4CDD27, created: 2021-09-15
Keys 1-1 of 1 for "flow-signer@onflow.org".  Enter number(s), N)ext, or Q)uit > 1
```

Verify the root-snapshot file
```shell
gpg --verify ./flow_observer/bootstrap/public-root-information/root-protocol-state-snapshot.json.asc

gpg: assuming signed data in 'bootstrap/public-root-information/root-protocol-state-snapshot.json'
gpg: Signature made Wed Sep 15 11:34:33 2021 PDT
gpg:                using ECDSA key 40CD95717AC463E61EE3B285B718CA310EDB542F
gpg: Good signature from "Flow Team (Flow Full Observer node snapshot verification master key) <flow-signer@onflow.org>" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: 7D23 8D1A E6D3 2A71 8ECD  8611 CB52 64F7 FD4C DD27
     Subkey fingerprint: 40CD 9571 7AC4 63E6 1EE3  B285 B718 CA31 0EDB 542F
```

Alternately, if you don't care about the blocks before the current block, you can request the current root-snapshot file via the [Flow CLI](../../../tools/flow-cli/index.md).

For mainnet
```shell
 flow snapshot save ./flow_observer/bootstrap/public-root-information/root-protocol-state-snapshot.json --host secure.mainnet.nodes.onflow.org:9001 --network-key 28a0d9edd0de3f15866dfe4aea1560c4504fe313fc6ca3f63a63e4f98d0e295144692a58ebe7f7894349198613f65b2d960abf99ec2625e247b1c78ba5bf2eae
```

For testnet
```shell
flow snapshot save ./flow_observer/bootstrap/public-root-information/root-protocol-state-snapshot.json --host secure.testnet.nodes.onflow.org:9001 --network-key ba69f7d2e82b9edf25b103c195cd371cf0cc047ef8884a9bbe331e62982d46daeebf836f7445a2ac16741013b192959d8ad26998aff12f2adc67a99e1eb2988d
```

#### Step 4 - Start the node

The light node can be run as a docker container

##### Observer for Flow Mainnet

```shell
docker run --rm \
 -v $PWD/flow_observer/bootstrap:/bootstrap:ro  \
 -v $PWD/flow_observer/data:/data:rw \
 --name flow_observer \
 -p 80:80 \
 -p 3569:3569 \
 -p 9000:9000 \
 -p 9001:9001 \
 gcr.io/flow-container-registry/observer:v0.27.2 \
 --bootstrapdir=/bootstrap \
 --datadir=/data/protocol \
 --bind 0.0.0.0:3569  \
 --rest-addr=:80 \
 --loglevel=error \
 --secretsdir=/data/secrets  \
 --upstream-node-addresses=access-008.mainnet23.nodes.onflow.org:9001 \
 --upstream-node-public-keys=11742552d21ac93da37ccda09661792977e2ca548a3b26d05f22a51ae1d99b9b75c8a9b3b40b38206b38951e98e4d145f0010f8942fd82ddf0fb1d670202264a \
 --bootstrap-node-addresses=access-008.mainnet23.nodes.onflow.org:3570  \
 --bootstrap-node-public-keys=11742552d21ac93da37ccda09661792977e2ca548a3b26d05f22a51ae1d99b9b75c8a9b3b40b38206b38951e98e4d145f0010f8942fd82ddf0fb1d670202264a \
 --observer-networking-key-path=/bootstrap/network.key
```

##### Observer for Flow Testnet

```shell
docker run --rm \
 -v $PWD/flow_observer/bootstrap:/bootstrap:ro  \
 -v $PWD/flow_observer/data:/data:rw \
 --name flow_observer \
 -p 80:80 \
 -p 3569:3569 \
 -p 9000:9000 \
 -p 9001:9001 \
 gcr.io/flow-container-registry/observer:v0.27.2 \
 --bootstrapdir=/bootstrap \
 --datadir=/data/protocol \
 --bind 0.0.0.0:3569  \
 --rest-addr=:80 \
 --loglevel=error \
 --secretsdir=/data/secrets  \
 --upstream-node-addresses=access-003.devnet47.nodes.onflow.org:9001 \
 --upstream-node-public-keys=b662102f4184fc1caeb2933cf87bba75cdd37758926584c0ce8a90549bb12ee0f9115111bbbb6acc2b889461208533369a91e8321eaf6bcb871a788ddd6bfbf7 \
 --bootstrap-node-addresses=access-003.devnet47.nodes.onflow.org:3570  \
 --bootstrap-node-public-keys=b662102f4184fc1caeb2933cf87bba75cdd37758926584c0ce8a90549bb12ee0f9115111bbbb6acc2b889461208533369a91e8321eaf6bcb871a788ddd6bfbf7 \
 --observer-networking-key-path=/bootstrap/network.key
```

The light node acts as a DHT client and bootstraps from upstream access nodes which run the DHT server.
The upstream bootstrap server is specified using the `bootstrap-node-addresses` which is the comma-separated list of hostnames of the access nodes.
The `bootstrap-node-public-keys` is the list of the corresponding networking public key of those nodes.

The light node delegates many of the API calls to the upstream access nodes.
The `upstream-node-addresses` is the list of access node hostnames to which this light node can delegate to. The list can be different from the bootstrap node list.
The `bootstrap-node-public-key` is the list of the corresponding networking public key of those nodes.

> In the above docker commands, the Flow community access nodes are being used as the upstream access nodes. However, any other Flow access node that supports a light node can be used

_All parameters and their explanation can be found [here](https://github.com/onflow/flow-go/blob/82da35141ff095fbf75ce2c950efec240ad38565/cmd/access/node_builder/access_node_builder.go#L523-L558)_

🚀 **The node should now be up and running**

You can now query the node for blocks, transaction etc. similar to how you would query an access node.

e.g. querying the gRPC API endpoint using Flow CLI
```shell
flow blocks get latest --host localhost:9000
```

e.g. querying the REST API endpoint using curl
```shell
curl "http://localhost/v1/blocks?height=sealed"
```

The light node, like the other type of Flow nodes, also produces Prometheus metrics that can be used to monitor node health. More on that [here](./node-setup.mdx#monitoring-and-metrics)


## FAQs

### Does the light node need to be staked?

No, the light node is not a staked node.

### Can any access node be used to bootstrap a light node?

No, only Access nodes which have explicitly turned ON support for light nodes can be used to bootstrap a light node.

The public access nodes that support light nodes are listed below. Apart from these, other public access nodes run by node operators other than the Flow foundation team may choose to support light nodes.

### How can an access node turn ON support for light node?

An access node can support a light node by passing in the following two parameters when starting the access node
```shell
 --supports-observer=true --public-network-address=0.0.0.0:3570
```
`public-network-address` is the address the light nodes will connect to.

### Are light nodes subject to rate limits?

The light node serves all the [Block related queries](https://github.com/onflow/flow/blob/master/protobuf/flow/access/access.proto#L24-L42) from is local database. These are not subjected to any rate limits.

However, it proxies all the other requests to the access node and those will be rate limited as per the rate limits defined on that access node.


### Flow community access nodes that support connections from light nodes

#### For mainnet

Access-007:
* Host: `access-007.[current mainnet spork].nodes.onflow.org`
* Public Key: `28a0d9edd0de3f15866dfe4aea1560c4504fe313fc6ca3f63a63e4f98d0e295144692a58ebe7f7894349198613f65b2d960abf99ec2625e247b1c78ba5bf2eae`

Access-008:
* Host: `access-008.[current mainnet spork].nodes.onflow.org`
* Public Key: `11742552d21ac93da37ccda09661792977e2ca548a3b26d05f22a51ae1d99b9b75c8a9b3b40b38206b38951e98e4d145f0010f8942fd82ddf0fb1d670202264a`

#### For testnet

Access-003:
* Host: `access-003.[current devnet spork].nodes.onflow.org`
* Public Key: `b662102f4184fc1caeb2933cf87bba75cdd37758926584c0ce8a90549bb12ee0f9115111bbbb6acc2b889461208533369a91e8321eaf6bcb871a788ddd6bfbf7`

Access-004:
* Host: `access-004.[current devnet spork].nodes.onflow.org`
* Public Key: `0d1523612be854638b985fc658740fa55f009f3cd49b739961ab082dc91b178ed781ef5f66878613b4d34672039150abfd9c8cfdfe48c565bca053fa4db30bec`

While the public keys remain the same, the hostnames change each spork to include the spork name. Substitute `[current mainnet spork]` and `[current devnet spork]` with the appropriate spork name (e.g. `mainnet20`).
See [Past Sporks](./past-sporks.mdx) for the current spork for each network.---
title: Past Spork Info
description: Information about all Flow Mainnet and Testnet sporks.
---

A JSON version of the information below can be found in [onflow/flow/sporks.json](https://github.com/onflow/flow/blob/master/sporks.json)

## Mainnet Sporks

## Mainnet 24

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Access Node**: access.mainnet.nodes.onflow.org:9000                                   |
| **Date**: Nov 8, 2023                                                                  |
| **Root Height**: 65264619                                                               |
| **Root Parent ID**: aace2d9b6e66067989d0f71c2efff38fe30d88da61e3d80946c7e7b4ee2bbc2f    |
| **Root State Commit**: 709530929e4968daff19c303ef1fc5f0a7649b3a1ce7d5ee5202056969524c94 |
| **Git Commit**: e63117642e34b215993d14d36622d45df249016c                                |
| **Branch/Tag**: [v0.32.7](https://github.com/onflow/flow-go/releases/tag/v0.32.7)       |
| **Docker Image Tag**: v0.32.7                                                           |

## Mainnet 23

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Access Node**: access-001.mainnet23.nodes.onflow.org:9000                                   |
| **Date**: Jun 20, 2023                                                                  |
| **Root Height**: 55114467                                                               |
| **Root Parent ID**: dcaa1469c6cd67154942c70b594bdff407ea28eda1fc9c4a81a814f02dc2efc9    |
| **Root State Commit**: 5586f6b9af7c0d8efa7b403dbd3a894d71a18faad5a1abda48d3dfb7dcd4b017 |
| **Git Commit**: 0f6ea38efc91b7d27736b8b2c94091076c624796                                |
| **Branch/Tag**: [v0.31.9](https://github.com/onflow/flow-go/releases/tag/v0.31.9)       |
| **Docker Image Tag**: v0.31.9                                                           |

## Mainnet 22

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Access Node**: access-001.mainnet22.nodes.onflow.org:9000                             |
| **Date**: Feb 22, 2023                                                                  |
| **Root Height**: 47169687                                                               |
| **Root Parent ID**: 60a976d4cc36d0a5150d3f81ede85809916d4af9eb791d9190af0a12c1fd8a17    |
| **Root State Commit**: c9c9d3da3fe059a616b13768da2374275bd1a35f94d753ee8e41c538a3cc92d8 |
| **Git Commit**: e644427a8e83e8cd2a307c40e4c8fd3066008cae                                |
| **Branch/Tag**: [v0.29.13](https://github.com/onflow/flow-go/releases/tag/v0.29.13)     |
| **Docker Image Tag**: v0.29.13                                                          |

## Mainnet 21

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Access Node**: access-001.mainnet21.nodes.onflow.org:9000                             |
| **Date**: Jan 18, 2023                                                                  |
| **Root Height**: 44950207                                                               |
| **Root Parent ID**: 52004adfa7854b1a515d0d905dd5317dc7f77a8dbb56058e04dde01e53e80a92    |
| **Root State Commit**: 905c5e9a576ba2cbe49b5fe5f64ae84c2dee1bc26a3e81932e573e06a722d08a |
| **Git Commit**:  7f02a642bb437b45326c4ace54a7f033b32832f8                               |
| **Branch/Tag**: [v0.29.6](https://github.com/onflow/flow-go/releases/tag/v0.29.6)       |
| **Docker Image Tag**: v0.29.6                                                           |

## Mainnet 20

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Access Node**: access-001.mainnet20.nodes.onflow.org:9000                             |
| **Date**: Nov 2, 2022                                                                   |
| **Root Height**: 40171634                                                               |
| **Root Parent ID**: f66302ac43623a87d29dfdeb08fce5d19e3af7be2e4283d468f74ee10468f248    |
| **Root State Commit**: ec1e1cd34bb05b5abb3c4701a7f365d1dde46d9d908dc57420bde8b4a53d940a |
| **Git Commit**:  b9b941db9a3949db0e299a40264d852980d35ddd                               |
| **Branch/Tag**: [v0.28.6](https://github.com/onflow/flow-go/releases/tag/v0.28.6)       |
| **Docker Image Tag**: v0.28.6                                                           |

## Mainnet 19

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Access Node**: access-001.mainnet19.nodes.onflow.org:9000                             |
| **Date**: Aug 24, 2022                                                                  |
| **Root Height**: 35858811                                                               |
| **Root Parent ID**: 5c030d4125f8ace0e0ab8255880143190d58aca4ddb7c4720c28eaf497adcae1    |
| **Root State Commit**: 96ff0d9a2b7d8264ea8727d4a104d7372efcfe18dc0c9111aff5c46b688eff04 |
| **Git Commit**:  b6e9a988514d13e1e1ecd0802d7e02f9e9b1415b                               |
| **Branch/Tag**: [v0.27.4](https://github.com/onflow/flow-go/releases/tag/v0.27.4)       |
| **Docker Image Tag**: v0.27.4                                                           |

## Mainnet 18

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Access Node**: access-001.mainnet18.nodes.onflow.org:9000                             |
| **Date**: Jun 15, 2022                                                                  |
| **Root Height**: 31735955                                                               |
| **Root Parent ID**: 716d54edbb3d9b2ad290709a516f1ffe4290c7b7b33a49bd0480e0b193a45884    |
| **Root State Commit**: 5bdae9f5fb4cc5d63075547df5502e2bc3cb20707452389fb89ebbe71ecf7b68 |
| **Git Commit**:  fdc732183233f1c577a9e529da6b453364431301                               |
| **Branch/Tag**: [v0.26.9](https://github.com/onflow/flow-go/releases/tag/v0.26.9)       |
| **Docker Image Tag**: v0.26.9                                                           |

## Mainnet 17

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Access Node**: access-001.mainnet17.nodes.onflow.org:9000                             |
| **Date**: Apr 6, 2022                                                                   |
| **Root Height**: 27341470                                                               |
| **Root Parent ID**: dd7ed04e14559ed47ecc92896a5cb3dbb6b234065d9be7f816d99602238762aa    |
| **Root State Commit**: 113e752ec0619b63187630b4fae308ec5405a00f56f25c2de0b139e283a95b14 |
| **Git Commit**:  5226c35eb14890db024b9193793b0c49d1b5ad04                               |
| **Branch/Tag**: [v0.25.7](https://github.com/onflow/flow-go/releases/tag/v0.25.7)       |
| **Docker Image Tag**: v0.25.7                                                           |

## Mainnet 16

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Access Node**: access-001.mainnet16.nodes.onflow.org:9000                             |
| **Date**: Feb 9, 2022                                                                   |
| **Root Height**: 23830813                                                               |
| **Root Parent ID**: b0e7a891682dce277a41e87e2cef52af344ac614bf70c82a5a3a801e63960e88    |
| **Root State Commit**: 8964d1f74c2bed2d0fbb4a366fff1fd3c39b71653e9de4d4512090798631e5f8 |
| **Git Commit**:  c78cac3573e0548611f29df7cfa2db92203554c1                               |
| **Branch/Tag**: [v0.24.4](https://github.com/onflow/flow-go/releases/tag/v0.24.4)       |
| **Docker Image Tag**: v0.24.4                                                           |

## Mainnet 15

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Access Node**: access-001.mainnet15.nodes.onflow.org:9000                             |
| **Date**: Dec 8, 2021                                                                   |
| **Root Height**: 21291692                                                               |
| **Root Parent ID**: 8a28ddc6653a8991435dfbc95103d6be1a3b653cda3d664681215ee93112a203    |
| **Root State Commit**: 84d9b325d3f48f7f075eea0db6c246cb5adc759a2dd8561e461477a7ca1f7f22 |
| **Git Commit**:  bfde54ae3324db5d18ebeaa22c70b5574a114f2e                               |
| **Branch/Tag**: [v0.23.4](https://github.com/onflow/flow-go/releases/tag/v0.23.4)       |
| **Docker Image Tag**: v0.23.4                                                           |

## Mainnet 14

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Access Node**: access-001.mainnet14.nodes.onflow.org:9000                             |
| **Date**: Oct 6, 2021                                                                   |
| **Root Height**: 19050753                                                               |
| **Root Parent ID**: ac4dbf344ce96e39e15081f1dc3fbbf6dc80532e402de9a57af847d3b35df596    |
| **Root State Commit**: 641eb088e3ce1a01ff56df2d3a14372c65a7fef44c08799eb92cd7759d1d1d2a |
| **Git Commit**:  f019c1dbd778ce9f92dea61349ca36003678a9ad                               |
| **Branch/Tag**: [v0.22.9-patch-1-epoch-view-check-hotfix](https://github.com/onflow/flow-go/releases/tag/v0.22.9-patch-1-epoch-view-check-hotfix)       |
| **Docker Image Tag**: v0.22.9-patch-1-epoch-view-check-hotfix                           |

## Mainnet 13

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Access Node**: access-001.mainnet13.nodes.onflow.org:9000                             |
| **Date**: Sept 15, 2021                                                                 |
| **Root Height**: 18587478                                                               |
| **Root Parent ID**: 2f708745fff4f66db88fac8f2f41d496edd341a2837d3e990e87679266e9bdb8    |
| **Root State Commit**: 51e3098d327df22fd005d960cb73167c83cb438c53e6c4363c07d8611ae44528 |
| **Git Commit**: 9535540110a4452231d044aceabab0e60f67708c                                |
| **Branch/Tag**: [v0.21.3](https://github.com/onflow/flow-go/releases/tag/v0.21.3)       |
| **Docker Image Tag**: v0.21.3                                                           |

## Mainnet 12

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Access Node**: access-001.mainnet12.nodes.onflow.org:9000                             |
| **Date**: Aug 18, 2021                                                                  |
| **Root Height**: 17544523                                                               |
| **Root Parent ID**: f6ca04ba5c6fa6ba690a77202a9fad8d3ec30c67762ae065f0f0f53e8fed84d0    |
| **Root State Commit**: b5cf1977b12de699d0e777af5be25095653735a153d1993f97ff07804b070917 |
| **Git Commit**: 4a0c10d74f1bcaadfdfec8c325efa411acd1a084                                |
| **Branch/Tag**: [v0.20.5](https://github.com/onflow/flow-go/releases/tag/v0.20.5)       |
| **Docker Image Tag**: v0.20.5                                                           |

## Mainnet 11

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Access Node**: access-001.mainnet11.nodes.onflow.org:9000                             |
| **Date**: July 21, 2021                                                                 |
| **Root Height**: 16755602                                                               |
| **Root Parent ID**: de15461988000eddc6e507dc7b159dcd192ee3aa72f3bd3b0e31ae9c6538399f    |
| **Root State Commit**: 4eb91bf34cb65b7537a6a95806f444f409308b2eaaa0ad28d1924b6cb8afa140 |
| **Git Commit**: 2644560c0562412a3c2209820be07f8f3f8b1846                                |
| **Branch/Tag**: [v0.19.2](https://github.com/onflow/flow-go/releases/tag/v0.19.2)       |
| **Docker Image Tag**: v0.19.2                                                           |

## Mainnet 10

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Access Node**: access-001.mainnet10.nodes.onflow.org:9000                             |
| **Date**: June 23, 2021                                                                 |
| **Root Height**: 15791891                                                               |
| **Root Parent ID**: 1d4109bbb364d5cdd94640546dd1c423d792d962284665233d541e4ade921726    |
| **Root State Commit**: 9b6a1a5ab52fd3d5a19ea22f09cb607bba63671311f157b3e604dd265efb851a |
| **Git Commit**: 01f53ebd7df3101e337d9212736cff6ab1e0056d                                |
| **Branch/Tag**: [v0.18.4](https://github.com/onflow/flow-go/releases/tag/v0.18.4)       |
| **Docker Image Tag**: v0.18.4                                                           |

## Mainnet 9

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Access Node**: access-001.mainnet9.nodes.onflow.org:9000                              |
| **Date**: May 26, 2021                                                                  |
| **Root Height**: 14892104                                                               |
| **Root Parent ID**: 265d10ba3e36ed6539fd4d7f4322735aad4997c0378d75783e471437dd83ef33    |
| **Root State Commit**: fcc30a6664337ef534ad544ad7b17c5cc3b5470a8ef0d93f18573fddf6b25c4a |
| **Git Commit**: 2d81520c49a8865fa686c32c508d2261155c86bc                                |
| **Branch/Tag**: [v0.17.4](https://github.com/onflow/flow-go/releases/tag/v0.17.4)       |
| **Docker Image Tag**: v0.17.4                                                           |

## Mainnet 8

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Access Node**: access-001.mainnet8.nodes.onflow.org:9000                              |
| **Date**: April 28, 2021                                                                |
| **Root Height**: 13950742                                                               |
| **Root Parent ID**: faa2a3a996c6efcc3ef562fe03d797e4b19dbe00f6beab082d6d37a447044abd    |
| **Root State Commit**: 259836c7f74e6bbb803c9cfb516044bc701d99c2840e9b9f89609464867e7f0f |
| **Git Commit**: 4e733ba2038512e9d80bcd955e67e88ba6e3ecf2                                |
| **Branch/Tag**: v0.16.2                                                                 |
| **Docker Image Tag**: v0.16.2                                                           |

## Mainnet 7

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Access Node**: access-001.mainnet7.nodes.onflow.org:9000                              |
| **Date**: April 7, 2021                                                                 |
| **Root Height**: 13404174                                                               |
| **Root Parent ID**: 8b969d0babbb7d2043957b3d55a811f2c13344faa76565096d4ad901a466ecaa    |
| **Root State Commit**: 1247d74449a0252ccfe4fd0f8c6dd98e049417b3bffc3554646d92f810e11542 |
| **Git Commit**: b6f47fd23ffe31e2fe714c6bff0b17d901e210b4                                |
| **Branch/Tag**: v0.15.3-patch.4                                                         |
| **Docker Image Tag**: v0.15.3-patch.4                                                   |

Releases compatible with Mainnet 7: No change from Mainnet 6

## Mainnet 6

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Access Node**: access-001.mainnet6.nodes.onflow.org:9000                              |
| **Date**: Mar 10, 2021                                                                  |
| **Root Height**: 12609237                                                               |
| **Root Parent ID**: c68e63ca5b6f7ff61ef2b28d7da528c5b677b0f81f2782f067679c108d77932b    |
| **Root State Commit**: ddfedbfaa2d858e6a8e3b142381a91b289f50e45622f5b5a86ac5c00ce61bf11 |
| **Git Commit**: c887bd343ca7db6351690007b87bec40d39d7b86                                |
| **Branch/Tag**: v0.14.9                                                                 |
| **Docker Image Tag**: v0.14.9                                                           |

Releases compatible with Mainnet 6:

### Network Implementations

Flow Go: https://github.com/onflow/flow-go/releases/tag/v0.14.9 <br/>
Emulator: https://github.com/onflow/flow-emulator/releases/tag/v0.16.1<br/>

Emulator v0.16.1 is distributed in Flow CLI v0.15.0: https://github.com/onflow/flow-cli/releases/tag/v0.15.0

### SDK Compatibility

#### Flow Go SDK

Minimum version: https://github.com/onflow/flow-go-sdk/releases/tag/v0.16.1 <br/>
Recommended version: https://github.com/onflow/flow-go-sdk/releases/tag/v0.16.1 <br/>

#### FCL (Flow Client Library)

Minimum version: [v0.0.66](https://github.com/onflow/fcl-js/blob/master/packages/fcl/CHANGELOG.md#0066---2020-11-09) <br/>
Recommended version: [v0.0.67](https://github.com/onflow/fcl-js/blob/master/packages/fcl/CHANGELOG.md#0067-alpha0---2020-11-17)

While FCL v0.0.67 is not strictly necessary to use Mainnet 6, we strongly recommend upgrading in order to adapt to wallet improvements that were introduced in v0.0.67.

---

## Mainnet 5

| Spork Info                                                                                           |
| :--------------------------------------------------------------------------------------------------- |
| **Access Node**: access-001.mainnet5.nodes.onflow.org:9000                                           |
| **Date**: Feb 17, 2021                                                                               |
| **Root Height**: 12020337                                                                            |
| **Root Parent ID**: 9131733835702b0d6321088bddb4642a4964bb5c630440ccb0de47bdbc371d1a                 |
| **Root State Commit**: 54bef048a6c5574ef4eb452dd2698aeb2fe5eca6edd536aca6d0bc631c2daaa9              |
| **Git Commit**: 027569a9d76e41b1140b189fa1b9187c711ab241                                             |
| **Branch/Tag**: v0.14.1 for Access, Verification, Collection and v0.14.2 for Consensus and Execution |
| **Docker Image Tag**: v0.14.1 / v0.14.2                                                                    |

---

## Mainnet 4

| Spork Info                                                                             |
| :------------------------------------------------------------------------------------- |
| **Access Node**: access-001.mainnet4.nodes.onflow.org:9000                             |
| **Date**: Dec 16, 2020                                                                 |
| **Root Height**: 9992020                                                               |
| **Root Parent ID**: 691e35a4ac4d0d47e1be1ec81512ac9f6cdd04545b908fad1d6ceea58c76b560   |
| **Root State Commit**: 0011fda57f2f3aaa8e6bcc1e1deea9778a9543252f8b65bbd4ebca3687789420 |
| **Git Commit**: f4a73c7f20109209e9e2e999cf50fcf1ec41241b                               |
| **Branch/Tag**: v0.13.1                                                                |
| **Docker Image Tag**: v0.13.1                                                                |

---

## Mainnet 3

| Spork Info                                                                             |
| :------------------------------------------------------------------------------------- |
| **Access Node**: access-001.mainnet3.nodes.onflow.org:9000                             |
| **Date**: Dec 9, 2020                                                                  |
| **Root Height**: 9737133                                                               |
| **Root Parent ID**: 116751c904a7f868cd6e8c90522fdbd70fe826db6886b830338c68c6339df3e7   |
| **Root State Commit**: 1d2c91e801d0560024848a0c981e03120efc372436ada5f7909c4d44d4600f04 |
| **Git Commit**: badd5887512b955e7aa18b4e73dae980ca72fa22                               |
| **Branch/Tag**: v0.12.6                                                                |
| **Docker Image Tag**: v0.12.6                                                                |

---

## Mainnet 2

| Spork Info                                                                             |
| :------------------------------------------------------------------------------------- |
| **Access Node**: access-001.mainnet2.nodes.onflow.org:9000                             |
| **Date**: Nov 13, 2020                                                                 |
| **Root Height**: 8742959                                                               |
| **Root Parent ID**: b35fdb189d21a95df7f19f941786f748d9854a8b93b1e555b51cda7d9f53a6e1   |
| **Root State Commit**: d6a25be552ed93213df0ffc2e8c7f39f6401c04cbf22bac7a4b84d3c9493f005 |
| **Git Commit**: 4ef68efb935c0e3393ae3966752ece5e7739bab4                               |
| **Branch/Tag**: v0.11.1                                                                |
| **Docker Image Tag**: v0.11.1                                                                |

---

## Mainnet 1

| Spork Info                                                                             |
| :------------------------------------------------------------------------------------- |
| **Access Node**: access-001.mainnet1.nodes.onflow.org:9000                             |
| **Date**: Oct 13, 2020                                                                 |
| **Root Height**: 7601063                                                               |
| **Root Parent ID**: ab1ee18b6e1c0ee11cc021c26a17c694c627699a576e85f7013cd743bdbc7877   |
| **Root State Commit**: 6e1adf15689eaf5ea6859bcdd0b510f5eb4c34dac878d8577b3f65bc20c3f312 |
| **Git Commit**: 114d45436e7d9052e910c98a1e40f730e3fd12d7                               |
| **Branch/Tag**: v0.10.1                                                               |
| **Docker Image Tag**: v0.10.1                                                                |

---

## Candidate 9

| Spork Info                                                                             |
| :------------------------------------------------------------------------------------- |
| **Access Node**: access-001.candidate9.nodes.onflow.org:9000                           |
| **Date**: Sep 25, 2020                                                                 |
| **Root Height**: 6483246                                                               |
| **Root Parent ID**: 9131733835702b0d6321088bddb4642a4964bb5c630440ccb0de47bdbc371d1a   |
| **Root State Commit**: 90c6f406f5d21880d525ad4702cb249509b85e7f745db2de67e9fe541a56da4c |
| **Git Commit**: v0.9.3                                                                 |
| **Branch/Tag**: v0.9.3                                                                 |
| **Docker Image Tag**:                                                                        |

---

## Candidate 8

| Spork Info                                                                             |
| :------------------------------------------------------------------------------------- |
| **Access Node**: access-001.candidate8.nodes.onflow.org:9000                           |
| **Date**: Sep 9, 2020                                                                 |
| **Root Height**: 4972987                                                               |
| **Root Parent ID**: 5bc2b0900a5138e39d9209a8fe32e14b3e5c884bd36d2a645620f746b7c8bd47   |
| **Root State Commit**: 6b9161a225b087a461ec95e710fdf4e73f6d6c9401ebf066207a021dced4ce5e |
| **Git Commit**:                                                                        |
| **Branch/Tag**:                                                                  |
| **Docker Image Tag**:                                                                        |

---

## Candidate 7

| Spork Info                                                                             |
| :------------------------------------------------------------------------------------- |
| **Access Node**: access-001.candidate7.nodes.onflow.org:9000                           |
| **Date**: Aug 24, 2020                                                                 |
| **Root Height**: 4132133                                                               |
| **Root Parent ID**: 28f4f495aad016b519acf27fc9d9a328f6a4009807480e36e2df780eeccd99bc   |
| **Root State Commit**: 001d173bfcf9c7f71684da89bff72b3ee582b39a69c7929360230faf73735c17|
| **Git Commit**: f811f8cd49369ae2bc559e0fbb781aff129484f5                               |
| **Branch/Tag**: candidate7                                                             |
| **Docker Image Tag**: v0.7.2                                                           |

---

## Candidate 6

| Spork Info                                                                             |
| :------------------------------------------------------------------------------------- |
| **Access Node**: access-001.candidate6.nodes.onflow.org:9000                           |
| **Date**: Aug 18, 2020                                                                 |
| **Root Height**: 3187931                                                               |
| **Root Parent ID**: 2ff5f7424a448943a153001d2f0869d4fac330906ecb8e17b7ef7fe50e4c7b36   |
| **Root State Commit**: bd7f16dc5ef5eced849ab5f437547c14c1907059e1ecf89a942d0521166c5cbb |
| **Git Commit**: b30c48008c0ec1cc8ecb750aeb9ff9f3d712681d                               |
| **Branch/Tag**:                                                                        |
| **Docker Image Tag**:                                                                        |

---

## Candidate 5

| Spork Info                                                                             |
| :------------------------------------------------------------------------------------- |
| **Access Node**: access-001.candidate5.nodes.onflow.org:9000                           |
| **Date**: Jul 28, 2020                                                                 |
| **Root Height**: 2033592                                                               |
| **Root Parent ID**: a0efffb2beb1500419ae4f7c6e49bfbbe3a4d1d1c201bf925ccaec467ea30e91   |
| **Root State Commit**: 0190d417a26b9870f5bb2cf408ad31985b3aa7e57f6ababa6e543f0f90b99dcd |
| **Git Commit**: cd876653d20b398952af4002701a0ae2800fd5f2                               |
| **Branch/Tag**:                                                                        |
| **Docker Image Tag**:                                                                        |

---

## Candidate 4

| Spork Info                                                                             |
| :------------------------------------------------------------------------------------- |
| **Access Node**: access-001.candidate4.nodes.onflow.org:9000                           |
| **Date**: Jul 14, 2020                                                                 |
| **Root Height**: 1065711                                                               |
| **Root Parent ID**: 68c2bbe68524b50f5d689bc2ac7ad2dd70e88ed7dd15ad6c3cdf6ea314cb1aa3   |
| **Root State Commit**: c05086e4d1d428d3b9af5bd8b81d8780054f783ef4eec3ca28b491202e9ac696|
| **Git Commit**: b9b197280d6590576f1ef183bc3d04d41d6be587                               |
| **Branch/Tag**:                                                                  |
| **Docker Image Tag**:                                                                        |

---

## Testnet Sporks

## Devnet 49

| Spork Info                                                                              |
|:----------------------------------------------------------------------------------------|
| **Date**: Nov 2nd, 2023                                                                 |
| **Root Height**: 129578013                                                              |
| **Root Parent ID**: 91b039c1a5caf25776948270a6355017b8841bfb329c87460bfc3cf5189eba6f    |
| **Root State Commit**: e10d3c53608a1f195b7969fbc06763285281f64595be491630a1e1bdfbe69161 |
| **Git Commit**: fce4ae31c8c90c6a21de9856a319c379bb797fc5                                |
| **Branch/Tag**: v0.32.6-patch.1                                                         |
| **Docker Image Tag**: v0.32.6-patch.1                                                   |

## Devnet 48

| Spork Info                                                                              |
|:----------------------------------------------------------------------------------------|
| **Date**: Aug 4th, 2023                                                                 |
| **Root Height**: 127720466                                                              |
| **Root Parent ID**: 2b30e75bd857f898456dcb296bea4b8bc8001cab7062eeee9e47876411b36d76    |
| **Root State Commit**: f2e5ebfca2fd519e49f7bd85bea81e92eeaa85a705b3376d8534e9c9649da710 |
| **Git Commit**: 692969b1718b3d21f95ee7f66e5061623d99e599                                |
| **Branch/Tag**: v0.32.3                                                                 |
| **Docker Image Tag**: v0.32.3                                                           |

## Devnet 47

| Spork Info                                                                              |
|:----------------------------------------------------------------------------------------|
| **Date**: Aug 4th, 2023                                                                 |
| **Root Height**: 113167876                                                              |
| **Root Parent ID**: dbd59a00503707c8bc3c5fb3bcc7bd243da4bf8e24c86b6a496505e275b85311    |
| **Root State Commit**: 42006aedbfbfa9fcd949de8347b55166df77d8742bf5f273266a8dfcdf2b836b |
| **Git Commit**: db1c2584d6d8359b7ccf733c16bd5e1b9385c9bc                                |
| **Branch/Tag**: v0.31.13                                                                |
| **Docker Image Tag**: v0.31.13                                                          |

## Devnet 46

| Spork Info                                                                              |
|:----------------------------------------------------------------------------------------|
| **Date**: Jun 8th, 2023                                                                 |
| **Root Height**: 105155067                                                              |
| **Root Parent ID**: daced0cdeed95cf143320db50ac904ed17dabe04898e988264af2a71e0d1ca48    |
| **Root State Commit**: e8c39b7a1672cb3f5f70da6f1d71a3a0322d3d6c3d7ebf8092ae2ae40d12c30b |
| **Git Commit**: 3d4159e93c92cc6331e69708b8c3270d40c09c5f                                |
| **Branch/Tag**: v0.31.4                                                                 |
| **Docker Image Tag**: v0.31.4                                                           |

## Devnet 45

| Spork Info                                                                              |
|:----------------------------------------------------------------------------------------|
| **Date**: Jun 7th, 2023                                                                 |
| **Root Height**: 105032150                                                              |
| **Root Parent ID**: 71df56106ee1492c055a60e2d951a6a8d1b7d1483b903f10146cec912e793e82    |
| **Root State Commit**: 0e2e053ca4436a4881f65acc031e12820b5260ef616446950650a1bc8fc9be2f |
| **Git Commit**: 8d32e5ea087fcceb0d1aa923c56be1d5a2d6538a                                |
| **Branch/Tag**: v0.31.2                                                                 |
| **Docker Image Tag**: v0.31.2                                                           |

## Devnet 44

| Spork Info                                                                              |
|:----------------------------------------------------------------------------------------|
| **Date**: Apr 24th, 2023                                                                |
| **Root Height**: 100675451                                                               |
| **Root Parent ID**: 298854580771edc6ec2e2bbc8da3990ff7f746e2fc5cfe16e550d577bdd4bc5b    |
| **Root State Commit**: 2a062531331b8214de4e900a26ff0f76c578481b4ce22b4b5d8e55bd9535abda |
| **Git Commit**: b5b65c9d43bf6bd12766eef06e870990c3963b7c                                |
| **Branch/Tag**: v0.30.6                                                                 |
| **Docker Image Tag**: v0.30.6                                                           |

## Devnet 43

| Spork Info                                                                              |
|:----------------------------------------------------------------------------------------|
| **Date**: Apr 12th, 2023                                                                |
| **Root Height**: 99452067                                                               |
| **Root Parent ID**: 0e6bae31b2f34ffb0d64d4e1a33c2fbcebd80c936d77d70d2f5dd9321dc92393    |
| **Root State Commit**: 7cd69bb0a4448566dce42808efa8b1d03f322135f0bfce6f18037fca1294984c |
| **Git Commit**: d55ca8f48167e9669bdb1dc3173253936863e31e                                |
| **Branch/Tag**: v0.30.3                                                                 |
| **Docker Image Tag**: v0.30.3                                                           |

## Devnet 42

| Spork Info                                                                              |
|:----------------------------------------------------------------------------------------|
| **Date**: Apr 12th, 2023                                                                |
| **Root Height**: 99444465                                                               |
| **Root Parent ID**: a3788d5c0ff1c45db38bca2625bf18bfc562e1bfdc9ebb7dc83ef080be31e697    |
| **Root State Commit**: a6e5bfc16a39109ef86caad4dab77ec3752680ef3813c3449f239d84fddc5aa1 |
| **Git Commit**: d55ca8f48167e9669bdb1dc3173253936863e31e                                |
| **Branch/Tag**: v0.30.3                                                                 |
| **Docker Image Tag**: v0.30.3                                                           |

## Devnet 41

| Spork Info                                                                              |
|:----------------------------------------------------------------------------------------|
| **Date**: Jan 30th, 2023                                                                |
| **Root Height**: 93156994                                                               |
| **Root Parent ID**: 26ff2f7f2948a05c63e723eb42946565809b47dbef87079a8f0bae0cc36a0478    |
| **Root State Commit**: 08d712b4f7ed838d53b8699e2fd94d0ad010c4b1fa45735b6e80083ff8ef08ff |
| **Git Commit**: a7f2cd0ddd9fc7e1e56187327a84fec9efdc3c9d                                |
| **Branch/Tag**: v0.29.8                                                                 |
| **Docker Image Tag**: v0.29.8                                                           |

## Devnet 40

| Spork Info                                                                              |
|:----------------------------------------------------------------------------------------|
| **Date**: Jan 23rd, 2023                                                                |
| **Root Height**: 92473965                                                               |
| **Root Parent ID**: 7c9812f414d9e9795c1cd7dbd27fc45baf880391452e0e948aaa80ba86dfc77d    |
| **Root State Commit**: 0068a04843d2c8e007086abaaee90c8c8cae8aa78f240048cd4d43aeb0376d0b |
| **Git Commit**: 7f02a642bb437b45326c4ace54a7f033b32832f8                                |
| **Branch/Tag**: v0.29.6                                                                 |
| **Docker Image Tag**: v0.29.6                                                           |

## Devnet 39

| Spork Info                                                                              |
|:----------------------------------------------------------------------------------------|
| **Date**: Jan 4th, 2023                                                                 |
| **Root Height**: 90595736                                                               |
| **Root Parent ID**: 3d09b9703019b40a065787fff3dd62e28eafa5efcfb69efbc2d713d73034cf38    |
| **Root State Commit**: afd47ff2a8e73efd51f0cbe7f572eefda25a66e77f1e6b9c4f3f4e7cdc46568f |
| **Git Commit**: e1c172aaee7da9e33828429757b44f51e59368a2                                |
| **Branch/Tag**: v0.29.3                                                                 |
| **Docker Image Tag**: v0.29.3                                                           |

## Devnet 38

| Spork Info                                                                              |
|:----------------------------------------------------------------------------------------|
| **Date**: Oct 19th, 2022                                                                |
| **Root Height**: 83007730                                                               |
| **Root Parent ID**: 1b914363c9a34c46b93974adeefb10c546578d7f3f4ac9291e01d746d2c84226    |
| **Root State Commit**: 79df428bc27f22d38c233777610d93d33e180f23cfbc640a95d144a508e0f080 |
| **Git Commit**: 3aae289f8f390f58ac481fd694254ea0e48960a8                                |
| **Branch/Tag**: v0.28.4                                                                 |
| **Docker Image Tag**: v0.28.4                                                           |

## Devnet 37

| Spork Info                                                                              |
|:----------------------------------------------------------------------------------------|
| **Date**: Aug 10th, 2022                                                                |
| **Root Height**: 76159167                                                               |
| **Root Parent ID**: 8f379a8a86f28c7adef276890874b17786cecf5efb9e71734b0a780bd38660a0    |
| **Root State Commit**: 7d1fe692ea2f857568dec54ddece094a68a9ba8ff8dd0de0664e6f73abb90dd8 |
| **Git Commit**: 959911cabd50e1a11be45e89726952a90f1a9c22                                |
| **Branch/Tag**: v0.27.2                                                                 |
| **Docker Image Tag**: v0.27.2                                                           |

## Devnet 36

| Spork Info                                                                              |
|:----------------------------------------------------------------------------------------|
| **Date**: July 27th, 2022                                                               |
| **Root Height**: 74786360                                                               |
| **Root Parent ID**: 9d9113ca8daa4f3be72e949ea9ead2d4b11db222b2ccd0dc897186ee5f8703ab    |
| **Root State Commit**: aa2e12033129f27b5320fb973cf109f562db3ad7ddaf50dbfe9d8cc195a7ac0f |
| **Git Commit**: 13970fcae812bc04487422922f73eab39f53935c                                |
| **Branch/Tag**: v0.26.17                                                                |
| **Docker Image Tag**: v0.26.17                                                          |

## Devnet 35

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Date**: June 9th, 2022                                                                 |
| **Root Height**: 70072575                                                               |
| **Root Parent ID**: cd76fd9d5ceb1b98b5f30b0108f40836593c533ffe32eef0c6f3ed6d50bf645b    |
| **Root State Commit**: d933d73f48c9371f0a00ab7ffc1ed0daf5ba9e520d2d539e6b9494920c5ffd91 |
| **Git Commit**: 07057c8d5fe2f09bbe5a9a3f8de6209346d910d0                                |
| **Branch/Tag**: v0.26.6                                                                 |
| **Docker Image Tag**: v0.26.6                                                           |

## Devnet 34

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Date**: Apr 4th, 2022                                                                 |
| **Root Height**: 64904846                                                               |
| **Root Parent ID**: 0cbb13d9e7ed7092b5f20d0a20a79d1cae96fd796fb2bc569b27ce49cc97d97e    |
| **Root State Commit**: f2e77e16628543e285be8bac677db06e17b37f49e53a107af1e6bf99fbc17b30 |
| **Git Commit**: 5226c35eb14890db024b9193793b0c49d1b5ad04                                |
| **Branch/Tag**: v0.25.7                                                                 |
| **Docker Image Tag**: v0.25.7                                                           |

## Devnet 33

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Date**: Feb 7th, 2022                                                                 |
| **Root Height**: 59558934                                                               |
| **Root Parent ID**: 099fbb7b645c3441ea830746ed67059bcc1091c88ff3fd78b331137cf917d15f    |
| **Root State Commit**: 5b5578cb4ef6c34818ce2cfd9969720c7f17681f41dffa3a9e361935140d7c8e |
| **Git Commit**: bd3dca7bf20914f5c019a325b6939bbb662aa131                                |
| **Branch/Tag**: v0.24.3                                                                 |
| **Docker Image Tag**: v0.24.3                                                                 |

## Devnet 32

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Date**: Dec 6th, 2021                                                                 |
| **Root Height**: 53376277                                                               |
| **Root Parent ID**: f900db2ccff33f3bf353c8bf28ece0a9d2650f2805b23ddb7893e296774a5457    |
| **Root State Commit**: 843ea0b5498342dcf960376585eeafee8ebe008df3b03325351408a100cb830c |
| **Git Commit**: be20371fa8c5044a4e25e5629bbca91f1ed19731                                |
| **Branch/Tag**: v0.23.3                                                                 |
| **Docker Image Tag**: v0.23.3                                                                 |

## Devnet 31

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Date**: Nov 5th, 2021                                                                 |
| **Root Height**: 50540412                                                               |
| **Root Parent ID**: cfebaa6b8c19ec48a27eaa84c3469b23255350532b5ea4c7e4c42313386c07b6    |
| **Root State Commit**: 31a2b1eb05a6acb91560970e46b8f3f3171747245eae1ad2bf40290ce773806e |
| **Git Commit**: 3d060b90264d59ccd38b4500ae0cd6d72036cfe4                                |
| **Branch/Tag**: v0.23-testnet                                                           |
| **Docker Image Tag**: v0.23.1                                                                 |

## Devnet 30

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Date**: Oct 6th, 2021                                                                 |
| **Root Height**: 47330085                                                               |
| **Root Parent ID**: 0ec9172a21f84cbae15761ae4d59ab4a701f9d4fd15cd0632715befc8cf205cf    |
| **Root State Commit**: e280f972c72c6b379ec3d4a7173953e596704d8d72f384ef1637d2f4f01ff901 |
| **Git Commit**: f019c1dbd778ce9f92dea61349ca36003678a9ad                                |
| **Branch/Tag**: v0.22.8-patch-1-scripts-and-errors                                      |
| **Docker Image Tag**: v0.22.8-patch-1-scripts-and-errors                                      |

## Devnet 29

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Date**: Oct 5th, 2021                                                                 |
| **Root Height**: 47242826                                                               |
| **Root Parent ID**: 00f745576222a1e7e15ee79974b4b3eaddd760fb4f56e846cfaef3cb5ea59d50    |
| **Root State Commit**: 3c5bfb88a3fa184c9981e7677d1f2a2cd0a4eaa581bb2a7867b7b023ae015f38 |
| **Git Commit**: e1659aebc39b4a15c68112227fc8c32788a798b6                                |
| **Branch/Tag**: v0.22.8                                                                 |
| **Docker Image Tag**: v0.22.8                                                                 |

## Devnet 28

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Date**: Sept 22, 2021                                                                 |
| **Root Height**: 45889254                                                               |
| **Root Parent ID**: 1518c15f7078cb8fd4c636b9fc15ee847ac231a8631ed59a0b8c9d4a182fb5b2    |
| **Root State Commit**: 296001ee05ce3e6c6616ad9bcdc20e6d93d02c91354e57fff6054cff44c5afa3 |
| **Git Commit**: a979f4d25a79630581f6b350ad26730d4012cad4                                |
| **Branch/Tag**: v0.21.6                                                                 |
| **Docker Image Tag**: v0.21.6                                                                 |

## Devnet 27

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Date**: Sept 14, 2021                                                                 |
| **Root Height**: 45051578                                                               |
| **Root Parent ID**: 8525ac24717b5f42e29172f881e9a7439235e4cd443a8a59494dbecf07b9376a    |
| **Root State Commit**: b3ef3b039f722130009b658e3f5faee43b3b9202fec2e976907012994a8fc9be |
| **Git Commit**: 4f903f1d45e6f8c997a60de47de62a74ede3c2e4                                |
| **Branch/Tag**: v0.21.3                                                                 |
| **Docker Image Tag**: v0.21.3                                                                 |

## Devnet 26

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Date**: Aug 11, 2021                                                                  |
| **Root Height**: 41567027                                                               |
| **Root Parent ID**: ea465f33266be26b21c82ec728c75cc0dcbb022405d83c44ed0082b0df9aa81d    |
| **Root State Commit**: 9459485a2a640b1bdc3066916a9a46dc20bf2528a03f06ddc541d34444c3264c |
| **Git Commit**: 781ec414b892e2ccf7034aa263b5b19d97f82031                                |
| **Branch/Tag**: v0.20.4                                                                 |
| **Docker Image Tag**: v0.20.4                                                                 |

## Devnet 25

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Date**: July 20, 2021                                                                 |
| **Root Height**: 39272449                                                               |
| **Root Parent ID**: 2824828e7c87e1a89bc94daca9497625f1a35c8f9fc555f52d1f8b475179e125    |
| **Root State Commit**: bd50708e7808be0d43725a9eae6039558b32b679c5a584a2e6103bb027dad7eb |
| **Git Commit**: 2644560c0562412a3c2209820be07f8f3f8b1846                                |
| **Branch/Tag**: v0.19.2                                                                 |
| **Docker Image Tag**: v0.19.2                                                                 |

## Devnet 24

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Date**: June 22, 2021                                                                 |
| **Root Height**: 36290422                                                               |
| **Root Parent ID**: 8d6fad91536ec750d1bb44ebb59e030af2dca49d41c104e45f4f82433184e663    |
| **Root State Commit**: fdfd7a9fff481256972095ffc2c6cba300128f41d8c6aa971985de29427eb39d |
| **Git Commit**: 37d9ae7a309bf7d21063f57fce008d04828d4840                                |
| **Branch/Tag**: v0.18.3                                                                 |
| **Docker Image Tag**: v0.18.3                                                                 |

## Devnet 23

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Date**: May 25, 2021                                                                  |
| **Root Height**: 33257098                                                               |
| **Root Parent ID**: dafa3e7a9a93de8ceb0a3acd09b2cce4ad0e5d7ea8fe4237f27c4503e5ad416c    |
| **Root State Commit**: decf340a722ba136c94ece029e9333d9fbcf216482cd1c81a274365e2abd6688 |
| **Git Commit**: fef838147fa70c94a254183e23e7e79f0d412ef6                                |
| **Branch/Tag**: v0.17.3                                                                 |
| **Docker Image Tag**: v0.17.3                                                                 |

## Devnet 22

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Date**: Apr 27, 2021                                                                  |
| **Root Height**: 30171528                                                               |
| **Root Parent ID**: 46c7c675f2ed413532009a6a6ecaa566d360a806e033693520d7add147ca89ea                            |
| **Root State Commit**: d88edf1b2a07dba9ef48214dbffb743c0b2e01f7c74e3e14d828ac076d30f1a6 |
| **Git Commit**: 8331b78d99eddea405076e3b6a7839ec5f6ea209                                |
| **Branch/Tag**: v0.16.2                                                                 |
| **Docker Image Tag**: v0.16.2                                                                 |

## Devnet 21

| Spork Info                                                                              |
| :-------------------------------------------------------------------------------------- |
| **Date**: Mar 30, 2021                                                                  |
| **Root Height**: 26935025                                                               |
| **Root Parent ID**: 3f92949a68c577b6d7d17267f00fc47304d1c44052f0c9a078b63fd344f636dd    |
| **Root State Commit**: 21f48748d35178bd6ad89f6324321fa9d123ee7a07b07826acbce887260b2c70 |
| **Git Commit**: 8331b78d99eddea405076e3b6a7839ec5f6ea209                                |
| **Branch/Tag**: v0.15.3-patch.1                                                         |
| **Docker Image Tag**: v0.15.3-patch.1                                                         |

## Devnet 20

| Spork Info                                                                             |
| :------------------------------------------------------------------------------------- |
| **Date**: Mar 9, 2021                                                                  |
| **Root Height**: 25450390                                                              |
| **Root Parent ID**: febe212117a83f7f70ed6a5af285ff03332f81a1120ab2c306560c4cb42672f7   |
| **Root State Commit**: 828259e9cb895f7f8a7306debbe6de524500db65cb6b80e27b2db9040513b04e |
| **Git Commit**: b9b197280d6590576f1ef183bc3d04d41d6be587                               |
| **Branch/Tag**: v0.14.19                                                               |
| **Docker Image Tag**: v0.14.19                                                               |

---

## Devnet 19

| Spork Info                                                                             |
| :------------------------------------------------------------------------------------- |
| **Date**: Feb 3, 2021                                                                  |
| **Root Height**: 16483518                                                              |
| **Root Parent ID**: 4220911048404bd3a7733ab6219531a5945dc20020f86869bcd6422c3a6e3f76   |
| **Root State Commit**: f6eea9b652a7df433b80d8d647ba414aabcfa03153dd1cba33048c27ce888097 |
| **Git Commit**: eb11ae095df6db6e856b1a8e824f03ce4c713b19                               |
| **Branch/Tag**: v0.14.0                                                                |
| **Docker Image Tag**: v0.14.0                                                                |

---

## Devnet 18

| Spork Info                                                                             |
| :------------------------------------------------------------------------------------- |
| **Date**: Dec 11, 2020                                                                 |
| **Root Height**: 17756122                                                              |
| **Root Parent ID**: 52ace0d0c8d4e574213fe98e19a5043f215bee992659bd1ef35c5758acf54d1b   |
| **Root State Commit**: b1412c9d453b1c10d3ace6111e00ac804d564ba3d3295002bedb077685c7da73 |
| **Git Commit**: 115ccee9cae920ee5bc309537cf43a9b152a1cf9                               |
| **Branch/Tag**: v0.13.0                                                                |
| **Docker Image Tag**: v0.13.0                                                                |

---

## Devnet 17

| Spork Info                                                                             |
| :------------------------------------------------------------------------------------- |
| **Date**: Nov 27, 2020                                                                 |
| **Root Height**: 16483518                                                              |
| **Root Parent ID**: 96d452f9d2a15fafab720f1809fc490b019b23e42c885590e62085e48b8c2b6b   |
| **Root State Commit**: 0b45f6055a1f09b413d098997cc0e7c9a0ef19eac8b4d294085b0e2f436c6bff |
| **Git Commit**: ef54713595d0fe1e0bb4b14e9469c4a64dfaf6e7                               |
| **Branch/Tag**: v0.12.1                                                                |
| **Docker Image Tag**: v0.12.1                                                                |
---
title: Spork Process
description: What to do during a spork
---

## Overview

A spork is a coordinated network upgrade process where node operators upgrade their node software and
re-initialize with a consolidated representation of the previous spork's state. This enables rapid development
on the Flow Protocol and minimizes the impact of breaking changes.

The Flow network sporks approximately once every two months. Upcoming sporks
are announced in advance on the `#flow-validators-announcements` **Discord** channel
and in [Upcoming Sporks](./upcoming-sporks.mdx). The `#flow-validators-announcements` channel is
also used to coordinate during the spork process.

This guide is for existing operators participating in a spork. See [Node Bootstrap](./node-bootstrap.mdx)
for a guide to joining the network for the first time.

## Step 1 - Cleaning Up Previous Spork State

Once the spork start has been announced on, stop your node and clear your database. The node should stay stopped for the duration of the spork.

<Callout type="warning">
  You can skip this step if it is your first time running a node on Flow.
</Callout>

1. Stop your Flow node
2. Clear the contents of your `data` directory that you have previously created. The default location is `/var/flow/data`. The `data` directory contains the Flow chain state.

<Callout type="warning">

If you had a previous node running on **mainnet 16**, you'll need to turn it
off just before joining the updated network and re-start your node with the
updated configuration. Refer to Discord communications for guidance during the spork.

</Callout>

## Step 2 - Start Your Node

Once you receive an announcement that the spork process is complete (via Discord), you will need to fetch the genesis info, update your runtime configuration and then boot your Flow node up!

<Callout type="warning">

The Flow team will provide you a new token `PULL_TOKEN` to pull the genesis info from. (Please do NOT use the original Token that you used in Step 1) The `YOUR_NODE_TYPE` must be the same ones that you used when initially [setting up your node](./node-bootstrap.mdx#generate-your-node-keys)

</Callout>

1. Run the transit script to fetch the new genesis info:
   `./boot-tools/transit pull -b ./bootstrap -t ${PULL_TOKEN} -r ${YOUR_NODE_TYPE}`

```shell Example
$ ./boot-tools/transit pull -b ./bootstrap -t mainnet-16  -r consensus
Transit script Commit: a9f6522855e119ad832a97f8b7bce555a163e490
2020/11/25 01:02:53 Running pull
2020/11/25 01:02:53 Downloading bootstrap/public-root-information/node-infos.pub.json
2020/11/25 01:02:54 Downloading bootstrap/public-root-information/root-protocol-snapshot.json
2020/11/25 01:02:54 Downloading bootstrap/random-beacon.priv.json.39fa54984b8eaa463e129919464f61c8cec3a4389478df79c44eb9bfbf30799a.enc
2020/11/25 01:02:54 SHA256 of the root block is: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855

$ tree ./bootstrap/
  ./bootstrap/
  ├── private-root-information
  │   └── private-node-info_39fa54984b8eaa463e129919464f61c8cec3a4389478df79c44eb9bfbf30799a
  │       └── node-info.priv.json
  ├── public-root-information
  │   ├── node-id
  │   ├── node-info.pub.39fa54984b8eaa463e129919464f61c8cec3a4389478df79c44eb9bfbf30799a.json
  │   ├── node-infos.pub.json
  │   └── root-protocol-snapshot.json
  └── random-beacon.priv.json.39fa54984b8eaa463e129919464f61c8cec3a4389478df79c44eb9bfbf30799a
```

2. Pull the latest changes from [flow-go repository](https://github.com/onflow/flow-go)
3. Get your `node-id`, you can find it at `/path/to/bootstrap/public-genesis-information/node-id`
4. Update the `FLOW_GO_NODE_ID` inside [runtime-conf.env](https://github.com/onflow/flow-go/blob/master/deploy/systemd-docker/runtime-conf.env) to the `node-id` that you got from the previous step
5. Start your Flow node via `docker` or `systemd`

See [Node Bootstrap](./node-bootstrap.mdx) for detailed information on Docker/Systemd configuration.

## Common Issues

### Error: cannot create connection

```shell
20T18:34:21Z","message":"could not create connection"}
{"level":"error","node_role":"consensus","node_id":"6d3fac8675a1df96f4bb7a27305ae531b6f4d0d2bc13a233e37bb07ab6b852dc","target":"QmVcSQaCdhmk1CMeMN7HTgGiUY1i2KqgVE2vvEmQXK4gAA","error":"failed to dial : all dials failed
  * [/ip4/155.138.151.101/tcp/3569] dial tcp4 155.138.151.101:3569: connect: connection refused","retry_attempt":2,"time":"2020-05-20T18:34:21Z","message":"could not create connection"}
```

This error is OK. Your fellow node operators have not turned on/joined the network yet. So no need to worry about it!

### Flow Node Not Booting Up

If your Flow node is not able to boot up, or it exits right after it boots up. You will need to do a [clean up of your state](./node-bootstrap.mdx#step-0---cleaning-up-your-previous-state).

After cleaning up the state try booting it up again. If the problem persists, message a member from the Flow team on Discord.
---
title: Upcoming Sporks
description: Information about upcoming Mainnet & Testnet sporks
---

The following are the upcoming Spork dates. These dates indicate the intention to Spork. Announcements will be made regarding any delays or changes to these dates in our developer [Discord server](http://discord.gg/flow).

<div className="spork-table">

| Mainnet Spork Date | Spork Info                                          | Testnet Spork Date                             | Spork Info |
| :----------------- | :---------------------------------------------------| ---------------------------------------------- | ---------- |
| Q3 2023 (date TBD) |                                                     | Q3 2023 (date TBD)                             |            |
| June 21, 2023      | Mainnet 23                                          | Jun 8, 2023                                    | Devnet46   |
|                    |                                                     | Jun 7, 2023                                    | Devnet45   |
|                    |                                                     | Apr 24, 2023                                   | Devnet44   |
|                    |                                                     | Apr 12, 2023                                   | Devnet43   |
|                    |                                                     | Apr 12, 2023                                   | Devnet42   |
| Feb 22, 2023       | Mainnet 22                                          | Jan 30, 2023 —> Feb 22, 2023                   | Devnet41   |
|                    |                                                     | Jan 23, 2023                                   | Devnet40   |
| Jan 18, 2023       | Mainnet 21                                          | Jan 4, 2023 —> Jan 18, 2023                    | Devnet39   |
| Nov 2, 2022        | Mainnet 20                                          | Oct 19, 2022 —> Nov 2, 2022                    | Devnet38   |
| Aug 24, 2022       | Mainnet 19                                          | Aug 10, 2022 —> Aug 24, 2022                   | Devnet37   |
|                    |                                                     | Jul 27, 2022                                   | Devnet36   |
| June 15, 2022      | [Mainnet 18](./past-sporks#mainnet-18)| June 9, 2022 —> June 15, 2022            | Devnet35   |
| April 6, 2022      | [Mainnet 17](./past-sporks#mainnet-17)| April 4, 2022 —> April 6, 2022           | Devnet34   |
| February 9, 2022   | [Mainnet 16](./past-sporks#mainnet-16)| February 7, 2022 —> February 9, 2022     | Devnet33   |
| December 8, 2021   | [Mainnet 15](./past-sporks#mainnet-15)| December 7, 2021 —> December 8, 2021     | Devnet32   |
| November 10, 2021  | Cancelled                                           | November 9, 2021 —> November 10, 2021    | Devnet31   |
| October 6, 2021    | [Mainnet 14](./past-sporks#mainnet-14)| October 5, 2021 —> October 6, 2021       | Devnet30   |
| September 15, 2021 | [Mainnet 13](./past-sporks#mainnet-13)| September 14, 2021 —> September 15, 2021 | Devnet27   |
| August 18, 2021    | [Mainnet 12](./past-sporks#mainnet-12)| August 12, 2021 —> August 18, 2021       | Devnet26   |
| July 21, 2021      | [Mainnet 11](./past-sporks#mainnet-11)| July 20, 2021 —> July 21, 2021           | Devnet25   |
| June 23, 2021      | [Mainnet 10](./past-sporks#mainnet-10)| June 22, 2021 —> June 23, 2021           | Devnet24   |
| May 26, 2021       | [Mainnet 9](./past-sporks#mainnet-9)  | May 25, 2021 —> May 26, 2021             | Devnet23   |
| April 28, 2021     | [Mainnet 8](./past-sporks#mainnet-8)  | April 27, 2021 —> April 28, 2021         | Devnet22   |
| April 7, 2021      | [Mainnet 7](./past-sporks#mainnet-7)  | March 30, 2021 —> March 31, 2021         | Devnet21   |
| March 10, 2021     | [Mainnet 6](./past-sporks#mainnet-6)  | March 9, 2021 —> March 10, 2021          | Devnet20   |

</div>
---
title: Flow Access API rate limits
sidebar_label: Access API Rate Limits
sidebar_position: 2
---

Following are the current rate limits for the [Access Node gRPC API](./access-api.mdx) in total across all public access nodes.
Once the limit has reached, the client will receive an RPC error `ResourceExhausted` in the gRPC response.

Please note, these limits only apply to the public (community) access nodes.

### Mainnet

---

The public access nodes are hosted by [QuickNode](https://www.quicknode.com/chains/flow).

> If you require higher limits, you can either run your own Access node (see this [guide](../node-operation/access-node-setup.md)) or use [QuickNode](https://www.quicknode.com/chains/flow) to run a fully-managed access node.


|                 gRPC API                             | Total requests per second per client IP        |
|:-----------------------------------------------------|:---------------------------------------------:|
| flow.access.AccessAPI/Ping                           |                   100                         |
| flow.access.AccessAPI/GetLatestBlockHeader           |                   100                         |
| flow.access.AccessAPI/GetBlockHeaderByID             |                   100                         |
| flow.access.AccessAPI/GetBlockHeaderByHeight         |                   100                         |
| flow.access.AccessAPI/GetLatestBlock                 |                   100                         |
| flow.access.AccessAPI/GetBlockByID                   |                   100                         |
| flow.access.AccessAPI/GetBlockByHeight               |                   100                         |
| flow.access.AccessAPI/GetCollectionByID              |                   100                         |
| flow.access.AccessAPI/SendTransaction                |                   50                          |
| flow.access.AccessAPI/GetTransaction                 |                   100                         |
| flow.access.AccessAPI/GetTransactionResult           |                   100                         |
| flow.access.AccessAPI/GetAccount                     |                   100                         |
| flow.access.AccessAPI/GetAccountAtLatestBlock        |                   100                         |
| flow.access.AccessAPI/GetAccountAtBlockHeight        |                   100                         |
| flow.access.AccessAPI/ExecuteScriptAtLatestBlock     |                   5                           |
| flow.access.AccessAPI/ExecuteScriptAtBlockID         |                   5                           |
| flow.access.AccessAPI/ExecuteScriptAtBlockHeight     |                   5                           |
| flow.access.AccessAPI/GetEventsForHeightRange        |                   30                          |
| flow.access.AccessAPI/GetEventsForBlockIDs           |                   30                          |
| flow.access.AccessAPI/GetNetworkParameters           |                   100                         |
| flow.access.AccessAPI/GetLatestProtocolStateSnapshot |                   100                         |


_The rate limits are the same for the gRPC-web interface and the REST API_


### Testnet

---


The public access nodes are hosted by Flow Foundation.

|                 gRPC API                             | Total request per second per IP               |
|:-----------------------------------------------------|:---------------------------------------------:|
| flow.access.AccessAPI/Ping                           |                   2000                        |
| flow.access.AccessAPI/GetLatestBlockHeader           |                   2000                        |
| flow.access.AccessAPI/GetBlockHeaderByID             |                   2000                        |
| flow.access.AccessAPI/GetBlockHeaderByHeight         |                   2000                        |
| flow.access.AccessAPI/GetLatestBlock                 |                   2000                        |
| flow.access.AccessAPI/GetBlockByID                   |                   2000                        |
| flow.access.AccessAPI/GetBlockByHeight               |                   2000                        |
| flow.access.AccessAPI/GetCollectionByID              |                   2000                        |
| flow.access.AccessAPI/SendTransaction                |                   2000                        |
| flow.access.AccessAPI/GetTransaction                 |                   2000                        |
| flow.access.AccessAPI/GetTransactionResult           |                   2000                        |
| flow.access.AccessAPI/GetAccount                     |                   2000                        |
| flow.access.AccessAPI/GetAccountAtLatestBlock        |                   2000                        |
| flow.access.AccessAPI/GetAccountAtBlockHeight        |                   2000                        |
| flow.access.AccessAPI/ExecuteScriptAtLatestBlock     |                   200                         |
| flow.access.AccessAPI/ExecuteScriptAtBlockID         |                   200                         |
| flow.access.AccessAPI/ExecuteScriptAtBlockHeight     |                   200                         |
| flow.access.AccessAPI/GetEventsForHeightRange        |                   100                         |
| flow.access.AccessAPI/GetEventsForBlockIDs           |                   100                         |
| flow.access.AccessAPI/GetNetworkParameters           |                   2000                        |
| flow.access.AccessAPI/GetLatestProtocolStateSnapshot |                   4                          |

_The rate limits are the same for the gRPC-web interface and the REST API_

Please note: The rate limits are applied by each of the access nodes behind a load balancer and limits listed here are the aggregate total from all the access nodes. Actual limits may be somewhat less depending on how the requests are routed.
---
title: Flow Access API Specification
sidebar_label: Access API
sidebar_position: 1
---

The Access API is implemented as a [gRPC service](https://grpc.io/).

A language-agnostic specification for this API is defined using [Protocol Buffers](https://developers.google.com/protocol-buffers), which can be used to generate client libraries in a variety of programming languages.

- [Flow Access API protobuf source files](https://github.com/onflow/flow/tree/master/protobuf)

## Flow access node endpoints

The Access Nodes hosted by DapperLabs are accessible at:

| Network     | GRPC                                      | Web GRPC                          | REST                         |
| -------     | ----------------------------------------- | --------------------------------- | ---------------------------- |
| Mainnet     | `access.mainnet.nodes.onflow.org:9000`    | `mainnet.onflow.org`              | `mainnet.onflow.org`         |
| Sandboxnet (deprecated)  |  |  |  |
| Testnet     | `access.devnet.nodes.onflow.org:9000`     | `testnet.onflow.org`              | `testnet.onflow.org`         |

#### Mainnet
##### We are still in the process of aggregating the past chain data but mainnet 5 to mainnet 1 spork data can be retrieved from the Access nodes mentioned [here](../node-operation/spork.mdx#mainnet)

Production network where the Flow blockchain is running. Funds are at risk.

#### Testnet

Our test environment. Funds can be fauceted freely. It is sporked 2 weeks prior to mainnet.

#### Rate limits for Dapper Labs access nodes

Access nodes operated by Dapper Labs are [rate limited](./access-api-rate-limits).

---

## Ping

`Ping` will return a successful response if the Access API is ready and available.

```proto
rpc Ping(PingRequest) returns (PingResponse)
```

If a ping request returns an error or times out, it can be assumed that the Access API is unavailable.


#### Request

```proto
message PingRequest {}
```




#### Response

```proto
message PingResponse {}
```



---

## Block Headers

The following methods query information about [block headers](#block-header).

### GetLatestBlockHeader

`GetLatestBlockHeader` gets the latest sealed or unsealed [block header](#block-header).

```proto
rpc GetLatestBlockHeader (GetLatestBlockHeaderRequest) returns (BlockHeaderResponse)
```


#### Request

```proto
message GetLatestBlockHeaderRequest {
  bool is_sealed
}
```




#### Response

```proto
message BlockHeaderResponse {
  flow.BlockHeader block
  flow.BlockStatus block_status
}
```



### GetBlockHeaderByID

`GetBlockHeaderByID` gets a [block header](#block-header) by ID.

```proto
rpc GetBlockHeaderByID (GetBlockHeaderByIDRequest) returns (BlockHeaderResponse)
```


#### Request

```proto
message GetBlockHeaderByIDRequest {
  bytes id
}
```




#### Response

```proto
message BlockHeaderResponse {
  flow.BlockHeader block
  flow.BlockStatus block_status
}
```



### GetBlockHeaderByHeight

`GetBlockHeaderByHeight` gets a [block header](#block-header) by height.

```proto
rpc GetBlockHeaderByHeight (GetBlockHeaderByHeightRequest) returns (BlockHeaderResponse)
```


#### Request

```proto
message GetBlockHeaderByHeightRequest {
  uint64 height
}
```




#### Response

```proto
message BlockHeaderResponse {
  flow.BlockHeader block
  flow.BlockStatus block_status
}
```



---

## Blocks

The following methods query information about [full blocks](#block).

### GetLatestBlock

`GetLatestBlock` gets the full payload of the latest sealed or unsealed [block](#block).

```proto
rpc GetLatestBlock (GetLatestBlockRequest) returns (BlockResponse)
```


#### Request

```proto
message GetLatestBlockRequest {
  bool is_sealed
}
```




#### Response

```proto
message BlockResponse {
  flow.Block block
  flow.BlockStatus block_status
}
```



### GetBlockByID

`GetBlockByID` gets a [full block](#block) by ID.

```proto
rpc GetBlockByID (GetBlockByIDRequest) returns (BlockResponse)
```


#### Request

```proto
message GetBlockByIDRequest {
  bytes id
}
```




#### Response

```proto
message BlockResponse {
  flow.Block block
  flow.BlockStatus block_status
}
```



### GetBlockByHeight

`GetBlockByHeight` gets a [full block](#block) by height.

```proto
rpc GetBlockByHeight (GetBlockByHeightRequest) returns (BlockResponse)
```


#### Request

```proto
message GetBlockByHeightRequest {
  uint64 height
}
```




#### Response

```proto
message BlockResponse {
  flow.Block block
  flow.BlockStatus block_status
}
```



---

## Collections

The following methods query information about [collections](#collection).

### GetCollectionByID

`GetCollectionByID` gets a [collection](#collection) by ID.

```proto
rpc GetCollectionByID (GetCollectionByIDRequest) returns (CollectionResponse)
```


#### Request

```proto
message GetCollectionByIDRequest {
  bytes id
}
```




#### Response

```proto
message CollectionResponse {
  flow.Collection collection
}
```



---

## Transactions

The following methods can be used to submit [transactions](#transaction) and fetch their results.

### SendTransaction

`SendTransaction` submits a transaction to the network.

```proto
rpc SendTransaction (SendTransactionRequest) returns (SendTransactionResponse)
```

`SendTransaction` determines the correct cluster of collection nodes that is responsible for collecting the transaction based on the hash of the transaction and forwards the transaction to that cluster.


#### Request

`SendTransactionRequest` message contains the transaction that is being request to be executed.

```proto
message SendTransactionRequest {
  flow.Transaction transaction
}
```




#### Response

`SendTransactionResponse` message contains the ID of the submitted transaction.

```proto
message SendTransactionResponse {
  bytes id
}
```



### GetTransaction

`GetTransaction` gets a [transaction](#transaction) by ID.

If the transaction is not found in the access node cache, the request is forwarded to a collection node.

_Currently, only transactions within the current epoch can be queried._

```proto
rpc GetTransaction (GetTransactionRequest) returns (TransactionResponse)
```


#### Request

`GetTransactionRequest` contains the ID of the transaction that is being queried.

```proto
message GetTransactionRequest {
  bytes id
}
```




#### Response

`TransactionResponse` contains the basic information about a transaction, but does not include post-execution results.

```proto
message TransactionResponse {
  flow.Transaction transaction
}
```



### GetTransactionResult

`GetTransactionResult` gets the execution result of a transaction.

```proto
rpc GetTransactionResult (GetTransactionRequest) returns (TransactionResultResponse)
```


#### Request

```proto
message GetTransactionRequest {
  bytes id
}
```




#### Response

```proto
message TransactionResultResponse {
  flow.TransactionStatus status
  uint32 status_code
  string error_message
  repeated flow.Event events
}
```



---

## Accounts

### GetAccount

`GetAccount` gets an [account](#account) by address at the latest sealed block.

⚠️ Warning: this function is deprecated. It behaves identically to `GetAccountAtLatestBlock` and will be removed in a future version.

```proto
rpc GetAccount(GetAccountRequest) returns (GetAccountResponse)
```


#### Request

```proto
message GetAccountRequest {
  bytes address
}
```




#### Response

```proto
message GetAccountResponse {
  Account account
}
```



### GetAccountAtLatestBlock

`GetAccountAtLatestBlock` gets an [account](#account) by address.

The access node queries an execution node for the account details, which are stored as part of the sealed execution state.

```proto
rpc GetAccountAtLatestBlock(GetAccountAtLatestBlockRequest) returns (AccountResponse)
```


#### Request

```proto
message GetAccountAtLatestBlockRequest {
  bytes address
}
```




#### Response

```proto
message AccountResponse {
  Account account
}
```



### GetAccountAtBlockHeight

`GetAccountAtBlockHeight` gets an [account](#accounts) by address at the given block height.

The access node queries an execution node for the account details, which are stored as part of the execution state.

```proto
rpc GetAccountAtBlockHeight(GetAccountAtBlockHeightRequest) returns (AccountResponse)
```


#### Request

```proto
message GetAccountAtBlockHeightRequest {
  bytes address
  uint64 block_height
}
```




#### Response

```proto
message AccountResponse {
  Account account
}
```

##

## Scripts

### ExecuteScriptAtLatestBlock

`ExecuteScriptAtLatestBlock` executes a read-only Cadence script against the latest sealed execution state.

This method can be used to read execution state from the blockchain. The script is executed on an execution node and the return value is encoded using the [JSON-Cadence data interchange format](https://cadence-lang.org/docs/json-cadence-spec).

```proto
rpc ExecuteScriptAtLatestBlock (ExecuteScriptAtLatestBlockRequest) returns (ExecuteScriptResponse)
```

This method is a shortcut for the following:

```
header = GetLatestBlockHeader()
value = ExecuteScriptAtBlockID(header.ID, script)
```


#### Request

```proto
message ExecuteScriptAtLatestBlockRequest {
  bytes script
}
```




#### Response

```proto
message ExecuteScriptResponse {
  bytes value
}
```



### ExecuteScriptAtBlockID

`ExecuteScriptAtBlockID` executes a ready-only Cadence script against the execution state at the block with the given ID.

This method can be used to read account state from the blockchain. The script is executed on an execution node and the return value is encoded using the [JSON-Cadence data interchange format](https://cadence-lang.org/docs/json-cadence-spec).

```proto
rpc ExecuteScriptAtBlockID (ExecuteScriptAtBlockIDRequest) returns (ExecuteScriptResponse)
```


#### Request

```proto
message ExecuteScriptAtBlockIDRequest {
  bytes block_id
  bytes script
}
```




#### Response

```proto
message ExecuteScriptResponse {
  bytes value
}
```



### ExecuteScriptAtBlockHeight

`ExecuteScriptAtBlockHeight` executes a ready-only Cadence script against the execution state at the given block height.

This method can be used to read account state from the blockchain. The script is executed on an execution node and the return value is encoded using the [JSON-Cadence data interchange format](https://cadence-lang.org/docs/json-cadence-spec).

```proto
rpc ExecuteScriptAtBlockHeight (ExecuteScriptAtBlockHeightRequest) returns (ExecuteScriptResponse)
```


#### Request

```proto
message ExecuteScriptAtBlockHeightRequest {
  uint64 block_height
  bytes script
}
```




#### Response

```proto
message ExecuteScriptResponse {
  bytes value
}
```



---

## Events

The following methods can be used to query for on-chain [events](#event).

### GetEventsForHeightRange

`GetEventsForHeightRange` retrieves [events](#event) emitted within the specified block range.

```proto
rpc GetEventsForHeightRange(GetEventsForHeightRangeRequest) returns (GetEventsForHeightRangeResponse)
```

Events can be requested for a specific sealed block range via the `start_height` and `end_height` (inclusive) fields and further filtered by event type via the `type` field.

If `start_height` is greater than the current sealed chain height, then this method will return an error.

If `end_height` is greater than the current sealed chain height, then this method will return events up to and including the latest sealed block.

The event results are grouped by block, with each group specifying a block ID, height and block timestamp.

Event types are name-spaced with the address of the account and contract in which they are declared.


#### Request

```proto
message GetEventsForHeightRangeRequest {
  string type
  uint64 start_height = 2;
  uint64 end_height = 3;
}
```




#### Response

```proto
message EventsResponse {
  message Result {
    bytes block_id = 1;
    uint64 block_height = 2;
    repeated entities.Event events = 3;
    google.protobuf.Timestamp block_timestamp = 4;
  }
  repeated Result results = 1;
}
```



### GetEventsForBlockIDs

`GetEventsForBlockIDs` retrieves [events](#event) for the specified block IDs and event type.

```proto
rpc GetEventsForBlockIDs(GetEventsForBlockIDsRequest) returns (GetEventsForBlockIDsResponse)
```

Events can be requested for a list of block IDs via the `block_ids` field and further filtered by event type via the `type` field.

The event results are grouped by block, with each group specifying a block ID, height and block timestamp.


#### Request

```proto
message GetEventsForBlockIDsRequest {
  string type = 1;
  repeated bytes block_ids = 2;
}
```




#### Response

```proto
message EventsResponse {
  message Result {
    bytes block_id = 1;
    uint64 block_height = 2;
    repeated entities.Event events = 3;
    google.protobuf.Timestamp block_timestamp = 4;
  }
  repeated Result results = 1;
}
```



---

## Network Parameters

Network parameters provide information about the Flow network. Currently, it only includes the chain ID.
The following method can be used to query for network parameters.

### GetNetworkParameters

`GetNetworkParameters` retrieves the network parameters.

```proto
rpc GetNetworkParameters (GetNetworkParametersRequest) returns (GetNetworkParametersResponse)
```


#### Request

```proto
message GetNetworkParametersRequest {}
```




#### Response

```proto
message GetNetworkParametersResponse {
  string chain_id = 1;
}
```

| Field    | Description                                                                                                  |
| -------- | ------------------------------------------------------------------------------------------------------------ |
| chain_id | Chain ID helps identify the Flow network. It can be one of `flow-mainnet`, `flow-testnet` or `flow-emulator` |



---

## Protocol state snapshot

The following method can be used to query the latest protocol state [snapshot](https://github.com/onflow/flow-go/blob/master/state/protocol/snapshot.go).

### GetLatestProtocolStateSnapshotRequest

`GetLatestProtocolStateSnapshotRequest` retrieves the latest Protocol state snapshot serialized as a byte array.
It is used by Flow nodes joining the network to bootstrap a space-efficient local state.

```proto
rpc GetLatestProtocolStateSnapshot (GetLatestProtocolStateSnapshotRequest) returns (ProtocolStateSnapshotResponse);
```


#### Request

```proto
message GetLatestProtocolStateSnapshotRequest {}
```




#### Response

```proto
message ProtocolStateSnapshotResponse {
  bytes serializedSnapshot = 1;
}
```


## Execution results

The following method can be used to query the for [execution results](https://github.com/onflow/flow-go/blob/master/model/flow/execution_result.go) for a given block.

### GetExecutionResultForBlockID

`GetExecutionResultForBlockID` retrieves execution result for given block. It is different from Transaction Results,
and contain data about chunks/collection level execution results rather than particular transactions.
Particularly, it contains `EventsCollection` hash for every chunk which can be used to verify the events for a block.

```proto
rpc GetExecutionResultForBlockID(GetExecutionResultForBlockIDRequest) returns (ExecutionResultForBlockIDResponse);
```


#### Request

```proto
message GetExecutionResultForBlockIDRequest {
  bytes block_id = 1;
}
```



#### Response

```proto
message ExecutionResultForBlockIDResponse {
  flow.ExecutionResult execution_result = 1;
}
```




## Entities

Below are in-depth descriptions of each of the data entities returned or accepted by the Access API.

## Block

```proto
message Block {
  bytes id
  bytes parent_id
  uint64 height
  google.protobuf.Timestamp timestamp
  repeated CollectionGuarantee collection_guarantees
  repeated BlockSeal block_seals
  repeated bytes signatures
}
```

| Field                 | Description                                                                                                                                                                                                                                                                                                       |
| --------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| id                    | SHA3-256 hash of the entire block payload                                                                                                                                                                                                                                                                         |
| height                | Height of the block in the chain                                                                                                                                                                                                                                                                                  |
| parent_id             | ID of the previous block in the chain                                                                                                                                                                                                                                                                             |
| timestamp             | Timestamp of when the proposer claims it constructed the block. <br/> **NOTE**: It is included by the proposer, there are no guarantees on how much the time stamp can deviate from the true time the block was published. <br/> Consider observing blocks' status changes yourself to get a more reliable value. |
| collection_guarantees | List of [collection guarantees](#collection-guarantee)                                                                                                                                                                                                                                                            |
| block_seals           | List of [block seals](#block-seal)                                                                                                                                                                                                                                                                                |
| signatures            | BLS signatures of consensus nodes                                                                                                                                                                                                                                                                                 |

The detailed semantics of block formation are covered in the [block formation guide](../../../build/basics/blocks.md).

## Block Header

A block header is a summary of a [block](#block) and contains only the block ID, height, and parent block ID.

```proto
message BlockHeader {
  bytes id
  bytes parent_id
  uint64 height
}
```

| Field     | Description                               |
| --------- | ----------------------------------------- |
| id        | SHA3-256 hash of the entire block payload |
| parent_id | ID of the previous block in the chain     |
| height    | Height of the block in the chain          |

## Block Seal

A block seal is an attestation that the execution result of a specific [block](#block) has been verified and approved by a quorum of verification nodes.

```proto
message BlockSeal {
  bytes block_id
  bytes execution_receipt_id
  repeated bytes execution_receipt_signatures
  repeated bytes result_approval_signatures
}
```

| Field                        | Description                                                            |
| ---------------------------- | ---------------------------------------------------------------------- |
| block_id                     | ID of the block being sealed                                           |
| execution_receipt_id         | ID execution receipt being sealed                                      |
| execution_receipt_signatures | BLS signatures of verification nodes on the execution receipt contents |
| result_approval_signatures   | BLS signatures of verification nodes on the result approval contents   |

## Block Status

```proto
enum BlockStatus {
  UNKNOWN = 0;
  FINALIZED = 1;
  SEALED = 2;
}
```

| Value     | Description                                              |
| --------- | -------------------------------------------------------- |
| UNKNOWN   | The block status is not known.                           |
| FINALIZED | The consensus nodes have finalized the block             |
| SEALED    | The verification nodes have verified the block           |

## Collection

A collection is a batch of [transactions](#transaction) that have been included in a block. Collections are used to improve consensus throughput by increasing the number of transactions per block.

```proto
message Collection {
  bytes id
  repeated bytes transaction_ids
}
```

| Field           | Description                                       |
| --------------- | ------------------------------------------------- |
| id              | SHA3-256 hash of the collection contents          |
| transaction_ids | Ordered list of transaction IDs in the collection |

## Collection Guarantee

A collection guarantee is a signed attestation that specifies the collection nodes that have guaranteed to store and respond to queries about a collection.

```proto
message CollectionGuarantee {
  bytes collection_id
  repeated bytes signatures
}
```

| Field         | Description                                                        |
| ------------- | ------------------------------------------------------------------ |
| collection_id | SHA3-256 hash of the collection contents                           |
| signatures    | BLS signatures of the collection nodes guaranteeing the collection |

## Transaction

A transaction represents a unit of computation that is submitted to the Flow network.

```proto
message Transaction {
  bytes script
  repeated bytes arguments
  bytes reference_block_id
  uint64 gas_limit
  TransactionProposalKey proposal_key
  bytes payer
  repeated bytes authorizers
  repeated TransactionSignature payload_signatures
  repeated TransactionSignature envelope_signatures
}

message TransactionProposalKey {
  bytes address
  uint32 key_id
  uint64 sequence_number
}

message TransactionSignature {
  bytes address
  uint32 key_id
  bytes signature
}
```

| Field                         | Description                                                                                          |
| ----------------------------- | ---------------------------------------------------------------------------------------------------- |
| script                        | Raw source code for a Cadence script, encoded as UTF-8 bytes                                         |
| arguments                     | Arguments passed to the Cadence script, encoded as [JSON-Cadence](https://cadence-lang.org/docs/json-cadence-spec) bytes |
| reference_block_id            | Block ID used to determine transaction expiry                                                        |
| [proposal_key](#proposal-key) | Account key used to propose the transaction                                                          |
| payer                         | Address of the payer account                                                                         |
| authorizers                   | Addresses of the transaction authorizers                                                             |
| signatures                    | [Signatures](#transaction-signatures) from all signer accounts                                       |

The detailed semantics of transaction creation, signing and submission are covered in the [transaction submission guide](../../../build/basics/transactions.md#signing-a-transaction).

### Proposal Key

The proposal key is used to specify a sequence number for the transaction. Sequence numbers are covered in more detail [here](../../../build/basics/transactions.md#sequence-numbers).

| Field           | Description                                                                          |
| --------------- | ------------------------------------------------------------------------------------ |
| address         | Address of proposer account                                                          |
| key_id          | ID of proposal key on the proposal account                                           |
| sequence_number | [Sequence number](../../../build/basics/transactions.md#sequence-numbers) for the proposal key |

### Transaction Signature

| Field     | Description                               |
| --------- | ----------------------------------------- |
| address   | Address of the account for this signature |
| key_id    | ID of the account key                     |
| signature | Raw signature byte data                   |

### Transaction Status

```proto
enum TransactionStatus {
  UNKNOWN = 0;
  PENDING = 1;
  FINALIZED = 2;
  EXECUTED = 3;
  SEALED = 4;
  EXPIRED = 5;
}
```

| Value     | Description                                                                                                                               |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| UNKNOWN   | The transaction status is not known.                                                                                                      |
| PENDING   | The transaction has been received by a collector but not yet finalized in a block.                                                        |
| FINALIZED | The consensus nodes have finalized the block that the transaction is included in                                                          |
| EXECUTED  | The execution nodes have produced a result for the transaction                                                                            |
| SEALED    | The verification nodes have verified the transaction (the block in which the transaction is) and the seal is included in the latest block |
| EXPIRED   | The transaction was submitted past its expiration block height.                                                                           |

## Account

An account is a user's identity on Flow. It contains a unique address, a balance, a list of public keys and the code that has been deployed to the account.

```proto
message Account {
  bytes address
  uint64 balance
  bytes code
  repeated AccountKey keys
  map<string, bytes> contracts
}
```

| Field     | Description                                                                 |
| --------- | --------------------------------------------------------------------------- |
| address   | A unique account identifier                                                 |
| balance   | The account balance                                                         |
| code      | The code deployed to this account (**deprecated**, use `contracts` instead) |
| keys      | A list of keys configured on this account                                   |
| contracts | A map of contracts or contract interfaces deployed on this account          |

The `code` and `contracts` fields contain the raw Cadence source code, encoded as UTF-8 bytes.

More information on accounts can be found [here](../../../build/basics/accounts.md).

### Account Key

An account key is a reference to a public key associated with a Flow account. Accounts can be configured with zero or more public keys, each of which can be used for signature verification when authorizing a transaction.

```proto
message AccountKey {
  uint32 id
  bytes public_key
  uint32 sign_algo
  uint32 hash_algo
  uint32 weight
  uint32 sequence_number
  bool revoked
}
```

| Field           | Description                                                                             |
| --------------- | --------------------------------------------------------------------------------------- |
| id              | Index of the key within the account, used as a unique identifier                        |
| public_key      | Public key encoded as bytes                                                             |
| sign_algo       | [Signature algorithm](../../../build/basics/accounts.md#signature-and-hash-algorithms) |
| hash_algo       | [Hash algorithm](../../../build/basics/accounts.md#signature-and-hash-algorithms)      |
| weight          | [Weight assigned to the key](../../../build/basics/accounts.md#account-keys)                 |
| sequence_number | [Sequence number for the key](../../../build/basics/transactions.md#sequence-numbers)             |
| revoked         | Flag indicating whether or not the key has been revoked                                 |

More information on account keys, key weights and sequence numbers can be found [here](../../../build/basics/accounts.md).

## Event

An event is emitted as the result of a [transaction](#transaction) execution. Events are either user-defined events originating from a Cadence smart contract, or built-in Flow system events.

```proto
message Event {
  string type
  bytes transaction_id
  uint32 transaction_index
  uint32 event_index
  bytes payload
}
```

| Field             | Description                                                                |
| ----------------- | -------------------------------------------------------------------------- |
| type              | Fully-qualified unique type identifier for the event                       |
| transaction_id    | ID of the transaction the event was emitted from                           |
| transaction_index | Zero-based index of the transaction within the block                       |
| event_index       | Zero-based index of the event within the transaction                       |
| payload           | Event fields encoded as [JSON-Cadence values](https://cadence-lang.org/docs/json-cadence-spec) |

## Execution Result

Execution result for a particular block.

```proto
message ExecutionResult {
  bytes previous_result_id
  bytes block_id
  repeated Chunk chunks
  repeated ServiceEvent service_events
}
```

| Field              | Description                                          |
| ------------------ | ---------------------------------------------------- |
| previous_result_id | Identifier of parent block execution result          |
| block_id           | ID of the block this execution result corresponds to |
| chunks             | Zero or more chunks                                  |
| service_events     | Zero or more service events                          |


### Chunk

Chunk described execution information for given collection in a block

```proto
message Chunk {
  bytes start_state
  bytes event_collection
  bytes block_id
  uint64 total_computation_used
  uint64 number_of_transactions
  uint64 index
  bytes end_state
}
```

| Field                  | Description                                          |
| ---------------------- | ---------------------------------------------------- |
| start_state            | State commitment at start of the chunk               |
| event_collection       | Hash of events emitted by transactions in this chunk |
| block_id               | Identifier of a block                                |
| total_computation_used | Total computation used by transactions in this chunk |
| number_of_transactions | Number of transactions in a chunk                    |
| index                  | Index of chunk inside a block (zero-based)           |
| end_state              | State commitment after executing chunk               |

### Service Event

Special type of events emitted in system chunk used for controlling Flow system.

```proto
message ServiceEvent {
  string type;
  bytes payload;
}
```

| Field   | Description                         |
| ------- | ----------------------------------- |
| type    | Type of an event                    |
| payload | JSON-serialized content of an event |

---
title: Flow Archive Node Access API Specification
sidebar_label: Archive API
sidebar_position: 3
---

The Archive Access API is implemented as a [gRPC service](https://grpc.io/).

A language-agnostic specification for this API is defined using [Protocol Buffers](https://developers.google.com/protocol-buffers), which can be used to generate client libraries in a variety of programming languages.

- [Flow Archive Access API protobuf source files](https://github.com/onflow/flow/tree/master/protobuf)

## Flow archive node access endpoints

The Archive Nodes hosted by DapperLabs are accessible at:

#### Current Mainnet
`archive.mainnet.nodes.onflow.org:9000`

#### Testnet

`archive.devnet.nodes.onflow.org:9000`

#### Canarynet

`archive.canary.nodes.onflow.org:9000`

#### Rate limits for Dapper Labs archive nodes

Archive nodes operated by Dapper Labs are [rate limited](./archive-api-rate-limits.mdx).

---

## Accounts

### GetAccountAtBlockHeight

`GetAccountAtBlockHeight` gets an [account](#accounts) by address at the given block height.

The archive node queries an execution node for the account details, which are stored as part of the execution state.

```proto
rpc GetAccountAtBlockHeight(GetAccountAtBlockHeightRequest) returns (AccountResponse)
```


#### Request

```proto
message GetAccountAtBlockHeightRequest {
  bytes address
  uint64 block_height
}
```




#### Response

```proto
message AccountResponse {
  Account account
}
```


## Scripts

### ExecuteScriptAtBlockID

`ExecuteScriptAtBlockID` executes a ready-only Cadence script against the execution state at the block with the given ID.

This method can be used to read account state from the blockchain. The script is executed on an execution node and the return value is encoded using the [JSON-Cadence data interchange format](https://cadence-lang.org/docs/json-cadence-spec).

```proto
rpc ExecuteScriptAtBlockID (ExecuteScriptAtBlockIDRequest) returns (ExecuteScriptResponse)
```


#### Request

```proto
message ExecuteScriptAtBlockIDRequest {
  bytes block_id
  bytes script
}
```




#### Response

```proto
message ExecuteScriptResponse {
  bytes value
}
```



### ExecuteScriptAtBlockHeight

`ExecuteScriptAtBlockHeight` executes a ready-only Cadence script against the execution state at the given block height.

This method can be used to read account state from the blockchain. The script is executed on an execution node and the return value is encoded using the [JSON-Cadence data interchange format](https://cadence-lang.org/docs/json-cadence-spec).

```proto
rpc ExecuteScriptAtBlockHeight (ExecuteScriptAtBlockHeightRequest) returns (ExecuteScriptResponse)
```


#### Request

```proto
message ExecuteScriptAtBlockHeightRequest {
  uint64 block_height
  bytes script
}
```




#### Response

```proto
message ExecuteScriptResponse {
  bytes value
}
```
---
title: Archive Access API rate limits on Dapper Labs Archive nodes
sidebar_label: Archive API Rate Limits
sidebar_position: 4
---

#### Rate limits

Following are the current rate limits for the [Archive Node gRPC API](./archive-access-api.mdx) in total across all Dapper Labs Archive nodes. The actual limits are enforced by each individual node. If you are using a load balanced endpoint, the limits below are the max rate, and may vary depending on how your requests are routed.

Once the limit has reached, the client will receive an RPC error `ResourceExhausted` in the gRPC response.

Please note, these limits only apply to the archive nodes hosted by Dapper Labs. Archive nodes run by other node operators will have different rate limits.
Also, all the gRPC endpoints listed below start with `flow.access.AccessAPI` due to the Archive Access API having the same gRPC protobuf definitions as the original Access API from our [Access Nodes](../../../references/run-and-secure/node-operation/node-roles.mdx#access). For information on rate limitting of the Access API for Flow's Access Nodes please visit [this page](./access-api-rate-limits.mdx).

##### Mainnet

|                 gRPC API                             | Total request per second per client IP        |
|:-----------------------------------------------------|:---------------------------------------------:|
| flow.access.AccessAPI/GetAccountAtBlockHeight        |                   5                           |
| flow.access.AccessAPI/ExecuteScriptAtBlockID         |                   5                           |
| flow.access.AccessAPI/ExecuteScriptAtBlockHeight     |                   5                           |


##### Testnet

|                 gRPC API                             | Total request per second per IP               |
|:-----------------------------------------------------|:---------------------------------------------:|
| flow.access.AccessAPI/GetAccountAtLatestBlock        |                   5                           |
| flow.access.AccessAPI/ExecuteScriptAtBlockID         |                   5                           |
| flow.access.AccessAPI/ExecuteScriptAtBlockHeight     |                   5                           |



{
    "label": "FAQ"
  }---
title: Flow Users / Backers
description: FAQ
---

## Does Flow have a block explorer?

There are two block explorers live today. You can find them here:

- https://flowdiver.io/
- https://flow.bigdipper.live/

## I staked and now I can't see my FLOW - what happened?

Once you complete a successful staking or delegation request, your tokens are sent to the staking contract. Your tokens are not lost - they are staked! To view your active stake or delegation, navigate to the Stake & Delegate page on Flow Port (left side bar, or this URL + your address after the last slash ([https://port.onflow.org/stake-delegate/](https://port.onflow.org/stake-delegate/))

## Is it possible to add multiple public keys to a given account/address so that it can be controlled by more than one private key?

Yes, accounts support multiple, weighted keys, [here](https://cadence-lang.org/docs/language/accounts)
using `AuthAccount`’s `fun addPublicKey(_ publicKey: [UInt8])`and <br/>`fun removePublicKey(_ index: Int)` functions.

## How do keys and accounts work on Flow?

Accounts are created with associated keys. There can be multiple keys on an account. To execute transactions from the account, a total of 1000 weight keys need to sign. The account holds a field for FLOW balance. When transactions move flow, that balance is updated by the protocol. The account also holds place for storage and contract code.

FLOW supports a variety of signature schemes for adding keys to an account.

Details: [concepts/accounts-and-keys](../../../../build/basics/accounts.md)

## How do I create a Flow account if I do not have a service account?

Instructions to generate an address are here: [flow-go-sdk/creating-accounts](../../../../tools/clients/flow-go-sdk/index.mdx#create-accounts). You don't need a service account.
---
title: Builders / Developers
description: FAQ
---

## What is the expected TPS (transactions per second) for the forseeable future?

Not all transactions are equal, so throughput numbers alone doesn't tell the whole story.
Flow’s transaction throughput depends on a variety of factors, such as networking bandwidth available to the nodes and optimizations in our implementation. The dominant factor is transaction complexity, impacted by the number of instructions your transaction executes, the number of ledger reads and writes your transaction performs and how many signatures have to be checked to confirm that your transaction has the required privileges. For benchmark loads of simple token balance transfers (essentially an addition and subtraction plus two signature verifications), our current implementation easily sustained a throughput of significantly more than 100 tps. However, we observed that transactions on Mainnet are generally considerably more complex (requiring several signature verifications; many ledger reads and writes; and running relatively complex computations). For the near-term future, 100tps seems like a realistic magnitude. We are working hard towards sustaining 100tps of the kind which are currently run on Mainnet. If your transactions are much simpler than the average Mainnet transaction, Flow potentially already satisfies your desired throughput. The best way to find out would be to test a benchmark set of your specific transactions on TestNet.

## Does Flow have a block explorer?

There are two block explorers live today. You can find them here:

- https://flowdiver.io/
- https://flow.bigdipper.live/

## How can I connect to and query the Access Nodes? What data is available there?

At the protocol level, you can connect to an access node via GRPC. We provide JavaScript and Golang SDKs to do this for you.

Once you have connected to an access node, you can fetch information regarding accounts, contracts, blocks, collections, transactions, and events. You can also execute scripts to query the current state of the Flow blockchain.

### Available Data

#### Accounts, Contracts, Blocks, Collections, Transactions, Events

These types are documented on the [Access API](/http-api) page.

The SDKs expose Flow data as types. For example the Go Flow Block data type implementation can be found here:

[https://github.com/onflow/flow-go-sdk/blob/master/block.go](https://github.com/onflow/flow-go-sdk/blob/master/block.go)

You can query historical data and fetch contract code using the SDKs.

### Scripts

Flow allows you to actively query the state of the blockchain using scripts written in the Cadence programming language. You can find out more about Cadence here:

[cadence](../../../../build/guides/smart-contracts/cadence.md)

Running scripts and parsing their output is supported by the SDKs.

Scripts can access multiple contracts and accounts, calculate values, and ensure that data is correct using Cadence's type system. They can only access the _current_ state of the blockchain.

### Using The SDKs

#### JavaScript

You can download FCL (Flow Client Library) here:

[https://github.com/onflow/fcl-js](https://github.com/onflow/fcl-js)

To connect to an access node you will need to provide a URL to the SDK.
[testnet and mainnet](../access-api.mdx)

Here are examples of querying an access node at the bottom of this page:

[https://github.com/onflow/fcl-js/tree/master/packages/sdk](https://github.com/onflow/fcl-js/tree/master/packages/sdk)

Here are examples of creating a script and Cadence data types:

[https://github.com/onflow/fcl-js/tree/master/packages/types#scripts](https://github.com/onflow/fcl-js/tree/master/packages/types#scripts)

And here are examples of parsing script output:

[https://github.com/onflow/fcl-js/tree/master/packages/sdk/src/decode](https://github.com/onflow/fcl-js/tree/master/packages/sdk/src/decode)

#### Go

You can download the Go SDK here:

[https://github.com/onflow/flow-go-sdk](https://github.com/onflow/flow-go-sdk)

To connect to an access node you will need to provide a URL to the SDK.
**testnet: access.devnet.nodes.onflow.org:9000
mainnet: access.mainnet.nodes.onflow.org:9000**

You can find examples of querying an access node at the bottom of this page:

[https://github.com/onflow/flow-go-sdk/blob/master/README.md](https://github.com/onflow/flow-go-sdk/blob/master/README.md)

You can find examples using the emulator that can be adapted to use an access node here:

[https://github.com/onflow/flow-go-sdk/blob/master/examples/get_events/main.go](https://github.com/onflow/flow-go-sdk/blob/master/examples/get_events/main.go)

And here is an example of using a script:

[https://github.com/onflow/flow-go-sdk#executing-a-script](https://github.com/onflow/flow-go-sdk#executing-a-script)

#### Other Programming Languages

For an example of implementing access node communication using another programming language, see "Interact with Flow using Ruby" by Daniel Podaru:
[https://www.onflow.org/post/interact-with-flow-using-ruby](https://www.onflow.org/post/interact-with-flow-using-ruby)

## How do apps consume events? How do events work?

Flow transactions can emit informative "events" containing data intended to be used by off-chain observers. Events can be used to trigger backend or UI events, for example.

Note that a single transaction may emit many events, and that the order of events may surprise you if a non-standard transaction is being used. Event parameters may be optional, which means that they might be nil in some scenarios. All of this means that you must be careful when parsing events.

### Defining Events

Events are implemented within Flow smart contracts using the Cadence programming language.

You can find out more about events in Cadence here:

[cadence/language/events/](https://cadence-lang.org/docs/language/events)

As an example of the kinds of information events can contain, see the documentation of the events that the staking protocol emits:

[staking/events](../../../../references/run-and-secure/staking/07-staking-scripts-events.md)

### Consuming Events

To consume events, you must query a Flow Access Node and specify the type of event and the range of blocks you wish to fetch those events from. You can then parse any returned events and handle the information that they contain.

### Using Go

Once you connect to an Access Node using the Go SDK you can query for events.

This is documented here:

[https://github.com/onflow/flow-go-sdk#querying-events](https://github.com/onflow/flow-go-sdk#querying-events)

And there is an example of usage here:
https://github.com/onflow/flow-go-sdk/blob/master/examples/get_events/main.go
[https://github.com/onflow/flow-go-sdk/blob/master/examples/get_events](https://github.com/onflow/flow-go-sdk/blob/master/examples/get_events)

### Using JavaScript

Once you connect to an Access Node using FCL (Flow Client Library) you can query for events.

This is documented here:

[https://github.com/onflow/fcl-js/tree/master/packages/sdk#getevents-usage](https://github.com/onflow/fcl-js/tree/master/packages/sdk#getevents-usage)

### Using Other Programming Languages

Currently, we only provide Go and FCL-JS (Flow Client Library) for Flow. For an example of accessing the Flow blockchain and consuming events from it using another programming language, see "Interact with Flow using Ruby" by Daniel Podaru:

[https://www.onflow.org/post/interact-with-flow-using-ruby](https://www.onflow.org/post/interact-with-flow-using-ruby)

## What is FCL?

FCL (Flow Client Library) enables applications to easily integrate with all FCL-compatible wallets and other services (e.g. profiles, private information, notifications). This offers developers a strong foundation to compose their apps with existing building blocks. FCL is currently supported for browser applications, and will be extended to other platforms.

With FCL, you can:

- Integrate all compatible wallets without any custom code or code injection
- Authenticate users
- Query users' Flow accounts
- Send transactions (e.g. initializing resources, sending assets, purchasing, etc.)
- Sign transactions through wallet integration to avoid key management (especially helpful for non-custodial apps)

## How do I access mainnet?

You can find details about accessing Flow mainnet here [/http-api](/http-api).

The access is via a GRPC interface. Transactions can also be submitted using the GRPC [SendTransaction call](/http-api#tag/Transactions/paths/~1transactions/post). A GRPC client written in any language should be able to talk via the Access API. We have a [Go SDK](https://github.com/onflow/flow-go-sdk) and [FCL-JS (Flow Client Library)](https://github.com/onflow/fcl-js) that can be used if you are using a Go based or a JS based client respectively.

## What's the difference between a mainnet spork and testnet spork? How do sporks affect TopShot?

The Mainnet and Testnet are two separate networks. The difference is which network will be undergoing the down time. Since the main application for NBA TopShot exists on Mainnet, only Mainnet sporks will affect the main applications uptime.

Currently NBA Top Shot runs on Mainnet and NBA Top Shot test app runs on Flow Testnet.

## How much will Gas cost on Flow?

Starting on October 16, 2021 at 7:30am PT (2:30pm UTC), there will be a flat fee of 0.00001 FLOW applied to every transaction submitted to the network. Transaction Fees are subject to change. In the event that a change does occur, the community will be informed ahead of implementation. These fees are for spam prevention and will be low and fixed for all transactions.

## How can I deploy a contract?

To deploy a contract, please follow the steps outlined in the [Dapp Deployment guide](../../../../tools/flow-cli/accounts/account-add-contract.md).

## How can I create my first account for mainnet?

New accounts can be created using Flow Port. You can [follow these guidelines to get a new mainnet account](../flow-port/index.md#creating-an-account).

## How can I deploy a contract to mainnet?

Please review the [Dapp Deployment guide](../../../../tools/flow-cli/accounts/account-add-contract.md) for all details.

## Is there a testnet/devnet?

There is an access node for you to develop against on the testnet/devnet. You can learn more about it [here](../../../../references/flow-networks)

## Is there a public node?

Yes, an access node is publicly accessible to submit transactions and read data from the blockchain. If you’d like to access the devnet access node to build against, you can do so [here](../../../../references/flow-networks/accessing-testnet.md#accessing-flow-testnet)

## Is it possible to add multiple public keys to a given account/address so that it can be controlled by more than one private key?

Yes, accounts support multiple, weighted keys, [here](https://cadence-lang.org/docs/language/accounts)
using `AuthAccount`’s `fun addPublicKey(_ publicKey: [UInt8])`and <br/>`fun removePublicKey(_ index: Int)` functions.

## How do keys and accounts work on Flow?

Accounts are created with associated keys. There can be multiple keys on an account. To execute transactions from the account, a total of 1000 weight keys need to sign. The account holds a field for FLOW balance. When transactions move flow, that balance is updated by the protocol. The account also holds place for storage and contract code.

FLOW supports a variety of signature schemes for adding keys to an account.

Details: [concepts/accounts-and-keys](../../../../build/basics/accounts.md)

## How can I see what Fungible-Tokens an account has?

If you know the /public/ storage path to the FungibleToken.Balance capability for a particular FT vault type, you can borrow that and check its balance. If you wish to know which vaults an account has, you will currently have to check a list of well-known paths. There is an issue that may help with this in future - [https://github.com/onflow/cadence/issues/208](https://github.com/onflow/cadence/issues/208)

## How can I see what NFTs an account has?

If you know the /public/ storage path to the NonFungibleToken.CollectionPublic capability for a particular NFT type, you can borrow that and call getIDs() on it. If you wish to know which token collections an account has, you will currently have to check a list of well-known paths. There is an issue that may help with this in future - [https://github.com/onflow/cadence/issues/208](https://github.com/onflow/cadence/issues/208)

## How can I see what resources an account has?

Flow doesn't yet provide functionality to inspect all of the resources on an account, but it is possible to execute a Cadence script that checks for resources at known storage paths.

## How do I create a Flow account if I do not have a service account?

Instructions to generate an address are here: [flow-go-sdk#create-accounts](../../../../tools/clients/flow-go-sdk/index.mdx#create-accounts). You don't need a service account.

## Is there a tutorial about how to access flow testnet? From scratch, getting testnet, Flow token etc..?

Yes: [testnet-deployment](../../../../build/guides/smart-contracts/deploying.md)

## Can you query events between a block range?

You can query the access API to get events for a block range. See Access API spec here: [/http-api](/http-api).

## Where can I follow feature releases on Flow?

You can follow Flow node software releases here: [https://github.com/onflow/flow-go/releases](https://github.com/onflow/flow-go/releases).
---
title: Flow Operators
description: FAQ
---

## What is the expected TPS (transactions per second) for the forseeable future?

Not all transactions are equal, so throughput numbers alone doesn't tell the whole story.
Flow’s transaction throughput depends on a variety of factors, such as networking bandwidth available to the nodes and optimizations in Flow's implementation. The dominant factor is transaction complexity, impacted by the number of instructions your transaction executes, the number of ledger reads and writes your transaction performs and how many signatures have to be checked to confirm that your transaction has the required privileges. For benchmark loads of simple token balance transfers (essentially an addition and subtraction plus two signature verifications), Flow's current implementation easily sustained a throughput of significantly more than 100 tps. However, we observed that transactions on Mainnet are generally considerably more complex (requiring several signature verifications; many ledger reads and writes; and running relatively complex computations). For the near-term future, 100tps seems like a realistic magnitude. We are working hard towards sustaining 100tps of the kind which are currently run on Mainnet. If your transactions are much simpler than the average Mainnet transaction, Flow potentially already satisfies your desired throughput. The best way to find out would be to test a benchmark set of your specific transactions on TestNet.

## Does the blockheight go up 1 every second?

Flow targets 1 second block times but the protocol is still early in its development and further optimizations are needed to achieve that. As of Feb 2021, the rate of block finalization on Mainnet is 0.4 blocks/s; with a standard deviation of ±0.1 blocks/s. Hence, a new block is finalized on average every 2.5 seconds. Note that block height only has a loose correlation with time, as the block rate naturally fluctuates.

## Does Flow have a block explorer?

There are two block explorers live today. You can find them here:

- https://flowdiver.io/
- https://flow.bigdipper.live/

## How can I connect to and query the Access Nodes? What data is available there?

At the protocol level, you can connect to an access node via GRPC. We provide JavaScript and Golang SDKs to do this for you.

Once you have connected to an access node, you can fetch information regarding accounts, contracts, blocks, collections, transactions, and events. You can also execute scripts to query the current state of the Flow blockchain.

### Available Data

#### Accounts, Contracts, Blocks, Collections, Transactions, Events

These types are documented on the [Access API](/http-api) page.

The SDKs expose Flow data as types. For example the Go Flow Block data type implementation can be found here:

[https://github.com/onflow/flow-go-sdk/blob/master/block.go](https://github.com/onflow/flow-go-sdk/blob/master/block.go)

You can query historical data and fetch contract code using the SDKs.

### Scripts

Flow allows you to actively query the state of the blockchain using scripts written in the Cadence programming language. You can find out more about Cadence here:

[cadence](../../../../build/guides/smart-contracts/cadence.md)

Running scripts and parsing their output is supported by the SDKs.

Scripts can access multiple contracts and accounts, calculate values, and ensure that data is correct using Cadence's type system. They can only access the _current_ state of the blockchain.

### Using The SDKs

#### JavaScript

You can download the FCL (Flow Client Library) here:

[https://github.com/onflow/fcl-js](https://github.com/onflow/fcl-js)

To connect to an access node you will need to provide a URL to the SDK.
[access node urls](../access-api.mdx)

Here are examples of querying an access node at the bottom of this page:

[https://github.com/onflow/fcl-js/tree/master/packages/sdk](https://github.com/onflow/fcl-js/tree/master/packages/sdk)

Here are examples of creating a script and Cadence data types:

[https://github.com/onflow/fcl-js/tree/master/packages/types#scripts](https://github.com/onflow/fcl-js/tree/master/packages/types#scripts)

And here are examples of parsing script output:

[https://github.com/onflow/fcl-js/tree/master/packages/decode](https://github.com/onflow/fcl-js/tree/master/packages/sdk/src/decode)

#### Go

You can download the Go SDK here:

[https://github.com/onflow/flow-go-sdk](https://github.com/onflow/flow-go-sdk)

To connect to an access node you will need to provide a URL to the SDK.
**testnet: access.devnet.nodes.onflow.org:9000
mainnet: access.mainnet.nodes.onflow.org:9000**

You can find examples of querying an access node at the bottom of this page:

[https://github.com/onflow/flow-go-sdk/blob/master/README.md](https://github.com/onflow/flow-go-sdk/blob/master/README.md)

You can find examples using the emulator that can be adapted to use an access node here:

[https://github.com/onflow/flow-go-sdk/blob/master/examples/get_events/main.go](https://github.com/onflow/flow-go-sdk/blob/master/examples/get_events/main.go)

And here is an example of using a script:

[https://github.com/onflow/flow-go-sdk#executing-a-script](https://github.com/onflow/flow-go-sdk#executing-a-script)

#### Other Programming Languages

For an example of implementing access node communication using another programming language, see "Interact with Flow using Ruby" by Daniel Podaru:
[https://www.onflow.org/post/interact-with-flow-using-ruby](https://www.onflow.org/post/interact-with-flow-using-ruby)

## How do apps consume events? How do events work?

Flow transactions can emit informative "events" containing data intended to be used by off-chain observers. Events can be used to trigger backend or UI events, for example.

Note that a single transaction may emit many events, and that the order of events may surprise you if a non-standard transaction is being used. Event parameters may be optional, which means that they might be nil in some scenarios. All of this means that you must be careful when parsing events.

### Defining Events

Events are implemented within Flow smart contracts using the Cadence programming language.

You can find out more about events in Cadence here:

[cadence/language/events/](https://cadence-lang.org/docs/language/events)

As an example of the kinds of information events can contain, see the documentation of the events that the staking protocol emits:

[staking/events](../../staking/07-staking-scripts-events.md)

### Consuming Events

To consume events, you must query a Flow Access Node and specify the type of event and the range of blocks you wish to fetch those events from. You can then parse any returned events and handle the information that they contain.

### Using Go

Once you connect to an Access Node using the Go SDK you can query for events.

This is documented here:

[https://github.com/onflow/flow-go-sdk#querying-events](https://github.com/onflow/flow-go-sdk#querying-events)

And there is an example of usage here:

[https://github.com/onflow/flow-go-sdk/blob/master/examples/get_events)](https://github.com/onflow/flow-go-sdk/blob/master/examples/get_events)

### Using JavaScript

Once you connect to an Access Node using the FCL (Flow Client Library) you can query for events.

This is documented here:

[https://github.com/onflow/fcl-js/tree/master/packages/sdk#getevents-usage](https://github.com/onflow/fcl-js/tree/master/packages/sdk#getevents-usage)
And there is an example of usage here:

### Using Other Programming Languages

Currently, we only provide Go and FCL-JS (Flow Client Library) for Flow. For an example of accessing the Flow blockchain and consuming events from it using another programming language, see "Interact with Flow using Ruby" by Daniel Podaru:

[https://www.onflow.org/post/interact-with-flow-using-ruby](https://www.onflow.org/post/interact-with-flow-using-ruby)

## I staked and now I can't see my FLOW - what happened?

Once you complete a successful staking or delegation request, your tokens are sent to the staking contract. Your tokens are not lost - they are staked! To view your active stake or delegation, navigate to the Stake & Delegate page on Flow Port (left side bar, or this URL + your address after the last slash ([https://port.onflow.org/stake-delegate/](https://port.onflow.org/stake-delegate/))

## What do I do when I get this error: Node start up issue - could not process block proposal: invalid extension of protocol state?

It sounds like you didn't wipe your `data` folder? Turn off your node, remove the `data` folder and restart the node.

## What errors are acceptable to see when my node is running?

No errors should be considered acceptable. If there are errors that are constantly recurring, please bring it to attention so logging can be adjusted accordingly, if required.

## Is there a testnet/devnet?

There is an access node for you to develop against on the testnet/devnet. You can learn more about it here [testnet-deployment#accessing-flow-testnet](../../../../build/guides/smart-contracts/deploying.md#accessing-flow-testnet)

## Is there a public node?

Yes, an access node is publicly accessible to submit transactions and read data from the blockchain. If you’d like to access the devnet access node to build against, you can do so [here](../../../flow-networks/accessing-testnet.md)

## Is it possible to add multiple public keys to a given account/address so that it can be controlled by more than one private key?

Yes, accounts support multiple, weighted keys, [here](https://cadence-lang.org/docs/language/accounts)
using `AuthAccount`’s `fun addPublicKey(_ publicKey: [UInt8])`and <br/>`fun removePublicKey(_ index: Int)` functions.

## How do keys and accounts work on Flow?

Accounts are created with associated keys. There can be multiple keys on an account. To execute transactions from the account, a total of 1000 weight keys need to sign. The account holds a field for FLOW balance. When transactions move flow, that balance is updated by the protocol. The account also holds place for storage and contract code.

FLOW supports a variety of signature schemes for adding keys to an account.

Details: [concepts/accounts-and-keys](../../../../build/basics/accounts.md)

## How do I create a Flow account if I do not have a service account?

Instructions to generate an address are here: [flow-go-sdk#create-accounts](../../../../tools/clients/flow-go-sdk/index.mdx#create-accounts). You don't need a service account.

## Can you query events between a block range?

You can query the access API to get events for a block range. See Access API spec here: [http-api](/http-api).

## Where can I follow feature releases on Flow?

You can follow Flow node software releases here: [https://github.com/onflow/flow-go/releases](https://github.com/onflow/flow-go/releases).

## How do I run a Flow node and become a node operator?
See the dedicated section on node operation: [nodes/node-operation/](../../node-operation/index.md)
---
title: Flow Port
description: How to use Flow Port
---

Welcome to Flow Port, your portal to the decentralized world of Flow. Access your Flow account, interact with the blockchain, manage your assets and more.
## Creating an Account
In order to access Flow Port, you must have a valid Flow address. If you do not have a Flow address, you can choose to create one via any of the available FCL wallet providers.

### Blocto
#### Before You Start

 1. If you already have an existing Blocto Account, [navigate to this link](https://blocto.app.link/flow-distribution) to finish setting up your account to ensure tokens can be delivered to it.

 2. If you do not have an existing Blocto Account, you have 2 different ways to create one: a) Through Flow Port and b) Through Blocto's mobile application. Below are instructions of how to do this in Flow Port.

#### Creating Account through Flow Port: Navigate to Flow Port

 1. Using Google Chrome, Navigate to [Flow Port](https://port.onflow.org/).

 2. Click on 'Sign Up'

 3. Click on Blocto. Please disable any ad blockers you have before logging in using Blocto

 4. Follow the user interface prompts to create a new Flow Account Address.

 5. After you create your account, you should be logged into Flow Port. You can now see your account address in Flow Port

### Ledger
#### Before You Start

 1. Ensure you have:

     - a.) [Ledger Live](https://www.ledger.com/ledger-live) installed on your computer

     - b.) [Initialized](https://support.ledger.com/hc/en-us/articles/360017362160-Flow-FLOW-?support=true) your Ledger Device.

#### Install the Flow App

 1. Connect your Ledger Device to your computer and open Ledger Live.

 2. Make sure your Ledger device firmware is up to date. You can check this by clicking on **‘Manager’** from the side navigation bar. Choose to install the update if one is available

     - a.) NOTE: Sometimes the install option doesn't show up, or it is not clickable. If this is the case, wait for a little bit of time to see if it appears, or restart the ledger live app if necessary.

 3. On the Manager screen in Ledger Live and search for ‘Flow’.

 4. You should see the Flow App. Install it and follow the instructions on the device.

     - a.) NOTE: If the Flow App does not appear, it may be because you are on an outdated version. Please ensure you are on the most updated version.

#### Navigate to Flow Port to Create an Address

 1. Navigate to [Flow Port](https://port.onflow.org/).

 2. Click on 'Sign Up' if you need to create a new Flow Account.

 3. Click on Ledger.

 4. Follow the prompts on the screen. Plug in your Ledger device and open the Flow App.

 5. Click on Create an account. Follow the prompts on your Ledger device.

 6. Once your account address is created, you will be automatically logged into Flow Port.

## Staking & Delegating

For a detailed walkthrough on how to use Flow Port for staking and delegating, please read the [Flow Port staking walkthrough](./staking-guide.md)
### How Do I Stake or Delegate?

So you have decided you want to be a part of the Flow Network. Welcome! You are joining a group of people from all around the world that are a part of a movement centered around bringing decentralization, user empowerment, and transparency into the world. Below is a step-by-step guide that will assist you in the staking & delegation process.

### Staking via a Custody Provider

If you are using a custody provider who controls your account and private keys for you, such as Kraken, Finoa, or Coinlist, they all have different policies and processes for what you need to do to stake your tokens, the rewards you receive, and the fees that they take from your staking rewards.

### Starting a Manual Staking Transaction
 1. You need to have FLOW in order to stake. Please see the [FLOW Token](../../../../references/core-contracts/03-flow-token.md) reference for information on how to become a FLOW holder.

 2. Once you have FLOW tokens in your account, you can start staking through [Flow Port](https://port.onflow.org/) or, if applicable, with your [custody provider](#staking-via-a-custody-provider).

 3. If you are using Flow Port, log-in with your Flow account address and navigate to the Stake/Delegate page. See the Manual Staking/Delegating section below for more information about what to do next.

### Manual Staking/Delegating
If you are not using a custody provider, there is more responsibility that you have to accept, because you have complete control of your tokens. You need to ensure that you are well informed about the staking process and potentially node operation process because you will have to manage those on your own. Please read the [staking documentation](../../../../references/run-and-secure/staking/index.md) before continuing with this guide.

Below are the various options you can choose. Please be aware, that at this time you can only have 1 stake or 1 delegate per account. This means that if you want to do multiple stakes, multiple delegates, or a mixture of stakes and delegates, you will need to create multiple accounts to do so. Please read them carefully as it will help you understand which route is best for your situation:
- Staking your own Node: You are responsible for running and maintaining a Flow Node. You are also solely responsible for providing the minimum stake for your   selected node (minimum 135,000 FLOW) and you have the technical know-how and bandwidth to run and operate a node in the Flow protocol.
- Delegating: You have FLOW tokens and you want to stake, without having to run your own node and/or have the full minimum stake required to run your own node. You can ‘delegate’ any amount of your FLOW tokens to an existing node operator and you will earn rewards.

Please see a list [here](https://github.com/onflow/flow/blob/master/nodeoperators/NodeOperatorList.md) for all node operators that you can delegate to. This list will be updated as new node operators are onboarded onto the network.'

### Staking your own Node
  1. Once you have navigated to the staking/delegating page in Flow Port, click on the 'Stake a Node' option.

  2. Next, select the type of node you will be running.

  3. Input the amount of Flow you wish to stake with that node. You must stake at least the minimum in order for your stake request to be successfully processed. You are able to provide the minimum stake across multiple transactions. Meaning, you could execute your stake transaction with half of the minumum required. Then, before the next epoch, you can choose to 'Add Flow' to that pending stake to get it to the minimum stake required.

  4. Run the [bootstrapping instructions](../../../../references/run-and-secure/node-operation/node-bootstrap.mdx) and provide the remaining technical details needed to stake a node.

### Delegating
  1. Once you have navigated to the staking/delegating page in Flow Port, click on the Delegate option.

  2. Next, you will specify which node operator you would like to delegate to and how many tokens you want to delegate to them.

  3. Execute the transaction. You will now see your pending delegation that will be processed during the next epoch.

  4. At this point, you can also cancel the pending delegation. On the pending delegation, you will see an `X` that you can click to initiate the cancelation transaction.

## I have successfully executed a Stake Transaction, now what?
  - Now that you have executed a stake transaction in either Flow Port or your custody provider’s portal, that transaction will sit in a pending status until it is processed, which will be at the next [Epoch](../../../../references/run-and-secure/staking/index.md#epochs) Date (which is currently weekly).
  - During the next [Epoch](../../../../references/run-and-secure/staking/index.md#epochs), the transaction will be processed. If successful, the provided FLOW will be staked and the associated Node would be either **a)** included in the network protocol if it is a new node or **b)** continue to operate as is in the network protocol.
  - You are now a part of Flow, and will begin to earn rewards for being a valued member of the network!

## What else can I do?
  - Add additional stake to your existing stake. Any added FLOW will again sit in a pending status and be processed at the next epoch.
  - Withdraw/re-stake your earned rewards. If you decide to withdraw your rewards, this action will happen instantly. If you decide to re-stake your rewards, the request will again sit in a pending status and will be processed at the next [Epoch](../../../../references/run-and-secure/staking/index.md#epochs).
  - Withdraw Rewards and send your earnings to other accounts. If you decide that you want to withdraw your rewards and send those earnings to other accounts via the 'Send FLOW' function, you should first withdraw your rewards. Once in your account, you can send these funds to any other account via the 'Send FLOW' option.
  - Request to be unstaked from the network. The unstake request will sit in a pending status for two epochs. Once it is processed, the amount that has been unstaked will sit in your unstaked FLOW amount and can now be withdrawn or re-staked.
  - Change the node you are staked/delegated to. If your staked/delegated node has no FLOW actively staked and you have completely withdrawn all unstaked amounts and rewards associated with the node, then you can move your stake to a different node. Click on the `Change Node` button to initiate this process. Please note that this feature is only visible once you get your active stake/delegate into the appropriate status.

## FAQs
  1. Why do I have multiple 'Keys' on my account?

     If you created your account with Blocto, you will see that you have multiple keys that exist on your account in the 'Dashboard':

     1 with weight 1 (device key): This is generated on Blocto and sent to users' device when they login  with email.
     1 with weight 999 (Blocto service key): This is kept in Blocto's secure key management service and is used to sign transaction.
     1 with weight 1000 (recovery key): This is kept in Blocto's secure key management service and is only used when user wants to switch to non-custodial mode.

     Normally if a user wants to send a Flow transaction, it requires signature from both the key on users' device and a key from Blocto service. Making it harder for hackers to steal your assets.

  2. Where can I find a list of node operators to delegate to?

     - a.) Please see a list [here](https://github.com/onflow/flow/blob/master/nodeoperators/NodeOperatorList.md) for all node operators that you can delegate to. This list will be updated as new node operators are onboarded onto the network.

  3. I am currently running a node on the network already and have already gone through the staking process once. Do I need to execute a new stake every time there is a new epoch?

       - a.) Once you successfully stake your node and become part of the network, you do not need to submit a new staking request each and every epoch. Your node will be automatically staked from epoch to epoch. This also means that your Node ID will remain the same from epoch to epoch. If you want to unstake your node from the network, then you will follow the process of unstaking your node.

  4. I have a Blocto account and I see that I can stake both in Flow Port and in Blocto's mobile app. What is the difference?

       - a.) If you go through Flow Port, you can choose any node operator within the Flow network to delegate any amount of your Flow Tokens to. If you go through Blocto's mobile site, you will only be able to stake to Blocto run nodes. You can read more about Blocto's staking process by referencing [here](https://guide.blocto.app/article/stake-flow-tokens-step-by-step-with-blocto).

  5. Do I need to use my Ledger device to view information about my account (e.g. my balance and current staked or delegated FLOW)?

       - a.) No you do not! You only need your Ledger device to sign transactions. If you want to view your account, you can do so without your Ledger. You can do this by navigating directly to the appropriate desired page URL, while inputting your address into the URL itself. For quick reference, below is a list of these URLs and where you would input your address:
       - Dashboard: https://port.onflow.org/account/[AccountAddress]
       - Stake & Delegate: https://port.onflow.org/stake-delegate/[AccountAddress]

  6. I am clicking 'submit' to execute a transaction, but nothing is happening. How can I unblock myself?

       - a.) Please disable any pop-up blockers and ad blockers you have and refresh the page. If you are still experiencing issues, please reach out via [Discord](https://discord.gg/4yGnMzkZxr) in the appropriate channel.
---
title: Flow Port Staking Guide
---

This guide provides step-by-step instructions for using the Flow Port to stake your FLOW tokens and start earning rewards.
Currently, Flow Port only supports staking or delegating using tokens held in Blocto or Ledger wallets.
If you're new to the concepts of staking and delegating you can [read this guide](../../../../references/run-and-secure/staking/index.md) to learn more.

## First Step

When you arrive in Port, select **Stake & Delegate** from the left-hand menu. You should be taken to this page.

![Flow Port Staking pt. 0](port-stake-0-00.png)

From here you can decide whether to stake or delegate.

- Select **Stake** if you plan to stake a node you're running.
- Select **Delegate** to delegate your stake to another Node Operator. You don't need to know which Node Operator, you'll be provided with a list to choose from. If you are not running your own node you scan skip directly to the [delegation section](#delegating)

## Stake a Node

Users who will be running their own nodes can stake them using the Flow Port.

#### Pre-requisites

In order to stake your node, you'll need to have the required amount of FLOW for your node type.
You'll also need the following information about your node:

- Node ID
- Network Address
- Networking Key
- Staking Key
- Machine Account Public Key (for collection/consensus nodes only)

If you don't have this information, go [here](../../../../references/run-and-secure/node-operation/node-bootstrap.mdx#step-1---run-genesis-bootstrap) for instructions on how to acquire it.

### Begin Staking

First, select the type of node you'll be running by choosing from the list. You must have the required amount of locked FLOW in your account.

![Flow Port Staking](port-stake-0-02.png)

Once you selected your node type, click next and specify how much you'd like to stake. The minimum amount for your node type is required,
but you may stake as much as you like beyond that. Here's the screen you should see:

![Flow Port Staking](port-stake-0-03.png)

Clicking next will take you to the final screen, where you'll need to enter information about your node you previously obtained.
If you don't have this information, go [here](../../../../references/run-and-secure/node-operation/node-bootstrap.mdx#step-1---run-genesis-bootstrap) for instructions on how to acquire it.
Here's the screen you should see:

![Flow Port Staking](port-stake-0-04.png)

Clicking next will take you to a confirmation screen. This is your chance to double-check that you've entered your information correctly. If you're ready, check the
box confirming your information and click submit to send the transaction that will stake your node! You should see a transaction status screen like this:

![Flow Port Staking](port-stake-0-05.png)

**Note:** If your transaction fails, double-check the information you provided. <br/> <br/>

If you return to the home screen, you'll be able to see your staking request in progress!

![Flow Port Staking](port-stake-4.png)

### Existing Node Operators

If you are already a node operator with a staked node, you will first need to upgrade your account to a Staking Collection. On the Stake & Delegate page you will see a card which will walk you through submitting the transaction to upgrade your account to Staking Collection.

![Flow Port Staking](staking-collection.png)

Once this is done, you can now create a [Machine Account](../../../../references/run-and-secure/node-operation/machine-existing-operator.mdx) by clicking the "Upgrade Node" button on the Stake & Delegate page.

![Flow Port Staking](machine-account.png)

You can follow the guide [here](../../../../references/run-and-secure/node-operation/machine-existing-operator.mdx) to create your Machine Account.

## Delegating

Delegating is the process of staking your locked FLOW to nodes which are being run by another party.

#### Pre-requisites

In order to delegate your stake to another node, you'll need to know the **node operator ID** of the operator who is running the nodes you wish to stake.
Here is a list of node operator IDs you can delegate to: [List of Available Node Operators](https://github.com/onflow/flow/blob/master/nodeoperators/NodeOperatorList.md)

### Enter a Node Operator ID

Simply enter the ID of the node operator of your choice and click next.

![Flow Port Staking](port-delegate-1.png)

### Enter an amount

Next you'll enter an amount of FLOW you would like to delegate. When delegating you may send any amount to the node operator.

![Flow Port Staking](port-delegate-2.png)

Click next to reach the confirmation screen. Confirm the details of your delegation request and click submit!

![Flow Port Staking](port-delegate-3.png)

Once your transaction is submitted, you can monitor its status from this screen, or return to the Flow Port home screen.

![Flow Port Staking](port-delegate-4.png)

**Note:** If you transaction fails, double-check the information you provided. <br/> <br/>

That's it! You've successfully delegated stake to your chosen node operator!

## Returning to Port

Within Flow Port, navigate to the ‘Stake & Delegate’ page to see details about your existing staked and/or delegated tokens.
This will also show you the rewards you have earned for your staked/delegated tokens.

![Flow Port Staking pt. 1](port-stake-1.png)

From here, you can do a few different things with your rewards:

- You can choose to **re-stake** them to the associated node.
- You can choose to **withdraw** them to your wallet.

## Re-staking

Flow Port will not automatically re-stake your rewards.
To re-stake your rewards, simply hover your cursor over the 3 dots next to the rewards field:

![Flow Port Re-Staking](port-stake-2.png)

Click on the Restake option. This will take you to a screen that looks like the below. Input the amount of rewards you want to re-stake, acknowledge the transaction inputs and click submit:

![Flow Port Re-Staking](port-stake-3.png)

Once the transition is processed, you can reference the Stake & Delegate page again to see the pending stake now:

![Flow Port Re-Staking](port-stake-4.png)

## Withdraw your Rewards

To withdraw your rewards, simply hover your cursor over the 3 dots next to the rewards field, and click on ‘Withdraw’.

![Flow Port Re-Staking](port-stake-5.png)

Input the amount that you want to withdraw to your wallet, acknowledge the transaction inputs and click submit:

![Flow Port Re-Staking](port-stake-6.png)

Once the transition is processed, you can now see the withdrawn rewards in your balance and you are now free to do other actions with them (send them to other accounts, delegate to a node, etc).
---
title: Flow Nodes
sidebar_position: 7
---

# Hello Node Operator!

Flow nodes are vital components of the Flow blockchain. These nodes are responsible for a variety of network operations to maintain the distributed ledger.

## Why run a node?

---

By running your own node, you have direct access to the evolving state of the network, without having to rely on third parties.
This increases privacy and security, reduces reliance on external servers, and helps balance load distribution.
By running a node, you also directly contribute to the security and decentralization of the whole network.

Flow multirole architecture makes it more scalable and provides several node types that you as a node operator can pick and choose from.


## Which node should you run?

---

The different types of nodes are described [here](../../../references/run-and-secure/node-operation/node-roles.mdx). As node operator, you can choose to run any of the different types of node that best fits your needs.

The nodes are classified as follows,

![Flownodesdiagram.png](../../../references/run-and-secure/node-operation/Flownodesdiagram.png)

## Light node a.k.a. Observer node

---

The light node is one of the easiest nodes to spin up and can be run by Dapp developers who need the latest block data available locally, e.g. a wallet application that needs to track the latest block ID and height.
In addition to supporting dapps, an observer node can also be run by access node operators who want to scale their access nodes' endpoints. Access node operators can spin up geographically dispersed observer nodes which can talk to their staked access nodes and to each other.

The observer node is not staked but still provides the same API as the access node.

<Callout type="info">
<br />
To run a light node, follow this [guide](../../../references/run-and-secure/node-operation/observer-node.mdx)
<br />
</Callout>

## Archive node

---

The Archive node provides a scalable and efficient way to access the history of Flow protocol and the execution state for the current spork. Like the observer node, it too can be run by anyone without being staked or added to the approved list of nodes.
The Archive node follows the chain, stores and indexes both protocol and execution state, and allows retrieval of blocks, collections, transactions and events from the genesis of the current spork.

It also allows script execution and other read-only queries that require the execution state to be read. It can answer any queries from past data e.g. “what was the Flow account balance at height X?”, where X is several thousand blocks in the past.

_The archive node is currently in beta and will be available as a GA release in H2 2023 (see [here](https://flow.com/post/flow-blockchain-node-operation-archive-node) for more)_

## Full node

---

In a nutshell, Full Nodes are staked network participants that drive network progress, e.g. by creating and executing new blocks. They are the primary contributors to network safety (all of them validate the correctness of the consensus process and secure the network additionally through their role-specific tasks). In comparison, Light Nodes don't contribute to the networks progress. Though, they help to secure the network by also validating the integrity of the consensus process.
- The Access node is a full node that serves as an RPC node and acts as a gateway node for the network.
- The Validator node (Collection, Consensus, Verification and Execution) is a full node that plays a role in block generation.


## Access node

---

If you want local access to the protocol state data (blocks, collections, transactions) and do not want to use one of the community access nodes you can run an access node.
Dapp developers, chain explorers, chain analytics etc. who want exclusive access to chain data and not be subject to the rate-limits on the community access node can choose to run an access node.

An access node is minimally staked for network security.
The central goal for Access Nodes is to provide RPC functionality to its node operator.
In comparison, contributing to protocol progress (e.g. routing transactions to collector clusters, relaying blocks to the unstaked peer-to-peer network, etc.) should only take up a marginal fraction an Access Node's computational resources.
Furthermore, Access Node operators can freely rate-limit the amount of resources their Access Node dedicates to supporting the broader ecosystem. Therefore, Access Nodes do not receive staking rewards.

<Callout type="info">
  <br />
  Launch an access node using QuickNode
  <a
    href="https://www.quicknode.com/chains/flow"
    target="_blank"
  >
    https://www.quicknode.com/chains/flow
  </a>
  <br/>
</Callout>


<Callout type="info">
  <br />
  To run a self-hosted access node, follow this [guide](../../../references/run-and-secure/node-operation/access-node-setup.md)
  <br />
</Callout>

<Callout type="tip">
  <br />
Alternately, instead of running an access node, you can use the [Flow community](./access-api.mdx) access nodes or the ones run by any of the other node operators.
  <br />
</Callout>

## Validator node

---

You can also be a core participant in running the Flow network and contribute to securing it. Depending on your preference, you could run one or any combination of the following node roles:
- Collection Nodes collaboratively create batches of transactions (in Flow terminology collections).
- Consensus Nodes create blocks, schedule them for asynchronous execution, and commit execution results once they are verified (so called sealing). In addition, they orchestrate the Flow protocol and enforce protocol compliance.
- Execution Nodes asynchronously execute blocks. They are the power-houses in the protocol, providing the vast computational resources available to Flow transactions.
- Verification Nodes check the execution results in a distributed manner.

Nodes with these roles are staked and also receive staking rewards.

### Running a staked node

---

To run a staked node (node type access, collection, consensus, verification or execution) the node must:
* be registered with sufficient stake
* be authorized by the governance working group

Before proceeding, ensure you have the stake required for your new node and that your node will be authorized by the governance working group (apply [here](https://github.com/onflow/flow-validator)).

To set up a new staked node after it has been authorized by the Flow governance working group, you will need to complete the following steps:

1. [Provision](../../../references/run-and-secure/node-operation/node-setup.mdx) the machine on which your node will run.

2. [Generate and register](../../../references/run-and-secure/node-operation/node-bootstrap.mdx) your node identity.

3. [Start](../../../references/run-and-secure/node-operation/node-bootstrap.mdx#step-3---start-your-flow-node) your node!
---
title: Slashing Conditions
---

## Introduction

Flow is a proof-of-stake system, which means holders of FLOW can earn inflationary rewards
by staking their FLOW tokens to secure and operate the network.
A node can participate in the Flow network by depositing a specific amount of stake
(based on role types) thereby making a bonded pledge to participate
in the Flow protocol during the upcoming epoch.
(An epoch is a finite amount of time defined by the protocol, approximately one week,
during which the nodes participate to run the protocol and are responsible for their operations.)

See the [Staking and Epochs section of the documentation](LINK REQUIRED) to learn more
about the design and functionality of this part of the protocol.

Flow nodes follow the procedures defined in the protocol (based on their role)
in order to receive rewards. Any deviation (see Slashing Challenges below)
from the protocol can result in decreased reward payments or punishments.
Severe infractions, which undermine the safety of the network,
can lead to “slashing”, where some or all of the staked tokens are confiscated from the offending node(s).

This reward and punishment structure is designed to guarantee the security
of the protocol and optimize performance over time.
This document outlines the most severe infractions against the protocol
which result in some portion of a node’s stake being taken from them (“slashing conditions”).
Enforcing these slashing conditions is critical to ensure the cryptoeconomic security of the protocol.
Future documents will describe an incentive structure that encourages system-wide efficiency and speed,
by providing bonuses to the most performant nodes and withholding payments to nodes that are unresponsive.

This document assumes a working understanding of the high-level architecture of the Flow blockchain.
Readers who are new to Flow or those looking for a refresher are encouraged
to read the Protocol Summary [here](../../../references/run-and-secure/node-operation/node-roles.mdx) and the staking documentation.

## Slashing Conditions

Any violation of the Flow protocol that could result in staked tokens being seized
from the offending nodes is called **Slashable Behaviour.**
In order for the tokens to be seized, the data necessary to prove the occurrence of Slashable Behaviour
must be combined with the data necessary to attribute the behaviour
to the node(s) responsible into a **Slashing Witness**.
(A reduction of rewards, e.g. due to lack of active participation,
is not formally included in our definition of slashing.)
The Flow protocol considers only server threats to safety and liveness
to be slashable conditions and as such, there are no performance related slashing penalties.
The one exception is in the case of missing Collections (see the section on MCC below),
where a widespread failure to respond by a large number of nodes is presumed
to be coordinated and therefore punishable with slashing.

Most Slashable Behaviour in Flow can be detected and attributed to the offender
by a single honest node observing that behaviour.
(In other words, one node can generate a Slashing Witness without coordinating with other nodes.)
However, some Slashable Behaviour can only be detected and attributed
by combining information from multiple nodes. In those situations,
the node that first detects the potential infraction raises a **Slashing Challenge**.
When a challenge is raised, other nodes are expected to provide additional information
which can be combined with the original challenge into a definitive Slashing Witness
that is used to adjudicate the challenge. Each type of Slashing Challenge depends
on different information provided from a different subset of nodes,
the details of which are provided below.

Flow adheres to a number of principles in the design of its slashing rules:

- Only Consensus Nodes can perform slashing, and only by following the BFT consensus mechanism
defined in the protocol. As such, a super-majority of Consensus Nodes must inspect
and confirm a Slashing Witness before any punishment is levied.

- All Slashing Witnesses are objectively decidable.
Given the current protocol state (maintained by the Consensus Nodes)
and a well-formed Slashing Witness, all non-Byzantine Consensus Nodes will deterministically come
to the same conclusion as to which node or nodes should be slashed (if any)
and the amount of stake to be seized.

- All Slashing Behaviour in Flow requires active malfeasance on the part of the offending node.
In other words, a node will only be slashed if it takes an action against the rules of the protocol,
and it will not be slashed if it fails to take an action prescribed by the protocol.
(“If your machine is crashed, you won’t get slashed.”) The one exception
is in the case of missing Collections (see the section on MCC below),
where a widespread failure to respond by a large number of nodes is presumed
to be coordinated and therefore punishable with slashing.

- Flow makes no attempt to detect and punish liveness failures within the protocol.
A liveness failure across the network functionally slashes the stake of any participants
excluded from participating in the reboot (since their stake is locked in a non-functional network).
Community analysis can determine which nodes were responsible for the failure
and exclude those Byzantine actors from the new instance.

- Any staked node of Flow can submit a Slashing Witness for any Slashable Behaviour,
regardless of its role. (For example, a Collection Node could submit a Slashing Witness
for an invalid execution receipt, even though the protocol doesn’t require Collection Nodes
to verify execution receipts.)

- Submitting an invalid Slashing Witness is Slashable Behaviour.
We treat the invalid Slashing Witness itself as the Slashing Witness for that case.

## Stages of Slashing

Transitioning to a rigorous staking protocol in which all slashable conditions are checked,
enforced, and punished will take place over three phases.
The Slashing Challenges section below outlines the various challenges
which may be submitted against an offending node but these challenges
will not be fully enforced until Phase 3 of the network.

### Phase 1: Beta

- In the beta phase of the network, the expectation is that nodes are running error detection
and logging but not submitting formal challenges. Any errors found may be submitted
to the Flow team for additional testing and security improvements.

### Phase 2: Testing Slashing Mechanics

- At this time the slashing mechanisms will be implemented and require testing.
Formal challenges should be raised and the protocol will follow the complete,
formal mechanics for arbitrating challenges and slashing perpetrators,
but no real slashing will take place.

### Phase 3: BFT

- By now, the network has been security-hardened and tested and valid challenges
result in real slashing of the offending node.

## Slashing Challenges

### 0. All Nodes

**Invalid Report Witness (IRW): **if any nodes report an invalid/inaccurate witness,
an invalid report witness will be reported by the Consensus Nodes,
and the node(s) reporting the witness get slashed.

### 1. Collection Nodes

**1.1 Missing Collection Challenge (MCC): ** Collection nodes are responsible
for storing collection content (all transactions) for any collection which they guarantee
during the current epoch and the first 1000 blocks of the next epoch.
During this time they have to respond to any collection request from staked execution,
verification and Consensus Nodes and should respond in a timely manner (specific timeout).
If an Execution Node or a Verification Node doesn't receive the response from any
of the collection guarantors (Collection Nodes who signed a collection),
they can raise a Missing Collection Challenge and broadcast it to the Consensus Nodes to evaluate.

**Adjudication: **Consensus nodes randomly contact some of the guarantors.
If Collection Nodes don't respond, a portion of their stakes will be seized.
If the amount of their stake goes to less than half, they will be fully slashed.
Then the Consensus Nodes notify all the Execution Nodes to skip that collection. 
If any of the Collection Nodes respond, Consensus Nodes redirect the collection content
to the Execution Nodes but will also set small penalties both
for all the guarantors and that Execution Node (according to their revenue ratio).

**1.2 Invalid Collection Witness (ICW):** Collection nodes are responsible for responding
to collection content queries by collection hash from any staked nodes.
The collection hash is the hash of an ordered list of transaction hashes.
If a collection content sent by the Collection Node turns out to be invalid,
any staked node can report an Invalid Collection Witness. This includes cases where:

- the content is malformed or incomplete,
- there exists an invalid transaction inside the collection, or
- the collection hash doesn't match (inside collection guarantee).

**Adjudication:** Consensus nodes evaluate the content of the collection,
if the collection is found invalid, the Collection Node who signed the content is slashed.

**1.3 Double Collection Proposal Witness (DCPW):** Collection nodes of a cluster run a mini consensus
inside the cluster to decide on a collection, which requires Collection nodes to propose
the collection and aggregate votes from others. During the collection consensus,
if a Collection Node proposes more than one proposal, any other Collection Node
inside the cluster can report a Double Collection Proposal Witness (including both proposals).

**Adjudication: **Consensus nodes evaluate the content and signatures of these two proposals,
and if the witness turns out to be valid, the Collection Node who proposed two collections will get slashed.

**1.4 Double Collection Voting Witness (DCVW):** Collection nodes of a cluster
run a mini consensus inside the cluster to decide on a collection,
which requires Collection nodes to propose the collection and aggregate votes from others.
During the collection consensus, if a Collection Node votes for more than one collection proposal
with identical collection number and size, any other Collection Node inside the cluster
can report a Double Collection Voting Witness (including both votes).

**Adjudication: **Consensus nodes evaluate the signatures of these two votes and evaluate them,
and if the witness turns out to be valid, the Collection Node who voted two times will get slashed.

### 2. Consensus Nodes

**2.1 Double Block Proposal Witness (DBPW):** Consensus nodes run the consensus (HotStuff algorithm) over blocks.
During these consensus steps, if a Consensus Node proposes more than one variation of a block proposal,
any other Consensus Node can report a Double Block Proposal Witness (including both proposals).
This report will be broadcasted to all other Consensus Nodes.

**Adjudication: **Consensus nodes evaluate content and signatures of both proposals.
If the witness turns out to be valid, the Consensus Node who submitted both proposals will get slashed.

**2.2 Double Block Voting Witness (DBVW): ** Consensus nodes run the consensus (HotStuff algorithm)
over blocks. During the consensus steps, if a Consensus Node votes for
more than one block proposal with the same height, any other Consensus Node can report
a Double Block Voting Witness (including both votes).
This report will be broadcasted to all other Consensus Nodes.

**Adjudication: **Consensus nodes evaluate content and signatures of both votes
and If the witness turns out to be valid, the Consensus Node who submitted both votes will get slashed.

**2.3 Invalid Block Vote Witness (IBVW):** If a Consensus Node votes for an invalid block
or the content of the vote itself is invalid (e.g. vote for non-existing block),
any other Consensus Nodes can report an Invalid Block Vote Witness.

**Adjudication: **Consensus nodes evaluate the vote content and signature.
If the witness turns out to be valid, the Consensus Node who submitted the faulty vote will get slashed.

**2.4 Invalid Block Proposal Witness (IBPW):** If a Consensus Node proposes
an invalid block proposal (e.g. quorum certificate without 2/3 vote),
any other Consensus Nodes can raise an Invalid Block Proposal Witness.

**Adjudication: **Consensus nodes evaluate the proposal content and signature,
If the witness turns out to be valid, the Consensus Node who submitted the invalid proposal
will get slashed.

**2.5 Invalid Block Witness (IBW):** If the block contents returned by any Consensus Node is invalid,
any node can raise the Invalid Block Witness:

- It is malformed or incomplete
- It doesn't match the payload hash provided by the block header

**Adjudication: **Consensus nodes evaluate the block content and signatures.
If the witness turns out to be valid, the Consensus Node who signed the block content will get slashed.

**2.6 Invalid Random Beacon Signature Witness (IRBSW):**
If any participant of the random beacon returns an invalid signature,
an Invalid Random Beacon Signature Witness can be reported by other Consensus Nodes.

**Adjudication:** Consensus nodes evaluate the random beacon signature.
If the witness turns out to be valid, the Consensus Node who signed the invalid random beacon part
will get slashed.

### 3. Execution Nodes

**3.1 Faulty Computation Challenge (FCC): ** If any of the Verification Nodes
find a fault in the execution of transactions by an Execution Node it can raise an FCC challenge.
An FCC challenge includes a faulty chunk and all the evidence.

**Adjudication: **Consensus nodes evaluate the challenge, by sending requests
for collection contents and chunk data needed to run the faulty chunk and comparing
the results against the expected state commitment. If Consensus Nodes detect any fault
in the execution of that chunk, the Execution Node(s) who signed the faulty execution receipts
will get slashed. If no fault is found, the Verification Node who raised the challenge will get slashed.

**3.2 Conflicting Execution Results Challenge (CERC): **
If two or more variations of execution results are reported by Execution Nodes for a given block.
Since only one can be valid, Consensus Nodes raise a conflicting execution results challenge.

**Adjudication: **As soon as this challenge is raised, all the Verification Nodes
go into full check mode (checks all the chunks). The first execution result
that receives result approval from at least 2/3 of Verification Nodes is the accurate one,
and the other execution results will be considered faulty and Execution Nodes generating those
will get slashed. If none of the execution results receive majority approval
from Verification Nodes after a very long timeout,
all the Consensus Nodes start executing chunks to determine the correct output.

**3.3 Invalid Chunk Data Package Witness (ICDPW):** If the contents of a chunk data package
doesn't match the hash provided inside the execution result, or the contents is invalid,
the Verification Nodes can report an Invalid Chunk Data Package Witness.

**Adjudication: **Consensus nodes evaluate the content of the chunk data package.
If the witness turns out to be valid, the Execution Node(s)
who signed the faulty chunk data package will get slashed.

**3.4 Missing Chunk Data Package Challenge (MCDPC):**
If an Execution Node doesn't respond to the chunk data package request by any staked Verification Node,
a Missing Chunk Data Package Challenge can be raised by the Verification Node.

**Adjudication: **When this challenge is received by the Consensus Nodes,
they contact Execution Nodes and ask for the chunk data package.
If none of the Execution Nodes respond after a long timeout, all of them get slashed.
If any of the Execution Nodes responds with a valid chunk data package,
Consensus Nodes redirect the chunk data package to the Verification Nodes
but will also set small penalties both for all the Execution Nodes and the challenge raiser
(Verification Node) according to their revenue ratio.

**3.5 Execution Results Timeout Challenge (ERTC):**
If no execution receipt received in X number of blocks after the submission of each block,
the liveness of the system is compromised and Consensus Nodes can raise
an Execution Results Timeout Challenge for all the Execution Nodes.

**Adjudication: **When this challenge is received by the Consensus Nodes,
they contact Execution Nodes and ask for an update. If none of the Execution Nodes respond
after a long timeout, all of them get slashed.
If any of the Execution Nodes return the execution receipt, the case is dismissed.

**3.6 Invalid Execution Receipt Witness (IERW):**
If an Execution Node provides an execution receipt that is not valid,
the Consensus Nodes can report an Invalid Execution Receipt Witness.

**Adjudication: **Consensus nodes evaluate the content of the execution receipt.
If the witness turns out to be valid, the Execution Node(s)
who signed the invalid execution receipt will get slashed.

**3.7 Non-Matching SPoCKs Challenge (NMSC): **
If the SPoCKs provided by the Execution Node don't match the ones provided by the Verification Node,
the Consensus Nodes can raise a Non-Matching SPoCKs challenge.

**Adjudication: **Consensus nodes have to re-execute the chunk
to be able to compute the accurate SPoCKs secret to be able to adjudicate the challenge.
This requires requesting the collection and all other data needed for execution from other nodes.
Any node which provided invalid SPoCKs will be slashed.

### 4. Verification Nodes

**4.1 Non-Matching SPoCKs Challenge (NMSC):**
If the SPoCKs provided by the Execution Node don't match the ones provided by the Verification Node,
the Consensus Nodes can raise a Non-Matching SPoCKs challenge.

**Adjudication: **Consensus nodes have to re-execute the chunk to determine the accurate SPoCKs secret
which is needed to adjudicate the challenge. This requires requesting the collection
and all other data needed for execution from the other nodes.
Any node which provided invalid SPoCKs will be slashed.

**4.2 Invalid Result Approval Witness (IRAW):**
If a Verification Node provides an invalid result approval,
the Consensus Nodes can report this witness.
This includes cases that a Verification Node sends a result approval
for a chunk that was not assigned to the Verification Node (excluding full check mode)
or if the SPoCK’s signature doesn't match the public key of the Verification Node.

**Adjudication: **Consensus nodes evaluate the content and signatures of the result approval.
If the witness turns out to be valid, the Verification Node who signed that result approval be slashed.
---
title: Epoch and Staking Terminology
sidebar_label: Epoch and Staking Terminology
description: Important Definitions for Epochs
---

<Callout type="warning">
  If you haven't read the staking introduction, please read that
  first. That document provides a non-technical overview of staking on Flow for
  all users and is a necessary prerequisite to this document.
</Callout>
<Callout type="warning">
  This document assumes you have some technical knowledge about the Flow
  blockchain and programming environment.
</Callout>

## Terminology

If any of the definitions are confusing, you can find more detail in the other sections of the technical docs.

**Staker:** Any user who has staked tokens for the Flow network.
A node operator is a staker, and a delegator is a staker as well.

**Node Operator:** A user who operates a node on the Flow network. Each node operator has a unique node resource
object they store in their account to perform staking operations.

**Node Operator Metadata:** This information is tracked for each node operator in the Flow network.
  - **Node ID:** 32 byte identifier for the node. Usually a hash of the node public key.
  - **Role:** Indicates what role the node operator is. (Collection, Consensus, Execution, Verification, Access)
  - **Networking Address:** The address that the node operator uses for networking. Using a hostname is highly encouraged.
  - **Networking Key:** The 64 byte ECDSA-P256 node operator public key for networking.
  - **Staking Key:** The 96 byte BLS12-381 public key for the node. 
    Used to sign node messages and votes for Quorum Certificate generation.
  - **Proof of Possession:** A 48 byte (96 hex characters) string that acts as cryptographic
    proof of ownership of the node's staking key.

**Delegator:** A user who delegates tokens to a node operator and receives rewards for their staked tokens, minus a fee
taken by the node operator. Each delegator stores a unique delegator resource object in their account
that allows them to perform staking operations.

- **Delegator Metadata:** This information is tracked for all delegators in the network.
  - **id:** The ID associated with a delegator. These IDs are assigned to delegators automatically
    by the staking contract and are only unique within an individual node operators' record.
  - **nodeID:** The ID of the node operator a user delegates to.

**Node Identity Table:** The record of all the nodes in the network, and their delegators.
The identity table keeps separate lists for the info about node operators and delegators.

<Callout type="warning">
  NOTE: The staking smart contract does not associate a node or delegator with
  an account address. It associates it with the assigned resource object that
  corresponds to that entry in the contract. There can be any number of these
  objects stored in the same account, and they can be moved to different
  accounts if the owner chooses.
</Callout>

**Epoch:** The period of time between changes in the identity table and reward payments. 
(Initially a week, measured in consensus views)
At the end of every epoch, insufficiently staked node operators are refunded their stake,
rewards are paid to those who are currently staked, committed tokens are marked as staked,
unstaking tokens are marked as unstaked, and unstaking requests are changed from staked to unstaking.

**Consensus View:** A internal detail that the Flow consensus algorithm, HotStuff, uses to measure time.
Views count the number of rounds in the consensus algorithm.
Each round/view the counter is incremented and a new block may be proposed.

**Seat:** The right to participate in the network as a node of a certain type for a specific Epoch.

**Staking Auction Phase:** The period of time when nodes and delegators are able to submit staking operations
in preparation for the upcoming epoch. This phase is expected to take over 90% of the time of an epoch.

**Epoch Setup Phase:** The period of time after the staking auction, where nodes have to perform certain processes
to initialize the state and communication with other nodes for the next epoch.
These processes are called **Cluster Quorum Certificate Generation (QC)**, and **Distributed Key Generation (DKG)**.
If any node does not perform this initialization properly, it is not included in the next epoch's Identity Table.
This phase is expected to take less than 10% of the time of an epoch, near the end.

**Cluster Quorum Certificate Generation (QC):** A process by which nodes using the HotStuff consensus algorithm
submit signed messages in order to generate a certificate for bootstrapping HotStuff. Each collector cluster runs
a mini-version of HotStuff, and since clusters are randomized each epoch, a new quorum ceritificate is required
for each cluster each epoch.

**Distributed Key Generation (DKG):** Process for generating a shared public key to initialize the random beacon.
Consensus nodes use a shared whiteboard to communicate and submit final key vectors to generate a shared key.

**Epoch Commit Phase:** The final phase of an epoch, after the Epoch Setup Phase. In this phase, the identity table
has been finalized for the next epoch, all setup has been completed, and the network
is simply waiting for the next epoch to start.

**Service Event:** Special messages that are generated by the epoch smart contracts and included in execution results.
They enable communication between system smart contracts and the Flow protocol.
In other words, they serve as a communication mechanism between the execution state and the protocol state.
Service events are not any different that other Cadence events, except in the fact that
Flow nodes treat them differently because they are being emitted by the service account.

**Node and Delegator Staked Token Tracking Terms:**
  - **Tokens Committed:** The tokens that a user has committed to stake in the next epoch, but that aren't currently staked.
  - **Tokens Staked:** The tokens that a user has staked in the current epoch.
  - **Tokens Requested to Unstake:** The amount of tokens that a user has requested to be unstaked
    at the end of the current epoch (to be removed from the **tokens staked** pool).
  - **Tokens Unstaking:** The tokens that were unstaked at the beginning of the current epoch and
    are being held for an additional epoch holding period before being released.
  - **Tokens Unstaked:** Tokens that used to be committed or staked and have been unstaked.
  - **Tokens Rewarded:** Tokens that the user has received via staking rewards.

**Delegation Rewards Cut:** The percentage of a delegator's rewards that the node operators take. Initially set to 8%.

**Epoch Payout:** The total amount of tokens paid in rewards at the end of an epoch.
This value will change as the supply of FLOW changes. See the [rewards page](./schedule) for more details.

**Minimum Stake Requirement:** Each node type has a requirement for the minimum number of FLOW
they have to commit to stake to be considered a valid node and receive rewards. If a node operator
does not meet the minimum stake, they will not be included in the next epoch and will not receive any rewards.
Delegators are not subject to minimum stake requirements.

- Collection Nodes: 250,000 FLOW
- Consensus Nodes: 500,000 FLOW
- Execution Nodes: 1,250,000 FLOW
- Verification Nodes: 135,000 FLOW

There is no maximum stake limit.

---
title: Epoch and Reward Schedule
sidebar_label: Epoch and Reward Schedule
description: How the Flow protocol manages the schedule of an epoch and rewards payments
---

<Callout type="warning">

This information covers the current state of how epoch phases are ran and how
rewards are calculated and distributed to node operators and delegators. 
All of the information in the document is still being designed and is subject to change
based on research and discussion by the Flow core team and community.
If any changes are proposed, the Flow community will be notified in advance.
</Callout>

# Schedule

![Flow Epoch Schedule](epoch-phase-diagram.png)

An Epoch is a period of time when the node operators in the network are constant. At epoch 
boundaries, newly staked node operators are able to join the network and existing node operators
which have unstaked may exit the network.

Each epoch lasts approximately a week, and the **Epoch Switchover** is defined as the point in time
when one epoch ends and the next epoch begins, marking a possible change in the list of valid nodes.

<Callout type="info">

The exact timing of each epoch end is influenced by the number of blocks proposed during the epoch.
Therefore, epoch phase timing can very and will likely drift over time.

**All quoted epoch end times are estimates and subject to some variance (up to several hours)**.
See [Epoch Preparation Protocol](./04-epoch-preparation.mdx#epoch-length) for details. 

</Callout>

**Staking Operations are disabled for approximately the last day of an epoch**,
typically around 12:00pm (7:00pm UTC) on Tuesday every week until the next day around the same time.
See [Epoch Setup](./04-epoch-preparation.mdx#phase-1-epoch-setup) for more information on this phase.

**Epoch Switchovers will happen around 12:00 pm PT on Wednesday (7:00 pm UTC)** every week. 
Please note exact epoch ending time vary based on the performance of the network
& all staking operations that interact with staked tokens will be processed
by the protocol at the start of each epoch. 

## Rewards

**Rewards are usually paid around 12 pm PT on Wednesday (7:00 pm UTC)**, every week,
to all users that have tokens staked.
This is close to the same time as the Epoch Switchover. See the Rewards Distribution section below
for more information about rewards calculation and schedule.

## Staking Auction

The first, and longest phase of an epoch is the [staking auction](./04-epoch-preparation.mdx#phase-0-staking-auction).
This phase is when nodes and delegators can register to stake and perform other staking operations
such as staking more tokens or unstaking their existing tokens.
None of these operations are fully executed until the **Epoch Switchover** though.

**The Staking Auction lasts for at least the first 90% of the length of an Epoch**

## Epoch Setup and Epoch Commit

The [Epoch Setup](./04-epoch-preparation.mdx#phase-1-epoch-setup)
and [Epoch Commit](./04-epoch-preparation.mdx#phase-2-epoch-committed)
phases are the final phases of the epoch, when node operators who have been included
in the next epoch perform important setup functionailty to prepare for the next epoch.

**The Epoch Setup and Epoch Committed phases usually last less than 10% of the time of an epoch.**

**Staking Operations will be rejected during the Epoch Setup and Epoch Commit phases.**
This is because the staking information has been finalized in preparation for the next epoch
and cannot be changed because these final phases rely on the staking information being constant.

**The Staking Auction Ends every Tuesday near 12:00pm PT (7:00 pm UTC).**
**This means that staking operations will be disabled for ALL users**
**in the period between the end of the staking auction and the beginning of the next epoch, currently 24hrs.**

## Rewards Distribution

The rewards distribution schedule has been designed to ensure 
there is enough liquid supply of FLOW available in the ecosystem 
to empower a wide variety of use cases and promote fair and diverse participation in the Flow ecosystem.

The numbers in this table represent the total amount of tokens that are paid 
as staking rewards at each epoch to the entire pool of participants in the Flow network. 
While the total staking reward amount is known and fixed per epoch,
rewards that individual stakers receive are variable depending on many factors. 

The total rewards for each epoch are fixed for that epoch, but where those rewards come from can change.
When the protocol pays rewards, it first pulls from the central pool of all the transaction fees
that have been paid by every user in the network since the last rewards payment.
Once that pool has been depleted, the protocol mints new tokens that are used as rewards.

Please see the next section on how to calculate an individual staking reward.

|                               | Dec 22, 2020        | Dec 29, Jan 5, 12, 19, 26 (2021) | Feb 2, 2021 weekly on Wednesdays indefinitely |
| ----------------------------- | ------------------- | -------------------------------- | --------------------------------------------- |
| Total Rewards % (Annual)      | 5%                  | 20%                              | 5%                                            |
| Total Rewards Amount Per Week | ~1.2M FLOW          | ~4.4M FLOW                       | ~1.3M FLOW                                    |

## Individual Calculation

Each user gets a percentage of the total rewards during each epoch 
that is proportional to their percentage of all the tokens that are staked by all participants.

The full reward calculation on a per-user basis is equal to:	

```	
New Reward(user) = Tr  * (Sn / St)	
```	

where:	
- `Tr` = Total staking rewards to be paid out during the current epoch. (See table above)
- `Sn` = Amount of FLOW Staked by the target user for the current Epoch. (Different for each staker)
- `St` = Sum of all the FLOW staked by all the participants in the network. (Changes every epoch)

Rewards for delegators are also calculated in the exact same way that rewards for node operators are calculated, 
with one difference in that 8% of the calculated reward amount is given to the node operator being delegated to 
(effected as a protocol layer fee, which is the same for all node operators). 
The remaining 92% is awarded to the delegator. 
Note: the 8% fee is only applied to the staking reward, not to the tokens delegated.

With this calculation, the node you choose to run or delegate to 
DOES NOT affect the amount of rewards you receive every week. 
The only variable that you can control is the number of tokens you have staked. 
The more tokens you stake, the more rewards you will receive.

Because of the variable nature of the rewards calculation, we cannot provide an expected weekly/yearly return 
for a single staker. You can plug your own numbers into the formula to see some sample calculations, 
but you won't be able to know exactly what you will earn until the beginning 
of the epoch in which you are participating in staking or delegation.

## Rewards History

For the first two years of its existence, the staking rewards payments
were handled with manual transactions. You can find the history of those transactions
including their arguments and IDs in the
[Pay Rewards Section](https://github.com/onflow/service-account/tree/main/transactions/pay-rewards
of the Flow Service Account Repo. The dates correspond to the date when the
rewards were paid at the end of an epoch and the network transitioned to a new epoch.

Future rewards payments and epoch switchovers happen automatically via a system chunk transaction,
which does not create regular transaction IDs.---
title: Epoch Preparation Protocol
sidebar_label: Epoch Preparation Protocol
description: Technical Overview of the Flow Epoch Protocol
---

<Callout type="warning">
  If you haven't read the staking introduction, please read that
  first. That document provides a non-technical overview of staking on Flow for
  all users and is a necessary prerequisite to this document.
</Callout>
<Callout type="warning">
  This document assumes you have some technical knowledge about the Flow
  blockchain and programming environment.
</Callout>

# Epochs

The epoch preparation protocol defines how information about the next epoch
is determined and propagated to the protocol state.

There are two primary actors in this protocol, the Epoch Smart Contracts, and the Consensus Committee:

- [`Epoch Smart Contracts`](https://github.com/onflow/flow-core-contracts/blob/master/contracts/epochs) - the smart contracts that manage epochs:
    - `FlowClusterQC` : Manages the quorum certificate generation for bootstrapping
      the hotstuff consensus algorithm for each collector cluster.
    - `FlowDKG` : Manages the Distributed Key Generation that consensus nodes participate
      in to initialize the random beacon for each epoch.
    - `FlowIDTableStaking` : Manages the source of truth for the identity table,
      and enforces rules related to staking FLOW, delegating, paying rewards, and allocating token movements between epochs.
    - `FlowEpoch` : Ties all of the previously mentioned contracts together to manage
      the high level epoch lifecycle. `FlowEpoch` acts as a state machine that transitions
      between different epoch phases when specific conditions from the other contracts are met and triggers important operations in the other smart contracts when phase changes happen.
- `Consensus Committee` - the committee of consensus nodes for the current epoch

This document describes the communication protocol between these two actors and the impact on the protocol state.

It gives an overview of the process of epochs, the staking auction, and the epoch setup and commit phases.
It is an important prerequisite to understand before proceeding with any other technical integration or interaction with the Flow Protocol,
but does not provide step-by-step instructions for how to perform specific actions.

The transactions described in this document are contained in the [`flow-core-contracts/transactions/epoch/`](https://github.com/onflow/flow-core-contracts/tree/master/transactions/epoch)
directory. You can see the text of all the transactions used to interact with the smart contracts there.

## Epochs Overview

Only a pre-determined set of nodes is authorized to participate in the protocol at any given time.
The set of authorized nodes is a-priori known to all network participants. 
This set is referred to as the **Identity Table**. An **Epoch** is defined as a period of time 
where the set of authorized nodes is constant (or can only shrink due to ejection of malicious nodes).

At an Epoch switchover, which is the time when the network transitions from one epoch to the next,
the set of authorized nodes can change. For each of Flow's node roles, the Flow protocol admits a protocol-determined number of nodes. 

For each Epoch, there is a [Staking Auction](./06-technical-overview.mdx) in which new potential node operators may submit Staking Commitments.
All this is completely smart-contract based and handled through conventional transactions.

After the Staking Auction is over, the protocol determines which commitments to accept and which to reject.
The node operators whose staking commitments were accepted are added to the Identity Table for the next epoch,
and become authorized participants at the next epoch switchover.
Staked Nodes also can submit other operations to modify their existing stake, which are all carried out at the end of the current epoch.

The smart contract that determines the nodes for the next Epoch has special privileges.
Specifically, it is allowed to emit [Service Events](./05-epoch-scripts-events.md#monitor-epoch-service-events),
which are how the execution state updates the consensus node-based protocol state.

At the end of the staking auction, the epoch smart contracts conclude that they have now determined
the set of nodes which will be running the network for the next Epoch, and the amount of FLOW that all the nodes have staked.
The smart contract then emits a service event with this information.

When processing the block with seat assignment, all network nodes (including future ones which are supposed to monitor the chain in anticipation)
are thereby informed about the upcoming change.

<Callout type="warning">
Note: At this point in the epoch (end of the staking auction), 
there is no change in participating nodes.
The change in participating nodes happens at the end of the epoch.
</Callout>

After the staking auction, there is an interim period of time until the new Epoch starts for the following tasks to be completed:
- The epoch smart contract runs the cluster assignment algorithm for all the collector nodes
and each collector node will vote for the root block of their respective clusters
- The Random Beacon Committee for the next Epoch (currently all consensus nodes)
will run the Distributed Key Generation (DKG),
- When completing the QC generation and DKG, the smart contracts will emit a service event. 
After consensus nodes have collected all relevant information (public keys for the random beacon and cluster quorum certificates), 
they can update the identity table to include the information for the next Epoch.

If preparation for the next Epoch is not completed before the current Epoch ends,
a spork is required to transition to the next Epoch.

## Epoch Length

The length of an Epoch is measured in terms of consensus views.
The number of views in an epoch and in the various epoch phases are determined before 
the Epoch begins and stored as a field in the main epoch smart contract (`FlowEpoch`).

Generally, there is not a block for every view, so the view number will not change at the same rate as the block height.

Because the length of a consensus view can vary depending on many different factors,
the wall-clock time of an epoch is expected to vary from week to week. 
Under typical network conditions we expect the variance in epoch length to be less than 2 hours for a 1-week epoch (~1%).
Under adverse network conditions the variance in epoch length will increase (typically this will result in longer epochs).

As the average view rate changes over time, the Service Account can change the epoch length to
target a 1 week wall-clock epoch length.

# Phases

The preparation for the next epoch is separated into distinct phases.
Each phase occurs completely within the current epoch.

![Flow Epoch Schedule](https://storage.googleapis.com/flow-resources/documentation-assets/epoch-phase-diagram.png)

The Epoch Smart Contract acts as a state machine. The smart contract keeps a record of the current phase,
the number of views in the current phase, and the conditions that need to be met in order to advance to the next phase, or next epoch.
A special `Heartbeat` resource is used to call the `advanceBlock()` method during every single new block in Flow.
During these regular method calls, if all of the conditions are met to advance to the next phase,
the smart contract performs any relevant retreival and storage of information, emits a Service Event,
and transitions to the next phase, which often involves setting certain metadata
or enabling one of the connected smart contracts to begin its work.

From the perspective of the consensus committe, the phase transitions within epochs
occur as a result of including a service event in a block,
thus the phase transition only applies to the fork containing the block with the service event.

At the end of Phase 0 and beginning of Phase 1, the `EpochSetup` service event is emitted
that contains the identity table and other initial metadata for the upcoming epoch.

At the end of Phase 1 and beginning of Phase 2, the `EpochCommit` service event
is emitted that contains the results of the Epoch Setup phase.

The start of a new epoch is the first block with its view > the last view of the previous epoch,
and its parent view ≤ the last view of the last epoch.

## Phase Transitions

The **Consensus Committee** triggers the **phase transition coinciding with the Epoch switchover**
by publishing the block of the next Epoch.
This block's execution state will also detect the the end view of an epoch has arrived
and trigger the start of the new epoch. 
The state of the smart contracts reflect the latest epoch's new identity table and metadata.

For the **Epoch-*internal* Phase transitions**, meaning the phase transitions within an epoch,
the **Epoch Smart Contract** provides the trigger by emitting a respective service event:

- The `EpochSetup` service event triggers the phase transition
`Staking Auction Phase` → `Epoch Setup Phase`
- The `EpochCommit` service event triggers the phase transition
`Epoch Setup Phase` → `Epoch Committed Phase`

Only one of each service event may be emitted each epoch, for a given fork.
`EpochCommit` may only be emitted after `EpochSetup` has been generated in the respective given fork. 

The `FlowEpoch` contract manages all of these phases, the `FlowIDTableStaking` contract
manages the identity table and staking auction, the `FlowClusterQC` contract manages
the Quorum Certificate generation for collector clusters, and the `FlowDKG` contract manages
the Distributed Key Generation protocol for the consensus nodes.

Initially, control of these phases and contracts will be managed manually by the Flow Token Admin,
but control will eventually be completely decentralized and managed by the node software, smart contracts,
and democratically by all the stakers in the network.

## Phase 0: Staking Auction

**Purpose:** During the staking auction phase, operators can put up stake
in exchange for being a part of the upcoming epoch.
All voluntary commitments to register a new node, increase, or decrease stake for the next epoch
must occur before the end of this phase. 

**Duration:** The staking auction phase begins with the first block of the current Epoch
Its last block is the block in which the `EpochSetup` service event is emitted.

### **Protocol Directives:**

Epoch Smart Contract

- The `FlowEpoch` Smart Contract is responsible for ensuring that staking, un-staking,
and stake-modification transactions for the next epoch are 
are only executed during the staking auction and fail otherwise.
The contract enforces this by setting a `stakingEnabled` field in the staking contract.
Every staking method checks to see if this is set before executing.

- The `FlowEpoch` Smart Contract must ensure that the subsequent phases
are sufficiently long to perform all required tasks before the epoch ends.
- As part of the execution result for the last block of the staking auction,
the `Epoch Smart Contract` computes the seat assignment information for the next epoch,
and emits a specialized service event, the `EpochSetup` event,
with the timing and identity table information about the next epoch.
See the [Epoch Setup Event Documentation](./05-epoch-scripts-events.md#epochsetup)
for a detailed breakdown of the epoch setup event.

## Phase 1: Epoch Setup

**Purpose:** During the epoch setup phase, all nodes participating in the upcoming epoch
must perform setup tasks in preparation for the upcoming epoch. 

**Duration:** The epoch setup phase begins right after the `EpochSetup` service event is emitted.
It ends with the block where `EpochCommit` service emitted.

### **Protocol Directives:**

Consensus:

- When a primary constructs a block that seals the `EpochSetup` service event,
the primary includes an update to the protocol state in the block.
Specifically, it adds the nodes for the `PendingEpoch` to the list of authorized nodes.
When this block is propagated, all staked nodes will know about the participants
in the next epoch and can communicate with them.

- Based on the `RandSeed` field in the `EpochSetup` event, all nodes compute: 
    - The seed to initialize the consensus node's primary selection algorithm for the next epoch
    - The seeds to initialize the collector clusters' primary selection algorithm for the next epoch

- The collector nodes generate the root block for their respective clusters
in the next Epoch and submit a vote for the root block to a specialized smart contract, `FlowClusterQC`.
- The Random Beacon Committee for the next Epoch (currently all consensus nodes)
will run the DKG through a specialized smart contract, `FlowDKG`.

Epoch Smart Contract:

- The `FlowEpoch` Smart Contract is responsible for ensuring that Epoch Setup transactions
are only executed during the Epoch Setup phase and fail otherwise.
The contract enforces this by setting an `enabled` field in the `FlowClusterQC` and `FlowDKG` contracts.
Every state-changing method from these contracts checks to see if this is set before executing.

- The Epoch `Epoch Smart Contract` must ensure that the subsequent phase
is sufficiently long to perform all required tasks before the epoch ends.

- As part of the execution of the last block of the Epoch Setup phase,
the `Epoch Smart Contract` computes the public key shares generated by the DKG
and the `QC`s for the collector clusters and publishes these as `EpochCommit` service event.
The `FlowEpoch` Smart Contract should emit this event as soon as the artifacts are determined.

See the [Epoch Commit Event Documentation](./05-epoch-scripts-events.md#epochcommit)
for a detailed breakdown of the epoch commit event.

## Phase 2: Epoch Committed

**Purpose:** When the epoch committed phase starts, the precise role of each node is fully specified.
From a protocol-perspective, all information is available for each node
to start its operation for the next Epoch.
This phase provides some time for nodes to establish the communication channels
and synchronize with the network to seamlessly switch over to the next epoch. 

**Duration:** The epoch committed phase begins right *after* the `EpochCommit` service event
has been emitted. It ends when the epoch ends.

### **Protocol Directives:**

Consensus

- When a primary constructs a block that seals the `EpochCommit` service event,
the primary includes an update to the protocol state in the block. Specifically, it: 
 - adds the information generated in the setup phase to the Protocol State and 
 - marks the updated Protocol State as `committed` in this respective fork.

# Query Information from the Epoch Contract

See the [epoch scripts and events document](./05-epoch-scripts-events.md#introduction) for detailed documentation about
you can use scripts events to learn information about the state of the epoch contracts.
---
title: Stake Slashing
sidebar_position: 4
description: How Flow enforces honest node behaviour
---

Flow slashes nodes only for acts that directly impact
the security and integrity of the network and its shared execution state.
Nodes are not slashed for liveness infractions.
The protocol reserves slashing for maintaining the security of the protocol rather than its liveness.

You can find more details on the conditions under which a node is slashed
in the [Flow whitepapers](https://www.onflow.org/technical-paper).

Direct stake slashing is not currently enforced by the protocol and staking contract.
It will be handled on a case-by-case basis for the foreseeable future
to ensure network participants have time to participate in the testing and rollout of slashing.

There is a very basic form of slashing that is currently used, where
nodes who have liveness issues during an epoch may have their rewards 
and their delegators' rewards reduced by a pre-determinded amount based on
the severity of the liveness infractions. This amount is often 50%
and is only taken from the stakers' rewards for a given epoch.
Their staked FLOW is not touched at all.

When slashing is enforced, slashable protocol violations must be adjudicated by a supermajority
of more than 2/3 of the staked consensus nodes in order to take effect.
If a node is found guilty of committing a slashable protocol violation,
the consensus nodes directly deduct a fine from the node's stake.

It is still TBD where the slashed tokens will be deposited.

The remaining un-slashed stake is deposited back into node's unstaked pool
at the end of the unstaking period.
---
title: Query Epoch Info with Scripts or Events
sidebar_title: Epoch Scripts and Events
---

# Introduction

The epoch contract stores a lot of different state, and the state is constantly changing.
As an external party, there are two ways to keep track of these state changes. 
You can either use Cadence scripts to query the state of the contract at any given time,
or you can monitor events that are emitted by the epoch contract to be notified of any important occurances.

# Monitor Epoch Service Events

These events can be queried using the Go or JavaScript SDKs to extract useful notifications and information about the
state of the epoch preparation protocol.

## What is a Service Event?

Service events are special messages that are generated by smart contracts and included in execution results.
They enable communication between system smart contracts and the Flow protocol.
In other words, they serve as a communication mechanism between the execution state and the protocol state. 

Concretely, service events are defined and emitted as events like any other in Cadence. An event is considered a service event when it is:

- emitted within the service chunk
- emitted from a smart contract deployed to the service account
- conformant to an event allowlist

Each block contains a system chunk. For each system chunk,
all service events emitted are included in the corresponding execution result. 

When verifying the system chunk, verifier nodes will only produce result approvals
when the system chunks included in the execution result are correct.
Thus, the security of this communication mechanism is enforced by the verification system.

When sealing a block containing a service event, the consensus committee will update the protocol state accordingly,
depending on the semantics of the event. 

For example, a service event may indicate that a node's stake has diminished to the point where they should be ejected,
in which case the consensus committee would mark that node as ejected in the protocol state.

Service events are fundamentally asynchronous, due the lag between block execution and sealing.
Consequently they are handled slightly differently than other protocol state updates.

The diagram below illustrates the steps each service event goes through to be included in the protocol state.

![Flow Service Event Diagram](epoch-service-event-diagram.png)

For conciseness, we say a service event is `sealed` when the block in which it was emitted is sealed,
and we say a service event is `finalized` when the block containing the seal is finalized.

## Event Descriptions

### `EpochSetup`

The Epoch Setup service event is emitted by `FlowEpoch.startEpochSetup()` 
when the staking auction phase ends and the Epoch Smart Contracts transition to the Epoch Setup phase. 
It contains the finalized identity table for the upcoming epoch,
as well as timing information for phase changes.

```cadence
pub event EpochSetup (

    /// The counter for the upcoming epoch. Must be one greater than the
    /// counter for the current epoch.
    counter: UInt64,

    /// Identity table for the upcoming epoch with all node information.
    /// Includes:
    /// nodeID, staking key, networking key, networking address, role,
    /// staking information, weight, and more.
    nodeInfo: [FlowIDTableStaking.NodeInfo],

    /// The first view (inclusive) of the upcoming epoch.
    firstView: UInt64,

    /// The last view (inclusive) of the upcoming epoch.
    finalView: UInt64,

    /// The cluster assignment for the upcoming epoch. Each element in the list
    /// represents one cluster and contains all the node IDs assigned to that
    /// cluster, with their weights and votes
    collectorClusters: [FlowClusterQC.Cluster],

    /// The source of randomness to seed the leader selection algorithm with 
    /// for the upcoming epoch.
    randomSource: String,

    /// The deadlines of each phase in the DKG protocol to be completed in the upcoming
    /// EpochSetup phase. Deadlines are specified in terms of a consensus view number. 
    /// When a DKG participant observes a finalized and sealed block with view greater 
    /// than the given deadline, it can safely transition to the next phase. 
    DKGPhase1FinalView: UInt64,
    DKGPhase2FinalView: UInt64,
    DKGPhase3FinalView: UInt64
)
```

### `EpochCommit`

The `EpochCommit` service event is emitted when the Epoch Smart Contracts transition 
from the Epoch Setup phase to the Epoch Commit phase. 
It is emitted only when all preparation for the upcoming epoch (QC and DKG) has been completed.

```cadence
pub event EpochCommit (

    /// The counter for the upcoming epoch. Must be equal to the counter in the
    /// previous EpochSetup event.
    counter: UInt64,

    /// The result of the QC aggregation process. Each element contains 
    /// all the nodes and votes received for a particular cluster
    /// QC stands for quorum certificate that each cluster generates.
    clusterQCs: [FlowClusterQC.ClusterQC],

    /// The resulting public keys from the DKG process, encoded as by the flow-go
    /// crypto library, then hex-encoded.
    /// Group public key is the first element, followed by the individual keys
    dkgPubKeys: [String],
)
```


# Query Information with Scripts

The `FlowEpoch` smart contract stores important metadata about the current, proposed,
and previous epochs. Metadata for all historical epochs is stored permenantely 
in the Epoch Smart Contract's storage.

```cadence
pub struct EpochMetadata {

    /// The identifier for the epoch
    pub let counter: UInt64

    /// The seed used for generating the epoch setup
    pub let seed: String

    /// The first view of this epoch
    pub let startView: UInt64

    /// The last view of this epoch
    pub let endView: UInt64

    /// The last view of the staking auction
    pub let stakingEndView: UInt64

    /// The total rewards that are paid out for the epoch
    pub var totalRewards: UFix64

    /// The reward amounts that are paid to each individual node and its delegators
    pub var rewardAmounts: [FlowIDTableStaking.RewardsBreakdown]

    /// Tracks if rewards have been paid for this epoch
    pub var rewardsPaid: Bool

    /// The organization of collector node IDs into clusters
    /// determined by a round robin sorting algorithm
    pub let collectorClusters: [FlowClusterQC.Cluster]

    /// The Quorum Certificates from the ClusterQC contract
    pub var clusterQCs: [FlowClusterQC.ClusterQC]

    /// The public keys associated with the Distributed Key Generation
    /// process that consensus nodes participate in
    /// Group key is the last element at index: length - 1
    pub var dkgKeys: [String]
}
```

### Get Epoch Metadata

The `FlowEpoch` smart contract provides a public function, `FlowEpoch.getEpochMetadata()`
to query the metadata for a particular epoch.

You can use the **Get Epoch Metadata**([EP.01](../../core-contracts/07-epoch-contract-reference.md#getting-epoch-info)) script
with the following arguments:

| Argument         | Type     | Description                                   |
| ---------------- | ---------| --------------------------------------------- |
| **epochCounter** | `UInt64` | The counter of the epoch to get metadata for. |

### Get Configurable Metadata

The `FlowEpoch` smart contract also has a set of metadata that is configurable by the admin
for phase lengths, number of collector clusters, and inflation percentage.

```cadence
pub struct Config {
    /// The number of views in an entire epoch
    pub(set) var numViewsInEpoch: UInt64

    /// The number of views in the staking auction
    pub(set) var numViewsInStakingAuction: UInt64
    
    /// The number of views in each dkg phase
    pub(set) var numViewsInDKGPhase: UInt64

    /// The number of collector clusters in each epoch
    pub(set) var numCollectorClusters: UInt16

    /// Tracks the annualized percentage of FLOW total supply that is minted as rewards at the end of an epoch
    /// Calculation for a single epoch would be (totalSupply * FLOWsupplyIncreasePercentage) / 52
    pub(set) var FLOWsupplyIncreasePercentage: UFix64
}
```

You can use the **Get Configurable Metadata**([EP.02](../../core-contracts/07-epoch-contract-reference.md#getting-epoch-info)) script
to get the list of configurable metadata:

This script does not require any arguments.

### Get Epoch Counter

The `FlowEpoch` smart contract always tracks the counter of the current epoch.

You can use the **Get Epoch Counter**([EP.03](../../core-contracts/07-epoch-contract-reference.md#getting-epoch-info)) script
to get the current epoch counter.

This script does not require any arguments.

### Get Epoch Phase

The `FlowEpoch` smart contract always tracks the active phase of the current epoch.

```cadence
pub enum EpochPhase: UInt8 {
    pub case STAKINGAUCTION
    pub case EPOCHSETUP
    pub case EPOCHCOMMIT
}
```

You can use the **Get Epoch Phase**([EP.04](../../core-contracts/07-epoch-contract-reference.md#getting-epoch-info)) script
to get the current epoch phase.

This script does not require any arguments.---
title: Staking Technical Overview
sidebar_label: Staking Technical Overview
description: Technical Overview of the Flow Staking Auction Phase
---

<Callout type="warning">
  If you haven't read the Introduction, please read that first. That document
  provides a non-technical overview of staking on Flow for all users and is a
  necessary prerequisite to this document.
</Callout>
<Callout type="warning">
  This document assumes you have some technical knowledge about the Flow
  blockchain and programming environment.
</Callout>

# Staking

This document describes the functionality of the
[core identity table and staking smart contract](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowIDTableStaking.cdc).
It gives an overview of the process of epochs, staking as a node, and delegation. It is an important prerequisite
to understand before proceeding with any other technical integration or interaction with the Flow Protocol,
but does not provide step-by-step instructions for how to perform specific actions. See the
[Staking Collection Docs for instructions](./staking-collection/)

This document also describes how to read public staking data from the contract.
Anyone can read public data from the staking smart contract with these instructions.

The transactions described in this document are contained in the
[`flow-core-contracts/transactions/idTableStaking/`](https://github.com/onflow/flow-core-contracts/tree/master/transactions/idTableStaking)
directory. You can see the text of all the transactions used to interact with the smart contract there.

## Smart Contract Summary

The Flow staking smart contract manages a record of stakers who have staked tokens for the network.
Users who want to stake can register with the staking contract at any time during the staking auction,
and their tokens will be locked for staking until they request to unstake them.

You should already understand from reading the [epoch documentation](./epoch-preparation)
that an epoch lasts roughly a week. The `FlowIDTableStaking` contract focuses on the identity table
and staking part of the epoch schedule.

Epoch Schedule from the perspective of the `FlowIDTableStaking` contract:

1. **Start of Epoch:** Generic metadata about the current epoch is updated and shared
   and the staking auction is enabled.
2. **Staking Auction:** Stakers can perform any action they want to manage their stake, like
   initially registering, staking new tokens, unstaking tokens, or withdrawing rewards.
   This phase takes up the vast majority of time in the epoch.
3. **End Staking Auction:** Stakers cannot perform any more staking actions
   until the start of the next epoch/staking auction.
4. **Remove Insufficiently Staked Nodes:** All node operators who don't meet the minimum
   or are not operating their node properly will be removed.
5. **Randomly Assign Nodes to New Slots:** Each node type has a configurable
   number of nodes that can operate during any given epoch.
   The contract will randomly select nodes from the list of newly staked and approved nodes
   to add them to the ID table. Once all the slots have been filled, the remaining nodes are refunded
   and can apply again for the next epoch.
6. **Rewards Calculation:** Calculate rewards for all the node operators staked in the current epoch.
7. **Move tokens between pools.** (See the token pools section for the order of movements)
8. **Rewards Payout:** Pay rewards to all the node operators staked
   from the previous epoch using the calculation from earlier in the epoch.
9. **End Epoch:** Set the reward payout for the upcoming epoch and go to the top of this list.

The `FlowIDTableStaking` contract manages the identity table, and all of these phases.
Initially, control of these phases is controlled by the `FlowIDTableStaking.Admin` resource
object stored in the Flow Epoch account storage.
Control will eventually be completely decentralized and managed by the node software, smart contracts,
and democratically by all the stakers in the network.

## Staking as a Node Operator

For a node to stake, node operators first need to generate their staking key,
staking key proof-of-possesion, networking address, and networking key.

The [node operation guide](../node-operation/index.md)
describes how to run a node and generate node information.

To generate a node ID, simply hash the staking key.

Node operators need to determine the role of node they will be running
(Collection, Consensus, Execution, Verification, or Access).

<Callout type="warning">
  NOTE: Access Nodes are eligible to stake but will not receive rewards for
  their stake. Please register as a different node type if you would like to
  receive rewards.
</Callout>

Once the info has been determined:

- Node role: `UInt8` (1 = Collection, 2 = Consensus, 3 = Execution, 4 = Verification, 5 = Access)
- Node ID: 32 byte `String` (64 hex characters)
- Networking Address: `String` (Length must be less than 510 characters and be a properly formatted IP address or hostname)
- Networking Key: 64 byte `String` (128 hex characters, must be a valid ECDSA-P256 Key)
- Staking Key: 96 byte `String` (192 hex characters, must be a valid BLS key)
- Staking Key Proof of Possesion: (48 byte (96 hex characters) string)

The node operator is ready to register their node.

<Callout type="warning">
  NOTE: The staking smart contract validates that the strings for the keys are
  valid public keys. The staking admin and node software also checks the keys
  and networking address to make sure they are valid and if they are not, the
  registered node will not be eligible to stake.
</Callout>

To register a node, the node operator calls the
[`addNodeRecord` function](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowIDTableStaking.cdc#L870)
on the staking contract, providing all the node info and the tokens that they want to immediately stake, if any.

This registers the node in the Flow node identity table
and commits the specified tokens to stake during the next epoch.
This also returns a special node operator object that is stored in the node operator's account.
This object is used for staking, unstaking, and withdrawing rewards.

Consensus and Collection nodes also need to create a separate machine account
for use in the DKG and QC proccesses, respectively. This machine account creation
is handled automatically by the staking collection smart contract.
More information is in the [machine account documentation](./11-machine-account.mdx#creation).

Every node operator will run the same transaction to register their node at any time throughout the staking auction.

<Callout type="warning">
  The register node transaction only needs to be submitted once per node. A node
  does not need to register every epoch. A registration cannot be used to manage
  multiple nodes. Multiple nodes need to be registered separately (with the
  Staking Collection).
</Callout>

<Callout type="warning">
  Once a node operator has registered their node and its metadata, the metadata
  cannot be modified. The only exception is the networking address, which can me
  modified with the Update Networking Address transaction. If a node operator
  wants to update any of their other metadata such as ID, keys, or role, they
  need to unstake, withdraw their tokens, and register a completely new node.
</Callout>

Once node operators have registered and have the special node object, they will be able
to perform any of the valid staking options with it, assuming that they have
the required amount of tokens to perform each operation.

When the staking auction ends, if a node operator has committed less than the minimum stake required,
[or if their node information is invalid and they haven't been approved by the network,](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowIDTableStaking.cdc#L788)
their committed tokens are moved to their unstaked pool, which they can withdraw from at any time.

Nodes who did have enough tokens committed and are approved will have their
[committed tokens moved to the staked state](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowIDTableStaking.cdc#L923-L927)
at the end of the epoch if they are selected as a node operator
by the random node slot filling algorithm.
There is a configurable cap on the number of nodes of each type.

If a node operator has users delegating to them, they cannot withdraw their own tokens
such that their own staked tokens would fall below the minimum requirement for that node type.
If they have delegators and try to submit [an unstaking transaction](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowIDTableStaking.cdc#L510-L514)
that would put their stake below the minimum, it will fail.

If they want to unstake below the minimum, they must unstake all of their tokens using the special
[`unstakeAll` method,](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowIDTableStaking.cdc#L538)
which also unstakes all of the tokens that have been delegated to them.

Consequently, a node operator cannot accept delegation unless [their own stake is above the minimum.](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowIDTableStaking.cdc#L1066)

## Staking as a Delegator

Every staked node in the Flow network is eligible for delegation by any other user.
The user only needs to know the node ID of the node they want to delegate to.

To register as a delegator, the delegator submits a **Register Delegator**
transaction that calls the [`registerNewDelegator function`](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowIDTableStaking.cdc#L1053),
providing the ID of the node operator they want to delegate to.
This transaction should store the `NodeDelegator` object
in the user's account, which is what they use to perform staking operations.

Users are able to get a list of possible node IDs to delegate to via on-chain scripts.
This information will also be provided off-chain, directly from the node operators or via
third-party services. [Available node IDs are listed in a public repo.](https://github.com/onflow/flow/blob/master/nodeoperators/NodeOperatorList.md)

The fee that node operators take from the rewards their delegators receive is 8%.
A node operator cannot be delegated to unless the total tokens they have committed to stake
are above the minimum requirement for their node types.

The delegation logic keeps track of the amount of tokens each delegator has delegated for the node operator.
When rewards are paid, the protocol [automatically takes the 8% cut](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowIDTableStaking.cdc#L888-L898)
of the delegator's rewards for the node operator
and the delegator's rewards are deposited in the delegator's reward pool.

## Staking Operations Available to All Stakers

Regardless of whether they are a node operator or delegator, a staker has access
to all the same staking operations, outlined below.
Specific implementations of these transactions are detailed in the [Staking Collection Docs](./staking-collection/)

### Stake More Tokens

A staker can commit more tokens to stake for the next epoch at any time during the staking auction,
and there are three different ways to do it.

1. They can commit new tokens to stake by submitting a **stake_new_tokens** transaction,
   which withdraws tokens from their account's flow token vault and commits them.
2. They can commit tokens that are in their unstaked token pool, which holds the tokens
   that they have unstaked. Submit a **stake_unstaked_tokens**
   transaction to move the tokens from the unstaked pool to the committed pool.
3. They can commit tokens that are in their rewarded token pool, which holds the tokens
   they have been awarded. They submit a **stake_rewarded_tokens**
   transaction to move the tokens from the rewards pool to the committed pool.

### Cancel Committed Stake / Unstake Tokens

At any time during the staking auction, a staker can submit a request to unstake tokens with a **request_unstaking** transaction.
If there are tokens that have been committed but are not staked yet,
they are moved to the unstaked pool and are available to withdraw.

If the requested tokens are in the staked pool,
it marks the specified amount of tokens to be unstaked at the end of the epoch.
At the end of the epoch, the tokens are moved to the unstaking pool.
They will sit in this pool for one (1) additional epoch,
at which point they will be moved to the unstaked tokens pool.

### Cancel an Unstake Request

Unstaking requests are not fulfilled until the end of the epoch where they are submitted,
so a staker can cancel the unstaking request before it is carried out.
A staker can do this by submitting a **stake_unstaked_tokens** transaction, specifying
the number of tokens of their unstake request they would like to cancel.
If the specified number of tokens have been requested to unstake, the request will be canceled.

### Withdraw Unstaked Tokens

At any time, stakers are able to freely withdraw from their unstaked tokens pool
with the **withdraw_unstaked** transaction.

### Withdraw Rewarded Tokens

Staking rewards are paid out at the end of every epoch based on how many tokens
are in a users `tokensStaked` pool. Every staker's rewards
are deposited into their rewarded tokens pool. Rewards can be withdrawn
at any time by submitting a **withdraw_reward_tokens** transaction.

These tokens are unlocked and can be transferred on-chain if desired, or re-staked.

The source code for the staking contract and more transactions
can be found in the [Flow Core Contracts GitHub Repository](https://github.com/onflow/flow-core-contracts).

# Monitor Events from the Identity Table and Staking Contract

See the staking events document for information about the events that can be emitted by the staking contract.

# Appendix

## Token Pools

Each node operator has five token pools allocated to them:

- **Committed Tokens:** Tokens that are committed for the next epoch.
  They are automatically moved to the staked pool when the next epoch starts.
- **Staked Tokens:** Tokens that are staked by the node operator for the current epoch.
  They are only moved at the end of an epoch and if the staker
  has submitted an unstaking request.
- **Unstaking Tokens:** Tokens that have been unstaked,
  but are not free to withdraw until the following epoch.
- **Unstaked Tokens:** Tokens that are freely available to withdraw or re-stake.
  Unstaked tokens go to this pool.
- **Rewarded Tokens:** Tokens that are freely available to withdraw or re-stake.
  Rewards are paid and deposited to the rewarded Pool after each epoch.

At the end of every epoch, tokens are moved between pools in this order:

1. All committed tokens will get moved either to the staked tokens pool,
   or to the unstaked tokens pool (depending on if the registered node has met the minimum stake requirements).
2. All committed tokens get moved to staked tokens pool.
3. All unstaking tokens get moved to the unstaked tokens pool.
4. All requested unstaking tokens get moved from the staked pool to the unstaking pool.
---
title: Query Staking Info with Scripts or Events
sidebar_title: Staking Scripts and Events
---

# Introduction

The staking contract stores a lot of different state, and the state is constantly changing.
As an external party, there are two ways to keep track of these state changes. 
You can either use Cadence scripts to query the state of the contract at any given time,
or you can monitor events that are emitted by the staking contract to be notified of any important occurances.

# Query Information with Scripts

## Get the list of proposed nodes for the next epoch:

`FlowIDTableStaking.getProposedNodeIDs()`: Returns an array of node IDs for proposed nodes.
Proposed nodes are nodes that have enough staked and committed for the next epoch to be above the minimum requirement.

You can use the **Get Proposed Table**([SC.05](../../core-contracts/06-staking-contract-reference.md#getting-staking-info)) script for retrieving this info.

This script requires no arguments.

## Get the list of all nodes that are currently staked:

`FlowIDTableStaking.getStakedNodeIDs()`: Returns an array of nodeIDs that are currently staked.
Staked nodes are nodes that currently have staked tokens above the minimum.

You can use the **Get Current Table**([SC.04](../../core-contracts/06-staking-contract-reference.md#getting-staking-info)) script for retrieving this info.

This script requires no arguments.

## Get all of the info associated with a single node staker:

`FlowIDTableStaking.NodeInfo(nodeID: String)`: Returns a `NodeInfo` struct with all of the metadata
associated with the specified node ID. You can see the `NodeInfo` definition in the [FlowIDTableStaking
smart contract.](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowIDTableStaking.cdc#L264)

You can use the **Get Node Info**([SC.08](../../core-contracts/06-staking-contract-reference.md#getting-staking-info)) script
with the following arguments:

| Argument   | Type     | Description                            |
| ---------- | -------- | -------------------------------------- |
| **nodeID** | `String` | The node ID of the node to search for. |

You can also query the info from an address by using the **Get Node Info From Address**([SC.26](../../core-contracts/06-staking-contract-reference.md#getting-staking-info)) script
with the following arguments:

| Argument    | Type      | Description                                       |
| ----------- | --------- | ------------------------------------------------- |
| **address** | `Address` | The address of the account that manages the node. |

## Get the total committed balance of a node (with delegators):

`FlowIDTableStaking.NodeInfo(_ nodeID: String).totalCommittedWithDelegators()`: Returns the total committed balance for a node,
which is their total tokens staked + committed, plus all of the staked + committed tokens of all their delegators.

You can use the **Get Node Total Commitment**([SC.09](../../core-contracts/06-staking-contract-reference.md#getting-staking-info)) script
with the following argument:

| Argument   | Type     | Description                            |
| ---------- | -------- | -------------------------------------- |
| **nodeID** | `String` | The node ID of the node to search for. |

## Get the total committed balance of a node (without delegators):

`FlowIDTableStaking.NodeInfo(_ nodeID: String).totalCommittedWithoutDelegators()`: Returns the total committed balance for a node,
which is their total tokens staked + committed, plus all of the staked + committed tokens of all their delegators.

You can use the **Get Only Node Total Commitment**([SC.09](../../core-contracts/06-staking-contract-reference.md#getting-staking-info)) script
with the following argument:

| Argument   | Type     | Description                            |
| ---------- | -------- | -------------------------------------- |
| **nodeID** | `String` | The node ID of the node to search for. |

## Get all the info associated with a single delegator:

`FlowIDTableStaking.DelegatorInfo(nodeID: String, delegatorID: UInt32)`: Returns a `DelegatorInfo` struct with all of the metadata
associated with the specified node ID and delegator ID. You can see the `DelegatorInfo` definition in the [FlowIDTableStaking
smart contract.](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowIDTableStaking.cdc#L348)

You can use the **Get Delegator Info**([SC.10](../../core-contracts/06-staking-contract-reference.md#getting-staking-info))
script with the following arguments:

| Argument        | Type     | Description                                  |
| --------------- | -------- | -------------------------------------------- |
| **nodeID**      | `String` | The node ID that the delegator delegates to. |
| **delegatorID** | `String` | The ID of the delegator to search for.       |

You can also query the info from an address by using the **Get Delegator Info From Address**([SC.27](../../core-contracts/06-staking-contract-reference.md#getting-staking-info)) script
with the following arguments:

| Argument    | Type      | Description                                            |
| ----------- | --------- | ------------------------------------------------------ |
| **address** | `Address` | The address of the account that manages the delegator. |

## Get the delegation cut percentage:

`FlowIDTableStaking.getRewardCutPercentage(): UFix64`: Returns a `UFix64` number for the cut of delegator rewards that each node operator takes.

You can use the **Get Cut Percentage**([SC.01](../../core-contracts/06-staking-contract-reference.md#getting-staking-info)) script to retrieve this info.

This script requires no arguments.

## Get the minimum stake requirements:

`FlowIDTableStaking.getMinimumStakeRequirements(): {UInt8: UFix64}`: Returns a mapping
for the stake requirements for each node type.

You can use the **Get stake requirements**([SC.02](../../core-contracts/06-staking-contract-reference.md#getting-staking-info)) script to retrieve this info.

This script requires no arguments.

## Get the total weekly reward payout:

`FlowIDTableStaking.getEpochTokenPayout(): UFix64`: Returns a `UFix64` value for the total number of FLOW paid out each epoch (week).

You can use the **Get weekly payout**([SC.03](../../core-contracts/06-staking-contract-reference.md#getting-staking-info)) script to retrieve this info.

This script requires no arguments.

## Get the total FLOW staked:

You can use the **Get total FLOW staked**([SC.06](../../core-contracts/06-staking-contract-reference.md#getting-staking-info)) script to retrieve this info.

This script requires no arguments.

## Get the total FLOW staked by all the nodes of a single node role:

You can use the **Get total FLOW staked by node type**([SC.07](../../core-contracts/06-staking-contract-reference.md#getting-staking-info)) script
with the following arguments:

| Argument     | Type    | Description                     |
| ------------ | ------- | ------------------------------- |
| **nodeType** | `UInt8` | The type of node to search for. |


# Staking Events

Staking events can be queried using the Go or JavaScript SDKs to extract useful notifications and information about the
state of the staking process.

## Global Staking and Epoch Events

### NewEpoch

```cadence
pub event NewEpoch(totalStaked: UFix64, totalRewardPayout: UFix64)
```

| Field             | Type   | Description                                                            |
| ----------------- | ------ | ---------------------------------------------------------------------- |
| totalStaked       | UFix64 | The total number of tokens staked for the new Epoch                    |
| totalRewardPayout | UFix64 | The total number of tokens that will be paid as rewards for this epoch |

Emitted by `FlowIDTableStaking.Admin.moveTokens()` when the tokens are moved between pools, which signals a new epoch.

### NewWeeklyPayout

```cadence
pub event NewWeeklyPayout(newPayout: UFix64)
```

| Field     | Type   | Description                                                        |
| --------- | ------ | ------------------------------------------------------------------ |
| newPayout | UFix64 | The new number of tokens that will be paid at the end of the epoch |

Emitted by `FlowIDTableStaking.Admin.setEpochTokenPayout()` when the Admin changes the total tokens paid at the end of the epoch.

After this event the `epochTokenPayout` is equal to the new value.

### NewStakingMinimums


`pub event NewStakingMinimums(newMinimums: {UInt8: UFix64})`


| Field           | Type            | Description                                                  |
| --------------- | --------------- | ------------------------------------------------------------ |
| newRequirements | `{UInt8: UFix64}` | The new minimum staking requirements for all the node types. |

Emitted by `FlowIDTableStaking.Admin.setMinimumStakeRequirements()` when the Admin changes the minimum requirements for node types.

### NewDelegatorCutPercentage


`pub event NewDelegatorCutPercentage(newCutPercentage: UFix64)`


| Field            | Type   | Description                                                         |
| ---------------- | ------ | ------------------------------------------------------------------- |
| newCutPercentage | UFix64 | The percentage of the delegator reward that goes to node operators. |

Emitted by `FlowIDTableStaking.Admin.setCutPercentage()` when the Admin changes the percentage of delegator rewards that every node operator takes.

Note that the percentage will be more than 0.0 and less than 1.0, with the actual percentage equal to this multiplied by 100.

Also note that the percentage is taken from the _delegator_ reward to go to the _node operator_.

After this event the nodeDelegatingRewardCut is equal to the new value.

## Node Events

These are events that concern the operation of a node.

### NewNodeCreated

```cadence
pub event NewNodeCreated(nodeID: String, role: UInt8, amountCommitted: UFix64)
```

| Field           | Type   | Description                                                                                                                                                                                         |
| --------------- | ------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| nodeID          | String | The unique ID string for the node. 32 bytes. Usually the hash of the node's public key.                                                                                                             |
| role            | UInt8  | The node's role type. From 1 to 5 inclusive. For the meaning of the values see [FlowIDTableStaking.cdc](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowIDTableStaking.cdc) |
| amountCommitted | UFix64 | The amount of FLOW tokens staked to register the node. This is determined by the `role`.                                                                                                            |

Emitted by `FlowIDTableStaking.NodeRecord.init()` when a new node is successfully created.

After this event is emitted for your node, you can begin to perform staking transactions using it.

### NodeRemovedAndRefunded

```cadence
pub event NodeRemovedAndRefunded(nodeID: String, amount: UFix64)
```

| Field  | Type   | Description                                                                                                     |
| ------ | ------ | --------------------------------------------------------------------------------------------------------------- |
| nodeID | String | The unique ID string for the node. 32 bytes. The same value emitted in the `NewNodeCreated` event for the node. |
| amount | UFix64 | The amount of FLOW tokens returned to the node.                                                                 |

Emitted by `FlowIDTableStaking.Admin.endStakingAuction()` if the node is being removed from the next epoch
due to a failure to meet the minimum requirements of committed tokens for the next epoch.

After this event, the refunded FLOW tokens will be part of the node's `tokensUnstaked` balance.

## Token Events

These are events that concern the direct usage of FLOW tokens - staking or unstaking locked tokens, withdrawing rewards, etc.

Events emitted when using delegation are described in the next section.

### TokensCommitted

```cadence
pub event TokensCommitted(nodeID: String, amount: UFix64)
```

| Field  | Type   | Description                                                                                                     |
| ------ | ------ | --------------------------------------------------------------------------------------------------------------- |
| nodeID | String | The unique ID string for the node. 32 bytes. The same value emitted in the `NewNodeCreated` event for the node. |
| amount | UFix64 | The amount of additional FLOW tokens committed to the node.                                                     |

Emitted whenever additional tokens are staked on the node for the following epoch. Specifically:

1. By `FlowIDTableStaking.NodeStaker.stakeNewTokens()` when new tokens (tokens that have not previously been staked) are added to the system
   to stake on the node during the next epoch.
2. By `FlowIDTableStaking.NodeStaker.stakeUnstakedTokens()` when unstaked tokens (tokens that were previously staked and then unstaked)
   are staked again with the node for the next epoch.
3. By `FlowIDTableStaking.NodeStaker.stakeRewardedTokens()` when reward tokens (tokens paid in return for previous staking)
   are staked with the node for the next epoch.

After this event, the FLOW tokens will be part of the node's `tokensCommitted` balance.

### TokensStaked

```cadence
pub event TokensStaked(nodeID: String, amount: UFix64)
```

| Field  | Type   | Description                                                                                                     |
| ------ | ------ | --------------------------------------------------------------------------------------------------------------- |
| nodeID | String | The unique ID string for the node. 32 bytes. The same value emitted in the `NewNodeCreated` event for the node. |
| amount | UFix64 | The amount of FLOW tokens staked to the node.                                                                   |

Emitted by `FlowIDTableStaking.Admin.moveTokens()` at the end of an epoch if committed tokens are being added to the node's tokensStaked balance.

After this event, the tokens will be part of the node's staked balance.

### TokensUnstaking

```cadence
pub event TokensUnstaking(nodeID: String, amount: UFix64)
```

| Field  | Type   | Description                                                                                                     |
| ------ | ------ | --------------------------------------------------------------------------------------------------------------- |
| nodeID | String | The unique ID string for the node. 32 bytes. The same value emitted in the `NewNodeCreated` event for the node. |
| amount | UFix64 | The amount of FLOW tokens unstaked from the node.                                                               |

Emitted by `FlowIDTableStaking.Admin.moveTokens()` at the end of an epoch if
a node operator's staked tokens are being unstaked in response to a request from the node operator.
After this event, the tokens will be a part of the node operator's `tokensUnstaking` balance, where they are held for a whole epoch "unstaking period" with no rewards.

### TokensUnstaked

```cadence
pub event TokensUnstaked(nodeID: String, amount: UFix64)
```

| Field  | Type   | Description                                                                                                     |
| ------ | ------ | --------------------------------------------------------------------------------------------------------------- |
| nodeID | String | The unique ID string for the node. 32 bytes. The same value emitted in the `NewNodeCreated` event for the node. |
| amount | UFix64 | The amount of FLOW tokens unstaked from the node.                                                               |

Emitted by `FlowIDTableStaking.NodeStaker.requestUnstaking()` and `FlowIDTableStaking.Admin.moveTokens()`
when tokens are deposited into the `tokensUnstaked` pool:

### RewardsPaid

```cadence
pub event RewardsPaid(nodeID: String, amount: UFix64)
```

| Field  | Type   | Description                                                                                                     |
| ------ | ------ | --------------------------------------------------------------------------------------------------------------- |
| nodeID | String | The unique ID string for the node. 32 bytes. The same value emitted in the `NewNodeCreated` event for the node. |
| amount | UFix64 | The amount of FLOW tokens paid to the node this epoch as a reward.                                              |

Emitted by `FlowIDTableStaking.Admin.payRewards()` at the end of the epoch to pay rewards to node operators based on the tokens that they have staked.

After this event, the reward tokens will be part of the node's tokensRewarded balance.

The Delegator rewards are paid at the same time, see `DelegatorRewardsPaid` below.

### UnstakedTokensWithdrawn

```cadence
pub event UnstakedTokensWithdrawn(nodeID: String, amount: UFix64)
```

| Field  | Type   | Description                                                                                                     |
| ------ | ------ | --------------------------------------------------------------------------------------------------------------- |
| nodeID | String | The unique ID string for the node. 32 bytes. The same value emitted in the `NewNodeCreated` event for the node. |
| amount | UFix64 | The amount of unstaked FLOW tokens that the node operator is withdrawing.                                       |

Emitted by `FlowIDTableStaking.NodeStaker.withdrawUnstakedTokens()` when the node operator calls that function to withdraw part or all of their
unstaked tokens balance.

After this event, the FLOW tokens will be withdrawn to a newly created `FungibleToken.Vault` which the caller can deposit to the vault of their choice.

### RewardTokensWithdrawn

```cadence
pub event RewardTokensWithdrawn(nodeID: String, amount: UFix64)
```

| Field  | Type   | Description                                                                                                     |
| ------ | ------ | --------------------------------------------------------------------------------------------------------------- |
| nodeID | String | The unique ID string for the node. 32 bytes. The same value emitted in the `NewNodeCreated` event for the node. |
| amount | UFix64 | The amount of rewarded FLOW tokens that the node operator is withdrawing.                                       |

Emitted by `FlowIDTableStaking.NodeStaker.withdrawRewardedTokens()` when the node operator calls that function to withdraw part or all of their
reward tokens balance.

After this event, the FLOW tokens will be withdrawn to a newly created `FungibleToken.Vault` which the caller can deposit to the vault of their choice.

## Delegator Events

These are events that concern FLOW token delegation.

### NewDelegatorCreated

```cadence
pub event NewDelegatorCreated(nodeID: String, delegatorID: UInt32)
```

| Field       | Type   | Description                                                                                                     |
| ----------- | ------ | --------------------------------------------------------------------------------------------------------------- |
| nodeID      | String | The unique ID string for the node. 32 bytes. The same value emitted in the `NewNodeCreated` event for the node. |
| delegatorID | UFix64 | The ID for the new delegator. Unique within the node but not globally.                                          |

Emitted by `FlowIDTableStaking.Admin.registerNewDelegator()` when the node operator registers a new delegator for the node.

Note that the delegatorID is unique within the node but is not globally unique.

After this event, the new delegator is registered with the node.

### DelegatorTokensCommitted

```cadence
pub event DelegatorTokensCommitted(nodeID: String, delegatorID: UInt32, amount: UFix64)
```

| Field       | Type   | Description                                                                                                     |
| ----------- | ------ | --------------------------------------------------------------------------------------------------------------- |
| nodeID      | String | The unique ID string for the node. 32 bytes. The same value emitted in the `NewNodeCreated` event for the node. |
| delegatorID | UInt32 | The ID for the delegator.                                                                                       |
| amount      | UFix64 | The amount of additional FLOW tokens committed to the node.                                                     |

Emitted whenever additional tokens are committed for a delegator for the following epoch. Specifically:

1. By `FlowIDTableStaking.NodeDelegator.delegateNewTokens()` when new tokens (tokens that have not previously been staked) are added to the system
   to stake with the delegator during the next epoch.
2. By `FlowIDTableStaking.NodeDelegator.delegateUnstakedTokens()` when unstaked tokens (tokens that were previously staked and then unstaked)
   are staked again with the delegator for the next epoch.
3. By `FlowIDTableStaking.NodeDelegator.delegateRewardedTokens()` when reward tokens (tokens paid in return for previous staking)
   are staked with the delegator for the next epoch.

After this event, the FLOW tokens will be part of the delegator's `tokensCommitted` balance.

### DelegatorTokensStaked

```cadence
pub event DelegatorTokensStaked(nodeID: String, delegatorID: UInt32, amount: UFix64)
```

| Field       | Type   | Description                                                                                                     |
| ----------- | ------ | --------------------------------------------------------------------------------------------------------------- |
| nodeID      | String | The unique ID string for the node. 32 bytes. The same value emitted in the `NewNodeCreated` event for the node. |
| delegatorID | UInt32 | The ID for the delegator.                                                                                       |
| amount      | UFix64 | The amount of FLOW tokens staked to the node.                                                                   |

Emitted by `FlowIDTableStaking.Admin.moveTokens()` at the end of an epoch if committed tokens are being added to the delegator's tokensStaked balance.

After this event, the tokens will be part of the delegator's staked balance.

### DelegatorTokensUnstaking

```cadence
pub event DelegatorTokensUnstaking(nodeID: String, delegatorID: UInt32, amount: UFix64)
```

| Field       | Type   | Description                                                                                                     |
| ----------- | ------ | --------------------------------------------------------------------------------------------------------------- |
| nodeID      | String | The unique ID string for the node. 32 bytes. The same value emitted in the `NewNodeCreated` event for the node. |
| delegatorID | UInt32 | The ID for the delegator.                                                                                       |
| amount      | UFix64 | The amount of FLOW tokens unstaked from the node.                                                               |

Emitted by `FlowIDTableStaking.Admin.moveTokens()` at the end of an epoch if
a delegator's staked tokens are being unstaked in response to a request from the delegator.
After this event, the tokens will be a part of the delegator's `tokensUnstaking` balance, where they are held for a whole epoch "unstaking period" with no rewards.

### DelegatorTokensUnstaked

```cadence
pub event DelegatorTokensUnstaked(nodeID: String, delegatorID: UInt32, amount: UFix64)
```

| Field       | Type   | Description                                                                                                     |
| ----------- | ------ | --------------------------------------------------------------------------------------------------------------- |
| nodeID      | String | The unique ID string for the node. 32 bytes. The same value emitted in the `NewNodeCreated` event for the node. |
| delegatorID | UInt32 | The ID for the delegator.                                                                                       |
| amount      | UFix64 | The amount of FLOW tokens unstaked from the node.                                                               |

Emitted by `FlowIDTableStaking.NodeDelegator.requestUnstaking()` and `FlowIDTableStaking.Admin.moveTokens()`
when tokens are deposited into the delegator's `tokensUnstaked` pool:

### DelegatorRewardsPaid

```cadence
pub event DelegatorRewardsPaid(nodeID: String, delegatorID: UInt32, amount: UFix64)
```

| Field       | Type   | Description                                                                                                     |
| ----------- | ------ | --------------------------------------------------------------------------------------------------------------- |
| nodeID      | String | The unique ID string for the node. 32 bytes. The same value emitted in the `NewNodeCreated` event for the node. |
| delegatorID | UFix64 | The ID for the delegator. Unique within the node but not globally.                                              |
| amount      | UFix64 | The amount of rewarded FLOW tokens that the delegator is paid.                                                  |

Emitted by `FlowIDTableStaking.Admin.payRewards()` at the end of an epoch when rewards are being paid.

After this event is emitted, the reward tokens will be part of the delegator's tokensRewarded balance.

The Node rewards are paid at the same time, see `RewardsPaid` above.

### DelegatorUnstakedTokensWithdrawn

```cadence
pub event DelegatorUnstakedTokensWithdrawn(nodeID: String, delegatorID: UInt32, amount: UFix64)
```

| Field       | Type   | Description                                                                                                     |
| ----------- | ------ | --------------------------------------------------------------------------------------------------------------- |
| nodeID      | String | The unique ID string for the node. 32 bytes. The same value emitted in the `NewNodeCreated` event for the node. |
| delegatorID | UFix64 | The ID for the delegator. Unique within the node but not globally.                                              |
| amount      | UFix64 | The amount of unstaked FLOW tokens that the delegator is withdrawing.                                           |

Emitted by `FlowIDTableStaking.NodeDelegator.withdrawUnstakedTokens()` when the delegator calls that function to withdraw part or all of their
unstaked tokens balance.

After this event, the FLOW tokens will be withdrawn to a newly created `FungibleToken.Vault` which the caller can deposit to the vault of their choice.

### DelegatorRewardTokensWithdrawn

```cadence
pub event DelegatorRewardTokensWithdrawn(nodeID: String, delegatorID: UInt32, amount: UFix64)
```

| Field       | Type   | Description                                                                                                     |
| ----------- | ------ | --------------------------------------------------------------------------------------------------------------- |
| nodeID      | String | The unique ID string for the node. 32 bytes. The same value emitted in the `NewNodeCreated` event for the node. |
| delegatorID | UFix64 | The ID for the delegator. Unique within the node but not globally.                                              |
| amount      | UFix64 | The amount of rewarded FLOW tokens that the delegator is withdrawing.                                           |

Emitted by `FlowIDTableStaking.NodeDelegator.withdrawRewardedTokens()` when the delegator calls that function to withdraw part or all of their
unstaked tokens balance.

After this event, the FLOW tokens will be withdrawn to a newly created `FungibleToken.Vault` which the caller can deposit to the vault of their choice.
---
title: Staking and Delegation rewards
sidebar_label: How to Query Staking rewards
description: How to check the staking and delegation rewards
---

## Current method to check staking rewards

Every week, the Flow governance committee executes the reward payout transaction.
When the transaction executes, it generates events for the rewards paid to each node and delegator.
To check the staking and delegation rewards, that transaction should be queried.

Example using [Flow cli](../../../tools/flow-cli/index.md)
```
$ flow transactions get 84eca4ff612ef70047d60510710cca872c8a17c1bd9f63686e74852b6382cc84 -n mainnet

Status		✅ SEALED
ID		84eca4ff612ef70047d60510710cca872c8a17c1bd9f63686e74852b6382cc84
Payer		e467b9dd11fa00df
Authorizers	[e467b9dd11fa00df]

Proposal Key:
    Address	e467b9dd11fa00df
    Index	11
    Sequence	118

No Payload Signatures

Envelope Signature 0: e467b9dd11fa00df
Envelope Signature 1: e467b9dd11fa00df
Envelope Signature 2: e467b9dd11fa00df
Envelope Signature 3: e467b9dd11fa00df
Envelope Signature 4: e467b9dd11fa00df
Signatures (minimized, use --include signatures)

Events:
    Index	0
    Type	A.1654653399040a61.FlowToken.TokensWithdrawn
    Tx ID	84eca4ff612ef70047d60510710cca872c8a17c1bd9f63686e74852b6382cc84
    Values
		- amount (UFix64): 64.59694884
		- from (Address?): 0xf919ee77447b7497

    Index	1
    Type	A.f919ee77447b7497.FlowFees.TokensWithdrawn
    Tx ID	84eca4ff612ef70047d60510710cca872c8a17c1bd9f63686e74852b6382cc84
    Values
		- amount (UFix64): 64.59694884

    Index	2
    Type	A.1654653399040a61.FlowToken.TokensMinted
    Tx ID	84eca4ff612ef70047d60510710cca872c8a17c1bd9f63686e74852b6382cc84
    Values
		- amount (UFix64): 1326397.40305116

    Index	3
    Type	A.1654653399040a61.FlowToken.TokensDeposited
    Tx ID	84eca4ff612ef70047d60510710cca872c8a17c1bd9f63686e74852b6382cc84
    Values
		- amount (UFix64): 1326397.40305116
		- to (Never?): nil

    Index	4
    Type	A.1654653399040a61.FlowToken.TokensWithdrawn
    Tx ID	84eca4ff612ef70047d60510710cca872c8a17c1bd9f63686e74852b6382cc84
    Values
		- amount (UFix64): 1004.16460872
		- from (Never?): nil

    Index	5
    Type	A.1654653399040a61.FlowToken.TokensDeposited
    Tx ID	84eca4ff612ef70047d60510710cca872c8a17c1bd9f63686e74852b6382cc84
    Values
		- amount (UFix64): 1004.16460872
		- to (Address?): 0x8624b52f9ddcd04a
   ...
   ...
   <clipped for brevity>
```

Example using [Flow Go SDK](../../../tools/clients/flow-go-sdk/index.mdx)
```
package main

import (
	"context"
	"fmt"
	"github.com/onflow/flow-go-sdk"
	client "github.com/onflow/flow-go-sdk/access/grpc"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

func main() {

	// the Flow mainnet community Access node API endpoint
	accessNodeAddress := "access.mainnet.nodes.onflow.org:9000"

	maxGRPCMessageSize := 1024 * 1024 * 20 // to accommodate for the large transaction payload

	// create a gRPC client for the Access node
	accessNodeClient, err := client.NewClient(accessNodeAddress,
		grpc.WithTransportCredentials(insecure.NewCredentials()),
		grpc.WithDefaultCallOptions(grpc.MaxCallRecvMsgSize(maxGRPCMessageSize)))
	if err != nil {
		fmt.Println("err:", err.Error())
		panic(err)
	}

	ctx := context.Background()

	txID := flow.HexToID("84eca4ff612ef70047d60510710cca872c8a17c1bd9f63686e74852b6382cc84")

	rewardsTxResult, err := accessNodeClient.GetTransactionResult(ctx, txID)
	if err != nil {
		panic(err)
	}

	for _, event := range rewardsTxResult.Events {
		fmt.Println("Event type: " + event.Type)
		fmt.Println("Event: " + event.Value.String())
		fmt.Println("Event payload: " + string(event.Payload))
	}
}
```

## New method to check staking rewards

As part of the new method, rewards payout will happen automatically after the end of the epoch and without the need of an explicit transaction being submitted by the service account.
Instead of a separate reward payout transaction, the reward payout events will be recorded in the system chunk in the block that is produced at the time of the epoch transition without creating a regular transaction ID.

The rewards payout can be queried by querying the block which contains the system chunk that contains the reward payout events.
```
flow events get A.8624b52f9ddcd04a.FlowIDTableStaking.RewardsPaid A.8624b52f9ddcd04a.FlowIDTableStaking.DelegatorRewardsPaid --start <block Height> --end <block height> -n mainnet

where block height is the height of the block containing the rewards payout events
```

Example

```
$ flow events get A.8624b52f9ddcd04a.FlowIDTableStaking.RewardsPaid A.8624b52f9ddcd04a.FlowIDTableStaking.DelegatorRewardsPaid --start 51753836 --end 51753836 -n mainnet

Events Block #51753836:
    Index	6
    Type	A.8624b52f9ddcd04a.FlowIDTableStaking.RewardsPaid
    Tx ID	f31815934bff124e332b3c8be5e1c7a949532707251a9f2f81def8cc9f3d1458
    Values
		- nodeID (String): "a3075cf9280cab4fa0b7b1e639b675bdae3e8874557d98ee78963f0799338a5f"
		- amount (UFix64): 1660.21200000

    Index	9
    Type	A.8624b52f9ddcd04a.FlowIDTableStaking.RewardsPaid
    Tx ID	f31815934bff124e332b3c8be5e1c7a949532707251a9f2f81def8cc9f3d1458
    Values
		- nodeID (String): "cf0ff514b6aa659914b99ab1d17743edb2b69fbb338ab01945a08530a98c97d4"
		- amount (UFix64): 3762.20370347

    Index	12
    Type	A.8624b52f9ddcd04a.FlowIDTableStaking.RewardsPaid
    Tx ID	f31815934bff124e332b3c8be5e1c7a949532707251a9f2f81def8cc9f3d1458
    Values
		- nodeID (String): "de988efc8cb79d02876b7beffd404fc24b61c287ebeede567f90056f0eece90f"
		- amount (UFix64): 939.85630919

    Index	27
    Type	A.8624b52f9ddcd04a.FlowIDTableStaking.RewardsPaid
    Tx ID	f31815934bff124e332b3c8be5e1c7a949532707251a9f2f81def8cc9f3d1458
    Values
		- nodeID (String): "fa5f24a66c2f177ebc09b8b51429e9f157037880290e7858f4336479e57dc26b"
		- amount (UFix64): 1660.21200000

    Index	30
    Type	A.8624b52f9ddcd04a.FlowIDTableStaking.RewardsPaid
    Tx ID	f31815934bff124e332b3c8be5e1c7a949532707251a9f2f81def8cc9f3d1458
    Values
		- nodeID (String): "581525fa93d8fe4b334c179698c6e72baccb802593e55e40da61d24e589d85be"
		- amount (UFix64): 1937.24727662
    ...
    ...
   <clipped for brevity>
    ...
    ...
    Index	50115
    Type	A.8624b52f9ddcd04a.FlowIDTableStaking.DelegatorRewardsPaid
    Tx ID	f31815934bff124e332b3c8be5e1c7a949532707251a9f2f81def8cc9f3d1458
    Values
		- nodeID (String): "95ffacf0c05757cff71a4ee49e025d5a6d1103a3aa7d91253079e1bfb7c22458"
		- delegatorID (UInt32): 23
		- amount (UFix64): 0.10424555

    Index	50118
    Type	A.8624b52f9ddcd04a.FlowIDTableStaking.DelegatorRewardsPaid
    Tx ID	f31815934bff124e332b3c8be5e1c7a949532707251a9f2f81def8cc9f3d1458
    Values
		- nodeID (String): "95ffacf0c05757cff71a4ee49e025d5a6d1103a3aa7d91253079e1bfb7c22458"
		- delegatorID (UInt32): 18
		- amount (UFix64): 17.31047712
```

Example using [Flow Go SDK](../../../tools/clients/flow-go-sdk/index.mdx)
```
package main

import (
	"context"
	"fmt"
	client "github.com/onflow/flow-go-sdk/access/grpc"
)

func main() {

	// the Flow testnet community Access node API endpoint
	accessNodeAddress := "access.mainnet.nodes.onflow.org:9000"

	// create a gRPC client for the Access node
	accessNodeClient, err := client.NewClient(accessNodeAddress)
	if err != nil {
		fmt.Println("err:", err.Error())
		panic(err)
	}

	ctx := context.Background()

	blockEvents, err := accessNodeClient.GetEventsForHeightRange(ctx,
		"A.8624b52f9ddcd04a.FlowIDTableStaking.RewardsPaid",
		51753836,
		51753836)
	if err != nil {
		panic(err)
	}

	for _, blockEvent := range blockEvents {
		fmt.Println("Block: " + blockEvent.BlockID.String())
		for _, event := range blockEvent.Events {
			fmt.Println("\tEvent type: " + event.Type)
			fmt.Println("\tEvent: " + event.Value.String())
			fmt.Println("\tEvent payload: " + string(event.Payload))
		}
	}
}
```---
title: Quorum Certificate and Distributed Key Generation
sidebar_label: QC and DKG
description: How the Flow protocol manages the Epoch Setup Phase
---

<Callout type="warning">
  If you haven't read the Intro to Flow Staking document and the Epoch protocol document,
  please read that first. Those documents provide an overview of epochs on Flow for
  all users and are necessary prerequisites to this document.
</Callout>
<Callout type="warning">
  This document assumes you have some technical knowledge about the Flow
  blockchain and programming environment.
</Callout>


# Epoch Setup Phase

**Purpose:** During the epoch setup phase, all nodes participating in the upcoming epoch
must perform setup tasks in preparation for the upcoming epoch, including
the Collector Cluster Quorum Certificate Generation and Consensus Committe Distributed Key Generation.

**Duration:** The epoch setup phase begins right after the `EpochSetup` service event is emitted.
It ends with the block where `EpochCommit` service emitted.

# Machine Accounts

The processes described in this document are fully automated.

They are expected to be performed entirely by the node software with no manual
interaction required by the node operator after the node has been set up and registered.

To facilitate this, we recommend that node operators use a secondary "machine account"
that only stores the `FlowClusterQC.Voter` or `FlowDKG.Participant` resource objects
in addition to FLOW to pay for transaction fees. You can connect your node to this account
to participate in the Epoch Setup Phase without having to do the actions manually.

If you are using the [Staking Collection](./staking-collection) for your node,
this functionality is built-in. When you register a node with the staking collection,
you also have to provide a public key or keys for your machine account for the node.

If you have a node without a machine account (if you were operating a node from the time
before epochs and staking collection were enabled, for example) the staking collection
also provides a method to create a machine account for an existing node.

See the [Staking Collection Docs](./14-staking-collection.mdx#machine-account-support)
for more information.

# Collector Cluster Quorum Certificate Generation Protocol

The collector nodes are organized into clusters and must bootstrap
the Hotstuff consensus algorithm for each cluster. To do this,
they generate the root block for their respective clusters
and submit a vote for the root block to a specialized smart contract, `FlowClusterQC`.
If 2/3 of the collectors in a cluster have voted with the same unique vote,
then the cluster is considered complete.
Once all clusters are complete, the QC is complete.

## `FlowClusterQC` Transactions

### Create QC Voter Object

A node uses the [`getClusterQCVoter()`](https://github.com/onflow/flow-core-contracts/blob/master/contracts/epochs/FlowEpoch.cdc#L732)
function in the `FlowEpoch` contract to create their Voter object and needs to provide
a reference to their `FlowIDTableStaking.NodeStaker` object to prove they are the node owner.

When registering a node with the staking collection, this process is handled by
[the transaction to register.](./14-staking-collection.mdx#register-a-new-staked-node)
It also creates a machine account for the QC object.

If a user already has a registered node with the staking collection, but hasn't created their QC Voter object yet,
they can use the [`create_machine_account.cdc` transaction.](./14-staking-collection.mdx#create-a-machine-account-for-an-existing-node)

If a user is not using the staking collection, they can use the **Create QC Voter** ([QC.01](../../core-contracts/07-epoch-contract-reference.md#quorum-certificate-transactions-and-scripts))
transaction. This will only store the QC Voter object in the account that stores the `NodeStaker` object.
It does not create a machine account or store it elsewhere, so it is not recommended to use. We encourage to use the staking collection instead.

### Submit Vote

During the Epoch Setup Phase, the node software should submit the votes for the QC generation
automatically using the **Submit QC Vote** ([QC.02](../../core-contracts/07-epoch-contract-reference.md#quorum-certificate-transactions-and-scripts))
transaction with the following arguments.

| Argument                | Type     | Description |
|-------------------------|----------|-------------|
| **voteSignature**       | `String` | The signed message (signed with the node's staking key) |
| **voteMessage**         | `String` | The raw message itself. |

# Consensus Committee Distributed Key Generation Protocol (DKG)

The Random Beacon Committee for the next Epoch (currently all consensus nodes)
will run the DKG through a specialized smart contract, `FlowDKG`.
To do this, they post a series of messages to a public "whiteboard" to 
collectively generate a shared key array. When each node has enough information
to generate their array of keys, they send the generated array to the smart contract
as their final submission.
If `(# of consensus nodes-1)/2` consensus nodes submit the same key array,
the DKG is considered to be complete.

## `FlowDKG` Transactions

### Create DKG Participant Object

A node uses the [`getDKGParticipant()`](https://github.com/onflow/flow-core-contracts/blob/master/contracts/epochs/FlowEpoch.cdc#L746)
function in the `FlowEpoch` contract to create their Voter object and needs to provide
a reference to their `FlowIDTableStaking.NodeStaker` object to prove they are the node owner.

When registering a node with the staking collection, this process is handled by
[the transaction to register.](./14-staking-collection.mdx#register-a-new-staked-node)
It also creates a machine account for the DKG Object.

If a user already has a registered node with the staking collection, but hasn't created their DKG Participant object yet,
they can use the [`create_machine_account.cdc` transaction.](./14-staking-collection.mdx#create-a-machine-account-for-an-existing-node)

If a user is not using the staking collection, they can use the **Create DKG Participant** ([DKG.01](../../core-contracts/07-epoch-contract-reference.md#dkg-transactions-and-scripts))
transaction. This will only store the DKG Participant object in the account that stores the `NodeStaker` object.
It does not create a machine account or store it elsewhere, so it is not recommended to use. 
The staking collection is the recommended method.

### Post Whiteboard Message

During the Epoch Setup Phase, the node software should post whiteboard messages to the DKG
automatically using the **Post Whiteboard Message** ([DKG.02](../../core-contracts/07-epoch-contract-reference.md#dkg-transactions-and-scripts))
transaction with the following arguments.

| Argument          | Type     | Description |
|-------------------|----------|-------------|
| **content**       | `String` | The content of the whiteboard message |

### Send Final Submission

During the Epoch Setup Phase, the node software should send its final submission for the DKG
automatically using the **Send Final Submission** ([DKG.03](../../core-contracts/07-epoch-contract-reference.md#dkg-transactions-and-scripts))
transaction with the following arguments.

| Argument           | Type        | Description |
|--------------------|-------------|-------------|
| **submission**     | `[String?]` | The final key vector submission for the DKG. |

# Monitor Events and Query State from the QC and DKG Contracts

See the [QC and DKG events and scripts document](./qc-dkg-scripts-events) for information
about the events that can be emitted by these contracts and scripts you can use to query information.
---
title: Query QC/DKG Info with Scripts or Events
sidebar_label: QC/DKG Scripts and Events
---

# Introduction

The Cluster Quorum Certificate (QC) and Distributed Key Generation (DKG) protocol smart contracts
store a lot of different state, and the state is constantly changing.
As an external party, there are two ways to keep track of these state changes. 
You can either use Cadence scripts to query the state of the contract at any given time,
or you can monitor events that are emitted by the contracts to be notified of any important occurances.

# Query Information with Scripts

These events can be queried using the Go or JavaScript SDKs to extract useful notifications and information about the
state of these processes.

## QC Scripts

These scripts allow anyone to query information about the state of the QC contract.

### Get Clusters

To return a struct representing the information associated with a collector cluster,
can use the **Get Cluster** ([QC.03](../../core-contracts/07-epoch-contract-reference.md#quorum-certificate-transactions-and-scripts)) script with the following argument:

| Argument         | Type     | Description |
|------------------|----------|-------------|
| **clusterIndex** | `UInt16` | The index of the cluster to query |

### Get QC Enabled

To return a boolean representing if the QC is enabled,
can use the **Get QC Enabled** ([QC.04](../../core-contracts/07-epoch-contract-reference.md#quorum-certificate-transactions-and-scripts)) script with no arguments.

### Get Node Has Voted

To return a boolean representing if a node has voted for the current QC, you
can use the **Get Node Has Voted** ([QC.05](../../core-contracts/07-epoch-contract-reference.md#quorum-certificate-transactions-and-scripts)) script with the following argument:

| Argument         | Type     | Description |
|------------------|----------|-------------|
| **nodeID** | `String` | The node ID to check for |


### Get Voting Complete

To return a boolean representing if the voting for the QC phase is complete,
can use the **Get Voting Complete** ([QC.06](../../core-contracts/07-epoch-contract-reference.md#quorum-certificate-transactions-and-scripts)) script with no arguments.

## QC Events

Documentation coming soon

## DKG Scripts

### Get DKG Enabled

To return a boolean representing if the DKG is enabled, you
can use the **Get DKG Enabled** ([DKG.04](../../core-contracts/07-epoch-contract-reference.md#dkg-transactions-and-scripts)) script with no arguments.

### Get DKG Completed

To return a boolean representing if the dkg is complete, you
can use the **Get DKG Complete** ([DKG.05](../../core-contracts/07-epoch-contract-reference.md#dkg-transactions-and-scripts)) script with no arguments.

### Get Whiteboard Messages

To return an array of structs representing all the whiteboard messages, you
can use the **Get DKG Whiteboard Messages** ([DKG.06](../../core-contracts/07-epoch-contract-reference.md#dkg-transactions-and-scripts)) script with no arguments.

### Get Final Submissions

To return an array of key vectors for the nodes' final submissions, you
can use the **Get Final Submissions** ([DKG.07](../../core-contracts/07-epoch-contract-reference.md#dkg-transactions-and-scripts)) script with no arguments.

### Get Node Has Submitted

To return a boolean representing if a node has sent their final submission for the DKG, you
can use the **Get Node Has Submitted** ([DKG.08](../../core-contracts/07-epoch-contract-reference.md#dkg-transactions-and-scripts)) script with the following argument:

| Argument         | Type     | Description |
|------------------|----------|-------------|
| **nodeID** | `String` | The node ID to check for |

## DKG Events

```cadence
/// Emitted when the admin enables the DKG
pub event StartDKG()

/// Emitted when the admin ends the DKG after enough submissions have been recorded
pub event EndDKG(finalSubmission: [String?]?)

/// Emitted when a consensus node has posted a message to the DKG whiteboard
pub event BroadcastMessage(nodeID: String, content: String)
```---
title: Machine Account
sidebar_label: Machine Account
description: Usage and Purpose of the Machine Account
---

### What is a Machine Account?

A Machine Account is a Flow account which is used autonomously by a node to interact with
system smart contracts. Machine Accounts contain Cadence resources granted to network 
participants which are used to participate in smart-contract-mediated protocols. Currently,
Machine Accounts are used in the [Epoch Preparation Protocol](./04-epoch-preparation.mdx), 
which prepares the network for the next epoch.

Your Machine Account is distinct from the account you use for staking your node (your Staking Account).
The Machine Account is intended for use by node software and does not have access to your staked tokens or staking rewards.

<Callout type="info">

Currently Machine Accounts are required only for `collection` and `consensus` nodes.

</Callout>

#### Creation

For new node operators, Machine Accounts are created during the [staking process](../nodes/flow-port/staking-guide.md) in Flow Port.
For node operators who initially staked prior to the introduction of Machine Accounts, Machine Accounts can be
created for your staked nodes by following [this guide](../node-operation/machine-existing-operator.mdx).

#### Funding

Machine Accounts must maintain a balance of liquid FLOW tokens to pay fees on transactions they
submit to system smart contracts. Typically very few transactions will be sent (about 1-5 per week)
however more may be required under certain circumstances and network conditions.

<Callout type="info">

Because some transactions sent by the Machine Account are system critical, we recommend maintaining
a balance sufficient to accomodate worst-case transaction submission numbers at all times.

</Callout>

When creating a new machine account, we recommend initially funding with 0.005 FLOW for collection nodes and
0.25 FLOW for consensus nodes.

Machine account balances should be monitored and periodically refilled to ensure they have sufficient funds.
We recommend a minimum balance at all times of 0.002 FLOW for collection nodes and 0.1 FLOW for consensus nodes.

A node operator can easily withdraw their FLOW from their machine account if they decide they don't need them there any more.
---
title: Staking FAQ
sidebar_title: FAQs
description: Frequently Asked Questions
---

### Where will users receive their staking reward for each staking option?

Staking rewards are not deposited directly into a user's account.
They are deposited to the user's rewards pool in their connected staking object
and can be withdrawn or restaked at any time.

If you staked using Flow Port, then you should be able to see your staking rewards there.
You can also withdraw the rewards or manually re-stake them through Flow Port.

If you staked using a staking provider such as Kraken, Blocto or Finoa,
please ask them how they manage staking rewards.

### Will staking rewards be automatically re-staked?

There will be _no_ automatic re-staking of staking rewards with Flow Port (i.e. using Ledger or Blocto).
If you want to re-stake your rewards, you must manually do so yourself.

If you staked using a staking provider such as Kraken, Blocto or Finoa,
please ask them what their policies are.

DeFi liquid staking strategies such as offered by [incrementFi](https://app.increment.fi/staking)
are not managed by the protocol or nodes, but are more sophisticated ways
to manage your staking.

### Does it make a difference as to what TYPE of node we delegate to in terms of rewards?

No, rewards are calculated the same for every node type.

### Can a validator change its fees?

The network enforces a delegation fee of 8% which cannot be directly changed.
Any different fees that nodes claim they have are rebates that they
offer using their own methods and are not enforced by the protocol. 

### Can a token holder stake to multiple nodes? If yes, how is the stake split between them?

A token holder can delegate to multiple nodes from a single account if they use the 
[Staking Collection](./14-staking-collection.mdx).

The staking collection is enabled by default on Flow port, and many custody providers also support it.

### Is the wallet key transferred to the staked node?

No - The keys on the node are different from the wallet keys. The wallet keys always stay in the wallet.
A node operator generates the staking and networking keys separately which will be used on the node.

### Can I stake through multiple accounts to meet the minimum FLOW required for staking a node?

No, the minimum stake must come from a single account for all node types.
Temporarily, the minimum for consensus nodes can come from a combination
of staking actions from two accounts controlled by the same party.

### How can I reach the Consensus node minimum stake of 500K FLOW

The consensus node minimum of 500K FLOW can be met with a minimum
250,000 FLOW staking action and additional delegation
adding a minimum of 250,000 more FLOW from the same entity.

### Is rewards payout another spork?

No, rewards payout is not a spork but is an automatic transaction that happens
at the beginning of every new epoch.

### Can I query an account address of a node ID or delegator ID?

The staking smart contract does not directly associate a node or delegator with an account address. 
It associates it with the assigned resource object that corresponds to that entry in the contract. 
There can be any number of these objects stored in the same account, 
and they can be moved to different accounts if the owner chooses.
It is possible to query the information about a node that an address runs though, by using the
`get_node_info_from_address.cdc` script.---
title: Options for Building Staking Integrations
sidebar_label: Technical Staking Options
---

This document describes two different methods for staking at a high level.

<Callout type="warning">

We highly recommended you use the Staking Collection paradigm,
as this will be the most supported method for staking with any set up.

</Callout>

# Staking Collection

A Staking Collection is a resource that allows its owner to manage multiple staking
objects in a single account via a single storage path, and perform staking actions
using Flow. It also supports machine accounts, a necessary feature for Flow epoch node operation.

The staking collection paradigm is the most flexible of the three choices
and will receive the most support in the future. It is the set-up that Flow Port and many other staking providers use.

The staking collection setup and guide is detailed in the [staking collection guide.](./14-staking-collection.mdx)

# Staking

The basic method to stake is to stake directly with the `FlowIDTableStaking` smart contract.
This would involve calling the node or delegator registration functions directly in the staking
contract and storing the staking objects directly in account storage.

This is probably the simplest way to implement this, but it is not very flexible
and not recommended.

The basic staking guide is detailed [here](./15-staking-guide.mdx)---
title: Manage a Staking Collection
sidebar_label: Staking Collection Guide
---

This document outlines the steps a token holder can take to stake
using [the `FlowIDTableStaking` contract](../../core-contracts/06-staking-contract-reference.md)
and [the `FlowStakingCollection` contract.](../../core-contracts/11-staking-collection.md)
This is the recommended and most supported way to stake FLOW.
It supports any number of nodes and delegators per account, supports locked and unlocked FLOW,
and supports easily interaction with a node's machine account for collector and consensus nodes.

# Staking Collection Overview

A Staking Collection is a resource that allows its owner to manage multiple staking
objects in a single account via a single storage path, and perform staking actions 
using both locked and unlocked Flow.

Before the staking collection, accounts could use the instructions in 
[the unlocked staking guide](./15-staking-guide.mdx)
to stake with tokens. This was a bit restrictive, because that guide (and the corresponding transactions) 
only supports one node and one delegator object
per account. If a user wanted to have more than one per account,
they would either have to use custom transactions with custom storage paths for each object,
or they would have had to use multiple accounts, which comes with many hassles of its own.

The staking collection is a solution to both of these deficiencies.
When an account is set up to use a staking collection, the staking collection recognizes
the existing locked account capabilities (if they exist) and unlocked account staking objects,
and incorporates their functionality so any user can stake for a node or stake as a delegator
through a single common interface, regardless of if they have a brand new account,
or have been staking through the locked account or unlocked account before.

The staking collection also easily allows a user to transfer their node or delegator objects
to other accounts without interrupting the staking process!

## Staker Object Fields

The staking collection resource has two main fields, 
```cadence
access(self) var nodeStakers: @{String: FlowIDTableStaking.NodeStaker}
access(self) var nodeDelegators: @{String: FlowIDTableStaking.NodeDelegator}
```
These dictionaries store the staking objects that are managed by the staking collection.
Access to these dictionaries are mediated by the staking methods.
When a user wants to perform a staking operation,
they specify the nodeID and/or delegatorID they want to stake for, and the function routes the function
call to the correct staking object and performs the specified operation.

## Vault Capability Fields

The staking collection also has a field that stores a capability for
the unlocked FLOW Vault and locked FLOW vault (if applicable)
```cadence
/// unlocked vault
access(self) var unlockedVault: Capability<&FlowToken.Vault>

/// locked vault
/// will be nil if the account has no corresponding locked account
access(self) var lockedVault: Capability<&FlowToken.Vault>?
```

When a user performs staking operations like staking new tokens,
the staking collection tracks the number of unlocked tokens
and locked tokens (if applicable) that are used by the staking objects in the collection. 
The collection will always try to stake any available locked tokens first.
Once all locked tokens are staked, if the user requested to stake more than the locked token balance,
the collection will then dip into the unlocked balance for the remaining tokens.
If the user has no locked tokens, the staking collection 
will simply ignore the locked tokens part of the functionality and only use unlocked tokens.

When a user withdraws tokens from a staking object, the collection
will always try to withdraw unlocked tokens first.
Any unlocked tokens are then deposited directly into the vault on the unlocked account,
and remaining locked tokens are deposited to the vault in the locked account.

## Machine Account Support

The staking collection also supports an important feature for epochs, machine accounts.
Machine accounts are where node operators store important resource objects 
that are critical to the functionality of the epoch preparation protocol.
Every collector and consensus node should have an associated machine account that stores these objects,
and the staking collection helps the user create and manage these accounts.

When a user registers a new collector or consensus node,
the staking collection also creates a machine account for them and registers
the required object that needs to go in the machine account.
The node operator is then responsible for adding keys to the account.
(the **Register Node** transaction includes this step).

Once the machine account is created and set up, the node operator just has to
connect it to their node software and make sure the account has enough FLOW
to pay for transaction fees, which can be handled simply by submitting
a regular FLOW transfer to the machine account's address

## Staking Collection Public Getter Methods

The staking collection also defines many getter methods to query information
about an account's staking collection. You can simply call one of these methods on the contract,
providing the account address, and the contract will retreive
the relevant info for you, like so:
```cadence
import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS
import FlowIDTableStaking from 0xIDENTITYTABLEADDRESS

/// Gets an array of all the delegator metadata for delegators stored in the staking collection
pub fun main(address: Address): [FlowIDTableStaking.DelegatorInfo] {
    return FlowStakingCollection.getAllDelegatorInfo(address: address)
}
```

Remember: A Staking Collection does not require an account
to have a secondary locked account or locked FLOW.
However, if an account does have an associated locked account, when the Staking Collection is initialized,
it will connect to that locked account's node and delegator objects
as well as it's locked token vault allowing it to perform staking actions with locked and unlocked FLOW.

<Callout type="info">
Staking Collection is backwards compatible with other methods of staking on Flow.
Existing accounts with associated locked accounts
will still be able to stake in the same way as before,
but they will also be able to use the staking collection, if desired.
</Callout>


# How to use the Staking Collection

There is a standard set of transactions provided with the staking collection.

## Setup

### Setup a Staking Collection

To set up a Staking Collection, you must run the **Setup Staking Collection** ([SCO.01](../../core-contracts/11-staking-collection.md)) transaction.

This transaction requires no arguments and will perform the following actions:
1. Create private capabilities for the unlocked vault and locked vault (if applicable).
2. Create a new staking collection resource object, initializing it with the unlocked and locked vault capabilities.
3. Store the staking collection at a pre-defined storage path.
4. Create a public link to the staking collection so others can query metadata about it.
5. If there are any node or delegator objects in the unlocked account, the transaction stores those in the staking collection
   so they can be used through the same interface as usual.

**No arguments** are required for the **Setup Staking Collection** transaction.

Once this transaction is complete, your existing staking objects (if any) from your unlocked account and locked account
will be available via the staking collection and you can use all the transactions described below to access them.

### Create a Machine Account for an existing Node

Many nodes will have been created before the staking collection was set up and before epochs were enabled,
meaning that they don't already have an associated machine account. 
These nodes need a new transaction to create the machine account for the node and save it to the staking collection.

To create a machine account for a node that doesn't already have one,
you must submit the **Create Machine Account** ([SCO.03](../../core-contracts/11-staking-collection.md))
transaction with the following arguments:

| Argument       | Type        | Description |
|----------------|-------------|-------------|
| **nodeID**     | `String`    | The ID of the node. |
| **publicKeys** | `[String]` | The public keys to add to the machine account.|

If the node is a collector or consensus node, this transaction creates the associated machine account,
registers the QC or DKG object, stores it in the machine account,
and adds the provided public key(s) to the machine account.
If no public keys are provided, the transaction will fail.

## Register Stakers

### Register a New Staked Node

To register a new staked node, you must submit the **Register Node** ([SCO.03](../../core-contracts/11-staking-collection.md))
transaction with the following arguments:

| Argument              | Type        | Description |
|-----------------------|-------------|-------------|
| **id**                | `String`    | The ID of the new node. It must be a 32 byte `String`. The operator is free to choose this value, but it must be unique across all nodes. A recommended process to generate this is to hash the staking public key. |
| **role**              | `UInt8`     | The role of the new node. (1: collection, 2: consensus, 3: execution, 4: verification, 5: access) |
| **networkingAddress** | `String`    | The IP address of the new node. |
| **networkingKey**     | `String`    | The networking public key as a hex-encoded string. |
| **stakingKey**        | `String`    | The staking public key as a hex-encoded string. |
| **stakingKeyPoP**     | `String`    | The staking key Proof-of-Possesion as a hex-encoded string. |
| **amount**            | `UFix64`    | The number of FLOW tokens to stake. |
| **publicKeys**        | `[String]?` | The public keys to add to the machine account. `nil` if no machine account |

This transaction registers the account as a staker with the specified node information
and attaches a `NodeStaker` resource to the `Staking Collection`. 
This `NodeStaker` resourece can then later be used to perform staking actions via the staking collection staking methods.

If the node is a collector or consensus node, it also creates the associated machine account,
registers the QC or DKG object, stores it in the machine account,
and adds the provided public key(s) to the machine account.
If the node requires a machine account and no public keys are provided, the transaction will fail.

Once the account has registered their node using their Staking Collection,
their tokens and node information are committed to the central staking contract for the next epoch.

At this point, the Staking Collection now has access to various staking operations that they can perform,
assuming they have the correct number of tokens to perform the action.

### Register a New Staked Delegator

To register a new delegator, you must submit the **Register Delegator** ([SCO.02](../../core-contracts/11-staking-collection.md))
transaction with the following arguments:

| Argument   | Type     | Description |
|------------|----------|-------------|
| **id**     | `String` | The ID of the node to delegate to. |
| **amount** | `UFix64` | The number of FLOW tokens to delegate. |

This transaction registers the account as a delegator to the node identified by the supplied node id.
It also attaches a `NodeDelegator` resource to the `Staking Collection`. 
This `NodeDelegator` resourece can then later be used to perform delegation actions.

Once the account has registered their new delegator using their Staking Collection,
their tokens are committed to the central staking contract for the next epoch.

At this point, the Staking Collection now has access to various delegator operations that they can perform,
assuming they have the correct number of tokens to perform the action.


## Staking Operations

These transactions perform actions that directly interact with the staking contract.
Most of them will only succeed during the Staking Auction phase of the epoch.

### Stake New Tokens

The Staking Collection can stake additional tokens for any Node or Delegator managed by it at any time.

The owner of a Staking Collection can use the **Stake New Tokens** ([SCO.06](../../core-contracts/11-staking-collection.md))
transaction with the following arguments:

| Argument                | Type               | Description |
|-------------------------|--------------------|-------------|
| **nodeID**              | `String`           | The nodeID of the node to stake new tokens to. |
| **delegatorID**         | `Optional(UInt32)` | `nil` if staking for a node. If staking for a delegator, the delegator ID. |
| **amount**              | `UFix64`           | The number of FLOW tokens to stake. |

<Callout type="info">
To stake new tokens for an active node, leave the <b>delegatorID</b> arguement as <b>nil</b>.


If staking for a delegator, <b>delegatorID</b> should be the delegator ID you are staking for.
</Callout>

The amount may be any number of tokens up to the sum of an accounts locked and unlocked FLOW.

### Re-stake Unstaked Tokens

After tokens become unstaked, the owner of a Staking Collection can choose
to re-stake the unstaked tokens to the same Node or Delegator.

The owner of a Staking Collection can use the **Stake Unstaked Tokens** ([SCO.08](../../core-contracts/11-staking-collection.md))
transaction with the following arguments:

| Argument                | Type               | Description |
|-------------------------|--------------------|-------------|
| **nodeID**              | `String`           | The nodeID of the node to stake the unstaked tokens to. |
| **delegatorID**         | `Optional(UInt32)` | `nil` if staking for a node. If staking for a delegator, the delegator ID. |
| **amount**              | `UFix64`           | The number of FLOW tokens to restake. |

<Callout type="info">
To stake unstaked tokens for an active node, leave the <b>delegatorID</b> arguement as <b>nil</b>.

If staking for a delegator, <b>delegatorID</b> should be the delegator ID you are staking for.
</Callout>

### Re-stake Rewarded Tokens

After earning rewards from staking, the owner of a Staking Collection
can choose to re-stake the rewarded tokens to the same node or delegator.

The owner of a Staking Collection can use the **Stake Unstaked Tokens** ([SCO.07](../../core-contracts/11-staking-collection.md))
transaction with the following arguments:

| Argument                | Type               | Description |
|-------------------------|--------------------|-------------|
| **nodeID**              | `String`           | The nodeID of the node to stake the rewarded tokens to. |
| **delegatorID**         | `Optional(UInt32)` | `nil` if staking for a node. If staking for a delegator, the delegator ID. |
| **amount**              | `UFix64`           | The number of FLOW tokens to restake. |

<Callout type="info">
To stake rewarded tokens for an active node, leave the <b>delegatorID</b> arguement as <b>nil</b>.
</Callout>

### Request to Unstake Tokens at the end of the Epoch

The owner of a Staking Collection can submit a request to unstake their tokens at any time for any Node or Delegator in their collection.

If the tokens aren't staked yet, they will be uncommitted and available to withdraw.

_Note: unstaked tokens will be held by the central staking contract until the end of the following epoch._
_Once the tokens are released (unstaked), they can be claimed via the [Withdraw Unstaked Tokens](#withdraw-unstaked-tokens) action below._

The owner of a Staking Collection can use the **Unstake Tokens** ([SCO.05](../../core-contracts/11-staking-collection.md))
transaction with the following arguments:

| Argument                | Type               | Description |
|-------------------------|--------------------|-------------|
| **nodeID**              | `String`           | The nodeID of the chosen node. |
| **delegatorID**         | `Optional(UInt32)` | `nil` if staking for a node. If staking for a delegator, the delegator ID. |
| **amount**              | `UFix64`           | The number of FLOW tokens to restake. |

<Callout type="info">
To unstake tokens from an active node, leave the <b>delegatorID</b> arguement as <b>nil</b>.
</Callout>

### Unstake All Tokens

The owner of a Staking Collection can use the **Unstake All** ([SCO.09](../../core-contracts/11-staking-collection.md))
transaction with the following arguments:

| Argument                | Type               | Description |
|-------------------------|--------------------|-------------|
| **nodeID**              | `String`           | The nodeID of the node to unstake all tokens from. |
| **delegatorID**         | `Optional(UInt32)` | `nil` if staking for a node. If staking for a delegator, the delegator ID. |

### Withdraw Unstaked Tokens

After tokens for an active Node or Delegator become unstaked,
the ownder of Staking Collection can withdraw them from the central staking contract.

The owner of a Staking Collection can use the **Withdraw Unstaked Tokens** ([SCO.11](../../core-contracts/11-staking-collection.md))
transaction with the following arguments:

| Argument                | Type               | Description |
|-------------------------|--------------------|-------------|
| **nodeID**              | `String`           | The nodeID of the node to withdraw the unstaked tokens from. |
| **delegatorID**         | `Optional(UInt32)` | `nil` if staking for a node. If staking for a delegator, the delegator ID. |
| **amount**              | `UFix64`           | The number of FLOW tokens to withdraw. |

<Callout type="info">
To withdraw unstaked tokens from an active node, leave the <b>delegatorID</b> arguement as <b>nil</b>.
</Callout>

### Withdraw Rewarded Tokens

After earning rewards from staking, the token holder can withdraw them from the central staking contract.

The owner of a Staking Collection can use the **Withdraw Rewarded Tokens** ([SCO.10](../../core-contracts/11-staking-collection.md))
transaction with the following arguments:

| Argument                | Type               | Description |
|-------------------------|--------------------|-------------|
| **nodeID**              | `String`           | The nodeID of the node to withdraw the rewarded tokens from. |
| **delegatorID**         | `Optional(UInt32)` | `nil` if staking for a node. If staking for a delegator, the delegator ID. |
| **amount**              | `UFix64`           | The number of FLOW tokens to withdraw. |

<Callout type="info">
To withdraw rewarded tokens from an active node, leave the <b>delegatorID</b> arguement as <b>nil</b>.
</Callout>

## Staking Collection Modification

### Close a Node or Delegator

Once a Node or Delegator has no tokens staked, comitted or in an unstaking state, it is eligible to be closed.

Closing a Node or Delegator first returns any unstaked or rewarded tokens
to the account for which the Staking Collection is stored in.
It then destroys the NodeStaker or NodeDelegator object from within the Staking Collection.

_Note: Once a Node or Delegator has been closed, it cannot be accessed again,_
_and no staking or delegation actions can be futher preformed on it._

The owner of a Staking Collection can use the **Close Stake** ([SCO.12](../../core-contracts/11-staking-collection.md))
transaction with the following arguments:

| Argument                | Type               | Description |
|-------------------------|--------------------|-------------|
| **nodeID**              | `String`           | The nodeID of the node to close. |
| **delegatorID**         | `Optional(UInt32)` | `nil` if staking for a node. If staking for a delegator, the delegator ID. |

<Callout type="info">
To close an active node, leave the <b>delegatorID</b> arguement as <b>nil</b>.
</Callout>

### Transfer a Node

A user may transfer an existing Node to another another account's Staking Collection.

The account to transfer the Node to must have a valid Staking Collection set up.

Transferring a Node will remove it from the authorizer's Staking Collection
and deposit it to the receiver's Staking Collection.

_Note: Once a Node or Delegator has been transferred, it cannot be accessed again by the sender._
_As well, all staked tokens will be considered staked by the receiver's Staking Collection._

<Callout type="warning">
Transferring a Node will result in loss of custody of any Staked tokens for the sender.
</Callout>

The owner of a Staking Collection can use the **Transfer Node** ([SCO.13](../../core-contracts/11-staking-collection.md))
transaction with the following arguments:

| Argument                | Type               | Description |
|-------------------------|--------------------|-------------|
| **nodeID**              | `String`           | The nodeID of the node to transfer.  |
| **to**                  | `Address`          | The address of the account which contains the Staking Collection to transfer the Node to. |

### Transfer a Delegator

A user may transfer an existing Delegator to another another account's Staking Collection.

The account to transfer the Delegator to must have a valid Staking Collection set up.

Transferring a Delegator will remove it from the authorizer's Staking Collection
and deposit it to the receiver's Staking Collection.

_Note: Once a Node or Delegator has been transferred, it cannot be accessed again by the sender._
_As well, all staked tokens will be considered staked by the receiver's Staking Collection._

<Callout type="warning">
Transferring a Delegator will result in loss of custody of any Staked tokens for the sender.
</Callout>

The owner of a Staking Collection can use the **Transfer Delegator** ([SCO.14](../../core-contracts/11-staking-collection.md))
transaction with the following arguments:

| Argument                | Type               | Description |
|-------------------------|--------------------|-------------|
| **nodeID**              | `String`           | The nodeID of the delegator to transfer.  |
| **delegatorID**         | `UInt32`           | The delegatorID of the delegator to transfer.  |
| **to**                  | `Address`          | The address of the account which contains the Staking Collection to transfer the Delegator to. |


### Update A Node's Networking Address

A user may update their node's networking address if it has become inconsistent with the protocol state.

This operation can only be performed in the staking auction phase of an epoch.

_Note: Currently, if a node updates its networking address and the new address does not match_
_what is stored in the protocol state for the node, the node will not be able to participate in the upcoming epoch_
_Only update your networking address if you have already confirmed with the Flow team that you can._
_This restriction will be removed once fully automated epochs are completely implemented_

The owner of a Staking Collection can use the **Update Networking Address** ([SCO.22](../../core-contracts/11-staking-collection.md))
transaction with the following arguments:

| Argument        | Type      | Description |
|-----------------|-----------|-------------|
| **nodeID**      | `String`  | The nodeID of the node to update.  |
| **newAddress**  | `String`  | The new networking address |


# Staking Collection Scripts

These scripts allow anyone to query information about an account's staking collection

### Get All Node Info

To return an array of structs representing the information associated with each node managed by an account's Staking Collection, anyone
can use the **Get All Node Info** ([SCO.15](../../core-contracts/11-staking-collection.md)) script with the following arguments:

| Argument    | Type       | Description |
|-------------|------------|-------------|
| **address** | `Addresss` | The Address of the account holding the Staking Collection to query from |

This script returns an array of `FlowIDTableStaking.NodeInfo` [structs](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowIDTableStaking.cdc#L264)
representing the nodes managed by an accounts Staking Collection.

### Get All Delegator Info

To return an array of structs representing the information associated with each delegator managed by an account's Staking Collection, anyone
can use the **Get All Delegator Info** ([SCO.16](../../core-contracts/11-staking-collection.md)) script with the following arguments:

| Argument    | Type       | Description |
|-------------|------------|-------------|
| **address** | `Addresss` | The Address of the account holding the Staking Collection to query from |

This script returns an array of `FlowIDTableStaking.DelegatorInfo` [structs](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowIDTableStaking.cdc#L264)
representing the delegators managed by an accounts Staking Collection.

### Get All Node Ids

To return an array of Strings representing the ids associated with each node managed by an account's Staking Collection, anyone
can use the **Get All Node Ids** ([SCO.17](../../core-contracts/11-staking-collection.md)) script with the following arguments:

| Argument    | Type       | Description |
|-------------|------------|-------------|
| **address** | `Addresss` | The Address of the account holding the Staking Collection to query from |

This script returns an array of `String`
representing each id of each node managed by an accounts Staking Collection.

### Get All Delegator Ids

To return an array of structs representing the delegator ids associated with each delegation managed by an account's Staking Collection, anyone
can use the **Get All Delegator Ids** ([SCO.16](../../core-contracts/11-staking-collection.md)) script with the following arguments:

| Argument    | Type       | Description |
|-------------|------------|-------------|
| **address** | `Addresss` | The Address of the account holding the Staking Collection to query from |

This script returns an array of `FlowStakingCollection.DelegatorIDs` [structs](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowStakingCollection.cdc#L29)
representing the delegator Ids of each delegator managed by an accounts Staking Collection.

### Get Locked Tokens Used

To query how many Locked FLOW tokens an account has staked using their Staking Collection, anyone
can use the **Get Locked Tokens Used** ([SCO.19](../../core-contracts/11-staking-collection.md)) script with the following arguments:

| Argument    | Type       | Description |
|-------------|------------|-------------|
| **address** | `Addresss` | The Address of the account holding the Staking Collection to query from |

This script returns a `UFix64` representing the number of Locked FLOW tokens staked using an accounts Staking Collection.

<Callout type="info">
Note: This number does not include Locked FLOW tokens staked not through an accounts Staking Collection.
</Callout>

### Get Unlocked Tokens Used

To query how many Unlocked FLOW tokens an account has staked using their Staking Collection, anyone
can use the **Get Unlocked Tokens Used** ([SCO.20](../../core-contracts/11-staking-collection.md)) script with the following arguments:

| Argument    | Type       | Description |
|-------------|------------|-------------|
| **address** | `Addresss` | The Address of the account holding the Staking Collection to query from |

This script returns a `UFix64` representing the number of Unlocked FLOW tokens staked using an accounts Staking Collection.

<Callout type="info">
Note: This number does not include Unlocked FLOW tokens staked not through an accounts Staking Collection.
</Callout>

### Get Does Stake Exist 

To query if a Node or Delegator is managed by an accounts Staking Collection, anyone
can use the **Get Does Node Exist** ([SCO.21](../../core-contracts/11-staking-collection.md)) script with the following arguments:

| Argument                | Type               | Description |
|-------------------------|--------------------|-------------|
| **address**             | `Addresss`         | The Address of the account holding the Staking Collection to query from |
| **nodeID**              | `String`           | The nodeID of the node to check, or the nodeID of the node delegating to to check. |
| **delegatorID**         | `Optional(UInt32)` | The delegatorID of the delegator to check, if checking for a delegator. |

This script returns a `Bool`.

<Callout type="info">
To query if a Node is managed by an accounts Staking Collection, leave the <b>delegatorID</b> arguement as <b>nil</b>. 
Otherwise, fill it in with the <b>delegatorID</b> of the Delegator.
</Callout>

### Get Machine Account Info

To query the machine account information for an account's staking collection, anyone
can use the **Get Machine Account Info** ([SCO.21](../../core-contracts/11-staking-collection.md)) script with the following arguments:

| Argument                | Type               | Description |
|-------------------------|--------------------|-------------|
| **address**             | `Addresss`         | The Address of the account holding the Staking Collection to query from |

This script returns a `{String: FlowStakingCollection.MachineAccountInfo}`,
which is a mapping of nodeIDs to the `FlowStakingCollection.MachineAccountInfo` struct.
---
title: Basic Staking with FLOW
sidebar_label: Basic Staking Guide (Deprecated)
---

This document outlines the steps a token holder can take to stake and manage 
a Flow node with FLOW using only the types defined in the `FlowIDTableStaking` contract.
It only supports having one node or delegator object per account and is not supported by ledger
and will likely not be supported by other wallets, so it is recommended to use the staking collection
instead.

<Callout type="warning">
This guide covers staking with **FLOW tokens**.
</Callout>

# Staking

## Setup

### Register a New Staked Node

To register as a node operator with FLOW, the token holder can use the **Register Node** ([SC.11](../../core-contracts/06-staking-contract-reference.md#staking))
transaction with the following arguments:

| Argument              | Type     | Description |
|-----------------------|----------|-------------|
| **id**                | `String` | The ID of the new node. It must be a 32 byte `String`. The operator is free to choose this value, but it must be unique across all nodes. A recommended process to generate this is to hash the staking public key. |
| **role**              | `UInt8`  | The role of the new node. (1: collection, 2: consensus, 3: execution, 4: verification, 5: access) |
| **networkingAddress** | `String` | The IP address of the new node. (Length must be less than 255 bytes (510 Hex characters)) |
| **networkingKey**     | `String` | The networking public key as a 64 byte hex-encoded `String` (128 hex characters) |
| **stakingKey**        | `String` | The staking public key as a 96 byte hex-encoded `String` (192 hex characters) |
| **amount**            | `UFix64` | The number of FLOW tokens to stake. |

This transaction registers the account as a node operator with the specified node information
and creates a public link to query the nodes ID from the account address.

---

Once the token holder has registered their node,
their tokens and node information are committed to the central staking contract for the next epoch.

At this point, the token holder now has access to various staking operations that they can perform,
assuming they have the correct number of tokens to perform the action.

## Stake Tokens

The token holder can stake additional tokens at any time.

_Note: this transaction stakes additional tokens to the same node that was registered in the setup phase._

To stake tokens, the token holder can use the **Stake FLOW** ([SC.12](../../core-contracts/06-staking-contract-reference.md#staking))
transaction with the following arguments:

| Argument   | Type     | Description |
|------------|----------|-------------|
| **amount** | `UFix64` | The number of FLOW tokens to stake. |

This transaction commits tokens to stake from the token holder's account.

## Re-stake Unstaked Tokens

After tokens become unstaked, the token holder can choose to re-stake the unstaked tokens to the same node.

To staked unstaked tokens, the token holder can use the **Re-stake Unstaked FLOW** ([SC.13](../../core-contracts/06-staking-contract-reference.md#staking)) 
transaction with the following arguments:

| Argument   | Type     | Description |
|------------|----------|-------------|
| **amount** | `UFix64` | The number of unstaked FLOW tokens to stake. |

## Re-stake Rewarded Tokens

After earning rewards from staking, the token holder can choose to re-stake the rewarded tokens to the same node.

To stake rewarded tokens, the token holder can use the **Re-stake Rewarded FLOW** ([SC.14](../../core-contracts/06-staking-contract-reference.md#staking)) 
transaction with the following arguments:

| Argument   | Type     | Description |
|------------|----------|-------------|
| **amount** | `UFix64` | The number of rewarded FLOW tokens to stake. |

## Request Unstake Tokens

The token holder can submit a request to unstake some of their tokens at any time.
If the tokens aren't staked yet, they will be uncommitted and available to withdraw.

To request to unstake staked tokens, the token holder can use 
the **Request Unstaking** ([SC.15](../../core-contracts/06-staking-contract-reference.md#staking)) transaction.

| Argument   | Type     | Description |
|------------|----------|-------------|
| **amount** | `UFix64` | The number of rewarded FLOW tokens to request to un-stake. |

_Note: this transaction will not succeed if the node operator has delegators and the request
would put the node operator below the minimum required tokens staked for their node type.
Use the `Unstake All` transaction instead, which will also unstake all delegators._

_Note: unstaked tokens will be held by the central staking contract until the end of the following epoch. 
Once the tokens are released (unstaked), they can be claimed via the 
[Withdraw Unstaked Tokens](#withdraw-unstaked-tokens) action below._

## Unstake All Tokens

The token holder can submit a request to unstake all their tokens at any time.
If the tokens aren't staked yet, they will be uncommitted and available to withdraw.

To unstake all staked tokens, the token holder can use 
the **Unstake All FLOW** ([SC.16](../../core-contracts/06-staking-contract-reference.md#staking)) transaction.

This transaction requires no arguments.

**Warning: this will unstake all of the user's staked tokens and unstake all of the tokens
from users that are delegating FLOW to the node.**

## Withdraw Unstaked Tokens

After tokens become unstaked, the token holder can withdraw them from the central staking contract.

To withdraw unstaked tokens, 
the token holder can use the **Withdraw Unstaked FLOW** ([SC.17](../../core-contracts/06-staking-contract-reference.md#staking)) 
transaction with the following arguments:

| Argument   | Type     | Description |
|------------|----------|-------------|
| **amount** | `UFix64` | The number of unstaked FLOW tokens to withdraw. |

This transaction moves the unstaked tokens back into the `FlowToken.Vault` owned by the token holder.

## Withdraw Rewarded Tokens

After earning rewards from staking, the token holder can withdraw them from the central staking contract.

To withdraw rewarded tokens, 
the token holder can use the **Withdraw Rewarded FLOW** ([SC.18](../../core-contracts/06-staking-contract-reference.md#staking)) 
transaction with the following arguments:

| Argument   | Type     | Description |
|------------|----------|-------------|
| **amount** | `UFix64` | The number of rewarded FLOW tokens to withdraw. |

This transaction moves the rewarded tokens back into the `FlowToken.Vault` owned by the token holder. 

## Stake Multiple Nodes from the Same Account

Currently, the default staking transactions can only be used as they are to stake one node per account.

If a token holder wants to create a second staking relationship using the transactions as is, they must create a new account
and transfer their tokens to the new account.

It is possible to have multiple nodes per account by storing the node objects at different storage paths,
but this would require small changes to these transactions to use the new storage paths.


# Delegating

## Setup

## Register as a Delegator

To register as a delegator, the token holder can use the **Register Delegator** ([SC.19](../../core-contracts/06-staking-contract-reference.md#delegating))
transaction with the following arguments:

| Argument   | Type     | Description |
|------------|----------|-------------|
| **id**     | `String` | The ID of the node to delegate to. |
| **amount** | `UFix64` | The number of FLOW tokens to delegate. |

This transaction registers the account as a delegator to the node ID they specified.

---

## Delegate New Tokens

The token holder can delegate additional tokens after registering as a delegator. 

_Note: this transaction delegates additional tokens to the same node that was registered in the setup phase._

To delegate new tokens, 
the token holder can use the **Delegate New FLOW** ([SC.20](../../core-contracts/06-staking-contract-reference.md#delegating)) 
transaction with the following arguments:

| Argument   | Type     | Description |
|------------|----------|-------------|
| **amount** | `UFix64` | The number of FLOW tokens to delegate. |

## Re-delegate Unstaked Tokens

After delegated tokens become unstaked, the token holder can choose to re-delegate the unstaked tokens to the same node.

To delegate unstaked tokens, 
the token holder can use the **Re-delegate Unstaked FLOW** ([SC.21](../../core-contracts/06-staking-contract-reference.md#delegating))
transaction with the following arguments:

| Argument   | Type     | Description |
|------------|----------|-------------|
| **amount** | `UFix64` | The number of unstaked FLOW tokens to delegate. |

## Re-delegate Rewarded Tokens

After earning rewards from delegation, the token holder can choose to re-delegate the rewarded tokens to the same node.

To delegate rewarded tokens, 
the token holder can use the **Re-delegate Rewarded FLOW** ([SC.22](../../core-contracts/06-staking-contract-reference.md#delegating))
transaction with the following arguments:

| Argument   | Type     | Description |
|------------|----------|-------------|
| **amount** | `UFix64` | The number of rewarded FLOW tokens to delegate. |

## Unstake Delegated Tokens

The token holder can submit a request to unstake their delegated tokens at any time.
If the tokens aren't staked yet, they will be uncommitted and available to withdraw.

To unstake delegated tokens, 
the token holder can use the **Unstake Delegated FOW** ([SC.23](../../core-contracts/06-staking-contract-reference.md#delegating))
transaction with the following arguments:

| Argument   | Type     | Description |
|------------|----------|-------------|
| **amount** | `UFix64` | The number of FLOW tokens to unstake. |

_Note: unstaked delegated tokens will be held by the central staking contract for a period of time 
(the rest of the current epoch plus all of the next epoch) before they are 
released to the token holder. Once the tokens are released (unstaked), 
they can be claimed via the [Withdraw Unstaked Tokens](#withdraw-unstaked-tokens) action below._

## Withdraw Unstaked Tokens

After delegated tokens become unstaked, the token holder can withdraw them from the central staking contract.

To withdraw unstaked tokens, 
the token holder can use the **Withdraw Unstaked FLOW** ([SC.24](../../core-contracts/06-staking-contract-reference.md#delegating))
transaction with the following arguments:

| Argument   | Type     | Description |
|------------|----------|-------------|
| **amount** | `UFix64` | The number of unstaked FLOW tokens to withdraw. |

This transaction moves the unstaked tokens back into the `FlowToken.Vault` owned by the token holder.

## Withdraw Rewarded Tokens

After earning rewards from delegation, the token holder can withdraw them from the central staking contract.

To withdraw rewarded tokens, 
the token holder can use the **Withdraw Rewarded FLOW** ([SC.25](../../core-contracts/06-staking-contract-reference.md#delegating))
transaction with the following arguments:

| Argument   | Type     | Description |
|------------|----------|-------------|
| **amount** | `UFix64` | The number of rewarded FLOW tokens to withdraw. |

This transaction moves the rewarded tokens back into the `FlowToken.Vault` owned by the token holder. 

## Delegate to Multiple Nodes from the Same Account

Currently, the default delegating transactions can only be used as they are to stake one node per account.

If a token holder wants to create a second delegating relationship using the transactions as is, they must create a new account
and transfer their tokens to the new account.

It is possible to have multiple delegator objects per account 
by storing the node objects at different storage paths,
but this would require small changes to these transactions to use the new storage paths.
---
title: Epochs, Staking & Delegating on Flow
sidebar_title: Staking and Epochs
description: Introduction to how staking works on Flow
---

This document provides an introduction to staking FLOW tokens on the Flow network
for token holders and node operators.
Staking is an important part of the security protocol of a proof-of-stake (PoS) blockchain.
Running nodes and staking tokens contributes to the blockchain's
security and is rewarded accordingly.

## What is Staking?

Flow is a global network of computers working together
to maintain the security and integrity of its users' data.

This global network is made up of many individual nodes: software applications run by people.
Every node in the network shares a small part of the responsibility
to keep the network running smoothly and to ensure that other nodes are doing the same.
This shared responsibility is a core premise of decentralization, because no single central
node is solely responsible for the security and integrity of the network and the data it contains.

Node operators are what we call the people who run nodes.
In order to connect their software applications as nodes on the network,
a node operator must first purchase tokens. Every node operator has to temporarily give (or ‘stake’)
a large number of their tokens to the network as a promise that they will not modify their node
to do something that is against the rules of the network, like steal funds from users' accounts.
This process of temporarily giving up tokens is called staking.

If a node ever breaks the rules defined by the network,
a number of the node operator's staked tokens will be taken from them as a punishment.
This process is automatic. Every node knows the rules defined by the network
and automatically watches other nodes and reports them if they misbehave.
Meanwhile, the network pays the node operator a reward from a mixture of
transaction fees and newly minted tokens
on a regular basis provided their node does not break the rules.

If a node operator breaks the rules, they lose the tokens they've staked.
If they operate their node with integrity, they get rewarded with more tokens!
This is the basic incentive that enables a decentralized proof-of-stake network, like Flow.

## How Does Staking Work on Flow?

The Flow protocol maintains a list of node operators.
The list contains important information about each node, like their public keys, node address,
and what kind of node they are running.
(Collection, Consensus, Execution, Verification, or Access)

A node operator registers a node by submitting a transaction containing
their node information, a cryptographic proof that they control their node info,
and the FLOW they wish to stake.
If they meet the requirements to run a node, then will be accepted to join the network!

Once a node is staking and operating properly, it will receive periodic reward payments,
assuming it stays online and actively participates in the protocol
without committing any actions that would harm the network, which we call slashable offenses.
Once nodes have registered, they are required to operate for a protocol-specified timeframe.
This timeframe is otherwise known as an **Epoch.**

## Epochs

An **Epoch** is a roughly week-long period that the network uses
to manage list of nodes and pay rewards.

- Only a pre-determined set of nodes is authorized to participate in the protocol. 
The set of authorized nodes is known to all network participants.
This set is referred to as the **Identity Table**.
- An **Epoch** is defined as a period of time, where the set of authorized nodes is constant
(or can only shrink due to ejection of malicious nodes).

Every epoch, a list of committed nodes are chosen to be the staked nodes of the network.
This list is called the **Identity Table (ID Table)**.
The node's staked tokens are locked in and cannot change for the duration of the epoch.
At the end of the epoch, rewards are paid to each staked node based on how many tokens they had staked for that epoch
and how well they performed during the epoch. Nodes can choose to join or leave, but changes to the Identity Table
can only happen at end of an epoch, which is also the beginning of a new epoch.
This process repeats itself indefinitely, as long as the network remains functioning.

To determine the list of nodes that are included as officially staked nodes in the next epoch,
the protocol looks at the records of all the nodes that have committed tokens.
It checks to make sure each node's information is correct and that the node is running properly.
Each node also has to have committed tokens above the minimum stake required for their node role
and be authorized by the service account.
If any of these checks are insufficient, the node is not included in the next epoch.

Every epoch, some nodes also have to perform certain processes to initialize the state and communication
with other nodes for the next epoch. These processes are called **Cluster Quorum Certificate Generation (QC)**,
and **Distributed Key Generation (DKG)**. If any node does not perform this initialization properly,
it is not included in the next epoch's Identity Table.

If a node passes all the checks and initializations, it is approved and included as an official node for the next epoch.

Nodes (and users who delegate to them) do not have to continue to submit
staking registration transactions every epoch in order to remain staked.
As long as they continue to run their node properly, their tokens will remain staked.
A node operator only needs to take action if they want to stake more tokens
or if they want to unstake their staked tokens.

If a node operator or delegator decides to stake or unstake tokens,
their requests are not carried out until the end of the current epoch.
In the case of unstaking requests, they also must wait an additional
epoch before their unstaked tokens are available to withdraw.
This allows the protocol to deal with any slashable offenses that may have happened in the previous epoch.

See the [Epochs](./04-epoch-preparation.mdx) section of the documentation for in-depth explainations 
of the identity table, epoch schedule, QC, and DKG.

## Rewards

Please see the [schedule](./03-schedule.mdx) section of the documentation
for information about reward calculations and schedule and
what you can do with the rewards you earn by staking a node!

## Delegation

Any account in the network may also participate in staking by delegating their tokens to a node operator.
Every node operator in the network is eligible to receive delegations, there is no opting out.

To delegate to a node, a user simply specifies the ID of the node they want to delegate to
and the amount of tokens they want to delegate.
The tokens are committed and managed in the exact same way that normal staked tokens are managed.

Rewards for delegators are also calculated in the exact same way that rewards for node operators are calculated,
with one difference in that 8% of the calculated amount is given to the delegatee (the node being delegated to).
The remaining 92% is awarded to the delegator.

## How Do I Stake?

So you have decided you want to be a part of the Flow network? Welcome!
You are joining a group of people from all around the world that are a part of a movement that is bringing decentralization and transparency into the world.

### Staking using Flow Port

[Flow Port](https://port.onflow.org/) is a simple browser-based app for the Flow blockchain
that provides functionality for sending, receiving, and staking tokens.
Any wallet that uses the [Flow Client Library](../../../tools/clients/fcl-js/index.md)
is compatible with Flow Port.

If you created your account using [Flow Port](https://port.onflow.org/),
you can also stake and earn rewards using the Flow Port.
Follow this [step-by-step guide](../../run-and-secure/nodes/flow-port/staking-guide.md) to stake using Flow Port.
Flow Port currently supports staking as a node, delegating,
and reward withdrawal using **Blocto**, **Ledger**, **Lilico**, and **NuFi** accounts / wallets.

### Staking via a Custody Provider

If you are using a custody provider who controls your account and private keys for you,
such as Kraken, Finoa, or Coinlist, they all have different policies and processes
for what you need to do to stake your tokens, the rewards you receive,
and the fees that they take from your staking rewards.

### Manual Staking or Building your own Staking Integration

If you are self-custodying your Flow account and keys, or you want to build a staking service for customers,
you will need to learn more about how staking works,
the various methods for staking, and how you can participate safely and reliably.
See the [staking technical overview](./06-technical-overview.mdx) first
for information about technical integration.
---
sidebar_label: FCL Reference
sidebar_position: 2
---

# Flow Client Library (FCL) API Reference

> For release updates, [see the repo](https://github.com/onflow/fcl-js/releases)

## Configuration

FCL has a mechanism that lets you configure various aspects of FCL. When you move from one instance of the Flow Blockchain to another (Local Emulator to Testnet to Mainnet) the only thing you should need to change for your FCL implementation is your configuration.

---

### Setting Configuration Values

Values only need to be set once. We recommend doing this once and as early in the life cycle as possible. To set a configuration value, the `put` method on the `config` instance needs to be called, the `put` method returns the `config` instance so they can be chained.

Alternatively, you can set the config by passing a JSON object directly.

```javascript
import * as fcl from "@onflow/fcl";

fcl
  .config() // returns the config instance
  .put("foo", "bar") // configures "foo" to be "bar"
  .put("baz", "buz"); // configures "baz" to be "buz"

// OR

fcl.config({
  foo: "bar",
  baz: "buz",
});
```

### Getting Configuration Values

The `config` instance has an **asynchronous** `get` method. You can also pass it a fallback value.

```javascript
import * as fcl from "@onflow/fcl";

fcl.config().put("foo", "bar").put("woot", 5).put("rawr", 7);

const FALLBACK = 1;

async function addStuff() {
  var woot = await fcl.config().get("woot", FALLBACK); // will be 5 -- set in the config before
  var rawr = await fcl.config().get("rawr", FALLBACK); // will be 7 -- set in the config before
  var hmmm = await fcl.config().get("hmmm", FALLBACK); // will be 1 -- uses fallback because this isnt in the config

  return woot + rawr + hmmm;
}

addStuff().then((d) => console.log(d)); // 13 (5 + 7 + 1)
```

### Common Configuration Keys

| Name                                   | Example                                              | Description                                                                                                                                                                                    |
| --------------------------------- | --------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `accessNode.api` **(required)**        | `https://rest-testnet.onflow.org`                  | API URL for the Flow Blockchain Access Node you want to be communicating with. See all available access node endpoints [here](https://developers.onflow.org/http-api/). |
| `app.detail.title`                     | `Cryptokitties`                                      | Your applications title, can be requested by wallets and other services.                                                                                                                       |
| `app.detail.icon`                      | `https://fcl-discovery.onflow.org/images/blocto.png` | Url for your applications icon, can be requested by wallets and other services.                                                                                                                |
| `challenge.handshake`                  | **DEPRECATED**                                       | Use `discovery.wallet` instead.|
| `discovery.authn.endpoint`             | `https://fcl-discovery.onflow.org/api/testnet/authn` | Endpoint for alternative configurable Wallet Discovery mechanism. Read more on [discovery](#discovery)                                                                                         |
| `discovery.wallet` **(required)**      | `https://fcl-discovery.onflow.org/testnet/authn`     | Points FCL at the Wallet or Wallet Discovery mechanism.     
| `discovery.wallet.method`     | `IFRAME/RPC`, `POP/RPC`, `TAB/RPC`, `HTTP/POST`, or `EXT/RPC`     | Describes which service strategy a wallet should use.                                                                                                                                      |
| `fcl.limit`                         | `100`                                            | Specifies fallback compute limit if not provided in transaction.  Provided as integer.                                                                                      |
| `flow.network` **(recommended)**                      | `testnet`                                            | Used in conjunction with stored interactions and provides FCLCryptoContract address for `testnet` and `mainnet`. Possible values: `local`, `canarynet`, `testnet`, `mainnet`.                                                                            |
## Using Contracts in Scripts and Transactions

### Address Replacement

Configuration keys that start with `0x` will be replaced in FCL scripts and transactions, this allows you to write your script or transaction Cadence code once and not have to change it when you point your application at a difference instance of the Flow Blockchain.

```javascript
import * as fcl from "@onflow/fcl"

fcl.config()
  .put("0xFungibleToken", "0xf233dcee88fe0abe")

async function myScript () {
  return fcl.send([
    fcl.script`
      import FungibleToken from 0xFungibleToken // will be replaced with 0xf233dcee88fe0abe because of the configuration

      pub fun main() { /* Rest of the script goes here */ }
    `
  ]).then(fcl.decode)
}

async function myTransaction () {
  return fcl.send([
    fcl.transaction`
      import FungibleToken from 0xFungibleToken // will be replaced with 0xf233dcee88fe0abe because of the configuration

      transaction { /* Rest of the transaction goes here */ }
    `
  ]).then(fcl.decode)
}
```

#### Example

```javascript
import * as fcl from "@onflow/fcl"

fcl.config()
  .put("flow.network", "testnet")
  .put("accessNode.api", "https://rest-testnet.onflow.org")
  .put("discovery.wallet", "https://fcl-discovery.onflow.org/testnet/authn")
  .put("app.detail.title", "Test Harness")
  .put("app.detail.icon", "https://i.imgur.com/r23Zhvu.png")
  .put("service.OpenID.scopes", "email email_verified name zoneinfo")
  .put("0xFlowToken", "0x7e60df042a9c0868")
```

### Using Flow.json

A simpler way to import contracts in scripts and transactions is to use the `config.load` method to ingest your contracts from your `flow.json` file. This keeps the import syntax unified across tools and lets FCL figure out which address to use for what network based on the network provided in config. To use `config.load` you must first import your `flow.json` file and then pass it to `config.load` as a parameter.

```javascript
import { config } from '@onflow/fcl'
import flowJSON from '../flow.json'

config({
  'flow.network': 'testnet',
  'accessNode.api': 'https://rest-testnet.onflow.org',
  'discovery.wallet': `https://fcl-discovery.onflow.org/testnet/authn`,
}).load({ flowJSON })
```

Let's say your `flow.json` file looks like this:

```
{
  "contracts": {
		"HelloWorld": "cadence/contracts/HelloWorld.cdc"
	}
}
```

Then in your scripts and transactions, all you have to do is:

```
import "HelloWorld"
```

FCL will automatically replace the contract name with the address for the network you are using.

> Note: never put private keys in your `flow.json`. You should use the [key/location syntax](../../../tools/flow-cli/flow.json/security.md) to separate your keys into a separate git ignored file.

---

## Wallet Interactions

These methods allows dapps to interact with FCL compatible wallets in order to authenticate the user and authorize transactions on their behalf.

> ⚠️These methods are **async**.

---

### `authenticate`

> ⚠️**This method can only be used in web browsers.**

Calling this method will authenticate the current user via any wallet that supports FCL. Once called, FCL will initiate communication with the configured `discovery.wallet` endpoint which lets the user select a wallet to authenticate with. Once the wallet provider has authenticated the user, FCL will set the values on the [current user](#currentuserobject) object for future use and authorization.

#### Note

⚠️`discovery.wallet` value **must** be set in the configuration before calling this method. See [FCL Configuration](#configuration).

📣 The default discovery endpoint will open an iframe overlay to let the user choose a supported wallet.

#### Usage

```javascript
import * as fcl from "@onflow/fcl";
fcl
  .config()
  .put("accessNode.api", "https://rest-testnet.onflow.org")
  .put("discovery.wallet", "https://fcl-discovery.onflow.org/testnet/authn");
// anywhere on the page
fcl.authenticate();
```

#### Note

⚠️ `authenticate` can also take a service returned from [discovery](#discovery) with `fcl.authenticate({ service })`.


---

### `unauthenticate`

> ⚠️**This method can only be used in web browsers.**

Logs out the current user and sets the values on the [current user](#currentuserobject) object to null.

#### Note

⚠️The current user must be authenticated first.

#### Usage

```javascript
import * as fcl from "@onflow/fcl";
fcl.config().put("accessNode.api", "https://rest-testnet.onflow.org");
// first authenticate to set current user
fcl.authenticate();
// ... somewhere else & sometime later
fcl.unauthenticate();
// fcl.currentUser.loggedIn === null
```

---

### `reauthenticate`

> ⚠️**This method can only be used in web browsers.**

A **convenience method** that calls [`fcl.unauthenticate()`](#unauthenticate) and then [`fcl.authenticate()`](#authenticate) for the current user.

#### Note

⚠️The current user must be authenticated first.

#### Usage

```javascript
import * as fcl from "@onflow/fcl";
// first authenticate to set current user
fcl.authenticate();
// ... somewhere else & sometime later
fcl.reauthenticate();
// logs out user and opens up login/sign-up flow
```

---

### `signUp`

> ⚠️**This method can only be used in web browsers.**

A **convenience method** that calls and is equivalent to [`fcl.authenticate()`](<#authenticate>).

---

### `logIn`

> ⚠️**This method can only be used in web browsers.**

A **convenience method** that calls and is equivalent to [`fcl.authenticate()`](<#authenticate>).

---

### `authz`

A **convenience method** that produces the needed authorization details for the current user to submit transactions to Flow. It defines a signing function that connects to a user's wallet provider to produce signatures to submit transactions.

> 📣 You can replace this function with your own [authorization function](#authorization-function) if needed.

#### Returns

| Type                                        | Description                                                                                              |
| ------------------------------------------- | -------------------------------------------------------------------------------------------------------- |
| [AuthorizationObject](#authorizationobject) | An object containing the necessary details from the current user to authorize a transaction in any role. |

#### Usage

**Note:** The default values for `proposer`, `payer`, and `authorizations` are already `fcl.authz` so there is no need to include these parameters, it is shown only for example purposes. See more on [signing roles](../../../build/basics/transactions.md).

```javascript
import * as fcl from "@onflow/fcl";
// login somewhere before
fcl.authenticate();
// once logged in authz will produce values
console.log(fcl.authz);
// prints {addr, signingFunction, keyId, sequenceNum} from the current authenticated user.

const txId = await fcl.mutate({
  cadence: `
    import Profile from 0xba1132bc08f82fe2
    
    transaction(name: String) {
      prepare(account: AuthAccount) {
        account.borrow<&{Profile.Owner}>(from: Profile.privatePath)!.setName(name)
      }
    }
  `,
  args: (arg, t) => [arg("myName", t.String)],
  proposer: fcl.authz, // optional - default is fcl.authz
  payer: fcl.authz, // optional - default is fcl.authz
  authorizations: [fcl.authz], // optional - default is [fcl.authz]
});
```

---

## Current User

Holds the [current user](#currentuserobject), if set, and offers a set of functions to manage the authentication and authorization of the user.

> ⚠️**The following methods can only be used in web browsers.**

---

### `currentUser.subscribe`

The callback passed to subscribe will be called when the user authenticates and un-authenticates, making it easy to update the UI accordingly.

#### Arguments

| Name       | Type     |                                                                                                                                        |
| ---------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| `callback` | function | The callback will be called with the [current user](#currentuserobject) as the first argument when the current user is set or removed. |

#### Usage

```javascript
import React, { useState, useEffect } from "react";
import * as fcl from "@onflow/fcl";

export function AuthCluster() {
  const [user, setUser] = useState({ loggedIn: null });
  useEffect(() => fcl.currentUser.subscribe(setUser), []); // sets the callback for FCL to use

  if (user.loggedIn) {
    return (
      <div>
        <span>{user?.addr ?? "No Address"}</span>
        <button onClick={fcl.unauthenticate}>Log Out</button> {/* once logged out in setUser(user) will be called */}
      </div>
    );
  } else {
    return (
      <div>
        <button onClick={fcl.logIn}>Log In</button>{" "}
        {/* once logged in setUser(user) will be called */}
        <button onClick={fcl.signUp}>Sign Up</button> {/* once signed up, setUser(user) will be called */}
      </div>
    );
  }
}
```

---

### `currentUser.snapshot`

Returns the [current user](#currentuserobject) object. This is the same object that is set and available on [`fcl.currentUser.subscribe(callback)`](#currentusersubscribe).

#### Usage

```javascript
// returns the current user object
const user = fcl.currentUser.snapshot();

// subscribes to the current user object and logs to console on changes
fcl.currentUser.subscribe(console.log);
```

---

### `currentUser.authenticate`

Equivalent to `fcl.authenticate`.

---

### `currentUser.unauthenticate`

Equivalent to `fcl.unauthenticate`.

---

### `currentUser.authorization`

Equivalent to `fcl.authz`

---

### `currentUser.signUserMessage`

A method to use allowing the user to personally sign data via FCL Compatible Wallets/Services.

> ⚠️ This method requires the current user's wallet to support a signing service endpoint. Currently, only Blocto is compatible with this feature by default.

#### Arguments

| Name  | Type   | Description                       |
| ----- | ------ | --------------------------------- |
| `message` | string **(required)** | A hexadecimal string to be signed |

#### Returns

| Type    | Description                                                                                                                                                                             |
| ------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Array` | An Array of [CompositeSignatures](https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/src/wallet-provider-spec/draft-v2.md#compositesignature): {`addr`, `keyId`, `signature`} |

#### Usage

```javascript
import * as fcl from "@onflow/fcl"

export const signMessage = async () => {
  const MSG = Buffer.from("FOO").toString("hex")
  try {
    return await currentUser.signUserMessage(MSG)
  } catch (error) {
    console.log(error)
  }
}
```

---

## Discovery

### `discovery`

Discovery abstracts away code so that developers don't have to deal with the discovery of Flow compatible wallets, integration, or authentication. Using `discovery` from FCL allows dapps to list and authenticate with wallets while having full control over the UI. Common use cases for this are login or registration pages.

(Alternatively, if you don't need control over your UI you can continue to use the `discovery.wallet` config value documented in the [Quickstart](../../../build/guides/flow-app-quickstart.md) for the simplest configuration.)

> ⚠️**The following methods can only be used in web browsers.**

#### Note

⚠️`discovery.authn.endpoint` value **must** be set in the configuration before calling this method. See [FCL Configuration](#configuration).

### Suggested Configuration

| Environment                     | Example                                              |
| ------------------------------- | ---------------------------------------------------- |
| Mainnet                         | `https://fcl-discovery.onflow.org/api/authn`         |
| Testnet                         | `https://fcl-discovery.onflow.org/api/testnet/authn` |

If the Discovery endpoint is set in config, then you can iterate through authn services and pass the chosen service to [authenticate](#authenticate) to authenticate a user.

#### Usage

```javascript
import "./config"
import { useState, useEffect } from "react"
import * as fcl from "@onflow/fcl"

function Component() {
  const [wallets, setWallets] = useState([])
  useEffect(() => fcl.discovery.authn.subscribe(res => setWallets(res.results)), [])

  return (
    <div>
      {wallets.map((wallet) => (
        <button
          key={wallet.provider.address}
          onClick={() => fcl.authenticate({ service: wallet })}
        >
          Login with {wallet.provider.name}
        </button>
      ))}
    </div>
  )
}
```

### authn

#### More Configuration

By default, limited functionality services or services that require developer registration, like Ledger or Dapper Wallet, require apps to opt-in in order to display to users. To enable opt-in services in an application, use the `discovery.authn.include` property in your configuration with a value of an array of services you'd like your app to opt-in to displaying for users.

```javascript

import { config } from "@onflow/fcl"

config({
  "discovery.authn.endpoint": "https://fcl-discovery.onflow.org/api/testnet/authn", // Endpoint set to Testnet
  "discovery.authn.include": ["0x9d2e44203cb13051"] // Ledger wallet address on Testnet set to be included
})
```

**Opt-In Wallet Addresses on Testnet and Mainnet**

| Service           | Testnet            | Mainnet            |
| ------------------| ------------------ | ------------------ |
| `Dapper Wallet`   | 0x82ec283f88a62e65 | 0xead892083b3e2c6c |
| `Ledger`          | 0x9d2e44203cb13051 | 0xe5cd26afebe62781 |

For more details on wallets, view the [service list here](https://github.com/onflow/fcl-discovery/blob/master/data/services.json).

---

### `discovery.authn.snapshot()`

Return a list of `authn` services.

### `discovery.authn.subscribe(callback)`

The callback sent to `subscribe` will be called with a list of `authn` services.

---

## On-chain Interactions

> 📣 **These methods can be used in browsers and NodeJS.**

These methods allows dapps to interact directly with the Flow blockchain via a set of functions that currently use the [Access Node API](../../../references/run-and-secure/nodes/access-api.mdx).

---

### Query and Mutate Flow with Cadence

If you want to run arbitrary Cadence scripts on the blockchain, these methods offer a convenient way to do so **without having to build, send, and decode interactions**.

### `query`

Allows you to submit scripts to query the blockchain.

#### Options

_Pass in the following as a single object with the following keys.All keys are optional unless otherwise stated._

| Key       | Type                                  | Description                                                                                                                                                                                                            |
| --------- | ------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `cadence` | string **(required)**                 | A valid cadence script.                                                                                                                                                                                                |
| `args`    | [ArgumentFunction](#argumentfunction) | Any arguments to the script if needed should be supplied via a function that returns an array of arguments.                                                                                                            |
| `limit`   | number                                | Compute (Gas) limit for query. Read the [documentation about computation cost](../../../build/basics/fees.md) for information about how computation cost is calculated on Flow. |

#### Returns

| Type | Description                            |
| ---- | -------------------------------------- |
| any  | A JSON representation of the response. |

#### Usage

```javascript
import * as fcl from "@onflow/fcl";

const result = await fcl.query({
  cadence: `
    pub fun main(a: Int, b: Int, addr: Address): Int {
      log(addr)
      return a + b
    }
  `,
  args: (arg, t) => [
    arg(7, t.Int), // a: Int
    arg(6, t.Int), // b: Int
    arg("0xba1132bc08f82fe2", t.Address), // addr: Address
  ],
});
console.log(result); // 13
```

#### Examples

- [Additional Explanation](https://gist.github.com/orodio/3bf977a0bd45b990d16fdc1459b129a2)

---

### `mutate`

Allows you to submit transactions to the blockchain to potentially mutate the state.

⚠️When being used in the browser, `fcl.mutate` uses the built-in `fcl.authz` function to produce the authorization (signatures) for the current user. When calling this method from Node.js, you will need to supply your own custom authorization function.

#### Options

_Pass in the following as a single object with the following keys. All keys are optional unless otherwise stated._

| Key        | Type                                            | Description                                                                                                                                                                                                            |
| ---------- | ----------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `cadence`  | string **(required)**                           | A valid cadence transaction.                                                                                                                                                                                           |
| `args`     | [ArgumentFunction](#argumentfunction)           | Any arguments to the script if needed should be supplied via a function that returns an array of arguments.                                                                                                            |
| `limit`    | number                                          | Compute (Gas) limit for query. Read the [documentation about computation cost](../flow-go-sdk/index.mdx#gas-limit) for information about how computation cost is calculated on Flow. |
| `proposer` | [AuthorizationFunction](#authorization-function) | The authorization function that returns a valid [AuthorizationObject](#authorizationobject) for the [proposer role](#TransactionRolesObject).                                                                                |

#### Returns

| Type   | Description         |
| ------ | ------------------- |
| string | The transaction ID. |

#### Usage

```javascript
import * as fcl from "@onflow/fcl";
// login somewhere before
fcl.authenticate();

const txId = await fcl.mutate({
  cadence: `
    import Profile from 0xba1132bc08f82fe2
    
    transaction(name: String) {
      prepare(account: AuthAccount) {
        account.borrow<&{Profile.Owner}>(from: Profile.privatePath)!.setName(name)
      }
    }
  `,
  args: (arg, t) => [arg("myName", t.String)],
});
```

#### Examples

- [Additional explanation](https://gist.github.com/orodio/3bf977a0bd45b990d16fdc1459b129a2)
- [Custom authorization function](#authorization-function)

---

### `verifyUserSignatures` (Deprecated)

Use `fcl.AppUtils.verifyUserSignatures`

## AppUtils

### `AppUtils.verifyUserSignatures`
A method allowing applications to cryptographically verify a message was signed by a user's private key/s. This is typically used with the response from `currentUser.signUserMessage`.

#### Note

⚠️ `fcl.config.flow.network` or options override is required to use this api. See [FCL Configuration](#configuration).

#### Arguments

| Name                  | Type                  | Description                       |
| --------------------- | --------------------- | --------------------------------- |
| `message`             | string **(required)** | A hexadecimal string              |
| `compositeSignatures` | Array **(required)**  | An Array of `CompositeSignatures` |
| `opts`                | Object **(optional)** | `opts.fclCryptoContract` can be provided to override FCLCryptoContract address for local development                 |

#### Returns

| Type    | Description                  |
| ------- | ---------------------------- |
| Boolean | `true` if verified or `false` |

#### Usage

```javascript
import * as fcl from "@onflow/fcl"

const isValid = await fcl.AppUtils.verifyUserSignatures(
  Buffer.from('FOO').toString("hex"),
  [{f_type: "CompositeSignature", f_vsn: "1.0.0", addr: "0x123", keyId: 0, signature: "abc123"}],
  {fclCryptoContract}
)

```

#### Examples

- [fcl-next-harness](https://github.com/onflow/fcl-next-harness)

---

### `AppUtils.verifyAccountProof`

A method allowing applications to cryptographically prove that a user controls an on-chain account. During user authentication, some FCL compatible wallets will choose to support the FCL `account-proof` service. If a wallet chooses to support this service, and the user approves the signing of message data, they will return `account-proof` data and a signature(s) that can be used to prove a user controls an on-chain account. 
See [proving-authentication](https://github.com/onflow/fcl-js/blob/master/docs/reference/proving-authentication.mdx) documentaion for more details.

⚠️ `fcl.config.flow.network` or options override is required to use this api. See [FCL Configuration](#configuration).

#### Arguments

| Name                  | Type                  | Description                       |
| --------------------- | --------------------- | --------------------------------- |
| `appIdentifier`       | string **(required)** | A hexadecimal string              |
| `accountProofData`    | Object **(required)** | Object with properties: <br/>`address`: `string` - A Flow account address. <br/> `nonce`: `string` - A random string in hexadecimal format (minimum 32 bytes in total, i.e 64 hex characters) <br/> `signatures`: `Object[]` - An array of composite signatures to verify                                                                              |
| `opts`                | Object **(optional)** | `opts.fclCryptoContract` can be provided to overide FCLCryptoContract address for local development                 |

#### Returns

| Type    | Description                  |
| ------- | ---------------------------- |
| Boolean | `true` if verified or `false` |

#### Usage

```javascript
import * as fcl from "@onflow/fcl"

const accountProofData = {
  address: "0x123",
  nonce: "F0123"
  signatures: [{f_type: "CompositeSignature", f_vsn: "1.0.0", addr: "0x123", keyId: 0, signature: "abc123"}],
}

const isValid = await fcl.AppUtils.verifyAccountProof(
  "AwesomeAppId",
  accountProofData,
  {fclCryptoContract}
)

```

#### Examples

- [fcl-next-harness](https://github.com/onflow/fcl-next-harness)

---

### Query and mutate the blockchain with Builders

In some cases, you may want to utilize pre-built interactions or build more complex interactions than what the `fcl.query` and `fcl.mutate` interface offer. To do this, FCL uses a pattern of building up an interaction with a combination of builders, resolving them, and sending them to the chain.

> ⚠️**Recommendation:** Unless you have a specific use case that require usage of these builders, you should be able to achieve most cases with `fcl.query({...options}` or `fcl.mutate({...options})`

### `send`

Sends arbitrary scripts, transactions, and requests to Flow.

This method consumes an array of [builders](#builders) that are to be resolved and sent. The builders required to be included in the array depend on the [interaction](#interaction) that is being built.

#### Note

⚠️Must be used in conjuction with [`fcl.decode(response)`](<#decode>) to get back correct keys and all values in JSON.

#### Arguments

| Name       | Type                    | Description            |
| ---------- | ----------------------- | ---------------------- |
| `builders` | [[Builders](#builders)] | See builder functions. |

#### Returns

| Type                              | Description                                                                                                                                       |
| --------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |
| [ResponseObject](#responseobject) | An object containing the data returned from the chain. Should always be decoded with `fcl.decode()` to get back appropriate JSON keys and values. |

#### Usage

```javascript
import * as fcl from "@onflow/fcl";

// a script only needs to resolve the arguments to the script
const response = await fcl.send([fcl.script`${script}`, fcl.args(args)]);
// note: response values are encoded, call await fcl.decode(response) to get JSON

// a transaction requires multiple 'builders' that need to be resolved prior to being sent to the chain - such as setting the authorizations.
const response = await fcl.send([
  fcl.transaction`
    ${transaction}
    `,
  fcl.args(args),
  fcl.proposer(proposer),
  fcl.authorizations(authorizations),
  fcl.payer(payer),
  fcl.limit(9999),
]);
// note: response contains several values (Cad)
```

---

### `decode`

Decodes the response from `fcl.send()` into the appropriate JSON representation of any values returned from Cadence code.

#### Note

📣 To define your own decoder, see [`tutorial`](https://github.com/onflow/flow-js-sdk/tree/master/packages/sdk/src/decode).

#### Arguments

| Name       | Type                              | Description                                            |
| ---------- | --------------------------------- | ------------------------------------------------------ |
| `response` | [ResponseObject](#responseobject) | Should be the response returned from `fcl.send([...])` |

#### Returns

| Type | Description                                                                                                                                                                    |
| ---- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| any  | A JSON representation of the raw string response depending on the cadence code executed.<br/> The return value can be a single value and type or an object with multiple types. |

#### Usage

```javascript
import * as fcl from "@onflow/fcl";

// simple script to add 2 numbers
const response = await fcl.send([
  fcl.script`
        pub fun main(int1: Int, int2: Int): Int {
            return int1 + int2
        }
    `,
  fcl.args([
    fcl.arg(1, fcl.t.Int),
    fcl.arg(2, fcl.t.Int)
  ]),
]);

const decoded = await fcl.decode(response);

assert(3 === decoded);
assert(typeof decoded === "number");
```

---

## Builders

These methods fill out various portions of a transaction or script template in order to
build, resolve, and send it to the blockchain. A valid populated template is referred to as an [Interaction](#interaction).

⚠️**These methods must be used with `fcl.send([...builders]).then(fcl.decode)`**

### Query Builders

### `getAccount`

A builder function that returns the interaction to get an account by address.

⚠️Consider using the pre-built interaction [`fcl.account(address)`](<#account>) if you do not need to pair with any other builders.

#### Arguments

| Name      | Type                | Description                                                                        |
| --------- | ------------------- | ---------------------------------------------------------------------------------- |
| `address` | [Address](#address) | Address of the user account with or without a prefix (both formats are supported). |

#### Returns after decoding

| Type                      | Description                              |
| ------------------------- | ---------------------------------------- |
| [AccountObject](#account) | A JSON representation of a user account. |

#### Usage

```javascript
import * as fcl from "@onflow/fcl";

// somewhere in an async function
// fcl.account is the same as this function
const getAccount = async (address) => {
  const account = await fcl.send([fcl.getAccount(address)]).then(fcl.decode);
  return account;
};
```

---

### `getBlock`

A builder function that returns the interaction to get the latest block.

📣 Use with `fcl.atBlockId()` and `fcl.atBlockHeight()` when building the interaction to get information for older blocks.

⚠️Consider using the pre-built interaction [`fcl.getblock(isSealed)`](#getblock) if you do not need to pair with any other builders.

#### Arguments

| Name       | Type    | Default | Description                                                                    |
| ---------- | ------- | ------- | ------------------------------------------------------------------------------ |
| `isSealed` | boolean | false   | If the latest block should be sealed or not. See [block states](#interaction). |

#### Returns after decoding

| Type                          | Description                                           |
| ----------------------------- | ----------------------------------------------------- |
| [BlockObject](#blockobject) | The latest block if not used with any other builders. |

#### Usage

```javascript
import * as fcl from "@onflow/fcl";

const latestSealedBlock = await fcl
  .send([
    fcl.getBlock(true), // isSealed = true
  ])
  .then(fcl.decode);
```

---

### `atBlockHeight`

A builder function that returns a partial interaction to a block at a specific height.

⚠️Use with other interactions like [`fcl.getBlock()`](#getblock) to get a full interaction at the specified block height.

#### Arguments

| Name          | Type   | Description                                            |
| ------------- | ------ | ------------------------------------------------------ |
| `blockHeight` | number | The height of the block to execute the interaction at. |

#### Returns

| Type                                | Description                                                                                                 |
| ----------------------------------- | ----------------------------------------------------------------------------------------------------------- |
| [Partial Interaction](#interaction) | A partial interaction to be paired with another interaction such as `fcl.getBlock()` or `fcl.getAccount()`. |

#### Usage

```javascript
import * as fcl from "@onflow/fcl";

await fcl.send([fcl.getBlock(), fcl.atBlockHeight(123)]).then(fcl.decode);
```

---

### `atBlockId`

A builder function that returns a partial interaction to a block at a specific block ID.

⚠️Use with other interactions like [`fcl.getBlock()`](#getblock) to get a full interaction at the specified block ID.

#### Arguments

| Name      | Type   | Description                                        |
| --------- | ------ | -------------------------------------------------- |
| `blockId` | string | The ID of the block to execute the interaction at. |

#### Returns

| Type                                | Description                                                                                                 |
| ----------------------------------- | ----------------------------------------------------------------------------------------------------------- |
| [Partial Interaction](#interaction) | A partial interaction to be paired with another interaction such as `fcl.getBlock()` or `fcl.getAccount()`. |

#### Usage

```javascript
import * as fcl from "@onflow/fcl";

await fcl.send([fcl.getBlock(), fcl.atBlockId("23232323232")]).then(fcl.decode);
```

---

### `getBlockHeader`

A builder function that returns the interaction to get a block header.

📣 Use with `fcl.atBlockId()` and `fcl.atBlockHeight()` when building the interaction to get information for older blocks.

#### Returns after decoding

| Type                                    | Description                                                  |
| --------------------------------------- | ------------------------------------------------------------ |
| [BlockHeaderObject](#blockheaderobject) | The latest block header if not used with any other builders. |

#### Usage

```javascript
import * as fcl from "@onflow/fcl";

const latestBlockHeader = await fcl
  .send([fcl.getBlockHeader()])
  .then(fcl.decode);
```

### `getEventsAtBlockHeightRange`

A builder function that returns all instances of a particular event (by name) within a height range.

⚠️The block range provided must be from the current spork.

⚠️The block range provided must be 250 blocks or lower per request.

#### Arguments

| Name              | Type                    | Description                                                      |
| ----------------- | ----------------------- | ---------------------------------------------------------------- |
| `eventName`       | [EventName](#eventname) | The name of the event.                                           |
| `fromBlockHeight` | number                  | The height of the block to start looking for events (inclusive). |
| `toBlockHeight`   | number                  | The height of the block to stop looking for events (inclusive).  |

#### Returns after decoding

| Type                          | Description                                    |
| ----------------------------- | ---------------------------------------------- |
| [[EventObject]](#event-object) | An array of events that matched the eventName. |

#### Usage

```javascript
import * as fcl from "@onflow/fcl";

const events = await fcl
  .send([
    fcl.getEventsAtBlockHeightRange(
      "A.7e60df042a9c0868.FlowToken.TokensWithdrawn",
      35580624,
      35580624
    ),
  ])
  .then(fcl.decode);
```

---

### `getEventsAtBlockIds`

A builder function that returns all instances of a particular event (by name) within a set of blocks, specified by block ids.

⚠️The block range provided must be from the current spork.

#### Arguments

| Name        | Type                    | Description                               |
| ----------- | ----------------------- | ----------------------------------------- |
| `eventName` | [EventName](#eventname) | The name of the event.                    |
| `blockIds`  | number                  | The ids of the blocks to scan for events. |

#### Returns after decoding

| Type                          | Description                                    |
| ----------------------------- | ---------------------------------------------- |
| [[EventObject]](#event-object) | An array of events that matched the eventName. |

#### Usage

```javascript
import * as fcl from "@onflow/fcl";

const events = await fcl
  .send([
    fcl.getEventsAtBlockIds("A.7e60df042a9c0868.FlowToken.TokensWithdrawn", [
      "c4f239d49e96d1e5fbcf1f31027a6e582e8c03fcd9954177b7723fdb03d938c7",
      "5dbaa85922eb194a3dc463c946cc01c866f2ff2b88f3e59e21c0d8d00113273f",
    ]),
  ])
  .then(fcl.decode);
```

---

### `getCollection`

A builder function that returns all a collection containing a list of transaction ids by its collection id.

⚠️The block range provided must be from the current spork. All events emitted during past sporks is current unavailable.

#### Arguments

| Name           | Type   | Description               |
| -------------- | ------ | ------------------------- |
| `collectionID` | string | The id of the collection. |

#### Returns after decoding

| Type                                  | Description                                                                       |
| ------------------------------------- | --------------------------------------------------------------------------------- |
| [CollectionObject](#collectionobject) | An object with the id and a list of transactions within the requested collection. |

#### Usage

```javascript
import * as fcl from "@onflow/fcl";

const collection = await fcl
  .send([
    fcl.getCollection(
      "cccdb0c67d015dc7f6444e8f62a3244ed650215ed66b90603006c70c5ef1f6e5"
    ),
  ])
  .then(fcl.decode);
```

---

### `getTransactionStatus`

A builder function that returns the status of transaction in the form of a [TransactionStatusObject](#transactionstatusobject).

⚠️The transactionID provided must be from the current spork.

📣 Considering [subscribing to the transaction from `fcl.tx(id)`](#tx) instead of calling this method directly.

#### Arguments

| Name            | Type   | Description                                                                                                                           |
| --------------- | ------ | ------------------------------------------------------------------------------------------------------------------------------------- |
| `transactionId` | string | The transactionID returned when submitting a transaction. Example: `9dda5f281897389b99f103a1c6b180eec9dac870de846449a302103ce38453f3` |

#### Returns after decoding

#### Returns

| Type                                                | Description                                            |
| --------------------------------------------------- | ------------------------------------------------------ |
| [TransactionStatusObject](#transactionstatusobject) | Object representing the result/status of a transaction |

#### Usage

```javascript
import * as fcl from "@onflow/fcl";

const status = await fcl
  .send([
    fcl.getTransactionStatus(
      "9dda5f281897389b99f103a1c6b180eec9dac870de846449a302103ce38453f3"
    ),
  ])
  .then(fcl.decode);
```

---

### `getTransaction`

A builder function that returns a [transaction object](#transactionobject) once decoded.

⚠️The transactionID provided must be from the current spork.

📣 Considering using [`fcl.tx(id).onceSealed()`](#tx) instead of calling this method directly.

#### Arguments

| Name            | Type   | Description                                                                                                                           |
| --------------- | ------ | ------------------------------------------------------------------------------------------------------------------------------------- |
| `transactionId` | string | The transactionID returned when submitting a transaction. Example: `9dda5f281897389b99f103a1c6b180eec9dac870de846449a302103ce38453f3` |

#### Returns after decoding

#### Returns

| Type                                    | Description                                                    |
| --------------------------------------- | -------------------------------------------------------------- |
| [TransactionObject](#transactionobject) | An full transaction object containing a payload and signatures |

#### Usage

```javascript
import * as fcl from "@onflow/fcl";

const tx = await fcl
  .send([
    fcl.getTransaction(
      "9dda5f281897389b99f103a1c6b180eec9dac870de846449a302103ce38453f3"
    ),
  ])
  .then(fcl.decode);
```

---

### `getEvents` (Deprecated)

Use [`fcl.getEventsAtBlockHeightRange`](#geteventsatblockheightrange) or [`fcl.getEventsAtBlockIds`](#geteventsatblockids).

---

### `getLatestBlock` (Deprecated)

Use [`fcl.getBlock`](#getblock).

---

### `getBlockById` (Deprecated)

Use [`fcl.getBlock`](#getblock) and [`fcl.atBlockId`](#atblockid).

---

### `getBlockByHeight` (Deprecated)

Use [`fcl.getBlock`](#getblock) and [`fcl.atBlockHeight`](#atblockheight).

---

### Utility Builders

These builders are used to compose interactions with other builders such as scripts and transactions.

> ⚠️**Recommendation:** Unless you have a specific use case that require usage of these builders, you should be able to achieve most cases with `fcl.query({...options}` or `fcl.mutate({...options})`

### `arg`

A utility builder to be used with `fcl.args[...]` to create FCL supported arguments for interactions.

#### Arguments

| Name    | Type             | Description                                               |
| ------- | ---------------- | --------------------------------------------------------- |
| `value` | any              | Any value that you are looking to pass to other builders. |
| `type`  | [FType](#ftype)  | A type supported by Flow.                                 |

#### Returns

| Type                              | Description                         |
| --------------------------------- | ----------------------------------- |
| [ArgumentObject](#argumentobject) | Holds the value and type passed in. |

#### Usage

```javascript
import * as fcl from "@onflow/fcl";

await fcl
  .send([
    fcl.script`
      pub fun main(a: Int, b: Int): Int {
        return a + b
      }
    `,
    fcl.args([
      fcl.arg(5, fcl.t.Int), // a
      fcl.arg(4, fcl.t.Int), // b
    ]),
  ])
  .then(fcl.decode);
```

---

### `args`

A utility builder to be used with other builders to pass in arguments with a value and supported type.

#### Arguments

| Name   | Type                                  | Description                                                           |
| ------ | ------------------------------------- | --------------------------------------------------------------------- |
| `args` | [[Argument Objects]](#argumentobject) | An array of arguments that you are looking to pass to other builders. |

#### Returns

| Type                                | Description                                                                                                         |
| ----------------------------------- | ------------------------------------------------------------------------------------------------------------------- |
| [Partial Interaction](#interaction) | An interaction that contains the arguments and types passed in. This alone is a partial and incomplete interaction. |

#### Usage

```javascript
import * as fcl from "@onflow/fcl";

await fcl
  .send([
    fcl.script`
      pub fun main(a: Int, b: Int): Int {
        return a + b
      }
    `,
    fcl.args([
      fcl.arg(5, fcl.t.Int), // a
      fcl.arg(4, fcl.t.Int), // b
    ]),
  ])
  .then(fcl.decode); // 9
```

---

### Template Builders

> ⚠️**_Recommended:_** The following functionality is simplified by [`fcl.query({...options}`](#query) or [`fcl.mutate({...options})`](#mutate) and is reccomended to use over the functions below.

### `script`

A template builder to use a Cadence script for an interaction.

📣 Use with `fcl.args(...)` to pass in arguments dynamically.

#### Arguments

| Name   | Type   | Description                     |
| ------ | ------ | ------------------------------- |
| `CODE` | string | Should be valid Cadence script. |

#### Returns

| Type                        | Description                                   |
| --------------------------- | --------------------------------------------- |
| [Interaction](#interaction) | An interaction containing the code passed in. |

#### Usage

```javascript
import * as fcl from "@onflow/fcl";

const code = `
  pub fun main(): Int {
    return 5 + 4
  }
`;
const answer = await fcl.send([fcl.script(code)]).then(fcl.decode);
console.log(answer); // 9
```

---

### `transaction`

A template builder to use a Cadence transaction for an interaction.

⚠️Must be used with `fcl.payer`, `fcl.proposer`, `fcl.authorizations` to produce a valid interaction before sending to the chain.

📣 Use with `fcl.args[...]` to pass in arguments dynamically.

#### Arguments

| Name   | Type   | Description                            |
| ------ | ------ | -------------------------------------- |
| `CODE` | string | Should be valid a Cadence transaction. |

#### Returns

| Type                                | Description                                                                                                                    |
| ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| [Partial Interaction](#interaction) | An partial interaction containing the code passed in. Further builders are required to complete the interaction - see warning. |

#### Usage

```javascript
import * as fcl from "@onflow/fcl";

const code = `
  pub fun main(): Int {
    return 5 + 4
  }
`;
const answer = await fcl.send([fcl.script(code)]).then(fcl.decode);
console.log(answer); // 9
```

---

## Pre-built Interactions

These functions are abstracted short hand ways to skip the send and decode steps of sending an interaction to the chain. More pre-built interactions are coming soon.

### `account`

A pre-built interaction that returns the details of an account from their public address.

#### Arguments

| Name      | Type                | Description                                                                        |
| --------- | ------------------- | ---------------------------------------------------------------------------------- |
| `address` | [Address](#address) | Address of the user account with or without a prefix (both formats are supported). |

#### Returns

| Type                            | Description                              |
| ------------------------------- | ---------------------------------------- |
| [AccountObject](#accountobject) | A JSON representation of a user account. |

#### Usage

```javascript
import * as fcl from "@onflow/fcl";
const account = await fcl.account("0x1d007d755706c469");
```

---

### `block`

A pre-built interaction that returns the latest block (optionally sealed or not), by id, or by height.

#### Arguments

| Name     | Type    | Default | Description                                                                    |
| -------- | ------- | ------- | ------------------------------------------------------------------------------ |
| `sealed` | boolean | false   | If the latest block should be sealed or not. See [block states](#interaction). |
| `id`     | string  |         | ID of block to get.                                                            |
| `height` | int     |         | Height of block to get.                                                        |

#### Returns

| Type                        | Description                       |
| --------------------------- | --------------------------------- |
| [BlockObject](#blockobject) | A JSON representation of a block. |

#### Usage

```javascript
import * as fcl from "@onflow/fcl";
await fcl.block() // get latest finalized block
await fcl.block({sealed: true}) // get latest sealed block
await fcl.block({id: '0b1bdfa9ddaaf31d53c584f208313557d622d1fedee1586ffc38fb5400979faa'}) // get block by id
await fcl.block({height: 56481953}) // get block by height
```

---

### `latestBlock` (Deprecated)

A pre-built interaction that returns the latest block (optionally sealed or not).

#### Arguments

| Name       | Type    | Default | Description                                                                    |
| ---------- | ------- | ------- | ------------------------------------------------------------------------------ |
| `isSealed` | boolean | false   | If the latest block should be sealed or not. See [block states](#interaction). |

#### Returns

| Type                        | Description                       |
| --------------------------- | --------------------------------- |
| [BlockObject](#blockobject) | A JSON representation of a block. |

#### Usage

```javascript
import * as fcl from "@onflow/fcl";
const latestBlock = await fcl.latestBlock();
```

---

## Transaction Status Utility

### `tx`

A utility function that lets you set the transaction to get subsequent status updates (via polling) and the finalized result once available.
⚠️The poll rate is set at `2500ms` and will update at that interval until transaction is sealed.

#### Arguments

| Name            | Type   | Description             |
| --------------- | ------ | ----------------------- |
| `transactionId` | string | A valid transaction id. |

#### Returns

| Name              | Type     | Description                                                                                               |
| ----------------- | -------- | --------------------------------------------------------------------------------------------------------- |
| `snapshot()`      | function | Returns the current state of the transaction.                                                             |
| `subscribe(cb)`   | function | Calls the `cb` passed in with the new transaction on a status change.                                     |
| `onceFinalized()` | function | Provides the transaction once status `2` is returned. See [Tranasaction Statuses](#transaction-statuses). |
| `onceExecuted()`  | function | Provides the transaction once status `3` is returned. See [Tranasaction Statuses](#transaction-statuses). |
| `onceSealed()`    | function | Provides the transaction once status `4` is returned. See [Tranasaction Statuses](#transaction-statuses). |

#### Usage

```javascript
import * as fcl from "@onflow/fcl";

const [txStatus, setTxStatus] = useState(null);
useEffect(() => fcl.tx(txId).subscribe(setTxStatus));
```

---

## Event Polling Utility

### `events`

A utility function that lets you set the transaction to get subsequent status updates (via polling) and the finalized result once available.
⚠️The poll rate is set at `10000ms` and will update at that interval for getting new events.


Note:
⚠️`fcl.eventPollRate` value **could** be set to change the polling rate of all events subcribers, check [FCL Configuration](#configuration) for guide.

#### Arguments
| Name        | Type   | Description         |
| ----------- | ------ | ------------------- |
| `eventName` | string | A valid event name. |

#### Returns

| Name            | Type     | Description                                  |
| --------------- | -------- | -------------------------------------------- |
| `subscribe(cb)` | function | Calls the `cb` passed in with the new event. |

#### Usage

```javascript
import * as fcl from "@onflow/fcl";
// in some react component
fcl.events(eventName).subscribe((event) => {
  console.log(event)
})
```

#### Examples

- [Flow-view-source example](https://github.com/orodio/flow-view-source/blob/master/src/pages/event.comp.js)

---

## Types, Interfaces, and Definitions

---

### `Builders`

Builders are modular functions that can be coupled together with `fcl.send([...builders])` to create an [Interaction](#interaction). The builders needed to create an interaction depend on the script or transaction that is being sent.

---

### `Interaction`

An interaction is an object containing the information to perform an action on chain.This object is populated through builders and converted into the approriate access node API call. See the interaction object [here](https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/src/interaction/interaction.js). A 'partial' interaction is an interaction object that does not have sufficient information to the intended on-chain action. Multiple partial interactions (through builders) can be coupled to create a complete interaction.

---

### `CurrentUserObject`

| Key         | Value Type          | Default   | Description                                                                                                                                                                                                                                                                                    |
| ----------- | ------------------- | --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `addr`      | [Address](#address) | `null`    | The public address of the current user                                                                                                                                                                                                                                                         |
| `cid`       | string              | `null`    | Allows wallets to specify a [content identifier](https://docs.ipfs.io/concepts/content-addressing/) for user metadata.                                                                                                                                                                         |
| `expiresAt` | number              | `null`    | Allows wallets to specify a time-frame for a valid session.                                                                                                                                                                                                                                    |
| `f_type`    | string              | `'USER'`  | A type identifier used internally by FCL.                                                                                                                                                                                                                                                      |
| `f_vsn`     | string              | `'1.0.0'` | FCL protocol version.                                                                                                                                                                                                                                                                          |
| `loggedIn`  | boolean             | `null`    | If the user is logged in.                                                                                                                                                                                                                                                                      |
| `services`  | [ServiceObject]     | `[]`      | A list of trusted services that express ways of interacting with the current user's identity, including means to further discovery, [authentication, authorization](https://gist.github.com/orodio/a74293f65e83145ec8b968294808cf35#you-know-who-the-user-is), or other kinds of interactions. |

---

### `AuthorizationObject`

This type conforms to the interface required for FCL to authorize transaction on behalf o the current user.

| Key               | Value Type          | Description                                                                                       |
| ----------------- | ------------------- | ------------------------------------------------------------------------------------------------- |
| `addr`            | [Address](#address) | The address of the authorizer                                                                     |
| `signingFunction` | function            | A function that allows FCL to sign using the authorization details and produce a valid signature. |
| `keyId`           | number              | The index of the key to use during authorization. (Multiple keys on an account is possible).      |
| `sequenceNum`     | number              | A number that is incremented per transaction using they keyId.                                    |

---

### `SignableObject`

An object that contains all the information needed for FCL to sign a message with the user's signature.

| Key         | Value Type          | Description                                                                                          |
| ----------- | ------------------- | ---------------------------------------------------------------------------------------------------- |
| `addr`      | [Address](#address) | The address of the authorizer                                                                        |
| `keyId`     | number              | The index of the key to use during authorization. (Multiple keys on an account is possible).         |
| `signature` | function            | A [SigningFunction](#signing-function) that can produce a valid signature for a user from a message. |

---

### `AccountObject`

The JSON representation of an account on the Flow blockchain.

| Key         | Value Type                    | Description                                                                                |
| ----------- | ----------------------------- | ------------------------------------------------------------------------------------------ |
| `address`   | [Address](#address)           | The address of the account                                                                 |
| `balance`   | number                        | The FLOW balance of the account in 10^8.                                                   |
| `code`      | [Code](#code)                 | The code of any Cadence contracts stored in the account.                                   |
| `contracts` | Object: [Contract](#contract) | An object with keys as the contract name deployed and the value as the the cadence string. |
| `keys`      | [[KeyObject]](#keyobject)     | Any contracts deployed to this account.                                                    |

---

### `Address`

| Value Type        | Description                                                                                                                     |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| string(formatted) | A valid Flow address should be 16 characters in length. <br/>A `0x` prefix is optional during inputs. <br/>eg. `f8d6e0586b0a20c1` |

---

### `ArgumentObject`

An argument object created by `fcl.arg(value,type)`

| Key     | Value Type      | Description                                       |
| ------- | --------------- | ------------------------------------------------- |
| `value` | any             | Any value to be used as an argument to a builder. |
| `xform` | [FType](#ftype) | Any of the supported types on Flow.               |

---

### `ArgumentFunction`

An function that takes the `fcl.arg` function and fcl types `t` and returns an array of `fcl.arg(value,type)`.

`(arg, t) => Array<Arg>`

| Parameter Name | Value Type       | Description                                                               |
| -------------- | ---------------- | ------------------------------------------------------------------------- |
| `arg`          | function         | A function that returns an [ArgumentObject](#argumentobject) - `fcl.arg`. |
| `t`            | [FTypes](#ftype) | An object with acccess to all of the supported types on Flow.             |

**Returns**

| Value Type   | Description          |
| ------------ | -------------------- |
| `[fcl.args]` | Array of `fcl.args`. |

---

### `Authorization Function`

An authorization function must produce the information of the user that is going to sign and a signing function to use the information to produce a signature.

⚠️This function is always async.

📣 By default FCL exposes `fcl.authz` that produces the authorization object for the current user (given they are signed in and only on the browser). Replace this with your own function that conforms to this interface to use it wherever an authorization object is needed.

| Parameter Name | Value Type                      | Description                                    |
| -------------- | ------------------------------- | ---------------------------------------------- |
| `account`      | [AccountObject](#accountobject) | The account of the user that is going to sign. |

**Returns**

| Value Type                                           | Description                                                                                   |
| ---------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| ```Promise<[AuthorizationObject](#authorizationobject)>``` | The object that contains all the information needed by FCL to authorize a user's transaction. |

#### Usage

---

```javascript
const authorizationFunction = async (account) => {
    // authorization function need to return an account
    const { address, keys } = account
    const tempId = `${address}-${keys[process.env.minterAccountIndex]}`;
    const keyId = Number(KEY_ID);
    let signingFunction = async signable => {
      return {
        keyId,
        addr: fcl.withPrefix(address),
        signature: sign(process.env.FLOW_MINTER_PRIVATE_KEY, signable.message), // signing function, read below
      }
    }
    return {
    ...account,
    address,
    keyId,
    tempId,
    signingFunction,
  }
```

- [Detailed explanation](https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/src/wallet-provider-spec/authorization-function.md)

---

### `Signing Function`

Consumes a payload and produces a signature for a transaction.

⚠️This function is always async.

📣 Only write your own signing function if you are writing your own custom authorization function.

#### Payload

Note: These values are destructed from the payload object in the first argument.

| Parameter Name | Value Type | Description                                                                                                                          |
| -------------- | ---------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| `message`      | string     | The encoded string which needs to be used to produce the signature.                                                                  |
| `addr`         | string     | The encoded string which needs to be used to produce the signature.                                                                  |
| `keyId`        | string     | The encoded string which needs to be used to produce the signature.                                                                  |
| `roles`        | string     | The encoded string which needs to be used to produce the signature.                                                                  |
| `voucher`      | object     | The raw transactions information, can be used to create the message for additional safety and lack of trust in the supplied message. |

**Returns**

| Value Type                                 | Description                                                                                   |
| ------------------------------------------ | --------------------------------------------------------------------------------------------- |
| ```Promise<[SignableObject](#signableobject)>``` | The object that contains all the information needed by FCL to authorize a user's transaction. |

#### Usage

```javascript
import * as fcl from "@onflow/fcl";
import { ec as EC } from "elliptic";
import { SHA3 } from "sha3";
const ec: EC = new EC("p256");

const produceSignature = (privateKey, msg) => {
  const key = ec.keyFromPrivate(Buffer.from(privateKey, "hex"));
  const sig = key.sign(this.hashMsg(msg));
  const n = 32;
  const r = sig.r.toArrayLike(Buffer, "be", n);
  const s = sig.s.toArrayLike(Buffer, "be", n);
  return Buffer.concat([r, s]).toString("hex");
};

const signingFunction = ({
  message, // The encoded string which needs to be used to produce the signature.
  addr, // The address of the Flow Account this signature is to be produced for.
  keyId, // The keyId of the key which is to be used to produce the signature.
  roles: {
    proposer, // A Boolean representing if this signature to be produced for a proposer.
    authorizer, // A Boolean representing if this signature to be produced for a authorizer.
    payer, // A Boolean representing if this signature to be produced for a payer.
  },
  voucher, // The raw transactions information, can be used to create the message for additional safety and lack of trust in the supplied message.
}) => {
  return {
    addr, // The address of the Flow Account this signature was produced for.
    keyId, // The keyId for which key was used to produce the signature.
    signature: produceSignature(message), // The hex encoded string representing the signature of the message.
  };
};
```

#### Examples:

- [Detailed explanation](https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/src/wallet-provider-spec/authorization-function.md)

---

### `TransactionObject`

| Key                  | Value Type                            | Description                                                                                                                                                                                   |
| -------------------- | ------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `args`               | object                                     | A list of encoded Cadence values passed into this transaction.  These have not been decoded by the JS-SDK.                                                       |
| `authorizers`        | [\[Address\]](#address)               | A list of the accounts that are authorizing this transaction to mutate to their on-chain account state.  [See more here](../../../build/basics/transactions.md#signer-roles). |
| `envelopeSignatures` | [\[SignableObject\]](#signableobject) | A list of signatures generated by the payer role. [See more here](../../../build/basics/transactions.md#anatomy-of-a-transaction).                                            |
| `gasLimit`           | number                                | The maximum number of computational units that can be used to execute this transaction.  [See more here](../../../build/basics/fees.md).                                  |
| `payer`              | [Address](#address)                   | The account that pays the fee for this transaction.  [See more here](../../../build/basics/transactions.md#signer-roles).                                                     |
| `payloadSignatures`  | [\[SignableObject\]](#signableobject) | A list of signatures generated by the proposer and authorizer roles. [See more here](../../../build/basics/transactions.md#anatomy-of-a-transaction).                         |
| `proposalKey`        | [\[ProposalKey\]](#proposalkeyobject) | The account key used to propose this transaction                                                                                                                                              |
| `referenceBlockId`   | string                                | A reference to the block used to calculate the expiry of this transaction.                                                                                                                    |
| `script`             | string                                | The UTF-8 encoded Cadence source code that defines the execution logic for this transaction                                                                                                   |

### `TransactionRolesObject`

| Key Name   | Value Type | Description                                                                |
| ---------- | ---------- | -------------------------------------------------------------------------- |
| proposer   | boolean    | A Boolean representing if this signature to be produced for a proposer.    |
| authorizer | boolean    | A Boolean representing if this signature to be produced for an authorizer. |
| payer      | boolean    | A Boolean representing if this signature to be produced for a payer.       |

For more on what each transaction role means, see [singing roles](../../../build/basics/transactions.md#signer-roles).

### `TransactionStatusObject`

| Key                     | Value Type                                       | Description                                                     |
| ------------------------ | ------------------------------------------ | --------------------------------------------------------------- |
| `blockId`                | string                                     | ID of the block that contains the transaction.                  |
| `events`                 | [[EventObject]](#event-object)             | An array of events that were emitted during the transaction.    |
| `status`                 | [TransactionStatus](#transaction-statuses) | The status of the transaction on the blockchain.                |
| `statusString` | [TransactionStatus](#transaction-statuses) | The `status` as as descriptive text (e.g. "FINALIZED").         |
| `errorMessage`           | string                                     | An error message if it exists. Default is an empty string `''`. |
| `statusCode`             | number                                     | The pass/fail status. 0 indicates the transaction succeeded, 1 indicates it failed. |

### `EventName`

| Value Type        | Description                                                                                                                        |
| ----------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| string(formatted) | A event name in Flow must follow the format `A.{AccountAddress}.{ContractName}.{EventName}` <br/>eg. `A.ba1132bc08f82fe2.Debug.Log` |

### `Contract`

| Value Type        | Description                                          |
| ----------------- | ---------------------------------------------------- |
| string(formatted) | A formatted string that is a valid cadence contract. |

### `KeyObject`

This is the JSON representation of a key on the Flow blockchain.

| Key              | Value Type | Description                                                                              |
| ---------------- | ---------- |------------------------------------------------------------------------------------------|
| `index`          | number     | The address of the account                                                               |
| `publicKey`      | string     | The public portion of a public/private key pair                                          |
| `signAlgo`       | number     | An index referring to one of `ECDSA_P256` or `ECDSA_secp256k1`                           |
| `hashAlgo`       | number     | An index referring to one of `SHA2_256` or `SHA3_256`                                    |
| `weight`         | number     | A number between 1 and 1000 indicating the relative weight to other keys on the account. |
| `sequenceNumber` | number     | This number is incremented for every transaction signed using this key.                  |
| `revoked`        | boolean    | If this key has been disabled for use.                                                   |

### `ProposalKeyObject`

ProposalKey is the account key used to propose this transaction.

A proposal key references a specific key on an account, along with an up-to-date sequence number for that key. This sequence number is used to prevent replay attacks.

You can find more information about sequence numbers [here](../../../build/basics/transactions.md#sequence-numbers)

 Key              | Value Type | Description                                                                              |
| ---------------- | ---------- | ---------------------------------------------------------------------------------------- |
| `address`          | [Address](#address)     | The address of the account                                                               |
| `keyIndex`      | number     | The index of the account key being referenced                                                |
| `sequenceNumber`       | number     | The sequence number associated with this account key for this transaction                           |

### `BlockObject`

The JSON representation of a key on the Flow blockchain.

| Key                    | Value Type                                                | Description                                                |
| ---------------------- | --------------------------------------------------------- | ---------------------------------------------------------- |
| `id`                   | string                                                    | The id of the block.                                       |
| `parentId`             | string                                                    | The id of the parent block.                                |
| `height`               | number                                                    | The height of the block.                                   |
| `timestamp`            | object                                                    | Contains time related fields.                              |
| `collectionGuarantees` | [[CollectionGuaranteeObject](#collectionguaranteeobject)] | Contains the ids of collections included in the block.     |
| `blockSeals`           | [SealedBlockObject]                                       | The details of which nodes executed and sealed the blocks. |
| `signatures`           | Uint8Array([numbers])                                     | All signatures.                                            |

### `BlockHeaderObject`

The subset of the [BlockObject](#blockobject) containing only the header values of a block.

| Key         | Value Type | Description                   |
| ----------- | ---------- | ----------------------------- |
| `id`        | string     | The id of the block.          |
| `parentId`  | string     | The id of the parent block.   |
| `height`    | number     | The height of the block.      |
| `timestamp` | object     | Contains time related fields. |

### `CollectionGuaranteeObject`

A collection that has been included in a block.

| Key            | Value Type        | Description          |
| -------------- | ----------------- | -------------------- |
| `collectionId` | string            | The id of the block. |
| `signatures`   | [SignatureObject] | All signatures.      |

### `CollectionObject`

A collection is a list of transactions that are contained in the same block.

| Key              | Value Type | Description                                             |
| ---------------- | ---------- | ------------------------------------------------------- |
| `id`             | string     | The id of the collection.                               |
| `transactionIds` | [string]   | The ids of the transactions included in the collection. |

### `ResponseObject`

The format of all responses in FCL returned from `fcl.send(...)`. For full details on the values and descriptions of the keys, view [here](https://github.com/onflow/flow-js-sdk/tree/master/packages/sdk/src/response).

| Key                 |
| ------------------- |
| `tag`               |
| `transaction`       |
| `transactionStatus` |
| `transactionId`     |
| `encodedData`       |
| `events`            |
| `account`           |
| `block`             |
| `blockHeader`       |
| `latestBlock`       |
| `collection`        |

### `Event Object`

| Key                | Value Type              | Description                                                                                           |
| ------------------ | ----------------------- | ----------------------------------------------------------------------------------------------------- |
| `blockId`          | string                  | ID of the block that contains the event.                                                              |
| `blockHeight`      | number                  | Height of the block that contains the event.                                                          |
| `blockTimestamp`   | string                  | The timestamp of when the block was sealed in a `DateString` format. eg. `'2021-06-25T13:42:04.227Z'` |
| `type`             | [EventName](#eventname) | A string containing the event name.                                                                   |
| `transactionId`    | string                  | Can be used to query transaction information, eg. via a Flow block explorer.                          |
| `transactionIndex` | number                  | Used to prevent replay attacks.                                                                       |
| `eventIndex`       | number                  | Used to prevent replay attacks.                                                                       |
| `data`             | any                     | The data emitted from the event.                                                                      |

### `Transaction Statuses`

The status of a transaction will depend on the Flow blockchain network and which phase it is in as it completes and is finalized.

| Status Code | Description                                                                                                           |
| ----------- | --------------------------------------------------------------------------------------------------------------------- |
| `0`         | Unknown                                                                                                               |
| `1`         | Transaction Pending - Awaiting Finalization                                                                           |
| `2`         | Transaction Finalized - Awaiting Execution                                                                            |
| `3`         | Transaction Executed - Awaiting Sealing                                                                               |
| `4`         | Transaction Sealed - Transaction Complete. At this point the transaction result has been committed to the blockchain. |
| `5`         | Transaction Expired                                                                                                   |

### `GRPC Statuses`

The access node GRPC implementation follows the standard GRPC Core status code spec. View [here](https://grpc.github.io/grpc/core/md_doc_statuscodes.html).

### `FType`

FCL arguments must specify one of the following support types for each value passed in.

| Type         | Example                                                                                                              |
| ------------ | -------------------------------------------------------------------------------------------------------------------- |
| `UInt`       | `fcl.arg(1, t.UInt)`                                                                                                 |
| `UInt8`      | `fcl.arg(8, t.UInt8)`                                                                                                |
| `UInt16`     | `fcl.arg(16, t.UInt16)`                                                                                              |
| `UInt32`     | `fcl.arg(32, t.UInt32)`                                                                                              |
| `UInt64`     | `fcl.arg(64, t.UInt64)`                                                                                              |
| `UInt128`    | `fcl.arg(128, t.UInt128)`                                                                                            |
| `UInt256`    | `fcl.arg(256, t.UInt256)`                                                                                            |
| `Int`        | `fcl.arg(1, t.Int)`                                                                                                  |
| `Int8`       | `fcl.arg(8, t.Int8)`                                                                                                 |
| `Int16`      | `fcl.arg(16, t.Int16)`                                                                                               |
| `Int32`      | `fcl.arg(32, t.Int32)`                                                                                               |
| `Int64`      | `fcl.arg(64, t.Int64)`                                                                                               |
| `Int128`     | `fcl.arg(128, t.Int128)`                                                                                             |
| `Int256`     | `fcl.arg(256, t.Int256)`                                                                                             |
| `Word8`      | `fcl.arg(8, t.Word8)`                                                                                                |
| `Word16`     | `fcl.arg(16, t.Word16)`                                                                                              |
| `Word32`     | `fcl.arg(32, t.Word32)`                                                                                              |
| `Word64`     | `fcl.arg(64, t.Word64)`                                                                                              |
| `UFix64`     | `fcl.arg("64.123", t.UFix64)`                                                                                        |
| `Fix64`      | `fcl.arg("64.123", t.Fix64)`                                                                                         |
| `String`     | `fcl.arg("Flow", t.String)`                                                                                          |
| `Character`  | `fcl.arg("c", t.String)`                                                                                             |
| `Bool`       | `fcl.arg(true, t.String)`                                                                                            |
| `Address`    | `fcl.arg("0xABC123DEF456", t.Address)`                                                                               |
| `Optional`   | `fcl.arg("Flow", t.Optional(t.String))`                                                                              |
| `Array`      | `fcl.args([ fcl.arg(["First", "Second"], t.Array(t.String)) ])`                                                      |
| `Dictionary` | `fcl.args([fcl.arg([{key: 1, value: "one"}, {key: 2, value: "two"}], t.Dictionary({key: t.Int, value: t.String}))])` |
| `Path`       | `fcl.arg({ domain: "public", identifier: "flowTokenVault" }, t.Path)`                                                |

---

# Authentication

The concept of authentication in FCL is tied closely to FCL's concept of `currentUser`. In fact `fcl.authenticate` and `fcl.unauthenticate` are both aliases to `fcl.currentUser.authenticate()` and `fcl.currentUser.unauthenticate()` respectively. So let's look at `currentUser`.

As a dapp developer, using FCL, our current thought is to enable three main pieces of functionality.

- How to know the `currentUser` and if they are logged in.
- How to log a user in.
- How to log a user out.

Due to the nature of how FCL works, logging a user in and signing a user up are the same thing.

# Knowing things about the current user

FCL provides two ways of getting the current users information. One way is a promise that returns a snapshot of the info, while the other way allows you to subscribe to info, calling a callback function with the latest info anytime it changes.

### Snapshot of Current User

```javascript
import * as fcl from "@onflow/fcl"

const currentUser = await fcl.currentUser.snapshot()
console.log("The Current User", currentUser)
```

### Subscribe to Current User

```javascript
import * as fcl from "@onflow/fcl"

// Returns an unsubscribe function
const unsubscribe = fcl.currentUser.subscribe(currentUser => {
  console.log("The Current User", currentUser)
})
```

# Actually Authenticating and Unauthenticating

The TL;DR is to call `fcl.authenticate()` and `fcl.unauthenticate()` respectively.

On Flow mainnet, you wont even need to configure anything for this to work, the users of your dapp will go through the authentication process and be able to use any FCL compatible wallet providers.

During development you will probably want to configure your dapp to use [`@onflow/dev-wallet`](https://github.com/onflow/fcl-dev-wallet).
The [Quick Start](../../../build/guides/flow-app-quickstart.md) guide will walk you through using it.

We know this can all be fairly overwhelming, we are commited to help though. If you run into any problems, reach out to us on [Discord](https://discord.gg/k6cZ7QC), we are more than happy to help out.
---
title: How to Configure FCL
---

## Configuration

FCL has a mechanism that lets you configure various aspects of FCL.
The main idea here (from an FCL perspective) should be that when you move from one instance of the Flow Blockchain to another (Local Emulator to Testnet to Mainnet) the only thing you should need to change (once again from an FCL perspective) is your configuration.

## Setting Configuration Values

Values only need to be set once. We recomend doing this once and as early in the life cycle as possible.
To set a configuation value, the `put` method on the `config` instance needs to be called, the `put` method returns the `config` instance so they can be chained.

```javascript
import * as fcl from "@onflow/fcl"

fcl.config()         // returns the config instance
  .put("foo", "bar") // configures "foo" to be "bar"
  .put("baz", "buz") // configures "baz" to be "buz"
```

## Getting Configuration Values

The `config` instance has an asynchronous `get` method. You can also pass it a fallback value incase the configuration state does not include what you are wanting.

```javascript
import * as fcl from "@onflow/fcl"

fcl.config()
  .put("foo", "bar")
  .put("woot", 5)
  .put("rawr", 7)

const FALLBACK = 1

async function addStuff () {
  var woot = await fcl.config().get("woot", FALLBACK) // will be 5 -- set in the config before
  var rawr = await fcl.config().get("rawr", FALLBACK) // will be 7 -- set in the config before
  var hmmm = await fcl.config().get("hmmm", FALLBACK) // will be 1 -- uses fallback because this isnt in the config

  return woot + rawr + hmmm
}

addStuff().then(d => console.log(d)) // 13 (5 + 7 + 1)
```

## Common Configuration Keys

- `accessNode.api` -- Api URL for the Flow Blockchain Access Node you want to be communicating with.
- `app.detail.title` - **(INTRODUCED `@onflow/fcl@0.0.68`)** Your applications title, can be requested by wallets and other services.
- `app.detail.icon` - **(INTRODUCED `@onflow/fcl@0.0.68`)** Url for your applications icon, can be requested by wallets and other services.
- `challenge.handshake` -- **(DEPRECATED `@onflow/fcl@0.0.68`)** Points FCL at the Wallet or Wallet Discovery mechanism.
- `discovery.wallet` -- **(INTRODUCED `@onflow/fcl@0.0.68`)** Points FCL at the Wallet or Wallet Discovery mechanism.
- `discovery.wallet.method` -- Describes which service strategy a wallet should use: `IFRAME/RPC`, `POP/RPC`, `TAB/RPC`, `HTTP/POST`, `EXT/RPC`
- `env` -- **(DEPRECATED `@onflow/fcl@1.0.0`)** Used in conjunction with stored interactions. Possible values: `local`, `canarynet`, `testnet`, `mainnet`
- `fcl.limit` -- Specifies fallback compute limit if not provided in transaction.  Provided as integer.
- `flow.network` (recommended) -- **(INTRODUCED `@onflow/fcl@1.0.0`)** Used in conjunction with stored interactions and provides FCLCryptoContract address for `testnet` and `mainnet`. Possible values: `local`, `canarynet`, `testnet`, `mainnet`.
- `service.OpenID.scopes` - **(INTRODUCED `@onflow/fcl@0.0.68`)** Open ID Connect claims for Wallets and OpenID services.

## Using Contracts in Scripts and Transactions

### Address Replacement

Configuration keys that start with `0x` will be replaced in FCL scripts and transactions, this allows you to write your script or transaction Cadence code once and not have to change it when you point your application at a difference instance of the Flow Blockchain.

```javascript
import * as fcl from "@onflow/fcl"

fcl.config()
  .put("0xFungibleToken", "0xf233dcee88fe0abe")

async function myScript () {
  return fcl.send([
    fcl.script`
      import FungibleToken from 0xFungibleToken // will be replaced with 0xf233dcee88fe0abe because of the configuration

      pub fun main() { /* Rest of the script goes here */ }
    `
  ]).then(fcl.decode)
}

async function myTransaction () {
  return fcl.send([
    fcl.transaction`
      import FungibleToken from 0xFungibleToken // will be replaced with 0xf233dcee88fe0abe because of the configuration

      transaction { /* Rest of the transaction goes here */ }
    `
  ]).then(fcl.decode)
}
```

#### Example

```javascript
import * as fcl from "@onflow/fcl"

fcl.config()
  .put("flow.network", "testnet")
  .put("accessNode.api", "https://rest-testnet.onflow.org")
  .put("discovery.wallet", "https://fcl-discovery.onflow.org/testnet/authn")
  .put("app.detail.title", "Test Harness")
  .put("app.detail.icon", "https://i.imgur.com/r23Zhvu.png")
  .put("0xFlowToken", "0x7e60df042a9c0868")
```

### Using Flow.json

A simpler way to import contracts in scripts and transactions is to use the `config.load` method to ingest your contracts from your `flow.json` file. This keeps the import syntax unified across tools and lets FCL figure out which address to use for what network based on the network provided in config. To use `config.load` you must first import your `flow.json` file and then pass it to `config.load` as a parameter.

```javascript
import { config } from '@onflow/fcl'
import flowJSON from '../flow.json'

config({
  'flow.network': 'testnet',
  'accessNode.api': 'https://rest-testnet.onflow.org',
  'discovery.wallet': `https://fcl-discovery.onflow.org/testnet/authn`,
}).load({ flowJSON })
```

Let's say your `flow.json` file looks like this:

```
{
  "contracts": {
		"HelloWorld": "cadence/contracts/HelloWorld.cdc"
	}
}
```

Then in your scripts and transactions, all you have to do is:

```
import "HelloWorld"
```

FCL will automatically replace the contract name with the address for the network you are using.

> Note: never put private keys in your `flow.json`. You should use the [key/location syntax](../../../tools/flow-cli/flow.json/security.md) to separate your keys into a separate git ignored file.---
title: Wallet Discovery
---

## Wallet Discovery

Knowing all the wallets available to users on a blockchain can be challenging. FCL's Discovery mechanism relieves much of the burden of integrating with Flow compatible wallets and let's developers focus on building their dapp and providing as many options as possible to their users.

There are two ways an app can use Discovery: 
 1. The **UI version** which can be configured for display via iFrame, Popup, or Tab.
 2. The **API version** which allows you to access authentication services directly in your code via `fcl.discovery.authn` method which we'll describe below.

## UI Version

When authenticating via FCL using Discovery UI, a user is shown a list of services they can use to login.

![FCL Default Discovery UI](./images/discovery.png)

This method is the simplest way to integrate Discovery and its wallets and services into your app. All you have to do is configure `discovery.wallet` with the host endpoint for testnet or mainnet.

> **Note**: Opt-in wallets, like Ledger and Dapper Wallet, require you to explicitly state you'd like to use them. For more information on including opt-in wallets, [see these docs](./api.md#more-configuration). 
> 
> A [Dapper Wallet](https://meetdapper.com/developers) developer account is required. To enable Dapper Wallet inside FCL, you need to [follow this guide](https://docs.meetdapper.com/quickstart).

```javascript
import { config } from "@onflow/fcl";

config({
  "accessNode.api": "https://rest-testnet.onflow.org",
  "discovery.wallet": "https://fcl-discovery.onflow.org/testnet/authn"
})
```

Any time you call `fcl.authenticate` the user will be presented with that screen.

To change the default view from iFrame to popup or tab set `discovery.wallet.method` to `POP/RPC` (opens as a popup) or `TAB/RPC` (opens in a new tab). More info about service methods can be [found here](https://github.com/onflow/fcl-js/blob/9bce741d3b32fde18b07084b62ea15f9bbdb85bc/packages/fcl/src/wallet-provider-spec/draft-v3.md).

### Branding Discovery UI

Starting in version 0.0.79-alpha.4, dapps now have the ability to display app a title and app icon in the Discovery UI by setting a few values in their FCL app config. This branding provides users with messaging that has clear intent before authenticating to add a layer of trust.

All you have to do is set `app.detail.icon` and `app.detail.title` like this:

```javascript
import { config } from "@onflow/fcl";

config({
  "app.detail.icon": "https://placekitten.com/g/200/200",
  "app.detail.title": "Kitten Dapp"
})
```

**Note:** If these configuration options aren't set, Dapps using the Discovery API will still display a default icon and "Unknown App" as the title when attempting to authorize a user who is not logged in. It is highly recommended to set these values accurately before going live.

## API Version

If you want more control over your authentication UI, the Discovery API is also simple to use as it exposes Discovery directly in your code via `fcl`.

Setup still requires configuration of the Discovery endpoint, but when using the API it is set via `discovery.authn.endpoint` as shown below.

```javascript
import { config } from "@onflow/fcl"

config({
  "accessNode.api": "https://rest-testnet.onflow.org",
  "discovery.authn.endpoint": "https://fcl-discovery.onflow.org/api/testnet/authn"
})
```

You can access services in your Dapp from `fcl.discovery`:

```javascript
import * as fcl from "@onflow/fcl"

fcl.discovery.authn.subscribe(callback)

// OR 

fcl.discovery.authn.snapshot()
```
In order to authenticate with a service (for example, when a user click's "login"), pass the selected service to the `fcl.authenticate` method described here [in the API reference](./api.md#authenticate):

```jsx
fcl.authenticate({ service })
```

A simple React component may end up looking like this:

```jsx
import "./config"
import { useState, useEffect } from "react"
import * as fcl from "@onflow/fcl"

function Component() {
  const [services, setServices] = useState([])
  useEffect(() => fcl.discovery.authn.subscribe(res => setServices(res.results)), [])

  return (
    <div>
      {services.map(service => <button key={service.provider.address} onClick={() => fcl.authenticate({ service })}>Login with {service.provider.name}</button>)}
    </div>
  )
}
```

Helpful fields for your UI can be found in the `provider` object inside of the service. Fields include the following:

```json
{
  ...,
  "provider": {
    "address": "0xf086a545ce3c552d",
      "name": "Blocto",
      "icon": "/images/blocto.png",
      "description": "Your entrance to the blockchain world.",
      "color": "#afd8f7",
      "supportEmail": "support@blocto.app",
      "authn_endpoint": "https://flow-wallet-testnet.blocto.app/authn",
      "website": "https://blocto.portto.io"
    }
}
```

## Network Configuration

### Discovery UI URLs

| Environment | Example                                          |
| ----------- | ------------------------------------------------ |
| Mainnet     | `https://fcl-discovery.onflow.org/authn`         |
| Testnet     | `https://fcl-discovery.onflow.org/testnet/authn` |
| Local       | `https://fcl-discovery.onflow.org/local/authn`   |

### Discovery API Endpoints

| Environment | Example                                              |
| ----------- | ---------------------------------------------------- |
| Mainnet     | `https://fcl-discovery.onflow.org/api/authn`         |
| Testnet     | `https://fcl-discovery.onflow.org/api/testnet/authn` |
| Local       | `https://fcl-discovery.onflow.org/api/local/authn`   |

> Note: Local will return [Dev Wallet](https://github.com/onflow/fcl-dev-wallet) on emulator for developing locally with the default port of 8701. If you'd like to override the default port add ?port=0000 with the port being whatever you'd like to override it to.

## Other Configuration

> Note: Configuration works across both UI and API versions of Discovery.

### Include Opt-In Wallets

**Starting in FCL v0.0.78-alpha.10**

Opt-in wallets are those that don't have support for authentication, authorization, and user signature services. Or, support only a limited set of transactions.

To include opt-in wallets from FCL:

```
import * as fcl from "@onflow/fcl"

fcl.config({
  "discovery.wallet": "https://fcl-discovery.onflow.org/testnet/authn",
  "discovery.authn.endpoint": "https://fcl-discovery.onflow.org/api/testnet/authn",
  "discovery.authn.include": ["0x123"] // Service account address
})
```

**Opt-In Wallet Addresses on Testnet and Mainnet**

| Service         | Testnet            | Mainnet            |
| --------------- | ------------------ | ------------------ |
| `Dapper Wallet` | 0x82ec283f88a62e65 | 0xead892083b3e2c6c |
| `Ledger`        | 0x9d2e44203cb13051 | 0xe5cd26afebe62781 |

To learn more about other possible configurations, check out the following links:
- [Discovery API Docs](./api.md#discovery-1)
- [Discovery Github Repo](https://github.com/onflow/fcl-discovery)
---
sidebar_position: 3
---

# Flow Client Library (FCL)

The Flow Client Library (FCL) JS is a package used to interact with user wallets and the Flow blockchain. When using FCL for authentication, dapps are able to support all FCL-compatible wallets on Flow and their users without any custom integrations or changes needed to the dapp code.

It was created to make developing applications that connect to the Flow blockchain easy and secure. It defines a standardized set of communication patterns between wallets, applications, and users that is used to perform a wide variety of actions for your dapp. FCL also offers a full featured SDK and utilities to interact with the Flow blockchain.

While FCL itself is a concept and standard, FCL JS is the javascript implementation of FCL and can be used in both browser and server environments. All functionality for connecting and communicating with wallet providers is restricted to the browser. We also have FCL Swift implementation for iOS, see [FCL Swift](https://github.com/zed-io/fcl-swift) contributed by [@lmcmz](https://github.com/lmcmz).

---
## Getting Started

### Requirements
-  Node version `v12.0.0 or higher`.

### Installation

To use the FCL JS in your application, install using **yarn** or **npm**

```shell
npm i -S @onflow/fcl
```

```shell
yarn add @onflow/fcl
```
#### Importing

**ES6**
```js
import * as fcl from "@onflow/fcl";
```
**Node.js**
```js
const fcl = require("@onflow/fcl");
```
---
## FCL for Dapps
#### Wallet Interactions

- *Wallet Discovery* and *Sign-up/Login*: Onboard users with ease. Never worry about supporting multiple wallets. 
Authenticate users with any [FCL compatible wallet](./index.md#current-wallet-providers).
```js
// in the browser
import * as fcl from "@onflow/fcl"

fcl.config({
  "discovery.wallet": "https://fcl-discovery.onflow.org/testnet/authn", // Endpoint set to Testnet
})

fcl.authenticate()
```
![FCL Default Discovery UI](images/discovery.png)

> **Note**: A [Dapper Wallet](https://meetdapper.com/developers) developer account is required. To enable Dapper Wallet inside FCL, you need to [follow this guide](https://docs.meetdapper.com/quickstart).

- *Interact with smart contracts*: Authorize transactions via the user's chosen wallet 
- *Prove ownership of a wallet address*: Signing and verifying user signed data

[Learn more about wallet interactions >](./api.md#wallet-interactions)

#### Blockchain Interactions
- *Query the chain*: Send arbitrary Cadence scripts to the chain and receive back decoded values
```js
import * as fcl from "@onflow/fcl";

const result = await fcl.query({
  cadence: `
    pub fun main(a: Int, b: Int, addr: Address): Int {
      log(addr)
      return a + b
    }
  `,
  args: (arg, t) => [
    arg(7, t.Int), // a: Int
    arg(6, t.Int), // b: Int
    arg("0xba1132bc08f82fe2", t.Address), // addr: Address
  ],
});
console.log(result); // 13
```
- *Mutate the chain*: Send arbitrary transactions with your own signatures or via a user's wallet to perform state changes on chain.
```js
import * as fcl from "@onflow/fcl";
// in the browser, FCL will automatically connect to the user's wallet to request signatures to run the transaction
const txId = await fcl.mutate({
  cadence: `
    import Profile from 0xba1132bc08f82fe2
    
    transaction(name: String) {
      prepare(account: AuthAccount) {
        account.borrow<&{Profile.Owner}>(from: Profile.privatePath)!.setName(name)
      }
    }
  `,
  args: (arg, t) => [arg("myName", t.String)],
});
```

[Learn more about on-chain interactions >](./api.md#on-chain-interactions)

#### Utilities
- Get account details from any Flow address
- Get the latest block
- Transaction status polling
- Event polling
- Custom authorization functions

[Learn more about utilities >](./api.md#pre-built-interactions)


## Next Steps

See the [Flow App Quick Start](../../../build/guides/flow-app-quickstart.md).

See the full [API Reference](./api.md) for all FCL functionality.

Learn Flow's smart contract language to build any script or transactions: [Cadence](../../../build/guides/smart-contracts/cadence.md).

Explore all of Flow [docs and tools](/).


---
## FCL for Wallet Providers
Wallet providers on Flow have the flexibility to build their user interactions and UI through a variety of ways:
- Front channel communication via Iframe, pop-up, tab, or extension
- Back channel communication via HTTP

FCL is agnostic to the communication channel and is configured to create both custodial and non-custodial wallets. This enables users to interact with wallet providers without needing to download an app or extension.

The communication channels involve responding to a set of pre-defined FCL messages to deliver the requested information to the dapp.  Implementing a FCL compatible wallet on Flow is as simple as filling in the responses with the appropriate data when FCL requests them. If using any of the front-channel communication methods, FCL also provides a set of [wallet utilities](https://github.com/onflow/fcl-js/blob/master/packages/fcl/src/wallet-utils/index.js) to simplify this process.


### Current Wallet Providers
- [Blocto](https://blocto.portto.io/en/)
- [Ledger](https://ledger.com) (limited transaction support)
- [Dapper Wallet](https://www.meetdapper.com/)
- [Lilico](https://lilico.app/)
- [Flipper](https://flipper.org/)
- [NuFi](https://nu.fi)

### Wallet Discovery
It can be difficult to get users to discover new wallets on a chain. To solve this, we created a wallet discovery service that can be configured and accessed through FCL to display all available Flow wallet providers to the user. This means:
- Dapps can display and support all FCL compatible wallets that launch on Flow without needing to change any code
- Users don't need to sign up for new wallets - they can carry over their existing one to any dapp that uses FCL for authentication and authorization.

The discovery feature can be used via API, allowing you to customize your own UI or use the default UI without any additional configuration.

### Building a FCL compatible wallet

- Read the [wallet guide](https://github.com/onflow/fcl-js/blob/master/packages/fcl/src/wallet-provider-spec/draft-v3.md) to understand the implementation details.
- Review the architecture of the [Flow Dev Wallet](https://github.com/onflow/fcl-dev-wallet) for an overview.
- If building a non-custodial wallet, see the [Account API](https://github.com/onflow/flow-account-api) and the [FLIP](https://github.com/onflow/flow/pull/727) on derivation paths and key generation.

---

## Support

Notice an problem or want to request a feature? [Add an issue](https://github.com/onflow/flow-js-sdk/issues).

Discuss FCL with the community on the [forum](https://forum.onflow.org/c/developer-tools/flow-fcl/22).

Join the Flow community on [Discord](https://discord.gg/k6cZ7QC) to keep up to date and to talk to the team.
# Installation

This chapter explains the installation of the FCL JS library in your system. However, before moving to the installation, let us verify the prerequisite first.

## Prerequisite
- Node.js version v12.0.0 or higher. 

FCL JS depends on Node.js version v12.0.0 or higher. You can check your currently installed version using the below command:

```javascript
node --version
```

If Node.js is not installed on your system, you can download and install it by visiting [Node.js Download](https://nodejs.org/en/download/). 


Install FCL JS using **npm** or **yarn**

```shell
npm i -S @onflow/fcl
```

```shell
yarn add @onflow/fcl
```
#### Importing

**ES6**
```js
import * as fcl from "@onflow/fcl";
```
**Node.js**
```js
const fcl = require("@onflow/fcl");
```
---
title: Interaction Templates
---

# Interaction Templates

> Interaction Templates are a concept established in FLIP-934. Read the FLIP [here](https://github.com/onflow/flips/blob/main/application/20220503-interaction-templates.md)

> "Interaction" in this context refers to the higher order term establised in FLIP-934 that encompases a transaction and script, things that _interact_ with the blockchain.

## Overview

Interaction Templates establish a format for metadata that exists about an interaction. Interaction Templates can include:

- Human readable, internationalized messages about the interaction
- The Cadence code to carry out the interaction
- Information about arguments such as internationalized human readable messages and what the arguments act upon
- Contract dependencies the Interaction engages with, pinned to a version of them and their dependency tree

Applications and Wallets can use Interaction Templates and it's interaction metadata. 

For example Applications and Wallets can extract the internationalized human readable messaging from an Interaction Template to display to their users prior to execution of the interaction.

## For Applications

FCL `mutate` and `query` can accept an Interaction Template. FCL `mutate` and `query` will use the Interaction Template to:

- Extract the Cadence code to carry out the interaction
- Extract dependency configuration for the interaction (eg: Information about contract import addresses)

Here is an example of using `mutate` with an Interaction Template:
```javascript
import * as fcl from "@onflow/fcl"
import myTransactionTemplate from "./my-transaction-template.template.json"

const txId = await fcl.mutate({
  template: myTransactionTemplate
})
```

An Interaction Template can also be used with `query`:
```javascript
import * as fcl from "@onflow/fcl"
import myScriptTemplate from "./my-script-template.template.json"

const info = await fcl.query({
  template: myScriptTemplate
})
```

Interaction Templates can be resolved from remote locations:

```javascript
import * as fcl from "@onflow/fcl"

const txId = await fcl.mutate({
  template: "http://interactions.awesome-crypto-project.com/buy-nft"
})

const nftInfo = await fcl.query({
  template: "http://interactions.awesome-crypto-project.com/read-nft",
  args: (arg, t) => [arg("nft-id", t.String)]
})
```

FCL will resolve the template from the remote location before using it to execute its underlying transaction or script.

> 💡 By requesting an Interaction Template from an external location, applications have a mechanism to always retrieve the most up to date way of accomplishing an interaction.

By default FCL supports resolving Interaction Templates over http/https, but FCL can also be configured with various other ways to resolve Interaction Templates:

```javascript
import * as fcl from "@onflow/fcl"

await fcl.config().put("document.resolver.ipfs", async ({ url }) => {
  const jsonTemplate = getDocumentFromIPFS(url) // resolve interaction template from ipfs
  return jsonTemplate
})

const txId = await fcl.mutate({
  template: "ipfs://IPFSHASHGOESHERE"
})
```

## For Wallets

Wallets can use Interaction Templates to:
- Display internationalized human readable information about a transaction to their users during signing
- Verify the dependencies of an Interaction Template have not changed since when the Interaction Template was created
- Using Interaction Template Audits, gain confidence in the correctness and safety of an Interaction Template and it's underlying transaction

When recieving a transaction to sign, wallets can query for an Interaction Template that corresponds to it.

Flow operates an "Interaction Template Discovery Service" which wallets can use to query for Interaction Templates. Anyone can run an "Interaction Template Discovery Service" and wallets can choose to query from any of them.

```javascript
const cadence = cadenceFromTransactionToSign
const network = "mainnet" // "mainnet" | "testnet"

const cadence_base64 = btoa(cadence)

const interactionTemplate = await fetch(
  "https://flix.flow.com/v1/templates/search",
  {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    }
    body: JSON.stringify({
      cadence_base64,
      network
    })
  }
)
```

> 📖  For more on the "Interaction Template Discovery Service" that Flow operates, see [here](https://github.com/onflow/flow-interaction-template-service)

> ❗️ Not all transactions will have a corresponding Interaction Template. Wallets are encouraged to always support signing transactions that do not have a corresponding Interaction Template, or if they fail to discover one.

Once a wallet has a corresponding Interaction Template for a given transaction, they may also may wish to verify that the transaction it represents is safe to sign, and that the Interaction Template is accurate for that transaction.

To do so, wallets can rely on themselves, along with external Interaction Template Auditors to gain confidence in the Interaction Template and it's underlying transaction. Interaction Template Auditors are entities that audit Interaction Templates for correctness and safety.

> 💡 Anyone can be an Interaction Template Auditor. Wallets can choose auditors they trust, if any.

Wallets can specify auditors it trusts to FCL by configuring FCL with the address of each auditor:

```javascript
import * as fcl from "@onflow/fcl"

await fcl.config().put("flow.network", "mainnet")

const auditorA_FlowAddress = "0xABC123DEF456"
const auditorB_FlowAddress = "0xFFAA1212DEFF"

await fcl.config().put("flow.auditors", [
  auditorA_FlowAddress,
  auditorB_FlowAddress
])
```

Wallets can check if the auditors they configured FCL with have audited a given Interaction Template:

```javascript
import * as fcl from "@onflow/fcl"
import myTransactionTemplate from "./my-transaction-template.template.json"

const audits = await fcl.InteractionTemplateUtils
  .getInteractionTemplateAudits({
    template: myTransactionTemplate
  })

/**
 * audits = {
 *   "0xABC123DEF456": true,
 *   "0xFFAA1212DEFF": false
 * }
 ** /
```

The Flow team operates these auditor accounts:

| Flow Team Auditor Accounts | Address            |
|----------------------------|:-------------------|
| TestNet                    | 0xf78bfc12d0a786dc |
| MainNet                    | 0xfd100e39d50a13e6 |

Since not all auditors that a wallet trusts may have audited a given Interaction Template, trusting multiple auditors can increase the chance that at least one of the trusted auditors has audited the Interaction Template.

> ❗️ Auditors can revoke audits at any time, so be sure to always check an Interaction Template's audit status. 

Since contracts on Flow are mutable, wallets may additionally wish to verify that none of the dependency tree for the transaction an Interaction Template represents has changed since when it was created and of what it was audited against.

```javascript
import * as fcl from "@onflow/fcl"
import myTransactionTemplate from "./my-transaction-template.template.json"

const hasDependencyTreeChanged = await fcl.InteractionTemplateUtils
  .verifyDependencyPinsSameAtLatestSealedBlock({
    template: myTransactionTemplate
  })
```

If the dependency tree has changed, wallets may choose to disregard the Interaction Template (and it's audits).

Once the Interaction Template has been sufficiently audited by auditors the wallet trusts, and it's dependency tree determined unchanged since the interaction was created and audited against, then the wallet can use the Interaction Template with greater confidence in it's correctness and safety.

The wallet may then decide to render human readable information about the transaction such as:
- Internationalized 'title' and 'description' of the transaction
- Internationalized 'title' for each of the transactions arguments alongside the arguments value

The wallet may then also make the status of it's audits known to the user in their UI. This allows the user to have greater confidence in the safety of the transaction. 

## Data Structure

The following is an example Interaction Template that corresponds to a "Transfer FLOW" transaction:

```json
{
  "f_type": "InteractionTemplate",
  "f_version": "1.0.0",
  "id": "290b6b6222b2a77b16db896a80ddf29ebd1fa3038c9e6625a933fa213fce51fa",
  "data": {
    "type": "transaction",
    "interface": "",
    "messages": {
      "title": {
        "i18n": {
          "en-US": "Transfer Tokens"
        }
      },
      "description": {
        "i18n": {
          "en-US": "Transfer tokens from one account to another"
        }
      }
    },
    "cadence": "import FungibleToken from 0xFUNGIBLETOKENADDRESS\ntransaction(amount: UFix64, to: Address) {\nlet vault: @FungibleToken.Vault\nprepare(signer: AuthAccount) {\nself.vault <- signer\n.borrow<&{FungibleToken.Provider}>(from: /storage/flowTokenVault)!\n.withdraw(amount: amount)\n}\nexecute {\ngetAccount(to)\n.getCapability(/public/flowTokenReceiver)!\n.borrow<&{FungibleToken.Receiver}>()!\n.deposit(from: <-self.vault)\n}\n}",
    "dependencies": {
      "0xFUNGIBLETOKENADDRESS": {
        "FungibleToken": {
          "mainnet": {
            "address": "0xf233dcee88fe0abe",
            "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
            "contract": "FungibleToken",
            "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
            "pin_block_height": 34166296
          },
          "testnet": {
            "address": "0x9a0766d93b6608b7",
            "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
            "contract": "FungibleToken",
            "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
            "pin_block_height": 74776482
          }
        }
      }
    },
    "arguments": {
      "amount": {
        "index": 0,
        "type": "UFix64",
        "messages": {
          "title": {
            "i18n": {
              "en-US": "The amount of FLOW tokens to send"
            }
          }
        }
      },
      "to": {
        "index": 1,
        "type": "Address",
        "messages": {
          "title": {
            "i18n": {
              "en-US": "The Flow account the tokens will go to"
            }
          }
        }
      }
    }
  }
}
```
---
title: Proving Ownership of a Flow Account
---

## Proving Ownership of a Flow Account

A common desire that application developers have is to be able to prove that a
user controls an on-chain account. Proving ownership of an on-chain account is a
way to authenticate a user with an application backend. Fortunately,
FCL provides a way to achieve this.

During user authentication, some FCL compatible wallets will choose to support
the FCL `account-proof` service. If a wallet chooses to support this service, and
the user approves the signing of message data, they will return `account-proof` data
and a signature(s) that can be used to prove a user controls an on-chain account.

We'll walk through how you, an application developer, can use the `account-proof` service to
authenticate a user.

> Are you an FCL Wallet Developer? Check out the wallet provider specific docs
> [here](https://github.com/onflow/fcl-js/tree/master/packages/fcl/src/wallet-provider-spec/provable-authn.md)

### Authenticating a user using `account-proof`

In order to authenticate your users via a wallet provider's account-proof service, your application needs to
configure FCL by setting `fcl.accountProof.resolver` and providing two pieces of information.

The `fcl.accountProof.resolver` is an async resolver function used by FCL to retrieve account proof data
from your application server. It can be set in your application configuration under the `fcl.accountProof.resolver`
key. The resolved data should include a specific application identifier (`appIdentifier`) and a random `nonce`.
This data will be sent to the wallet for signing by the user. If the user approves and authentication is successfull,
a signature is returned to the client in the data field of an `account-proof` service.

**Application Identifier**

An application identifier is a human-readable string that uniquely identifies your application name.
The identifier is displayed by wallets when users are asked to approve a signing request.
It helps users compare against the request origin and detect some malicious phishing attempts,
improving trust of the application and signing process.

**Random Nonce**

In addition to the `appIdentifier` your application must provide a **minimum 32-byte random nonce** as a hex string.

If for any reason your application backend does not want to request an `account-proof` during authentication,
it should send a response of `null`. If FCL receives a `null` response from the `accountProof.resolver` it will
continue the authentication process with the wallet but will not request an account-proof and no signature will be returned.

> In the case of a network or server error FCL will cancel the authentication process and return a rejected promise.

```js
import {config} from "@onflow/fcl"

type AccountProofData {
  // e.g. "Awesome App (v0.0)" - A human readable string to identify your application during signing
  appIdentifier: string;  

  // e.g. "75f8587e5bd5f9dcc9909d0dae1f0ac5814458b2ae129620502cb936fde7120a" - minimum 32-byte random nonce as hex string
  nonce: string;          
}

type AccountProofDataResolver = () => Promise<AccountProofData | null>;

config({
  "fcl.accountProof.resolver": accountProofDataResolver
})
```

Here is the suggested order of operations of how your application might use the
`account-proof` service:

- A user would like to authenticate via your application client using FCL. The process is triggered
  by a call to `fcl.authenticate()`. If `fcl.accountProof.resolver` is configured, FCL will attempt
  to retrieve the account proof data (`appIdentifier` and `nonce`) and trigger your server to start a new
  account proof authentication process.
- Your application server generates a **minimum 32-byte random nonce** using a local source of entropy and
  sends it to the client. The server saves the challenge for future look-ups.
- If FCL successfully retrieves the `account-proof` data, it continues the authentication process over a secure channel with the wallet.
  FCL includes the `appIdentifier` and `nonce` as part of the `FCL:VIEW:READY:RESPONSE` or HTTP POST request body.
  If the resolver function call fails to retrieve the nonce, FCL will cancel the authentication process.
- If the wallet supports account proofs and the user approves authentication with the wallet, the wallet will return the `account-proof`
  service with its response.

The data within the `account-proof` service will look like this:

```js
{
  f_type: "Service",                    // Its a service!
  f_vsn: "1.0.0",                       // Follows the v1.0.0 spec for the service
  type: "account-proof",                // The type of service it is
  method: "DATA",                       // Its data!
  uid: "awesome-wallet#account-proof",  // A unique identifier for the service
  data: {
    f_type: "account-proof",
    f_vsn: "2.0.0"

    // The user's address (8 bytes, i.e 16 hex characters)
    address: "0xf8d6e0586b0a20c7",                 

    // Nonce signed by the current account-proof (minimum 32 bytes in total, i.e 64 hex characters)
    nonce: "75f8587e5bd5f9dcc9909d0dae1f0ac5814458b2ae129620502cb936fde7120a",

    signatures: [CompositeSignature],
  }
}
```

- Your application client initiates a secure channel with your application server
  to relay the `account-proof` data and authenticate the user with your server.
  Subsequent exchanges between the client and server will happen over this channel.

- Your application server receives the `account-proof` data structure, and can then
  begin the verification process.

  - The server checks if the Flow address corresponds to an existing application
    account and determines whether it needs to sign in a returning user or create
    a new account. It is up to your application to decide how to manage
    the two cases.
  - The server looks the challenge up. If the nonce is not found or the nonce
    has expired, reject the authentication request, otherwise continue.
  - The server determines whether the `CompositeSignature` in the
    `account-proof` data structure contains valid signatures for the nonce
    and on-chain accounts (more details in the section below on how this is done).
  - If the verification is successful, delete the `nonce` or mark it as expired,
    the application account defined by the on-chain address is successfully
    logged in. Otherwise the authentication fails and the `nonce` is not deleted.

**Verification**

Your application can verify the signature against the data from `account-proof`
data using FCL's provided utility:

```js

import { AppUtils } from "@onflow/fcl"

  const accountProofData = {
    accountProof.address,   // address of the user authenticating
    accountProof.nonce,     // nonce
    accountProof.signatures // signatures
  }
  
  const isValid = await AppUtils.verifyAccountProof(
    appIdentifier,
    accountProofData
  )
```

## Implementation considerations:

- The authentication assumes the Flow address is the identifier of the user's application account.
  If an existing user doesn't have a Flow address in their profile, or if they decide to authenticate using
  a Flow address different than the one saved in their profile, the user's account won't be found and the
  process would consider a new user creating an account. It is useful for your application to consider
  other authentication methods that allow an existing user to update the Flow address in their profile so
  they are able to use FCL authentication.
- In the `account-proof` flow as described in this document,
  the backend doesn't know the user's account address at the moment of generating a nonce.
  This results in the nonces not being tied to particular Flow addresses. The backend should
  enforce an expiry window for each nonce to avoid the pool of valid nonces from growing indefinitely.
  Your application is encouraged to implement further mitigations against malicious attempts and
  maintain a scalable authentication process.
- FCL `account-proof` provides functionality to prove a user is in control of
  a Flow address. All other aspects of authentication, authorization and session management
  are up to the application. There are many resources available for setting up secure user
  authentication systems. Application developers should carefully consider what's best for their use
  case and follow industry best practices.
- It is important to use a secure source of entropy to generate the random nonces. The source should insure
  nonces are not predictable by looking at previously generated nonces. Moreover, backend should use its own
  local source and not rely on a publicly available source. Using a nonce of at least 32-bytes insures
  it is extremely unlikely to have a nonce collision.
- Your application identifier `appIdentifier` is a constant defined by your backend. It is
  important that the backend uses the `appIdentifier` it expects when verifying the signatures,
  and not rely on an identifier passed along with the `account-proof`. For this reason,
  `appIdentifier` is not included in the `account-proof` data.
- A successful FCL authentication proves the user fully controls a Flow account. This means the user
  controls one or many account keys with weights that add up to the full account weight. The authentication
  would fail if the user doesn't control keys that add up to a full weight.
# Scripts

Scripts let you run non-permanent Cadence scripts on the Flow blockchain. They can return data.

They always need to contain a `pub fun main()` function as an entry point to the script.

`fcl.query` is a function that sends Cadence scripts to the chain and receives back decoded responses.

The `cadence` key inside the object sent to the `query` function is a [JavaScript Tagged Template Literal](https://styled-components.com/docs/advanced#tagged-template-literals) that we can pass Cadence code into.

### Sending your first Script

In the following code snippet we are going to send a script to the Flow blockchain.
The script is going to add two numbers, and return them.

```javascript
import * as fcl from "@onflow/fcl"

const response = await fcl.query({
  cadence: `
    pub fun main(): Int {
      return 1 + 2
    }
  `
})

console.log(response) // 3
```

### A more complicated Script

Things like [Resources](../../../build/guides/smart-contracts/cadence.md#resources) and [Structs](../../../build/guides/smart-contracts/cadence.md#structures) are fairly common place in Cadence.

In the following code snippet, our script defines a struct called `Point`, it then returns a list of them.

The closest thing to a Structure in JavaScript is an object. In this case when we decode this response, we would be expecting to get back an array of objects, where the objects have an `x` and `y` value.

```javascript
import * as fcl from "@onflow/fcl"

const response = await fcl.query({
  cadence: `
    pub struct Point {
      pub var x: Int
      pub var y: Int

      init(x: Int, y: Int) {
        self.x = x
        self.y = y
      }
    }

    pub fun main(): [Point] {
      return [Point(x: 1, y: 1), Point(x: 2, y: 2)]
    }
  `
})

console.log(response) // [{x:1, y:1}, {x:2, y:2}]
```

### Transforming the data we get back with custom decoders.

In our dapp, we probably have a way of representing these Cadence values internally. In the above example it might be a `Point` class.

FCL enables us to provide custom decoders that we can use to transform the data we receive from the Flow blockchain at the edge, before anything else in our dapp gets a chance to look at it.

We add these custom decoders by [Configuring FCL](./configure-fcl.mdx).
This lets us set it once when our dapp starts up and use our normalized data through out the rest of our dapp.

In the below example we will use the concept of a `Point` again, but this time, we will add a custom decoder, that enables `fcl.decode` to transform it into a custom JavaScript `Point` class.

```javascript
import * as fcl from "@onflow/fcl"

class Point {
  constructor({ x, y }) {
    this.x = x
    this.y = y
  }
}

fcl.config()
  .put("decoder.Point", point => new Point(point))

const response = await fcl.query({
  cadence: `
    pub struct Point {
      pub var x: Int
      pub var y: Int

      init(x: Int, y: Int) {
        self.x = x
        self.y = y
      }
    }

    pub fun main(): [Point] {
      return [Point(x: 1, y: 1), Point(x: 2, y: 2)]
    }
  `
})

console.log(response) // [Point{x:1, y:1}, Point{x:2, y:2}]
```

To learn more about `query`, check out the [API documentation](./api.md#query).
---
title: SDK Reference
sidebar_label: SDK Reference
sidebar_position: 2
---

## Overview 

This reference documents methods available in the SDK that can be accessed via FCL, and explains in detail how these methods work.
FCL/SDKs are open source, and you can use them according to the licence.

The library client specifications can be found here:

[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/ref.svg" width="130" />](./api.md)


## Getting Started

### Installing
NPM:
```
npm install --save @onflow/fcl @onflow/types
```

Yarn:
```
yarn add @onflow/fcl @onflow/types
```

### Importing the Library
```javascript
import * as fcl from "@onflow/fcl"
import * as types from "@onflow/types"
```

## Connect
[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/ref.svg" width="130" />](./configure-fcl.mdx)

By default, the library uses HTTP to communicate with the access nodes and it must be configured with the correct access node API URL.  An error will be returned if the host is unreachable.

📖**The HTTP/REST API information** can be found [here](/http-api/).  The public Flow HTTP/REST access nodes are accessible at:
- Testnet `https://rest-testnet.onflow.org`
- Mainnet `https://rest-mainnet.onflow.org`
- Local Emulator `127.0.0.1:8888` 

Example:
```javascript
import { config } from "@onflow/fcl"

config({
  "accessNode.api": "https://rest-testnet.onflow.org"
})
```

📖 **gRPC Access API URLs** can be found [here](../../../references/run-and-secure/nodes/access-api.mdx#flow-access-node-endpoints). `sdk.transport` must be specified if you wish to use the gRPC API.  The public Flow gRPC access nodes are accessible at:
- Testnet `https://access-testnet.onflow.org`
- Mainnet `https://access-mainnet.onflow.org`
- Local Emulator `127.0.0.1:3569`

For local development, use the [flow emulator](https://github.com/onflow/flow-emulator) which once started provides an HTTP access endpoint at `127.0.0.1:8888` and a gRPC access endpoint at `127.0.0.1:3569`.

If using the gRPC Access API, the `sdk.transport` configuration key must be populated as this value defaults to the HTTP API transport.  The SDK can be configured to use the gRPC API transport as follows:
```javascript
import { config } from "@onflow/fcl"
import { send as transportGRPC } from "@onflow/transport-grpc"

config({
  "accessNode.api": "https://access-testnet.onflow.org",
  "sdk.transport": transportGRPC
})
```

## Querying the Flow Network
After you have established a connection with an access node, you can query the Flow network to retrieve data about blocks, accounts, events and transactions. We will explore how to retrieve each of these entities in the sections below.

### Get Blocks
[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/ref.svg" width="130" />](./api.md#getblock)

Query the network for block by id, height or get the latest block.

📖 **Block ID** is SHA3-256 hash of the entire block payload. This hash is stored as an ID field on any block response object (ie. response from `GetLatestBlock`). 

📖 **Block height** expresses the height of the block on the chain. The latest block height increases by one for every valid block produced.

#### Examples

This example depicts ways to get the latest block as well as any other block by height or ID:

```
import * as fcl from "@onflow/fcl";

// Get latest block
const latestBlock = await fcl.latestBlock(true); // If true, get the latest sealed block

// Get block by ID (uses builder function)
await fcl.send([fcl.getBlock(), fcl.atBlockId("23232323232")]).then(fcl.decode);

// Get block at height (uses builder function)
await fcl.send([fcl.getBlock(), fcl.atBlockHeight(123)]).then(fcl.decode)
```
Result output: [BlockObject](./api.md#blockobject)

### Get Account
[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/ref.svg" width="130" />](./api.md#account)

Retrieve any account from Flow network's latest block or from a specified block height.

📖 **Account address** is a unique account identifier. Be mindful about the `0x` prefix, you should use the prefix as a default representation but be careful and safely handle user inputs without the prefix.

An account includes the following data:
- Address: the account address.
- Balance: balance of the account.
- Contracts: list of contracts deployed to the account.
- Keys: list of keys associated with the account.

#### Examples
Example depicts ways to get an account at the latest block and at a specific block height:

```javascript
import * as fcl from "@onflow/fcl";

// Get account from latest block height
const account = await fcl.account("0x1d007d755706c469");

// Get account at a specific block height
fcl.send([
  fcl.getAccount("0x1d007d755706c469"),
  fcl.atBlockHeight(123)
]);
```
Result output: [AccountObject](./api.md#accountobject)


### Get Transactions
[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/ref.svg" width="130" />](./api.md#gettransaction)

Retrieve transactions from the network by providing a transaction ID. After a transaction has been submitted, you can also get the transaction result to check the status.

📖 **Transaction ID** is a hash of the encoded transaction payload and can be calculated before submitting the transaction to the network.

⚠️ The transaction ID provided must be from the current spork.

📖 **Transaction status** represents the state of a transaction in the blockchain. Status can change until it is finalized.

| Status       | Final   | Description |
| ------------ | ------- | ----------- |
|   UNKNOWN    |    ❌   |   The transaction has not yet been seen by the network  |
|   PENDING    |    ❌   |   The transaction has not yet been included in a block   |
|   FINALIZED  |    ❌   |  The transaction has been included in a block   |
|   EXECUTED   |    ❌   |   The transaction has been executed but the result has not yet been sealed  |
|   SEALED     |    ✅   |   The transaction has been executed and the result is sealed in a block  |
|   EXPIRED    |    ✅   |  The transaction reference block is outdated before being executed    |

```javascript
import * as fcl from "@onflow/fcl";

// Snapshot the transaction at a point in time
fcl.tx(transactionId).snapshot();

// Subscribe to a transaction's updates
fcl.tx(transactionId).subscribe(callback);

// Provides the transaction once the status is finalized
fcl.tx(transactionId).onceFinalized();

// Provides the transaction once the status is executed
fcl.tx(transactionId).onceExecuted();

// Provides the transaction once the status is sealed
fcl.tx(transactionId).onceSealed();
```
Result output: [TransactionStatusObject](./api.md#gettransactionstatus)


### Get Events
[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/ref.svg" width="130" />](./api.md#geteventsatblockheightrange)

Retrieve events by a given type in a specified block height range or through a list of block IDs.

📖 **Event type** is a string that follow a standard format:
```
A.{contract address}.{contract name}.{event name}
```

Please read more about [events in the documentation](https://cadence-lang.org/docs/language/core-events). The exception to this standard are 
core events, and you should read more about them in [this document](https://cadence-lang.org/docs/language/core-events).

📖 **Block height range** expresses the height of the start and end block in the chain.

#### Examples
Example depicts ways to get events within block range or by block IDs:

```javascript
import * as fcl from "@onflow/fcl";

// Get events at block height range
await fcl
  .send([
    fcl.getEventsAtBlockHeightRange(
      "A.7e60df042a9c0868.FlowToken.TokensWithdrawn", // event name
      35580624, // block to start looking for events at
      35580624 // block to stop looking for events at
    ),
  ])
  .then(fcl.decode);

// Get events from list of block ids
await fcl
  .send([
    fcl.getEventsAtBlockIds("A.7e60df042a9c0868.FlowToken.TokensWithdrawn", [
      "c4f239d49e96d1e5fbcf1f31027a6e582e8c03fcd9954177b7723fdb03d938c7",
      "5dbaa85922eb194a3dc463c946cc01c866f2ff2b88f3e59e21c0d8d00113273f",
    ]),
  ])
  .then(fcl.decode);
```
Result output: [EventObject](./api.md#event-object)

### Get Collections
[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/ref.svg" width="130" />](./api.md#getcollection)

Retrieve a batch of transactions that have been included in the same block, known as ***collections***. 
Collections are used to improve consensus throughput by increasing the number of transactions per block and they act as a link between a block and a transaction.

📖 **Collection ID** is SHA3-256 hash of the collection payload.

Example retrieving a collection:
```javascript
import * as fcl from "@onflow/fcl";

const collection = await fcl
  .send([
    fcl.getCollection(
      "cccdb0c67d015dc7f6444e8f62a3244ed650215ed66b90603006c70c5ef1f6e5"
    ),
  ])
  .then(fcl.decode);
```
Result output: [CollectionObject](./api.md#collectionobject)

### Execute Scripts
[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/ref.svg" width="130" />](./api.md#query)

Scripts allow you to write arbitrary non-mutating Cadence code on the Flow blockchain and return data. You can learn more about [Cadence here](https://cadence-lang.org/docs/language) and [scripts here](./scripts.mdx), but we are now only interested in executing the script code and getting back the data.

We can execute a script using the latest state of the Flow blockchain or we can choose to execute the script at a specific time in history defined by a block height or block ID.

📖 **Block ID** is SHA3-256 hash of the entire block payload, but you can get that value from the block response properties.

📖 **Block height** expresses the height of the block in the chain.

```javascript
import * as fcl from "@onflow/fcl";

const result = await fcl.query({
  cadence: `
    pub fun main(a: Int, b: Int, addr: Address): Int {
      log(addr)
      return a + b
    }
  `,
  args: (arg, t) => [
    arg(7, t.Int), // a: Int
    arg(6, t.Int), // b: Int
    arg("0xba1132bc08f82fe2", t.Address), // addr: Address
  ],
});
```
Example output:
```bash
console.log(result); // 13
```

## Mutate Flow Network
Flow, like most blockchains, allows anybody to submit a transaction that mutates the shared global chain state. A transaction is an object that holds a payload, which describes the state mutation, and one or more authorizations that permit the transaction to mutate the state owned by specific accounts.

Transaction data is composed and signed with help of the SDK. The signed payload of transaction then gets submitted to the access node API. If a transaction is invalid or the correct number of authorizing signatures are not provided, it gets rejected. 

## Transactions
A transaction is nothing more than a signed set of data that includes script code which are instructions on how to mutate the network state and properties that define and limit it's execution. All these properties are explained bellow. 

📖 **Script** field is the portion of the transaction that describes the state mutation logic. On Flow, transaction logic is written in [Cadence](../../../build/guides/smart-contracts/cadence.md). Here is an example transaction script:
```
transaction(greeting: String) {
  execute {
    log(greeting.concat(", World!"))
  }
}
```

📖 **Arguments**. A transaction can accept zero or more arguments that are passed into the Cadence script. The arguments on the transaction must match the number and order declared in the Cadence script. Sample script from above accepts a single `String` argument.

📖 **[Proposal key](../../../build/basics/transactions.md#proposal-key)** must be provided to act as a sequence number and prevent replay and other potential attacks.

Each account key maintains a separate transaction sequence counter; the key that lends its sequence number to a transaction is called the proposal key.

A proposal key contains three fields:
- Account address
- Key index
- Sequence number

A transaction is only valid if its declared sequence number matches the current on-chain sequence number for that key. The sequence number increments by one after the transaction is executed.

📖 **[Payer](../../../build/basics/transactions.md#signer-roles)** is the account that pays the fees for the transaction. A transaction must specify exactly one payer. The payer is only responsible for paying the network and gas fees; the transaction is not authorized to access resources or code stored in the payer account.

📖 **[Authorizers](../../../build/basics/transactions.md#signer-roles)** are accounts that authorize a transaction to read and mutate their resources. A transaction can specify zero or more authorizers, depending on how many accounts the transaction needs to access.

The number of authorizers on the transaction must match the number of AuthAccount parameters declared in the prepare statement of the Cadence script.

Example transaction with multiple authorizers:
```
transaction {
  prepare(authorizer1: AuthAccount, authorizer2: AuthAccount) { }
}
```

📖 **Gas limit** is the limit on the amount of computation a transaction requires, and it will abort if it exceeds its gas limit.
Cadence uses metering to measure the number of operations per transaction. You can read more about it in the [Cadence documentation](../../../build/guides/smart-contracts/cadence.md).

The gas limit depends on the complexity of the transaction script. Until dedicated gas estimation tooling exists, it's best to use the emulator to test complex transactions and determine a safe limit.

📖 **Reference block** specifies an expiration window (measured in blocks) during which a transaction is considered valid by the network.
A transaction will be rejected if it is submitted past its expiry block. Flow calculates transaction expiry using the _reference block_ field on a transaction.
A transaction expires after `600` blocks are committed on top of the reference block, which takes about 10 minutes at average Mainnet block rates.

### Mutate
[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/ref.svg" width="130" />](./api.md#mutate)

FCL "mutate" does the work of building, signing, and sending a transaction behind the scenes. In order to mutate the blockchain state using FCL, you need to do the following:

```javascript
import * as fcl from "@onflow/fcl"

await fcl.mutate({
  cadence: `
    transaction(a: Int) {
      prepare(acct: AuthAccount) {
        log(acct)
        log(a)
      }
    }
  `,
  args: (arg, t) => [
    arg(6, t.Int)
  ],
  limit: 50
})
```

Flow supports great flexibility when it comes to transaction signing, we can define multiple authorizers (multi-sig transactions) and have different payer account than proposer. We will explore advanced signing scenarios bellow.

### [Single party, single signature](../../../build/basics/transactions.md#single-party-single-signature)

- Proposer, payer and authorizer are the same account (`0x01`).
- Only the envelope must be signed.
- Proposal key must have full signing weight.

| Account | Key ID | Weight |
| ------- | ------ | ------ |
| `0x01`  | 1      | 1000   |

```javascript
// There are multiple ways to acheive this
import * as fcl from "@onflow/fcl"

// FCL provides currentUser as an authorization function
await fcl.mutate({
  cadence: `
    transaction {
      prepare(acct: AuthAccount) {}
    }
  `,
  proposer: currentUser,
  payer: currentUser,
  authorizations: [currentUser],
  limit: 50,
})

// Or, simplified

mutate({
  cadence: `
    transaction {
      prepare(acct: AuthAccount) {}
    }
  `,
  authz: currentUser, // Optional. Will default to currentUser if not provided.
  limit: 50,
})


// Or, create a custom authorization function
const authzFn = async (txAccount) => {
  return {
    ...txAccount,
    addr: "0x01",
    keyId: 0,
    signingFunction: async(signable) => {
      return {
        addr: "0x01",
        keyId: 0,
        signature
      }
    }
  }
}

mutate({
  cadence: `
    transaction {
      prepare(acct: AuthAccount) {}
    }
  `,
  proposer: authzFn,
  payer: authzFn,
  authorizations: [authzFn],
  limit: 50,
})
```

### [Single party, multiple signatures](../../../build/basics/transactions.md#single-party-multiple-signatures)

- Proposer, payer and authorizer are the same account (`0x01`).
- Only the envelope must be signed.
- Each key has weight 500, so two signatures are required.

| Account | Key ID | Weight |
| ------- | ------ | ------ |
| `0x01`  | 1      | 500    |
| `0x01`  | 2      | 500    |

**[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/try.svg" width="130" />](https://github.com/onflow/flow-go-sdk/tree/master/examples#single-party-multiple-signatures)**
```javascript
import * as fcl from "@onflow/fcl"

const authzFn = async (txAccount) => {
  return [
    {
      ...txAccount,
      addr: "0x01",
      keyId: 0,
      signingFunction: async(signable) => {
        return {
          addr: "0x01",
          keyId: 0,
          signature
        }
      }
    },
    {
      ...txAccount,
      addr: "0x01",
      keyId: 1,
      signingFunction: async(signable) => {
        return {
          addr: "0x01",
          keyId: 1,
          signature
        }
      }
    }
  ]
}

mutate({
  cadence: `
    transaction {
      prepare(acct: AuthAccount) {}
    }
  `,
  proposer: authzFn,
  payer: authzFn,
  authorizations: [authzFn],
  limit: 50,
})
```

### [Multiple parties](../../../build/basics/transactions.md#multiple-parties)

- Proposer and authorizer are the same account (`0x01`).
- Payer is a separate account (`0x02`).
- Account `0x01` signs the payload.
- Account `0x02` signs the envelope.
    - Account `0x02` must sign last since it is the payer.

| Account | Key ID | Weight |
| ------- | ------ | ------ |
| `0x01`  | 1      | 1000   |
| `0x02`  | 3      | 1000   |

**[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/try.svg" width="130" />](https://github.com/onflow/flow-go-sdk/tree/master/examples#multiple-parties)**
```javascript
import * as fcl from "@onflow/fcl"

const authzFn = async (txAccount) => {
  return {
    ...txAccount,
    addr: "0x01",
    keyId: 0,
    signingFunction: async(signable) => {
      return {
        addr: "0x01",
        keyId: 0,
        signature
      }
    }
  }
}

const authzTwoFn = async (txAccount) => {
  return {
    ...txAccount,
    addr: "0x02",
    keyId: 0,
    signingFunction: async(signable) => {
      return {
        addr: "0x02",
        keyId: 0,
        signature
      }
    }
  }
}

mutate({
  cadence: `
    transaction {
      prepare(acct: AuthAccount) {}
    }
  `,
  proposer: authzFn,
  payer: authzTwoFn,
  authorizations: [authzFn],
  limit: 50,
})
```

### [Multiple parties, two authorizers](../../../build/basics/transactions.md#multiple-parties)

- Proposer and authorizer are the same account (`0x01`).
- Payer is a separate account (`0x02`).
- Account `0x01` signs the payload.
- Account `0x02` signs the envelope.
    - Account `0x02` must sign last since it is the payer.
- Account `0x02` is also an authorizer to show how to include two AuthAccounts into an transaction

| Account | Key ID | Weight |
| ------- | ------ | ------ |
| `0x01`  | 1      | 1000   |
| `0x02`  | 3      | 1000   |

**[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/try.svg" width="130" />](https://github.com/onflow/flow-go-sdk/tree/master/examples#multiple-parties-two-authorizers)**
```javascript
import * as fcl from "@onflow/fcl"

const authzFn = async (txAccount) => {
  return {
    ...txAccount,
    addr: "0x01",
    keyId: 0,
    signingFunction: async(signable) => {
      return {
        addr: "0x01",
        keyId: 0,
        signature
      }
    }
  }
}

const authzTwoFn = async (txAccount) => {
  return {
    ...txAccount,
    addr: "0x02",
    keyId: 0,
    signingFunction: async(signable) => {
      return {
        addr: "0x02",
        keyId: 0,
        signature
      }
    }
  }
}

mutate({
  cadence: `
    transaction {
      prepare(acct: AuthAccount, acct2: AuthAccount) {}
    }
  `,
  proposer: authzFn,
  payer: authzTwoFn,
  authorizations: [authzFn, authzTwoFn],
  limit: 50,
})
```

### [Multiple parties, multiple signatures](../../../build/basics/transactions.md#multiple-parties)

- Proposer and authorizer are the same account (`0x01`).
- Payer is a separate account (`0x02`).
- Account `0x01` signs the payload.
- Account `0x02` signs the envelope.
    - Account `0x02` must sign last since it is the payer.
- Both accounts must sign twice (once with each of their keys).

| Account | Key ID | Weight |
| ------- | ------ | ------ |
| `0x01`  | 1      | 500    |
| `0x01`  | 2      | 500    |
| `0x02`  | 3      | 500    |
| `0x02`  | 4      | 500    |

```javascript
import * as fcl from "@onflow/fcl"

const authzFn = async (txAccount) => {
  return [
    {
      ...txAccount,
      addr: "0x01",
      keyId: 0,
      signingFunction: async(signable) => {
        return {
          addr: "0x01",
          keyId: 0,
          signature
        }
      }
    },
    {
      ...txAccount,
      addr: "0x01",
      keyId: 1,
      signingFunction: async(signable) => {
        return {
          addr: "0x01",
          keyId: 1,
          signature
        }
      }
    }
  ]
}

const authzTwoFn = async (txAccount) => {
  return [
    {
      ...txAccount,
      addr: "0x02",
      keyId: 0,
      signingFunction: async(signable) => {
        return {
          addr: "0x02",
          keyId: 0,
          signature
        }
      }
    },
    {
      ...txAccount,
      addr: "0x02",
      keyId: 1,
      signingFunction: async(signable) => {
        return {
          addr: "0x02",
          keyId: 1,
          signature
        }
      }
    }
  ]
}

mutate({
  cadence: `
    transaction {
      prepare(acct: AuthAccount) {}
    }
  `,
  proposer: authzFn,
  payer: authzTwoFn,
  authorizations: [authzFn],
  limit: 50,
})
```

After a transaction has been [built](./sdk-guidelines.mdx#build-transactions) and [signed](./sdk-guidelines.mdx#sign-transactions), it can be sent to the Flow blockchain where it will be executed. If sending was successful you can then [retrieve the transaction result](./sdk-guidelines.mdx#get-transactions).
# Transactions

Transactions let you send Cadence code to the Flow blockchain that permanently alters its state.

We are assuming you have read the [Scripts Documentation](./scripts.mdx) before this, as transactions are sort of scripts with more required things.

While `query` is used for sending scripts to the chain, `mutate` is used for building and sending transactions. Just like [scripts](./scripts.mdx), `fcl.mutate` is a [JavaScript Tagged Template Literal](https://styled-components.com/docs/advanced#tagged-template-literals) that we can pass Cadence code into.

Unlike scripts, they require a little more information, things like a proposer, authorizations and a payer, which may be a little confusing and overwhelming.

# Sending your first Transaction

There is a lot to unpack in the following code snippet.
It sends a transaction to the Flow blockchain. For the transaction, the current user is authorizing it as both the `proposer` and the `payer`.
Something that is unique to Flow is the one paying for the transaction doesn't always need to be the one performing the transaction.
Proposers and Payers are special kinds of authorizations that are always required for a transaction.
The `proposer` acts similar to the `nonce` in Ethereum transactions, and helps prevent repeat attacks.
The `payer` is who will be paying for the transaction.
If these are not set, FCL defaults to using the current user for all roles.

`fcl.mutate` will return a `transactionId`. We can pass the response directly to `fcl.tx` and then use the `onceSealed` method which resolves a promise when the transaction is sealed.

```javascript
import * as fcl from "@onflow/fcl"

const transactionId = await fcl.mutate({
  cadence: `
    transaction {
      execute {
        log("Hello from execute")
      }
    }
  `,
  proposer: fcl.currentUser,
  payer: fcl.currentUser,
  limit: 50
})

const transaction = await fcl.tx(transactionId).onceSealed()
console.log(transaction) // The transactions status and events after being sealed
```

# Authorizing a transaction

The below code snippet is the same as the above one, except for one extremely important difference.
Our Cadence code this time has a prepare statement, and we are using the `fcl.currentUser` when constructing our transaction.

The `prepare` statement's arguments directly map to the order of the authorizations in the `authorizations` array.
Four authorizations means four `AuthAccount`s as arguments passed to `prepare`. In this case though there is only one, and it is the `currentUser`.

These authorizations are important as you can only access/modify an accounts storage if you have the said accounts authorization.

```javascript
import * as fcl from "@onflow/fcl"

const transactionId = await fcl.mutate({
  cadence: `
    transaction {
      prepare(acct: AuthAccount) {
        log("Hello from prepare")
      }
      execute {
        log("Hello from execute")
      }
    }
  `,
  proposer: fcl.currentUser,
  payer: fcl.currentUser,
  authorizations: [fcl.currentUser],
  limit: 50
})

const transaction = await fcl.tx(transactionId).onceSealed()
console.log(transaction) // The transactions status and events after being sealed
```

To learn more about `mutate`, check out the [API documentation](./api.md#mutate).
---
title: Signing and Verifying Arbitrary Data
---

## Signing Arbitrary Data

Cryptographic signatures are a key part of the blockchain. They are used to prove ownership of an address without exposing its private key. While primarily used for signing transactions, cryptographic signatures can also be used to sign arbitrary messages.

FCL has a feature that lets you send arbitrary data to a configured wallet/service where the user may approve signing it with their private key/s.

## Verifying User Signatures

What makes message signatures more interesting is that we can use Flow blockchain to verify the signatures. Cadence has a built-in function  `publicKey.verify` that will verify a signature against a Flow account given the account address.

FCL includes a utility function, `AppUtils.verifyUserSignatures`, for verifying one or more signatures against an account's public key on the Flow blockchain.

You can use both in tandem to prove a user is in control of a private key or keys.

This enables cryptographically-secure login flow using a message-signing-based authentication mechanism with a user’s public address as their identifier.

---

## `currentUser.signUserMessage()`

A method to use allowing the user to personally sign data via FCL Compatible Wallets/Services.

> :Note: **Requires authentication/configuration with an authorized signing service.**

### Arguments

| Name      | Type   | Description                       |
| --------- | ------ | --------------------------------- |
| `message` | string | A hexadecimal string to be signed |

#### Returns

| Type    | Description                                                                                                                                                                               |
| ------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Array` | An Array of [CompositeSignatures](https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/src/wallet-provider-spec/draft-v2.md#compositesignature): {`addr`, `keyId`, `signature`} |

#### Usage

```javascript
import * as fcl from "@onflow/fcl"

const signMessage = async () => {
  const MSG = Buffer.from("FOO").toString("hex")
  try {
    return await fcl.currentUser.signUserMessage(MSG)
  } catch (error) {
    console.log(error)
  }
}
```

---

## `AppUtils.verifyUserSignatures`

#### Note

⚠️ `fcl.config.flow.network` or options override is required to use this API. See [FCL Configuration](#configuration).

A method allowing applications to cryptographically verify the ownership of a Flow account by verifying a message was signed by a user's private key/s. This is typically used with the response from `currentUser.signUserMessage`.

### Arguments

| Name                  | Type                  | Description                       |
| --------------------- | --------------------- | --------------------------------- |
| `message`             | string **(required)** | A hexadecimal string              |
| `compositeSignatures` | Array **(required)**  | An Array of `CompositeSignatures` |
| `opts`                | Object **(optional)** | `opts.fclCryptoContract` can be provided to override FCLCryptoContract address for local development                 |

#### Returns

| Type    | Description                  |
| ------- | ---------------------------- |
| Boolean | `true` if verified or `false` |

#### Usage

```javascript
/**
 * Verify a valid signature/s for an account on Flow.
 *
 * @param {string} msg - A message string in hexadecimal format
 * @param {Array} compSigs - An array of Composite Signatures
 * @param {string} compSigs[].addr - The account address
 * @param {number} compSigs[].keyId - The account keyId
 * @param {string} compSigs[].signature - The signature to verify
 * @param {Object} [opts={}] - Options object
 * @param {string} opts.fclCryptoContract - An optional override of Flow account address where the FCLCrypto contract is deployed
 * @return {bool}
 *
 * @example
 *
 *  const isValid = await fcl.AppUtils.verifyUserSignatures(
 *    Buffer.from('FOO').toString("hex"),
 *    [{f_type: "CompositeSignature", f_vsn: "1.0.0", addr: "0x123", keyId: 0, signature: "abc123"}],
 *    {fclCryptoContract}
 *  )
 */
```

#### Examples

Use cases include cryptographic login, message validation, verifiable credentials, and others.

---
---
title: Add FCL Support for WalletConnect 2.0
---

# Add FCL Support for WalletConnect 2.0

To improve developer experience and streamline **Flow** dApp integration with **WalletConnect 2.0** wallets, **FCL `^1.3.0`** introduces support for **`discovery-service`** plugins. These **`ServicePlugins`** allow for injection of client configured **services**, service **methods**, and the execution **strategies** required to interact with them.
FCL dApps can opt-in through use of the [**fcl-wc**](https://www.npmjs.com/package/@onflow/fcl-wc) package and **FCL Plugin Registry**.

When using FCL Discovery for authentication, dApps are able to support most FCL-compatible wallets and their users on Flow without any custom integrations or changes needed to the dApp code. 

These instructions explain how dApps can also add support for FCL compatible wallets that use the WalletConnect 2.0 protocol.

## How does it work?

- The **`fc-wc`** package is used to initialize a **WalletConnect 2.0** [**`SignClient`**](https://docs.walletconnect.com/2.0/introduction/sign) instance, and build a **`discovery-service`** **`ServicePlugin`** based on dApp specified options.
- **`discovery-service`** plugins are used to add opt-in wallets and other services to **FCL Wallet Discovery** (UI/API).
- The **FCL Plugin Registry** offers dApps the ability to add new services, methods, and the execution strategies needed to interact with them.

### Requirements

- `fcl` version >= `1.3.0`
- `fcl-wc` version >= `1.0.0`

### Implementation path

|     |    |    |
| :-: | :- | :- |
| [**1**](#1-add-required-packages) | Add required packages | Install and import minimum `fcl` and `fcl-wc` [versions](#requirements)|
| [**2**](#2-obtain-a-walletconnect-projectid) | Obtain a WalletConnect `projectID` | Visit [WalletConnect Cloud Registry](https://cloud.walletconnect.com/) and register for public relay server access and an application `projectId` |
| [**3**](#3-initialize-walletconnect-signclient-and-fclwcserviceplugin) | Initialize WalletConnect `SignClient` and `FclWcServicePlugin` | Initialize WalletConnect `SignClient` and `FclWcServicePlugin` with [configuration options](#configuration-options) |
| [**4**](#4-add-fclwcserviceplugin-to-fcl-plugin-registry) | Add `FclWcServicePlugin` to FCL Plugin Registry | Inject `FclWcServicePlugin` via `fcl.pluginRegistry.add(FclWcServicePlugin)` |

### 1. Add required packages

Install the `fcl` and `fcl-wc` packages:

```bash
npm install @onflow/fcl@ @onflow/fcl-wc
```

### 2. Obtain a WalletConnect projectID

Visit [WalletConnect Cloud Registry](https://cloud.walletconnect.com/) and register for public relay server access and an application **`projectId`**.

### 3. Initialize WalletConnect `SignClient` and `FclWcServicePlugin`

In addition to the WalletConnect `SignClient`, the `init` method of `fcl-wc` returns a [`ServicePlugin`](#serviceplugin-spec) object. This object can be injected using the [FCL Plugin Registry](#pluginregistry) to add support for new service methods and their corresponding execution strategies (like `WC/RPC` for WalletConnect ).
A `discovery-service` `ServicePlugin` may also include additional opt-in wallets to offer your users through FCL Wallet Discovery.

#### Configuration options

Initialize WalletConnect `SignClient` and `FclWcServicePlugin` with the following configuration options:

| Name       | Type    | Default | Description                                                                    |
| ---------- | ------- | ------- | ------------------------------------------------------------------------------ |
| `projectId` | boolean **(required)** | null   | A WalletConnect projectId for public relay server access. Your Project ID can be obtained from [WalletConnect Cloud Dashboard](https://cloud.walletconnect.com/app)  |
| `metadata` | object | `{ }`  | Optional dApp metadata to describe your application and define its appearance in a web browser. More details can be found [here](https://docs.walletconnect.com/2.0/swift/sign/dapp-usage) |
| `includeBaseWC` | boolean | false   | Optional configuration to include a generic WalletConnect service in FCL Discovery (UI/API). <br /> :exclamation: BaseWC Service offers no deeplink support for mobile. |
| `wcRequestHook` | function | null  | Optional function is called on all desktop WalletConnect client session proposals and signing requests. Use this to handle alerting user to check wallet for approval. |
| `pairingModalOverride` | function | null  | Optional function called to allow override of included QRCodeModal. Function receives two arguments: <br /> 1. Connection `uri` to display QR code or send to wallet to create pairing. <br /> 2. Callback function to manually cancel the request. |
| `wallets` | array | `[ ]` | Optional list of WalletConnect `authn` services to include in FCL Wallet Discovery (UI/API). <br /> :exclamation: Only available for use on **`testnet`**. These services will be combined with wallets returned from [WalletConnect cloud registry API](https://cloud.walletconnect.com/) and sent to Discovery for display in UI and inclusion in API response. |

#### Returns

|  Name  |  Type  |  Description  |
| ----- | ------- | ---------- |
| [FclWcServicePlugin](#fclwcserviceplugin) | `ServicePlugin` | A `ServicePlugin` of type `discovery-service`.  May also include optional `authn` services to offer through FCL Wallet Discovery (UI/API). |
| [client](#) | `SignClient` | An initialized WalletConnect [`SignClient`](https://docs.walletconnect.com/2.0/introduction/sign). |

```js
const FclWcServicePlugin = {
  name: "fcl-plugin-service-walletconnect",
  f_type: "ServicePlugin",   // the type of FCL plugin
  type: "discovery-service", // the is a service sent to Discovery
  services: [Service],       // (optional) Generic, Cloud Registry and client injected WalletConnect services
  serviceStrategy: {method: "WC/RPC", exec: execStrategy, // the method name and execution strategy for WalletConnect services
}
```

:exclamation: Setting FCL config `flow.network` to **`testnet`** or **`mainnet`** is required to use `fcl-wc` as it enables `"WC/RPC"` service strategy to request correct chain permissions.

```
import {config} from '@onflow/config'

config({
    "flow.network": "mainnet"
})
```

See [FCL Configuration](./configure-fcl.mdx) for more information.



### 4. Add FclWcServicePlugin to FCL Plugin Registry

In addition to the WalletConnect `SignClient`, the `init` method of `fcl-wc` returns a [`ServicePlugin`](#serviceplugin-spec) object. This object can be injected into the FCL Plugin Registry to add FCL support for new service methods, (like WC/RPC for WalletConnect) and their corresponding execution strategies.

#### Usage

```js
import * as fcl from "@onflow/fcl"
import { init } from "fcl-wc"

const { FclWcServicePlugin, client } = await init({
  projectId: WC_PROJECT_ID, // required
  metadata: WC_APP_METADATA, // optional
  includeBaseWC: false, // optional, default: false
  wallets: [], // optional, default: []
  wcRequestHook: (wcRequestData) => { // optional,default: null
    handlePendingRequest(data)
  },
  pairingModalOverride: (uri, rejectPairingRequest) => { // optional,default: null
    handlePendingPairingRequest(data)
  }
})

fcl.pluginRegistry.add(FclWcServicePlugin)
```

---

### ServicePlugin Spec


| Key         | Value Type | Description                   |
| ----------- | ---------- | ----------------------------- |
| `name`        | string     | The name of the plugin.         |
| `f_type`  | string     | The type of plugin (currently only supports `ServicePlugin` type). |
| `type`    | string     | The plugin subtype (currently only supports `discovery-service` type). |
| `services` | array     | A list of services to add to FCL. |
| `serviceStrategy` | `{ method: string, exec: function }`     | The method and corresponding strategy FCL uses to interact with the service. A service with the `service.method` property set to `"WC/RPC"` tells FCL to use the corresponding service strategy if it is supported by the dApp. |

---

## Integrating With Wallet Discovery

Knowing all the wallets available to users on a blockchain can be challenging. FCL's Discovery mechanism relieves much of the burden of integrating with Flow compatible wallets and let's developers focus on building their dApp and providing as many options as possible to their users.

There are two ways an app can use [Wallet Discovery](https://github.com/onflow/fcl-js/blob/master/docs/reference/discovery.mdx):

1. The UI version which can be configured for display via iFrame, Popup, or Tab.

2. The API version which allows you to access authentication services directly in your code via `fcl.discovery.authn` method which we'll describe below.

When using FCL Wallet Discovery for authentication, dApps are able to support FCL-compatible wallets on Flow without any custom integrations or changes needed to the dApp code.

#### `discovery-service` ServicePlugin

`FclWcServicePlugin` is a `ServicePlugin` of type `discovery-service`. `discovery-service` plugins may include additional authentication services to offer through FCL Wallet Discovery.

Once a valid `discovery-service` plugin is registered, FCL shares client supported services with Discovery to add registered and injected wallets to the UI and API. 

To connect a Flow supported wallet using WalletConnect 2.0, users of your dApp will go through the authentication process and have the option to select their preferred wallet.

:exclamation: Once a WalletConnect session is established and a `currentUser` is authenticated, FCL will handle client pairings and sessions during FCL `authn`, and initiate signing requests as part of `authz` using `fcl.mutate` and [`user-sign`](https://github.com/onflow/fcl-js/blob/master/docs/reference/user-signatures.mdx) using `fcl.signUserMessage`.

### How to add your FCL compatible WalletConnect wallet to Discovery (UI/API)

1. [Submit a PR](https://github.com/onflow/fcl-discovery/blob/master/data/services.json) to add your wallet to FCL Wallet Discovery `services.json`
2. Submit your FCL compatible wallet to [WalletConnect Cloud Registry](https://cloud.walletconnect.com/)
3. Add Wallet Service to `fcl-wc` init options. :exclamation: testnet only.

FCL tells Wallet Discovery which services are supported by the client (installed extensions and `discovery-service` `ServicePlugins`) so only those supported will be shown in Discovery UI or returned via Discovery API.

![Wallet Discovery UI](./images/wc-discovery.png)

## Wallet Provider Spec

### Implementation path

|     |    |    |
| :-: | :- | :- |
| **1** | Obtain a WalletConnect `projectId` |  Register to receive a `projectId` from the [WalletConnect Cloud Registry](https://cloud.walletconnect.com/). |
| **2** | Conform to [FCL Wallet Provider Spec](https://github.com/onflow/fcl-js/blob/master/packages/fcl/src/wallet-provider-spec/draft-v4.md) | Compatible wallets must support `flow_authn`, `flow_authz`, and `flow_user_sign` methods and wrap data in the appropriate FCL Response type. Services returned with the `AuthnResponse` of `flow_authn` should set `service.endpoint` to corresponding methods.<br/> **ServiceType** `authz` : `flow_authz` <br/> **ServiceType** `user-signature` : `flow_user_sign`
| **3** | Add wallet to WalletConnect Cloud Registry API **(optional)** | Submit your wallet to be included in the [WalletConnect Cloud Registry API and Explorer](https://explorer.walletconnect.com/) |
| **4** | Responses | All responses need to be wrapped in a [`PollingResponse`](https://github.com/onflow/fcl-js/blob/master/packages/fcl/src/wallet-provider-spec/draft-v4.md#pollingresponse) |

#### Metadata requirements

:exclamation: In order to correctly identify, improve pairing, and include deep link support for mobile, services using the `WC/RPC` method need to use the same universal link as their `uid` and `url` in Wallet metadata.
Wallets sourced from WalletConnect Cloud Registry automatically build the service from data and will set the `service.uid` to the universal link.

```javascript

import SignClient from '@walletconnect/sign-client'

export let signClient: SignClient

export async function createSignClient() {
  signClient = await SignClient.init({
    projectId: PROJECT_ID,
    relayUrl: 'wss://relay.walletconnect.com',
    metadata: {
      name: 'Awesome Wallet',
      description: 'Awesome Wallet with FCL Support for WalletConnect',
      url: 'https://deeplink.awesome-wallet.com/',
      icons: ['https://avatars.githubusercontent.com/u/37784886']
    }
  })
}

```

## Next steps

1. Read the [FCL Wallet Provider Spec](https://github.com/onflow/fcl-js/blob/master/packages/fcl/src/wallet-provider-spec/draft-v4.md).
2. Check out the a WalletConnect 2.0 [React POC Wallet](https://github.com/gregsantos/flow-walletconnect-v2-react-wallet) and [FCL Flow dApp](https://github.com/gregsantos/flow-walletconnect-v2-react-dapp) with support for WalletConnect v2.0.
3. Read and review the [WalletConnect 2.0 Docs](https://docs.walletconnect.com/2.0/), [examples and resources](https://docs.walletconnect.com/2.0/introduction/examples-and-resources).
# Error Codes

List of error codes returned from failing transactions and scripts. The error code has an accompanied error message that usually gives more clarification. This list is meant to give more information and helpful hints.
[Code file](https://github.com/onflow/flow-go/blob/master/fvm/errors/codes.go)

### 1006
**ErrCodeInvalidProposalSignatureError**

Example: 
`
...
`



### 1007
**ErrCodeInvalidProposalSeqNumberError**

Example: 
`
[Error Code: 1007] invalid proposal key: public key 0 on account xxx has sequence number xxx, but given xxx
`




### 1008
**ErrCodeInvalidPayloadSignatureError**

Example: 
`
[Error Code: 1008] invalid payload signature: public key 0 on account xxx does not have a valid signature: signature is not valid
`




### 1009
**ErrCodeInvalidEnvelopeSignatureError**

Example: 
`
[Error Code: 1009] invalid envelope key: public key 1 on account xxx does not have a valid signature: signature is not valid
`




### 1051
**ErrCodeValueError**

Example: 
`
[Error Code: 1051] invalid value (xxx): invalid encoded public key value: rlp: expected input list for flow.runtimeAccountPublicKeyWrapper...
`



### 1052
**ErrCodeInvalidArgumentError**

Example: 
`
[Error Code: 1052] transaction arguments are invalid: (argument is not json decodable: failed to decode value: runtime error: slice bounds out of range [:2] with length 0)
`



### 1053
**ErrCodeInvalidAddressError**

Example: 
`
...
`



### 1054
**ErrCodeInvalidLocationError**

Example: 
`
[Error Code: 1054] location (../contracts/FungibleToken.cdc) is not a valid location: expecting an AddressLocation, but other location types are passed ../contracts/FungibleToken.cdc
`



### 1055
**ErrCodeAccountAuthorizationError**

Example: 
`
[Error Code: 1055] authorization failed for account e85d442d61a611d8: payer account does not have sufficient signatures (1 < 1000)
`



### 1056
**ErrCodeOperationAuthorizationError**

Example: 
`
[Error Code: 1056] (RemoveContract) is not authorized: removing contracts requires authorization from specific accounts goroutine 5688834491 [running]:
`



### 1057
**ErrCodeOperationNotSupportedError**

Example: 
`
...
`



### 1101
**ErrCodeCadenceRunTimeError**

Example: 
`
[Error Code: 1101] cadence runtime error Execution failed: error: pre-condition failed: Amount withdrawn must be less than or equal than the balance of the Vault
`



### 1103
**ErrCodeStorageCapacityExceeded**

Example: 
`
[Error Code: 1103] The account with address (xxx) uses 96559611 bytes of storage which is over its capacity (96554500 bytes). Capacity can be increased by adding FLOW tokens to the account.
`



### 1105
**ErrCodeEventLimitExceededError**

Example: 
`
[Error Code: 1105] total event byte size (256200) exceeds limit (256000)
`



### 1106
**ErrCodeLedgerInteractionLimitExceededError**

Example: 
`
[Error Code: 1106] max interaction with storage has exceeded the limit (used: 20276498 bytes, limit 20000000 bytes)
`



### 1107
**ErrCodeStateKeySizeLimitError**

Example: 
`
...
`




### 1108
**ErrCodeStateValueSizeLimitError**

Example: 
`
...
`


### 1109
**ErrCodeTransactionFeeDeductionFailedError**

Example: 
`
[Error Code: 1109] failed to deduct 0 transaction fees from 14af75b8c487333c: Execution failed: f919ee77447b7497.FlowFees:97:24
`



### 1110
**ErrCodeComputationLimitExceededError**

Example: 
`
[Error Code: 1110] computation exceeds limit (100)
`



### 1111
**ErrCodeMemoryLimitExceededError**

Example: 
`
...
`


### 1112
**ErrCodeCouldNotDecodeExecutionParameterFromState**

Example: 
`
...
`


### 1113
**ErrCodeScriptExecutionTimedOutError**

Example: 
`
...
`

### 1114
**ErrCodeScriptExecutionCancelledError**

Example: 
`
...
`

### 1115
**ErrCodeEventEncodingError**

Example: 
`
...
`



### 1116
**ErrCodeInvalidInternalStateAccessError**

Example: 
`
...
`

### 1118
**ErrCodeInsufficientPayerBalance**

Example: 
`
 [Error Code: 1118] payer ... has insufficient balance to attempt transaction execution (required balance: 0.00100000)
`


### 1201
**ErrCodeAccountNotFoundError**

Example: 
`
[Error Code: 1201] account not found for address xxx
`



### 1202
**ErrCodeAccountPublicKeyNotFoundError**

Example: 
`
[Error Code: 1202] account public key not found for address xxx and key index 3
`



### 1203
**ErrCodeAccountAlreadyExistsError**

Example: 
`
...
`


### 1204
**ErrCodeFrozenAccountError**

Example: 
`
...
`



### 1206
**ErrCodeAccountPublicKeyLimitError**

Example: 
`
...
`



### 1251
**ErrCodeContractNotFoundError**

Example: 
`
...
`



### 2000
**FailureCodeUnknownFailure**

Example: 
`
...
`


### 2001
**FailureCodeEncodingFailure**

Example: 
`
...
`



### 2002
**FailureCodeLedgerFailure**

Example: 
`
...
`



### 2003
**FailureCodeStateMergeFailure**

Example: 
`
...
`



### 2004
**FailureCodeBlockFinderFailure**

Example: 
`
...
`

  
### 2006
**FailureCodeParseRestrictedModeInvalidAccessFailure**

Example: 
`
...
`


### 2007
**FailureCodePayerBalanceCheckFailure**

Example: 
`
...
`


---
title: Flow Go SDK
---

<div align="center">
  <a href="/tooling/intro">
    <img
      src="/images/tools/sdk-banner.svg"
      alt="Logo"
      width="300"
      height="auto"
    />
  </a>
  <p align="center">
    <br />
    <a href="https://github.com/onflow/flow-go-sdk">
      <strong>View on GitHub</strong>
    </a>
    <br />
    <br />
    <a href="../fcl-js/sdk-guidelines/">SDK Specifications</a>
    <a href="https://github.com/onflow/flow-go-sdk/blob/master/CONTRIBUTING.md">
      Contribute
    </a>
    <a href="https://github.com/onflow/flow-go-sdk/issues">Report a Bug</a>
  </p>
</div>
<br />

## Overview

This reference documents all the methods available in the SDK, and explains in detail how these methods work.
SDKs are open source, and you can use them according to the licence.

The library client specifications can be found here:

[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/ref.svg" width="130" />](https://pkg.go.dev/github.com/onflow/flow-go-sdk/client)

## Getting Started

### Installing

The recommended way to install Go Flow SDK is by using Go modules.

If you already initialized your Go project, you can run the following command in your terminal:

```sh
go get github.com/onflow/flow-go-sdk
```

It's usually good practice to pin your dependencies to a specific version.
Refer to the [SDK releases](https://github.com/onflow/flow-go-sdk/tags) page to identify the latest version.

### Importing the Library

After the library has been installed you can import it.

```go
import "github.com/onflow/flow-go-sdk"
```

## Connect

[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/ref.svg" width="130" />](https://pkg.go.dev/github.com/onflow/flow-go-sdk/client#New)

The Go SDK library uses HTTP or gRPC APIs to communicate with the access nodes and it must be configured with correct access node API URL.
The library provides default factories for connecting to Flow AN APIs and you can easily switch between HTTP or gRPC if you use the provided client interface.

You can check more examples for creating clients in the examples:
**[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/try.svg" width="130" />](https://github.com/onflow/flow-go-sdk/blob/master/examples/http_grpc_clients/main.go)**

Basic Example:

```go
// common client interface
var flowClient client.Client

// initialize an http emulator client
flowClient, err := http.NewClient(http.EmulatorHost)

// initialize a gPRC emulator client
flowClient, err = grpc.NewClient(grpc.EmulatorHost)
```

You can also initialize an HTTP client or gRPC client directly which will offer you access to network specific options,
but be aware you won't be able to easily switch between those since they don't implement a common interface. This is only
advisable if the implementation needs the access to those advanced options.
Advanced Example:

```go
// initialize http specific client
httpClient, err := http.NewHTTPClient(http.EMULATOR_URL)

// initialize grpc specific client
grpcClient, err := grpc.NewGRPCClient(
    grpc.EMULATOR_URL,
    grpcOpts.WithTransportCredentials(insecure.NewCredentials()),
)
```

## Querying the Flow Network

After you have established a connection with an access node, you can query the
Flow network to retrieve data about blocks, accounts, events and transactions. We will explore
how to retrieve each of these entities in the sections below.

### Get Blocks

[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/ref.svg" width="130" />](https://pkg.go.dev/github.com/onflow/flow-go-sdk/client#Client.GetBlockByHeight)

Query the network for block by id, height or get the latest block.

📖 **Block ID** is SHA3-256 hash of the entire block payload. This hash is stored as an ID field on any block response object (ie. response from `GetLatestBlock`).

📖 **Block height** expresses the height of the block on the chain. The latest block height increases by one for every valid block produced.

#### Examples

This example depicts ways to get the latest block as well as any other block by height or ID:

**[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/try.svg" width="130" />](https://github.com/onflow/flow-go-sdk/blob/master/examples/get_blocks/main.go)**

```go
func demo() {
    ctx := context.Background()
    flowClient := examples.NewFlowClient()

    // get the latest sealed block
    isSealed := true
    latestBlock, err := flowClient.GetLatestBlock(ctx, isSealed)
    printBlock(latestBlock, err)

    // get the block by ID
    blockID := latestBlock.ID.String()
    blockByID, err := flowClient.GetBlockByID(ctx, flow.HexToID(blockID))
    printBlock(blockByID, err)

    // get block by height
    blockByHeight, err := flowClient.GetBlockByHeight(ctx, 0)
    printBlock(blockByHeight, err)
}

func printBlock(block *flow.Block, err error) {
    examples.Handle(err)

    fmt.Printf("\nID: %s\n", block.ID)
    fmt.Printf("height: %d\n", block.Height)
    fmt.Printf("timestamp: %s\n\n", block.Timestamp)
}
```

Result output:

```bash
ID: 835dc83939141097aa4297aa6cf69fc600863e3b5f9241a0d7feac1868adfa4f
height: 10
timestamp: 2021-10-06 15:06:07.105382 +0000 UTC


ID: 835dc83939141097aa4297aa6cf69fc600863e3b5f9241a0d7feac1868adfa4f
height: 10
timestamp: 2021-10-06 15:06:07.105382 +0000 UTC


ID: 7bc42fe85d32ca513769a74f97f7e1a7bad6c9407f0d934c2aa645ef9cf613c7
height: 0
timestamp: 2018-12-19 22:32:30.000000042 +0000 UTC
```

### Get Account

[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/ref.svg" width="130" />](https://pkg.go.dev/github.com/onflow/flow-go-sdk/client#Client.GetAccount)

Retrieve any account from Flow network's latest block or from a specified block height.
The `GetAccount` method is actually an alias for the get account at latest block method.

📖 **Account address** is a unique account identifier. Be mindful about the `0x` prefix, you should use the prefix as a default representation but be careful and safely handle user inputs without the prefix.

An account includes the following data:

- Address: the account address.
- Balance: balance of the account.
- Contracts: list of contracts deployed to the account.
- Keys: list of keys associated with the account.

#### Examples

Example depicts ways to get an account at the latest block and at a specific block height:

**[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/try.svg" width="130" />](https://github.com/onflow/flow-go-sdk/blob/master/examples/get_accounts/main.go)**

```go
func demo() {
    ctx := context.Background()
    flowClient := examples.NewFlowClient()

    // get account from the latest block
    address := flow.HexToAddress("f8d6e0586b0a20c7")
    account, err := flowClient.GetAccount(ctx, address)
    printAccount(account, err)

    // get account from the block by height 0
    account, err = flowClient.GetAccountAtBlockHeight(ctx, address, 0)
    printAccount(account, err)
}

func printAccount(account *flow.Account, err error) {
    examples.Handle(err)

    fmt.Printf("\nAddress: %s", account.Address.String())
    fmt.Printf("\nBalance: %d", account.Balance)
    fmt.Printf("\nContracts: %d", len(account.Contracts))
    fmt.Printf("\nKeys: %d\n", len(account.Keys))
}
```

Result output:

```bash
Address: f8d6e0586b0a20c7
Balance: 999999999999600000
Contracts: 2
Keys: 1

Address: f8d6e0586b0a20c7
Balance: 999999999999600000
Contracts: 2
Keys: 1
```

### Get Transactions

[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/ref.svg" width="130" />](https://pkg.go.dev/github.com/onflow/flow-go-sdk/client#Client.GetTransaction)

Retrieve transactions from the network by providing a transaction ID. After a transaction has been submitted, you can also get the transaction result to check the status.

📖 **Transaction ID** is a hash of the encoded transaction payload and can be calculated before submitting the transaction to the network.

⚠️ The transaction ID provided must be from the current spork.

📖 **Transaction status** represents the state of transaction in the blockchain. Status can change until it is sealed.

| Status    | Final | Description                                                              |
| --------- | ----- | ------------------------------------------------------------------------ |
| UNKNOWN   | ❌    | The transaction has not yet been seen by the network                     |
| PENDING   | ❌    | The transaction has not yet been included in a block                     |
| FINALIZED | ❌    | The transaction has been included in a block                             |
| EXECUTED  | ❌    | The transaction has been executed but the result has not yet been sealed |
| SEALED    | ✅    | The transaction has been executed and the result is sealed in a block    |
| EXPIRED   | ✅    | The transaction reference block is outdated before being executed        |

**[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/try.svg" width="130" />](https://github.com/onflow/flow-go-sdk/blob/master/examples/get_transactions/main.go)**

```go
func demo(txID flow.Identifier) {
    ctx := context.Background()
    flowClient := examples.NewFlowClient()

    tx, err := flowClient.GetTransaction(ctx, txID)
    printTransaction(tx, err)

    txr, err := flowClient.GetTransactionResult(ctx, txID)
    printTransactionResult(txr, err)
}

func printTransaction(tx *flow.Transaction, err error) {
    examples.Handle(err)

    fmt.Printf("\nID: %s", tx.ID().String())
    fmt.Printf("\nPayer: %s", tx.Payer.String())
    fmt.Printf("\nProposer: %s", tx.ProposalKey.Address.String())
    fmt.Printf("\nAuthorizers: %s", tx.Authorizers)
}

func printTransactionResult(txr *flow.TransactionResult, err error) {
    examples.Handle(err)

    fmt.Printf("\nStatus: %s", txr.Status.String())
    fmt.Printf("\nError: %v", txr.Error)
}
```

Example output:

```bash
ID: fb1272c57cdad79acf2fcf37576d82bf760e3008de66aa32a900c8cd16174e1c
Payer: f8d6e0586b0a20c7
Proposer: f8d6e0586b0a20c7
Authorizers: []
Status: SEALED
Error: <nil>
```

### Get Events

[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/ref.svg" width="130" />](https://pkg.go.dev/github.com/onflow/flow-go-sdk/client#Client.GetEventsForBlockIDs)

Retrieve events by a given type in a specified block height range or through a list of block IDs.

📖 **Event type** is a string that follow a standard format:

```
A.{contract address}.{contract name}.{event name}
```

Please read more about [events in the documentation](../../../references/core-contracts/03-flow-token.md). The exception to this standard are
core events, and you should read more about them in [this document](https://cadence-lang.org/docs/language/core-events).

📖 **Block height range** expresses the height of the start and end block in the chain.

#### Examples

Example depicts ways to get events within block range or by block IDs:

**[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/try.svg" width="130" />](https://github.com/onflow/flow-go-sdk/blob/master/examples/get_events/main.go)**

```go
func demo(deployedContract *flow.Account, runScriptTx *flow.Transaction) {
    ctx := context.Background()
    flowClient := examples.NewFlowClient()

    // Query for account creation events by type
    result, err := flowClient.GetEventsForHeightRange(ctx, "flow.AccountCreated", 0, 30)
    printEvents(result, err)

    // Query for our custom event by type
    customType := fmt.Sprintf("AC.%s.EventDemo.EventDemo.Add", deployedContract.Address.Hex())
    result, err = flowClient.GetEventsForHeightRange(ctx, customType, 0, 10)
    printEvents(result, err)

    // Get events directly from transaction result
    txResult, err := flowClient.GetTransactionResult(ctx, runScriptTx.ID())
    examples.Handle(err)
    printEvent(txResult.Events)
}

func printEvents(result []client.BlockEvents, err error) {
    examples.Handle(err)

    for _, block := range result {
        printEvent(block.Events)
    }
}

func printEvent(events []flow.Event) {
    for _, event := range events {
        fmt.Printf("\n\nType: %s", event.Type)
        fmt.Printf("\nValues: %v", event.Value)
        fmt.Printf("\nTransaction ID: %s", event.TransactionID)
    }
}
```

Example output:

```bash
Type: flow.AccountCreated
Values: flow.AccountCreated(address: 0xfd43f9148d4b725d)
Transaction ID: ba9d53c8dcb0f9c2f854f93da8467a22d053eab0c540bde0b9ca2f7ad95eb78e

Type: flow.AccountCreated
Values: flow.AccountCreated(address: 0xeb179c27144f783c)
Transaction ID: 8ab7bfef3de1cf8b2ffb36559446100bf4129a9aa88d6bc59f72a467acf0c801

...

Type: A.eb179c27144f783c.EventDemo.Add
Values: A.eb179c27144f783c.EventDemo.Add(x: 2, y: 3, sum: 5)
Transaction ID: f3a2e33687ad23b0e02644ebbdcd74a7cd8ea7214065410a8007811d0bcbd353
```

### Get Collections

[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/ref.svg" width="130" />](https://pkg.go.dev/github.com/onflow/flow-go-sdk/client#Client.GetCollection)

Retrieve a batch of transactions that have been included in the same block, known as **_collections_**.
Collections are used to improve consensus throughput by increasing the number of transactions per block and they act as a link between a block and a transaction.

📖 **Collection ID** is SHA3-256 hash of the collection payload.

Example retrieving a collection:

```go
func demo(exampleCollectionID flow.Identifier) {
    ctx := context.Background()
    flowClient := examples.NewFlowClient()

    // get collection by ID
    collection, err := flowClient.GetCollection(ctx, exampleCollectionID)
    printCollection(collection, err)
}

func printCollection(collection *flow.Collection, err error) {
    examples.Handle(err)

    fmt.Printf("\nID: %s", collection.ID().String())
    fmt.Printf("\nTransactions: %s", collection.TransactionIDs)
}
```

Example output:

```bash
ID: 3d7b8037381f2497d83f2f9e09422c036aae2a59d01a7693fb6003b4d0bc3595
Transactions: [cf1184e3de4bd9a7232ca3d0b9dd2cfbf96c97888298b81a05c086451fa52ec1]
```

### Execute Scripts

[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/ref.svg" width="130" />](https://pkg.go.dev/github.com/onflow/flow-go-sdk/client#Client.ExecuteScriptAtLatestBlock)

Scripts allow you to write arbitrary non-mutating Cadence code on the Flow blockchain and return data. You can learn more about [Cadence and scripts here](https://cadence-lang.org/docs/language), but we are now only interested in executing the script code and getting back the data.

We can execute a script using the latest state of the Flow blockchain or we can choose to execute the script at a specific time in history defined by a block height or block ID.

📖 **Block ID** is SHA3-256 hash of the entire block payload, but you can get that value from the block response properties.

📖 **Block height** expresses the height of the block in the chain.

**[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/try.svg" width="130" />](https://github.com/onflow/flow-go-sdk/blob/master/examples/execute_script/main.go)**

```go
func demo() {
    ctx := context.Background()
    flowClient := examples.NewFlowClient()

    script := []byte(`
        pub fun main(a: Int): Int {
            return a + 10
        }
    `)
    args := []cadence.Value{ cadence.NewInt(5) }
    value, err := flowClient.ExecuteScriptAtLatestBlock(ctx, script, args)

    examples.Handle(err)
    fmt.Printf("\nValue: %s", value.String())

    complexScript := []byte(`
        pub struct User {
            pub var balance: UFix64
            pub var address: Address
            pub var name: String

            init(name: String, address: Address, balance: UFix64) {
                self.name = name
                self.address = address
                self.balance = balance
            }
        }

        pub fun main(name: String): User {
            return User(
                name: name,
                address: 0x1,
                balance: 10.0
            )
        }
    `)
    args = []cadence.Value{ cadence.NewString("Dete") }
    value, err = flowClient.ExecuteScriptAtLatestBlock(ctx, complexScript, args)
    printComplexScript(value, err)
}

type User struct {
	balance uint64
	address flow.Address
	name string
}

func printComplexScript(value cadence.Value, err error) {
    examples.Handle(err)
    fmt.Printf("\nString value: %s", value.String())

    s := value.(cadence.Struct)
    u := User{
        balance: s.Fields[0].ToGoValue().(uint64),
        address: s.Fields[1].ToGoValue().([flow.AddressLength]byte),
        name:    s.Fields[2].ToGoValue().(string),
    }

    fmt.Printf("\nName: %s", u.name)
    fmt.Printf("\nAddress: %s", u.address.String())
    fmt.Printf("\nBalance: %d", u.balance)
}
```

Example output:

```bash
Value: 15
String value: s.34a17571e1505cf6770e6ef16ca387e345e9d54d71909f23a7ec0d671cd2faf5.User(balance: 10.00000000, address: 0x1, name: "Dete")
Name: Dete
Address: 0000000000000001
Balance: 1000000000
```

## Mutate Flow Network

Flow, like most blockchains, allows anybody to submit a transaction that mutates the shared global chain state. A transaction is an object that holds a payload, which describes the state mutation, and one or more authorizations that permit the transaction to mutate the state owned by specific accounts.

Transaction data is composed and signed with help of the SDK. The signed payload of transaction then gets submitted to the access node API. If a transaction is invalid or the correct number of authorizing signatures are not provided, it gets rejected.

Executing a transaction requires couple of steps:

- [Building transaction](#build-the-transaction).
- [Signing transaction](#sign-transactions).
- [Sending transaction](#send-transactions).

## Transactions

A transaction is nothing more than a signed set of data that includes script code which are instructions on how to mutate the network state and properties that define and limit it's execution. All these properties are explained bellow.

📖 **Script** field is the portion of the transaction that describes the state mutation logic. On Flow, transaction logic is written in [Cadence](../../../build/guides/smart-contracts/cadence.md). Here is an example transaction script:

```
transaction(greeting: String) {
  execute {
    log(greeting.concat(", World!"))
  }
}
```

📖 **Arguments**. A transaction can accept zero or more arguments that are passed into the Cadence script. The arguments on the transaction must match the number and order declared in the Cadence script. Sample script from above accepts a single `String` argument.

📖 **[Proposal key](../../../build/basics/transactions.md#proposal-key)** must be provided to act as a sequence number and prevent reply and other potential attacks.

Each account key maintains a separate transaction sequence counter; the key that lends its sequence number to a transaction is called the proposal key.

A proposal key contains three fields:

- Account address
- Key index
- Sequence number

A transaction is only valid if its declared sequence number matches the current on-chain sequence number for that key. The sequence number increments by one after the transaction is executed.

📖 **[Payer](../../../build/basics/transactions.md#signer-roles)** is the account that pays the fees for the transaction. A transaction must specify exactly one payer. The payer is only responsible for paying the network and gas fees; the transaction is not authorized to access resources or code stored in the payer account.

📖 **[Authorizers](../../../build/basics/transactions.md#signer-roles)** are accounts that authorize a transaction to read and mutate their resources. A transaction can specify zero or more authorizers, depending on how many accounts the transaction needs to access.

The number of authorizers on the transaction must match the number of AuthAccount parameters declared in the prepare statement of the Cadence script.

Example transaction with multiple authorizers:

```
transaction {
  prepare(authorizer1: AuthAccount, authorizer2: AuthAccount) { }
}
```

📖 **Gas limit** is the limit on the amount of computation a transaction requires, and it will abort if it exceeds its gas limit.
Cadence uses metering to measure the number of operations per transaction. You can read more about it in the [Cadence documentation](../../../build/guides/smart-contracts/cadence.md).

The gas limit depends on the complexity of the transaction script. Until dedicated gas estimation tooling exists, it's best to use the emulator to test complex transactions and determine a safe limit.

📖 **Reference block** specifies an expiration window (measured in blocks) during which a transaction is considered valid by the network.
A transaction will be rejected if it is submitted past its expiry block. Flow calculates transaction expiry using the _reference block_ field on a transaction.
A transaction expires after `600` blocks are committed on top of the reference block, which takes about 10 minutes at average Mainnet block rates.

### Build Transactions

[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/ref.svg" width="130" />](https://pkg.go.dev/github.com/onflow/flow-go-sdk#Transaction)

Building a transaction involves setting the required properties explained above and producing a transaction object.

Here we define a simple transaction script that will be used to execute on the network and serve as a good learning example.

```
transaction(greeting: String) {

  let guest: Address

  prepare(authorizer: AuthAccount) {
    self.guest = authorizer.address
  }

  execute {
    log(greeting.concat(",").concat(self.guest.toString()))
  }
}
```

**[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/try.svg" width="130" />](https://github.com/onflow/flow-go-sdk/blob/master/examples/transaction_signing/single_party/main.go)**

```go
import (
  "context"
  "os"
  "github.com/onflow/flow-go-sdk"
  "github.com/onflow/flow-go-sdk/client"
)

func main() {

  greeting, err := os.ReadFile("Greeting2.cdc")
  if err != nil {
    panic("failed to load Cadence script")
  }

  proposerAddress := flow.HexToAddress("9a0766d93b6608b7")
  proposerKeyIndex := 3

  payerAddress := flow.HexToAddress("631e88ae7f1d7c20")
  authorizerAddress := flow.HexToAddress("7aad92e5a0715d21")

  var accessAPIHost string

  // Establish a connection with an access node
  flowClient := examples.NewFlowClient()

  // Get the latest sealed block to use as a reference block
  latestBlock, err := flowClient.GetLatestBlockHeader(context.Background(), true)
  if err != nil {
    panic("failed to fetch latest block")
  }

  // Get the latest account info for this address
  proposerAccount, err := flowClient.GetAccountAtLatestBlock(context.Background(), proposerAddress)
  if err != nil {
    panic("failed to fetch proposer account")
  }

  // Get the latest sequence number for this key
  sequenceNumber := proposerAccount.Keys[proposerKeyIndex].SequenceNumber

  tx := flow.NewTransaction().
    SetScript(greeting).
    SetComputeLimit(100).
    SetReferenceBlockID(latestBlock.ID).
    SetProposalKey(proposerAddress, proposerKeyIndex, sequenceNumber).
    SetPayer(payerAddress).
    AddAuthorizer(authorizerAddress)

  // Add arguments last

  hello := cadence.NewString("Hello")

  err = tx.AddArgument(hello)
  if err != nil {
    panic("invalid argument")
  }
}
```

After you have successfully [built a transaction](#build-the-transaction) the next step in the process is to sign it.

### Sign Transactions

[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/ref.svg" width="130" />](https://pkg.go.dev/github.com/onflow/flow-go-sdk#Transaction.SignEnvelope)

Flow introduces new concepts that allow for more flexibility when creating and signing transactions.
Before trying the examples below, we recommend that you read through the [transaction signature documentation](../../../build/basics/transactions.md.

After you have successfully [built a transaction](#build-the-transaction) the next step in the process is to sign it. Flow transactions have envelope and payload signatures, and you should learn about each in the [signature documentation](../../../build/basics/transactions.md).

Quick example of building a transaction:

```go
import (
    "github.com/onflow/flow-go-sdk"
    "github.com/onflow/flow-go-sdk/crypto"
)

var (
    myAddress    flow.Address
    myAccountKey flow.AccountKey
    myPrivateKey crypto.PrivateKey
)

tx := flow.NewTransaction().
    SetScript([]byte("transaction { execute { log(\"Hello, World!\") } }")).
    SetComputeLimit(100).
    SetProposalKey(myAddress, myAccountKey.Index, myAccountKey.SequenceNumber).
    SetPayer(myAddress)
```

Transaction signing is done through the `crypto.Signer` interface. The simplest (and least secure) implementation of `crypto.Signer` is `crypto.InMemorySigner`.

Signatures can be generated more securely using keys stored in a hardware device such as an [HSM](https://en.wikipedia.org/wiki/Hardware_security_module). The `crypto.Signer` interface is intended to be flexible enough to support a variety of signer implementations and is not limited to in-memory implementations.

Simple signature example:

```go
// construct a signer from your private key and configured hash algorithm
mySigner, err := crypto.NewInMemorySigner(myPrivateKey, myAccountKey.HashAlgo)
if err != nil {
    panic("failed to create a signer")
}

err = tx.SignEnvelope(myAddress, myAccountKey.Index, mySigner)
if err != nil {
    panic("failed to sign transaction")
}
```

Flow supports great flexibility when it comes to transaction signing, we can define multiple authorizers (multi-sig transactions) and have different payer account than proposer. We will explore advanced signing scenarios bellow.

### [Single party, single signature](../../../build/basics/transactions.md#single-party-single-signature)

- Proposer, payer and authorizer are the same account (`0x01`).
- Only the envelope must be signed.
- Proposal key must have full signing weight.

| Account | Key ID | Weight |
| ------- | ------ | ------ |
| `0x01`  | 1      | 1000   |

**[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/try.svg" width="130" />](https://github.com/onflow/flow-go-sdk/tree/master/examples#single-party-single-signature)**

```go
account1, _ := c.GetAccount(ctx, flow.HexToAddress("01"))

key1 := account1.Keys[0]

// create signer from securely-stored private key
key1Signer := getSignerForKey1()

referenceBlock, _ := flow.GetLatestBlock(ctx, true)
tx := flow.NewTransaction().
    SetScript([]byte(`
        transaction {
            prepare(signer: AuthAccount) { log(signer.address) }
        }
    `)).
    SetComputeLimit(100).
    SetProposalKey(account1.Address, key1.Index, key1.SequenceNumber).
    SetReferenceBlockID(referenceBlock.ID).
    SetPayer(account1.Address).
    AddAuthorizer(account1.Address)

// account 1 signs the envelope with key 1
err := tx.SignEnvelope(account1.Address, key1.Index, key1Signer)
```

### [Single party, multiple signatures](../../../build/basics/transactions.md#single-party-multiple-signatures)

- Proposer, payer and authorizer are the same account (`0x01`).
- Only the envelope must be signed.
- Each key has weight 500, so two signatures are required.

| Account | Key ID | Weight |
| ------- | ------ | ------ |
| `0x01`  | 1      | 500    |
| `0x01`  | 2      | 500    |

**[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/try.svg" width="130" />](https://github.com/onflow/flow-go-sdk/tree/master/examples#single-party-multiple-signatures)**

```go
account1, _ := c.GetAccount(ctx, flow.HexToAddress("01"))

key1 := account1.Keys[0]
key2 := account1.Keys[1]

// create signers from securely-stored private keys
key1Signer := getSignerForKey1()
key2Signer := getSignerForKey2()

referenceBlock, _ := flow.GetLatestBlock(ctx, true)
tx := flow.NewTransaction().
    SetScript([]byte(`
        transaction {
            prepare(signer: AuthAccount) { log(signer.address) }
        }
    `)).
    SetComputeLimit(100).
    SetProposalKey(account1.Address, key1.Index, key1.SequenceNumber).
    SetReferenceBlockID(referenceBlock.ID).
    SetPayer(account1.Address).
    AddAuthorizer(account1.Address)

// account 1 signs the envelope with key 1
err := tx.SignEnvelope(account1.Address, key1.Index, key1Signer)

// account 1 signs the envelope with key 2
err = tx.SignEnvelope(account1.Address, key2.Index, key2Signer)
```

### [Multiple parties](../../../build/basics/transactions.md#multiple-parties)

- Proposer and authorizer are the same account (`0x01`).
- Payer is a separate account (`0x02`).
- Account `0x01` signs the payload.
- Account `0x02` signs the envelope.
  - Account `0x02` must sign last since it is the payer.

| Account | Key ID | Weight |
| ------- | ------ | ------ |
| `0x01`  | 1      | 1000   |
| `0x02`  | 3      | 1000   |

**[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/try.svg" width="130" />](https://github.com/onflow/flow-go-sdk/tree/master/examples#multiple-parties)**

```go
account1, _ := c.GetAccount(ctx, flow.HexToAddress("01"))
account2, _ := c.GetAccount(ctx, flow.HexToAddress("02"))

key1 := account1.Keys[0]
key3 := account2.Keys[0]

// create signers from securely-stored private keys
key1Signer := getSignerForKey1()
key3Signer := getSignerForKey3()

referenceBlock, _ := flow.GetLatestBlock(ctx, true)
tx := flow.NewTransaction().
    SetScript([]byte(`
        transaction {
            prepare(signer: AuthAccount) { log(signer.address) }
        }
    `)).
    SetComputeLimit(100).
    SetProposalKey(account1.Address, key1.Index, key1.SequenceNumber).
    SetReferenceBlockID(referenceBlock.ID).
    SetPayer(account2.Address).
    AddAuthorizer(account1.Address)

// account 1 signs the payload with key 1
err := tx.SignPayload(account1.Address, key1.Index, key1Signer)

// account 2 signs the envelope with key 3
// note: payer always signs last
err = tx.SignEnvelope(account2.Address, key3.Index, key3Signer)
```

### [Multiple parties, two authorizers](../../../build/basics/transactions.md#multiple-parties)

- Proposer and authorizer are the same account (`0x01`).
- Payer is a separate account (`0x02`).
- Account `0x01` signs the payload.
- Account `0x02` signs the envelope.
  - Account `0x02` must sign last since it is the payer.
- Account `0x02` is also an authorizer to show how to include two AuthAccounts into an transaction

| Account | Key ID | Weight |
| ------- | ------ | ------ |
| `0x01`  | 1      | 1000   |
| `0x02`  | 3      | 1000   |

**[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/try.svg" width="130" />](https://github.com/onflow/flow-go-sdk/tree/master/examples#multiple-parties-two-authorizers)**

```go
account1, _ := c.GetAccount(ctx, flow.HexToAddress("01"))
account2, _ := c.GetAccount(ctx, flow.HexToAddress("02"))

key1 := account1.Keys[0]
key3 := account2.Keys[0]

// create signers from securely-stored private keys
key1Signer := getSignerForKey1()
key3Signer := getSignerForKey3()

referenceBlock, _ := flow.GetLatestBlock(ctx, true)
tx := flow.NewTransaction().
    SetScript([]byte(`
        transaction {
            prepare(signer1: AuthAccount, signer2: AuthAccount) {
              log(signer.address)
              log(signer2.address)
          }
        }
    `)).
    SetComputeLimit(100).
    SetProposalKey(account1.Address, key1.Index, key1.SequenceNumber).
    SetReferenceBlockID(referenceBlock.ID).
    SetPayer(account2.Address).
    AddAuthorizer(account1.Address).
    AddAuthorizer(account2.Address)

// account 1 signs the payload with key 1
err := tx.SignPayload(account1.Address, key1.Index, key1Signer)

// account 2 signs the envelope with key 3
// note: payer always signs last
err = tx.SignEnvelope(account2.Address, key3.Index, key3Signer)
```

### [Multiple parties, multiple signatures](../../../build/basics/transactions.md#multiple-parties)

- Proposer and authorizer are the same account (`0x01`).
- Payer is a separate account (`0x02`).
- Account `0x01` signs the payload.
- Account `0x02` signs the envelope.
  - Account `0x02` must sign last since it is the payer.
- Both accounts must sign twice (once with each of their keys).

| Account | Key ID | Weight |
| ------- | ------ | ------ |
| `0x01`  | 1      | 500    |
| `0x01`  | 2      | 500    |
| `0x02`  | 3      | 500    |
| `0x02`  | 4      | 500    |

**[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/try.svg" width="130" />](https://github.com/onflow/flow-go-sdk/tree/master/examples#multiple-parties-multiple-signatures)**

```go
account1, _ := c.GetAccount(ctx, flow.HexToAddress("01"))
account2, _ := c.GetAccount(ctx, flow.HexToAddress("02"))

key1 := account1.Keys[0]
key2 := account1.Keys[1]
key3 := account2.Keys[0]
key4 := account2.Keys[1]

// create signers from securely-stored private keys
key1Signer := getSignerForKey1()
key2Signer := getSignerForKey1()
key3Signer := getSignerForKey3()
key4Signer := getSignerForKey4()

referenceBlock, _ := flow.GetLatestBlock(ctx, true)
tx := flow.NewTransaction().
    SetScript([]byte(`
        transaction {
            prepare(signer: AuthAccount) { log(signer.address) }
        }
    `)).
    SetComputeLimit(100).
    SetProposalKey(account1.Address, key1.Index, key1.SequenceNumber).
    SetReferenceBlockID(referenceBlock.ID).
    SetPayer(account2.Address).
    AddAuthorizer(account1.Address)

// account 1 signs the payload with key 1
err := tx.SignPayload(account1.Address, key1.Index, key1Signer)

// account 1 signs the payload with key 2
err = tx.SignPayload(account1.Address, key2.Index, key2Signer)

// account 2 signs the envelope with key 3
// note: payer always signs last
err = tx.SignEnvelope(account2.Address, key3.Index, key3Signer)

// account 2 signs the envelope with key 4
// note: payer always signs last
err = tx.SignEnvelope(account2.Address, key4.Index, key4Signer)
```

### Send Transactions

[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/ref.svg" width="130" />](https://pkg.go.dev/github.com/onflow/flow-go-sdk/client#Client.SendTransaction)

After a transaction has been [built](#build-the-transaction) and [signed](#sign-transactions), it can be sent to the Flow blockchain where it will be executed. If sending was successful you can then [retrieve the transaction result](#get-transactions).

**[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/try.svg" width="130" />](https://github.com/onflow/flow-go-sdk/blob/master/examples/send_transactions/main.go)**

```go
func demo(tx *flow.Transaction) {
    ctx := context.Background()
    flowClient := examples.NewFlowClient()

    err := flowClient.SendTransaction(ctx, *tx)
    if err != nil {
        fmt.Println("error sending transaction", err)
    }
}
```

### Create Accounts

[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/ref.svg" width="130" />](https://pkg.go.dev/github.com/onflow/flow-go-sdk/templates#CreateAccount)

On Flow, account creation happens inside a transaction. Because the network allows for a many-to-many relationship between public keys and accounts, it's not possible to derive a new account address from a public key offline.

The Flow VM uses a deterministic address generation algorithm to assign account addresses on chain. You can find more details about address generation in the [accounts & keys documentation](../../../build/basics/accounts.md).

#### Public Key

Flow uses ECDSA key pairs to control access to user accounts. Each key pair can be used in combination with the SHA2-256 or SHA3-256 hashing algorithms.

⚠️ You'll need to authorize at least one public key to control your new account.

Flow represents ECDSA public keys in raw form without additional metadata. Each key is a single byte slice containing a concatenation of its X and Y components in big-endian byte form.

A Flow account can contain zero (not possible to control) or more public keys, referred to as account keys. Read more about [accounts in the documentation](../../../build/basics/accounts.md).

An account key contains the following data:

- Raw public key (described above)
- Signature algorithm
- Hash algorithm
- Weight (integer between 0-1000)

Account creation happens inside a transaction, which means that somebody must pay to submit that transaction to the network. We'll call this person the account creator. Make sure you have read [sending a transaction section](#send-transactions) first.

```go
var (
  creatorAddress    flow.Address
  creatorAccountKey *flow.AccountKey
  creatorSigner     crypto.Signer
)

var accessAPIHost string

// Establish a connection with an access node
flowClient := examples.NewFlowClient()

// Use the templates package to create a new account creation transaction
tx := templates.CreateAccount([]*flow.AccountKey{accountKey}, nil, creatorAddress)

// Set the transaction payer and proposal key
tx.SetPayer(creatorAddress)
tx.SetProposalKey(
    creatorAddress,
    creatorAccountKey.Index,
    creatorAccountKey.SequenceNumber,
)

// Get the latest sealed block to use as a reference block
latestBlock, err := flowClient.GetLatestBlockHeader(context.Background(), true)
if err != nil {
    panic("failed to fetch latest block")
}

tx.SetReferenceBlockID(latestBlock.ID)

// Sign and submit the transaction
err = tx.SignEnvelope(creatorAddress, creatorAccountKey.Index, creatorSigner)
if err != nil {
    panic("failed to sign transaction envelope")
}

err = flowClient.SendTransaction(context.Background(), *tx)
if err != nil {
    panic("failed to send transaction to network")
}
```

After the account creation transaction has been submitted you can retrieve the new account address by [getting the transaction result](#get-transactions).

The new account address will be emitted in a system-level `flow.AccountCreated` event.

```go
result, err := flowClient.GetTransactionResult(ctx, tx.ID())
if err != nil {
    panic("failed to get transaction result")
}

var newAddress flow.Address

if result.Status != flow.TransactionStatusSealed {
    panic("address not known until transaction is sealed")
}

for _, event := range result.Events {
    if event.Type == flow.EventAccountCreated {
        newAddress = flow.AccountCreatedEvent(event).Address()
        break
    }
}
```

### Generate Keys

[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/ref.svg" width="130" />](../../../build/basics/accounts.md#signature-and-hash-algorithms)

Flow uses [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm) signatures to control access to user accounts. Each key pair can be used in combination with the `SHA2-256` or `SHA3-256` hashing algorithms.

Here's how to generate an ECDSA private key for the P-256 (secp256r1) curve.

```go
import "github.com/onflow/flow-go-sdk/crypto"

// deterministic seed phrase
// note: this is only an example, please use a secure random generator for the key seed
seed := []byte("elephant ears space cowboy octopus rodeo potato cannon pineapple")

privateKey, err := crypto.GeneratePrivateKey(crypto.ECDSA_P256, seed)

// the private key can then be encoded as bytes (i.e. for storage)
encPrivateKey := privateKey.Encode()
// the private key has an accompanying public key
publicKey := privateKey.PublicKey()
```

The example above uses an ECDSA key pair on the P-256 (secp256r1) elliptic curve. Flow also supports the secp256k1 curve used by Bitcoin and Ethereum. Read more about [supported algorithms here](../../../build/basics/accounts.md#signature-and-hash-algorithms).

### Transfering Flow

This is an example of how to construct a FLOW token transfer transaction
with the Flow Go SDK.

## Cadence Script

The following Cadence script will transfer FLOW tokens from a sender
to a recipient.

_Note: this transaction is only compatible with Flow Mainnet._

```cadence
import FungibleToken from 0xf233dcee88fe0abe
import FlowToken from 0x1654653399040a61

transaction(amount: UFix64, recipient: Address) {
  let sentVault: @FungibleToken.Vault
  prepare(signer: AuthAccount) {
    let vaultRef = signer.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)
      ?? panic("failed to borrow reference to sender vault")

    self.sentVault <- vaultRef.withdraw(amount: amount)
  }

  execute {
    let receiverRef =  getAccount(recipient)
      .getCapability(/public/flowTokenReceiver)
      .borrow<&{FungibleToken.Receiver}>()
        ?? panic("failed to borrow reference to recipient vault")

    receiverRef.deposit(from: <-self.sentVault)
  }
}
```

## Build the Transaction

```go
import (
    "github.com/onflow/cadence"
    "github.com/onflow/flow-go-sdk"
)

// Replace with script above
const transferScript string = TOKEN_TRANSFER_CADENCE_SCRIPT

var (
    senderAddress    flow.Address
    senderAccountKey flow.AccountKey
    senderPrivateKey crypto.PrivateKey
)

func main() {
    tx := flow.NewTransaction().
        SetScript([]byte(transferScript)).
        SetComputeLimit(100).
        SetPayer(senderAddress).
        SetAuthorizer(senderAddress).
        SetProposalKey(senderAddress, senderAccountKey.Index, senderAccountKey.SequenceNumber)

    amount, err := cadence.NewUFix64("123.4")
    if err != nil {
        panic(err)
    }

    recipient := cadence.NewAddress(flow.HexToAddress("0xabc..."))

    err = tx.AddArgument(amount)
    if err != nil {
        panic(err)
    }

    err = tx.AddArgument(recipient)
    if err != nil {
        panic(err)
    }
}
```
# Migration Guide v0.25.0

The Go SDK version 0.25.0 introduced breaking changes in the API and package naming. 
Changes were required to make the implementation of the new HTTP access node API available. 

We will list all the changes and provide examples on how to migrate.

- **Renamed package: client -> access:** the `client` package was renamed to `access` 
which now includes both `grpc` package containing previously only gRPC implementation and 
also `http` package containing the new HTTP API implementation.
- **Removed package: convert:** the `convert` package was removed and all its functions were moved 
to each of the corresponding `grpc` or `http` packages. The methods were also changed to not be exported, 
so you can no longer use them outside the `convert` package.
- **New clients:** new clients were added each implementing the functions from the client interface 
and exposing a factory for creating them.
- **New Client Interface**: new client interface was created which is now network agnostic, meaning it 
doesn't any more expose additional options in the API that were used to pass gRPC specific options. You can 
still pass those options but you must use the network specific client as shown in the example bellow. 
The interface also changed some functions: 
  - `GetCollectionByID` renamed to `GetCollection`
  - `Close() error` was added


### Migration

#### Creating a Client
Creating a client for communicating with the access node has changed since it's now possible 
to pick and choose between HTTP and gRPC communication protocols. 

*Previous versions:*
```go
// initialize a gRPC emulator client
flowClient, err := client.New("127.0.0.1:3569", grpc.WithInsecure())
```

*Version 0.25.0*:
```go
// common client interface
var flowClient access.Client

// initialize an http emulator client
flowClient, err := http.NewClient(http.EmulatorHost)

// initialize a gPRC emulator client
flowClient, err = grpc.NewClient(grpc.EmulatorHost)
```

#### Using the gRPC Client with Options
Using the client is in most cases the same except for the advance case of passing additional 
options to the gRPC client which is no longer possible in the base client, you must use a 
network specific client as shown in the advanced example:

*Previous versions:*
```go
// initialize a gRPC emulator client
flowClient, err := client.New("127.0.0.1:3569", grpc.WithInsecure())
latestBlock, err := flowClient.GetLatestBlock(ctx, true, MaxCallSendMsgSize(100))
```

*Version 0.25.0:*
```go
// initialize a grpc network specific client
flowClient, err := NewBaseClient(
	grpc.EmulatorHost, 
	grpc.WithTransportCredentials(insecure.NewCredentials()),
)
latestBlock, err := flowClient.GetLatestBlock(ctx, true, MaxCallSendMsgSize(100))
```
# Clients

## Go SDK

[Flow Go SDK](./flow-go-sdk/index.mdx) provides a set of packages for Go developers to build applications that interact with the Flow network.

## Python SDK

[Flow Python SDK](https://github.com/janezpodhostnik/flow-py-sdk) provides a set of packages for Python developers to build applications that interact with the Flow network.

## Ruby

[FlowClient](https://github.com/glucode/flow_client) is a Ruby gRPC client for Flow (onflow.org).

## Kotlin

[Flow JVM SDK](https://github.com/onflow/flow-jvm-sdk) is a library for JVM languages (e.g. Java, Kotlin) that provides utilities to interact with the Flow blockchain.

## Unity

[Flow SDK for Unity](./unity-sdk/index.md) allows Unity developers to integrate their games and applications with the Flow blockchain.

## JavaScript (FCL)

[Flow Client Library (FCL)](./fcl-js/index.md) is a package used to interact with user wallets and the Flow blockchain.

## Swift

[flow-swift](https://github.com/Outblock/flow-swift) is a tool to build iOS applications in the Flow mobile realm.

## .Net

[flow.net](https://github.com/tyronbrand/flow.net) is a tool for building .Net applications on Flow.

## Rust

[Rust SDK](https://github.com/fee1-dead/flow.rs) for the Flow blockchain network.

## PHP

[PHP SDK](https://github.com/mayvenstudios/flow-php-sdk) for the Flow blockchain.

## Elixir

[OnFlow](https://github.com/nkezhaya/on_flow) is an Elixir client for interacting with the Flow blockchain. Documentation is available [here](https://hexdocs.pm/on_flow).

## HTTP API

[Flow OpenAPI](/http-api) specification.
---
title: API Reference
sidebar_position: 1
sidebar_label: API Reference
---

Click on the following link to view the API Reference for the Flow SDK for Unity. 

[<img src="https://raw.githubusercontent.com/onflow/sdks/main/templates/documentation/ref.svg" width="130" />](https://unity-flow-sdk-api-docs.vercel.app/)---
title: Changelog
sidebar_position: 4
sidebar_label: Changelog
---
## Version 2.0.0

- Added new wallet provider Wallet Connect
- Added iOS as a supported platform
- Added Cadence Convert feature for simple de/serialization
- Changed how wallet providers are instantiated (see Breaking Changes)

### Breaking Changes in 2.0.0

Previously, wallet providers (ie DevWallet) were instantiated as follows: 

```csharp
FlowSDK.RegisterWalletProvider(ScriptableObject.CreateInstance<DevWalletProvider>());
```

From 2.0.0, this should now be: 

```csharp
FlowSDK.RegisterWalletProvider(new DevWalletProvider());
```

## Version 1.0.3

- Add Example NFT sample

## Version 1.0.2

- Fixed an issue where the latest Flow emulator would cause the editor to freeze

## Version 1.0.1

- Added wallet authentication to contract and account creation tools
- Fixed all Unity warnings in all samples
- Removed unused and commented code
- Added README files to all samples
- Emulator listens on all local IP addresses
- Improved error handling from all API requests
- Improved error handling and feedback from Flow Control tools
- Limited Events.GetForBlockIds request to 50 block ids
- Fixed login panel on Flow Words Tutorial sample

## Version 1.0.0 

- Initial release of the Flow SDK for Unity# Flow SDK Convert

The FlowSDK provides a Convert class to convert between Cadence and C# datatypes.  It provides two functions, ToCadence and FromCadence.

The conversion is strict in regards to the types of the data.  C# types *must* match the Cadence type being converted from/to or an exception will be thrown.  The following are the required types:

Cadence|C#
---|---
Int|BigInteger
UInt|BigInteger
Int8|SByte
Int16|Int16
Int32|Int32
Int64|Int64
Int128|BigInteger
Int256|BigInteger
UInt8|Byte
UInt16|UInt16
UInt32|UInt32
UInt64|UInt64
UInt128|BigInteger
UInt256|BigInteger
Word8|Byte
Word16|UInt16
Word32|UInt32
Word64|UInt64
Fix64|Decimal
UFix64|Decimal
Address|String
String|String
Bool|Boolean
Path|CadencePathValue
Capability|CadenceCapabilityValue
`Array ([T])`|List&lt;T&gt;
`Dictionary ({T:R})`|Dictionary&lt;T,R&gt;
Struct|Class or Struct


## Usage

### ToCadence

The Convert.ToCadence function has the following signature:
```csharp
public static CadenceBase ToCadence(object source, string destinationType)
```

ToCadence will return a CadenceBase that can be passed into Script and Transaction functions.  Example:

```csharp
CadenceBase cb = Convert.ToCadence((Int64)44, "Int64");
```

This will result in a CadenceNumber with a value of "44" and a type of "Int64".  However:

```csharp
CadenceBase cb = Convert.ToCadence(44, "Int64");
```

will result in an exception "Exception: Can not convert System.Int32 into Int64.  Requires source to be System.Int64."

Similarly, the Cadence Int type is an arbitrary precision integer type and thus must be created using a System.BigInteger.

```csharp
CadenceBase cb = Convert.ToCadence(new BigInteger(44), "Int");
```

### FromCadence

The Convert.FromCadence has the following signature:

```csharp
public static T FromCadence<T>(CadenceBase cadence)
```
where T is the C# you would like the Cadence converted into.

FromCadence will return a value of the requested type given a CadenceBase value.  The Cadence and C# types must match.

```csharp
CadenceBase cb = new CadenceNumber(CadenceNumberType.Int16, "44");
Int16 i = Convert.FromCadence<Int16>(cb);
```

If the requested and source types do not match, an exception will be thrown.

```csharp
CadenceBase cb = new CadenceNumber(CadenceNumberType.Int16, "44");
Int64 i = Convert.FromCadence<Int64>(cb);
```

The above results in an exception:  "Exception: Attempt to convert cadence to invalid type.  Cadence type Int16 expects System.Int16, got System.Int64".

### Composite Types

Using the Convert class on primitive types isn't much easier than constructing the Cadence types yourself.  Using it on Composite types is much more useful.

Convert can convert between Cadence composite types (Struct, Enum, Resource, Event, Contract) and C# structs/classes.  In order to annotate your C# classes/structs a CadenceAttribute is provided.
The CadenceAttribute has two properties.  The Name and CadenceType properties allow you to provide hints to the converter as to what each C# types should be when converted to Cadence.

Given the following C# class:

```csharp
public class TestStruct
{
    public Int32 i32;
    public String s;
}
```

and the following Cadence struct:

```cadence
pub struct TestStruct {
    pub let i32: Int32
    pub let s: String
}
```

you can convert from Cadence to C# using:

```csharp
TestStruct ts = Convert.FromCadence<TestStruct>(cadence);
```

It will match based on the field names, and the types are compatible.  Converting from C# to Cadence, on the other hand, requires annotations.

```csharp
[Cadence(CadenceType="A.XXX.CCC.TestStruct")]
public class TestStruct
{
    [Cadence(CadenceType="Int32", Name="i32")]
    public Int32 i;
    [Cadence(CadenceType="String")]
    public String s;
}
```

This is because a C# string could be a Cadence Address or Cadence String.  For consistency, Convert requires all C#->Cadence conversions to be annotated with a CadenceType.  If a field is not 
annotated, it will be skipped when converting from C# to Cadence.

You can also use the Name parameter to account for differences in field naming.  In the above example we mapped the Cadence "i32" field to the C# "i" field.  The Name property is optional and
it will use the field name if no Name property is given.

***Note:  The CadenceType annotation on C# classes/structs (`[Cadence(CadenceType="A.XXX.CCC.TestStruct")]` in the above example) is ignored when converting from Cadence to C#.
Convert.FromCadence will populate all fields that have matching names/types regardless of the type of Cadence struct that is being converted.  This allows you to convert a Cadence struct defined
int a Cadence script into C# even if you do not know what the Cadence type is.***

The class annotation (A.XXX.CCC.TestStruct) is required when converting from C# to Cadence. XXX should be the address of the account that contains the contract where the struct is 
defined, without a leading "0x".  The CCC is the name of the contract.

Here's an example using the NBA TopShot contract (https://github.com/dapperlabs/nba-smart-contracts/blob/master/contracts/TopShot.cdc) on TestNet, defining a class to hold the Play struct:

```csharp
[Cadence(CadenceType="A.877931736ee77cff.TopShot.Play")]
public class Play
{
    [Cadence(CadenceType="UInt32")]
    public UInt32 playID; 
    [Cadence(CadenceType="{String:String}")]
    public Dictionary<String, String> metadata;
}
```

## Structs inside Structs

If a Cadence struct contains another struct, the field should be annotated as a "Struct".  Given the following Cadence:

```cadence
pub struct Other {
    pub let i: Int16

    pub init(i:Int16) {
        self.i=i
    }
}

pub struct Test {
    pub let o : Other
    
    pub init(i: Int16) {
        self.o = Other(i:i)
    }
}
```

you could use this C#:

```csharp
[Cadence(CadenceType="A.xxx.ccc.Nested")]
public class Other
{
    [Cadence(CadenceType="Int16")]
    public Int16 i;
}

[Cadence(CadenceType="A.xxx.ccc.Test")]
public class Test
{
    [Cadence(CadenceType="Struct")]
    public Other o;
} 
```

If you have a Cadence Test struct you can convert into C# using:
```csharp
TestStruct ts = Convert.FromCadence<TestStruct>(cadence);
```

If you have a C# Test object, you can convert to Cadence using:
```csharp
CadenceBase cb = Convert.ToCadence(ts, "Struct");
```

## Optionals

Cadence optionals are indicated by appending a ?.  For instance the Cadence type Int16? can contain either an Int16 value or nil.  If the C# type is a reference type, no additional work is required.
For instance a Cadence String? will have the C# equivalent type of String.  This is because the C# String is a reference type, which can natively be set to null.  On the other hand, the Cadence Int16? requires the C# type Int16? which wraps type the value type Int16 in a `Nullable<>`.

```csharp
//c is a Cadence Int16? type
Int16? i = Convert.FromCadence<Int16?>(c);
```

Trying to convert a Cadence optional into a non-nullable type results in an exception:

```csharp
//c is a Cadence Int16? type
Int16 i = Convert.FromCadence<Int16>(c);
```

"Exception: CadenceOptional requires a nullable type"# Dev Wallet

## Introduction

Dev Wallet is an implementation of a wallet provider for development purposes. It provides the following: 

- An example of how to implement the `IWallet` interface, should you wish to implement your own wallet provider. 
- An easy way to sign transactions during development, without the burden of connecting to real wallets. 

***IMPORTANT:*** Never use Dev Wallet in a production build, as it is not secure. 

The initial v1.0.0 release of the Flow SDK for Unity does not provide a production ready wallet provider. We are working hard to release one in the very near future. In the meantime, you can attempt to create your own wallet provider implementing the `IWallet` interface, or stick with Dev Wallet while you develop your game. 

## What are Wallets? 

A wallet is a piece of software or hardware that stores the private key associated with a Flow account. The term *custodian* is used to refer to the party that stores the private key. Hardware Wallets (eg Ledger), typically USB devices, allow users to be their own custodian, whereas hosted software wallets (eg Dapper Wallet) act as the custodian on behalf of the user. 

For more information about Wallets and Flow accounts, see [user-accounts-and-wallets](../../../../tutorials/user-accounts-and-wallets.md). 

## What is a Wallet Provider? 

In terms of the Flow SDK for Unity, a Wallet Provider is a class which implements the `IWallet` interface and allows users to interact with specific hardware or software wallets. This includes authenticating with a wallet, retrieving the user's Flow account address from the wallet, and requesting the wallet to sign transactions on behalf of the user. 

As of v1.0.0, the Flow SDK for Unity only contains a single wallet provider - Dev Wallet. This is not a real wallet provider, but a mock wallet provider for development purposes. It simulates the same functionality as a real wallet provider, but doesn't require users to create and integrate with real wallets. This is a great feature for developers, because it allows them to focus on making the game and designing their on-chain architecture in a purely sandbox environment. A production ready wallet provider will be released in a future version of the SDK as a priority feature. 

## How to use Dev Wallet

Dev Wallet uses the accounts listed in the Accounts tab of the Flow Control Window. You can "authenticate" as one of these accounts, then sign transactions with that account. For more information on setting up these accounts, see [flow-control#flowcontrol-accounts](../../unity-sdk/guides/flow-control.md#flowcontrol-accounts). 

### Registering

To use Dev Wallet, you must register it as follows: 

```csharp
FlowSDK.RegisterWalletProvider(ScriptableObject.CreateInstance<DevWalletProvider>());
```

This should be done at the same time as initializing the Flow SDK. Here is a complete example of initializing the Flow SDK to use the emulator and registering Dev Wallet: 

```csharp
using DapperLabs.Flow.Sdk;
using DapperLabs.Flow.Sdk.DevWallet;

FlowConfig flowConfig = new FlowConfig();
flowConfig.NetworkUrl = FlowControl.Data.EmulatorSettings.emulatorEndpoint // local emulator
flowConfig.Protocol = FlowConfig.NetworkProtocol.HTTP;

FlowSDK.Init(flowConfig);
FlowSDK.RegisterWalletProvider(ScriptableObject.CreateInstance<DevWalletProvider>());
```

### Authenticating

The `IWallet.Authenticate` method is as follows: 

```csharp
public void Authenticate(string username, System.Action<string> OnAuthSuccess, System.Action OnAuthFailed);
```

`username` is a string that can be used to identify a user's wallet. For Dev Wallet, this corresponds to the `Name` field of an account in the Accounts tab of the Flow Control Window. If you know which account you want to authenticate with, supply the account name as this argument. If you pass in a blank string, the user will get a dialog where they can choose which account to authenticate as. As this is a development tool, there are no passwords - it is simply simulating authentication. 
`OnAuthSuccess` is a function that will be called when you have successfully authenticated. The callback function must take a `string` argument, which will contain the authenticated account's Flow address. 
`OnAuthFailed` is a function that will be called if authentication failed. In Dev Wallet, this would only fail if you passed in a `username` that doesn't exist. 

Here is an example of authenticating as the `user1` account from game code: 

```csharp
FlowSDK.GetWalletProvider().Authenticate("user1", (string flowAddress) => 
{
    Debug.Log($"Authenticated - Flow account address is {flowAddress}");
}, () => 
{
    Debug.Log("Authentication failed.");
});
```

Here is an example of calling `Authenticate` to display a list of Dev Wallet accounts to choose from: 

```csharp
FlowSDK.GetWalletProvider().Authenticate("", (string flowAddress) => 
{
    Debug.Log($"Authenticated - Flow account address is {flowAddress}");
}, () => 
{
    Debug.Log("Authentication failed.");
});
```

### Signing Transactions

If you are using the Flow SDK to sign transactions then you do not need to worry about this, as it is handled automatically. When you submit a transaction, the SDK will request Dev Wallet to sign the transaction as the authenticated user. A dialog will be displayed requesting the user to approve the transaction. 

For full disclosure, here are the methods on the `IWallet` interface to sign a transaction: 

```csharp
public Task<byte[]> SignTransactionPayload(FlowTransaction txn);

public Task<byte[]> SignTransactionEnvelope(FlowTransaction txn);
```

In Flow, there are two parts of a transaction that can be signed - the Payload and the Authorization Envelope. The envelope must always be signed, and is the last thing to be signed by the Payer of the transaction fees. The Payload is only signed by the Proposer and\or the Authorizers IF they are not also the Payer (i.e. nobody signs the transaction twice). For more information see [transaction signing](../../../../build/basics/transactions.md#signing-a-transaction). 

The following is an example of how to call `SignTransactionPayload`, but as mentioned, this is automatically done by the SDK's `Transactions.Submit` function. It's an asynchronous so is therefore `await`ed, and returns the signature as a byte array. 

```csharp
byte[] signature = await FlowSDK.GetWalletProvider().SignTransactionPayload(txRequest);
```

### Unauthenticating

You can unauthenticate from Dev Wallet by calling the following: 

```csharp
FlowSDK.GetWalletProvider().Unauthenticate();
```

This will clear Dev Wallet's internal cache of who is authenticated. Note that trying to submit transactions without anyone authenticated will result in an error. 
﻿# FlowControl

FlowControl is a set of Unity tools and functions designed to streamline development and interactions with the Flow blockchain. 

After installing the Unity Flow SDK, open the FlowControl Manager window by clicking on Windows->Flow->Flow Control.

This will open the FlowControl Manager window.  It will also add a Flow Control object to your scene and create a FlowControlData resource to store your data if they are not already present.  You can have multiple FlowControlData resources to act as presets and switch between them as needed.

## FlowControl Emulator Settings

The first panel that displays will be your emulator settings.

![FlowControl Emulator Settings](../media/FlowControlEmulator.png)

**Installation Detection:**  FlowControl will attempt to find the flow binary in your path.  If it can't detect it, it will display a button with the label "Install" linking you to the install instructions.

**Emulator Data Directory:**  This field is required if you wish to control the emulator from FlowControl.  Set this to the **directory** where you would like to store your persisted 
emulator state (flowdb), and your initial emulator configuration (flow.json).  This should typically be outside your project folder.  The folder must exist.

**Emulator endpoint:**  If you want to connect to an emulator running on a different computer, such as when testing on mobile devices or several clients all connecting
to the same emulator instance, you can specify an emulator endpoint address here.

**Run emulator in play mode?**  This determines if the emulator should automatically start when you enter play mode.

**Start Emulator** button:  This will start the emulator in the background to allow you to interact with it in edit mode.

**Stop Emulator** button:  This will stop a running emulator process.

**Clear Persistent Data** button:  The Flow emulator maintains the state of the emulated blockchain in a database.  This allows you to persist data between runs.  If you would like to reset the emulated blockchain to its initial state, use this button.  This will delete the flowdb directory located in the Emulator Data Directory.  It will be recreated the next time you start the emulator.

**Show Emulator Log** button:  This opens the Emulator Output window.  You can use this to verify that scripts you run against the emulator execute 
properly and will display debug messages if something goes wrong.  You can also open the log using Window->Flow->Emulator Output

## Advanced Options

Some options are not exposed in the Flow Control Manager, but can be changed directly in the FlowControlData asset.
![FlowControlData asset](../media/FlowControlDataAsset.png)

**Flow Executable Path Override:**  This allows you to select the flow binary you would like to use.  This will override the auto detected flow binary.

**Persist Data:**  This allows you disable persisting the emulated blockchain to disk.  If this is disabled, all changes you make to the emulated blockchain will be lost when the emulator stops or restarts.

**Kill Other Flow:**  When starting or restarting the emulator, any running flow processes will be terminated.  If you wish to run your own emulator instance outside the control of Flow Control, uncheck this, as well as "Run Emulator in Play Mode" to ensure it doesn't get terminated. 

**Verbose:**  This controls the verbosity of emulator output.  Verbose output is usually desired, but if you would like non-verbose output for any reason, this allows you to control that setting.

## FlowControl Accounts

The Accounts panel allows you to store account information for easy access at runtime.
***Note:  Adding accounts to this panel does not create accounts on the blockchain***

![FlowControl Accounts](../media/FlowControlAccounts.png)

The "+" button at the top will add a blank account entry for you to fill in.  The fields may differ depending on which Gateway is selected, but Gateway and Name are always required.

The emulator_service_account account will be created/updated each time you start the emulator so that it will always be valid.

If it is a Testnet account, a link to the Testnet Flowdiver page for that account will be provided.  Clicking on it will open the page in your default browser.

## FlowControl Text Replacement

![FlowControl Text Replacement](../media/FlowControlTextReplacement.png)

The Text Replacement panel allows you to manage string replacement inside your Cadence scripts.  If you're switching between emulator and Testnet, this makes it easy to replace account addresses and other strings without having to edit the scripts each time.

All instances of Original Text will be replaced with Replacement Text.  There is no required format, but it is recommended that you enclose the placeholder text in a separator character to ensure that there are no conflicting replacements.

The Description field is optional and is just used to make it easy to remember what each replacement is for.

The Active checkbox indicates if this text replacement should be performed.

"Apply to accounts" allows you to select specific accounts this replacement should apply to.  Any transactions or script executions performed via these accounts will have this replacement applied.

"Apply to gateways" allows you to select specific gateways this replacement should apply to.  Any transactions or script executions performed via an account utilizing these gateways will have this replacement performed.

Accounts must meet both the account and gateway requirements for a text replacement to take place.  If an account is listed in the accounts list, but uses a gateway that is not in the gateways list, the replacement will not be processed and vice-versa.

## FlowControl Tools

The FlowControl Tools panel can be used to deploy contracts and create accounts.

![FlowControl Tools](../media/FlowControlTools.png)

### Manage Contracts

The Contract Name is the name of the contract as it will appear on the blockchain.  It must match the contract name in the contract file.  Text replacements are done on the contract file before deploying.

Contract is the cadence contract file that you want to deploy.

Account is the account that should deploy the contract.  The contract will be deployed to the same network that the account gateway uses.

The Deploy Contract button will attempt to deploy the contract.  Check the emulator logs or flowdiver.io to monitor the progress of deployment and check for errors.

The Update Contract button will attempt to update an existing contract.  There are rules as to what can change in a contract for an update to be accepted.  See [cadence/language/contract-updatability](https://cadence-lang.org/docs/language/contract-updatability) for more information.

The Remove Contract button will attempt to delete the contract with the given name from the specified account.  Once a contract is deleted, a new contract with the same name can not be created on the same account.  When using the emulator, clearing the database will allow you to recreate the contract.  When using testnet or mainnet, that contract name will become unavailable for the account.  This is done to prevent bypassing the contract update rules by deleting and recreating a contract with incompatible changes.


### Transactions

This section will allow you to execute a transaction against the gateway associated with the Signer account.  Currently it does not allow you to pass arguments to the transaction, but you can use a Text Replacement to work around this.


### Create New Account

The Paying account is the account that will initially fund the new account.  The new account name is not stored on the blockchain, and is only used to identify the new account in the Accounts panel.  After the account is created, the account information will be added to the Accounts panel.  Make sure to save a copy of this information somewhere.  If the private key is lost, that account will not be accessible.  You can change the account Name in the Accounts panel.  Note that changing the Address or Private Key fields will not change these on the blockchain.


## FlowControl inspector
![FlowControl Inspector](../media/FlowControlInspector.png)

Clicking the FlowControl object in your scene will give you access to the inspector.  This will allow you to select which FlowControlData resource you would like to use
as well as export to/import from JSON.  JSON is useful if you would like to modify FlowControl variables from a built project, since you will not be able to save the 
FlowControlData resource from a built project.  The Log JSON button will serialize the FlowControlData resource into a string and display it.  The Load JSON button will 
deserialize the displayed JSON into the selected FlowControlData resource.
# iOS Support

To use the Flow SDK in iOS projects, there are a couple more settings you must configure in your Unity project. 

## Provisioning

This is required for all iOS projects, so anyone with experience setting up iOS projects in Unity should be familiar with it. If you are new to developing for iOS on Unity, please follow [Unity's documentation on how to set up a project for iOS](https://docs.unity3d.com/Manual/iphone-GettingStarted.html). 

With iOS selected as the active platform, open the Player Settings (Edit - Project Settings - Player). Scroll down to **Identification** and enter your provisioning details. The fastest way to get up and running is to enter your **Signing Team ID** and check **Automatically Sign**. For a description of all these fields, please refer to [Unity's documentation](https://docs.unity3d.com/Manual/class-PlayerSettingsiOS.html#Identification). 

## IL2CPP Code Generation setting

If your version of Unity is older than 2022.1 (keeping in mind the minimum supported version is 2021.3) you will need to change the following setting: 

1. Open Build Settings (under File). 
2. If iOS is not already the active platform, select iOS and click **Switch Platform**. 
3. Change **IL2CPP Code Generation** to **Faster (smaller) builds**. 

The reason this must be changed is because the Flow SDK utilises generic sharing of value types. For a detailed description on this problem and how it has been fixed in 2022.1, please read this [Unity blog post](https://blog.unity.com/engine-platform/il2cpp-full-generic-sharing-in-unity-2022-1-beta). 

## Managed Stripping Level

Similar to the previous setting, sometimes automatic code stripping on iOS can strip out functions that the optimizer thinks aren't needed, but they actually are. We highly recommend you change this setting to avoid any of these issues. 

1. Open Project Settings (under Edit). 
2. Go to the Player tab. 
3. Expand Other Settings and scroll down to Optimization. 
4. Change **Managed Stripping Level** to **Minimal**. # Wallet Connect

## Introduction

Wallet Connect is a production ready wallet provider which implements the `IWallet` interface. It's not an actual wallet itself - it's a bridge that connects your Unity game with Flow Wallets that support Wallet Connect. 

## What are Wallets? 

A wallet is a piece of software or hardware that stores the private key associated with a Flow account. The term *custodian* is used to refer to the party that stores the private key. Hardware Wallets (eg Ledger), typically USB devices, allow users to be their own custodian, whereas hosted software wallets (eg Dapper Wallet) act as the custodian on behalf of the user. 

For more information about Wallets and Flow accounts, see [user-accounts-and-wallets](../../../../tutorials/user-accounts-and-wallets.md). 

## What is a Wallet Provider? 

In terms of the Flow SDK for Unity, a Wallet Provider is a class which implements the `IWallet` interface and allows users to interact with specific hardware or software wallets. This includes authenticating with a wallet, retrieving the user's Flow account address from the wallet, and requesting the wallet to sign transactions on behalf of the user. 

As of v2.0.0, the Flow SDK for Unity contains two wallet providers - [Dev Wallet](./dev-wallet.md) and Wallet Connect. Dev Wallet is a mock wallet provider to make development easier, while Wallet Connect connects to real wallets and is therefore used for production. You could also implement your own wallet provider by implementing the `IWallet` interface. 

## How to implement Wallet Connect

To implement Wallet Connect, you must first register your project in the Wallet Connect dashboard to obtain a Project ID, then register the provider with the Flow SDK. 

### Obtain Project ID

1. Go to [https://cloud.walletconnect.com/sign-in](https://cloud.walletconnect.com/sign-in) and sign in, or create an account if you don't have one. 
2. Click on New Project and provide a name. 
3. Copy the Project ID. 

### Registering

Create an instance of WalletConnectProvider and initialize it with the required config, then register it with the Flow SDK. Here is an example:

```csharp
using DapperLabs.Flow.Sdk;
using DapperLabs.Flow.Sdk.WalletConnect;
using DapperLabs.Flow.Sdk.Crypto;

IWallet walletProvider = ScriptableObject.CreateInstance<WalletConnectProvider>();
walletProvider.Init(new WalletConnectConfig 
{
    ProjectId = "xxxxxxxxxxxxxxxxxxxxx", // the Project ID from the previous step
    ProjectDescription = "An example project to showcase Wallet Connect", // a description for your project
    ProjectIconUrl = "https://walletconnect.com/meta/favicon.ico", // URL for an icon for your project
    ProjectName = "Dapper Unity Example", // the name of your project
    ProjectUrl = "https://dapperlabs.com" // URL for your project
});
FlowSDK.RegisterWalletProvider(walletProvider);
```

The description, icon, name and URL that you provide will appear in your user's wallet apps, when they connect the game to their wallet. 

### Authenticating

The `IWallet.Authenticate` method is as follows: 

```csharp
public void Authenticate(string username, System.Action<string> OnAuthSuccess, System.Action OnAuthFailed);
```

`username` is ignored in the Wallet Connect provider. 
`OnAuthSuccess` is a function that will be called when you have successfully authenticated with a wallet. The callback function must take a `string` argument, which will contain the authenticated account's Flow address. 
`OnAuthFailed` is a function that will be called if authentication failed, for example if the user rejected the request in their wallet app. 

Here is an example of authenticating from game code: 

```csharp
FlowSDK.GetWalletProvider().Authenticate("", (string flowAddress) => 
{
    Debug.Log($"Authenticated - Flow account address is {flowAddress}");
}, () => 
{
    Debug.Log("Authentication failed.");
});
```

### Signing Transactions

If you are using the Flow SDK to sign transactions then you do not need to worry about this, as it is handled automatically. When you submit a transaction, the SDK will request Wallet Connect to sign the transaction as the authenticated user. The user will receive a notification in their wallet app to approve the transaction. 

For full disclosure, here are the methods on the `IWallet` interface to sign a transaction: 

```csharp
public Task<byte[]> SignTransactionPayload(FlowTransaction txn);

public Task<byte[]> SignTransactionEnvelope(FlowTransaction txn);
```

In Flow, there are two parts of a transaction that can be signed - the Payload and the Authorization Envelope. The envelope must always be signed, and is the last thing to be signed by the Payer of the transaction fees. The Payload is only signed by the Proposer and\or the Authorizers IF they are not also the Payer (i.e. nobody signs the transaction twice). For more information on transaction signing, see [transaction signing](../../../../build/basics/transactions.md#signing-a-transaction). 

The following is an example of how to call `SignTransactionEnvelope`, but as mentioned, this is automatically done by the SDK's `Transactions.Submit` function. It is asynchronous so is therefore `await`ed, and returns the signature as a byte array. 

```csharp
byte[] signature = await FlowSDK.GetWalletProvider().SignTransactionEnvelope(txRequest);
```

## What your users will see

When your game calls `Authenticate`, a dialog box will appear. The contents of the dialog box will depend on what platform the user is on. 

### Desktop builds (Windows, MacOS)

The authenticate dialog box will contain a QR code. The user must scan the QR code with their wallet app, after which their app will ask them to approve the connection with your game. Once they have approved the connection, they will receive any transaction requests submitted by the game in their wallet app. They can approve or reject these transaction requests. 

### Mobile builds (iOS, Android)

The authenticate dialog box will contain a list of wallet apps that support Flow and Wallet Connect. If an app is installed on the device, it will say `Installed` next to the name. Selecting an app will either open the app if it's installed, or direct the user to download the app from the App Store (iOS) or Play Store (Android). If the app was installed and is opened, the user can approve the connection with your game. Once they have approved the connection, they will receive any transaction requests submitted by the game in their wallet app. They can approve or reject these transaction requests. 

## Customising the Authentication Dialogs

You can customise the UI of both the QR Code (desktop builds) and Wallet Select (mobile builds) dialogs, allowing you to keep the same UI theme as the rest of your game. To do this, supply your custom prefabs to the Wallet Connect Config object during initialization, such as in the following example: 

```csharp
// Register WalletConnect
IWallet walletProvider = new WalletConnectProvider();
walletProvider.Init(new WalletConnectConfig
{
    ProjectId = "xxxxxxxxxxxxxxxxxxxxx", 
    ProjectDescription = "An example project to showcase Wallet Connect", 
    ProjectIconUrl = "https://walletconnect.com/meta/favicon.ico", 
    ProjectName = "Dapper Unity Example", 
    ProjectUrl = "https://dapperlabs.com" 
    QrCodeDialogPrefab = qrCodeCustomPrefab, // custom prefab for QR Code dialog (desktop builds)
    WalletSelectDialogPrefab = walletSelectCustomPrefab // custom prefab for Wallet Select dialog (mobile builds)
});
FlowSDK.RegisterWalletProvider(walletProvider);
```

> **Note**: \
Your custom QR Code prefab must have the `QRCodeDialog` script added as a component. \
Your custom Wallet Select prefab must have the `WalletSelectDialog` script added as a component. 
# Flow SDK for Unity

The Flow SDK for Unity allows Unity developers to integrate their games and applications with the Flow blockchain.

## Introduction

As games developers ourselves, we understand that most games developers don’t have any background in blockchain technology or even understand why it is used. The Flow SDK for Unity has been developed by games developers, for games developers. Our aim is to make blockchain integration as easy as possible, so that you can focus on making a great game.

First, it helps to understand why you would want to make a game on blockchain, and what you can do.

## Why Blockchain?

Here at Dapper Labs we’re big believers in Web3. The two main advantages of blockchain that we believe in are:

**Trustlessness** – there is no trust required in any particular platform or service. Once something is on the blockchain, it’s there to stay. Users have full confidence that the data you put on-chain will always be available – there are no servers or databases that can be taken down.

**Composability** – once your Smart Contracts have been deployed, other developers can utilize them. They can deploy additional Smart Contracts that leverage your own, or develop other client applications which use them. Creating composable pieces of software like this gives new experiences to existing audiences – it's a win-win for everyone.

## So blockchains are awesome... why Flow?

Flow is a fast, decentralized and developer-friendly layer-1 blockchain. It was created to solve problems that Dapper Labs encountered while scaling CryptoKitties on Ethereum. Flow differs from other blockchains because it was explicitly designed to support games and consumer applications on day one, with the throughput necessary to scale to millions of active users. Some points which are unique to Flow include:

-   Multi-node architecture which facilitates scalability
-   Very low transaction fees
-   Eco-friendly due to its proof-of-stake consensus and multi-node architecture
-   Cadence – Flow's Smart Contract language, a resource-oriented programming language which has in-built security features
-   Upgradable Smart Contracts

## Overview of the Flow SDK

The Flow SDK allows Unity games to read and write from\\to a Flow blockchain. There are three chains\\environments\\networks developers should be aware of:

-   Emulator – this is an executable you can run locally, or on your own network, which emulates a Flow blockchain.
-   Testnet – the publicly available Flow blockchain used for testing.
-   Mainnet – the publicly available Flow blockchain used for production.

We highly recommend you do most of your development against a local emulator, and only deploy to Testnet when your Smart Contracts are finalised. While Flow does have “upgradable Smart Contracts”, there are many caveats to this, and you should get into the mindset that Smart Contracts are completely immutable once deployed. On an emulator, you can simply erase the entire chain and start again.

The types of things you can do with the Flow blockchain include:

-   Mint, burn and trade NFTs and Fungible Tokens
-   Store game data
-   Read any publicly available information
-   Run game logic

It is completely up to you, the developer, to decide how much data\\logic you want to store\\run on-chain, and how much (if any) on off-chain architecture such as servers and databases. We encourage you to experiment on an emulator, and when you’re ready, test on Testnet to get an indication of performance.

## Adding the Flow SDK

To add the Flow SDK for Unity, go to it in the Asset Store and add it to My Assets: [https://assetstore.unity.com/packages/decentralization/flow-sdk-237172](https://assetstore.unity.com/packages/decentralization/flow-sdk-237172)

Once you've added it to your account, follow these instructions to import it into your project: [https://docs.unity3d.com/Manual/upm-ui-import.html](https://docs.unity3d.com/Manual/upm-ui-import.html)

Alternatively, the Flow SDK for Unity is hosted on github here: [https://github.com/onflow/UnityFlowSDK](https://github.com/onflow/UnityFlowSDK)

To add it to your Unity project directly from the github repo:

1. In the Unity Editor, go to Window, Package Manager. 
2. Click the + dropdown in the top left corner. 
4. Select "Add package from git URL" and enter `https://github.com/onflow/UnityFlowSDK.git`. 

## Updating the Flow SDK

Check the Package Manager regularly for updates to the Flow SDK. 

1. In the Unity Editor, go to Window, Package Manager. 
2. Under Packages - Dapper Labs, select Flow SDK. 
3. Click Update. If there is no Update button then you are already up to date. 

## Samples

To add any of the SDKs Samples, click the related import button, from the Flow SDK package panel, in the Unity Package Manager window.

## Requirements

The Flow SDK is compatible with Unity version 2021.3 or higher.

Supported Platforms: Windows, OSX, Android

## Support

Email: unity-sdk-support@dapperlabs.com

Discord: https://onflow.org/discord---
title: License
sidebar_position: 4
---

MIT License

Copyright 2023 Dapper Labs

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.# Flow Unity SDK - FlowWords Sample

This sample is a working pre-deployed version of our FlowWords tutorial sample, running on FLOW Testnet.\
To use this sample you will need a WalletConnect compatible Testnet wallet. e.g. Lilico.

If you do not already have a compatible wallet, you can sign up for one here: [https://lilico.app](https://lilico.app)\
You will need to install the mobile phone app. (iOS or Android)

Once installed, you will need to enable dev mode in the Lilico app, do so as follows;
1. Go to the settings menu, by clicking the profile icon on the bottom right corner of the screen.
2. Select Developer Mode to enter the Developer mode submenu

    ![Lilico Settings](../media/Lilico_Settings.jpg)

3. Enable Developer Mode with the toggle at the top of the screen, and then set the network to TestNet.

    ![Lilico Enable Devmode](../media/Lilico_TestnetEnable.jpg)

4. Back out to the wallet dashboard by clicking the back button at the top left of the screen, then clicking the Dashboard button (small $) in the bottom left corner of the screen.
5. At this point your wallet should say TESTNET at the top of the screen. If your FLOW balance is zero, you can fund your Testnet account via the FLOW Testnet Faucet here: [https://testnet-faucet.onflow.org/fund-account](https://testnet-faucet.onflow.org/fund-account)
    1. Enter your Testnet account address, as shown in the Lilico app
    2. Complete the captcha, and click 'Fund Your Account'
    3. Refresh your Lilico app on your device to see your new FLOW balance! (swipe down on the dashboard screen)

We assume you have already added the SDK package to your Unity project, and Imported the FlowWords Sample using the Unity Package Manager.
If you have not already done so, do this now. You can find instructions on how to do so [here.](../index.md#adding-the-flow-sdk)

1. Open Game.scene from the FlowWords sample folder. (Samples\Flow SDK\\&lt;version&gt;\Flow Words\Scenes)
2. Press Play in Unity to run the game sample.
3. Whenever the game presents you with a QR code, scan the code with your mobile Wallet App, and approve the transactions on your mobile device!# Tutorial - How to Build FlowWords

## Outline

The FlowWords tutorial example project is the complete FlowWords game, with the FlowSDK and any SDK related code removed.

In this tutorial, you will learn how to;

1.  Configure the FlowSDK and local emulator for use with Unity
2.  Deploy contracts, create Accounts and run Transactions on the Flow emulator from within Unity.
3.  Incorporate Flow Accounts, Transactions and Scripts into Unity projects using Code

## Requirements

FlowWords Tutorial has been tested on Unity version 2021.3.6f1

This tutorial assumes you have created a blank project, and installed the FlowSDK package from the Unity Asset Store, and FlowWords Tutorial Sample.

## Step 1 – Configure the FlowSDK and local emulator

1.  Open the scene at Assets\\Samples\\Flow SDK\\&lt;version&gt;\\Flow Words Tutorial Assets\\Scenes\\Game.unity

    ![Open Game scene example](../media/bac9d81383b8aeacab6e2f757f6c5f1c.png)

2.  Open the Flow Control Manager window, at Window-\>Flow-\>Flow Control.  
    This will create a Flow Control GameObject in the Game scene, and a FlowControlData asset in the Resources folder if they do not already exist.

    ![Open Flow Control Manager example](../media/f8bf765df950289fd3d1b7dc8e73d545.png)

3.  Go to the Emulator Settings tab. If the manager states the Flow Executable cannot be found, use the Install button provided and follow the instructions to install the Flow CLI.  
    Note: If Unity still does not detect the emulator after installing the Flow CLI, you may need to restart your computer for the install to take effect.
4.  Set a directory for our Emulator data to reside in. This is where the emulator stores the state of the emulated Flow blockchain.  
    For the purposes of this tutorial, we will create a new folder called FlowEmulator inside our project folder.

    ![Set Emulator data directory example](../media/4eaf391ee18bc8b70452e4495b5b317a.png)

5.  Click Start Emulator to start the emulator and create the emulator_service_account, and ensure “Run emulator in play mode” is checked.

    ![Start Emulator example](../media/4444607a3effafd2c5bb8430b8fade3f.png)

    NOTE: If this is the first time you have run the emulator on Windows, you may be presented with a dialog to allow access through your firewall. This is safe to allow.  
	
6.  Go to the Accounts tab and verify that the service account has been created.  
    This is the account we will use to create more accounts, and deploy our game contract on to the emulator.

    ![Flow Control Manager Accounts final state](../media/6279d33bd3d9eea312ef2f9b05000dbf.png)

7.  Back on the Emulator Settings tab, you can click Show Emulator Log, to view the output.

    ![Flow Emulator Output example](../media/d4ef2f464230b54400ff46b92f2eb01e.png)

## Step 2 – Deploy Contracts, create Accounts and run Transactions

We have provided you with the FlowWords game contract, but before we can interact with the contract, we have to deploy it to the blockchain.

We also have to set up some text replacements as, once deployed, our scripts will require hardcoded references to the contract name and deployed address.

### Set up Text Replacements

Text replacements allow us to set and update references across all of our local Cadence scripts, without having to update each file individually.

1.  Open the Flow Control Manager window, and navigate to the Text Replacements tab.
2.  Set up the text replacements as follows. You can add text replacements by clicking the ‘+’ button at the top of the panel.

    ![Flow Control Manager Text Replacement final state](../media/bd9262a67638aa9c519921629e8c9075.png)

    The anatomy of a text replacement is as follows;  
    **Description**: A friendly description, has no bearing on functionality.  
    **Original Text**: The original text, in your script files, which you want to replace.  
    **Replacement Text**: The text that you wish to replace the original text with. This is what gets submitted to the chain.  
    **Active**: This checkbox enables or disables the text replacement.  
    **Apply to Accounts**: Select which, if any, accounts this text replacement should apply to.  
    **Apply to Gateways**: Select which, if any, gateways (such as Emulator, or TestNet) this replacement should apply to.

### Create User Accounts

While it would be perfectly possible to play our game with the emulator service account, we will often want to test our contracts with multiple different user accounts.

To create a new user account;

1.  Open the Flow Control Manager window, and navigate to the Tools tab.
2.  In the Create New Account section;

    ![Flow Control Manager new account creation example](../media/aeda525491f7b1b329e57ac7d07fa997.png)

    1.  Select the paying account. This will usually be the emulator_service_account
    2.  Enter a friendly name for the new account. This name is just for your own reference and does not get written to the chain.
    3.  Click Create
3.  If successful, the new account will appear under the Flow Control Manager Accounts tab.

    ![Flow Control Manager new account example final state](../media/84ffa7104bc4de009c328960c1c9c6e7.png)

### Deploy the Contract

Before anyone can interact with a contract, it must be deployed to the blockchain.

We are going to deploy our game contract to the emulator, for local testing. But for deploying to Testnet, or Mainnet follow the same process.

1.  Go to the Emulator Settings tab, in the Flow Control Manager, and Start the Emulator if it is not already running.
2.  Go to the Tools tab. In the Manage Contracts section, enter the contract name of ‘FlowWords’ – this should match our CONTRACT_NAME text replacement precisely.
3.  Populate the Contract field with game-contract.cdc, which can be found in Resources/contracts
      
    ![Resources folder example](../media/741a3e12d817f800c2bced3c927912ba.png)
	
4.  Finally, ensure that the Account field contains emulator_service_account, and click the Deploy Contract button.

    ![Flow Control Manager contract deployment example](../media/ed8abd462a98bd71a9abe6a66c04d958.png)

5.  To check if the contract has deployed successfully, open the Flow Emulator Output window. Successful deployment will look as follows;

    ![Flow Emulator Output example](../media/0933fe23c63eedcd9ba2c4f3aac2878c.png)

### Submit Transactions

For administration purposes, it is sometimes useful to be able to directly submit transactions to the chain.

We can use a transaction to check out text replacements are set up correctly, and our game contract has successfully deployed.

1.  In Flow Control Manager, navigate to tools.
2.  In the Transactions section;

    ![Flow Control Manager contract deployment example](../media/2ce641e868905901df937c4dd09de105.png)

    1.  Populate the Transaction field with check-contract-deployed.cdc, located in Resources/transactions
	          
        ![Resources folder example](../media/0bc22650b47abb1cf606b2c7381a6377.png)
		
    2.  Set the Signer field to the new Account we just created earlier. ‘Player1’
    3.  Click Execute Transaction
3.  If you have successfully configured the SDK and deployed the game contract, you will see the following message;

    ![Flow Emulator Output example](../media/bd9b6a0a7261d3c605aad9760a304220.png)

## Step 3 – Incorporate Flow Accounts, Transactions and Scripts into Code

We have our SDK and emulator configured, and our game contract deployed.  
Now we are going to create the code which will allow our game to send and receive data from the blockchain.

Our FlowWords tutorial project contains a script called FlowInterface.cs, which can be found in the Scripts folder. This script contains all of our blockchain interfacing functions, which are called from GameManager.cs and UIManager.cs.

Our game FlowInterface has 5 main functions:

-   Login
-   Logout
-   GetGameDataFromChain
-   SubmitGuess
-   LoadHighScoresFromChain

Our functions are going to need to access a number of cadence scripts and transactions.  
These have been provided for you, and can be found in the Resources\\scripts folder and Resources\\transactions folder.

![Resources folder example](../media/e6a3c62a95440af5c38b47c9efa27a72.png)

FlowInterface.cs has a number of Serialized TextAsset fields, which can be populated via the Unity inspector. Select the GameFlowInterface gameobject in the Game.unity scene, and populate the fields as follows, using the scripts and transactions in the aforementioned folders; (you may find these have already been populated for you)

![GameFlowInterface script assignment final state example](../media/5569416d261ff8e9d05b53c082c8a1b1.png)

### Login
Open FlowInterface.cs and find the Login function stub.

The Login function’s role is to take the credentials entered by the user, create a FlowControl.Account object with which we can submit transactions to the chain, and run the login.cdc transaction.

At the top of the file, add the following using statements to grant us easy access to the Flow SDK structures.

```csharp
using DapperLabs.Flow.Sdk.Cadence;
using DapperLabs.Flow.Sdk.DataObjects;
using DapperLabs.Flow.Sdk.DevWallet;
using Convert = DapperLabs.Flow.Sdk.Cadence.Convert;
```

Your file should now look like this:

```csharp
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Threading.Tasks;
using UnityEngine;
using DapperLabs.Flow.Sdk;
using DapperLabs.Flow.Sdk.Unity;
using DapperLabs.Flow.Sdk.Cadence;
using DapperLabs.Flow.Sdk.DataObjects;
using DapperLabs.Flow.Sdk.DevWallet;
using Convert = DapperLabs.Flow.Sdk.Cadence.Convert;
```

Uncomment the following at line 56:
```csharp
//private FlowControl.Account FLOW_ACCOUNT = null;
```

We now have to register a wallet provider with the Flow SDK. We are going to use DevWallet, which comes with the Flow SDK, and is only intended for development purposes on emulator and testnet. Add the following to the `Start` function:

```cs
// Set up SDK to access Emulator
FlowConfig flowConfig = new FlowConfig()
{
    NetworkUrl = "http://127.0.0.1:8888/v1",  // emulator
    Protocol = FlowConfig.NetworkProtocol.HTTP
};
FlowSDK.Init(flowConfig);

// Register DevWallet wallet provider with SDK
FlowSDK.RegisterWalletProvider(new DevWalletProvider());
```
Your Start function should now look like this:

```csharp
private void Start()
{
    if (Instance != this)
    {
        Destroy(this);
    }

    // Set up SDK to access Emulator
    FlowConfig flowConfig = new FlowConfig()
    {
        NetworkUrl = "http://127.0.0.1:8888/v1",  // emulator
        Protocol = FlowConfig.NetworkProtocol.HTTP
    };
    FlowSDK.Init(flowConfig);

    // Register DevWallet wallet provider with SDK
    FlowSDK.RegisterWalletProvider(new DevWalletProvider());
}
```

> **WARNING:** Do not use DevWallet in production builds. It is only intended for development purposes and does NOT securely store keys.\
Having the Address and Private Keys to a blockchain account gives your application full access to all of that account’s funds and storage. They should be treated with extreme care.

Next, we will fill out the body of the Login function.

```csharp
/// <summary>
/// Attempts to log in by executing a transaction using the provided credentials
/// </summary>
/// <param name="username">An arbitrary username the player would like to be known by on the leaderboards</param>
/// <param name="onSuccessCallback">Function that should be called when login is successful</param>
/// <param name="onFailureCallback">Function that should be called when login fails</param>
public void Login(string username, System.Action<string, string> onSuccessCallback, System.Action onFailureCallback)
{
    // Authenticate an account with DevWallet

}
```

First, we have to invoke the wallet provider to authenticate the user and get their flow address. Add the following code to the Login function;

```cs
// Authenticate an account with DevWallet
FlowSDK.GetWalletProvider().Authenticate(
    "", // blank string will show list of accounts from Accounts tab of Flow Control Window
    (string address) => onSuccessCallback(address, username), 
    onFailureCallback);
```

The Authenticate function takes parameters as follows;

-	The first parameter is a username which corresponds to the name of an account in the Accounts tab. If you leave this string blank (as above), a dialog will be shown to the user to select an account from the Accounts tab. 
-	The second parameter is a success callback for `Authenticate()`. We pass in a lambda function which starts a coroutine to run our async function `OnAuthSuccess`. This takes the flow address that we got from `Authenticate()`, as well as a few other parameters. 
-	The third parameter is a callback for if `Authenticate()` fails. We pass through the fail callback that was passed to Login. 

Your completed Login function should look as follows; 

```csharp
/// <summary>
/// Attempts to log in by executing a transaction using the provided credentials
/// </summary>
/// <param name="username">An arbitrary username the player would like to be known by on the leaderboards</param>
/// <param name="onSuccessCallback">Function that should be called when login is successful</param>
/// <param name="onFailureCallback">Function that should be called when login fails</param>
public void Login(string username, System.Action<string, string> onSuccessCallback, System.Action onFailureCallback)
{
    // Authenticate an account with DevWallet
    if (FlowSDK.GetWalletProvider().IsAuthenticated() == false)
    {
        FlowSDK.GetWalletProvider().Authenticate(
            "", // blank string will show list of accounts from Accounts tab of Flow Control Window
            (string address) => onSuccessCallback(address, username),
            onFailureCallback);
    }
}

```
Now we need to implement the `GetGameDataFromChain` function for when we successfully authenticate our user and get their flow address.\
At this point we have successfully authenticated our user, and all subsequent Scripts and Transactions will be submitted via the authenticated account.


### GetGameDataFromChain

This function executes the get-current-gamestate.cdc transaction on the chain, and then processes the emitted events to get the CurrentGameState for the logged in account, and current GameStartTime for the game of the day, which we use to show time remaining.

```csharp
/// <summary>
/// Attempts to get the current game state for the user from chain.
/// </summary>
/// <param name="username">An arbitrary username the player would like to be known by on the leaderboards</param>
/// <param name="onSuccessCallback">Callback on success</param>
/// <param name="onFailureCallback">Callback on failure</param>
public IEnumerator GetGameDataFromChain(string username, System.Action<Decimal, List<GuessResult>, Dictionary<string, string>> onSuccessCallback, System.Action onFailureCallback)
{
    // get FLOW_ACCOUNT object for text replacements

    // execute getCurrentGameState transaction on chain

    // check for error. if so, break.

    // transaction success, get data from emitted events

    // process currentGameState event

    // process gameStartTime event

    // call GameManager to set game state

    yield return null;
}
```

As you will recall, we previously configured a number of text replacements.\
These are useful, and allow us to easily change some hardcoded data from a contract or transaction, such as the deploy address of the contract, from one central location without having to edit every cadence script in our project.\
Our transactions and scripts will need to access the text replacement function, which lives in the FlowControl.Account class, so we need to first create a FlowControl.Account object as follows;

```cs
// get FLOW_ACCOUNT object for text replacements
FLOW_ACCOUNT = new FlowControl.Account
{
    GatewayName = "Emulator",   // the network to match
    AccountConfig = new Dictionary<string, string> { { "Address", FlowSDK.GetWalletProvider().GetAuthenticatedAccount().Address } } // the account address to match
};
```

We are about to pull down the user's saved game data. To make processing event data easier, we have declared three classes to hold the results of events emitted by transactions:

```csharp
public class StatePayload
{
    public List<GuessResult> currentState;
}

public class TimePayload
{
    public Decimal startTime;
}

public class GuessResultPayload
{
    public string result;
}
```

Let's compare these to the payloads for each event in the contract:

```cadence
pub event CurrentState(currentState: [UserGuess])
pub event LastGameStart(startTime: UFix64)
pub event GuessResult(result: String)

pub struct UserGuess
{
    pub let Guess: String
    pub let Result: String
    init(guess: String, result: String)
    {
        self.Guess = guess
        self.Result = result
    }
}
```

When using Cadence.Convert, cadence arrays are converted into C# Lists, as shown in the StatePayload class and CurrentState event.

In GameManager.cs, the GuessResult class is declared as:

```csharp
public class GuessResult
{
    /// <summary>
    /// the guess that was submitted
    /// </summary>
    [Cadence(CadenceType = "String", Name = "Guess")]
    public string word;
    /// <summary>
    /// A 5 letter code indicating the result and resulting color a cell should be. 
    /// </summary>
    /// <remarks>
    /// "p" = the letter at this position was in the word and in the correct (p)osition, color the cell green.
    /// "w" = the letter at this position was in the (w)ord, but in the incorrect position, color the cell yellow.
    /// "n" = the letter at this position was (n)ot in the word.
    /// </remarks>
    [Cadence(CadenceType = "String", Name = "Result")]
    public string colorMap;
}
```

We want the Cadence fields ```Guess``` and ```Result``` to map to the C# fields ```word``` and ```colorMap```.  To do this, we add a Cadence attribute to each field with a ```Name```
parameter that tells it which Cadence fields maps to that class field.

We did not have to do that with the three payload classes we defined earlier because the C# field names exactly match the Cadence field names in the contract.

Now that we have an Account object for text replacement, we can use it with the Transactions class to Submit our login.cdc transaction.  

Add the following code to the GetGameDataFromChain function;

```cs
// execute getCurrentGameState transaction on chain
Task<FlowTransactionResult> getStateTask = Transactions.SubmitAndWaitUntilExecuted(FLOW_ACCOUNT.DoTextReplacements(loginTxn.text), new CadenceString(username));

while (!getStateTask.IsCompleted)
{
    int dots = ((int)(Time.time * 2.0f) % 4);

    UIManager.Instance.SetStatus($"Retrieving data from chain" + new string('.', dots));

    yield return null;
}
```
Because transactions can take quite some time on chain, we create an asynchronous Task by calling SubmitAndWaitUntilExecuted from the Transactions class, to prevent blocking the main game thread.  
Into SubmitAndWaitUntilExecuted, we pass the script that we want to execute, and any parameters.

For our script, we refer to the serialized TextAsset field, loginTxn, to which we will assign login.cdc in the inspector.  
We pass our script into SubmitAndWaitUntilExecuted via the DoTextReplacements function on our FLOW_ACCOUNT object, which will parse the cadence script and replace any of our defined text replacements.

For parameters, the login.cdc script is expecting a single String parameter with the player’s display name in it. We pass in a new CadenceString object, which we create inline from the encapsulating function’s username string parameter.

Next, we simply wait until our asynchronous task.IsCompleted.  
While we wait, we update the UI with a simple animated ‘Connecting…’ text status, and yield to the Unity engine to prevent blocking the thread.

Once our transaction has completed, we want to check if it was successful on chain. Add the following code beneath the transaction submission code;

```cs
// check for error. if so, break.
if (getStateTask.Result.Error != null || getStateTask.Result.ErrorMessage != string.Empty || getStateTask.Result.Status == FlowTransactionStatus.EXPIRED)
{
    onFailureCallback();
    yield break;
}
```

Here we must check the transaction Result for three conditions:

-   Error: Was there an error submitting the transaction to the blockchain?
-   ErrorMessage: Was there an error during processing on the blockchain?
-   Status: A status of EXPIRED means that the transaction did not execute on time and was discarded.

Any error here, and we are simply going to fail the login, and call our onFailureCallback.

Next, we process the result of our transaction.  
This transaction is designed to return the game state for the user, and the time remaining on the word of the day, via emitted events.  
We can access these emitted events via the .Result.Events property on our task.  
To do so, add the following code below our submission logic;

```cs
// transaction success, get data from emitted events
List<FlowEvent> events = getStateTask.Result.Events;
FlowEvent currentStateEvent = events.Find(x => x.Type.EndsWith(".CurrentState"));
FlowEvent startTimeEvent = events.Find(x => x.Type.EndsWith(".LastGameStart"));

if (currentStateEvent == null || startTimeEvent == null)
{
    onFailureCallback();
    yield break;
}
```

This chunk accesses the returned Events list, and attempts to find events ending with “.CurrentState” and “.LastGameStart”. We use .EndsWith, as the transaction returns fully qualified event names, and the name of the deployed contract may change during development.  
Finally, we check that we do indeed have both of our required events, and if not, call the onFailure callback and break.

Next, we will parse the contents of each event. Add the following code to the function;

```cs
// process current game state event
Decimal gameStartTime = 0;
Dictionary<string, string> letterStatuses = new Dictionary<string, string>();
List<GuessResult> results = Convert.FromCadence<StatePayload>(currentStateEvent.Payload).currentState;
foreach (GuessResult newResult in results)
{
    newResult.word = newResult.word.ToUpper();
    for (int i = 0; i < 5; i++)
    {
        bool letterAlreadyExists = letterStatuses.ContainsKey(newResult.word[i].ToString());
        string currentStatus = letterAlreadyExists ? letterStatuses[newResult.word[i].ToString()] : "";
        switch (currentStatus)
        {
            case "":
                letterStatuses[newResult.word[i].ToString()] = newResult.colorMap[i].ToString();
                break;
            case "p":
                break;
            case "w":
                if (newResult.colorMap[i] == 'p')
                {
                    letterStatuses[newResult.word[i].ToString()] = newResult.colorMap[i].ToString();
                }
                break;
            case "n":
                if (newResult.colorMap[i] == 'p' || newResult.colorMap[i] == 'w')
                {
                    letterStatuses[newResult.word[i].ToString()] = newResult.colorMap[i].ToString();
                }
                break;
        }
    }
}

// get game start time event
gameStartTime = Convert.FromCadence<TimePayload>(startTimeEvent.Payload).startTime;
```
From the contract, we know that the CurrentState event returns a list of ```UserGuess``` structs.  We want to convert these to a C# ```List<GuessResult>```.

```csharp
List<GuessResult> results = Convert.FromCadence<StatePayload>(currentStateEvent.Payload).currentState;
```

This converts the Payload of the currentStateEvent event into a ```StatePayload``` object, then sets results to the ```currentState``` field of that object.

Then, we iterate over the results list and update the letterStatuses that we display.



The GameStartTime event is processed similarly:

```csharp
gameStartTime = Convert.FromCadence<TimePayload>(startTimeEvent.Payload).startTime;
```

The startTimeEvent payload is converted into a TimePayload object and the startTime field is extracted from that.  Because the Cadence type is UFix64, we get back a C# Decimal struct.

Finally, we call our onSuccess callback to return our results to our caller.  
Add the following lines to the bottom of the function;

```cs
// call GameManager to set game state
onSuccessCallback(gameStartTime, results, letterStatuses);
```

You can now remove the ```yield return null``` at the base of the function if you wish.

Your completed function should now look like this;

```csharp
/// <summary>
/// Attempts to get the current game state for the user from chain.
/// </summary>
/// <param name="username">An arbitrary username the player would like to be known by on the leaderboards</param>
/// <param name="onSuccessCallback">Callback on success</param>
/// <param name="onFailureCallback">Callback on failure</param>
public IEnumerator GetGameDataFromChain(string username, System.Action<Decimal, List<GuessResult>, Dictionary<string, string>> onSuccessCallback, System.Action onFailureCallback)
{
    // get FLOW_ACCOUNT object for text replacements
    FLOW_ACCOUNT = new FlowControl.Account
    {
        GatewayName = "Emulator",   // the network to match
        AccountConfig = new Dictionary<string, string> { { "Address", FlowSDK.GetWalletProvider().GetAuthenticatedAccount().Address } } // the account address to match
    };

    // execute getCurrentGameState transaction on chain
    Task<FlowTransactionResult> getStateTask = Transactions.SubmitAndWaitUntilExecuted(FLOW_ACCOUNT.DoTextReplacements(loginTxn.text), new CadenceString(username));

    while (!getStateTask.IsCompleted)
    {
        int dots = ((int)(Time.time * 2.0f) % 4);

        UIManager.Instance.SetStatus($"Retrieving data from chain" + new string('.', dots));

        yield return null;
    }

    // check for error. if so, break.
    if (getStateTask.Result.Error != null || getStateTask.Result.ErrorMessage != string.Empty || getStateTask.Result.Status == FlowTransactionStatus.EXPIRED)
    {
        onFailureCallback();
        yield break;
    }

    // transaction success, get data from emitted events
    List<FlowEvent> events = getStateTask.Result.Events;
    FlowEvent currentStateEvent = events.Find(x => x.Type.EndsWith(".CurrentState"));
    FlowEvent startTimeEvent = events.Find(x => x.Type.EndsWith(".LastGameStart"));

    if (currentStateEvent == null || startTimeEvent == null)
    {
        onFailureCallback();
        yield break;
    }

    // process current game state event
    Decimal gameStartTime = 0;
    Dictionary<string, string> letterStatuses = new Dictionary<string, string>();
    List<GuessResult> results = Convert.FromCadence<StatePayload>(currentStateEvent.Payload).currentState;
    foreach (GuessResult newResult in results)
    {
        newResult.word = newResult.word.ToUpper();
        for (int i = 0; i < 5; i++)
        {
            bool letterAlreadyExists = letterStatuses.ContainsKey(newResult.word[i].ToString());
            string currentStatus = letterAlreadyExists ? letterStatuses[newResult.word[i].ToString()] : "";
            switch (currentStatus)
            {
                case "":
                    letterStatuses[newResult.word[i].ToString()] = newResult.colorMap[i].ToString();
                    break;
                case "p":
                    break;
                case "w":
                    if (newResult.colorMap[i] == 'p')
                    {
                        letterStatuses[newResult.word[i].ToString()] = newResult.colorMap[i].ToString();
                    }
                    break;
                case "n":
                    if (newResult.colorMap[i] == 'p' || newResult.colorMap[i] == 'w')
                    {
                        letterStatuses[newResult.word[i].ToString()] = newResult.colorMap[i].ToString();
                    }
                    break;
            }
        }
    }

    // get game start time event
    gameStartTime = Convert.FromCadence<TimePayload>(startTimeEvent.Payload).startTime;

    // call GameManager to set game state
    onSuccessCallback(gameStartTime, results, letterStatuses);
}
```


### Logout

The Logout function’s role is to disconnect the authenticated wallet from your app, and to clear the FlowControl.Account object, to prevent any more transactions from being executed with those account credentials.

The Logout function is very simple. Simply add the following line;

```cs
FLOW_ACCOUNT = null;
FlowSDK.GetWalletProvider().Unauthenticate();
```

This clears the FlowAccount object, preventing any more transactions from being submitted with it, and unauthenticates the user from the wallet provider. 

Your completed Logout function should now look like this;

```csharp
/// <summary>
/// Clear the FLOW account object
/// </summary>
public void Logout()
{
    FLOW_ACCOUNT = null;
    FlowSDK.GetWalletProvider().Unauthenticate();
}
```


### SubmitGuess

This function has two phases. First, it checks that the entered word is valid by submitting the check-word.cdc script to chain, and processing the returned value.

If the word is deemed valid, it then submits the word guess to the game contract using the currently logged in user’s credentials, by executing the submit-guess.cdc transaction script on chain, and then processing the emitted events.

For phase one, enter the following code at the top of the SubmitGuess function;

```cs
// submit word via checkWord script to FLOW chain to check if word is valid
Task<FlowScriptResponse> checkWordTask = Scripts.ExecuteAtLatestBlock(FLOW_ACCOUNT.DoTextReplacements(checkWordScript.text), new CadenceString(word.ToLower()));

while (!checkWordTask.IsCompleted)
{
    int dots = ((int)(Time.time * 2.0f) % 4);
    UIManager.Instance.SetStatus("Waiting for server" + new string('.', dots));
    yield return null;
}

if (checkWordTask.Result.Error != null)
{
    onFailureCallback();
    UIManager.Instance.SetStatus("Error checking word validity.");
    yield break;
}

bool wordValid = ((checkWordTask.Result.Value as CadenceString).Value == "OK");
if (wordValid == false)
{
    onFailureCallback();
    yield break;
}
```

This code starts by calling ExecuteAtLatestBlock, passing in the checkWordScript and our guess word as a CadenceString object, to create an async Task using our Flow Account object.

Scripts on Cadence can be thought of as read-only transactions, which are performed very quickly.  
Since scripts are read only, they do not require signing, and are best to use when you need to quickly get publicly available data from chain.

As with our previous transactions, we then wait until our task.IsCompleted, and then check for any errors in the result. With scripts we only have to check the Result.Error, as this catches all possible failure modes.

We then process the return value of the script, which can be found in the Result.Value property on our completed task object. Scripts do not emit events like transactions, but have return values like a regular function.  
The return value is of the generic base type CadenceBase, which we cast to CadenceString, as we are expecting a string type return value.

If the word guess is deemed to be invalid we call the onFailure callback and break, otherwise we proceed onto the guess submission phase.

For the second phase of the function, add the following code below phase one;

```cs
// if word is valid, submit guess via transaction to FLOW chain
Task<FlowTransactionResult> submitGuessTask = Transactions.SubmitAndWaitUntilExecuted(FLOW_ACCOUNT.DoTextReplacements(submitGuessTxn.text), new CadenceString(word.ToLower()));
while (!submitGuessTask.IsCompleted)
{
    int dots = ((int)(Time.time * 2.0f) % 4);
    UIManager.Instance.SetStatus("Waiting for server" + new string('.', dots));
    yield return null;
}

if (submitGuessTask.Result.Error != null || submitGuessTask.Result.ErrorMessage != string.Empty || submitGuessTask.Result.Status == FlowTransactionStatus.EXPIRED)
{
    onFailureCallback();
    yield break;
}

// get wordscore
string wordScore = "";
FlowEvent ourEvent = submitGuessTask.Result.Events.Find(x => x.Type.EndsWith(".GuessResult"));
if (ourEvent != null)
{
    wordScore = Convert.FromCadence<GuessResultPayload>(ourEvent.Payload).result;

    // check if we are out of guesses
    if (wordScore == "OutOfGuesses")
    {
        onFailureCallback();
        UIManager.Instance.SetStatus("Out Of Guesses. Try again tomorrow.");
        yield break;
    }

    // process result
    onSuccessCallback(word, wordScore);
}
else
{
    onFailureCallback();
}
```

This phase begins by submitting the submit-guess.cdc transaction, passing in our guess word as a new CadenceString parameter. We then wait for the task to complete as usual, and check for any errors.  
As this is a transaction, we once again check the three possible failure modes, and call the onFailure callback if the transaction failed.

Next we parse our transaction’s emitted events.

```cadence
pub event GuessResult(result: String)
```

We are expecting an event called GuessResult, with a single string parameter called result.  We created a C# version of that event: ```GuessResultPayload```.

```csharp
// get wordscore
string wordScore = "";
FlowEvent ourEvent = submitGuessTask.Result.Events.Find(x => x.Type.EndsWith(".GuessResult"));
if (ourEvent != null)
{
    wordScore = Convert.FromCadence<GuessResultPayload>(ourEvent.Payload).result;

    // check if we are out of guesses
    if (wordScore == "OutOfGuesses")
    {
        onFailureCallback();
        UIManager.Instance.SetStatus("Out Of Guesses. Try again tomorrow.");
        yield break;
    }

    // process result
    onSuccessCallback(word, wordScore);
}
else
{
    onFailureCallback();
}
```

We first find our event in the Result.Events list on our task object.

If our event is found, we then convert the payload to a ```GuessResultPayload``` and store the ```result``` field as ```wordScore```.  We then pass the guess word, and the result back to our caller via the onSuccess callback.

If the GuessResult event cannot be found in the Result.Events list, we call the onFailure callback.

Once complete, your SubmitGuess function should look like this:

```csharp
public IEnumerator SubmitGuess(string word, System.Action<string, string> onSuccessCallback, System.Action onFailureCallback)
{
    // submit word via checkWord script to FLOW chain to check if word is valid
    Task<FlowScriptResponse> checkWordTask = Scripts.ExecuteAtLatestBlock(FLOW_ACCOUNT.DoTextReplacements(checkWordScript.text), new CadenceString(word.ToLower()));
    while (!checkWordTask.IsCompleted)
    {
        int dots = ((int)(Time.time * 2.0f) % 4);
        UIManager.Instance.SetStatus("Waiting for server" + new string('.', dots));
        yield return null;
    }

    if (checkWordTask.Result.Error != null)
    {
        onFailureCallback();
        UIManager.Instance.SetStatus("Error checking word validity.");
        yield break;
    }

    bool wordValid = ((checkWordTask.Result.Value as CadenceString).Value == "OK");
    if (wordValid == false)
    {
        onFailureCallback();
        yield break;
    }
    
    // if word is valid, submit guess via transaction to FLOW chain
    Task<FlowTransactionResult> submitGuessTask = Transactions.SubmitAndWaitUntilExecuted(FLOW_ACCOUNT.DoTextReplacements(submitGuessTxn.text), new CadenceString(word.ToLower()));
    while (!submitGuessTask.IsCompleted)
    {
        int dots = ((int)(Time.time * 2.0f) % 4);
        UIManager.Instance.SetStatus("Waiting for server" + new string('.', dots));
        yield return null;
    }

    if (submitGuessTask.Result.Error != null || submitGuessTask.Result.ErrorMessage != string.Empty || submitGuessTask.Result.Status == FlowTransactionStatus.EXPIRED)
    {
        onFailureCallback();
        yield break;
    }

    // get wordscore
    string wordScore = "";
    FlowEvent ourEvent = submitGuessTask.Result.Events.Find(x => x.Type.EndsWith(".GuessResult"));
    if (ourEvent != null)
    {
        wordScore = Convert.FromCadence<GuessResultPayload>(ourEvent.Payload).result;

        // check if we are out of guesses
        if (wordScore == "OutOfGuesses")
        {
            onFailureCallback();
            UIManager.Instance.SetStatus("Out Of Guesses. Try again tomorrow.");
            yield break;
        }

        // process result
        onSuccessCallback(word, wordScore);
    }
    else
    {
        onFailureCallback();
    }
}
```

### LoadHighScoresFromChain

This function fires off a number of small scripts simultaneously, which pull publicly available high score data from the game contract on chain using;

-   get-highscores.cdc
-   get-player-cumulativescore.cdc
-   get-player-guess-distribution.cdc
-   get-player-maxstreak.cdc
-   get-player-scores.cdc
-   get-player-streak.cdc.

It then processes their returned values, and passes them out to the onSuccess call for the high scores UI to render.

For this function, we are going to first fire off a number of simultaneous scripts on the blockchain. This is something you want to avoid with transactions, as transaction order of execution cannot be guaranteed due to the distributed nature of blockchain, however as scripts are read-only, and do not mutate the chain, order of execution is far less likely to matter.

To execute the scripts, add the following code to the top of the function;

```cs
// get player's wallet public address
string playerWalletAddress = FlowSDK.GetWalletProvider().GetAuthenticatedAccount().Address;

// execute scripts to get highscore data
Dictionary<string, Task<FlowScriptResponse>> tasks = new Dictionary<string, Task<FlowScriptResponse>>();
tasks.Add("GetHighScores", Scripts.ExecuteAtLatestBlock(FLOW_ACCOUNT.DoTextReplacements(GetHighScores.text)));
tasks.Add("GetPlayerCumulativeScore", Scripts.ExecuteAtLatestBlock(FLOW_ACCOUNT.DoTextReplacements(GetPlayerCumulativeScore.text), new CadenceAddress(playerWalletAddress)));
tasks.Add("GetPlayerWinningStreak", Scripts.ExecuteAtLatestBlock(FLOW_ACCOUNT.DoTextReplacements(GetPlayerWinningStreak.text), new CadenceAddress(playerWalletAddress)));
tasks.Add("GetPlayerMaxWinningStreak", Scripts.ExecuteAtLatestBlock(FLOW_ACCOUNT.DoTextReplacements(GetPlayerMaxWinningStreak.text), new CadenceAddress(playerWalletAddress)));
tasks.Add("GetGuessDistribution", Scripts.ExecuteAtLatestBlock(FLOW_ACCOUNT.DoTextReplacements(GetGuessDistribution.text), new CadenceAddress(playerWalletAddress)));

// wait for completion
bool complete = false;
while (!complete)
{
    complete = true;
    foreach (KeyValuePair<string, Task<FlowScriptResponse>> task in tasks)
    {
        complete = complete && task.Value.IsCompleted;
    }
    yield return null;
}

// check for errors
foreach (KeyValuePair<string, Task<FlowScriptResponse>> task in tasks)
{
    if (task.Value.Result.Error != null)
    {
        onFailureCallback();
        yield break;
    }
}
```

This block of code first obtains the public address of the current authenticated player and creates a ```Dictionary<string, Task>``` to store our concurrent script tasks.  
We then sequentially create async Tasks for each script that we want to execute, using ExecuteAtLatestBlock, and add them to the Task dictionary.

In our use case, we want all of the tasks to complete before we display any results, so our wait for completion code block iterates over every Task in the dictionary, and only moves on once every task.IsComplete.

Checking for errors is similarly done using a foreach loop, where every task is checked to ensure the Error field is null. If even one task has an Error, we call the onFailure callback and break.

Next we need to process the returned values. Add the following code beneath the previous;

```cs
// load global highscores
List<ScoreStruct> GlobalScores = Convert.FromCadence<List<ScoreStruct>>(tasks["GetHighScores"].Result.Value);
GlobalScores = GlobalScores.OrderByDescending(score => score.Score).Take(10).ToList();

// load player scores
BigInteger PlayerCumulativeScore = Convert.FromCadence<BigInteger>(tasks["GetPlayerCumulativeScore"].Result.Value);
BigInteger PlayerWinningStreak = Convert.FromCadence<BigInteger>(tasks["GetPlayerWinningStreak"].Result.Value);
BigInteger PlayerMaximumWinningStreak = Convert.FromCadence<BigInteger>(tasks["GetPlayerMaxWinningStreak"].Result.Value);
List<BigInteger> PlayerGuessDistribution = Convert.FromCadence<List<BigInteger>>(tasks["GetGuessDistribution"].Result.Value);

// callback
onSuccessCallback(GlobalScores, PlayerCumulativeScore, PlayerWinningStreak, PlayerMaximumWinningStreak, PlayerGuessDistribution);
```

Our global highscores are an array of Scores objects in the contract.

```cadence
access(contract) let TopScores : [Scores]
pub struct Scores
{
    pub let AccId : Address
    pub let Name : String
    pub let Score : UInt
}
```

We have a ScoreStruct defined HighScoresPanel.cs as:

```csharp
public struct ScoreStruct
{
    public string Name;
    public BigInteger Score;
}
```

```csharp
List<ScoreStruct> GlobalScores = Convert.FromCadence<List<ScoreStruct>>(tasks["GetHighScores"].Result.Value);
GlobalScores = GlobalScores.OrderByDescending(score => score.Score).Take(10).ToList();
```

Here we get the result of the GetHighScores task and convert it into a ```List<ScoreStruct>```.  Then we reorder the list and keep only the highest ten values.

Next, we parse the detailed statistics for the current player, using ```Convert.FromCadence``` to convert from the Cadence values into the C# types we want.

Finally, we call the onSuccess callback, passing in all of our parsed results.

Once complete, your function should look as follows;

```csharp
public IEnumerator LoadHighScoresFromChain(System.Action<List<ScoreStruct>, BigInteger, BigInteger, BigInteger, List<BigInteger>> onSuccessCallback, System.Action onFailureCallback)
{
    // get player's wallet public address
    string playerWalletAddress = FlowSDK.GetWalletProvider().GetAuthenticatedAccount().Address;

    // execute scripts to get highscore data
    Dictionary<string, Task<FlowScriptResponse>> tasks = new Dictionary<string, Task<FlowScriptResponse>>();
    tasks.Add("GetHighScores", Scripts.ExecuteAtLatestBlock(FLOW_ACCOUNT.DoTextReplacements(GetHighScores.text)));
    tasks.Add("GetPlayerCumulativeScore", Scripts.ExecuteAtLatestBlock(FLOW_ACCOUNT.DoTextReplacements(GetPlayerCumulativeScore.text), new CadenceAddress(playerWalletAddress)));
    tasks.Add("GetPlayerWinningStreak", Scripts.ExecuteAtLatestBlock(FLOW_ACCOUNT.DoTextReplacements(GetPlayerWinningStreak.text), new CadenceAddress(playerWalletAddress)));
    tasks.Add("GetPlayerMaxWinningStreak", Scripts.ExecuteAtLatestBlock(FLOW_ACCOUNT.DoTextReplacements(GetPlayerMaxWinningStreak.text), new CadenceAddress(playerWalletAddress)));
    tasks.Add("GetGuessDistribution", Scripts.ExecuteAtLatestBlock(FLOW_ACCOUNT.DoTextReplacements(GetGuessDistribution.text), new CadenceAddress(playerWalletAddress)));

    // wait for completion
    bool complete = false;
    while (!complete)
    {
        complete = true;
        foreach (KeyValuePair<string, Task<FlowScriptResponse>> task in tasks)
        {
            complete = complete && task.Value.IsCompleted;
        }
        yield return null;
    }

    // check for errors
    foreach (KeyValuePair<string, Task<FlowScriptResponse>> task in tasks)
    {
        if (task.Value.Result.Error != null)
        {
            onFailureCallback();
            yield break;
        }
    }

    // load global highscores
    List<ScoreStruct> GlobalScores = Convert.FromCadence<List<ScoreStruct>>(tasks["GetHighScores"].Result.Value);
    GlobalScores = GlobalScores.OrderByDescending(score => score.Score).Take(10).ToList();

    // load player scores
    BigInteger PlayerCumulativeScore = Convert.FromCadence<BigInteger>(tasks["GetPlayerCumulativeScore"].Result.Value);
    BigInteger PlayerWinningStreak = Convert.FromCadence<BigInteger>(tasks["GetPlayerWinningStreak"].Result.Value);
    BigInteger PlayerMaximumWinningStreak = Convert.FromCadence<BigInteger>(tasks["GetPlayerMaxWinningStreak"].Result.Value);
    List<BigInteger> PlayerGuessDistribution = Convert.FromCadence<List<BigInteger>>(tasks["GetGuessDistribution"].Result.Value);

    // callback
    onSuccessCallback(GlobalScores, PlayerCumulativeScore, PlayerWinningStreak, PlayerMaximumWinningStreak, PlayerGuessDistribution);

    yield return null;
}
```

## Step 5 – Play FlowWords!

If you have correctly followed all of the steps above, you will now have a working project.

1.  Return to the Unity editor, and press the Play button.
2.  Enter a friendly name - this will appear on the leaderboard. 
3.  Click Log In. 
4.  Select an account from the dialog that appears to authenticate with. 

You should see the login screen, say Connecting…, and then Loading…

![Login Panel User Interface](../media/fe0ccbbb8fb583dd7c461a1436d9206c.png)

Followed shortly thereafter by the game screen;

![Game User Interface](../media/8cd5f4e2d4ac66693e0c2a6f796d1b38.png)

And the High Scores screen (if you click the button);

![HighScores User Interface](../media/eb0fba4dbd9a040424afb3182e5ce345.png)

## Step 6 – Further Experimentation

For an extra challenge, try some of the following;

-   Add more accounts and play with some friends, hot seat style
-   Modify the game-contract.cdc to make a new game every 5 minutes instead of every 24 hours.
-   Try to remove and redeploy the contract  
    (hint: on testnet and mainnet, once removed, a contract’s name can never be used again on the same account)  
    (extra hint: delete-game-resources.cdc)
-   Poke about in the game contracts, scripts and transactions to see what they do!

If you ever get the emulator into a messy state, you can always hit the Clear Persistent Data button, which will wipe the emulator back to its blank state. This will of course lose all deployed contracts and high score and game history.

## Appendix – How to convert FlowWords to run on TestNet

To modify the tutorial project to run on TestNet, only minor modifications are required.

1. Change the network configuration to point to TestNet
2. Replace the DevWallet provider with a more secure solution. e.g. WalletConnect
3. Configure Account and update Text Replacements
4. Deploy the contract to TestNet

### Change the network configuration to TestNet

To change the network configuration, simply modify the start function as follows;

```cs
private void Start()
{
    if (Instance != this)
    {
        Destroy(this);
    }

    // Set up SDK to access TestNet
    FlowConfig flowConfig = new FlowConfig()
    {
        NetworkUrl = "https://rest-testnet.onflow.org/v1",  // testnet
        Protocol = FlowConfig.NetworkProtocol.HTTP
    };
    FlowSDK.Init(flowConfig);

    // Register DevWallet wallet provider with SDK
    FlowSDK.RegisterWalletProvider(new DevWalletProvider());
}
```

We have now replaced the emulator address with the address for the TestNet access point, and all subsequent transactions and scripts will be directed to TestNet.

### Replace DevWallet with WalletConnect

To now change the wallet provider, simply modify the start function as follows;

```cs
private void Start()
{
    if (Instance != this)
    {
        Destroy(this);
    }

    // Set up SDK to access TestNet
    FlowConfig flowConfig = new FlowConfig()
    {
        NetworkUrl = "https://rest-testnet.onflow.org/v1",  // testnet
        Protocol = FlowConfig.NetworkProtocol.HTTP
    };
    FlowSDK.Init(flowConfig);

    // Create WalletConnect wallet provider
    IWallet walletProvider = new WalletConnectProvider();
    walletProvider.Init(new WalletConnectConfig
    {
        ProjectId = "<YOUR PROJECT ID>", // insert Project ID from Wallet Connect dashboard
        ProjectDescription = "A simple word guessing game built on FLOW!",
        ProjectIconUrl = "https://walletconnect.com/meta/favicon.ico",
        ProjectName = "FlowWords",
        ProjectUrl = "https://dapperlabs.com"
    });

    // Register WalletConnect wallet provider with SDK
    FlowSDK.RegisterWalletProvider(walletProvider);
}
```

You will also need to add the following using declarations to the top of the file;

```cs
using DapperLabs.Flow.Sdk.WalletConnect;
using DapperLabs.Flow.Sdk.Crypto;
```

For this modification we have created a new WalletConnectProvider, and initialized it, and then registered our new WalletConnectProvider.

The only thing missing is a Project Id.\
Each WalletConnect application requires its own project id. You can get one by going to https://cloud.walletconnect.com and signing up for an account.\
You can then create a new project on the website, give it a name (we suggest FlowWords), and enter the project id provided into your code.

Finally, we need one more change to make sure our text replacement still functions correctly.

At the beginning of the OnAuthSuccess function, change the FLOW_ACCOUNT GatewayName from "Emulator" to "Flow Testnet".

```cs
// get FLOW account - we are only going to use this for text replacements
FLOW_ACCOUNT = new FlowControl.Account
{
    GatewayName = "Flow Testnet",
    AccountConfig = new Dictionary<string, string> { { "Address", FlowSDK.GetWalletProvider().GetAuthenticatedAccount().Address } }
};
```

### Configure Account and update Text Replacements

To deploy the contract to TestNet, the only current way to do so via the FlowSDK, is to use a TestNet account to which you know the private key.

First, in the Accounts tab of the Flow Control window, create a new account by clicking the plus '+' icon at the top of the window.\
Create the new account as follows, replacing the Address and Private Key with your own valid TestNet address / private key pair.

![New Account Example](../media/AppendixNewAccount.png)

Switch to the Text Replacements tab of the Flow Control window now, and create a new text replacement definition as follows, replacing the given replacement text with the address to your TestNet account.

![New Text Replacement Example](../media/AppendixTextReplacement.png)

Now modify the existing CONTRACT_NAME text replacement, by changing the Apply to Gateways field from Emulator, to All. This will make sure this replacement also applies to TestNet transactions.

### Deploy the Contract to TestNet

Now that all of the configuration is done, you can deploy the contract.

On the Tools tab of the Flow Control window, set up the Manage Contracts section as follows;

![New Account Example](../media/AppendixDeployContract.png)

Where;
- Contract Name is the name of the contract on the blockchain. This should match the text replacement configured for CONTRACT_NAME
- Contract is the game-contract.cdc asset included with the project sample in the Assets\\Samples\\Flow SDK\\&lt;version&gt;\\Flow Words Tutorial Assets\\Resources directory.
- Account is the new Deploy Account that you created in the previous step.

Once you have the Manage Contracts section filled in as per the example, click Deploy Contract.

If all goes well, you will see the text 'Executing Transaction' appear below the Deploy Contract button, followed by a clickable link to the transaction result on [Flowdiver](https://testnet.flowdiver.io/).

Congratulations! You can now run FlowWords, and play the game with a WalletConnect compatible wallet!

> **NOTE:** TestNet requires that all contracts deployed to an account have a unique name, does not allow contract removal without authorisation, and only allows contract updates that do not break interfaces or data structures or introduce undefined data to existing resources.\
\
Due to these limitations, iterative development should always be done on Emulator before attempting to push anything to a live network.

# Simple NFT Viewer

This example project will show you how to build a simple viewer that will allow you to view NFTs that conform to the [NFT](https://github.com/onflow/flow-nft) and [MetadataViews](https://github.com/onflow/flow-nft#nft-metadata) standards.

This tutorial will mostly ignore the C# code that actually displays the NFTs and focus on a high level summary of the steps used.

## Overview

When querying the blockchain we utilize four scripts:
```
* [GetCollections.cdc](Cadence/GetCollections.cdc) - Gets a list of Collections that conform to NFT.Collection for a given address
* [GetNftIdsForCollection.cdc](Cadence/GetNftIdsForCollection.cdc) - Gets a list of all NFT IDs that are contained in a given collection
* [GetDisplayDataForIDs.cdc](Cadence/GetDisplayDataForIDs.cdc) - Gets just the display data for a given NFT
* [GetFullDataForID.cdc](Cadence/GetFullDataForID.cdc) - Gets a more comprehensive set of data for a single NFT.
```
While we could use a single script to query for all the data, larger collections will cause the script to time out. Instead we query for just the data we need to reduce the chances of a timeout occurring.

## Finding Collections

First we need to get a list of all collections on an account that are a subtype of NFT.Collection.

```cadence
import NonFungibleToken from 0x1d7e57aa55817448

pub fun main(addr: Address) : [StoragePath] {
    //Get the AuthAccount for the given address.
    //The AuthAccount is needed because we're going to be looking into the Storage of the user
    var acct = getAuthAccount(addr)
    
    //Array that we will fill with all valid storage paths
    var paths : [StoragePath] = []
    
    //Uses the storage iteration API to iterate through all storage paths on the account
    acct.forEachStored(fun (path: StoragePath, type:Type): Bool {
        //Check to see if the resource at this location is a subtype of NonFungibleToken.Collection.
        if type.isSubtype(of: Type<@NonFungibleToken.Collection>()) {
            //Add this path to the array
            paths.append(path)
        }
        
        //returning true tells the iterator to continue to the next entry
        return true
    });
    
    //Return the array that we built
    return paths
}
```

We use the [Storage Iteration API](https://cadence-lang.org/docs/language/accounts#storage-iteration) to look at everything the account has in it's storage and see if it is an NFT Collection.  We return a list of all found NFT Collections.

## Getting NFT IDs Contained in a Collection

We use this to create a list of collection paths a user can pick from.  When the user selects a path to view, we fetch a list of IDs contained in that collection:

```cadence
import NonFungibleToken from 0x1d7e57aa55817448

pub fun main(addr: Address, path: StoragePath) : [UInt64] {
    //Get the AuthAccount for the given address.
    //The AuthAccount is needed because we're going to be looking into the Storage of the user
    var acct = getAuthAccount(addr)
    
    //Get a reference to an interface of type NonFungibleToken.Collection public backed by the resource located at path
    var ref = acct.borrow<&{NonFungibleToken.CollectionPublic}>(from: path)!
    
    //Return the list of NFT IDs contained in this collection
    return ref!.getIDs()
}
```

## Getting Display Data for an NFT

After we get a list of the available NFT IDs, we need to get some basic data about the NFT to display the thumbnail icon.

```cadence
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub fun main(addr: Address, path: StoragePath, ids: [UInt64]) : {UInt64:AnyStruct?} {
    //Array to hold the NFT display data that we will return
    //We use AnyStruct? because that is the type that is returned by resolveView.
    var returnData: {UInt64:AnyStruct?} = {}

    //Get account for address
    var acct = getAuthAccount(addr)
    
    //Get a reference to a capability to the storage path as a NonFungibleToken.CollectionPublic
    var ref = acct.borrow<&{NonFungibleToken.CollectionPublic}>(from: path)!
    
    //Loop through the requested IDs
    for id in ids {       
        //Get a reference to the NFT we're interested in
        var nftRef = ref.borrowNFT(id: id)
        
        //If for some reason we couldn't borrow a reference, continue onto the next NFT
        if nftRef == nil {
            continue
        }

        //Fetch the information we're interested in and store it in our NFT structure
        returnData[id] = nftRef.resolveView(Type<MetadataViews.Display>())
    }
    
    return returnData
}
```
This gives us a dictionary that maps NFT IDs to Display structs (```{UInt64:MetadataViews.Display}```).  Because accessing this information can be tedious in C#, we can define some C# classes to make our lives easier:

```csharp
public class File
{
    public string url;
    public string cid;
    public string path;
}

public class Display
{
    public String name;
    public String description;
    public File thumbnail;
}
```

This will allow us to use Cadence.Convert to convert from the CadenceBase that the script returns into a Display class.

This line in NFTViewer.cs is an example of converting using Cadence.Convert:

```csharp
Dictionary<UInt64, Display> displayData = Convert.FromCadence<Dictionary<UInt64, Display>>(scriptResponseTask.Result.Value);
```

You might ask whey we don't combine GetNftIdsForCollection.cdc and GetDisplayDataForIDs.cdc to get the Display data at the same time we get the list of IDs.  This approach would work in many cases, but when an account contains large numbers of NFTs, this could cause a script timeout.  Getting the list of IDs is a cheap call because the NFT contains this list in an array already.
By getting just the NFT IDs, we could implement paging and use multiple script calls to each fetch a portion of the display data.
This example doesn't currently do this type of paging, but could do so without modifying the cadence scripts.

## Getting Complete NFT Data

When a user selects a particular NFT to view in more detail, we need to fetch that detail.

```cadence
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

//Structure that will hold all the data we want for an NFT
pub struct NFTData {
    pub(set) var NFTView: AnyStruct?
    pub(set) var Display : AnyStruct?
    pub(set) var HTTPFile: AnyStruct?
    pub(set) var IPFSFile: AnyStruct?
    pub(set) var Edition: AnyStruct?
    pub(set) var Editions: AnyStruct?
    pub(set) var Serial: AnyStruct?
    pub(set) var Royalty: AnyStruct?
    pub(set) var Royalties: AnyStruct?
    pub(set) var Media: AnyStruct?
    pub(set) var Medias: AnyStruct?
    pub(set) var License: AnyStruct?
    pub(set) var ExternalURL: AnyStruct?
    pub(set) var NFTCollectionDisplay: AnyStruct?
    pub(set) var Rarity: AnyStruct?
    pub(set) var Trait: AnyStruct?
    pub(set) var Traits: AnyStruct?
    
    init() {
        self.NFTView = nil
        self.Display = nil
        self.HTTPFile = nil
        self.IPFSFile = nil
        self.Edition = nil
        self.Editions = nil
        self.Serial = nil
        self.Royalty = nil
        self.Royalties = nil
        self.Media = nil
        self.Medias = nil
        self.License = nil
        self.ExternalURL = nil
        self.NFTCollectionDisplay = nil
        self.Rarity = nil
        self.Trait = nil
        self.Traits = nil
    }
}

pub fun main(addr: Address, path: StoragePath, id: UInt64) : NFTData? {
    //Get account for address
    var acct = getAuthAccount(addr)
    
    //Get a reference to a capability to the storage path as a NonFungibleToken.CollectionPublic
    var ref = acct.borrow<&{NonFungibleToken.CollectionPublic}>(from: path)!
    
    //Get a reference to the NFT we're interested in
    var nftRef = ref.borrowNFT(id: id)
    
    //If for some reason we couldn't borrow a reference, continue onto the next NFT
    if nftRef == nil {
        return nil
    }

    var nftData : NFTData = NFTData() 

    //Fetch the information we're interested in and store it in our NFT structure
    nftData.Display = nftRef.resolveView(Type<MetadataViews.Display>())
    nftData.NFTView = nftRef.resolveView(Type<MetadataViews.NFTView>())
    nftData.HTTPFile = nftRef.resolveView(Type<MetadataViews.HTTPFile>())
    nftData.IPFSFile = nftRef.resolveView(Type<MetadataViews.IPFSFile>())
    nftData.Edition = nftRef.resolveView(Type<MetadataViews.Edition>())
    nftData.Editions = nftRef.resolveView(Type<MetadataViews.Editions>())
    nftData.Serial = nftRef.resolveView(Type<MetadataViews.Serial>())
    nftData.Media = nftRef.resolveView(Type<MetadataViews.Media>())
    nftData.Rarity = nftRef.resolveView(Type<MetadataViews.Rarity>())
    nftData.Trait = nftRef.resolveView(Type<MetadataViews.Trait>())
    nftData.Traits = nftRef.resolveView(Type<MetadataViews.Traits>())
    nftData.Medias = nftRef.resolveView(Type<MetadataViews.Medias>())
    nftData.ExternalURL = nftRef.resolveView(Type<MetadataViews.ExternalURL>())
    nftData.Royalty = nftRef.resolveView(Type<MetadataViews.Royalty>())
    nftData.Royalties = nftRef.resolveView(Type<MetadataViews.Royalties>())
    nftData.License = nftRef.resolveView(Type<MetadataViews.License>())
    nftData.NFTCollectionDisplay = nftRef.resolveView(Type<MetadataViews.NFTCollectionDisplay>())
    
    return nftData
}
```
Here we define a struct NFTData that will contain all the different information we want and fill the struct via multiple resolveView calls.

## C# Classes for Easy Converting

The end of NFTViewer.cs contains classes that we use to more easily convert from Cadence into C#.  One thing to note is that the Cadence structs contain Optionals, like:

```var IPFSFile: AnyStruct?```

while the C# versions do not, such as 

```public IPFSFile IPFSFile;```

This is because we are declaring them as Classes, not Structs.  Classes in C# are reference types, which can automatically be null.  We could have used Structs, in which case we'd have to use:

```public IPFSFile? IPFSFile```

This would wrap the IPFSFile struct in a Nullable, which would allow it to be null if the Cadence value was nil.

Another thing to note is the declaration of the C# File class:

```csharp
public class File
{
    public string url;
    public string cid;
    public string path;

    public string GetURL()
    {
        if (string.IsNullOrEmpty(url) && !string.IsNullOrEmpty(cid))
        {
            return $"https://ipfs.io/ipfs/{cid}"; 
        }

        return url;
    }
}
```

Compare this to the File interface in the MetadataViews contract:

```cadence
    pub struct interface File {
        pub fun uri(): String
    }
```

The MetadataViews.File interface doesn't actually contain any fields, only a single method.  Because only two things in MetadataViews implement the
File interface (HTTPFile and IPFSFile), we chose to combine the possible fields into our File class.

```cadence
pub struct HTTPFile: File {
        pub let url: String
}

pub struct IPFSFile: File {
    pub let cid: String
    pub let path: String?
}
```

This allows Cadence.Convert to convert either an HTTPFile or an IPFSFile into a File object.  We can then check which fields are populated to determine which it was initially.

This works fine for this simple viewer, but a more robust approach might be to create a ResolvedFile struct in the cadence script which has a single uri field and populates it by calling the uri() function on whatever File type was retrieved.
# Simple NFT demo

This tutorial will show you how to create, mint and list a simple NFT.  It follows the
Non Fungible Token standard (https://github.com/onflow/flow-nft/blob/master/contracts/NonFungibleToken.cdc),
but does not implement the MetadataViews interface.  If you would like to make your NFT compatible with
marketplaces, look at implementing MetadataViews (https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc)

The following are the main points of this tutorial:
1. Creating a contract that implements INFT
2. Deploying the contract
3. Listing, minting and storing NFTs defined by the contract via a transaction


### Getting started
Load the Samples/Flow SDK/x.x.x/Example NFT/Scenes/NFTExampleScene scene.
Press play and approve the transactions that come up (only on first time run)
Click Authenticate and choose the emulator_service_account.
Click Mint
Fill in the Text and URL fields and click Mint
Approve the transaction
Click List to refresh the NFT display panel and show your newly minted NFT
Repeat Mint and List as desired to make your list grow

Now we'll show you how this works.

### Creating an NFT contract

When creating an NFT it is recommended (but not required) to implement the NonFungibleToken.INFT
interface.  We will be doing so in this case.

At its simplest, an NFT on Flow is a resource with a unique id.  A Collection is a resource
that will allow you to store, list, deposit, and withdraw NFTs of a specific type.

We recommend reading through the [NFT tutorial](https://cadence-lang.org/docs/tutorial/non-fungible-tokens-1)
to understand what is happening, as well as reviewing the contents of Cadence/Contracts/SDKExampleNFT.cdc

The SDKExampleNFT minter allows for anyone to mint an SDKExampleNFT.  Typically you would restrict
minting to an authorized account.

This tutorial will not delve deeply into the NFT contract or Cadence, instead focusing on interacting
with them using the functionality the Unity SDK provides.

### Deploying the contracts

Open up Example.cs to follow along.

Our Start function looks like this:

```csharp
public void Start()
{
    //Initialize the FlowSDK, connecting to an emulator using HTTP
    FlowSDK.Init(new FlowConfig
    {
        NetworkUrl = FlowControl.Data.EmulatorSettings.emulatorEndpoint,
        Protocol = FlowConfig.NetworkProtocol.HTTP
    });

    //Register the DevWallet provider that we will be using
    FlowSDK.RegisterWalletProvider(new DevWalletProvider());
    
    //Deploy the NonFungibleToken and SDKExampleNFT contracts if they are not already deployed
    StartCoroutine(DeployContracts());
}
```

This initializes the FlowSDK to connect to the emulator, creates and registers a DevWalletProvioder, then
starts a coroutine to deploy our contract if needed.

Contracts can be deployed via the FlowControl Tools window, but we will deploy them via code for ease
of use.

The DeployContracts coroutine:

```csharp
public IEnumerator DeployContracts()
{
    statusText.text = "Verifying contracts";
    //Wait 1 second to ensure emulator has started up and service account information has been captured.
    yield return new WaitForSeconds(1.0f);

    //Get the address of the emulator_service_account, then get an account object for that account. 
    Task<FlowAccount> accountTask = Accounts.GetByAddress(FlowControl.Data.Accounts.Find(acct => acct.Name == "emulator_service_account").AccountConfig["Address"]);
    //Wait until the account fetch is complete
    yield return new WaitUntil(() => accountTask.IsCompleted);

    //Check for errors.
    if (accountTask.Result.Error != null)
    {
        Debug.LogError(accountTask.Result.Error.Message);
        Debug.LogError(accountTask.Result.Error.StackTrace);
    }

    //We now have an Account object, which contains the contracts deployed to that account.  Check if the NonFungileToken and SDKExampleNFT contracts are deployed
    if (!accountTask.Result.Contracts.Exists(x => x.Name == "SDKExampleNFT") || !accountTask.Result.Contracts.Exists(x => x.Name == "NonFungibleToken"))
    {
        statusText.text = "Deploying contracts,\napprove transactions";

        //First authenticate as the emulator_service_account using DevWallet
        FlowSDK.GetWalletProvider().Authenticate("emulator_service_account", null, null);

        //Ensure that we authenticated properly
        if (FlowSDK.GetWalletProvider().GetAuthenticatedAccount() == null)
        {
            Debug.LogError("No authenticated account.");
            yield break;
        }

        //Deploy the NonFungibleToken contract
        Task<FlowTransactionResponse> txResponse = CommonTransactions.DeployContract("NonFungibleToken", NonFungibleTokenContract.text);
        yield return new WaitUntil(() => txResponse.IsCompleted);
        if (txResponse.Result.Error != null)
        {
            Debug.LogError(txResponse.Result.Error.Message);
            Debug.LogError(txResponse.Result.Error.StackTrace);
            yield break;
        }

        //Wait until the transaction finishes executing
        Task<FlowTransactionResult> txResult = Transactions.GetResult(txResponse.Result.Id);
        yield return new WaitUntil(() => txResult.IsCompleted);
        
        //Deploy the SDKExampleNFT contract
        txResponse = CommonTransactions.DeployContract("SDKExampleNFT", SDKExampleNFTContract.text);
        yield return new WaitUntil(() => txResponse.IsCompleted);
        if (txResponse.Result.Error != null)
        {
            Debug.LogError(txResponse.Result.Error.Message);
            Debug.LogError(txResponse.Result.Error.StackTrace);
            yield break;
        }

        //Wait until the transaction finishes executing
        txResult = Transactions.GetResult(txResponse.Result.Id);
        yield return new WaitUntil(() => txResult.IsCompleted);

        //Unauthenticate as the emulator_service_account
        FlowSDK.GetWalletProvider().Unauthenticate();
    }

    //Enable the Authenticate button.
    authenticateButton.interactable = true;
    statusText.text = "";
}
```

We start by waiting one second.  This ensures that the emulator has finished initializing and
the required service account has been populated.

Next we fetch the emulator_service_account Account.  This Account object will contain the contracts
that are deployed to the account.  We check if both the required contracts are deployed,
and if they are not, we deploy them.

Upon first running the scene, you will be presented with two popups by DevWallet.  This authorizes
the transactions that will deploy the contracts.  You will not see these popups during subsequent
runs because the contracts will already be present on the account.  If you purge the emulator
data, you will see the popups again the next time you play the scene.

When using Testnet or Mainnet, the NonFungibleToken contract will already be deployed at a known location.
Launching the emulator with the --contracts flag will also deploy this contract.  I this case we are running
without --contracts, so we will deploy the NonFungibleToken contract ourselves.

### Listing, minting, and storing NFTs

Now that the contracts are in place, the Authenticate button will be clickable.  This uses the
registered wallet provider (DevWalletProvider) to authenticate.  Unless you create another account
using the FlowControl Tools panel, only emulator_service_account will be available.

After clicking Authenticate, it will prompt you to select an account to authenticate as.  Choose
emulator_service_account.  This is done with the following functions:

```csharp
    public void Authenticate()
    {
        FlowSDK.GetWalletProvider().Authenticate("", OnAuthSuccess, OnAuthFailed);
    }
    
    private void OnAuthFailed()
    {
        Debug.LogError("Authentication failed!");
        accountText.text = $"Account:  {FlowSDK.GetWalletProvider().GetAuthenticatedAccount()?.Address??"None"}";
        if (FlowSDK.GetWalletProvider().GetAuthenticatedAccount() == null)
        {
            mintPanelButton.interactable = false;
            listButton.interactable = false;
        }
    }

    private void OnAuthSuccess(string obj)
    {
        accountText.text = $"Account:  {FlowSDK.GetWalletProvider().GetAuthenticatedAccount().Address}";
        mintPanelButton.interactable = true;
        listButton.interactable = true;
    }
```

If authentication succeeds, a coroutine is started that will  make the Mint button available.

Clicking on the Mint button displays the Minting panel that will allow you to customize the NFT that will
be minted:

```csharp
public void ShowMintPanel()
    {
        textInputField.text = "";
        URLInputField.text = "";
        mintPanel.SetActive(true);
    }
```

### Minting
Clicking Mint in the Mint panel will trigger the creation of the NFT with the supplied text.


```csharp
public void MintNFT()
    {
        if(FlowSDK.GetWalletProvider() != null && FlowSDK.GetWalletProvider().IsAuthenticated())
        {
            StartCoroutine(MintNFTCoroutine());
        }
        
        mintPanel.SetActive(false);
    }
```

```csharp
    public IEnumerator MintNFTCoroutine()
    {
        statusText.text = "Minting...";
        List<CadenceBase> args = new List<CadenceBase>
        {
            Convert.ToCadence(new Dictionary<string, string>
            {
                ["Text"] = textInputField.text,
                ["URL"] = URLInputField.text
            }, "{String:String}")
        };

        Task<FlowTransactionResponse> txResponse = Transactions.Submit(mintTransaction.text, args);
        
        while(!txResponse.IsCompleted)
        {
            yield return null;
        }

        if (txResponse.Result.Error != null)
        {
            statusText.text = "Error, see log";
            Debug.LogError(txResponse.Result.Error.Message);
            yield break;
        }

        Task<FlowTransactionResult> txResult = Transactions.GetResult(txResponse.Result.Id);

        while (!txResult.IsCompleted)
        {
            yield return null;
        }

        if (txResult.Result.Error != null)
        {
            statusText.text = "Error, see log";
            Debug.LogError(txResult.Result.Error.Message);
            yield break;
        }
        
        statusText.text = "";
    }
```

Because transactions can take a while, they are done in coroutines to prevent the interface from locking
up.

First we construct a list of arguments we are going to pass to the transaction in MintAndSave.cdc.  This
list consists of a single Dictionary containing the "Text" and "URL" keys and String values from the Mint
panel.  We use Cadence.Convert to convert from a `Dictionary<string, string>` into a Cadence `{String:String}`
for the argument.

The MintAndSave.cdc file contains the transaction that will be executed.

```cadence
import SDKExampleNFT from 0xf8d6e0586b0a20c7
import NonFungibleToken from 0xf8d6e0586b0a20c7

transaction(md: {String:String}) {
    let acct : AuthAccount
    
    prepare(signer: AuthAccount) {
        self.acct = signer
    }
    
    execute {
        // Create collection if it doesn't exist
        if self.acct.borrow<&SDKExampleNFT.Collection>(from: SDKExampleNFT.CollectionStoragePath) == nil
        {
            // Create a new empty collection
            let collection <- SDKExampleNFT.createEmptyCollection()
            // save it to the account
            self.acct.save(<-collection, to: SDKExampleNFT.CollectionStoragePath)
            // link a public capability for the collection
            self.acct.link<&{SDKExampleNFT.CollectionPublic, NonFungibleToken.CollectionPublic}>(
                SDKExampleNFT.CollectionPublicPath,
                target: SDKExampleNFT.CollectionStoragePath
            )
        }
        
        //Get a reference to the minter
        let minter = getAccount(0xf8d6e0586b0a20c7)
            .getCapability(SDKExampleNFT.MinterPublicPath)
            .borrow<&{SDKExampleNFT.PublicMinter}>()
        
        
        //Get a CollectionPublic reference to the collection
        let collection = self.acct.getCapability(SDKExampleNFT.CollectionPublicPath)
            .borrow<&{NonFungibleToken.CollectionPublic}>()
              
        //Mint a new NFT and deposit into the authorizers account
        minter?.mintNFT(recipient: collection!, metadata: md)
    }
}
```

This transaction checks to see if an SDKExampleNFT collection exists on the account, creating/saving/linking it if it does
not.  Then it calls the contract to mint a new NFT with the desired metadata and saves it to the collection.

### Listing NFTs

The List button calls the UpdateNFTPanelCoroutine function that is responsible for populating the panel with information
about the SDKExampleNFT resources in the account you are authenticated as.

```csharp
public IEnumerator UpdateNFTPanelCoroutine()
{
    //Create the script request.  We use the text in the GetNFTsOnAccount.cdc file and pass the address of the
    //authenticated account as the address of the account we want to query.
    FlowScriptRequest scriptRequest = new FlowScriptRequest
    {
        Script = listScript.text,
        Arguments = new List<CadenceBase>
        {
            new CadenceAddress(FlowSDK.GetWalletProvider().GetAuthenticatedAccount().Address)
        }
    };

    //Execute the script and wait until it is completed.
    Task<FlowScriptResponse> scriptResponse = Scripts.ExecuteAtLatestBlock(scriptRequest);
    yield return new WaitUntil(() => scriptResponse.IsCompleted);

    //Destroy existing NFT display prefabs
    foreach (TMP_Text child in NFTContentPanel.GetComponentsInChildren<TMP_Text>())
    {
        Destroy(child.transform.parent.gameObject);
    }
    
    //Iterate over the returned dictionary
    Dictionary<ulong, Dictionary<string, string>> results = Convert.FromCadence<Dictionary<UInt64, Dictionary<string, string>>>(scriptResponse.Result.Value);
    //Iterate over the returned dictionary
    foreach (KeyValuePair<ulong, Dictionary<string, string>> nft in results)
    {
        //Create a prefab for the NFT
        GameObject prefab = Instantiate(NFTPrefab, NFTContentPanel.transform);
        
        //Set the text
        string text = $"ID:  {nft.Key}\n";
        foreach (KeyValuePair<string,string> pair in nft.Value)
        {
            text += $"    {pair.Key}: {pair.Value}\n";
        }
        
        prefab.GetComponentInChildren<TMP_Text>().text = text;
    }
}
```

When running a script, you can query any account.  In this case we will only query the account
that is authenticated with the wallet provider.

It executes the script defined in GetNFTsOnAccount.cdc:

```cadence
import SDKExampleNFT from 0xf8d6e0586b0a20c7

pub fun main(addr:Address): {UInt64:{String:String}} {

    //Get a capability to the SDKExampleNFT collection if it exists.  Return an empty dictionary if it does not
    let collectionCap = getAccount(addr).getCapability<&{SDKExampleNFT.CollectionPublic}>(SDKExampleNFT.CollectionPublicPath)
    if(collectionCap == nil)
    {
        return {}
    }
    
    //Borrow a reference to the capability, returning an empty dictionary if it can not borrow
    let collection = collectionCap.borrow()
    if(collection == nil)
    {
        return {}
    }

    //Create a variable to store the information we extract from the NFTs
    var output : {UInt64:{String:String}} = {}
    
    //Iterate through the NFTs, extracting id and metadata from each.
    for id in collection?.getIDs()! {
        log(collection!.borrowSDKExampleNFT(id:id))
        log(collection!.borrowSDKExampleNFT(id:id)!.metadata)
        output[id] = collection!.borrowSDKExampleNFT(id:id)!.metadata;
    }
    
    //Return the constructed data
    return output
}
```

This ensures that an SDKExampleNFT.Collection resource exists at the proper path, then creates and returns
a ```{UInt64:{String:String}}``` containing the information of all SDKExampleNFTs in the collection.  We use
Cadence.Convert to convert this into a C# ```Dictionary<UInt64, Dictionary<string,string>>```

After that we Instantiate prefabs to display the data of each of the returned NFTs.﻿# FlowControl scripting example
This example shows how to use FlowControl to perform common tasks purely from C#, without using
the FlowControl editor interface.  This will ignore any of the GUI related code and focus on
using the FlowControl and Flow SDK.

## Prerequisites
Ensure you have flow-cli installed.  This will allow us to use an emulated flow environment.
You can install it by following the instructions at [Flow CLI](../../../../tools/flow-cli/install.md)

## Sample walk through
You can follow along in FlowControlExample.cs

The first thing to notice is that we declare Start() to be an IEnumerator.  This makes Start a coroutine.
You will always want to run FlowSDK functions inside a coroutine because they can take a while to complete
and you don't want to lock up your game while they are processed.

```csharp
private IEnumerator Start()
{
    // Your start code
}
```

## Checking emulator state
The next thing we do is ensure the emulator is running.  We give it a few seconds to start:

```csharp
//Wait up to 2.5 seconds for the emulator to start.
int waited = 0;

while (!FlowControl.IsEmulatorRunning && waited < 5)
{
    waited++;
    yield return new WaitForSeconds(.5f);
}

if (!FlowControl.IsEmulatorRunning)
{
    //Stop execution if the emulator is not running by now.
    yield break;
}
```

## Creating a FlowControl Account
Next we'll create a FlowControl account to use ***ONLY*** for running scripts.  The Flow network
doesn't require an account to run scripts, but FlowControl uses Accounts to determine which network
to connect to.

```csharp
FlowControl.Account scriptOnlyAccount = new FlowControl.Account
{
    GatewayName = "Emulator"
};
```

Because this account doesn't have any keys associated with it, it can't be used to run transactions.
It does define which Gateway to use, in this case the "Emulator" gateway, so it can be used
to run scripts.

## Running scripts

Next, we'll use this account to run a script on the emulator.  Scripts on Flow are written in Cadence.
More information is available at [Developer Portal](https://cadence-lang.org/docs/language/)

First we'll define the script that we want to run:

```csharp
const string code = @"pub fun main(message: String): Int{
    log(message)
    return 42
}";
```

This script requires a Cadence String as input, returns a Cadence Int, and will log the input
string to the emulator log.

Now we execute this script:

```csharp
Task<FlowScriptResponse> task = scriptOnlyAccount.ExecuteScript(code, Convert.ToCadence("Test", "String"));
```

FlowControl uses an Account oriented approach.  Everything is done using an Account object.  In this
case we'll use the scriptOnlyAccount account that we created earlier to call ExecuteScript.

A script is code that can not permanently mutate the state of the blockchain.  It is read-only.
It ***CAN*** call functions that would change the state of the blockchain, but any changes that are
made will be discarded once the script finishes running.

We pass in the Cadence code we want to run and any arguments that are required by the script.
We need to use Cadence specific data types, so  we construct a new CadenceString using the string
"Test".

This returns a `Task<FlowScriptResponse>`.  This is an asynchronous Task that will result
in a FlowScriptResponse when it is complete.

Next, we need to wait for the Task to complete.  Inside a Unity coroutine we can use the `WaitUntil`
function as follows:

```csharp
yield return new WaitUntil(() => task.IsCompleted);
```

`WaitUntil` takes a function that returns a bool (`Func<bool>`), so we construct an anonymous one that
returns the IsCompleted field of the task.  This cause Unity to pause execution of the current coroutine
until the task is completed.

We then check to see if an error occured, and if so, log it to the console.

```csharp
if (task.Result.Error != null)
{
    Debug.LogError($"Error:  {task.Result.Error.Message}");
    yield break;
}
```

If there is no error, the script should have returned a Cadence Int value.  We can access it as follows:

```csharp
Debug.Log($"Script result: {Convert.FromCadence<BigInteger>(task.Result.Value)}");
```

This might be a bit confusing.  The Task will have a Result.  The result could contain an error,
but we checked for that earlier.  If it doesn't contain an error, then it will contain a Value.

That Value will be of type CadenceBase, which is the base type for all Cadence data types.  We
know that the script returns a number, so we can convert it to an appropriate data type using Convert.FromCadence.

## Creating an SdkAccount

Next, let's create an account that can be used to execute transactions that mutate the state of
the blockchain.  This will also demonstrate how you can use both FlowControl and the base SDK
together.

```csharp
SdkAccount emulatorSdkAccount = FlowControl.GetSdkAccountByName("emulator_service_account");
if (emulatorSdkAccount == null)
{
    Debug.LogError("Error getting SdkAccount for emulator_service_account");
    yield break;
}
```

When the emulator is started, FlowControl automatically creates an emulator_service_account FlowControl.Account
for you to use to access the built in emulator service account.  We'll use that account to create a new account.

Because the `CreateAccount` function is an SDK function, and not a FlowControl function, we'll need to create a
temporary `SdkAccount` from the FlowControl Account.  The `GetSdkAccountByName` function will construct an
SdkAccount object from a FlowControl.Account object.

If the name you pass to `FlowControl.GetSdkAccountByName` does not exist, it will return null, so we check
for that and stop execution if it fails.

## Creating an account on the blockchain

Now we'll use this new SdkAccount object to create a new Flow account on the emulated blockchain.

```csharp
FlowSDK.RegisterWalletProvider(ScriptableObject.CreateInstance<DevWalletProvider>());

string authAddress = "";
FlowSDK.GetWalletProvider().Authenticate("", (string address) =>
{
    authAddress = address;
}, null);

yield return new WaitUntil(() => { return authAddress != ""; });

//Convert FlowAccount to SdkAccount
SdkAccount emulatorSdkAccount = FlowControl.GetSdkAccountByAddress(authAddress);
if (emulatorSdkAccount == null)
{
    Debug.LogError("Error getting SdkAccount for emulator_service_account");
    yield break;
}

//Create a new account with the name "User"
Task<SdkAccount> newAccountTask = CommonTransactions.CreateAccount("User");
yield return new WaitUntil(() => newAccountTask.IsCompleted);

if (newAccountTask.Result.Error != null)
{
    Debug.LogError($"Error creating new account: {newAccountTask.Result.Error.Message}");
    yield break;
}

outputText.text += "DONE\n\n";

//Here we have an SdkAccount
SdkAccount userSdkAccount = newAccountTask.Result;

```
First we create and register a new `DevWalletProvider`.  Any time a transaction is run, it calls the provided wallet provider.  The `DevWalletProvider`
is an implementation of IWallet that shows a simulated wallet interface.  It will allow you to view and authorize the submitted transaction.

After creating and registering the wallet provider, we call `Authenticate` to display a popup that will allow you to select any of the accounts in the FlowControl
Accounts tab.  You should choose emulator_service_account when prompted when running the demo.

We then wait until the user has selected an account.

`CommonTransactions` contains some utility functions to make performing frequent operations a little easier.
One of these is `CreateAccount`.  It expects a `Name`, which is not placed on the blockchain, and the SdkAccount
that should pay for the creation of the new account.  That returns a Task that is handled similarly to
before.

If there is no error, the Result field of the task will contain the newly create account info.

Now, in order to use this new account with FlowControl, we'll need to create a FlowControl.Account from
the SdkAccount we have.

```csharp
FlowControl.Account userAccount = new FlowControl.Account
{
    Name = userSdkAccount.Name,
    GatewayName = "Emulator",
    AccountConfig = new Dictionary<string, string>
    {
        ["Address"] = userSdkAccount.Address,
        ["Private Key"] = userSdkAccount.PrivateKey
    }
};
```

Then we store this account in the FlowControlData object so that we can look it up by name later.

```csharp
FlowControl.Data.Accounts.Add(userAccount);
```

## Deploying a contract

The next section shows how to deploy a contract to the Flow network.  Because this is another utility
function from `CommonTransactions`, it needs an SdkAccount.  We'll use userSdkAccount we created earlier.

First we need to define the contract we wish to deploy.

```csharp
const string contractCode = @"
    pub contract HelloWorld {
        pub let greeting: String

        pub event TestEvent(field: String)

        init() {
            self.greeting = ""Hello, World!""
        }

        pub fun hello(data: String): String {
            emit TestEvent(field:data)
            return self.greeting
        }
    }";
```

We won't discuss how to write Flow contracts in depth here, but simply put this contract defines a single
function that will emit an event and return the string "Hello World!" when run.

Then we use the same pattern we've used before to deploy this contract using the `CommonTransaction.DeployContract`
function.  Note that we should register a new wallet provider since we are changing the account we want to run the transaction
as.

```csharp
FlowSDK.GetWalletProvider().Authenticate(userAccount.Name, null, null);
Task<FlowTransactionResponse> deployContractTask = 
    CommonTransactions.DeployContract("HelloWorld", contractCode);

yield return new WaitUntil(() => deployContractTask.IsCompleted);

if (deployContractTask.Result.Error != null)
{
    Debug.LogError($"Error deploying contract: {deployContractTask.Result.Error.Message}");
    yield break;
}
```
We'll reauthenticate with the wallet provider to tell it to use the new newly created account.  Because we pass in a name this time, it
won't display the select account pop-up.

The first argument to `DeployContract` is the contract name.  This must match the name in the contract
data itself.  The second argument is the Cadence code that defines the contract, and the third argument
is the SdkAccount that the contract should be deployed to.

## Replacement text

Next we'll see how to add a `ReplacementText` entry to FlowControl.  This is typically done via the
FlowControl editor interface, but can be done programatically as shown.

```csharp
FlowControl.TextReplacement newTextReplacement = new FlowControl.TextReplacement
{
    description = "User Address",
    originalText = "%USERADDRESS%",
    replacementText = userSdkAccount.Address,
    active = true,
    ApplyToAccounts = new List<string> { "User" },
    ApplyToGateways = new List<string> { "Emulator" }
};

FlowControl.Data.TextReplacements.Add(newTextReplacement);
```

Note that we are setting `ApplyToAccounts` and `ApplyToGateways` so that this `TextReplacement` will be
performed any time the FlowControl.Account account with the name "User" executes a function against the emulator.

This new `TextReplacement` will be used when we execute a transaction using the contract we just deployed.

## Transactions

First we'll write the transaction we want to execute.

```csharp
string transaction = @"
    import HelloWorld from %USERADDRESS% 
    transaction {
        prepare(acct: AuthAccount) {
            log(""Transaction Test"")
            HelloWorld.hello(data:""Test Event"")
        }
    }";
```

Based on the `TextReplacement` we created earlier, `%USERADDRESS%` will be replaced with the Flow address
of the user account we created.  This will then call the `hello` function on the `HelloWorld` contract
we deployed to the user account.

Next we follow a similar pattern to before:

```csharp
Task<FlowTransactionResult> transactionTask = userAccount.SubmitAndWaitUntilSealed(transaction);
yield return new WaitUntil(() => transactionTask.IsCompleted);

if (transactionTask.Result.Error != null || !string.IsNullOrEmpty(transactionTask.Result.ErrorMessage))
{
    Debug.LogError($"Error executing transaction: {transactionTask.Result.Error?.Message??transactionTask.Result.ErrorMessage}");
    yield break;
}
```

Here, we're using the `SubmitAndWaitUntilSealed` FlowControl function.  This combines two SDK functions
together.  It first submits the transaction to the network.  Then it polls the network until the network
indicates that the transaction has been sealed and then returns the results.

Because this is combining two operations together, there are two potential failure points.  The first
is a network error or syntax error that causes the submission to be rejected.  This will be indicated
in the `Result.Error` field.  The second is something that goes wrong during the processing of the
transaction after submission was successful.  This will be indicated in the Result.ErrorMessage field.
When using SubmitAndWaitUntilSealed or SubmitAndWaitUntilExecuted, you will want to check both of the
error fields to ensure it has completed successfully.

Finally, we check the events emitted by the transaction.  Because submitting transactions returns before
the transaction is actually processed, you can't return data directly from a transaction like you can
with a script.  Instead, you emit events that can be retrieved.  We'll check the events of the completed
transaction as follows:

## Transaction Events

```csharp
FlowEvent txEvent = transactionTask.Result.Events.Find(x => x.Type.Contains("TestEvent"));

//Show that the transaction finished and display the value of the event that was emitted during execution.
//The Payload of the returned FlowEvent will be a CadenceComposite.  We want the value associated with the
//"field" field as a string
Debug.Log($"Executed transaction.  Event type: {txEvent.Type}.  Event payload: {Convert.FromCadence<TestEvent>(txEvent.Payload).field}");
```

We end up a with a list of Events that were emitted by a transaction in the `Result.Events` object.  We
use LINQ to find the event we're interested in.  It will contain "TestEvent" in it.

We need something to convert the Cadence TestEvent into, so we declared a C# class earlier:

```csharp
public class TestEvent
{
    public String field;
}
```

Then we have to get the payload from the event to display.  We'll convert it into our TestEvent class and access the ```field``` field.

# Sample - FlowSDK Usage Demo

This sample demonstrates how to call each of the APIs within the SDK. It's a simple UI containing input fields and buttons for testing out each API call, and displays information that is returned by the APIs. You will need to set up an emulator with applicable test data to use this sample.

## Importing the Sample

To import the sample, first add the Flow SDK to your project, then follow these steps.

1.  Open Package Manager.
2.  Select the Flow SDK package.
3.  On the right, expand Samples and click Import next to FlowSDK Usage Demo.

![](../media/fd52a768f2367b763980b22d85479305.png)

This will import the sample into a Samples folder under your Assets:

![](../media/58d03fbcda193c672c0287da2f3f04ba.png)

## Installing the Flow Emulator

To install the Flow emulator, please follow the instructions for your platform here:

[flow-cli/install](../../../../tools/flow-cli/index.md)

Note that the Flow CLI and Flow emulator are bundled into the same command-line executable.

To test that the Flow emulator is installed correctly, open a command line interface, type `flow` and press enter. You should see something like this:

![](../media/be2bc6569ca5a475b3c147cf34f07c1a.png)

## Configuring the Emulator

The directory that you run the emulator from must contain a flow.json file. A default one can be created by running the command `flow init`, but this sample contains a flow.json file which is specific to the sample:

![](../media/54f8a5235b61d70f09904c38ed3e5e5c.png)

Firstly, open the scene that comes with the sample:

![](../media/881d1efa0c8e4ff9bffe3382274a255c.png)

Select the UI Canvas in the hierarchy:

![](../media/82ea27a997c12eab231ad8bf2e49d335.png)

In the inspector, scroll down to the bottom and click "Open Flow Control Window":

![](../media/61267a392954311426b4144345f25dfd.png)

The Flow Control Window contains all the editor tools that come with the Flow SDK. It should look like this:

![](../media/6d33d20949b4923d1e805e8e21884935.png)

If you see a message asking you to install the Flow emulator, then Unity has not detected your Flow installation. Click the Install button and follow the directions to install the Flow CLI \\ emulator.

To run the emulator, we need to specify which directory to run it from, remembering that it requires a flow.json file. Click the browse button and select the folder in the sample that contains the flow.json file (it should be in **Assets/Samples/Flow SDK/\<version\>/FlowSDK Usage Demo/Scripts/Cadence**):

![](../media/62ec9ee52b31041e7420ac7ad7132684.png)

Click on Start Emulator. The message at the bottom of the window should say **Emulator Status: Running**. Click on Emulator Log. This will open another window showing the output of the emulator:

![](../media/f6a8324547c8ec499a2eb68248091ba3.png)

To test the emulator, open a command line interface and enter the command `flow blocks get latest`. You should see something like this:

![](../media/270ed3d6ac5df815d35cc82f588a4a18.png)

The command retrieves information about the latest block on the blockchain. The latest block is currently block height 0, meaning that there is only one block on the blockchain, the root block (hence why Parent ID is null). Now we're going to add some more blocks.

In your file explorer, navigate to the folder that the emulator is running from. Execute the **emulator_test_data** script for your platform (**.bat** for windows, **.sh** for mac/linux). When the script has finished, go back to your command line interface and enter the command `flow blocks get latest` again. Now you should see something like this:

![](../media/2466ac711f979da15f6ad5a6cdb6421a.png)

There are now 11 blocks on your blockchain emulator - the latest block is at block height 10 (remember the first one was block height 0). Every block has its own ID and the ID of its parent, the previous block in the chain.

You are now ready to run the sample app.

## Running the FlowSDK Usage Demo

Click the Play button in the editor. You will see the following:

![](../media/3421ca4434716e8f2efc89bbf5f3c7ad.png)

The buttons along the bottom display different tabs which correspond to different API calls within the SDK. The tabs demonstrate the following API calls:

**Blocks**

*GetById*  
*GetByHeight*  
*GetLatest*

**Collections**

*GetById*

**Events**

*GetForBlockHeightRange*  
*GetForBlockIds*

**Scripts**

*ExecuteAtLatestBlock*

**Transactions**

*Submit*  
*GetById*  
*GetResult*

**Accounts**

*GetByAddress*

We will now discuss each of the tests throughout the sample. As you read through each of these, it's recommended to look at the code calling these APIs. All of the code is contained here:

![](../media/15840cee138659b172d6023791b73155.png)

### Blocks

Blocks are the foundation of blockchains, and Flow is no different. A Block primarily consists of two things - Collections and Block Seals. Collections contain Transactions that are yet to be executed, while Block Seals contain the results of Transactions that have been executed and verified, and are ready to be sealed.

**Get Block by ID**

*MainUIController.BlocksGetById()*

Enter a valid Block ID and click the button to retrieve information about the block.

**Get Block by Height**

*MainUIController.BlocksGetByHeight()*

Enter a valid Block Height to retrieve information about the block at that height.

**Get Latest Block**

*MainUIController.BlocksGetLatest()*

Simply click the button to retrieve information about the latest block.

### Collections

A Collection contains a list of Transactions to be executed.

**Get Collection by ID**

*MainUIController.CollectionsGetById()*

Enter a valid Collection ID to retrieve information about the collection.

### Events

Events are defined and emitted in your Smart Contracts. You would emit an event when you want to later query that something has happened.

**Get Events for Height Range**

*MainUIController.EventsGetForHeightRange()*

This will retrieve any events of the given type emitted in a given block height range. Enter the Type, Start Block Height and End Block Height and click the button.

**Get Events for Block Ids**

*MainUIController.EventsGetForBlockIds()*

Similar to the previous API, but instead of providing a block height range, you provide a comma separated list of Block Ids. Any events matching the Type that were emitted in those Block Ids will be returned.

For both of the API calls, the dropdown in the bottom left will populate with a list of blocks. Selecting a block in the list will populate the right-hand side with the event results.

#### Event Types

For both of these API calls, the Event Type is a fully qualified type in the following format:

```
A.{contract address}.{contract name}.{event name}
```

Contract address - the account that the Smart Contract which defines the event is deployed to.   
Contract name - the name of the Smart Contract which defines the event.   
Event name - the name of the event as defined in the Smart Contract.

Here is an example of an Event Type:

```
A.7e60df042a9c0868.FlowToken.TokensInitialized
```

#### Core Events

There are a few core events that are emitted directly by Flow and don't follow the standard naming convention. These event types are:

```
flow.AccountCreated  
flow.AccountKeyAdded  
flow.AccountKeyRemoved  
flow.AccountContractAdded  
flow.AccountContractUpdated  
flow.AccountContractRemoved
```

### Scripts

Scripts are cadence code that you write and are executed on the blockchain. They can contain arguments and return values, and can interact with Smart Contracts. Scripts are read-only - they cannot mutate anything on the blockchain. Anything held in local memory is discarded when the script finishes execution. For more information on programming see [Cadence](../../../../build/guides/smart-contracts/cadence.md).

**Execute Simple Script At Latest Block**

*MainUIController.ExecuteSimpleScript()*

This executes a very simple script which returns a string message. The message is printed to the UI.

**Execute Script With Args At Latest Block**

*MainUIController.ExecuteScriptWithArgs()*

This demonstrates sending arguments with a simple script. Enter a number in each of the input fields and click the button. The script will add the numbers together and return the result, printing it to the UI.

**Execute Get Tokens At Latest Block**

*MainUIController.ExecuteGetTokens()*

The **emulator_test_data** script that you ran earlier deployed a Smart Contract for fungible tokens called FlowSDKSampleToken. It also created a few accounts and minted some of these tokens into a couple of accounts.

This test demonstrates passing an account address as an argument to a script, which returns a single value - the number of FlowSDKSampleTokens that account has.

In the Flow Control Window, click the Accounts tab. This shows a few accounts which you can get the address of to test the script.

![](../media/51d4f1e5f01dc36b0fdd0853eb08b0bd.png)

If you would like to see the cadence script itself, it is located here:

![](../media/f30282a8889db37965bcd49b209ac614.png)

**Execute Print NFTs At Latest Block**

*MainUIController.ExecutePrintNfts()*

The **emulator_test_data** script also deployed a contract called FlowSDKSampleNFT, an example implementation of an NFT. It also minted a few of these NFTs and deposited them into a couple of accounts.

This test is similar to the previous one - enter an account address into the input field and click the button to retrieve a list of NFTs that account owns. Instead of returning a single value, the script returns an array of values (NFT Ids).

The cadence script for this test is in the same location as the previous test, called **print-nfts.cdc**.

**Execute Get NFTs For Sale At Latest Block**

*MainUIController.ExecuteGetNftsForSale()*

This script does not have any arguments, but demonstrates returning a complex data structure - an array of structs. The struct, which has multiple properties, is defined in the script itself.

The data being returned is a list of NFTs that are for sale, and contains the Id, price and owner's address for each NFT. Right now it will not return anything, because there are no NFTs for sale. You will need to run the **Submit Transaction List NFT** test in the Transactions tab for this script to display anything.

The cadence script for this test is in the same location as the others, called **get-nfts-for-sale.cdc**.

### Transactions

Like Scripts, Transactions are cadence code that you write and are executed on the blockchain, but that is where the similarities end. The purpose of Transactions is to mutate data on the blockchain. To do this, the Transaction must be signed by the account/s that are going to be affected. The Transaction code can contain arguments, but can't return a value. This is because there is a delay for the Transaction to execute, because it has to go through the collection/consensus/execution/verification cycle.

For more information about Transactions, see [cadence/language/transactions](https://cadence-lang.org/docs/language/transactions).

For more information about Transaction signing, see [concepts/transaction-signing](../../../../build/basics/transactions.md#signing-a-transaction).

For more information about Cadence programming, see [cadence](../../../../build/guides/smart-contracts/cadence.md).

**Signing In**

To sign transactions, you must sign-in to a wallet provider. This sample uses DevWallet, an example wallet provider specifically made for development. For more information see [DevWallet](../guides/dev-wallet.md).

Click the Sign In button. This will open a dialog asking to select an account to sign in with. The list of accounts is populated from the Accounts tab of the Flow Control Window. Select an account and click Ok. The address of the account you select will show underneath "Signed in as". You can now run the three transaction tests. 

**Submit Transaction**

*MainUIController.SubmitTxSinglePayerProposerAuthorizer()*

This is a very simple Transaction that logs out a message on the blockchain. Simply click the first Submit Transaction button on the left. Successfully submitting a Transaction will return a Transaction Id.

Now go to the Flow Emulator Output and scroll to the bottom. You should see several things - the transaction was submitted, executed, the log message in the cadence code was printed, and a new block was committed.

![](../media/db2741c083bc677b767e5f2973f63e1b.png)

**Submit Transaction With Args**

*MainUIController.SubmitTxWithArgs()*

This is a very simple Transaction like the previous one which doesn't actually mutate anything, but simply demonstrates passing arguments to the Transaction. Enter a string argument and a number argument, then click the next Submit Transaction button. Like the previous test, the arguments are logged out on the blockchain.

![](../media/f0dfb75d21cf7462d7f0aaf199d97b27.png)

**Submit Transaction List NFT**

*MainUIController.SubmitTxListNft()*

This Transaction demonstrates an actual use case of listing an account's NFT for sale. Enter the NFT Id and price, then click the last Submit Transaction button. To get a list of NFT Ids for a given account, go back to the Scripts tab and run the "Execute Print NFTs At Latest Block" script.

Note: The NFT Price must be a decimal number, eg 23.5 or 12.0

If you'd like to see the cadence code for this Transaction, it's located here:

![](../media/5ba73beddcefba8eade5c9ce4322a86d.png)

**Get Transaction By Id**

*MainUIController.GetTransactionById()*

This API call will return all of the information that was submitted with the Transaction. For ease of use, the input field for this is automatically populated with the Transaction Id of the previous Transaction that was submitted. You can of course enter a different valid Transaction Id. Clicking the button will populate all the fields under the Transaction heading.

**Get Transaction Result**

*MainUIController.GetTransactionResult()*

This demonstrates how to retrieve the result of a Transaction. You must supply the Transaction Id using the same input as the previous test. As previously mentioned, the input is automatically populated with the Transaction Id of the last submitted Transaction.

The fields under the Result heading are populated when running this API call. The following information is returned.

Status: Current status of the Transaction. Can be Unknown, Pending, Finalized, Executed, Sealed or Expired.   
Error Message: If there was an error executing the Transaction (eg a cadence runtime error), this will be populated with the error message from the blockchain. When running against an emulator, you will also see the error in the Flow Emulator Output.   
Events: A list of events that were emitted during execution of the Transaction.

### Accounts

**Signing In**

Like the Transactions tab, you must be signed in to a wallet provider to run most of these tests. That's because they are actually transactions, and therefore require signing. If you already signed in on the Transactions tab, you will still be signed in as the same user here. Otherwise, Click Sign In and select an account, then click Ok. 

**Get Account**

*MainUIController.GetAccount()*

Retrieves details about the given account address, including Flow token balance, public keys and any deployed Smart Contracts. This is not a transaction, therefore you do not need to be signed in to run this test. 

**Create Account**

*MainUIController.CreateAccount()*

To create an account on Flow, it needs to be sponsored by another account. Every account on Flow must have a minimum of 0.001 Flow tokens in their balance, so the sponsor must pay this to the new account. To test this, enter a name for the new account, then click Create Account. The account you are signed in as will sign the transaction and pay the 0.001 Flow tokens to the new account. If it fails, ensure the account has enough Flow tokens to execute this transaction and still retain the minimum 0.001 Flow tokens. 

A new public\\private keypair will be generated and assigned to the new account.

Note: the Account Name is not actually stored on the blockchain. It is only used by the SDK.

**Deploy Contract**

*MainUIController.DeployContract()*

This demonstrates deploying a Smart Contract to an account. Enter the name of the contract and the path of its source file, then click Deploy Contract.

Note that the Contract Name must match the name of the contract in the source file.

The Contract Source File location is relative to the project's Assets directory.

**Remove Contract**

*MainUIController.RemoveContract()*

Removes a Smart Contract from an account. Enter the name of the contract then click Remove Contract.

**Update Contract**

*MainUIController.UpdateContract()*

Updates a Smart Contract which is already deployed to the signed-in account. Unlike Deploy Contract, the `init()` function of the contract is not executed. Enter the Contract Name and the path of the updated source file, then click Update Contract.

Note that the Contract Name must match the name of the contract in the source file, and must also match the name of the existing contract deployed to the account.

The Contract Source File location is relative to the project's Assets directory.

Only certain things in a Smart Contract can be modified. See this link about [Contract Updatability](https://cadence-lang.org/docs/language/contract-updatability).
---
title: Flow Emulator
description: A development tool that looks, acts and talks like Flow
sidebar_position: 3
---

The Flow Emulator is a lightweight tool that emulates the behaviour of the real Flow network.

The emulator exposes a gRPC server that implements the Flow Access API,
which is designed to have near feature parity with the real network API.

## Running the emulator with the Flow CLI

The emulator is bundled with the [Flow CLI](../../tools/flow-cli/index.md), a command-line interface for working with Flow.

### Installation

Follow [these steps](../../tools/flow-cli/install.md) to install the Flow CLI on macOS, Linux, and Windows.

## Usage

To learn more about using the Emulator,
have a look at [the README of the repository](https://github.com/onflow/flow-emulator/#starting-the-server).
---
title: -title-
sidebar_label:
description: -description-
---

\{short description\}

```shell
{command}
```

\{optional warning\}

## Example Usage

```shell
{usage example with response}
```

## Arguments

### \{Argument 1\}

- Name: `\{argument\}`
- Valid Input: `\{input\}`

\{argument general description\}

## Arguments

### Address

- Name: `address`
- Valid Input: Flow account address

Flow [account address](../../../build/basics/accounts.md) (prefixed with `0x` or not).

## Flags

### \{Option 1\}

- Flag: `\{flag value\}`
- Valid inputs: \{input description\}

\{flag general description\}

### Signer

- Flag: `--signer`
- Valid inputs: the name of an account defined in the configuration (`flow.json`)

Specify the name of the account that will be used to sign the transaction.

### Host

- Flag: `--host`
- Valid inputs: an IP address or hostname.
- Default: `127.0.0.1:3569` (Flow Emulator)

Specify the hostname of the Access API that will be
used to execute the commands.

### Network Key

- Flag: `--network-key`
- Valid inputs: A valid network public key of the host in hex string format

Specify the network public key of the Access API that will be
used to create a secure GRPC client when executing the command.

### Network

- Flag: `--network`
- Short Flag: `-n`
- Valid inputs: the name of a network defined in the configuration (`flow.json`)
- Default: `emulator`

Specify which network you want the command to use for execution.

### Filter

- Flag: `--filter`
- Short Flag: `-x`
- Valid inputs: case-sensitive name of the result property.

Specify any property name from the result you want to return as the only value.

### Output

- Flag: `--output`
- Short Flag: `-o`
- Valid inputs: `json`, `inline`

Specify in which format you want to display the result.

### Save

- Flag: `--save`
- Short Flag: `-s`
- Valid inputs: valid filename

Specify the filename where you want the result to be saved.

### Log

- Flag: `--log`
- Short Flag: `-l`
- Valid inputs: `none`, `error`, `debug`
- Default: `info`

Specify the log level. Control how much output you want to see while command execution.

### Configuration

- Flag: `--config-path`
- Short Flag: `-f`
- Valid inputs: valid filename

Specify a filename for the configuration files, you can provide multiple configuration
files by using `-f` flag multiple times.

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.
{
  "label": "Accounts",
  "position": 4
}---
title: Deploy a Contract
sidebar_position: 3
---

Deploy a new contract to a Flow account using the Flow CLI.   

```shell
flow accounts add-contract <filename> [<argument> <argument>...] [flags]
```

⚠️  Deprecation notice: using name argument in adding contract command will be deprecated soon.
```shell
flow accounts add-contract <name> <filename> [<argument> <argument>...] [flags]
```

## Example Usage

```shell
> flow accounts add-contract ./FungibleToken.cdc

Contract 'FungibleToken' deployed to the account 0xf8d6e0586b0a20c7

Address	 0xf8d6e0586b0a20c7
Balance	 99999999999.70000000
Keys	 1

Key 0	Public Key		 640a5a359bf3536d15192f18d872d57c98a96cb871b92b70cecb0739c2d5c37b4be12548d3526933c2cda9b0b9c69412f45ffb6b85b6840d8569d969fe84e5b7
	Weight			 1000
	Signature Algorithm	 ECDSA_P256
	Hash Algorithm		 SHA3_256
	Revoked 		 false
	Sequence Number 	 6
	Index 			 0

Contracts Deployed: 1
Contract: 'FungibleToken'
```
**Testnet Example**
```
> flow accounts add-contract ./FungibleToken.cdc --signer alice --network testnet

Contract 'FungibleToken' deployed to the account 0xf8d6e0586b0a20c7

Address	 0xf8d6e0586b0a20c7
Balance	 99999999999.70000000
Keys	 1

Key 0	Public Key		 640a5a359bf3536d15192f18d872d57c98a96cb871b92b70cecb0739c2d5c37b4be12548d3526933c2cda9b0b9c69412f45ffb6b85b6840d8569d969fe84e5b7
	Weight			 1000
	Signature Algorithm	 ECDSA_P256
	Hash Algorithm		 SHA3_256
	Revoked 		 false
	Sequence Number 	 6
	Index 			 0

Contracts Deployed: 1
Contract: 'FungibleToken'
```
*Make sure alice account is defined in flow.json*

## Arguments

### Name

- Name: `name`
- Valid inputs: any string value.

Name of the contract as it is defined in the contract source code.

⚠️  Deprecation notice: use filename argument only, no need to use name argument.

### Filename

- Name: `filename`
- Valid inputs: a path in the current filesystem.

Path to the file containing the contract source code.

### Arguments
- Name: `argument`
- Valid inputs: valid [cadence values](https://cadence-lang.org/docs/json-cadence-spec)
  matching argument type in transaction code.

Input arguments values matching corresponding types in the source code and passed in the same order.

Example:
```shell
> flow accounts add-contract ./contract.cdc Hello 2
```
Transaction code:
```
pub contract HelloWorld {
    init(a:String, b:Int) {
    }
}
```

## Flags

### Signer

- Flag: `--signer`
- Valid inputs: the name of an account defined in the configuration (`flow.json`)

Specify the name of the account that will be used to sign the transaction.

### Arguments JSON

- Flag: `--args-json`
- Valid inputs: arguments in JSON-Cadence form.
- Example: `flow accounts add-contract ./tx.cdc '[{"type": "String", "value": "Hello"}]'`

Arguments passed to the Cadence transaction in Cadence JSON format.
Cadence JSON format contains `type` and `value` keys and is
[documented here](https://cadence-lang.org/docs/json-cadence-spec).

### Include Fields

- Flag: `--include`
- Valid inputs: `contracts`

Specify fields to include in the result output. Applies only to the text output.


### Host

- Flag: `--host`
- Valid inputs: an IP address or hostname.
- Default: `127.0.0.1:3569` (Flow Emulator)

Specify the hostname of the Access API that will be
used to execute the command. This flag overrides
any host defined by the `--network` flag.

### Network Key

- Flag: `--network-key`
- Valid inputs: A valid network public key of the host in hex string format

Specify the network public key of the Access API that will be
used to create a secure GRPC client when executing the command.

### Network

- Flag: `--network`
- Short Flag: `-n`
- Valid inputs: the name of a network defined in the configuration (`flow.json`).
- Default: `emulator`

Specify which network you want the command to use for execution.

### Filter

- Flag: `--filter`
- Short Flag: `-x`
- Valid inputs: a case-sensitive name of the result property.

Specify any property name from the result you want to return as the only value.

### Output

- Flag: `--output`
- Short Flag: `-o`
- Valid inputs: `json`, `inline`

Specify the format of the command results.

### Save

- Flag: `--save`
- Short Flag: `-s`
- Valid inputs: a path in the current filesystem.

Specify the filename where you want the result to be saved

### Log

- Flag: `--log`
- Short Flag: `-l`
- Valid inputs: `none`, `error`, `debug`
- Default: `info`

Specify the log level. Control how much output you want to see during command execution.

### Configuration

- Flag: `--config-path`
- Short Flag: `-f`
- Valid inputs: a path in the current filesystem.
- Default: `flow.json`

Specify the path to the `flow.json` configuration file.
You can use the `-f` flag multiple times to merge
several configuration files.

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.
---
title: Remove a Contract
sidebar_position: 5
---
_This feature is only found in the Emulator. You **cannot** remove a contract on Testnet or Mainnet._

Remove an existing contract deployed to a Flow account using the Flow CLI.

```shell
flow accounts remove-contract <name>
```

## Example Usage

```shell
> flow accounts remove-contract FungibleToken

Contract 'FungibleToken' removed from account '0xf8d6e0586b0a20c7'

Address	 0xf8d6e0586b0a20c7
Balance	 99999999999.70000000
Keys	 1

Key 0	Public Key		 640a5a359bf3536d15192f18d872d57c98a96cb871b92b70cecb0739c2d5c37b4be12548d3526933c2cda9b0b9c69412f45ffb6b85b6840d8569d969fe84e5b7
	Weight			 1000
	Signature Algorithm	 ECDSA_P256
	Hash Algorithm		 SHA3_256
	Revoked 		 false
	Sequence Number 	 6
	Index 			 0

Contracts Deployed: 0
```
**Testnet Example**
```
> flow accounts remove-contract FungibleToken --signer alice --network testnet

Contract 'FungibleToken' removed from account '0xf8d6e0586b0a20c7'

Address	 0xf8d6e0586b0a20c7
Balance	 99999999999.70000000
Keys	 1

Key 0	Public Key		 640a5a359bf3536d15192f18d872d57c98a96cb871b92b70cecb0739c2d5c37b4be12548d3526933c2cda9b0b9c69412f45ffb6b85b6840d8569d969fe84e5b7
	Weight			 1000
	Signature Algorithm	 ECDSA_P256
	Hash Algorithm		 SHA3_256
	Revoked 		 false
	Sequence Number 	 6
	Index 			 0

Contracts Deployed: 0

```
*Make sure alice account is defined in flow.json*

## Arguments

### Name

- Name: `name`
- Valid inputs: any string value.

Name of the contract as it is defined in the contract source code.

## Flags

### Signer

- Flag: `--signer`
- Valid inputs: the name of an account defined in the configuration (`flow.json`).

Specify the name of the account that will be used to sign the transaction.

### Include Fields

- Flag: `--include`
- Valid inputs: `contracts`

Specify fields to include in the result output. Applies only to the text output.


### Host

- Flag: `--host`
- Valid inputs: an IP address or hostname.
- Default: `127.0.0.1:3569` (Flow Emulator)

Specify the hostname of the Access API that will be
used to execute the command. This flag overrides
any host defined by the `--network` flag.

### Network Key

- Flag: `--network-key`
- Valid inputs: A valid network public key of the host in hex string format

Specify the network public key of the Access API that will be
used to create a secure GRPC client when executing the command.

### Network

- Flag: `--network`
- Short Flag: `-n`
- Valid inputs: the name of a network defined in the configuration (`flow.json`)
- Default: `emulator`

Specify which network you want the command to use for execution.

### Filter

- Flag: `--filter`
- Short Flag: `-x`
- Valid inputs: a case-sensitive name of the result property

Specify any property name from the result you want to return as the only value.

### Output

- Flag: `--output`
- Short Flag: `-o`
- Valid inputs: `json`, `inline`

Specify the format of the command results.

### Save

- Flag: `--save`
- Short Flag: `-s`
- Valid inputs: a path in the current filesystem

Specify the filename where you want the result to be saved

### Log

- Flag: `--log`
- Short Flag: `-l`
- Valid inputs: `none`, `error`, `debug`
- Default: `info`

Specify the log level. Control how much output you want to see during command execution.

### Configuration

- Flag: `--config-path`
- Short Flag: `-f`
- Valid inputs: a path in the current filesystem
- Default: `flow.json`

Specify the path to the `flow.json` configuration file. 
You can use the `-f` flag multiple times to merge
several configuration files.

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.
---
title: Account Staking Info
description: How to get staking info
sidebar_position: 6
---

Retrieve staking information for the account on the Flow network using Flow CLI.

```shell
flow accounts staking-info <address>
```

## Example Usage

```shell
> accounts staking-info 535b975637fb6bee --host access.testnet.nodes.onflow.org:9000

Account Staking Info:
    ID: 			 "ca00101101010100001011010101010101010101010101011010101010101010"
    Initial Weight: 	 100
    Networking Address: 	 "ca00101101010100001011010101010101010101010101011010101010101010"
    Networking Key: 	 "ca00101101010100001011010101010101010101010101011010101010101010ca00101101010100001011010101010101010101010101011010101010101010"
    Role: 			 1
    Staking Key: 		 "ca00101101010100001011010101010101010101010101011010101010101010ca00101101010100001011010101010101010101010101011010101010101010ca00101101010100001011010101010101010101010101011010101010101010"
    Tokens Committed: 	 0.00000000
    Tokens To Unstake: 	 0.00000000
    Tokens Rewarded: 	 82627.77000000
    Tokens Staked: 		 250000.00000000
    Tokens Unstaked: 	 0.00000000
    Tokens Unstaking: 	 0.00000000
    Node Total Stake (including delegators):    250000.00000000


Account Delegation Info:
    ID: 			 7
    Tokens Committed: 	 0.00000000
    Tokens To Unstake: 	 0.00000000
    Tokens Rewarded: 	 30397.81936000
    Tokens Staked: 		 100000.00000000
    Tokens Unstaked: 	 0.00000000
    Tokens Unstaking: 	 0.00000000

```

## Arguments

### Address

- Name: `address`
- Valid Input: Flow account address.

Flow [account address](../../../build/basics/accounts.md) (prefixed with `0x` or not).

## Flags

### Include Fields

- Flag: `--include`
- Valid inputs: `contracts`

Specify fields to include in the result output. Applies only to the text output.


### Host

- Flag: `--host`
- Valid inputs: an IP address or hostname.
- Default: `127.0.0.1:3569` (Flow Emulator)

Specify the hostname of the Access API that will be
used to execute the command. This flag overrides
any host defined by the `--network` flag.

### Network Key

- Flag: `--network-key`
- Valid inputs: A valid network public key of the host in hex string format

Specify the network public key of the Access API that will be
used to create a secure GRPC client when executing the command.

### Network

- Flag: `--network`
- Short Flag: `-n`
- Valid inputs: the name of a network defined in the configuration (`flow.json`)
- Default: `emulator`

Specify which network you want the command to use for execution.

### Filter

- Flag: `--filter`
- Short Flag: `-x`
- Valid inputs: a case-sensitive name of the result property

Specify any property name from the result you want to return as the only value.

### Output

- Flag: `--output`
- Short Flag: `-o`
- Valid inputs: `json`, `inline`

Specify the format of the command results.

### Save

- Flag: `--save`
- Short Flag: `-s`
- Valid inputs: a path in the current filesystem

Specify the filename where you want the result to be saved

### Log

- Flag: `--log`
- Short Flag: `-l`
- Valid inputs: `none`, `error`, `debug`
- Default: `info`

Specify the log level. Control how much output you want to see during command execution.

### Configuration

- Flag: `--config-path`
- Short Flag: `-f`
- Valid inputs: a path in the current filesystem
- Default: `flow.json`

Specify the path to the `flow.json` configuration file.
You can use the `-f` flag multiple times to merge
several configuration files.

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.
---
title: Update a Contract
sidebar_position: 4
---

Update an existing contract deployed to a Flow account using the Flow CLI.

```shell
flow accounts update-contract <filename> [<argument> <argument>...] [flags]
```

⚠️  Deprecation notice: using name argument in update contract command will be deprecated soon.
```shell
flow accounts update-contract <name> <filename> [<argument> <argument>...] [flags]
```

## Example Usage

```shell
> flow accounts update-contract ./FungibleToken.cdc

Contract 'FungibleToken' updated on account '0xf8d6e0586b0a20c7'

Address	 0xf8d6e0586b0a20c7
Balance	 99999999999.70000000
Keys	 1

Key 0	Public Key		 640a5a359bf3536d15192f18d872d57c98a96cb871b92b70cecb0739c2d5c37b4be12548d3526933c2cda9b0b9c69412f45ffb6b85b6840d8569d969fe84e5b7
	Weight			 1000
	Signature Algorithm	 ECDSA_P256
	Hash Algorithm		 SHA3_256
	Revoked 		 false
	Sequence Number 	 6
	Index 			 0

Contracts Deployed: 1
Contract: 'FungibleToken'
```
**Testnet Example**
```
> flow accounts update-contract ./FungibleToken.cdc --signer alice --network testnet

Contract 'FungibleToken' updated on account '0xf8d6e0586b0a20c7'

Address	 0xf8d6e0586b0a20c7
Balance	 99999999999.70000000
Keys	 1

Key 0	Public Key		 640a5a359bf3536d15192f18d872d57c98a96cb871b92b70cecb0739c2d5c37b4be12548d3526933c2cda9b0b9c69412f45ffb6b85b6840d8569d969fe84e5b7
	Weight			 1000
	Signature Algorithm	 ECDSA_P256
	Hash Algorithm		 SHA3_256
	Revoked 		 false
	Sequence Number 	 6
	Index 			 0

Contracts Deployed: 1
Contract: 'FungibleToken'
```
*Make sure alice account is defined in flow.json*

## Arguments

### Name
- Name: `name`
- Valid inputs: Any string value

Name of the contract as it is defined in the contract source code.

⚠️  Deprecation notice: use filename argument only, no need to use name argument.

### Filename
- Name: `filename`
- Valid inputs: Any filename and path valid on the system.

Filename of the file containing contract source code.

### Arguments
- Name: `argument`
- Valid inputs: valid [cadence values](https://cadence-lang.org/docs/json-cadence-spec)
  matching argument type in transaction code.

Input arguments values matching corresponding types in the source code and passed in the same order.

Example:
```shell
> flow accounts update-contract ./contract.cdc Hello 2
```
Transaction code:
```
pub contract HelloWorld {
    init(a:String, b:Int) {
    }
}
```

## Flags

### Signer

- Flag: `--signer`
- Valid inputs: the name of an account defined in the configuration (`flow.json`)

Specify the name of the account that will be used to sign the transaction.

### Show Diff

- Flag: `--show-diff`
- Valid inputs: `true`, `false`

Shows a diff to approve before updating between deployed contract and new contract updates.

### Arguments JSON

- Flag: `--args-json`
- Valid inputs: arguments in JSON-Cadence form.
- Example: `flow accounts update-contract ./tx.cdc '[{"type": "String", "value": "Hello"}]'`

Arguments passed to the Cadence transaction in Cadence JSON format.
Cadence JSON format contains `type` and `value` keys and is
[documented here](https://cadence-lang.org/docs/json-cadence-spec).

### Include Fields

- Flag: `--include`
- Valid inputs: `contracts`

Specify fields to include in the result output. Applies only to the text output.

### Host

- Flag: `--host`
- Valid inputs: an IP address or hostname.
- Default: `127.0.0.1:3569` (Flow Emulator)

Specify the hostname of the Access API that will be
used to execute the command. This flag overrides
any host defined by the `--network` flag.

### Network Key

- Flag: `--network-key`
- Valid inputs: A valid network public key of the host in hex string format

Specify the network public key of the Access API that will be
used to create a secure GRPC client when executing the command.

### Network

- Flag: `--network`
- Short Flag: `-n`
- Valid inputs: the name of a network defined in the configuration (`flow.json`)
- Default: `emulator`

Specify which network you want the command to use for execution.

### Filter

- Flag: `--filter`
- Short Flag: `-x`
- Valid inputs: a case-sensitive name of the result property

Specify any property name from the result you want to return as the only value.

### Output

- Flag: `--output`
- Short Flag: `-o`
- Valid inputs: `json`, `inline`

Specify the format of the command results.

### Save

- Flag: `--save`
- Short Flag: `-s`
- Valid inputs: a path in the current filesystem

Specify the filename where you want the result to be saved

### Log

- Flag: `--log`
- Short Flag: `-l`
- Valid inputs: `none`, `error`, `debug`
- Default: `info`

Specify the log level. Control how much output you want to see during command execution.

### Configuration

- Flag: `--config-path`
- Short Flag: `-f`
- Valid inputs: a path in the current filesystem
- Default: `flow.json`

Specify the path to the `flow.json` configuration file.
You can use the `-f` flag multiple times to merge
several configuration files.

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.---
title: Create an Account
description: How to create a Flow account from the command line
sidebar_position: 2
---

The Flow CLI provides a command to submit an account creation 
transaction to any Flow Access API. There are two options how to create an account, you can use the 
interactive mode which guides you through the process and creates the account for you or by using 
the manual process which requires a pre-existing account on the network you chose.

## Interactive Mode
Creating the account in interactive mode prompts you for an account name and network selection. 
After you enter the required information the account will be created for you and saved to `flow.json`. 
If account creation is done on testnet or mainnet the account key will be saved to a separate key file, 
which will also be put in `.gitignore`. You can [read more about key security here](../flow.json/security.md).

💡 _Please note that the account creation process can take up to a minute so please be patient._

```shell
flow accounts create

Enter an account name: mike
✔ Testnet

🎉 New account created with address 0x77e6ae4c8c2f1dd6 and name mike on Testnet network.

Here’s a summary of all the actions that were taken:
 - Added the new account to flow.json.
 - Saved the private key to mike.pkey.
 - Added mike.pkey to .gitignore.
```

## Manual Mode
Manual mode requires you to have a pre-existing account on the network which you will have to provide as a signer. 
That account must be added to `flow.json` for the command to work. You also have to generate a key pair, we 
suggest using the `flow keys generate` command, [which you can read more about here](../keys/generate-keys.md).

```shell
# Create an account on Flow Testnet
> flow accounts create \
    --key a69c6986e846ba6d0....1397f5904cd319c3e01e96375d5777f1a47010 \
    --signer my-testnet-account 

Address	 0x01cf0e2f2f715450
Balance	 10000000
Keys	 1

Key 0	Public Key		 a69c6986e846ba6d0....1397f5904cd319c3e01e96375d5777f1a47010
	Weight			 1000
	Signature Algorithm	 ECDSA_P256
	Hash Algorithm		 SHA3_256

Contracts Deployed: 0
```

In the above example, the `flow.json` file would look something like this:

```json
{
  "accounts": {
    "my-testnet-account": {
      "address": "a2c4941b5f3c7151",
      "key": "12c5dfde...bb2e542f1af710bd1d40b2"
    }
  }
}
```

## Flags
    
### Public Key

- Flag: `--key`
- Valid inputs: a hex-encoded public key in raw form.

Specify the public key that will be added to the new account
upon creation.

### Key Weight

- Flag: `--key-weight`
- Valid inputs: number between 0 and 1000
- Default: 1000

Specify the weight of the public key being added to the new account. 

When opting to use this flag, you must specify a `--key-weight` flag for each public `--key` flag provided.

### Public Key Signature Algorithm
    
- Flag: `--sig-algo`
- Valid inputs: `"ECDSA_P256", "ECDSA_secp256k1"`
- Default: `"ECDSA_P256"`

Specify the ECDSA signature algorithm for the provided public key.
This option can only be used together with the `--key` flag.

Flow supports the secp256k1 and P-256 curves.

### Public Key Hash Algorithm

- Flag: `--hash-algo`
- Valid inputs: `"SHA2_256", "SHA3_256"`
- Default: `"SHA3_256"`

Specify the hash algorithm that will be paired with the public key
upon account creation.

### Signer

- Flag: `--signer`
- Valid inputs: the name of an account defined in `flow.json`.

Specify the name of the account that will be used to sign the transaction
and pay the account creation fee.

### Contract

- Flag: `--contract`
- Valid inputs: String with format `name:filename`, where `name` is 
  name of the contract as it is defined in the contract source code
  and `filename` is the filename of the contract source code.

Specify one or more contracts to be deployed during account creation.

### Include Fields

- Flag: `--include`
- Valid inputs: `contracts`

Specify fields to include in the result output. Applies only to the text output.

### Host

- Flag: `--host`
- Valid inputs: an IP address or hostname.
- Default: `127.0.0.1:3569` (Flow Emulator)

Specify the hostname of the Access API that will be
used to execute the command. This flag overrides
any host defined by the `--network` flag.

### Network Key

- Flag: `--network-key`
- Valid inputs: A valid network public key of the host in hex string format

Specify the network public key of the Access API that will be
used to create a secure GRPC client when executing the command.

### Network

- Flag: `--network`
- Short Flag: `-n`
- Valid inputs: the name of a network defined in the configuration (`flow.json`)
- Default: `emulator`

Specify which network you want the command to use for execution.

### Filter

- Flag: `--filter`
- Short Flag: `-x`
- Valid inputs: a case-sensitive name of the result property.

Specify any property name from the result you want to return as the only value.

### Output

- Flag: `--output`
- Short Flag: `-o`
- Valid inputs: `json`, `inline`

Specify the format of the command results.

### Save

- Flag: `--save`
- Short Flag: `-s`
- Valid inputs: a path in the current filesystem.

Specify the filename where you want the result to be saved

### Log

- Flag: `--log`
- Short Flag: `-l`
- Valid inputs: `none`, `error`, `debug`
- Default: `info`

Specify the log level. Control how much output you want to see during command execution.

### Configuration

- Flag: `--config-path`
- Short Flag: `-f`
- Valid inputs: a path in the current filesystem.
- Default: `flow.json`

Specify the path to the `flow.json` configuration file.
You can use the `-f` flag multiple times to merge
several configuration files.

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.---
title: Get an Account
description: How to get a Flow account from the command line
sidebar_position: 1
---

The Flow CLI provides a command to fetch any account by its address from the Flow network.

```shell
flow accounts get <address>
```

## Example Usage

```shell
flow accounts get 0xf8d6e0586b0a20c7
```

### Example response
```shell
Address	 0xf8d6e0586b0a20c7
Balance	 99999999999.70000000
Keys	 1

Key 0	Public Key		 640a5a359bf3536d15192f18d872d57c98a96cb871b92b70cecb0739c2d5c37b4be12548d3526933c2cda9b0b9c69412f45ffb6b85b6840d8569d969fe84e5b7
	Weight			 1000
	Signature Algorithm	 ECDSA_P256
	Hash Algorithm		 SHA3_256
	Revoked 		 false
	Sequence Number 	 6
	Index 			 0

Contracts Deployed: 2
Contract: 'FlowServiceAccount'
Contract: 'FlowStorageFees'


```

## Arguments

### Address

- Name: `address`
- Valid Input: Flow account address

Flow [account address](../../../build/basics/accounts.md) (prefixed with `0x` or not).


## Flags

### Include Fields

- Flag: `--include`
- Valid inputs: `contracts`

Specify fields to include in the result output. Applies only to the text output.

### Host

- Flag: `--host`
- Valid inputs: an IP address or hostname.
- Default: `127.0.0.1:3569` (Flow Emulator)

Specify the hostname of the Access API that will be
used to execute the command. This flag overrides
any host defined by the `--network` flag.

### Network Key

- Flag: `--network-key`
- Valid inputs: A valid network public key of the host in hex string format

Specify the network public key of the Access API that will be
used to create a secure GRPC client when executing the command.

### Network

- Flag: `--network`
- Short Flag: `-n`
- Valid inputs: the name of a network defined in the configuration (`flow.json`)
- Default: `emulator`

Specify which network you want the command to use for execution.

### Filter

- Flag: `--filter`
- Short Flag: `-x`
- Valid inputs: a case-sensitive name of the result property.

Specify any property name from the result you want to return as the only value.

### Output

- Flag: `--output`
- Short Flag: `-o`
- Valid inputs: `json`, `inline`

Specify the format of the command results.

### Save

- Flag: `--save`
- Short Flag: `-s`
- Valid inputs: a path in the current filesystem.

Specify the filename where you want the result to be saved

### Log

- Flag: `--log`
- Short Flag: `-l`
- Valid inputs: `none`, `error`, `debug`
- Default: `info`

Specify the log level. Control how much output you want to see during command execution.

### Configuration

- Flag: `--config-path`
- Short Flag: `-f`
- Valid inputs: a path in the current filesystem.
- Default: `flow.json`

Specify the path to the `flow.json` configuration file.
You can use the `-f` flag multiple times to merge
several configuration files.

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.---
title: Data Collection
description: Data collected from Flow CLI usage
sidebar_position: 14
---

Flow CLI tracks flow command usage count using Mixpanel.

Data collection is enabled by default. Users can opt out of our data collection through running `flow settings metrics disable`. 
To opt back in, users can run `flow settings metrics enable`.

## Why do we collect data about flow cli usage?

Collecting aggregate command count allow us to prioritise features and fixes based on how users use flow cli.

## What data do we collect?

We only collect the number of times a command is executed. 

We don't keep track of the values of arguments, flags used
and the values of the flags used. We also don't associate any commands to any particular user.

The only property that we collect from our users are their preferences for opting in / out of data collection. 
The analytics user ID is specific to Mixpanel and does not permit Flow CLI maintainers to e.g. track you across websites you visit.

Further details regarding the data collected can be found under Mixpanel's data collection page in `Ingestion API` 
section of https://help.mixpanel.com/hc/en-us/articles/115004613766-Default-Properties-Collected-by-Mixpanel.

Please note that although Mixpanel's page above mentions that geolocation properties are recorded by default, 
we have turned off geolocation data reporting to Mixpanel.
{
  "label": "Deploy Project",
  "position": 5
}---
title: Deploy a Project
description: How to deploy Flow project contracts with the CLI
sidebar_position: 3
---

```shell
flow project deploy
```

This command automatically deploys your project's contracts based on the 
configuration defined in your `flow.json` file.

Before using this command, read about how to 
[configure project contracts and deployment targets](./project-contracts.md).

## Example Usage

```shell
> flow project deploy --network=testnet

Deploying 2 contracts for accounts: my-testnet-account

NonFungibleToken -> 0x8910590293346ec4
KittyItems -> 0x8910590293346ec4

✨  All contracts deployed successfully
```

In the example above, your `flow.json` file might look something like this:

```json
{
  ...
  "contracts": {
    "NonFungibleToken": "./cadence/contracts/NonFungibleToken.cdc",
    "KittyItems": "./cadence/contracts/KittyItems.cdc"
  },
  "deployments": {
    "testnet": {
      "my-testnet-account": ["KittyItems", "NonFungibleToken"]
    }
  },
  ...
}
```

Here's a sketch of the contract source files:

```cadence NonFungibleToken.cdc
pub contract NonFungibleToken { 
  // ...
}
```

```cadence KittyItems.cdc
import NonFungibleToken from "./NonFungibleToken.cdc"

pub contract KittyItems { 
  // ...
}
```

## Initialization Arguments
Deploying contracts that take initialization arguments 
can be achieved with adding those arguments to the configuration. 

Each deployment can be specified as an object containing 
`name` and `args` key specifying arguments to be 
used during the deployment. Example:

```
...
  "deployments": {
    "testnet": {
      "my-testnet-account": [
        "NonFungibleToken", {
            "name": "Foo", 
            "args": [
                { "type": "String", "value": "Hello World" },
                { "type": "UInt32", "value": "10" }
            ]
        }]
    }
  }
...
```


⚠️ Warning: before proceeding, 
we recommend reading the [Flow CLI security guidelines](../flow.json/security.md) 
to learn about the best practices for private key storage.

## Dependency Resolution

The `deploy` command attempts to resolve the import statements in all contracts being deployed.

After the dependencies are found, the CLI will deploy the contracts in a deterministic order
such that no contract is deployed until all of its dependencies are deployed.
The command will return an error if no such ordering exists due to one or more cyclic dependencies.

In the example above, `Foo` will always be deployed before `Bar`.

## Address Replacement

After resolving all dependencies, the `deploy` command rewrites each contract so 
that its dependencies are imported from their _target addresses_ rather than their 
source file location.

The rewritten versions are then deployed to their respective targets,
leaving the original contract files unchanged.

In the example above, the `KittyItems` contract would be rewritten like this:

```cadence KittyItems.cdc
import NonFungibleToken from 0xf8d6e0586b0a20c7

pub contract KittyItems { 
  // ...
}
```
## Merging Multiple Configuration Files

You can use the `-f` flag multiple times to merge several configuration files. 

If there is an overlap in any of the fields in the configuration between two or more configuration files, the value of 
the overlapped field in the resulting configuration will come from the configuration file that is on the further right 
order in the list of configuration files specified in the -f flag 

Let's look at an example of `deploy` commands with multiple configuration files below

```cadence flow.json
{
    "accounts": {
        "admin-account": {
            "address": "f8d6e0586b0a20c7",
            "key": "21c5dfdeb0ff03a7a73ef39788563b62c89adea67bbb21ab95e5f710bd1d40b7"
        }, 
        "test-account": {
            "address": "f8d6e0586b0a20c8",
            "key": "52d5dfdeb0ff03a7a73ef39788563b62c89adea67bbb21ab95e5f710bd1d51c9"
        }
    }
}
```
```cadence private.json
{
    "accounts":{
		"admin-account":{
			"address":"f1d6e0586b0a20c7",
			"key":"3335dfdeb0ff03a7a73ef39788563b62c89adea67bbb21ab95e5f710bd1d40b7"
	    }
	}
}
```
In the example above, when we try to use the `deploy` command with multiple configuration files and there is an overlap 
in the `admin-account` account in `accounts` field of the configuration, the resulting configuration will be like this

> flow project deploy -f flow.json -f private.json
```
{
    "accounts":{
	    "admin-account":{
			"address":"f1d6e0586b0a20c7",
			"key":"3335dfdeb0ff03a7a73ef39788563b62c89adea67bbb21ab95e5f710bd1d40b7"
	    }, 
	    "test-account":{
			"address":"f8d6e0586b0a20c8",
			"key":"52d5dfdeb0ff03a7a73ef39788563b62c89adea67bbb21ab95e5f710bd1d51c9"
	    }
	}
}
```

## Flags

### Allow Updates

- Flag: `--update`
- Valid inputs: `true`, `false`
- Default: `false`

Indicate whether to overwrite and upgrade existing contracts. Only contracts with difference with existing contracts
will be overwritten.

### Show Update Diff

- Flag: `--show-diff`
- Valid inputs: `true`, `false`
- Default: `false`

Shows a diff to approve before updating between deployed contract and new contract updates.

### Host

- Flag: `--host`
- Valid inputs: an IP address or hostname.
- Default: `127.0.0.1:3569` (Flow Emulator)

Specify the hostname of the Access API that will be
used to execute the command. This flag overrides
any host defined by the `--network` flag.

### Network Key

- Flag: `--network-key`
- Valid inputs: A valid network public key of the host in hex string format

Specify the network public key of the Access API that will be
used to create a secure GRPC client when executing the command.

### Network

- Flag: `--network`
- Short Flag: `-n`
- Valid inputs: the name of a network defined in the configuration (`flow.json`)
- Default: `emulator`

Specify which network you want the command to use for execution.

### Filter

- Flag: `--filter`
- Short Flag: `-x`
- Valid inputs: a case-sensitive name of the result property.

Specify any property name from the result you want to return as the only value.

### Output

- Flag: `--output`
- Short Flag: `-o`
- Valid inputs: `json`, `inline`

Specify the format of the command results.

### Save

- Flag: `--save`
- Short Flag: `-s`
- Valid inputs: a path in the current filesystem.

Specify the filename where you want the result to be saved

### Log

- Flag: `--log`
- Short Flag: `-l`
- Valid inputs: `none`, `error`, `debug`
- Default: `info`

Specify the log level. Control how much output you want to see during command execution.

### Configuration

- Flag: `--config-path`
- Short Flag: `-f`
- Valid inputs: a path in the current filesystem.
- Default: `flow.json`

Specify the path to the `flow.json` configuration file.
You can use the `-f` flag multiple times to merge
several configuration files.

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.---
title: Create Emulator Snapshot
description: How to start create emulator snapshot from the command line
sidebar_position: 4
---

The Flow CLI provides a command to create emulator snapshots, which are points in blockchain 
history you can later jump to and reset the state to that moment. This can be useful for testing where you 
establish a begining state, run tests and after revert back to the initial state.

The command syntax is:
```shell
flow emulator snapshot create|load|list {name}
```

## Example Usage

### Create a new snapshot
Create a new emulator snapshot at the current block with a name of `myInitialState`. 
```shell
> flow emulator snapshot create myInitialState
```

### Load an existing snapshot
To jump to a previously created snapshot we use the load command in combination with the name.
```shell
> flow emulator snapshot load myInitialState
```

### List all existing snapshots
To list all the existing snapshots we previously created and can load to we run the following command:
```shell
> flow emulator list
```


To learn more about using the Emulator, have a look at the [README of the repository](https://github.com/onflow/flow-emulator).

## Flags

### Emulator Flags
You can specify any [emulator flags found here](https://github.com/onflow/flow-emulator#configuration) and they will be applied to the emulator service.

### Configuration

- Flag: `--config-path`
- Short Flag: `-f`
- Valid inputs: valid filename

Specify a filename for the configuration files, you can provide multiple configuration
files by using `-f` flag multiple times.

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.
---
title: Add Project Contracts
description: How to define the Cadence contracts for Flow project
sidebar_position: 2
---

## Add a Contract

To add a contract to your project, update the `"contracts"` section of your `flow.json` file.

Contracts are specified as key-value pairs, where the key is the contract name,
and the value is the location of the Cadence source code.

For example, the configuration below will register the 
contract `Foo` from the `FooContract.cdc` file.

```json
{
  "contracts": {
    "Foo": "./cadence/contracts/FooContract.cdc"
  }
}
```

## Define Contract Deployment Targets

Once a contract is added, it can then be assigned to one or more deployment targets.

A deployment target is an account to which the contract will be deployed.
In a typical project, a contract has one deployment target per network (e.g. Emulator, Testnet, Mainnet).

Deployment targets are defined in the `"deployments"` section of your `flow.json` file.

Targets are grouped by their network, where each network is a mapping from target account to contract list. 
Multiple contracts can be deployed to the same target account.

For example, here's how we'd deploy contracts `Foo` and `Bar` to the account `my-testnet-account`:

```json
{
  "contracts": {
    "Foo": "./cadence/contracts/FooContract.cdc",
    "Bar": "./cadence/contracts/BarContract.cdc"
  },
  "deployments": {
    "testnet": {
      "my-testnet-account": ["Foo", "Bar"]
    }
  }
}
```
---
title: Start Emulator
description: How to start Flow emulator from the command line
sidebar_position: 1
---

The Flow CLI provides a command to start an emulator. 
The Flow Emulator is a lightweight tool that emulates the behaviour of the real Flow network.

```shell
flow emulator
```

⚠️ The emulator command expects configuration to be initialized. See [flow init](../flow.json/initialize-configuration.md) command.


## Example Usage

```shell
> flow emulator

INFO[0000] ⚙️   Using service account 0xf8d6e0586b0a20c7  serviceAddress=f8d6e0586b0a20c7 ...
...
```

To learn more about using the Emulator, have a look at the [README of the repository](https://github.com/onflow/flow-emulator).

## Flags

### Emulator Flags
You can specify any [emulator flags found here](https://github.com/onflow/flow-emulator#configuration) and they will be applied to the emulator service.

### Configuration

- Flag: `--config-path`
- Short Flag: `-f`
- Valid inputs: valid filename

Specify a filename for the configuration files, you can provide multiple configuration
files by using `-f` flag multiple times.

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.---
title: Flow Interaction Templates (FLIX)
sidebar_label: Flow Interaction Templates (FLIX)
description: Flow Interaction Templates (FLIX) via the CLI
sidebar_position: 12
---
## Introduction

The Flow CLI provides a `flix` command with a few sub commands `execute` and `package`. Get familiar with Flow Interaction Templates [(FLIX)](https://github.com/onflow/flips/blob/main/application/20220503-interaction-templates.md). FLIX are a standard for distributing Cadence scripts and transactions, and metadata in a way that is consumable by tooling and wallets. FLIX can be audited for correctness and safety by auditors in the ecosystem.

```shell
>flow flix
execute, package

Usage:
  flow flix [command]

Available Commands:
  execute     execute FLIX template with a given id, name, or local filename
  package     package file for FLIX template fcl-js is default


```

### Execute

The Flow CLI provides a `flix` command to `execute` FLIX. The Cadence being execute in the FLIX can be a transaciton or script.

```shell
flow flix execute <query> [<argument> <argument>...] [flags]
```

Queries can be a FLIX `id`, `name`, or `path` to a local FLIX file.

### Execute Usage

```shell
# Execute a FLIX transaction by name on Testnet
flow flix execute transfer-flow 5.0 "0x123" --network testnet --signer "testnet-account"
```

```shell
# Execute a FLIX script by id on Testnet
flow flix execute bd10ab0bf472e6b58ecc0398e9b3d1bd58a4205f14a7099c52c0640d9589295f --network testnet
```

```shell
# Execute a local FLIX script by path on Testnet
flow flix execute ./multiply.template.json 2 3 --network testnet
```

The Flow CLI provides a `flix` command to `package` up generated plain and simple JavaScript. This JavaScript uses FCL (Flow Client Library) to call the cadence the Flow Interaction Templates (FLIX) is based on. 

<Callout type="info">
Currently, `flix package` command only supports generating FCL (Flow Client Library) specific JavaScript, there are plans to support other languages like golang.
</Callout>


```shell
flow flix package <query> [flags]
```

## Package

Queries can be a FLIX `id`, `name`, or `path` to a local FLIX file. This command leverages [FCL](../clients/fcl-js/) which will execute FLIX cadence code. 

### Package Usage

```shell
# Generate packaged code that leverages FCL to call the Cadence transaction code, `--save` flag will save the output to a specific file
flow flix package transfer-flow --save ./package/transfer-flow.js
```

```shell
# Geneate package code for a FLIX script using id, since there is no saving file, the result will display in terminal
flow flix package bd10ab0bf472e6b58ecc0398e9b3d1bd58a4205f14a7099c52c0640d9589295f 
```

```shell
# Generate package code using local template file to save in a local file 
flow flix package ./multiply.template.json --save ./multiply.js
```

### Example Package Output
```shell
flow flix package transfer-flow
```

```javascript

/**
    This binding file was auto generated based on FLIX template v1.0.0. 
    Changes to this file might get overwritten.
    Note fcl version 1.3.0 or higher is required to use templates. 
**/

import * as fcl from "@onflow/fcl"
const flixTemplate = "transfer-flow"

/**
* Transfer tokens from one account to another
* @param {Object} Parameters - parameters for the cadence
* @param {string} Parameters.amount - The amount of FLOW tokens to send: UFix64
* @param {string} Parameters.to - The Flow account the tokens will go to: Address
* @returns {Promise<string>} - returns a promise which resolves to the transaction id
*/
export async function transferTokens({amount, to}) {
  const transactionId = await fcl.mutate({
    template: flixTemplate,
    args: (arg, t) => [arg(amount, t.UFix64), arg(to, t.Address)]
  });

  return transactionId
}
```

<Callout type="info">
SOON: `flix generate` will generate FLIX json files using FLIX specific properties in comment blocks directly in Cadence code, [FLIP - Interaction Template Cadence Doc](https://github.com/onflow/flips/pull/80)
</Callout>


## Resources

To find out more about FLIX, see the [read the FLIP](https://github.com/onflow/flips/blob/main/application/20220503-interaction-templates.md).

For a list of all templates, check out the [FLIX template repository](https://github.com/onflow/flow-interaction-template-service/tree/master/templates).

To generate a FLIX, see the [FLIX CLI readme](https://github.com/onflow/flow-interaction-template-tools/tree/master/cli).

## Arguments
- Name: `argument`
- Valid input: valid [FLIX](https://github.com/onflow/flips/blob/main/application/20220503-interaction-templates.md)  

Input argument value matching corresponding types in the source code and passed in the same order.
You can pass a `nil` value to optional arguments by executing the flow FLIX execute script like this: `flow flix execute template.json nil`.

## Flags

### Arguments JSON

- Flag: `--args-json`
- Valid inputs: arguments in JSON-Cadence form.
- Example: `flow flix execute template.script.json '[{"type": "String", "value": "Hello World"}]'`

Arguments passed to the Cadence script in the Cadence JSON format.
Cadence JSON format contains `type` and `value` keys and is 
[documented here](https://cadence-lang.org/docs/json-cadence-spec).

## Block Height

- Flag: `--block-height`
- Valid inputs: a block height number

## Block ID

- Flag: `--block-id`
- Valid inputs: a block ID

### Signer

- Flag: `--signer`
- Valid inputs: the name of an account defined in the configuration (`flow.json`)

Specify the name of the account that will be used to sign the transaction.

### Proposer

- Flag: `--proposer`
- Valid inputs: the name of an account defined in the configuration (`flow.json`)

Specify the name of the account that will be used as proposer in the transaction.

### Payer

- Flag: `--payer`
- Valid inputs: the name of an account defined in the configuration (`flow.json`)

Specify the name of the account that will be used as payer in the transaction.

### Authorizer

- Flag: `--authorizer`
- Valid inputs: the name of a single or multiple comma-separated accounts defined in the configuration (`flow.json`)

Specify the name of the account(s) that will be used as authorizer(s) in the transaction. If you want to provide multiple authorizers separate them using commas (e.g. `alice,bob`)

### Gas Limit

- Flag: `--gas-limit`
- Valid inputs: an integer greater than zero.
- Default: `1000`

Specify the gas limit for this transaction.

### Host

- Flag: `--host`
- Valid inputs: an IP address or hostname.
- Default: `127.0.0.1:3569` (Flow Emulator)

Specify the hostname of the Access API that will be
used to execute the command. This flag overrides
any host defined by the `--network` flag.

### Network Key

- Flag: `--network-key`
- Valid inputs: A valid network public key of the host in hex string format

Specify the network public key of the Access API that will be
used to create a secure GRPC client when executing the command.

### Network

- Flag: `--network`
- Short Flag: `-n`
- Valid inputs: the name of a network defined in the configuration (`flow.json`)
- Default: `emulator`

Specify which network you want the command to use for execution.

### Filter

- Flag: `--filter`
- Short Flag: `-x`
- Valid inputs: a case-sensitive name of the result property.

Specify any property name from the result you want to return as the only value.

### Output

- Flag: `--output`
- Short Flag: `-o`
- Valid inputs: `json`, `inline`

Specify the format of the command results.

### Save

- Flag: `--save`
- Short Flag: `-s`
- Valid inputs: a path in the current filesystem.

Specify the filename where you want the result to be saved

### Log

- Flag: `--log`
- Short Flag: `-l`
- Valid inputs: `none`, `error`, `debug`
- Default: `info`

Specify the log level. Control how much output you want to see during command execution.

### Configuration

- Flag: `--config-path`
- Short Flag: `-f`
- Valid inputs: a path in the current filesystem.
- Default: `flow.json`

Specify the path to the `flow.json` configuration file.
You can use the `-f` flag multiple times to merge
several configuration files.

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.

{
  "label": "Flow.json",
  "position": 9
}---
title: Configuration
description: What is Flow CLI Configuration
sidebar_position: 2
---

Flow CLI uses a state called configuration which is stored in a file (usually `flow.json`). 

Flow configuration (`flow.json`) file will contain the following properties:

- A `networks` list pre-populated with the Flow emulator, testnet and mainnet connection configuration.
- An `accounts` list pre-populated with the Flow Emulator service account.
- A `deployments` empty object where all [deployment targets](../deployment/project-contracts.md#define-contract-deployment-targets) can be defined. 
- A `contracts` empty object where you [define contracts](../deployment/project-contracts.md#add-a-contract) you wish to deploy.

## Example Project Configuration

```json
{
  "networks": {
    "emulator": "127.0.0.1:3569",
    "mainnet": "access.mainnet.nodes.onflow.org:9000",
    "testnet": "access.devnet.nodes.onflow.org:9000"
  },
  "accounts": {
    "emulator-account": {
      "address": "f8d6e0586b0a20c7",
      "key": "ae1b44c0f5e8f6992ef2348898a35e50a8b0b9684000da8b1dade1b3bcd6ebee",
    }
  },
  "deployments": {},
  "contracts": {}
}
```

## Configuration

Below is an example of a configuration file for a complete Flow project.
We'll walk through each property one by one.

```json
{
  "contracts": {
    "NonFungibleToken": "./cadence/contracts/NonFungibleToken.cdc",
    "Kibble": "./cadence/contracts/Kibble.cdc",
    "KittyItems": "./cadence/contracts/KittyItems.cdc",
    "KittyItemsMarket": "./cadence/contracts/KittyItemsMarket.cdc",
    "FungibleToken": {
      "source": "./cadence/contracts/FungibleToken.cdc",
      "aliases": {
        "testnet": "9a0766d93b6608b7",
        "emulator": "ee82856bf20e2aa6"
      }
    }
  },

  "deployments": {
    "testnet": {
      "admin-account": ["NonFungibleToken"],
      "user-account": ["Kibble", "KittyItems", "KittyItemsMarket"]
    }, 
    "emulator": {
      "emulator-account": [
        "NonFungibleToken",
        "Kibble",
        "KittyItems",
        "KittyItemsMarket"
      ]
    }
  },

  "accounts": {
    "admin-account": {
      "address": "3ae53cb6e3f42a79",
      "key": "12332967fd2bd75234ae9037dd4694c1f00baad63a10c35172bf65fbb8ad1111"
    },
    "user-account": {
      "address": "e2a8b7f23e8b548f",
      "key": "22232967fd2bd75234ae9037dd4694c1f00baad63a10c35172bf65fbb8ad1111"
    },
    "emulator-account": {
      "address": "f8d6e0586b0a20c7",
      "key": "2eae2f31cb5b756151fa11d82949c634b8f28796a711d7eb1e52cc301ed11111",
    }
  },

  "networks": {
    "emulator": "127.0.0.1:3569",
    "mainnet": "access.mainnet.nodes.onflow.org:9000",
    "testnet": "access.devnet.nodes.onflow.org:9000",
    "testnetSecure": {
      "Host": "access-001.devnet30.nodes.onflow.org:9001",
      "NetworkKey": "ba69f7d2e82b9edf25b103c195cd371cf0cc047ef8884a9bbe331e62982d46daeebf836f7445a2ac16741013b192959d8ad26998aff12f2adc67a99e1eb2988d"
    }
  }
}
```

### Contracts

Contracts are specified as key-value pairs, where the key is the contract name, 
and the value is the location of the Cadence source code.

The advanced format allows us to specify aliases for each network.

#### Simple Format 

```json
...

"contracts": {
  "NonFungibleToken": "./cadence/contracts/NonFungibleToken.cdc"
}

...
```

#### Advanced Format 

Using advanced format we can define `aliases`. Aliases define an address where the contract is already deployed for that specific network. 
In the example scenario below the contract `FungibleToken` would be imported from the address `9a0766d93b6608b7` when deploying to testnet network 
and address `ee82856bf20e2aa6` when deploying to the Flow emulator. 
We can specify aliases for each network we have defined. When deploying to testnet it is always a good idea to specify aliases for all the [common contracts](../../../references/core-contracts/index.md) that have already been deployed to the testnet. 

⚠️ If we use an alias for the contract we should not specify it in the `deployment` section for that network. 

Our example below should not include `FungibleToken` in  `deployment` section for testnet and emulator network.

```json
...
"FungibleToken": {
  "source": "./cadence/contracts/FungibleToken.cdc",
  "aliases": {
    "testnet": "9a0766d93b6608b7",
    "emulator": "ee82856bf20e2aa6"
  }
}
...
```

Format used to specify advanced contracts is:
```json
"CONTRACT NAME": {
    "source": "CONTRACT SOURCE FILE LOCATION",
    "aliases": {
        "NETWORK NAME": "ADDRESS ON SPECIFIED NETWORK WITH DEPLOYED CONTRACT"
        ...
    }
}
```

### Accounts

The accounts section is used to define account properties such as keys and addresses. 
Each account must include a name, which is then referenced throughout the configuration file.

#### Simple Format

When using the simple format, simply specify the address for the account, and a single hex-encoded
private key.

```json
...

"accounts": {
  "admin-account": {
    "address": "3ae53cb6e3f42a79",
    "key": "12332967fd2bd75234ae9037dd4694c1f00baad63a10c35172bf65fbb8ad1111"
  }
}

...
```

#### Advanced format

The advanced format allows us to define more properties for the account. 
We can define the signature algorithm and hashing algorithm, as well as custom key formats.

Please note that we can use `service` for address in case the account is used on `emulator` network as this is a special 
value that is defined on the run time to the default service address on the emulator network.

**Example for advanced hex format:**
```json
...

"accounts": {
  "admin-account": {
    "address": "service",
    "key":{
        "type": "hex",
        "index": 0,
        "signatureAlgorithm": "ECDSA_P256",
        "hashAlgorithm": "SHA3_256",
        "privateKey": "12332967fd2bd75234ae9037dd4694c1f00baad63a10c35172bf65fbb8ad1111"
      }
  }
}

...
```

You can also use BIP44 to derive keys from a mnemonic. For more details please see the [FLIP](https://github.com/onflow/flips/blob/main/application/20201125-bip-44-multi-account.md)

**Example for BIP44 format:**
```json
...

"accounts": {
  "admin-account": {
    "address": "service",
    "key":{
        "type": "bip44",
        "index": 0,
        "signatureAlgorithm": "ECDSA_P256",
        "hashAlgorithm": "SHA3_256",
        "mnemonic": "skull design wagon top faith actor valley crystal subject volcano access join",
        "derivationPath": "m/44'/539'/0'/0/0"
      }
  }
}

...
```

Note: Default value for `derivationPath` is `m/44'/539'/0'/0/0` if omitted. 



You can also use a key management system (KMS) to sign the transactions. Currently, we only support Google KMS.

**Example for Google KMS format:**
```json
...
"accounts": {
  "admin-account": {
    "address": "service",
    "key": {
        "type": "google-kms",
        "index": 0,
        "signatureAlgorithm": "ECDSA_P256",
        "hashAlgorithm": "SHA3_256",
        "resourceID": "projects/flow/locations/us/keyRings/foo/bar/cryptoKeyVersions/1"
    }
  }
}
...
```

You can store the account key to a separate file and provide the file location as part of the key configuration.

**Example for separate key file:**
```json
...
"accounts": {
  "admin-account": {
    "address": "service",
    "key": {
        "type": "file",
        "location": "./test.key"
    }
  }
}
...
```
Inside the `test.key` file you should only put the hex key content (e.g. `12332967fd2bd75234ae9037dd4694c1f00baad63a10c35172bf65fbb8ad1111`)

### Deployments

The deployments section defines where the `project deploy` command will deploy specified contracts. 
This configuration property acts as the glue that ties together accounts, 
contracts and networks, all of which are referenced by name.

In the deployments section we specify the network, account name and list of contracts to be deployed to that account.

Format specifying the deployment is:
```json
...
"deployments": {
  "NETWORK": {
    "ACCOUNT NAME": ["CONTRACT NAME"]
  }
}

...
```


```json
...

"deployments": {
  "emulator": {
    "emulator-account": [
      "NonFungibleToken",
      "Kibble",
      "KittyItems",
      "KittyItemsMarket"
    ]
  },
  "testnet": {
    "admin-account": ["NonFungibleToken"],
    "user-account": [
      "Kibble",
      "KittyItems",
      "KittyItemsMarket"
    ]
  }
}

...
```

### Networks

Use this section to define networks and connection parameters for that specific network.

Format for networks is:

```json
...
"networks": {
  "NETWORK NAME": "ADDRESS"
}
...
```

```json
...
"networks": {
  "NETWORK NAME": {
    "host": "ADDRESS",
    "key": "ACCESS NODE NETWORK KEY"    
  }
}
...
```

```json
...

"networks": {
    "emulator": "127.0.0.1:3569",
    "mainnet": "access.mainnet.nodes.onflow.org:9000",
    "testnet": "access.devnet.nodes.onflow.org:9000",
    "testnetSecure": {
        "host": "access-001.devnet30.nodes.onflow.org:9001",
        "key": "ba69f7d2e82b9edf25b103c195cd371cf0cc047ef8884a9bbe331e62982d46daeebf836f7445a2ac16741013b192959d8ad26998aff12f2adc67a99e1eb2988d"
    },
}

...
```
### Emulators

The default emulator CLI is automatically configured with name being `"default"` and values of 
`serviceAccount`: `"emulator-account"` and `port`: `"3569"`. The default emulator configuration will not show up on 
flow.json.

To customize emulator values, add emulator section like the example below: 

```json
...

"emulators": {
    "custom-emulator": {
        "port": 3600,
        "serviceAccount": "emulator-account"
    }
}

...
```
---
title: Initialize Configuration
description: How to initialize Flow configuration using CLI
sidebar_position: 1
---

Flow CLI uses a state to operate which is called configuration (usually `flow.json` file). 
Before using commands that require this configuration we must initialize the project by 
using the init command. Read more about [state configuration here](./configuration.md).

```shell
flow init
```

## Example Usage

```shell
> flow init

Configuration initialized
Service account: 0xf8d6e0586b0a20c7

Start emulator by running: 'flow emulator' 
Reset configuration using: 'flow init --reset'

```

### Error Handling

Existing configuration will cause the error below.
You should initialize in an empty folder or reset configuration using `--reset` flag
or by removing the configuration file first.
```shell
❌ Command Error: configuration already exists at: flow.json, if you want to reset configuration use the reset flag
```

## Global Configuration

Flow supports global configuration which is a `flow.json` file saved in your home 
directory and loaded as the first configuration file wherever you execute the CLI command. 

Please be aware that global configuration has the lowest priority and is overwritten 
by any other configuration file if they exist (if `flow.json` exist in your current 
directory it will overwrite properties in global configuration, but only those which overlap).

You can generate a global configuration using `--global` flag. 

Command example: `flow init --global`.

Global flow configuration is saved as:
- MacOs: `~/flow.json`
- Linux: `~/flow.json`
- Windows: `C:\Users\$USER\flow.json`


## Flags

### Reset

- Flag: `--reset`

Using this flag will reset the existing configuration and create a new one.

### Global

- Flag: `--global`

Using this flag will create a global Flow configuration.

### Service Private Key

- Flag: `--service-private-key`
- Valid inputs: a hex-encoded private key in raw form.

Private key used on the default service account.


### Service Key Signature Algorithm

- Flag: `--service-sig-algo`
- Valid inputs: `"ECDSA_P256", "ECDSA_secp256k1"`
- Default: `"ECDSA_P256"`

Specify the ECDSA signature algorithm for the provided public key.

Flow supports the secp256k1 and P-256 curves.

### Service Key Hash Algorithm

- Flag: `--service-hash-algo`
- Valid inputs: `"SHA2_256", "SHA3_256"`
- Default: `"SHA3_256"`

Specify the hashing algorithm that will be paired with the public key
upon account creation.

### Log

- Flag: `--log`
- Short Flag: `-l`
- Valid inputs: `none`, `error`, `debug`
- Default: `info`

Specify the log level. Control how much output you want to see while command execution.






---
title: Manage Configuration
description: How to configure the Flow CLI
sidebar_position: 3
---

Configuration should be managed by using `config add` 
and `config remove` commands. Using add command will also 
validate values that will be added to the configuration.

```shell
flow config add <account|contract|network|deployment>
flow config remove <account|contract|network|deployment>
```

## Example Usage

```shell
flow config add account

Name: Admin
Address: f8d6e0586b0a20c7
✔ ECDSA_P256
✔ SHA3_256
Private key: e382a0e494...9285809356
Key index (Default: 0): 0
```

### Configuration

- Flag: `--config-path`
- Short Flag: `-f`
- Valid inputs: valid filename

Specify a filename for the configuration files, you can provide multiple configuration
files by using `-f` flag multiple times.






---
title: Security
description: How to securely use CLI
sidebar_position: 4
---

The managing of accounts and private keys is intrinsically dangerous. 
We must take extra precautions to not expose private key data when using
the CLI.

The Flow CLI provides several options to secure private account data.

⚠️ Warning: please be careful when using private keys in configuration files. 
Never commit private key data to source control.
If private key data must be kept in text, we suggest using a separate file
that is not checked into source control (e.g. excluded with `.gitignore`).

### Private Account Configuration File
Storing an account key to a separate file which is not checked into source control (e.g. excluded with `.gitignore`) 
can be the first step towards better security. 

#### Main configuration file
```json
...
"accounts": {
  "my-testnet-account": { 
    "address": "3ae53cb6e3f42a79",
    "key": {
      "type": "file",
      "location": "./my-testnet-account.key"
    } 
  }
}
...
```

#### Separate account key file
⚠️ Put this file in `.gitignore`

The `my-testnet-account.key` file only contains the hex-encoded private key.
```
334232967f52bd75234ae9037dd4694c1f00baad63a10c35172bf65fbb8ad1111
```
---

#### Private configuration file

⚠️ Put this file in `.gitignore`:

```json
// flow.testnet.json
{
  "accounts": {
    "my-testnet-account": {
      "address": "3ae53cb6e3f42a79",
      "key": "334232967f52bd75234ae9037dd4694c1f00baad63a10c35172bf65fbb8ad1111"
    }
  }
}
```

### Store Configuration in Environment Variables

You can use environment variables for values that should be kept private (e.g. private keys, addresses).

See example below:

```shell
PRIVATE_KEY=key flow project deploy
```

```json
// flow.json
{
  ...
  "accounts": {
    "my-testnet-account": {
      "address": "3ae53cb6e3f42a79",
      "key": "$PRIVATE_KEY"
    }
  }
  ...
}
```

### Private Dotenv File

The CLI will load environment variables defined in the `.env` file in the active directory, if one exists. 
These variables can be substituted inside the `flow.json`, 
just like any other environment variable.

⚠️ You should never commit `.env` to source control, 
especially if it contains sensitive information 
like a private key.

Example `.env` file:
```bash
PRIVATE_KEY=123
```

### Composing Multiple Configuration Files

You can merge multiple configuration files like so:

```shell
flow project deploy -f main.json -f private.json
```
{
  "label": "Flow Entities",
  "position": 9
}---
title: Get Block
description: How to get a block from the command line
sidebar_position: 1
---

The Flow CLI provides a command to fetch any block from the Flow network.

```shell
flow blocks get <block_id|latest|block_height>
```

## Example Usage

```shell
flow blocks get 12884163 --host access.mainnet.nodes.onflow.org:9000 --include transactions
```

### Example response

```shell
Block ID		2fb7571a6ccf02f3ac42f27c14ce0a4cb119060e4fbd7af36fd51894465e7002
Prent ID		1c5a6267ba9512e141e4e90630cb326cecfbf6113818487449efeb37fc98ca18
Timestamp		2021-03-19 17:46:15.973305066 +0000 UTC
Height			12884163
Status		        Sealed
Total Seals		2
Total Collections	8
    Collection 0:	3e694588e789a72489667a36dd73104dea4579bcd400959d47aedccd7f930eeb
         Transaction 0: acc2ae1ff6deb2f4d7663d24af6ab1baf797ec264fd76a745a30792f6882093b
         Transaction 1: ae8bfbc85ce994899a3f942072bfd3455823b1f7652106ac102d161c17fcb55c
         Transaction 2: 70c4d39d34e654173c5c2746e7bb3a6cdf1f5e6963538d62bad2156fc02ea1b2
         Transaction 3: 2466237b5eafb469c01e2e5f929a05866de459df3bd768cde748e068c81c57bf
    Collection 1:	e93f2bd988d66288c7e1ad991dec227c6c74b8039a430e43896ad94cf8feccce
         Transaction 0: 4d790300722b646e7ed3e2c52675430d7ccf2efd1d93f106b53bc348df601af6
    Collection 2:	c7d93b80ae55809b1328c686f6a8332e8e15083ab32f8b3105c4d910646f54bf
         Transaction 0: 95c4efbb30f86029574d6acd7df04afe6108f6fd610d823dfd398c80cfa5e842
    Collection 3:	1a4f563b48aaa38f3a7e867c89422e0bd84887de125e8f48ba147f4ee58ddf0d
         Transaction 0: fbcc99326336d4dbb4cbc01a3b9b85cfcdcdc071b3d0e01ee88ecd144444600b
    Collection 4:	01000c7773cc3c22cba6d8917a2486dc7a1a1842dd7fb7c0e87e63c22bb14abe
         Transaction 0: a75097639b434044de0122d3a28620e093f277fa715001e80a035568e118c59f
    Collection 5:	6f2b08f9673545a2e61e954feb8d55d2a3ef2b3cef7a8d2f8de527bc42d92c28
         Transaction 0: 8ea63d397bd07a25db3f06fb9785dbf09bc652159f68a84c55ea2be606ada1e9
    Collection 6:	13b5c48252930824a8c6e846470763582cacdacb772c1e9c584adefced6724b2
         Transaction 0: 8ba57a92311367189a89a59bcb3c32192387fefca9bde493e087bc0d479186a8
         Transaction 1: 8ab1d99702ccf31b6f4b3acd2580dddd440f08bc07acab4884337c0c593a8f69
    Collection 7:	bf90fdd2761b8f37565af60fc38165dd09edf0671fdd35b37f718a7eb45e804f
         Transaction 0: b92a14c0802183719efed00363d31076d7e50f41a6207781cf34d39c822bbacb


```

## Arguments

### Query
- Name: `<block_id|latest|block_height>`
- Valid Input: Block ID, `latest` or block height

Specify the block to retrieve by block ID or block height.

## Arguments

### Address
- Name: `address`
- Valid Input: Flow account address

Flow [account address](../../../build/basics/accounts.md) (prefixed with `0x` or not).


## Flags

### Events

- Flag: `--events`
- Valid inputs: Valid event name

List events of this type for the block.

### Include

- Flag: `--include`
- Valid inputs: `transactions`

Include additional values in the response.

### Signer

- Flag: `--signer`
- Valid inputs: the name of an account defined in the configuration (`flow.json`)

Specify the name of the account that will be used to sign the transaction.

### Host

- Flag: `--host`
- Valid inputs: an IP address or hostname.
- Default: `127.0.0.1:3569` (Flow Emulator)

Specify the hostname of the Access API that will be
used to execute the command. This flag overrides
any host defined by the `--network` flag.

### Network Key

- Flag: `--network-key`
- Valid inputs: A valid network public key of the host in hex string format

Specify the network public key of the Access API that will be
used to create a secure GRPC client when executing the command.

### Network

- Flag: `--network`
- Short Flag: `-n`
- Valid inputs: the name of a network defined in the configuration (`flow.json`)
- Default: `emulator`

Specify which network you want the command to use for execution.

### Filter

- Flag: `--filter`
- Short Flag: `-x`
- Valid inputs: a case-sensitive name of the result property.

Specify any property name from the result you want to return as the only value.

### Output

- Flag: `--output`
- Short Flag: `-o`
- Valid inputs: `json`, `inline`

Specify the format of the command results.

### Save

- Flag: `--save`
- Short Flag: `-s`
- Valid inputs: a path in the current filesystem.

Specify the filename where you want the result to be saved

### Log

- Flag: `--log`
- Short Flag: `-l`
- Valid inputs: `none`, `error`, `debug`
- Default: `info`

Specify the log level. Control how much output you want to see during command execution.

### Configuration

- Flag: `--config-path`
- Short Flag: `-f`
- Valid inputs: a path in the current filesystem.
- Default: `flow.json`

Specify the path to the `flow.json` configuration file.
You can use the `-f` flag multiple times to merge
several configuration files.

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.---
title: Get Collection
description: How to get a collection from the command line
sidebar_position: 3
---

The Flow CLI provides a command to fetch any collection from the Flow network.

```shell
flow collections get <collection_id>
```

## Example Usage

```shell
flow collections get 3e694588e789a72489667a36dd73104dea4579bcd400959d47aedccd7f930eeb \
--host access.mainnet.nodes.onflow.org:9000
```

### Example response

```shell
Collection ID 3e694588e789a72489667a36dd73104dea4579bcd400959d47aedccd7f930eeb:
acc2ae1ff6deb2f4d7663d24af6ab1baf797ec264fd76a745a30792f6882093b
ae8bfbc85ce994899a3f942072bfd3455823b1f7652106ac102d161c17fcb55c
70c4d39d34e654173c5c2746e7bb3a6cdf1f5e6963538d62bad2156fc02ea1b2
2466237b5eafb469c01e2e5f929a05866de459df3bd768cde748e068c81c57bf

```

## Arguments

### Collection ID
- Name: `collection_id`
- Valid Input: SHA3-256 hash of the collection contents

## Arguments

## Flags

### Host

- Flag: `--host`
- Valid inputs: an IP address or hostname.
- Default: `127.0.0.1:3569` (Flow Emulator)

Specify the hostname of the Access API that will be
used to execute the command. This flag overrides
any host defined by the `--network` flag.

### Network Key

- Flag: `--network-key`
- Valid inputs: A valid network public key of the host in hex string format

Specify the network public key of the Access API that will be
used to create a secure GRPC client when executing the command.

### Network

- Flag: `--network`
- Short Flag: `-n`
- Valid inputs: the name of a network defined in the configuration (`flow.json`)
- Default: `emulator`

Specify which network you want the command to use for execution.

### Filter

- Flag: `--filter`
- Short Flag: `-x`
- Valid inputs: a case-sensitive name of the result property.

Specify any property name from the result you want to return as the only value.

### Output

- Flag: `--output`
- Short Flag: `-o`
- Valid inputs: `json`, `inline`

Specify the format of the command results.

### Save

- Flag: `--save`
- Short Flag: `-s`
- Valid inputs: a path in the current filesystem.

Specify the filename where you want the result to be saved

### Log

- Flag: `--log`
- Short Flag: `-l`
- Valid inputs: `none`, `error`, `debug`
- Default: `info`

Specify the log level. Control how much output you want to see during command execution.

### Configuration

- Flag: `--config-path`
- Short Flag: `-f`
- Valid inputs: a path in the current filesystem.
- Default: `flow.json`

Specify the path to the `flow.json` configuration file.
You can use the `-f` flag multiple times to merge
several configuration files.

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.---
title: Get Events
description: How to get an event from the command line
sidebar_position: 2
---

Use the event command to fetch a single or multiple events in a specific range of blocks. 
You can provide start and end block height range, but also specify number of the latest blocks to 
be used to search for specified event. Events are fetched concurrently by using multiple workers which 
optionally you can also control by specifying the flags.

```shell
flow events get <event_name>
```

## Example Usage

Get the event by name `A.0b2a3299cc857e29.TopShot.Deposit` from the last 20 blocks on mainnet.
```shell
> flow events get A.0b2a3299cc857e29.TopShot.Deposit --last 20 --network mainnet

  Events Block #12913388:
	 Index	 2
	 Type	 A.0b2a3299cc857e29.TopShot.Deposit
	 Tx ID	 0a1e6cdc4eeda0e23402193d7ad5ba01a175df4c08f48fa7ac8d53e811c5357c
	 Values
		 id (UInt64)	3102159
		 to ({}?)	24214cf0faa7844d

	 Index	 2
	 Type	 A.0b2a3299cc857e29.TopShot.Deposit
	 Tx ID	 1fa5e64dcdc8ed5dad87ba58207ee4c058feb38fa271fff659ab992dc2ec2645
	 Values
		 id (UInt64)	5178448
		 to ({}?)	26c96b6c2c31e419

	 Index	 9
	 Type	 A.0b2a3299cc857e29.TopShot.Deposit
	 Tx ID	 262ab3996bdf98f5f15804c12b4e5d4e89c0fa9b71d57be4d7c6e8288c507c4a
	 Values
		 id (UInt64)	1530408
		 to ({}?)	2da5c6d1a541971b

...
```

Get two events `A.1654653399040a61.FlowToken.TokensDeposited` 
and `A.1654653399040a61.FlowToken.TokensWithdrawn` in the block height range on mainnet. 
```shell
> flow events get \
  A.1654653399040a61.FlowToken.TokensDeposited \
  A.1654653399040a61.FlowToken.TokensWithdrawn \ 
  --start 11559500 --end 11559600 --network mainnet
  
  Events Block #17015045:
    Index	0
    Type	A.1654653399040a61.FlowToken.TokensWithdrawn
    Tx ID	6dcf60d54036acb52b2e01e69890ce34c3146849998d64364200e4b21e9ac7f1
    Values
		- amount (UFix64): 0.00100000 
		- from (Address?): 0x9e06eebf494e2d78 

    Index	1
    Type	A.1654653399040a61.FlowToken.TokensWithdrawn
    Tx ID	6dcf60d54036acb52b2e01e69890ce34c3146849998d64364200e4b21e9ac7f1
    Values
		- amount (UFix64): 0.00100000 
		- from (Never?): nil 

  Events Block #17015047:
    Index	0
    Type	A.1654653399040a61.FlowToken.TokensWithdrawn
    Tx ID	24979a3c0203f514f7f5822cc8ae7046e24f25d4a775bef697a654898fb7673e
    Values
		- amount (UFix64): 0.00100000 
		- from (Address?): 0x18eb4ee6b3c026d2 

    Index	1
    Type	A.1654653399040a61.FlowToken.TokensWithdrawn
    Tx ID	24979a3c0203f514f7f5822cc8ae7046e24f25d4a775bef697a654898fb7673e
    Values
		- amount (UFix64): 0.00100000 
		- from (Never?): nil 
```

## Arguments

### Event Name

- Name: `event_name`
- Valid Input: String

Fully-qualified identifier for the events.
You can provide multiple event names separated by a space.

## Flags

### Start

- Flag: `--start`
- Valid inputs: valid block height

Specify the start block height used alongside the end flag. 
This will define the lower boundary of the block range.

### End

- Flag: `--end`
- Valid inputs: valid block height

Specify the end block height used alongside the start flag.
This will define the upper boundary of the block range.

### Last

- Flag: `--last`
- Valid inputs: number
- Default: `10`

Specify the number of blocks relative to the last block. Ignored if the 
start flag is set. Used as a default if no flags are provided.

### Batch

- Flag: `--batch`
- Valid inputs: number
- Default: `25`

Number of blocks each worker will fetch.

### Workers

- Flag: `--workers`
- Valid inputs: number
- Default: `10`

Number of workers to use when fetching events concurrently.


### Host

- Flag: `--host`
- Valid inputs: an IP address or hostname.
- Default: `127.0.0.1:3569` (Flow Emulator)

Specify the hostname of the Access API that will be
used to execute the command. This flag overrides
any host defined by the `--network` flag.

### Network Key

- Flag: `--network-key`
- Valid inputs: A valid network public key of the host in hex string format

Specify the network public key of the Access API that will be
used to create a secure GRPC client when executing the command.

### Network

- Flag: `--network`
- Short Flag: `-n`
- Valid inputs: the name of a network defined in the configuration (`flow.json`)
- Default: `emulator`

Specify which network you want the command to use for execution.

### Filter

- Flag: `--filter`
- Short Flag: `-x`
- Valid inputs: a case-sensitive name of the result property.

Specify any property name from the result you want to return as the only value.

### Output

- Flag: `--output`
- Short Flag: `-o`
- Valid inputs: `json`, `inline`

Specify the format of the command results.

### Save

- Flag: `--save`
- Short Flag: `-s`
- Valid inputs: a path in the current filesystem.

Specify the filename where you want the result to be saved

### Log

- Flag: `--log`
- Short Flag: `-l`
- Valid inputs: `none`, `error`, `debug`
- Default: `info`

Specify the log level. Control how much output you want to see during command execution.

### Configuration

- Flag: `--config-path`
- Short Flag: `-f`
- Valid inputs: a path in the current filesystem.
- Default: `flow.json`

Specify the path to the `flow.json` configuration file.
You can use the `-f` flag multiple times to merge
several configuration files.

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.---
title: Network Status 
description: How to get access node status from the command line
sidebar_position: 4
---

The Flow CLI provides a command to get network status of specified Flow Access Node

`flow status`

## Example Usage

```shell
> flow status --network testnet

Status:		 🟢 ONLINE
Network:	 testnet
Access Node:	 access.devnet.nodes.onflow.org:9000
```

## Flags

### Network

- Flag: `--network`
- Short Flag: `-n`
- Valid inputs: the name of a network defined in the configuration (`flow.json`).

Specify which network you want the command to use for execution.

### Host

- Flag: `--host`
- Valid inputs: an IP address or hostname.
- Default: `127.0.0.1:3569` (Flow Emulator)

Specify the hostname of the Access API that will be
used to execute the command. This flag overrides
any host defined by the `--network` flag.

### Network Key

- Flag: `--network-key`
- Valid inputs: A valid network public key of the host in hex string format

Specify the network public key of the Access API that will be
used to create a secure GRPC client when executing the command.

### Filter

- Flag: `--filter`
- Short Flag: `-x`
- Valid inputs: a case-sensitive name of the result property.

Specify any property name from the result you want to return as the only value.

### Output

- Flag: `--output`
- Short Flag: `-o`
- Valid inputs: `json`, `inline`

Specify the format of the command results.

### Save

- Flag: `--save`
- Short Flag: `-s`
- Valid inputs: a path in the current filesystem.

Specify the filename where you want the result to be saved

### Log

- Flag: `--log`
- Short Flag: `-l`
- Valid inputs: `none`, `error`, `debug`
- Default: `info`

Specify the log level. Control how much output you want to see during command execution.

### Configuration

- Flag: `--conf`
- Short Flag: `-f`
- Valid inputs: a path in the current filesystem.
- Default: `flow.json`

Specify the path to the `flow.json` configuration file.
You can use the `-f` flag multiple times to merge
several configuration files.

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.---
sidebar_position: 2
title: Flow CLI
sidebar_label: Flow CLI
---

## Installation

Follow [these steps](../flow-cli/install.md) to install the Flow CLI on 
macOS, Linux, and Windows.

## Create your first project
The Flow CLI is Flow’s primary development and testing environment, similar to Hardhat and Foundry for developers familiar with writing in Solidity. With the Flow CLI super commands, initiating your new project becomes effortless. Execute the `flow setup` command and make a selection from a variety of accessible scaffolds.

```
> flow setup hello-world --scaffold

🔨 General Scaffolds
   [1] Empty Cadence Project - Empty project containing only basic folder structure and flow.json configuration.
   [2] Simple Cadence Project - Scaffold contains required folder structure as well as some example Cadence code.
   [3] Cadence NFT Project - Scaffold contains the ExampleNFT sample NFT contract.
   [4] Hybrid Custody Project - Starter for exploring & implementing Hybrid Custody.

💻 Web Scaffolds
   [5] FCL Web Dapp - Simple TypeScript web application using next.js, FCL, and Cadence.

📱 Mobile Scaffolds
   [6] Swift iOS simple example - iOS example demonstrating usage of FCL and Flow interactions.
   [7] Android simple example - Android example demonstrating usage of FCL and Flow interactions.
   [8] FCL React Native Mobile Dapp - React Native (Expo) mobile dapp example demonstrating FCL and Flow interactions.

🏀 Unity Scaffolds
   [9] Simple Unity - Simple example demonstrating how to interact with the Flow network using Unity SDK.
   [10] Mobile Unity Game - Example words game built on Flow using the Unity SDK.
```

After you have created your new project you can proceed writing contracts and by running `dev` 
command the CLI will make sure they are deployed to the Flow emulator for you. Flow emulator is 
a simplified version of Flow network you can use locally to develop. 

So proceed by starting the emulator: 

```
> flow emulator
```

After creating your new project you are ready to start writing contracts. The Flow emulator is a simplified local simulation of the Flow network. Running the dev command in the CLI ensures that the contracts are deployed to the Flow emulator for you.

And then the flow dev:
```
> flow dev
```

### Next steps

As part of the next steps you can read more about [flow dev command](super-commands.md).
---
title: Install Instructions
description: How to install the Flow command-line interface (CLI)
sidebar_position: 2
---

The Flow CLI can be installed on macOS, Windows (7 or greater) and most Linux systems.

## macOS

### Homebrew

```sh
brew install flow-cli
```

### From a pre-built binary

_This installation method only works on x86-64._

This script downloads and installs the appropriate binary for your system:

```sh
sh -ci "$(curl -fsSL https://raw.githubusercontent.com/onflow/flow-cli/master/install.sh)"
```

To update, simply re-run the installation command above.

It is currently not possible to install earlier versions of the Flow CLI with Homebrew.
## Linux

### From a pre-built binary

_This installation method only works on x86-64._

This script downloads and installs the appropriate binary for your system:

```sh
sh -ci "$(curl -fsSL https://raw.githubusercontent.com/onflow/flow-cli/master/install.sh)"
```

To update, simply re-run the installation command above.

### Install a specific version

To install a specific version of Flow CLI newer than v0.42.0, append the version tag to the command (e.g. the command below installs CLI version v0.44.0).

```sh
sh -ci "$(curl -fsSL https://raw.githubusercontent.com/onflow/flow-cli/master/install.sh)" -- v0.44.0
```

To install a version older than v0.42.0, refer to [Installing versions before 0.42.0](#installing-versions-before-0420) below.

## Windows

### From a pre-built binary

_This installation method only works on Windows 10, 8.1, or 7 (SP1, with [PowerShell 3.0](https://www.microsoft.com/en-ca/download/details.aspx?id=34595)), on x86-64._

1. Open PowerShell ([Instructions](https://docs.microsoft.com/en-us/powershell/scripting/install/installing-windows-powershell?view=powershell-7#finding-powershell-in-windows-10-81-80-and-7))
2. In PowerShell, run:

    ```powershell
    iex "& { $(irm 'https://raw.githubusercontent.com/onflow/flow-cli/master/install.ps1') }"
    ```

To update, simply re-run the installation command above.

# Upgrade the Flow CLI

## macOS

### Homebrew

```sh
brew upgrade flow-cli
```

### From a pre-built binary

_This update method only works on x86-64._

This script downloads and updates the appropriate binary for your system:

```sh
sh -ci "$(curl -fsSL https://raw.githubusercontent.com/onflow/flow-cli/master/install.sh)"
```

## Linux

### From a pre-built binary

_This update method only works on x86-64._

This script downloads and updates the appropriate binary for your system:

```sh
sh -ci "$(curl -fsSL https://raw.githubusercontent.com/onflow/flow-cli/master/install.sh)"
```

## Windows

### From a pre-built binary

_This update method only works on Windows 10, 8.1, or 7 (SP1, with [PowerShell 3.0](https://www.microsoft.com/en-ca/download/details.aspx?id=34595)), on x86-64._

1. Open PowerShell ([Instructions](https://docs.microsoft.com/en-us/powershell/scripting/install/installing-windows-powershell?view=powershell-7#finding-powershell-in-windows-10-81-80-and-7))
2. In PowerShell, run:

    ```powershell
    iex "& { $(irm 'https://raw.githubusercontent.com/onflow/flow-cli/master/install.ps1') }"
    ```

# Uninstalling Flow CLI
To remove the flow CLI you can run the following command if it was previously installed using a pre-built binary. 

- macOS: `rm /usr/local/bin/flow`
- Linux: `rm ~/.local/bin/flow`
- Windows: `rm ~/Users/{user}/AppData/Flow/flow.exe`

If you installed it using Hombrew you can remove it using: `brew uninstall flow-cli`.

## Installing versions before 0.42.0
If you want to install versions before v0.42.0 you have to use a different install command. 

**Linux/macOS**
```
https://raw.githubusercontent.com/onflow/flow-cli/v0.41.3/install.ps1

sh -ci "$(curl -fsSL https://raw.githubusercontent.com/onflow/flow-cli/v0.41.3/install.sh)" -- v0.41.2
```

**Windows**
```
iex "& { $(irm 'https://raw.githubusercontent.com/onflow/flow-cli/master/install.ps1') }"
```
{
  "label": "Keys",
  "position": 4
}---
title: Decode Public Keys
description: How to decode Flow public keys from the command line
sidebar_position: 2
---

The Flow CLI provides a command to decode encoded public account keys.

```shell
flow keys decode <rlp|pem> <encoded public key>
```

## Example Usage

### Decode RLP Encoded Public Key
```shell
> flow keys decode rlp f847b84084d716c14b051ad6b001624f738f5d302636e6b07cc75e4530af7776a4368a2b586dbefc0564ee28384c2696f178cbed52e62811bcc9ecb59568c996d342db2402038203e8

Public Key 		 84d716c1...bcc9ecb59568c996d342db24 
Signature algorithm 	 ECDSA_P256
Hash algorithm 		 SHA3_256
Weight 			 1000
Revoked 		 false
```

### Decode PEM Encoded Public Key From File
```shell
> flow keys decode pem --from-file key.pem

Public Key 		 d479b3c...c4615360039a6660a366a95f 
Signature algorithm 	 ECDSA_P256
Hash algorithm 		 UNKNOWN
Revoked 		 false

```

## Arguments

### Encoding
- Valid inputs: `rlp`, `pem` 

First argument specifies a valid encoding of the public key provided.

### Optional: Public Key
- Name: `encoded public key`
- Valid inputs: valid encoded key content

Optional second argument provides content of the encoded public key. 
If this argument is omitted the `--from-file` must be used instead.  

## Flags

### From File

- Flag: `--from-file`
- Valid inputs: valid filepath

Provide file with the encoded public key. 

### Filter

- Flag: `--filter`
- Short Flag: `-x`
- Valid inputs: a case-sensitive name of the result property.

Specify any property name from the result you want to return as the only value.

### Output

- Flag: `--output`
- Short Flag: `-o`
- Valid inputs: `json`, `inline`

Specify the format of the command results.

### Save

- Flag: `--save`
- Short Flag: `-s`
- Valid inputs: a path in the current filesystem.

Specify the filename where you want the result to be saved

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.---
title: Derive Public Key
description: How to derive Flow public key from a private key from the command line
sidebar_position: 3
---

The Flow CLI provides a command to derive Public Key from a Private Key.

```shell
flow keys derive <private key>
```

## Example Usage

### Derive Public Key from a Private Key
```shell
> flow keys derive c778170793026a9a7a3815dabed68ded445bde7f40a8c66889908197412be89f 
```

### Example response

```shell
> flow keys generate

🔴️ Store Private Key safely and don't share with anyone! 
Private Key     c778170793026a9a7a3815dabed68ded445bde7f40a8c66889908197412be89f 
Public Key 	    584245c57e5316d6606c53b1ce46dae29f5c9bd26e9e8...aaa5091b2eebcb2ac71c75cf70842878878a2d650f7 
```

## Arguments

### Private Key
- Name: `private key`
- Valid inputs: valid private key content

## Flags

### Signature Algorithm

- Flag: `--sig-algo`
- Valid inputs: `"ECDSA_P256", "ECDSA_secp256k1"`

Specify the ECDSA signature algorithm for the key pair.

Flow supports the secp256k1 and P-256 curves.


### Filter

- Flag: `--filter`
- Short Flag: `-x`
- Valid inputs: a case-sensitive name of the result property.

Specify any property name from the result you want to return as the only value.

### Output

- Flag: `--output`
- Short Flag: `-o`
- Valid inputs: `json`, `inline`

Specify the format of the command results.

### Save

- Flag: `--save`
- Short Flag: `-s`
- Valid inputs: a path in the current filesystem.

Specify the filename where you want the result to be saved
---
title: Generate Keys
description: How to generate key pair from the command line
sidebar_position: 1
---

The Flow CLI provides a command to generate ECDSA key pairs
that can be [attached to new or existing Flow accounts](../../../build/basics/accounts.md).

```shell
flow keys generate
```

⚠️ Store private key safely and don't share with anyone!

## Example Usage

```shell
flow keys generate
```

### Example response

```shell
> flow keys generate

🔴️ Store Private Key safely and don't share with anyone! 
Private Key 	 c778170793026a9a7a3815dabed68ded445bde7f40a8c66889908197412be89f 
Public Key 	 584245c57e5316d6606c53b1ce46dae29f5c9bd26e9e8...aaa5091b2eebcb2ac71c75cf70842878878a2d650f7 
```

## Flags

### Seed

- Flag: `--seed`
- Valid inputs: any string with length >= 32

Specify a UTF-8 seed string that will be used to generate the key pair.
Key generation is deterministic, so the same seed will always
result in the same key.

If no seed is specified, the key pair will be generated using
a random 32 byte seed.

⚠️ Using seed with production keys can be dangerous if seed was not generated 
by using safe random generators.

### Signature Algorithm

- Flag: `--sig-algo`
- Valid inputs: `"ECDSA_P256", "ECDSA_secp256k1"`

Specify the ECDSA signature algorithm for the key pair.

Flow supports the secp256k1 and P-256 curves.

### Filter

- Flag: `--filter`
- Short Flag: `-x`
- Valid inputs: a case-sensitive name of the result property.

Specify any property name from the result you want to return as the only value.

### Output

- Flag: `--output`
- Short Flag: `-o`
- Valid inputs: `json`, `inline`

Specify the format of the command results.

### Save

- Flag: `--save`
- Short Flag: `-s`
- Valid inputs: a path in the current filesystem.

Specify the filename where you want the result to be saved

### Log

- Flag: `--log`
- Short Flag: `-l`
- Valid inputs: `none`, `error`, `debug`
- Default: `info`

Specify the log level. Control how much output you want to see during command execution.

### Configuration

- Flag: `--config-path`
- Short Flag: `-f`
- Valid inputs: a path in the current filesystem.
- Default: `flow.json`

Specify the path to the `flow.json` configuration file.
You can use the `-f` flag multiple times to merge
several configuration files.

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.
{
  "label": "Scripts",
  "position": 7
}---
title: Execute a Script
description: How to execute a Cadence script on Flow from the command line
sidebar_position: 6
---

The Flow CLI provides a command to execute a Cadence script on
the Flow execution state with any Flow Access API.

```shell
flow scripts execute <filename> [<argument> <argument>...] [flags]
```

## Example Usage

```shell
# Execute a script on Flow Testnet
> flow scripts execute script.cdc "Hello" "World"

"Hello World"
```

Script source code:
```
pub fun main(greeting: String, who: String): String {
	return greeting.concat(" ").concat(who)
}
```

## Arguments

### Filename

- Name: `filename`
- Valid inputs: a path in the current filesystem.

The first argument is a path to a Cadence file containing the 
script to be executed.

### Arguments
- Name: `argument`
- Valid inputs: valid [cadence values](https://cadence-lang.org/docs/json-cadence-spec)
  matching argument type in script code.

Input arguments values matching corresponding types in the source code and passed in the same order.
You can pass a `nil` value to optional arguments by executing the flow script like this: `flow scripts execute script.cdc nil`.


## Flags

### Arguments JSON

- Flag: `--args-json`
- Valid inputs: arguments in JSON-Cadence form.
- Example: `flow scripts execute script.cdc '[{"type": "String", "value": "Hello World"}]'`

Arguments passed to the Cadence script in the Cadence JSON format.
Cadence JSON format contains `type` and `value` keys and is 
[documented here](https://cadence-lang.org/docs/json-cadence-spec).

### Host

- Flag: `--host`
- Valid inputs: an IP address or hostname.
- Default: `127.0.0.1:3569` (Flow Emulator)

Specify the hostname of the Access API that will be
used to execute the command. This flag overrides
any host defined by the `--network` flag.

### Network Key

- Flag: `--network-key`
- Valid inputs: A valid network public key of the host in hex string format

Specify the network public key of the Access API that will be
used to create a secure GRPC client when executing the command.

### Network

- Flag: `--network`
- Short Flag: `-n`
- Valid inputs: the name of a network defined in the configuration (`flow.json`)
- Default: `emulator`

Specify which network you want the command to use for execution.

### Filter

- Flag: `--filter`
- Short Flag: `-x`
- Valid inputs: a case-sensitive name of the result property.

Specify any property name from the result you want to return as the only value.

### Output

- Flag: `--output`
- Short Flag: `-o`
- Valid inputs: `json`, `inline`

Specify the format of the command results.

### Save

- Flag: `--save`
- Short Flag: `-s`
- Valid inputs: a path in the current filesystem.

Specify the filename where you want the result to be saved

### Log

- Flag: `--log`
- Short Flag: `-l`
- Valid inputs: `none`, `error`, `debug`
- Default: `info`

Specify the log level. Control how much output you want to see during command execution.

### Configuration

- Flag: `--config-path`
- Short Flag: `-f`
- Valid inputs: a path in the current filesystem.
- Default: `flow.json`

Specify the path to the `flow.json` configuration file.
You can use the `-f` flag multiple times to merge
several configuration files.

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.
---
title: Super Commands
description: How Flow Super Commands Work
sidebar_position: 2
---

Flow CLI Super commands are set of commands that can be used during development 
of your dApp to greatly simplify the workflow. The result is you can focus on writing the contracts 
and the commands will take care of the rest. 


## Setup
The initial command to start your new Flow project is `flow setup` . By default, it will create 
basic folder structure and a flow.json configuration. 

Running the command:
```
> flow setup
```

Will create the following folders and files:
- `/contracts` folder should contain all your Cadence contracts,
- `/scripts` folder should contain all your Cadence scripts,
- `/transactions` folder should contain all your Cadence transactions,
- `/tests` folder should contain all your Cadence tests,
- `flow.json` is a configuration file for your project, which will be automatically maintained.

### Using Scaffolds
Based on the purpose of your project you can select from a list of available scaffolds. 
You can access the scaffolds by simply using the `--scaffold` flag like so:
```
> flow setup --scaffold
```

The list of scaffolds will continuously grow, and you are welcome to contribute to that. 
You can contribute by creating your own scaffold repository which can then be added to the scaffold 
list by [following instructions here](https://github.com/onflow/flow-cli/blob/master/CONTRIBUTING.md#adding-a-scaffold).


## Develop
After creating the project using the flow setup command you can start the emulator in 
the project directory by running `flow emulator`. After emulator is started up you can continue by 
running the flow develop command like so:
```
> flow dev
```
This will continuously watch for your projects Cadence files for changes and keep them in sync with the deployed contracts on the emulator. 

The output will look something like:
```
[15:53:38] Syncing all the contracts...

😜 charlie
  |- MyContract contracts/charlie/MyContract.cdc

😏 emulator-account
  |- HelloWorld contracts/HelloWorld.cdc
```

After the command is started it will automatically watch any changes you make to 
Cadence files and make sure to continuously sync those changes on the emulator network. 
If you make any mistakes it will report the errors as well. 

It is recommended that you use VSCode as the IDE and run the command in the terminal window of the IDE.
The latest VSCode extension also supports resolution of the improved import syntax, more on that later.


⚠️ Please note that this command only works on the emulator network. It's meant for development only and hence 
it doesn't allow interacting with testnet or mainnet network. After your project is completed you will 
be soon able to migrate it using a migration super command. Also, please note the command requires a 
running emulator which you have to start. If you restart the emulator the command needs to be restarted as well. 
This command is meant to be used during development, and it updates the contracts by removing and redeploying 
them, which means that if you manually interacted with those contracts and stored resources in accounts 
storage that stored items might no longer be valid after contract is updated. Our advise is to first focus 
on development and use automated tests to assert correct functionality and interact with contracts manually 
after this cycle is complete. Also note that this is still a very experimental feature, so it might 
undergo a lot of changes and improvements as we learn from the usage. 

**Deploying Contracts**

When adding the contracts to the `/contracts` folder it will automatically deploy them to the `default` 
account, which is also created for you at startup of running `flow dev`. 

If you want to add the contracts to a separate account all you have to do is create a folder inside the 
`/contracts` folder and add the contract there, that will first automatically create the account with 
the same name as the folder name and then deploy all the contracts inside 
that folder to that newly created account.

Example:
If I want to have a contract named `A.cdc` deployed to a default account and a contract named `B.cdc` 
deployed to account called `Bob` my folder structure inside contracts folder will look like:
```
/contracts
    A.cdc
    bob/
        B.cdc
```

## Import Schema
You can simply import your contracts by name. We have introducted a new way to import your contracts. This will simply your workflow. 

The new import schema format looks like:
```
import "{name of the contract}"
```
Example:
```
import "HelloWorld"
```
This will automatically import the contract you have created in your project with the same name and 
save the configuration in flow.json. It doesn't matter if the contract has been deployed on a non-default account.





{
  "label": "Tests",
  "position": 11,
}---
title: Run Cadence tests
description: How to run Cadence tests from the command line
sidebar_position: 11
---

The Flow CLI provides a command to run Cadence tests. 

```shell
flow test /path/to/test_script.cdc
```

⚠️ The `test` command expects configuration to be initialized. See [flow init](../flow.json/initialize-configuration.md) command.

## Example Usage

A simple Cadence script `test_script.cdc`, which has a test case for running a cadence script on-chain:
```cadence
import Test

pub let blockchain = Test.newEmulatorBlockchain()

pub fun testSumOfTwo() {
    let scriptResult = blockchain.executeScript(
        "pub fun main(a: Int, b: Int): Int { return a + b }",
        [2, 3]
    )

    Test.expect(scriptResult, Test.beSucceeded())

    let sum = scriptResult.returnValue! as! Int
    Test.assertEqual(5, sum)
}
```
The above test-script can be run with the CLI as follows, and the test results will be printed on the console.
```shell
$ flow test test_script.cdc

Test results: "test_script.cdc"
- PASS: testSumOfTwo

```

To learn more about writing tests in Cadence, take a look at the [Cadence testing framework](https://cadence-lang.org/docs/testing-framework).

## Flags

### Coverage

- Flag: `--cover`
- Default: `false`

Use the `cover` flag to calculate coverage report for the code being tested.
```shell
$ flow test --cover test_script.cdc

Test results: "test_script.cdc"
- PASS: testSumOfTwo
Coverage: 96.5% of statements

```

### Coverage Report File

- Flag: `--coverprofile`
- Valid inputs: valid filename and extension
- Default: `"coverage.json"`

Use the `coverprofile` to specify the filename where the calculated coverage report is to be written. Supported filename extensions are `.json` and `.lcov`.
```shell
$ flow test --cover test_script.cdc

$ cat coverage.json

$ flow test --cover --coverprofile="coverage.lcov" test_script.cdc

$ cat coverage.lcov
```

### Coverage Code Type

- Flag: `--covercode`
- Valid inputs: `"all"`, `"contracts"`
- Default: `"all"`

Use the `covercode` flag to calculate coverage report only for certain types of code. A value of `"contracts"` will exclude scripts and transactions from the coverage report.
```shell
$ flow test --cover --covercode="contracts" test_script.cdc

Test results: "tests/test_script.cdc"
- PASS: testSumOfTwo
There are no statements to cover
```

Since we did not use any contracts in our sample test script, there is no coverage percentage to be reported.

{
  "label": "Transactions",
  "position": 7
}---
title: Build a Transaction
description: How to build a Flow transaction from the command line
sidebar_position: 3
---

The Flow CLI provides a command to build a transactions with options to specify
authorizer accounts, payer account and proposer account. 

The `build` command doesn't produce any signatures and instead
is designed to be used with the `sign` and `send-signed` commands. 

Use this functionality in the following order:
1. Use this command (`build`) to build the transaction.
2. Use the `sign` command to sign with each account specified in the build process.
3. Use the `send-signed` command to submit the signed transaction to the Flow network.

```shell
flow transactions build <code filename> [<argument> <argument>...] [flags]
```

## Example Usage

```shell
> flow transactions build ./transaction.cdc "Meow" \
  --authorizer alice \
  --proposer bob \
  --payer charlie \
  --filter payload --save built.rlp

ID		e8c0a69952fbe50a66703985e220307c8d44b8fa36c76cbca03f8c43d0167847
Payer		e03daebed8ca0615
Authorizers	[f3fcd2c1a78f5eee]

Proposal Key:	
    Address	179b6b1cb6755e31
    Index	0
    Sequence	1

No Payload Signatures

No Envelope Signatures


Arguments (1):
    - Argument 0: {"type":"String","value":"Meow"}


Code

transaction(greeting: String) {
  let guest: Address

  prepare(authorizer: AuthAccount) {
    self.guest = authorizer.address
  }

  execute {
    log(greeting.concat(",").concat(self.guest.toString()))
  }
}


Payload:
f9013df90138b8d17472616e...73616374696f6e286eeec0c0
```

JSON arguments from a file example:
```shell
> flow transactions build tx1.cdc --args-json "$(cat args.json)"
```

## Arguments

### Code Filename

- Name: `filename`
- Valid inputs: Any filename and path valid on the system.

The first argument is a path to a Cadence file containing the
transaction to be executed.

### Arguments
- Name: `argument`
- Valid inputs: valid [cadence values](https://cadence-lang.org/docs/json-cadence-spec)
  matching argument type in transaction code.

Input arguments values matching corresponding types in the source code and passed in the same order.
For passing complex argument values see [send transaction](./send-transactions.md#example-usage) document. 

## Flags

### Payer

- Flag: `--payer`
- Valid Inputs: Flow address or account name from configuration.
- Default: service account

Specify account address that will be paying for the transaction.
Read more about payers [here](../../../build/basics/transactions.md).

### Proposer

- Flag: `--proposer`
- Valid inputs: Flow address or account name from configuration.
- Default: service account

Specify a name of the account that is proposing the transaction.
Account must be defined in flow configuration.

### Proposer Key Index

- Flag: `--proposer-key-index`
- Valid inputs: number of existing key index
- Default: 0

Specify key index for the proposer account.

### Authorizer

- Flag: `--authorizer`
- Valid Inputs: Flow address or account name from configuration.
- Default: service account

Additional authorizer addresses to add to the transaction.
Read more about authorizers [here](../../../build/basics/transactions.md).

### Arguments JSON

- Flag: `--args-json`
- Valid inputs: arguments in JSON-Cadence form.
- Example: `flow transactions build ./tx.cdc '[{"type": "String", "value": "Hello World"}]'`

Arguments passed to the Cadence transaction in Cadence JSON format.
Cadence JSON format contains `type` and `value` keys and is
[documented here](https://cadence-lang.org/docs/json-cadence-spec).

### Gas Limit

- Flag: `--gas-limit`
- Valid inputs: an integer greater than zero.
- Default: `1000`

Specify the gas limit for this transaction.

### Host

- Flag: `--host`
- Valid inputs: an IP address or hostname.
- Default: `127.0.0.1:3569` (Flow Emulator)

Specify the hostname of the Access API that will be
used to execute the commands.

### Network Key

- Flag: `--network-key`
- Valid inputs: A valid network public key of the host in hex string format

Specify the network public key of the Access API that will be
used to create a secure GRPC client when executing the command.

### Network

- Flag: `--network`
- Short Flag: `-n`
- Valid inputs: the name of a network defined in the configuration (`flow.json`)
- Default: `emulator`

Specify which network you want the command to use for execution.

### Include Fields

- Flag: `--include`
- Valid inputs: `code`, `payload`, `signatures`

Specify fields to include in the result output. Applies only to the text output.

### Filter

- Flag: `--filter`
- Short Flag: `-x`
- Valid inputs: case-sensitive name of the result property.

Specify any property name from the result you want to return as the only value.

### Output

- Flag: `--output`
- Short Flag: `-o`
- Valid inputs: `json`, `inline`

Specify in which format you want to display the result.

### Save

- Flag: `--save`
- Short Flag: `-s`
- Valid inputs: valid filename

Specify the filename where you want the result to be saved.

### Log

- Flag: `--log`
- Short Flag: `-l`
- Valid inputs: `none`, `error`, `debug`
- Default: `info`

Specify the log level. Control how much output you want to see while command execution.

### Configuration

- Flag: `--config-path`
- Short Flag: `-f`
- Valid inputs: valid filename

Specify a filename for the configuration files, you can provide multiple configuration
files by using `-f` flag multiple times.

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.

---
title: Build a Complex Transaction
description: How to build and send a complex Flow transaction from the command line
sidebar_position: 4
---

**Simple Transactions**

Sending a transaction using the Flow CLI can simply be 
achieved by using the [send command documented here](./send-transactions.md).

**Complex Transactions**

If you would like to build more complex transactions the Flow CLI provides 
commands to build, sign and send transactions allowing you to specify different 
authorizers, signers and proposers.  

The process of sending a complex transactions includes three steps:
1. [build a transaction](./build-transactions.md)
2. [sign the built transaction](./sign-transaction.md)
3. [send signed transaction](./send-signed-transactions.md)

Read more about each command flags and arguments in the above links.

## Examples
We will describe common examples for complex transactions. All examples are using an [example configuration](./complex-transactions.md#configuration).

### Single payer, proposer and authorizer
The simplest Flow transaction declares a single account as the proposer, payer and authorizer.

Build the transaction:
```shell
> flow transactions build tx.cdc 
  --proposer alice 
  --payer alice 
  --authorizer alice 
  --filter payload --save tx1
```
Sign the transaction:
```shell
> flow transactions sign tx1 --signer alice 
  --filter payload --save tx2
```
Submit the signed transaction:
```shell
> flow transactions send-signed tx2
```
Transaction content (`tx.cdc`):
```
transaction {
    prepare(signer: AuthAccount) {}
    execute { ... }
}
```

### Single payer and proposer, multiple authorizers
A transaction that declares same payer and proposer but multiple authorizers each required to sign the transaction. Please note that the order of signing is important, and [the payer must sign last](../../../build/basics/transactions.md#payer-signs-last).

Build the transaction:
```shell
> flow transactions build tx.cdc 
  --proposer alice
  --payer alice
  --authorizer bob
  --authorizer charlie 
  --filter payload --save tx1
```
Sign the transaction with authorizers:
```shell
> flow transactions sign tx1 --signer bob
  --filter payload --save tx2
```
```shell
> flow transactions sign tx2 --signer charlie
  --filter payload --save tx3
```
Sign the transaction with payer:
```shell
> flow transactions sign tx3 --signer alice
  --filter payload --save tx4
```
Submit the signed transaction:
```shell
> flow transactions send-signed tx4
```
Transaction content (`tx.cdc`):
```
transaction {
    prepare(bob: AuthAccount, charlie: AuthAccount) {}
    execute { ... }
}
```

### Different payer, proposer and authorizer
A transaction that declares different payer, proposer and authorizer each signing separately. 
Please note that the order of signing is important, and [the payer must sign last](../../../build/basics/transactions.md#payer-signs-last).  

Build the transaction:
```shell
> flow transactions build tx.cdc 
  --proposer alice 
  --payer bob 
  --authorizer charlie 
  --filter payload --save tx1
```
Sign the transaction with proposer:
```shell
> flow transactions sign tx1 --signer alice 
  --filter payload --save tx2
```
Sign the transaction with authorizer:
```shell
> flow transactions sign tx2 --signer charlie 
  --filter payload --save tx3
```
Sign the transaction with payer:
```shell
> flow transactions sign tx3 --signer bob 
  --filter payload --save tx4
```
Submit the signed transaction:
```shell
> flow transactions send-signed tx4
```
Transaction content (`tx.cdc`):
```
transaction {
    prepare(charlie: AuthAccount) {}
    execute { ... }
}
```

### Single payer, proposer and authorizer but multiple keys
A transaction that declares same payer, proposer and authorizer but the signer account has two keys with half weight, required to sign with both.


Build the transaction:
```shell
> flow transactions build tx.cdc 
  --proposer dylan1 
  --payer dylan1
  --authorizer dylan1 
  --filter payload --save tx1
```
Sign the transaction with the first key:
```shell
> flow transactions sign tx1 --signer dylan1 
  --filter payload --save tx2
```
Sign the transaction with the second key:
```shell
> flow transactions sign tx2 --signer dylan2 
  --filter payload --save tx3
```
Submit the signed transaction:
```shell
> flow transactions send-signed tx3
```
Transaction content (`tx.cdc`):
```
transaction {
    prepare(signer: AuthAccount) {}
    execute { ... }
}
```

### Configuration
This is an example configuration using mock values:
```json
{
    ... 
    "accounts": {
        "alice": {
            "address": "0x1",
            "key": "111...111"
        },
        "bob": {
            "address": "0x2",
            "key": "222...222"
        },
        "charlie": {
            "address": "0x3",
            "key": "333...333"
        },
        "dylan1": {
            "address": "0x4",
            "key": "444...444"
        },
        "dylan2": {
            "address": "0x4",
            "key": "555...555"
        }
    }
    ...
}
```
---
title: Build a Complex Transaction
description: How to decode a Flow transaction from the command line
sidebar_position: 7
---

The Flow CLI provides a command to decode a transaction
from RLP in a file. It uses same transaction format as get command

```shell
flow transactions decode <file>
```

## Example Usage

```shell
> flow transactions decode ./rlp-file.rlp 

ID		c1a52308fb906358d4a33c1f1d5fc458d3cfea0d570a51a9dea915b90d678346
Payer		83de1a7075f190a1
Authorizers	[83de1a7075f190a1]

Proposal Key:	
    Address	    83de1a7075f190a1
    Index	    1
    Sequence	1

No Payload Signatures

Envelope Signature 0: 83de1a7075f190a1
Signatures (minimized, use --include signatures)

Code (hidden, use --include code)

Payload (hidden, use --include payload)
```

## Arguments

### Filename

- Name: `<file_name>`
- Valid Input: file name.

The first argument is the filename containing the transaction RLP.

## Flags
    
### Include Fields

- Flag: `--include`
- Valid inputs: `code`, `payload`, `signatures`

Specify fields to include in the result output. Applies only to the text output.

### Output

- Flag: `--output`
- Short Flag: `-o`
- Valid inputs: `json`, `inline`

Specify the format of the command results.

### Save

- Flag: `--save`
- Short Flag: `-s`
- Valid inputs: a path in the current filesystem.

Specify the filename where you want the result to be saved

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.---
title: Get a Transaction
description: How to get a Flow transaction from the command line
sidebar_position: 2
---

The Flow CLI provides a command to fetch a transaction
that was previously submitted to an Access API.

```shell
flow transactions get <tx_id>
```

## Example Usage

```shell
> flow transactions get 40bc4b100c1930c61381c22e0f4c10a7f5827975ee25715527c1061b8d71e5aa --network mainnet 

Status		✅ SEALED
ID		40bc4b100c1930c61381c22e0f4c10a7f5827975ee25715527c1061b8d71e5aa
Payer		18eb4ee6b3c026d2
Authorizers	[18eb4ee6b3c026d2]

Proposal Key:	
    Address	18eb4ee6b3c026d2
    Index	11
    Sequence	17930

Payload Signature 0: 18eb4ee6b3c026d2
Payload Signature 1: 18eb4ee6b3c026d2
Envelope Signature 0: 18eb4ee6b3c026d2
Signatures (minimized, use --include signatures)

Events:		 
    Index	0
    Type	A.1654653399040a61.FlowToken.TokensWithdrawn
    Tx ID	40bc4b100c1930c61381c22e0f4c10a7f5827975ee25715527c1061b8d71e5aa
    Values
		- amount (UFix64):	0.00100000
		- from ({}?):			18eb4ee6b3c026d2

    Index	1
    Type	A.1654653399040a61.FlowToken.TokensDeposited
    Tx ID	40bc4b100c1930c61381c22e0f4c10a7f5827975ee25715527c1061b8d71e5aa
    Values
		- amount (UFix64):	0.00100000
		- to ({}?):			5068e27f275c546c

    Index	2
    Type	A.18eb4ee6b3c026d2.PrivateReceiverForwarder.PrivateDeposit
    Tx ID	40bc4b100c1930c61381c22e0f4c10a7f5827975ee25715527c1061b8d71e5aa
    Values
		- amount (UFix64):	0.00100000
		- to ({}?):			5068e27f275c546c



Code (hidden, use --include code)

Payload (hidden, use --include payload)
```

## Arguments

### Transaction ID

- Name: `<tx_id>`
- Valid Input: transaction ID.

The first argument is the ID (hash) of the transaction.

## Flags
    
### Include Fields

- Flag: `--include`
- Valid inputs: `code`, `payload`, `signatures`

Specify fields to include in the result output. Applies only to the text output.

### Wait for Seal

- Flag: `--sealed`
- Default: `false`

Indicate whether to wait for the transaction to be sealed
before displaying the result.

### Exclude Fields

- Flag: `--exclude`
- Valid inputs: `events`

Specify fields to exclude from the result output. Applies only to the text output.

### Host

- Flag: `--host`
- Valid inputs: an IP address or hostname.
- Default: `127.0.0.1:3569` (Flow Emulator)

Specify the hostname of the Access API that will be
used to execute the command. This flag overrides
any host defined by the `--network` flag.

### Network Key

- Flag: `--network-key`
- Valid inputs: A valid network public key of the host in hex string format

Specify the network public key of the Access API that will be
used to create a secure GRPC client when executing the command.

### Network

- Flag: `--network`
- Short Flag: `-n`
- Valid inputs: the name of a network defined in the configuration (`flow.json`)
- Default: `emulator`

Specify which network you want the command to use for execution.

### Filter

- Flag: `--filter`
- Short Flag: `-x`
- Valid inputs: a case-sensitive name of the result property.

Specify any property name from the result you want to return as the only value.

### Output

- Flag: `--output`
- Short Flag: `-o`
- Valid inputs: `json`, `inline`

Specify the format of the command results.

### Save

- Flag: `--save`
- Short Flag: `-s`
- Valid inputs: a path in the current filesystem.

Specify the filename where you want the result to be saved

### Log

- Flag: `--log`
- Short Flag: `-l`
- Valid inputs: `none`, `error`, `debug`
- Default: `info`

Specify the log level. Control how much output you want to see during command execution.

### Configuration

- Flag: `--config-path`
- Short Flag: `-f`
- Valid inputs: a path in the current filesystem.
- Default: `flow.json`

Specify the path to the `flow.json` configuration file.
You can use the `-f` flag multiple times to merge
several configuration files.

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.---
title: Send Signed Transaction
description: How to send a signed Flow transaction from the command line
sidebar_position: 6
---

The Flow CLI provides a command to send signed transactions to
any Flow Access API.

Use this functionality in the following order:
1. Use the `build` command to build the transaction.
2. Use the `sign` command to sign with each account specified in the build process.
3. Use this command (`send-signed`) to submit the signed transaction to the Flow network.

```shell
flow transactions send-signed <signed transaction filename>
```

## Example Usage

```shell
> flow transactions send-signed ./signed.rlp
    
Status		✅ SEALED
ID		528332aceb288cdfe4d11d6522aa27bed94fb3266b812cb350eb3526ed489d99
Payer		f8d6e0586b0a20c7
Authorizers	[f8d6e0586b0a20c7]

Proposal Key:	
    Address	f8d6e0586b0a20c7
    Index	0
    Sequence	0

No Payload Signatures

Envelope Signature 0: f8d6e0586b0a20c7
Signatures (minimized, use --include signatures)

Events:	 None

Code (hidden, use --include code)

Payload (hidden, use --include payload)

```


## Arguments

### Signed Code Filename
- Name: `signed transaction filename`
- Valid inputs: Any filename and path valid on the system.

The first argument is a path to a Cadence file containing the
transaction to be executed.

## Flags

### Include Fields

- Flag: `--include`
- Valid inputs: `code`, `payload`

Specify fields to include in the result output. Applies only to the text output.

### Exclude Fields

- Flag: `--exclude`
- Valid inputs: `events`

Specify fields to exclude from the result output. Applies only to the text output.

### Filter

- Flag: `--filter`
- Short Flag: `-x`
- Valid inputs: a case-sensitive name of the result property.

Specify any property name from the result you want to return as the only value.

### Host

- Flag: `--host`
- Valid inputs: an IP address or hostname.
- Default: `127.0.0.1:3569` (Flow Emulator)

Specify the hostname of the Access API that will be
used to execute the command. This flag overrides
any host defined by the `--network` flag.

### Network Key

- Flag: `--network-key`
- Valid inputs: A valid network public key of the host in hex string format

Specify the network public key of the Access API that will be
used to create a secure GRPC client when executing the command.

### Network

- Flag: `--network`
- Short Flag: `-n`
- Valid inputs: the name of a network defined in the configuration (`flow.json`)
- Default: `emulator`

Specify which network you want the command to use for execution.

### Output

- Flag: `--output`
- Short Flag: `-o`
- Valid inputs: `json`, `inline`

Specify the format of the command results.

### Save

- Flag: `--save`
- Short Flag: `-s`
- Valid inputs: a path in the current filesystem.

Specify the filename where you want the result to be saved

### Log

- Flag: `--log`
- Short Flag: `-l`
- Valid inputs: `none`, `error`, `debug`
- Default: `info`

Specify the log level. Control how much output you want to see during command execution.

### Configuration

- Flag: `--config-path`
- Short Flag: `-f`
- Valid inputs: a path in the current filesystem.
- Default: `flow.json`

Specify the path to the `flow.json` configuration file.
You can use the `-f` flag multiple times to merge
several configuration files.

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.---
title: Send a Transaction
description: How to send a Flow transaction from the command line
sidebar_position: 1
---

The Flow CLI provides a command to sign and send transactions to
any Flow Access API.

```shell
flow transactions send <code filename> [<argument> <argument>...] [flags]
```

## Example Usage

```shell
> flow transactions send ./tx.cdc "Hello"
    
Status		✅ SEALED
ID		b04b6bcc3164f5ee6b77fa502c3a682e0db57fc47e5b8a8ef3b56aae50ad49c8
Payer		f8d6e0586b0a20c7
Authorizers	[f8d6e0586b0a20c7]

Proposal Key:	
    Address	f8d6e0586b0a20c7
    Index	0
    Sequence	0

No Payload Signatures

Envelope Signature 0: f8d6e0586b0a20c7
Signatures (minimized, use --include signatures)

Events:	 None

Code (hidden, use --include code)

Payload (hidden, use --include payload)

```

Multiple arguments example:
```shell
> flow transactions send tx1.cdc Foo 1 2 10.9 0x1 '[123,222]' '["a","b"]'
```
Transaction code:
```
transaction(a: String, b: Int, c: UInt16, d: UFix64, e: Address, f: [Int], g: [String]) {
	prepare(authorizer: AuthAccount) {}
}
```

In the above example, the `flow.json` file would look something like this:

```json
{
  "accounts": {
    "my-testnet-account": {
      "address": "a2c4941b5f3c7151",
      "key": "12c5dfde...bb2e542f1af710bd1d40b2"
    }
  }
}
```

JSON arguments from a file example:
```shell
> flow transactions send tx1.cdc --args-json "$(cat args.json)"
```

## Arguments

### Code Filename
- Name: `code filename`
- Valid inputs: Any filename and path valid on the system.

The first argument is a path to a Cadence file containing the
transaction to be executed.

### Arguments
- Name: `argument`
- Valid inputs: valid [cadence values](https://cadence-lang.org/docs/json-cadence-spec) 
  matching argument type in transaction code.

Input arguments values matching corresponding types in the source code and passed in the same order.
You can pass a `nil` value to optional arguments by sending the transaction like this: `flow transactions send tx.cdc nil`.

## Flags

### Include Fields

- Flag: `--include`
- Valid inputs: `code`, `payload`

Specify fields to include in the result output. Applies only to the text output.

### Code

- Flag: `--code`

⚠️  No longer supported: use filename argument.

### Results

- Flag: `--results`

⚠️  No longer supported: all transactions will provide result.

### Exclude Fields

- Flag: `--exclude`
- Valid inputs: `events`

Specify fields to exclude from the result output. Applies only to the text output.

### Signer

- Flag: `--signer`
- Valid inputs: the name of an account defined in the configuration (`flow.json`)

Specify the name of the account that will be used to sign the transaction.

### Proposer

- Flag: `--proposer`
- Valid inputs: the name of an account defined in the configuration (`flow.json`)

Specify the name of the account that will be used as proposer in the transaction.

### Payer

- Flag: `--payer`
- Valid inputs: the name of an account defined in the configuration (`flow.json`)

Specify the name of the account that will be used as payer in the transaction.

### Authorizer

- Flag: `--authorizer`
- Valid inputs: the name of a single or multiple comma-separated accounts defined in the configuration (`flow.json`)

Specify the name of the account(s) that will be used as authorizer(s) in the transaction. If you want to provide multiple authorizers separate them using commas (e.g. `alice,bob`)

### Arguments JSON

- Flag: `--args-json`
- Valid inputs: arguments in JSON-Cadence form.
- Example: `flow transactions send ./tx.cdc '[{"type": "String", "value": "Hello World"}]'`

Arguments passed to the Cadence transaction in Cadence JSON format.
Cadence JSON format contains `type` and `value` keys and is 
[documented here](https://cadence-lang.org/docs/json-cadence-spec).

### Gas Limit

- Flag: `--gas-limit`
- Valid inputs: an integer greater than zero.
- Default: `1000`

Specify the gas limit for this transaction.

### Host

- Flag: `--host`
- Valid inputs: an IP address or hostname.
- Default: `127.0.0.1:3569` (Flow Emulator)

Specify the hostname of the Access API that will be
used to execute the command. This flag overrides
any host defined by the `--network` flag.

### Network Key

- Flag: `--network-key`
- Valid inputs: A valid network public key of the host in hex string format

Specify the network public key of the Access API that will be
used to create a secure GRPC client when executing the command.

### Network

- Flag: `--network`
- Short Flag: `-n`
- Valid inputs: the name of a network defined in the configuration (`flow.json`)
- Default: `emulator`

Specify which network you want the command to use for execution.

### Filter

- Flag: `--filter`
- Short Flag: `-x`
- Valid inputs: a case-sensitive name of the result property.

Specify any property name from the result you want to return as the only value.

### Output

- Flag: `--output`
- Short Flag: `-o`
- Valid inputs: `json`, `inline`

Specify the format of the command results.

### Save

- Flag: `--save`
- Short Flag: `-s`
- Valid inputs: a path in the current filesystem.

Specify the filename where you want the result to be saved

### Log

- Flag: `--log`
- Short Flag: `-l`
- Valid inputs: `none`, `error`, `debug`
- Default: `info`

Specify the log level. Control how much output you want to see during command execution.

### Configuration

- Flag: `--config-path`
- Short Flag: `-f`
- Valid inputs: a path in the current filesystem.
- Default: `flow.json`

Specify the path to the `flow.json` configuration file.
You can use the `-f` flag multiple times to merge
several configuration files.

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.
---
title: Sign a Transaction
description: How to sign a Flow transaction from the command line
sidebar_position: 5
---

The Flow CLI provides a command to sign transactions with options to specify
authorizer accounts, payer accounts and proposer accounts.

Use this functionality in the following order:
1. Use the `build` command to build the transaction.
2. Use this command (`sign`) to sign with each account specified in the build process.
3. Use the `send-signed` command to submit the signed transaction to the Flow network.

```shell
flow transactions sign <built transaction filename>
```

## Example Usage

```shell
> flow transactions sign ./built.rlp --signer alice \
  --filter payload --save signed.rlp

Hash		b03b18a8d9d30ff7c9f0fdaa80fcaab242c2f36eedb687dd9b368326311fe376
Payer		f8d6e0586b0a20c7
Authorizers	[f8d6e0586b0a20c7]

Proposal Key:	
    Address	f8d6e0586b0a20c7
    Index	0
    Sequence	6

No Envelope Signatures

Payload Signature 0:
    Address	f8d6e0586b0a20c7
    Signature	b5b1dfed2a899037...164e1b224a7ac924018e7033b68b0df86769dd54
    Key Index	0


Arguments (1):
    - Argument 0: {"type":"String","value":"Meow"}


Code

transaction(greeting: String) {
  let guest: Address

  prepare(authorizer: AuthAccount) {
    self.guest = authorizer.address
  }

  execute {
    log(greeting.concat(",").concat(self.guest.toString()))
  }
}


Payload:
f90184f...a199bfd9b837a11a0885f9104b54014750f5e3e5bfe4a5795968b0df86769dd54c0
```

## Arguments

### Built Transaction Filename or Remote Server URL
- Name: `built transaction filename | --from-remote-url <url>`
- Valid inputs: Any filename and path valid on the system or --from-remote-url flag and fully qualified remote server url.

Specify the filename containing valid transaction payload that will be used for signing.
To be used with the `flow transaction build` command.

When --from-remote-url flag is used the value needs to be a fully qualified url to transaction RLP
Example: `flow transaction sign --from-remote-url https://fully/qualified/url --signer alice`
## Flags

### From Remote Url
- Flag: `--from-remote-url`
- Valid input: `http(s)://fully/qualified/server/url`

Specify this flag with a fully qualified url to transaction RLP. The RLP will be fetched from server then signed. The resulting signed RLP is then posted to the remote url. This feature is to support protocol level multiple signature transaction coordination between multiple signers.
Note: --yes flag is not supported and will fail `sign` command when this flag is used. This forces the user to verify the cadence code.

### Include Fields

- Flag: `--include`
- Valid inputs: `code`, `payload`, `signatures`

Specify fields to include in the result output. Applies only to the text output.

### Signer

- Flag: `--signer`
- Valid inputs: the name of an account defined in the configuration (`flow.json`)

Specify the name of the account that will be used to sign the transaction.

### Host
- Flag: `--host`
- Valid inputs: an IP address or hostname.
- Default: `127.0.0.1:3569` (Flow Emulator)

Specify the hostname of the Access API that will be
used to execute the commands.

### Network Key

- Flag: `--network-key`
- Valid inputs: A valid network public key of the host in hex string format

Specify the network public key of the Access API that will be
used to create a secure GRPC client when executing the command.

### Network

- Flag: `--network`
- Short Flag: `-n`
- Valid inputs: the name of a network defined in the configuration (`flow.json`)
- Default: `emulator`

Specify which network you want the command to use for execution.

### Filter

- Flag: `--filter`
- Short Flag: `-x`
- Valid inputs: case-sensitive name of the result property.

Specify any property name from the result you want to return as the only value.

### Output

- Flag: `--output`
- Short Flag: `-o`
- Valid inputs: `json`, `inline`

Specify in which format you want to display the result.

### Save

- Flag: `--save`
- Short Flag: `-s`
- Valid inputs: valid filename

Specify the filename where you want the result to be saved.

### Log

- Flag: `--log`
- Short Flag: `-l`
- Valid inputs: `none`, `error`, `debug`
- Default: `info`

Specify the log level. Control how much output you want to see while command execution.

### Configuration

- Flag: `--conf`
- Short Flag: `-f`
- Valid inputs: valid filename

Specify a filename for the configuration files, you can provide multiple configuration
files by using `-f` flag multiple times.

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.{
  "label": "Utils",
  "position": 10
}---
title: Generate a Signature
description: How to generate a new signature from the command line
---

Generate a signature using the private key of the signer account.

```shell
flow signatures generate <message>  
```

⚠️ _Make sure the account you want to use for signing is saved in the `flow.json` configuration. 
The address of the account is not important, just the private key._

## Example Usage

```shell
> flow signatures generate 'The quick brown fox jumps over the lazy dog' --signer alice

Signature 		 b33eabfb05d374b...f09929da96f5beec167fd1f123ec
Message 		 The quick brown fox jumps over the lazy dog
Public Key 		 0xc92a7c...042c4025d241fd430242368ce662d39636987
Hash Algorithm 		 SHA3_256
Signature Algorithm 	 ECDSA_P256
```

## Arguments

### Message
- Name: `message`

Message used for signing.

## Flags

### Signer

- Flag: `--signer`
- Valid inputs: the name of an account defined in the configuration (`flow.json`)

Specify the name of the account that will be used to sign the transaction.

### Filter

- Flag: `--filter`
- Short Flag: `-x`
- Valid inputs: case-sensitive name of the result property.

Specify any property name from the result you want to return as the only value.

### Output

- Flag: `--output`
- Short Flag: `-o`
- Valid inputs: `json`, `inline`

Specify in which format you want to display the result.

### Save

- Flag: `--save`
- Short Flag: `-s`
- Valid inputs: valid filename

Specify the filename where you want the result to be saved.

### Log

- Flag: `--log`
- Short Flag: `-l`
- Valid inputs: `none`, `error`, `debug`
- Default: `info`

Specify the log level. Control how much output you want to see while command execution.

### Configuration

- Flag: `--config-path`
- Short Flag: `-f`
- Valid inputs: valid filename

Specify a filename for the configuration files, you can provide multiple configuration
files by using `-f` flag multiple times.

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.



---
title: Verify Signature
description: How to verify a signature from the command line 
---

Verify validity of a signature based on provided message and public key of the signature creator.

```shell
flow signatures verify <message> <signature> <public key>
```

## Example Usage

```shell
> flow signatures verify 
  'The quick brown fox jumps over the lazy dog' 
  b1c9eff5d829fdeaf2dad6308fc8033e3b8875bc185ef804ce5d0d980545ef5be0f98b47afc979d12272d257ce13c4b490e431bfcada485cb1d2e3f209be8d07 
  0xc92a7c72a78f8f046a79f8a5fe1ef72424258a55eb869f13e6133301d64ad025d3362d5df9e7c82289637af1431042c4025d241fd430242368ce662d39636987

Valid 			 true
Message 		 The quick brown fox jumps over the lazy dog
Signature 		 b1c9eff5d829fdeaf2...7ce13c4b490eada485cb1d2e3f209be8d07
Public Key 		 c92a7c72a78...1431042c4025d241fd430242368ce662d39636987
Hash Algorithm 		 SHA3_256
Signature Algorithm 	 ECDSA_P256
```

## Arguments

### Message
- Name: `message`

Message data used for creating the signature.

### Signature
- Name: `signature`

Message signature that will be verified.

### Public Key
- Name: `public key`

Public key of the private key used for creating the signature. 

## Flags

### Public Key Signature Algorithm

- Flag: `--sig-algo`
- Valid inputs: `"ECDSA_P256", "ECDSA_secp256k1"`

Specify the ECDSA signature algorithm of the key pair used for signing.

Flow supports the secp256k1 and P-256 curves.

### Public Key Hash Algorithm

- Flag: `--hash-algo`
- Valid inputs: `"SHA2_256", "SHA3_256"`
- Default: `"SHA3_256"`

Specify the hash algorithm of the key pair used for signing. 

### Filter

- Flag: `--filter`
- Short Flag: `-x`
- Valid inputs: case-sensitive name of the result property.

Specify any property name from the result you want to return as the only value.

### Output

- Flag: `--output`
- Short Flag: `-o`
- Valid inputs: `json`, `inline`

Specify in which format you want to display the result.

### Save

- Flag: `--save`
- Short Flag: `-s`
- Valid inputs: valid filename

Specify the filename where you want the result to be saved.

### Log

- Flag: `--log`
- Short Flag: `-l`
- Valid inputs: `none`, `error`, `debug`
- Default: `info`

Specify the log level. Control how much output you want to see while command execution.

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.


---
title: Snapshot Save
description: How to save a protocol snapshot from the command line
---

The FLOW CLI provides a command to save the latest finalized protocol state snapshot

```shell
flow snapshot save <output path>
```

## Example Usage

```shell
flow snapshot save  /tmp/snapshot.json --network testnet
```

### Example response
```shell
snapshot saved: /tmp/snapshot.json
```

## Arguments

### Output Path
- Name: `output path`
- Valid Input: any valid string path

Output path where the protocol snapshot JSON file will be saved.

## Flags


### Host
- Flag: `--host`
- Valid inputs: an IP address or hostname.
- Default: `127.0.0.1:3569` (Flow Emulator)

Specify the hostname of the Access API that will be
used to execute the commands.

### Network Key

- Flag: `--network-key`
- Valid inputs: A valid network public key of the host in hex string format

Specify the network public key of the Access API that will be
used to create a secure GRPC client when executing the command.

### Network

- Flag: `--network`
- Short Flag: `-n`
- Valid inputs: the name of a network defined in the configuration (`flow.json`)
- Default: `emulator`

Specify which network you want the command to use for execution.

### Filter

- Flag: `--filter`
- Short Flag: `-x`
- Valid inputs: case-sensitive name of the result property.

Specify any property name from the result you want to return as the only value.

### Output

- Flag: `--output`
- Short Flag: `-o`
- Valid inputs: `json`, `inline`

Specify in which format you want to display the result.

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.




---
title: Development Tools
description: How to start development tools using the Flow CLI
---

The Flow CLI integrates different development tools, which can now be easily started 
and managed from a single place. 

Currently the CLI supports starting:  
- [Flow Development Wallet](https://github.com/onflow/fcl-dev-wallet)


## Flow Development Wallet

The Flow Dev Wallet is a mock Flow wallet that simulates the protocols used by FCL to interact with the Flow blockchain on behalf of simulated user accounts.

**Be sure you have the emulator running before starting this command**
_You can start it using the `flow emulator` command_.

```shell
flow dev-wallet
```
_⚠️ This project implements an FCL compatible
interface, but should **not** be used as a reference for
building a production grade wallet._

After starting dev-wallet, you can set your fcl config to use it like below:

```javascript
import * as fcl from "@onflow/fcl"

fcl.config()
  // Point App at Emulator
  .put("accessNode.api", "http://localhost:8080") 
  // Point FCL at dev-wallet (default port)
  .put("discovery.wallet", "http://localhost:8701/fcl/authn") 
```
You can read more about setting up dev-wallet at [Flow Dev Wallet Project](https://github.com/onflow/fcl-dev-wallet)


## Flags

### Port

- Flag: `--port`
- Valid inputs: Number
- Default: `8701`

Port on which the dev wallet server will listen on.

### Emulator Host

- Flag: `--emulator-host`
- Valid inputs: a hostname
- Default: `http://localhost:8080`

Specifies the host configuration for dev wallet

### Configuration

- Flag: `--config-path`
- Short Flag: `-f`
- Valid inputs: valid filename

Specify a filename for the configuration files, you can provide multiple configuration
files by using `-f` flag multiple times.

Specify a filename for the configuration files, you can provide multiple configuration
files by using `-f` flag multiple times.

### Version Check

- Flag: `--skip-version-check`
- Default: `false`

Skip version check during start up to speed up process for slow connections.


---
title: Flow Dev Wallet
sidebar_label: Flow Dev Wallet
---

The Flow Dev Wallet is a mock Flow wallet that simulates the protocols used by [FCL](../clients/fcl-js/index.md) to interact with the Flow blockchain on behalf of simulated user accounts.

**IMPORTANT**

```
This project implements an FCL compatible
interface, but should **not** be used as a reference for
building a production grade wallet.

This project should only be used in aid of local
development against a locally run instance of the Flow
blockchain like the Flow emulator, and should never be used in
conjunction with Flow Mainnet, Testnet, Canarynet or any
other instances of Flow.
```

## Getting started

Before using the dev wallet, you'll need to start the Flow emulator.

### Install the `flow-cli`

The Flow emulator is bundles with the Flow CLI. Instructions for installing the CLI can be found here: [flow-cli/install/](../flow-cli/install.md)

### Create a `flow.json` file

Run this command to create `flow.json` file (typically in your project's root directory):

```sh
flow init
```

### Start the emulator

Start the emulator and deploy the contracts by running the following command from the directory containing `flow.json` in your project:

```sh
flow emulator start
flow project deploy --network emulator
```

## Configuring your JavaScript application

The Flow Dev Wallet is designed to be used with [`@onflow/fcl`](https://github.com/onflow/flow-js-sdk) version `1.0.0` or higher. The FCL package can be installed with: `npm install @onflow/fcl` or `yarn add @onflow/fcl`.

To use the dev wallet, configure FCL to point to the address of a locally running [Flow emulator](#start-the-emulator) and the dev wallet endpoint.

```javascript
import * as fcl from "@onflow/fcl"

fcl
  .config()
  // Point App at Emulator REST API
  .put("accessNode.api", "http://localhost:8888")
  // Point FCL at dev-wallet (default port)
  .put("discovery.wallet", "http://localhost:8701/fcl/authn")
```

### Test harness

It's easy to use this FCL harness app as a barebones
app to interact with the dev-wallet during development:

Navigate to http://localhost:8701/harness

## Contributing
Releasing a new version of Dev Wallet is as simple as tagging and creating a release, a Github Action will then build a bundle of the Dev Wallet that can be used in other tools (such as CLI). If the update of the Dev Wallet is required in the CLI, a seperate update PR on the CLI should be created.
 
---
title: Account Management
sidebar_label: Accounts
description: How to manage accounts addresses
---

## Overview

Flow accounts are not derived from a private key. This creates an issues for testing, since
you need to create actors in a specific order to use their addresses properly.

To reduce this friction, `getAccountAddress`, allows you to access a specific address using an alias. This way you can think about actual actors -- for example `Alice` and `Bob` -- without needing to know their Flow addresses.

It also helps you to write tests in a sequential or non-sequential way. Calling this method for the first time will create a new account and return the address. Calling it a second time with the same alias again will return the Flow address for that account, without creating new account.

## Private Key Management

#### Universal private key

By default, accounts created and consumed by the Flow JS Testing library will use a universal private key for signing transactions. Generally, this alleviates the burden of any low-level key management and streamlines the process of testing cadence code.

#### Custom private keys

However, under some circumstances the user may wish to create accounts (see: [`createAccount`](./accounts.md#createaccountname-keys)) or sign for accounts (see: [`sendTransaction`](./send-transactions.md)) using custom private keys (i.e. private key value, [hashing algorithm](./api.md#hashalgorithm), [signing algorithm](./send-transactions.md#signaturealgorithm), etc.) - this functionality is facilitated by the aforementioned methods.

## `getAccountAddress`

Resolves name alias to a Flow address (`0x` prefixed) under the following conditions:

- If an account with a specific name has not been previously accessed, the framework will create a new one and then store it under the provided alias.
- Next time when you call this method, it will grab exactly the same account. This allows you to create several accounts up-front and then use them throughout your code, without worrying that accounts match or trying to store and manage specific addresses.

#### Arguments

| Name    | Type   | Description                       |
| ------- | ------ | --------------------------------- |
| `alias` | string | The alias to reference or create. |

#### Returns

| Type                                                          | Description                              |
| ------------------------------------------------------------- | ---------------------------------------- |
| [Address](../clients/fcl-js/api.md#address) | `0x` prefixed address of aliased account |

#### Usage

```javascript
import {getAccountAddress} from "@onflow/flow-js-testing"

const main = async () => {
  const Alice = await getAccountAddress("Alice")
  console.log({Alice})
}

main()
```

## `createAccount({name, keys})`

In some cases, you may wish to manually create an account with a particular set of private keys

#### Options

_Pass in the following as a single object with the following keys._

| Key    | Type                                                                 | Required | Description                                                                                                                                                                                            |
| ------ | -------------------------------------------------------------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `name` | string                                                               | No       | human-readable name to be associated with created account (will be used for address lookup within [getAccountAddress](./accounts.md#getaccountaddress))                                                             |
| `keys` | [[KeyObject](./api.md#keyobject) or [PublicKey](./api.md#publickey)] | No       | An array of [KeyObjects](./api.md#keyobject) or [PublicKeys](./api.md#publickey) to be added to the account upon creation (defaults to the [universal private key](./accounts.md#universal-private-key)) |

> 📣 if `name` field not provided, the account address will not be cached and you will be unable to look it up using [`getAccountAddress`](./accounts.md#getaccountaddress).

#### Returns

| Type                                                          | Description                              |
| ------------------------------------------------------------- | ---------------------------------------- |
| [Address](../clients/fcl-js/api.md#address) | `0x` prefixed address of created account |# JS Testing API Reference

> ⚠️ **Required:** Your project must follow the [required structure](./structure.md) and it must be [initialized](./api.md#init) to use the following functions.

## Accounts

### `getAccountAddress`

Resolves name alias to a Flow address (`0x` prefixed) under the following conditions:

- If an account with a specific name has not been previously accessed, the framework will create a new one and then store it under the provided alias.
- Next time when you call this method, it will grab exactly the same account. This allows you to create several accounts up-front and then use them throughout your code, without worrying that accounts match or trying to store and manage specific addresses.

#### Arguments

| Name    | Type   | Description                       |
| ------- | ------ | --------------------------------- |
| `alias` | string | The alias to reference or create. |

#### Returns

| Type                                                          | Description                              |
| ------------------------------------------------------------- | ---------------------------------------- |
| [Address](../clients/fcl-js/api.md#address) | `0x` prefixed address of aliased account |

#### Usage

```javascript
import {getAccountAddress} from "@onflow/flow-js-testing"

const main = async () => {
  const Alice = await getAccountAddress("Alice")
  console.log({Alice})
}

main()
```

### `createAccount({name, keys})`

In some cases, you may wish to manually create an account with a particular set of private keys

#### Options

_Pass in the following as a single object with the following keys._

| Key    | Type                                                                 | Required | Description                                                                                                                                                                                            |
| ------ | -------------------------------------------------------------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `name` | string                                                               | No       | human-readable name to be associated with created account (will be used for address lookup within [getAccountAddress](./api.md#getaccountaddress))                                                     |
| `keys` | [[KeyObject](./api.md#keyobject) or [PublicKey](./api.md#publickey)] | No       | An array of [KeyObjects](./api.md#keyobject) or [PublicKeys](./api.md#publickey) to be added to the account upon creation (defaults to the [universal private key](./accounts.md#universal-private-key)) |

> 📣 if `name` field not provided, the account address will not be cached and you will be unable to look it up using [`getAccountAddress`](./api.md#getaccountaddress).

#### Returns

| Type                                                          | Description                              |
| ------------------------------------------------------------- | ---------------------------------------- |
| [Address](../clients/fcl-js/api.md#address) | `0x` prefixed address of created account |

## Contracts

### `deployContractByName(props)`

Deploys contract code located inside a Cadence file. Returns the transaction result.

#### Arguments

Props object accepts the following fields:

| Name           | Type                                                          | Optional | Description                                                                                                                                     |
| -------------- | ------------------------------------------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| `name`         | string                                                        |          | name of the file in `contracts` folder (with `.cdc` extension) and name of the contract (please note those should be the same)                  |
| `to`           | [Address](../clients/fcl-js/api.md#address) | ✅       | (optional) account address, where contract will be deployed. If this is not specified, framework will create new account with randomized alias. |
| `addressMap`   | [AddressMap](./api.md#addressmap)                             | ✅       | (optional) object to use for address mapping of existing deployed contracts                                                                     |
| `args`         | [Any]                                                         | ✅       | (optional) arguments, which will be passed to contract initializer. (optional) if template does not expect any arguments.                       |
| `update`       | boolean                                                       | ✅       | (optional) whether to update deployed contract. Default: `false`                                                                                |
| `transformers` | [[CadenceTransformer](./api.md#cadencetransformer)]           | ✅       | (optional) an array of operators to modify the code, before submitting it to network                                                            |

#### Returns

| Type                                                                        | Description                          |
| --------------------------------------------------------------------------- | ------------------------------------ |
| [ResponseObject](../clients/fcl-js/api.md#responseobject) | Result of the deploying transaction. |

#### Usage

```javascript
import path from "path";
import { init, emulator, deployContractByName } from "@onflow/flow-js-testing";

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence");

  await init(basePath);
  await emulator.start();

  // We will deploy our contract to the address that corresponds to "Alice" alias
  const to = await getAccountAddress("Alice");

  // We assume there is a file on "../cadence/contracts/Wallet.cdc" path
  const name = "Wallet";

  // Arguments will be processed and type matched in the same order as they are specified
  // inside of a contract template
  const args = [1337, "Hello", { name: "Alice" }];

  const [deploymentResult, err] = await deployContractByName({ to, name });
  console.log({ deploymentResult }, { err });
  }

  await emulator.stop();
};

main();
```

In a bit more rare case you would want to deploy contract code not from existing template file, but rather
from string representation of it. `deployContract` method will help you achieve this.

### `deployContract(props)`

Deploys contract code specified as string. Returns the transaction result.

#### Arguments

Props object accepts the following fields:

| Name           | Type                                                          | Optional | Description                                                                                                                          |
| -------------- | ------------------------------------------------------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| `contractCode` | string                                                        |          | string representation of contract                                                                                                    |
| `name`         | string                                                        |          | name of the contract to be deployed. Should be the same as the name of the contract provided in `contractCode`                       |
| `to`           | [Address](../clients/fcl-js/api.md#address) | ✅       | account address, where contract will be deployed. If this is not specified, framework will create new account with randomized alias. |
| `addressMap`   | [AddressMap](./api.md#addressmap)                             | ✅       | object to use for import resolver. Default: `{}`                                                                                     |
| `args`         | [Any]                                                         | ✅       | arguments, which will be passed to contract initializer. Default: `[]`                                                               |
| `update`       | boolean                                                       | ✅       | whether to update deployed contract. Default: `false`                                                                                |
| `transformers` | [[CadenceTransformer](./api.md#cadencetransformer)]           | ✅       | an array of operators to modify the code, before submitting it to network                                                            |

#### Returns

| Type                                                                        | Description                          |
| --------------------------------------------------------------------------- | ------------------------------------ |
| [ResponseObject](../clients/fcl-js/api.md#responseobject) | Result of the deploying transaction. |

#### Usage

```javascript
import path from "path"
import {
  init,
  emulator,
  getAccountAddress,
  deployContract,
  executeScript,
} from "@onflow/flow-js-testing"
;(async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  await init(basePath)
  await emulator.start()

  // We can specify, which account will hold the contract
  const to = await getAccountAddress("Alice")

  const name = "Wallet"
  const code = `
        pub contract Wallet{
            pub let balance: UInt
            init(balance: UInt){
              self.balance = balance
            }
        }
    `
  const args = [1337]

  await deployContract({to, name, code, args})

  const [balance, err] = await executeScript({
    code: `
      import Wallet from 0x01
      pub fun main(): UInt{
        return Wallet.balance
      }
    `,
  })
  console.log({balance}, {err})

  await emulator.stop()
})()
```

While framework have automatic import resolver for Contracts you might want to know where it's currently deployed.
We provide a method `getContractAddress` for this.

### `getContractAddress(name)`

Returns address of the account where the contract is currently deployed.

#### Arguments

| Name   | Type   | Description          |
| ------ | ------ | -------------------- |
| `name` | string | name of the contract |

#### Returns

| Type                                                          | Description           |
| ------------------------------------------------------------- | --------------------- |
| [Address](../clients/fcl-js/api.md#address) | `0x` prefixed address |

#### Usage

```javascript
import path from "path"
import {init, emulator, deployContractByName, getContractAddress} from "../src"
;(async () => {
  const basePath = path.resolve(__dirname, "./cadence")

  await init(basePath)
  await emulator.start()

  // if we omit "to" it will be deployed to Service Account
  // but let's pretend we don't know where it will be deployed :)
  await deployContractByName({name: "Hello"})

  const contractAddress = await getContractAddress("Hello")
  console.log({contractAddress})

  await emulator.stop()
})()
```

📣 Framework does not support contracts with identical names deployed to different accounts. While you can deploy contract
to a new address, the internal system, which tracks where contracts are deployed, will only store last address.

## Cryptography

### `pubFlowKey(keyObject)`

The `pubFlowKey` method exported by Flow JS Testing Library will generate an RLP-encoded public key given a private key, hashing algorithm, signing algorithm, and key weight.

| Name        | Type                            | Optional | Description                                                                |
| ----------- | ------------------------------- | -------- | -------------------------------------------------------------------------- |
| `keyObject` | [KeyObject](./api.md#keyobject) | ✅       | an object containing a private key & the key's hashing/signing information |

If `keyObject` is not provided, Flow JS Testing will default to the [universal private key](./accounts.md#universal-private-key).

#### Returns

| Type   | Description            |
| ------ | ---------------------- |
| Buffer | RLP-encoded public key |

#### Usage

```javascript
import {pubFlowKey} from "@onflow/flow-js-testing"

const key = {
  privateKey: "a1b2c3", // private key as hex string
  hashAlgorithm: HashAlgorithm.SHA3_256,
  signatureAlgorithm: SignatureAlgorithm.ECDSA_P256,
  weight: 1000,
}

const pubKey = await pubFlowKey(key) // public key generated from keyObject provided
const genericPubKey = await pubFlowKey() // public key generated from universal private key/service key
```

### `signUserMessage(msgHex, signer, domainTag)`

The `signUserMessage` method will produce a user signature of some arbitrary data using a particular signer.

#### Arguments

| Name        | Type                                                                                                     | Optional | Description                                                                                                                                                                                                                              |
| ----------- | -------------------------------------------------------------------------------------------------------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `msgHex`    | string or Buffer                                                                                         |          | a hex-encoded string or Buffer which will be used to generate the signature                                                                                                                                                              |
| `signer`    | [Address](../clients/fcl-js/api.md#address) or [SignerInfo](./api.md#signerinfoobject) | ✅       | [Address](../clients/fcl-js/api.md#address) or [SignerInfo](./api.md#signerinfoobject) object representing user to generate this signature for (default: [universal private key](./accounts.md#universal-private-key)) |
| `domainTag` | string                                                                                                   | ✅       | Domain separation tag provided as a utf-8 encoded string (default: no domain separation tag). See more about [domain tags here](https://cadence-lang.org/docs/language/crypto#hashing-with-a-domain-tag).                             |

#### Returns

| Type                                        | Description                                                                                        |
| ------------------------------------------- | -------------------------------------------------------------------------------------------------- |
| [SignatureObject](./api.md#signatureobject) | An object representing the signature for the message & account/keyId which signed for this message |

#### Usage

```javascript
import {signUserMessage, getAccountAddress} from "@onflow/flow-js-testing"

const Alice = await getAccountAddress("Alice")
const msgHex = "a1b2c3"

const signature = await generateUserSignature(msgHex, Alice)
```

## `verifyUserSigntatures(msgHex, signatures, domainTag)`

Used to verify signatures generated by [`signUserMessage`](./api.md#signusermessagemessage-signer). This function takes an array of signatures and verifies that the total key weight sums to >= 1000 and that these signatures are valid.

#### Arguments

| Name         | Type                                          | Optional | Description                                                                                                                                                                                                  |
| ------------ | --------------------------------------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `msgHex`     | string                                        |          | the message which the provided signatures correspond to provided as a hex-encoded string or Buffer                                                                                                           |
| `signatures` | [[SignatureObject](./api.md#signatureobject)] |          | An array of [SignatureObjects](./api.md#signatureobject) which will be verified against this message                                                                                                         |
| `domainTag`  | string                                        | ✅       | Domain separation tag provided as a utf-8 encoded string (default: no domain separation tag). See more about [domain tags here](https://cadence-lang.org/docs/language/crypto#hashing-with-a-domain-tag). |

#### Returns

This method returns an object with the following keys:
| Type | Description |
| ---- | ----------- |
| boolean | Returns true if signatures are valid and total weight >= 1000 |

#### Usage

```javascript
import {
  signUserMessage,
  verifyUserSignatures,
  getAccountAddress,
} from "@onflow/flow-js-testing"

const Alice = await getAccountAddress("Alice")
const msgHex = "a1b2c3"

const signature = await generateUserSignature(msgHex, Alice)

console.log(await verifyUserSignatures(msgHex, Alice)) // true

const Bob = await getAccountAddress("Bob")
console.log(await verifyUserSignatures(msgHex, Bob)) // false
```

## Emulator

Flow Javascript Testing Framework exposes `emulator` singleton allowing you to run and stop emulator instance
programmatically. There are two methods available on it.

### `emulator.start(options)`

Starts emulator on a specified port. Returns Promise.

#### Arguments

| Name      | Type            | Optional | Description                                            |
| --------- | --------------- | -------- | ------------------------------------------------------ |
| `options` | EmulatorOptions | ✅       | an object containing options for starting the emulator |

#### EmulatorOptions

| Key            | Type    | Optional | Description                                                                       |
| -------------- | ------- | -------- | --------------------------------------------------------------------------------- |
| `logging`      | boolean | ✅       | whether log messages from emulator shall be added to the output (default: false)  |
| `flags`        | string  | ✅       | custom command-line flags to supply to the emulator (default: no flags)           |
| `adminPort`    | number  | ✅       | override the port which the emulator will run the admin server on (default: auto) |
| `restPort`     | number  | ✅       | override the port which the emulator will run the REST server on (default: auto)  |
| `grpcPort`     | number  | ✅       | override the port which the emulator will run the GRPC server on (default: auto)  |
| `debuggerPort` | number  | ✅       | override the port which the emulator will run the debug server on (default: auto) |

#### Returns

| Type                        | Description                                                      |
| --------------------------- | ---------------------------------------------------------------- |
| [Promise](./api.md#Promise) | Promise, which resolves to true if emulator started successfully |

#### Usage

```javascript
import path from "path"
import {emulator, init} from "../src"
;(async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  await init(basePath)

  // Start emulator instance on port 8080
  await emulator.start()
  console.log("emulator is working")

  // Stop running emulator
  await emulator.stop()
  console.log("emulator has been stopped")
})()
```

### `emulator.stop()`

Stops emulator instance. Returns Promise.

#### Arguments

This method does not expect any arguments.

#### Returns

| Type                        | Description                                                        |
| --------------------------- | ------------------------------------------------------------------ |
| [Promise](./api.md#Promise) | Promise, which resolves to true if emulator stopped without issues |

#### Usage

```javascript
import {emulator, init} from "@onflow/flow-js-testing"

describe("test setup", () => {
  // Instantiate emulator and path to Cadence files
  beforeEach(async () => {
    const basePath = path.resolve(__dirname, "../cadence")

    await init(basePath)
    await emulator.start()
  })

  // Stop emulator, so it could be restarted
  afterEach(async () => {
    await emulator.stop()
  })
})
```

### `emulator.setLogging(newState)`

Set logging flag on emulator, allowing to temporally enable/disable logging.

#### Arguments

| Name       | Type    | Description            |
| ---------- | ------- | ---------------------- |
| `newState` | boolean | Enable/disable logging |

#### Returns

Method does not return anything.

#### Usage

```javascript
import path from "path"
import {emulator, init} from "@onflow/flow-js-testing"

describe("test setup", () => {
  // Instantiate emulator and path to Cadence files
  beforeEach(async () => {
    const basePath = path.resolve(__dirname, "../cadence")

    await init(basePath)
    await emulator.start()
  })

  // Stop emulator, so it could be restarted
  afterEach(async () => {
    await emulator.stop()
  })

  test("basic test", async () => {
    // Turn on logging from begining
    emulator.setLogging(true)
    // some asserts and interactions

    // Turn off logging for later calls
    emulator.setLogging(false)
    // more asserts and interactions here
  })
})
```

## FLOW Management

Some actions on the network will require account to have certain amount of FLOW token - transaction and storage fees,
account creation, etc.

Framework provides a method to query balance with `getFlowBalance` and mint new tokens via `mintFlow`. You can find
information how to use them below.

### `getFlowBalance(address)`

Fetch current FlowToken balance of account specified by address

#### Arguments

| Name      | Type                                                          | Description                     |
| --------- | ------------------------------------------------------------- | ------------------------------- |
| `address` | [Address](../clients/fcl-js/api.md#address) | address of the account to check |

#### Returns

| Type   | Description                                                                  |
| ------ | ---------------------------------------------------------------------------- |
| string | UFix64 amount of FLOW tokens stored in account storage represented as string |

#### Usage

```javascript
import {
  init,
  emulator,
  getAccountAddress,
  getFlowBalance,
} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  await init(basePath)
  await emulator.start()

  const Alice = await getAccountAddress("Alice")

  const [result, error] = await getFlowBalance(Alice)
  console.log({result}, {error})

  await emulator.stop()
}

main()
```

### `mintFlow(recipient, amount)`

Sends transaction to mint specified amount of FLOW token and send it to recipient.

> ⚠️ **Required:** Framework shall be initialized with `init` method for this method to work.

#### Arguments

| Name        | Type                                                          | Description                                                |
| ----------- | ------------------------------------------------------------- | ---------------------------------------------------------- |
| `recipient` | [Address](../clients/fcl-js/api.md#address) | address of the account to check                            |
| `amount`    | string                                                        | UFix64 amount of FLOW tokens to mint and send to recipient |

#### Returns

| Type                                                                        | Description        |
| --------------------------------------------------------------------------- | ------------------ |
| [ResponseObject](../clients/fcl-js/api.md#responseobject) | Transaction result |

#### Usage

```javascript
import path from "path"
import {
  init,
  emulator,
  getAccountAddress,
  getFlowBalance,
  mintFlow,
} from "../src"
;(async () => {
  const basePath = path.resolve(__dirname, "./cadence")

  await init(basePath)
  await emulator.start()

  // Get address for account with alias "Alice"
  const Alice = await getAccountAddress("Alice")

  // Get initial balance
  const [initialBalance] = await getFlowBalance(Alice)
  console.log(initialBalance)

  // Add 1.0 FLOW tokens to Alice account
  await mintFlow(Alice, "1.0")

  // Check updated balance
  const updatedBalance = await getFlowBalance(Alice)
  console.log({updatedBalance})

  await emulator.stop()
})()
```

## Init

For Framework to operate properly you need to initialize it first.
You can do it with provided `init` method.

### init( basePath, options)

Initializes framework variables.

#### Arguments

| Name       | Type   | Optional | Description                                           |
| ---------- | ------ | -------- | ----------------------------------------------------- |
| `bastPath` | string |          | path to the folder holding all Cadence template files |
| `options`  | object | ✅       | options object to use during initialization           |

#### Options

| Name   | Type | Optional | Description                     |
| ------ | ---- | -------- | ------------------------------- |
| `pkey` |      | ✅       | private key for service account |

#### Returns

| Type                        | Description                                                           |
| --------------------------- | --------------------------------------------------------------------- |
| [Promise](./api.md#Promise) | Promise, which resolves to true if framework was initialized properly |

#### Usage

```javascript
import path from "path"
import {init} from "@onflow/flow-js-testing"

describe("test setup", () => {
  beforeEach(async () => {
    const basePath = path.resolve(__dirname, "../cadence")
    await init(basePath)

    // alternatively you can pass specific port
    // await init(basePath, {port: 8085})
  })
})
```

## Environment

### `getBlockOffset()`

Returns current block offset - amount of blocks added on top of real current block height.

#### Returns

| Type   | Description                                                                                 |
| ------ | ------------------------------------------------------------------------------------------- |
| string | number representing amount of blocks added on top of real current block (encoded as string) |

#### Usage

```javascript
import path from "path"
import {init, emulator, getBlockOffset} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  init(basePath)
  await emulator.start()

  const [blockOffset, err] = await getBlockOffset()
  console.log({blockOffset}, {err})

  await emulator.stop()
}

main()
```

### `setBlockOffset(offset)`

Returns current block offset - amount of blocks added on top of real current block height.

#### Arguments

| Name | Type | Description |
| ---- | ---- | ----------- |

#### Returns

| Type   | Description                                                                    |
| ------ | ------------------------------------------------------------------------------ |
| number | number representing amount of blocks added on top of real current block height |

#### Usage

```javascript
import path from "path"
import {
  init,
  emulator,
  executeScript,
  getBlockOffset,
  setBlockOffset,
  sendTransaction,
} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  init(basePath)
  await emulator.start()

  // Offset current block height by 42
  await setBlockOffset(42)

  const [blockOffset, err] = await getBlockOffset()
  console.log({blockOffset}, {err})

  // "getCurrentBlock().height" in your Cadence code will be replaced by Manager to a mocked value
  const code = `
    pub fun main(): UInt64 {
      return getCurrentBlock().height
    }
  `

  const [result, error] = await executeScript({code})
  console.log({result}, {error})

  await emulator.stop()
}

main()
```

### `getTimestampOffset()`

Returns current timestamp offset - amount of seconds added on top of real current timestamp.

#### Returns

| Type   | Description                                                                  |
| ------ | ---------------------------------------------------------------------------- |
| number | number representing amount of seconds added on top of real current timestamp |

#### Usage

```javascript
import path from "path"
import {init, emulator, getTimestampOffset} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  init(basePath)
  await emulator.start()

  const [timestampOffset, err] = await getTimestampOffset()
  console.log({timestampOffset}, {err})

  await emulator.stop()
}

main()
```

### `setTimestampOffset(offset)`

Returns current timestamp offset - amount of seconds added on top of real current timestamp.

#### Arguments

| Name | Type | Description |
| ---- | ---- | ----------- |

#### Returns

| Type   | Description                                                                  |
| ------ | ---------------------------------------------------------------------------- |
| number | number representing amount of seconds added on top of real current timestamp |

#### Usage

```javascript
import path from "path"
import {
  init,
  emulator,
  executeScript,
  getTimestampOffset,
  setTimestampOffset,
  sendTransaction,
} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  init(basePath)
  await emulator.start()

  // Offset current timestamp by 10s
  await setTimestampOffset(10)

  const [timestampOffset, err] = await getTimestampOffset()
  console.log({timestampOffset}, {err})

  // "getCurrentBlock().timestamp" in your Cadence code will be replaced by Manager to a mocked value
  const code = `
    pub fun main(): UInt64 {
      return getCurrentBlock().timestamp
    }
  `

  const [result, error] = await executeScript({code})
  console.log({result}, {error})

  await emulator.stop()
}

main()
```

## Jest Helpers

In order to simplify the process even further we've created several Jest-based methods, which will help you to catch
thrown errors and ensure your code works as intended.

### `shallPass(ix)`

Ensure transaction does not throw and sealed.

#### Arguments

| Name | Type                                | Description                                          |
| ---- | ----------------------------------- | ---------------------------------------------------- |
| `ix` | [Interaction](./api.md#interaction) | interaction, either in form of a Promise or function |

#### Returns

| Type                                                                        | Description        |
| --------------------------------------------------------------------------- | ------------------ |
| [ResponseObject](../clients/fcl-js/api.md#responseobject) | Transaction result |

#### Usage

```javascript
import path from "path"
import {
  init,
  emulator,
  shallPass,
  sendTransaction,
  getAccountAddress,
} from "js-testing-framework"

// We need to set timeout for a higher number, cause some interactions might need more time
jest.setTimeout(10000)

describe("interactions - sendTransaction", () => {
  // Instantiate emulator and path to Cadence files
  beforeEach(async () => {
    const basePath = path.resolve(__dirname, "./cadence")
    await init(basePath)
    return emulator.start()
  })

  // Stop emulator, so it could be restarted
  afterEach(async () => {
    return emulator.stop()
  })

  test("basic transaction", async () => {
    const code = `
      transaction(message: String){
        prepare(singer: AuthAccount){
          log(message)
        }
      }
    `
    const Alice = await getAccountAddress("Alice")
    const signers = [Alice]
    const args = ["Hello, Cadence"]

    const [txResult, error] = await shallPass(
      sendTransaction({
        code,
        signers,
        args,
      })
    )

    // Transaction result will hold status, events and error message
    console.log({txResult}, {error})
  })
})
```

### shallRevert(ix, message)

Ensure interaction throws an error. Can test for specific error messages or catch any error message if `message` is not provided.
Returns Promise, which contains result, when resolved.

#### Arguments

| Name                     | Type                                | Description                                                                                                              |
| ------------------------ | ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| `ix`                     | [Interaction](./api.md#interaction) | transaction, either in form of a Promise or function                                                                     |
| `message` **(optional)** | `string` or `RegExp`                | expected error message provided as either a string equality or regular expression to match, matches any error by default |

#### Returns

| Type                                                                        | Description        |
| --------------------------------------------------------------------------- | ------------------ |
| [ResponseObject](../clients/fcl-js/api.md#responseobject) | Transaction result |

#### Usage

```javascript
import path from "path"
import {
  init,
  emulator,
  shallPass,
  sendTransaction,
  getAccountAddress,
} from "js-testing-framework"

// We need to set timeout for a higher number, cause some interactions might need more time
jest.setTimeout(10000)

describe("interactions - sendTransaction", () => {
  // Instantiate emulator and path to Cadence files
  beforeEach(async () => {
    const basePath = path.resolve(__dirname, "./cadence")
    await init(basePath)
    return emulator.start()
  })

  // Stop emulator, so it could be restarted
  afterEach(async () => {
    return emulator.stop()
  })

  test("basic transaction", async () => {
    const code = `
      transaction(message: String){
        prepare(singer: AuthAccount){
          panic("You shall not pass!")
        }
      }
    `
    const Alice = await getAccountAddress("Alice")
    const signers = [Alice]
    const args = ["Hello, Cadence"]

    // Catch any cadence error
    let [txResult, error] = await shallRevert(
      sendTransaction({
        code,
        signers,
        args,
      })
    )

    // Catch only specific panic message
    let [txResult2, error2] = await shallRevert(
      sendTransaction({
        code,
        signers,
        args,
      }),
      "You shall not pass!"
    )

    // Transaction result will hold status, events and error message
    console.log({txResult}, {error})
  })
})
```

### shallResolve(ix)

Ensure interaction resolves without throwing errors.

#### Arguments

| Name | Type                                | Description                                          |
| ---- | ----------------------------------- | ---------------------------------------------------- |
| `ix` | [Interaction](./api.md#interaction) | interaction, either in form of a Promise or function |

#### Returns

| Type                                            | Description        |
| ----------------------------------------------- | ------------------ |
| [InteractionResult](./api.md#InteractionResult) | Interaction result |

#### Usage

```javascript
import path from "path"
import {init, emulator, shallPass, executeScript} from "js-testing-framework"

// We need to set timeout for a higher number, cause some interactions might need more time
jest.setTimeout(10000)

describe("interactions - sendTransaction", () => {
  // Instantiate emulator and path to Cadence files
  beforeEach(async () => {
    const basePath = path.resolve(__dirname, "./cadence")
    await init(basePath)
    return emulator.start()
  })

  // Stop emulator, so it could be restarted
  afterEach(async () => {
    return emulator.stop()
  })

  test("basic script", async () => {
    const code = `
      pub fun main():Int{
        return 42
      }
    `

    const [result, error] = await shallResolve(
      executeScript({
        code,
      })
    )

    expect(result).toBe(42)
    expect(error).toBe(null)
  })
})
```

## Scripts

It is often the case that you need to query current state of the network. For example, to check balance of the
account, read public value of the contract or ensure that user has specific resource in their storage.

We abstract this interaction into single method called `executeScript`. Method have 2 different signatures.

> ⚠️ **Required:** Your project must follow the [required structure](./structure.md) it must be [initialized](./init.md) to use the following functions.

### `executeScript(props)`

Provides explicit control over how you pass values.

#### Arguments

`props` object accepts following fields:

| Name           | Type                                                | Optional | Description                                                                                |
| -------------- | --------------------------------------------------- | -------- | ------------------------------------------------------------------------------------------ |
| `code`         | string                                              | ✅       | string representation of Cadence script                                                    |
| `name`         | string                                              | ✅       | name of the file in `scripts` folder to use (sans `.cdc` extension)                        |
| `args`         | [any]                                               | ✅       | an array of arguments to pass to script. Optional if script does not expect any arguments. |
| `transformers` | [[CadenceTransformer](./api.md#cadencetransformer)] | ✅       | an array of operators to modify the code, before submitting it to network                  |

> ⚠️ **Required:** Either `code` or `name` field shall be specified. Method will throw an error if both of them are empty.
> If `name` field provided, framework will source code from file and override value passed via `code` field.

#### Returns

| Type                                                                        | Description   |
| --------------------------------------------------------------------------- | ------------- |
| [ResponseObject](../clients/fcl-js/api.md#responseobject) | Script result |

#### Usage

```javascript
import path from "path"
import {init, emulator, executeScript} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  // Init framework
  init(basePath)
  // Start emulator
  await emulator.start()

  // Define code and arguments we want to pass
  const code = `
    pub fun main(message: String): Int{
      log(message)

      return 42
    }
  `
  const args = ["Hello, from Cadence"]

  const [result, error, logs] = await executeScript({code, args})
  console.log({result}, {error}, {logs})

  // Stop emulator instance
  await emulator.stop()
}

main()
```

### `executeScript(name: string, args: [any])`

This signature provides simplified way of executing a script, since most of the time you will utilize existing
Cadence files.

#### Arguments

| Name   | Type   | Optional | Description                                                                                            |
| ------ | ------ | -------- | ------------------------------------------------------------------------------------------------------ |
| `name` | string |          | name of the file in `scripts` folder to use (sans `.cdc` extension)                                    |
| `args` | [any]  | ✅       | an array of arguments to pass to script. Optional if scripts don't expect any arguments. Default: `[]` |

#### Returns

| Type                                                                        | Description   |
| --------------------------------------------------------------------------- | ------------- |
| [ResponseObject](../clients/fcl-js/api.md#responseobject) | Script result |

#### Usage

```javascript
import path from "path"
import {init, emulator, executeScript} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  // Init framework
  init(basePath)
  // Start emulator
  await emulator.start()

  // Define arguments we want to pass
  const args = ["Hello, from Cadence"]

  // We assume there is a file `scripts/log-message.cdc` under base path
  const [result, error, logs] = await executeScript("log-message", args)
  console.log({result}, {error}, {logs})

  await emulator.stop()
}

main()
```

## Transactions

Another common case is interactions that mutate network state - sending tokens from one account to another, minting new NFT, etc. Framework provides `sendTransaction` method to achieve this. This method have 2 different signatures.

> ⚠️ **Required:** Your project must follow the [required structure](./structure.md) it must be [initialized](./init.md) to use the following functions.

### `sendTransaction(props)`

Send transaction to network.
Provides explicit control over how you pass values.

#### Arguments

`props` object accepts following fields:

| Name           | Type                                                                                                       | Optional | Description                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `code`         | string                                                                                                     | ✅       | string representation of Cadence transaction                                                                                                                     |
| `name`         | string                                                                                                     | ✅       | name of the file in `transaction` folder to use (sans `.cdc` extension)                                                                                          |
| `args`         | [any]                                                                                                      | ✅       | an array of arguments to pass to transaction. Optional if transaction does not expect any arguments.                                                             |
| `signers`      | [[Address](../clients/fcl-js/api.md#address) or [SignerInfo](./api.md#signerinfoobject)] | ✅       | an array of [Address](../clients/fcl-js/api.md#address) or [SignerInfo](./api.md#signerinfoobject) objects representing transaction autorizers |
| `addressMap`   | [AddressMap](./api.md#addressmap)                                                                          | ✅       | name/address map to use as lookup table for addresses in import statements                                                                                       |
| `transformers` | [[CadenceTransformer](./api.md#cadencetransformer)]                                                        | ✅       | an array of operators to modify the code, before submitting it to network                                                                                        |

> ⚠️ **Required:** Either `code` or `name` field shall be specified. Method will throw an error if both of them are empty.
> If `name` field provided, framework will source code from file and override value passed via `code` field.

> 📣 if `signers` field not provided, service account will be used to authorize the transaction.

> 📣 Pass `addressMap` only in cases, when you would want to override deployed contract. Otherwide
> imports can be resolved automatically without explicitly passing them via `addressMap` field

#### Usage

```javascript
import path from "path"
import {
  init,
  emulator,
  sendTransaction,
  getAccountAddress,
} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  // Init framework
  await init(basePath)
  // Start emulator
  await emulator.start()

  // Define code and arguments we want to pass
  const code = `
    transaction(message: String){
      prepare(signer: AuthAccount){
        log(message)
      }
    }
  `
  const args = ["Hello, from Cadence"]
  const Alice = await getAccountAddress("Alice")
  const signers = [Alice]

  const [result, error, logs] = await sendTransaction({code, args, signers})
  console.log({result}, {error}, {logs})

  // Stop emulator instance
  await emulator.stop()
}

main()
```

### `sendTransaction(name, signers, args)`

This signature provides simplified way to send a transaction, since most of the time you will utilize existing
Cadence files.

| Name      | Type                                                                                                             | Optional | Description                                                                                                                                                             |
| --------- | ---------------------------------------------------------------------------------------------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `name`    | string                                                                                                           | ✅       | name of the file in `transaction` folder to use (sans `.cdc` extension)                                                                                                 |
| `args`    | [any]                                                                                                            | ✅       | an array of arguments to pass to transaction. Optional if transaction does not expect any arguments.                                                                    |
| `signers` | [[Address](../clients/fcl-js/api.md#address) or [SignerInfoObject](./api.md#signerinfoobject)] | ✅       | an array of [Address](../clients/fcl-js/api.md#address) or array of [SignerInfoObject](./api.md#signerinfoobject) representing transaction autorizers |

#### Usage

```javascript
import path from "path"
import {
  init,
  emulator,
  sendTransaction,
  shallPass,
} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  // Init framework
  await init(basePath)
  // Start emulator
  await emulator.start()

  // Define arguments we want to pass
  const args = ["Hello, Cadence"]

  const [result, error, logs] = await shallPass(
    sendTransaction("log-message", [], args)
  )
  console.log({result}, {error}, {logs})

  // Stop the emulator instance
  await emulator.stop()
}

main()
```

## Templates

The philosophy behind Flow JS Testing Framework is to be a set of helper methods. They can be used in
opinionated way, envisioned by Flow Team. Or they can work as building blocks, allowing developers to build their own
testing solution as they see fit.

Following methods used inside other framework methods, but we feel encouraged to list them here as well.

### `getTemplate(file, addressMap, byAddress)`

Returns Cadence template as string with addresses replaced using addressMap

| Name         | Type                              | Optional | Description                                                                                               |
| ------------ | --------------------------------- | -------- | --------------------------------------------------------------------------------------------------------- |
| `file`       | string                            |          | relative (to the place from where the script was called) or absolute path to the file containing the code |
| `addressMap` | [AddressMap](./api.md#addressmap) | ✅       | object to use for address mapping of existing deployed contracts. Default: `{}`                           |
| `byAddress`  | boolean                           | ✅       | whether addressMap is `{name:address}` or `{address:address}` type. Default: `false`                      |

#### Returns

| Type   | Description                 |
| ------ | --------------------------- |
| string | content of a specified file |

#### Usage

```javascript
import path from "path"
import {init, getTemplate} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")
  await init(basePath)

  const template = await getTemplate("../cadence/scripts/get-name.cdc")
  console.log({template})
}

main()
```

### `getContractCode(name, addressMap)`

Returns Cadence template from file with `name` in `_basepath_/contracts` folder

#### Arguments

| Name         | Type                              | Optional | Description                                                      |
| ------------ | --------------------------------- | -------- | ---------------------------------------------------------------- |
| `name`       | string                            |          | name of the contract template                                    |
| `addressMap` | [AddressMap](./api.md#addressmap) | ✅       | object to use for address mapping of existing deployed contracts |

#### Returns

| Type   | Description                                  |
| ------ | -------------------------------------------- |
| string | Cadence template code for specified contract |

#### Usage

```javascript
import path from "path"
import {init, emulator, getContractCode} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  await init(basePath)
  await emulator.start()

  // Let's assume we need to import MessageContract
  await deployContractByName({name: "MessageContract"})
  const [MessageContract] = await getContractAddress("MessageContract")
  const addressMap = {MessageContract}

  const contractTemplate = await getContractCode("HelloWorld", {
    MessageContract,
  })
  console.log({contractTemplate})

  await emulator.stop()
}

main()
```

### `getTransactionCode(name, addressMap)`

Returns Cadence template from file with `name` in `_basepath_/transactions` folder

#### Arguments

| Name         | Type                              | Optional | Description                                                      |
| ------------ | --------------------------------- | -------- | ---------------------------------------------------------------- |
| `name`       | string                            |          | name of the transaction template                                 |
| `addressMap` | [AddressMap](./api.md#addressmap) | ✅       | object to use for address mapping of existing deployed contracts |

#### Returns

| Type   | Description                                     |
| ------ | ----------------------------------------------- |
| string | Cadence template code for specified transaction |

#### Usage

```javascript
import path from "path"
import {init, emulator, getTransactionCode} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  await init(basePath)
  await emulator.start()

  // Let's assume we need to import MessageContract
  await deployContractByName({name: "MessageContract"})
  const [MessageContract] = await getContractAddress("MessageContract")
  const addressMap = {MessageContract}

  const txTemplate = await getTransactionCode({
    name: "set-message",
    addressMap,
  })
  console.log({txTemplate})

  await emulator.stop()
}

main()
```

### `getScriptCode(name, addressMap)`

Returns Cadence template from file with `name` in `_basepath_/scripts` folder

#### Arguments

| Name         | Type                              | Optional | Description                                                      |
| ------------ | --------------------------------- | -------- | ---------------------------------------------------------------- |
| `name`       | string                            |          | name of the script template                                      |
| `addressMap` | [AddressMap](./api.md#addressmap) | ✅       | object to use for address mapping of existing deployed contracts |

#### Returns

| Type   | Description                                |
| ------ | ------------------------------------------ |
| string | Cadence template code for specified script |

#### Usage

```javascript
import path from "path"
import {init, emulator, getScriptCode} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  await init(basePath)
  await emulator.start()

  // Let's assume we need to import MessageContract
  await deployContractByName({name: "MessageContract"})
  const [MessageContract] = await getContractAddress("MessageContract")
  const addressMap = {MessageContract}

  const scriptTemplate = await getScriptCode({
    name: "get-message",
    addressMap,
  })

  console.log({scriptTemplate})
  await emulator.stop()
}

main()
```

## Storage Inspection

### getPaths

Retrieves information about the public, private, and storage paths for a given account.

#### Arguments

| Name                | Type      | Description                                                           |
| ------------------- | --------- | --------------------------------------------------------------------- |
| `address`           | `string`  | The address or name of the account to retrieve the paths from.        |
| `useSet` (optional) | `boolean` | Whether to return the paths as a Set or an array. Defaults to `true`. |

#### Returns

An object containing the following properties:

| Name           | Type                             | Description                                                       |
| -------------- | -------------------------------- | ----------------------------------------------------------------- |
| `publicPaths`  | `Array<string>` or `Set<string>` | An array or Set of the public paths for the account, as strings.  |
| `privatePaths` | `Array<string>` or `Set<string>` | An array or Set of the private paths for the account, as strings. |
| `storagePaths` | `Array<string>` or `Set<string>` | An array or Set of the storage paths for the account, as strings. |

> The `useSet` parameter determines whether the paths are returned as an array or Set. If `useSet` is `true`, the paths will be returned as a Set; otherwise, they will be returned as an array.

#### Usage

```js
import path from "path"
import {init, emulator} from "@onflow/flow-js-testing"
import {getAccountAddress, getPaths} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  await init(basePath)
  await emulator.start()

  // Get storage stats
  const Alice = await getAccountAddress("Alice")
  const paths = await getPaths(Alice)
  const {publicPaths, privatePaths, storagePaths} = paths

  // Output result to console
  console.log({Alice, paths})

  await emulator.stop()
}

main()
```

### getPathsWithType

Retrieves public, private, and storage paths for a given account with extra information available on them

#### Arguments

| Name      | Type     | Description                                                    |
| --------- | -------- | -------------------------------------------------------------- |
| `address` | `string` | The address or name of the account to retrieve the paths from. |

#### Returns

An object containing the following properties:

| Name           | Type     | Description                                                                                |
| -------------- | -------- | ------------------------------------------------------------------------------------------ |
| `publicPaths`  | `Object` | An object containing the public paths for the account, as keys and their types as values.  |
| `privatePaths` | `Object` | An object containing the private paths for the account, as keys and their types as values. |
| `storagePaths` | `Object` | An object containing the storage paths for the account, as keys and their types as values. |

> The types of the paths are not strictly defined and may vary depending on the actual types used in the account.

#### Usage

```js
import path from "path"
import {init, emulator} from "@onflow/flow-js-testing"
import {getPathsWithType} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  await init(basePath)
  await emulator.start()

  const {publicPaths} = await getPathsWithType("Alice")
  const refTokenBalance = publicPaths.flowTokenBalance

  if (
    refTokenBalance.restrictionsList.has(
      "A.ee82856bf20e2aa6.FungibleToken.Balance"
    )
  ) {
    console.log("Found specific restriction")
  }

  if (refTokenBalance.haveRestrictions("FungibleToken.Balance")) {
    console.log("Found matching restriction")
  }

  await emulator.stop()
}

main()
```

### getStorageValue

#### Arguments

| Name      | Type     | Description                                                            |
| --------- | -------- | ---------------------------------------------------------------------- |
| `account` | `string` | The address or name of the account to retrieve the storage value from. |
| `path`    | `string` | The path of the storage value to retrieve.                             |

#### Returns

| Type           | Description                                                                 |
| -------------- | --------------------------------------------------------------------------- |
| `Promise<any>` | The value of the storage at the given path, or `null` if no value is found. |

#### Usage

```js
import path from "path"
import {init, emulator} from "@onflow/flow-js-testing"
import {sendTransaction, getStorageValue} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  await init(basePath)
  await emulator.start()

  // Inplant some value into account
  await sendTransaction({
    code: `
        transaction{
          prepare(signer: AuthAccount){
            signer.save(42, to: /storage/answer)
          }
        }
      `,
    signers: [Alice],
  })
  const answer = await getStorageValue("Alice", "answer")
  console.log({answer})

  await emulator.stop()
}

main()
```

### getStorageStats

Retrieves the storage statistics (used and capacity) for a given account.

#### Arguments

| Name                 | Type      | Description                                                                                      |
| -------------------- | --------- | ------------------------------------------------------------------------------------------------ |
| `address`            | `string`  | The address or name of the account to check for storage statistics.                              |
| `convert` (optional) | `boolean` | Whether to convert the `used` and `capacity` values from strings to numbers. Defaults to `true`. |

#### Returns

A Promise that resolves to an object containing the following properties:

| Name       | Type                 | Description                                          |
| ---------- | -------------------- | ---------------------------------------------------- |
| `used`     | `number` or `string` | The amount of storage used by the account, in bytes. |
| `capacity` | `number` or `string` | The total storage capacity of the account, in bytes. |

> If `convert` is `true`, the `used` and `capacity` values will be converted from strings to numbers before being returned.

#### Usage

```js
import path from "path"
import {init, emulator} from "@onflow/flow-js-testing"
import {getAccountAddress, getStorageStats} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  await init(basePath)
  await emulator.start()

  // Get storage stats
  const Alice = await getAccountAddress("Alice")
  const {capacity, used} = await getStorageStats(Alice)

  // Output result to console
  console.log({Alice, capacity, used})

  await emulator.stop()
}

main()
```

## Types

### `AddressMap`

Object to use for address mapping of existing deployed contracts. Key shall be `string` and value shall be [Address](../clients/fcl-js/api.md#address)

#### Example

```javascript
const addressMap = {
  Messanger: "0x01cf0e2f2f715450",
  Logger: "0x179b6b1cb6755e31",
}
```

### `Interaction`

Interaction is a Promise or function returning a promise.

#### Example

```javascript
const ix = async () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(1337)
    })
  }, 500)
}
```

### `CadenceTransformer`

Function, which will get valid Cadence code, modify it and return valid Cadence code

#### Example

This transformer will look for occupancies of specific import statement and replace it with proper address, where it's deployed on Emulator

```javascript
const replaceAddress = async code => {
  const modified = code.replace(
    /import\s+FungibleToken\s+from\s+0xFUNGIBLETOKEN/,
    "import FungibleToken from 0xee82856bf20e2aa6"
  )

  return modified
}
```

### KeyObject

Key objects are used to specify signer keys when [creating accounts](./accounts.md).

| Key                  | Required | Value Type                                        | Description                                                                                                                 |
| -------------------- | -------- | ------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------- |
| `hashAlgorithm`      | No       | [HashAlgorithm](./api.md#hashalgorithm)           | Hashing algorithm to use for generating signatures to be signed by this key (default: `HashAlgorithm.SHA3_256`)             |
| `privateKey`         | Yes      | string                                            | Private key to use to generate the signature                                                                                |
| `signatureAlgorithm` | No       | [SignatureAlgorithm](./api.md#signaturealgorithm) | Signing algorithm used to sign transactions with this key (default: `SignatureAlgorithm.ECDSA_P256`)                        |
| `weight`             | No       | number                                            | Weight of the key - see [Flow Core Concepts](../../build/basics/accounts.md#account-keys) for more information |

### PublicKey

Public keys are stored as `Buffer` objects which have been RLP encoded according to the [Flow spec](../../build/basics/accounts.md).

In order to generate this object using the Flow JS Testing library, use the [`pubFlowKey` method](./api.md#pubflowkeykeyobject) exported by the library.

```javascript
import {pubFlowKey} from "@onflow/flow-js-testing"

const pubKey = await pubFlowKey({
  privateKey: ...,
  hashAlgorithm: ...,
  signatureAlgorithm: ...,
  weight: ...
})
```

### SignatureObject

Signature objects are used to represent a signature for a particular message as well as the account and keyId which signed for this message.

| Key         | Value Type                                                    | Description                                                                                                                                                      |
| ----------- | ------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `addr`      | [Address](../clients/fcl-js/api.md#address) | the address of the account which this signature has been generated for                                                                                           |
| `keyId`     | number                                                        | [Address](../clients/fcl-js/api.md#address) or [SignerInfo](./api.md#signerinfoobject) object representing user to generate this signature for |
| `signature` | string                                                        | a hexidecimal-encoded string representation of the generated signature                                                                                           |

### SignerInfoObject

Signer Info objects are used to specify information about which signer and which key from this signer shall be used to [sign a transaction](./send-transactions.md).

| Key                  | Required | Value Type                                                    | Description                                                                                                                                                                                        |
| -------------------- | -------- | ------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `addr`               | Yes      | [Address](../clients/fcl-js/api.md#address) | The address of the signer's account                                                                                                                                                                |
| `hashAlgorithm`      | No       | [HashAlgorithm](./api.md#hashalgorithm)                       | Hashing algorithm to use for generating the signature (default: `HashAlgorithm.SHA3_256`)                                                                                                          |
| `keyId`              | No       | number                                                        | The index of the desired key to use from the signer's account (default: `0`)                                                                                                                       |
| `privateKey`         | No       | string                                                        | Private key to use to generate the signature (default: service account private key - this is the default PK for all accounts generated by Flow JS Testing Library, see: [accounts](./accounts.md)) |
| `signatureAlgorithm` | No       | [SignatureAlgorithm](./api.md#signaturealgorithm)             | Signing algorithm used to generate the signature (default: `SignatureAlgorithm.ECDSA_P256`)                                                                                                        |

### HashAlgorithm

| Identifier | Value |
| ---------- | ----- |
| SHA2_256   | 1     |
| SHA3_256   | 3     |

Hash algorithms may be provided as either an enum (accessible via the `HashAlgorithm` object exported by Flow JS Testing, i.e. `HashAlgorithm.SHA3_256`) or as a string representation of their enum identifier (i.e. `"SHA3_256"`)

### SignatureAlgorithm

| Identifier      | Value |
| --------------- | ----- |
| ECDSA_P256      | 2     |
| ECDSA_secp256k1 | 3     |

Signing algorithms may be provided as either an enum (accessible via the `SignatureAlgorithm` object exported by Flow JS Testing, i.e. `SignatureAlgorithm.ECDSA_P256`) or as a string representation of their enum identifier (i.e. `"ECDSA_P256"`)

## Utilities

### `isAddress(address)`

Returns true if the given string is a validly formatted account [address](../clients/fcl-js/api.md#address) (both "0x" prefixed and non-prefixed are valid)

#### Arguments

| Name      | Type   | Optional | Description                      |
| --------- | ------ | -------- | -------------------------------- |
| `address` | string |          | string to test against the regex |

#### Returns

| Type    | Description                                                                                                                |
| ------- | -------------------------------------------------------------------------------------------------------------------------- |
| boolean | Returns true if given string is a validly formatted account [address](../clients/fcl-js/api.md#address). |

#### Usage

```javascript
import {isAddress} from "@onflow/flow-js-testing"

const badAddr = "0xqrtyff"
console.log(isAddress(badAddr)) // false

const goodAddrWithPrefix = "0xf8d6e0586b0a20c1"
console.log(isAddress(goodAddrWithPrefix)) // true

const goodAddrSansPrefix = "f8d6e0586b0a20c1"
console.log(isAddress(goodAddrSansPrefix)) // true
```
---
title: Contracts Management
sidebar_label: Contracts
description: How to manage contracts
---

> ⚠️ **Required:** Your project must follow the [required structure](./structure.md) and it must be [initialized](./init.md) to use the following functions.

## `deployContractByName(props)`

Deploys contract code located inside a Cadence file. Returns the transaction result.

#### Arguments

Props object accepts the following fields:

| Name           | Type                                                          | Optional | Description                                                                                                                                     |
| -------------- | ------------------------------------------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| `name`         | string                                                        |          | name of the file in `contracts` folder (with `.cdc` extension) and name of the contract (please note those should be the same)                  |
| `to`           | [Address](../clients/fcl-js/api.md#address) | ✅       | (optional) account address, where contract will be deployed. If this is not specified, framework will create new account with randomized alias. |
| `addressMap`   | [AddressMap](./api.md#addressmap)                       | ✅       | (optional) object to use for address mapping of existing deployed contracts                                                                     |
| `args`         | [Any]                                                         | ✅       | (optional) arguments, which will be passed to contract initializer. (optional) if template does not expect any arguments.                       |
| `update`       | boolean                                                       | ✅       | (optional) whether to update deployed contract. Default: `false`                                                                                |
| `transformers` | [[CadenceTransformer](./api.md#cadencetransformer)]           | ✅       | an array of operators to modify the code, before submitting it to network                                                                       |

#### Returns

| Type                                                                        | Description                          |
| --------------------------------------------------------------------------- | ------------------------------------ |
| [ResponseObject](../clients/fcl-js/api.md#responseobject) | Result of the deploying transaction. |

#### Usage

```javascript
import path from "path";
import { init, emulator, deployContractByName } from "@onflow/flow-js-testing";

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence");

  await init(basePath);
  await emulator.start();

  // We will deploy our contract to the address that corresponds to "Alice" alias
  const to = await getAccountAddress("Alice");

  // We assume there is a file on "../cadence/contracts/Wallet.cdc" path
  const name = "Wallet";

  // Arguments will be processed and type matched in the same order as they are specified
  // inside of a contract template
  const args = [1337, "Hello", { name: "Alice" }];

  const [deploymentResult, err] = await deployContractByName({ to, name });
  console.log({ deploymentResult }, { err });
  }

  await emulator.stop();
};

main();
```

In a bit more rare case you would want to deploy contract code not from existing template file, but rather
from string representation of it. `deployContract` method will help you achieve this.

## `deployContract(props)`

Deploys contract code specified as string. Returns the transaction result.

#### Arguments

Props object accepts the following fields:

| Name           | Type                                                          | Optional | Description                                                                                                                          |
| -------------- | ------------------------------------------------------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| `contractCode` | string                                                        |          | string representation of contract                                                                                                    |
| `name`         | string                                                        |          | name of the contract to be deployed. Should be the same as the name of the contract provided in `contractCode`                       |
| `to`           | [Address](../clients/fcl-js/api.md#address) | ✅       | account address, where contract will be deployed. If this is not specified, framework will create new account with randomized alias. |
| `addressMap`   | [AddressMap](./api.md#addressmap)                       | ✅       | object to use for import resolver. Default: `{}`                                                                                     |
| `args`         | [Any]                                                         | ✅       | arguments, which will be passed to contract initializer. Default: `[]`                                                               |
| `update`       | boolean                                                       | ✅       | whether to update deployed contract. Default: `false`                                                                                |
| `transformers` | [[CadenceTransformer](./api.md#cadencetransformer)]           | ✅       | an array of operators to modify the code, before submitting it to network                                                            |

#### Returns

| Type                                                                        | Description                          |
| --------------------------------------------------------------------------- | ------------------------------------ |
| [ResponseObject](../clients/fcl-js/api.md#responseobject) | Result of the deploying transaction. |

#### Usage

```javascript
import path from "path"
import {
  init,
  emulator,
  getAccountAddress,
  deployContract,
  executeScript,
} from "@onflow/flow-js-testing"
;(async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  await init(basePath)
  await emulator.start()

  // We can specify, which account will hold the contract
  const to = await getAccountAddress("Alice")

  const name = "Wallet"
  const code = `
        pub contract Wallet{
            pub let balance: UInt
            init(balance: UInt){
              self.balance = balance
            }
        }
    `
  const args = [1337]

  await deployContract({to, name, code, args})

  const [balance, err] = await executeScript({
    code: `
      import Wallet from 0x01
      pub fun main(): UInt{
        return Wallet.balance
      }
    `,
  })
  console.log({balance}, {err})

  await emulator.stop()
})()
```

While framework have automatic import resolver for Contracts you might want to know where it's currently deployed.
We provide a method `getContractAddress` for this.

### `getContractAddress(name)`

Returns address of the account where the contract is currently deployed.

#### Arguments

| Name   | Type   | Description          |
| ------ | ------ | -------------------- |
| `name` | string | name of the contract |

#### Returns

| Type                                                          | Description           |
| ------------------------------------------------------------- | --------------------- |
| [Address](../clients/fcl-js/api.md#address) | `0x` prefixed address |

#### Usage

```javascript
import path from "path"
import {init, emulator, deployContractByName, getContractAddress} from "../src"
;(async () => {
  const basePath = path.resolve(__dirname, "./cadence")

  await init(basePath)
  await emulator.start()

  // if we omit "to" it will be deployed to Service Account
  // but let's pretend we don't know where it will be deployed :)
  await deployContractByName({name: "Hello"})

  const contractAddress = await getContractAddress("Hello")
  console.log({contractAddress})

  await emulator.stop()
})()
```

📣 Framework does not support contracts with identical names deployed to different accounts. While you can deploy contract
to a new address, the internal system, which tracks where contracts are deployed, will only store last address.
---
title: Emulator
sidebar_label: Emulator
description: How to start a new instance of emulator
---

Flow Javascript Testing Framework exposes `emulator` singleton allowing you to run and stop emulator instance
programmatically. There are two methods available on it.

## `emulator.start(options)`

Starts emulator on random available port, unless overriden in options. Returns Promise.

#### Arguments

| Name      | Type                                             | Optional | Description                                            |
| --------- | ------------------------------------------------ | -------- | ------------------------------------------------------ |
| `options` | [EmulatorOptions](./emulator.md#emulatoroptions) | ✅       | an object containing options for starting the emulator |

#### EmulatorOptions

| Key            | Type    | Optional | Description                                                                       |
| -------------- | ------- | -------- | --------------------------------------------------------------------------------- |
| `logging`      | boolean | ✅       | whether log messages from emulator shall be added to the output (default: false)  |
| `flags`        | string  | ✅       | custom command-line flags to supply to the emulator (default: "")                 |
| `adminPort`    | number  | ✅       | override the port which the emulator will run the admin server on (default: auto) |
| `restPort`     | number  | ✅       | override the port which the emulator will run the REST server on (default: auto)  |
| `grpcPort`     | number  | ✅       | override the port which the emulator will run the GRPC server on (default: auto)  |
| `debuggerPort` | number  | ✅       | override the port which the emulator will run the debug server on (default: auto) |

#### Returns

| Type                             | Description                                                      |
| -------------------------------- | ---------------------------------------------------------------- |
| [Promise](./emulator.md#Promise) | Promise, which resolves to true if emulator started successfully |

#### Usage

```javascript
import {emulator, init} from "@onflow/flow-js-testing"

describe("test setup", () => {
  // Instantiate emulator and path to Cadence files
  beforeEach(async () => {
    const basePath = path.resolve(__dirname, "../cadence")

    await init(basePath)

    // Start emulator instance on auto-selected available ports
    await emulator.start()
  })
})
```

## `emulator.stop()`

Stops emulator instance. Returns Promise.

#### Arguments

This method does not expect any arguments.

#### Usage

```javascript
import {emulator, init} from "@onflow/flow-js-testing"

describe("test setup", () => {
  // Instantiate emulator and path to Cadence files
  beforeEach(async () => {
    const basePath = path.resolve(__dirname, "../cadence")

    await init(basePath)
    await emulator.start()
  })

  // Stop emulator, so it could be restarted
  afterEach(async () => {
    await emulator.stop()
  })
})
```

## `emulator.setLogging(newState)`

Set logging flag on emulator, allowing to temporally enable/disable logging.

#### Arguments

| Name       | Type    | Description            |
| ---------- | ------- | ---------------------- |
| `newState` | boolean | Enable/disable logging |

#### Usage

```javascript
import {emulator, init} from "@onflow/flow-js-testing"

describe("test setup", () => {
  // Instantiate emulator and path to Cadence files
  beforeEach(async () => {
    const basePath = path.resolve(__dirname, "../cadence")

    await init(basePath)
    await emulator.start()
  })

  // Stop emulator, so it could be restarted
  afterEach(async () => {
    await emulator.stop()
  })

  test("basic test", async () => {
    // Turn on logging from begining
    emulator.setLogging(true)
    // some asserts and interactions

    // Turn off logging for later calls
    emulator.setLogging(false)
    // more asserts and interactions here
  })
})
```
---
title: Additional Examples
sidebar_label: Additional Examples
description: More examples, which cover specific use cases
---

## Metadata

You may want to pass dictionaries as arguments to your Cadence code. The most
common is metadata with `\{String:String\}` type

```javascript
import {executeScript} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  // Init framework
  await init(basePath)
  // Start emulator
  await emulator.start()

  const code = `
    pub fun main(metadata: {String: String}): String{
      return metadata["name"]!
    }  
  `

  // Define arguments we want to pass
  const args = [{name: "Boris", nickname: "The Blade"}]

  // If something goes wrong with script execution, the method will throw an error
  // so we need to catch it and proce
  const [name, err] = await shallResolve(executeScript({code, args}))
  console.log(name, err)

  await emulator.stop()
}

main()
```

If you need to pass an array of dictionaries, it's not that different. Just replace the `args` variable above with
multiple values:

```javascript
const args = [
  // This is array of dictionaries
  [
    {name: "Boris", nickname: "The Blade"},
    {name: "Franky", nickname: "Four-Fingers"},
  ],
]
```

Or maybe you want to pass dictionary with type \{String: [String]\}:

```javascript
const args = [
  {
    names: ["Alice", "Bob", "Charlie"],
  },
]
```

Framework will try to resolve the types to the best of its abilities. If you encounter an error for your use case,
please create an issue here: [https://github.com/onflow/flow-js-testing/issues](https://github.com/onflow/flow-js-testing/issues)
---
title: Execute Scripts
sidebar_label: Execute Scripts
description: How to execute scripts
---

It is often the case that you need to query current state of the network. For example, to check balance of the
account, read public value of the contract or ensure that user has specific resource in their storage.

We abstract this interaction into single method called `executeScript`. Method have 2 different signatures.

> ⚠️ **Required:** Your project must follow the [required structure](./structure.md) it must be [initialized](./init.md) to use the following functions.

## `executeScript(props)`

Provides explicit control over how you pass values.

#### Arguments

`props` object accepts following fields:

| Name           | Type                                                | Optional | Description                                                                                |
| -------------- | --------------------------------------------------- | -------- | ------------------------------------------------------------------------------------------ |
| `code`         | string                                              | ✅       | string representation of Cadence script                                                    |
| `name`         | string                                              | ✅       | name of the file in `scripts` folder to use (sans `.cdc` extension)                        |
| `args`         | [any]                                               | ✅       | an array of arguments to pass to script. Optional if script does not expect any arguments. |
| `transformers` | [[CadenceTransformer](./api.md#cadencetransformer)] | ✅       | an array of operators to modify the code, before submitting it to network                  |

> ⚠️ **Required:** Either `code` or `name` field shall be specified. Method will throw an error if both of them are empty.
> If `name` field provided, framework will source code from file and override value passed via `code` field.

#### Returns

| Type                                                                        | Description   |
| --------------------------------------------------------------------------- | ------------- |
| [ResponseObject](../clients/fcl-js/api.md#responseobject) | Script result |

#### Usage

```javascript
import path from "path"
import {init, emulator, executeScript} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  // Init framework
  init(basePath)
  // Start emulator
  await emulator.start()

  // Define code and arguments we want to pass
  const code = `
    pub fun main(message: String): Int{
      log(message)

      return 42
    }
  `
  const args = ["Hello, from Cadence"]

  const [result, error, logs] = await executeScript({code, args})
  console.log({result}, {error}, {logs})

  // Stop emulator instance
  await emulator.stop()
}

main()
```

## `executeScript(name: string, args: [any])`

This signature provides simplified way of executing a script, since most of the time you will utilize existing
Cadence files.

#### Arguments

| Name   | Type   | Optional | Description                                                                                            |
| ------ | ------ | -------- | ------------------------------------------------------------------------------------------------------ |
| `name` | string |          | name of the file in `scripts` folder to use (sans `.cdc` extension)                                    |
| `args` | [any]  | ✅       | an array of arguments to pass to script. Optional if scripts don't expect any arguments. Default: `[]` |

#### Returns

| Type                                                                        | Description   |
| --------------------------------------------------------------------------- | ------------- |
| [ResponseObject](../clients/fcl-js/api.md#responseobject) | Script result |

#### Usage

```javascript
import path from "path"
import {init, emulator, executeScript} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  // Init framework
  init(basePath)
  // Start emulator
  await emulator.start()

  // Define arguments we want to pass
  const args = ["Hello, from Cadence"]

  // We assume there is a file `scripts/log-message.cdc` under base path
  const [result, error, logs] = await executeScript("log-message", args)
  console.log({result}, {error}, {logs})

  await emulator.stop()
}

main()
```
---
title: FLOW Token Management
sidebar_label: FLOW Token
description: How to mint FLOW Token
---

Some actions on the network will require an account to have a certain amount of FLOW (tokens) - transaction and storage fees, account creation, etc.
Framework provides a method to query FLOW balances with `getFlowBalance` and mint new tokens via `mintFlow`.

## `getFlowBalance(address)`

Returns current FLOW token balance of the specified account.

#### Arguments

| Name      | Type                                                          | Description                     |
| --------- | ------------------------------------------------------------- | ------------------------------- |
| `address` | [Address](../clients/fcl-js/api.md#address) | address of the account to check |

#### Returns

| Type     | Description                                            |
| -------- | ------------------------------------------------------ |
| `string` | UFix64 amount of FLOW tokens stored in account storage |

#### Usage

```javascript
import {
  init,
  emulator,
  getAccountAddress,
  getFlowBalance,
} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  await init(basePath)
  await emulator.start()

  const Alice = await getAccountAddress("Alice")

  const [result, error] = await getFlowBalance(Alice)
  console.log(result, error)

  await emulator.stop()
}

main()
```

## `mintFlow(recipient, amount)`

Sends transaction to mint the specified amount of FLOW and send it to recipient.

> ⚠️ **Required:** Framework shall be initialized with `init` method for this method to work.

#### Arguments

| Name        | Type                                                          | Description                                                |
| ----------- | ------------------------------------------------------------- | ---------------------------------------------------------- |
| `recipient` | [Address](../clients/fcl-js/api.md#address) | address of the account to check                            |
| `amount`    | string                                                        | UFix64 amount of FLOW tokens to mint and send to recipient |

#### Usage

```javascript
import {init, emulator, mintFlow} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  await init(basePath)
  await emulator.start()

  const Alice = await getAccountAddress("Alice")
  const amount = "42.0"
  const [mintResult, error] = await mintFlow(Alice)
  console.log(mintResult, error)

  await emulator.stop()
}

main()
```
---
title: Bootstrap Framework
sidebar_label: Bootstrap Framework
description: How to quickly init testing environment
---

### Init Testing Environment

Bootstrap your testing environment with a single command:

```shell
npx flow-js-testing init
```

When you run this command in the terminal it will initiate npm package in your current directory and create `package.json` file.
Then it will install dependencies. After the installation is finished, the utility will create the required config files for Babel, Jest and Flow CLI.

> ⚠️ **Warning:** This command will overwrite `babel.config.sj`, `jest.config.js` and `flow.json` files in the folder, where
> it would be executed and also could affect your `package.json` file. That's why we advise you to use new empty folder
> to contain your Cadence related tests.

### Generate New Test Suite

Create a test suite file for your project with all necessary imports and setup for describe blocks.
You can start writing your asserts and expectations right away:

```shell
npx flow-js-testing make [name]
```

#### Flags

| Name                  | Description                          |
| --------------------- | ------------------------------------ |
| `-c` or `--clear`     | Exclude comments from test suit code |
| `-b` or `--base-path` | Specify base path to Cadence folder  |

If you do not specify `name` as second argument, the tool will give your file a unique name.
---
title: Flow Javascript Testing
description: A Javascript Framework allowing you to test your Cadence code in a simple way
---

### The Problem

Writing smart contracts can be complex. With the help of the Cadence language server you can catch some simple bugs during development - wrong types, spelling errors, etc. Checking interaction behaviour is harder. It's not uncommon that smart contract and integration testing engineers are two different people and thus this can create additional friction for your project.

### The Solution

Flow Javascript Testing Framework aims to reduce said complexity by providing a set of helpful methods allowing
you easily:

- [Start and stop new emulator instance](./emulator.md)
- [Deploy contracts](./contracts.md)
- [Create new accounts](./accounts.md)
- [Send transactions](./send-transactions.md)
- [Execute scripts](./execute-scripts.md)
- [query balances and mint FLOW for specific account](./flow-token.md)

Framework will handle creating and managing the private keys you need to sign transactions, and try to automatically resolve import statements (provided, that necessary contracts deployed), so you can focus on writing Cadence code.

## Which testing library to choose?

Some examples provided in this documentation are using Jest to highlight the process, but most of the methods in
framework are agnostic of any other testing library - except for the ones using Jest explicitly. So you can use whatever you feel more comfortable with.

## Installation

Follow [these steps](./install.md) to add framework to your project.
---
title: Init Framework
sidebar_label: Init
description: How to init framework
---

For Framework to operate properly you need to initialize it first.
You can do it with provided `init` method.

### init( basePath, options)

Initializes framework variables.

#### Arguments

| Name       | Type   | Optional | Description                                           |
| ---------- | ------ | -------- | ----------------------------------------------------- |
| `basePath` | string |          | path to the folder holding all Cadence template files |
| `options`  | object | ✅       | options object to use during initialization           |

#### Options

| Name   | Type | Optional | Description                     |
| ------ | ---- | -------- | ------------------------------- |
| `pkey` |      | ✅       | private key for service account |

#### Usage

```javascript
import path from "path"
import {init} from "@onflow/flow-js-testing"

describe("test setup", () => {
  beforeEach(async () => {
    const basePath = path.resolve(__dirname, "../cadence")
    await init(basePath)

    // alternatively you can pass specific port
    // await init(basePath, {port: 8085})
  })
})
```
---
title: Install Flow Javascript Testing Framework
description: How to install the Flow command-line interface (CLI)
---

# Installation

It's possible to install Flow Javacript Testing Framework manually and automatically, using generator.

## Automatic Installation (via npx)

Create new folder and move into it:

```shell
mkdir test && cd ./test
```

Install `@onflow/flow-js-testing`

```shell
npm install @onflow/flow-js-testing
```

Generate complete setup via `init` call:

```shell
npx flow-js-testing init
```

Create new test suit via `make` call, specifying the name of the suit:

```shell
npx flow-js-testing make basic-test
```

## Manual Installation

If, for some reason, you would want to do this manually here's what you need to do.

Create new folder and move into it:

```shell
mkdir test && cd ./test
```

Initiate a project in that folder with:

```shell
npm init
```

Then install all necessary packages by running following command:

```shell
npm install @onflow/flow-js-testing jest @babel/core @babel/preset-env babel-jest
```

If your project _is_ JavaScript based, then run the above command from the folder that contains your project's `package.json` file.

### Jest Config

You'll need to configure Jest in order for tests to work properly.
Add `jest.config.json` file next to `package.json` and populate it with:

```json
{
  "testEnvironment": "node",
  "verbose": true,
  "coveragePathIgnorePatterns": ["/node_modules/"],
  "testTimeout": 50000
}
```

### Babel Config

Similarly, create `babel.config.json` then copy and paste the following configuration:

```json
{
  "presets": [
    [
      "@babel/preset-env",
      {
        "targets": {
          "node": "current"
        }
      }
    ]
  ]
}
```
---
title: Jest Helpers
sidebar_label: Jest Helpers
description: Helper methods for Jest
---

In order to simplify the process even further we've created several Jest-based methods, which will help you to catch
thrown errors and ensure your code works as intended.

## `shallPass(ix)`

Ensure transaction did not throw and was sealed.

#### Arguments

| Name | Type                                | Description                                          |
| ---- | ----------------------------------- | ---------------------------------------------------- |
| `ix` | [Interaction](./api.md#interaction) | interaction, either in form of a Promise or function |

#### Returns

| Type                                                                        | Description        |
| --------------------------------------------------------------------------- | ------------------ |
| [ResponseObject](../clients/fcl-js/api.md#responseobject) | Transaction result |

#### Usage

```javascript
import path from "path"
import {
  init,
  emulator,
  shallPass,
  sendTransaction,
  getAccountAddress,
} from "@onflow/flow-js-testing"

// We need to set timeout for a higher number, because some transactions might take up some time
jest.setTimeout(10000)

describe("interactions - sendTransaction", () => {
  // Instantiate emulator and path to Cadence files
  beforeEach(async () => {
    const basePath = path.resolve(__dirname, "./cadence")
    await init(basePath)
    return emulator.start()
  })

  // Stop emulator, so it could be restarted
  afterEach(async () => {
    return emulator.stop()
  })

  test("basic transaction", async () => {
    const code = `
      transaction(message: String){
        prepare(singer: AuthAccount){
          log(message)
        }
      }
    `
    const Alice = await getAccountAddress("Alice")
    const signers = [Alice]
    const args = ["Hello, Cadence"]

    const [txResult, error] = await shallPass(
      sendTransaction({
        code,
        signers,
        args,
      })
    )

    // Transaction result will hold status, events and error message
    console.log(txResult, error)
  })
})
```

## shallRevert(ix, message)

Ensure interaction throws an error. Can test for specific error messages or catch any error message if `message` is not provided.
Returns Promise, which contains result, when resolved.

#### Arguments

| Name                     | Type                                | Description                                                                                                              |
| ------------------------ | ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| `ix`                     | [Interaction](./api.md#interaction) | transaction, either in form of a Promise or function                                                                     |
| `message` **(optional)** | `string` or `RegExp`                | expected error message provided as either a string equality or regular expression to match, matches any error by default |

#### Returns

| Type                                                                        | Description        |
| --------------------------------------------------------------------------- | ------------------ |
| [ResponseObject](../clients/fcl-js/api.md#responseobject) | Transaction result |

#### Usage

```javascript
import path from "path"
import {
  init,
  emulator,
  shallPass,
  sendTransaction,
  getAccountAddress,
} from "js-testing-framework"

// We need to set timeout for a higher number, cause some interactions might need more time
jest.setTimeout(10000)

describe("interactions - sendTransaction", () => {
  // Instantiate emulator and path to Cadence files
  beforeEach(async () => {
    const basePath = path.resolve(__dirname, "./cadence")
    await init(basePath)
    return emulator.start()
  })

  // Stop emulator, so it could be restarted
  afterEach(async () => {
    return emulator.stop()
  })

  test("basic transaction", async () => {
    const code = `
      transaction(message: String){
        prepare(singer: AuthAccount){
          panic("You shall not pass!")
        }
      }
    `
    const Alice = await getAccountAddress("Alice")
    const signers = [Alice]
    const args = ["Hello, Cadence"]

    const [txResult, error] = await shallRevert(
      sendTransaction({
        code,
        signers,
        args,
      })
    )

    // Transaction result will hold status, events and error message
    console.log(txResult, error)
  })
})
```

## shallResolve(ix)

Ensure interaction resolves without throwing errors.

#### Arguments

| Name | Type                                | Description                                          |
| ---- | ----------------------------------- | ---------------------------------------------------- |
| `ix` | [Interaction](./api.md#interaction) | interaction, either in form of a Promise or function |

#### Returns

| Type                                                                        | Description        |
| --------------------------------------------------------------------------- | ------------------ |
| [ResponseObject](../clients/fcl-js/api.md#responseobject) | Transaction result |

#### Usage

```javascript
import path from "path"
import {init, emulator, shallPass, executeScript} from "js-testing-framework"

// We need to set timeout for a higher number, cause some interactions might need more time
jest.setTimeout(10000)

describe("interactions - sendTransaction", () => {
  // Instantiate emulator and path to Cadence files
  beforeEach(async () => {
    const basePath = path.resolve(__dirname, "./cadence")
    await init(basePath)
    return emulator.start()
  })

  // Stop emulator, so it could be restarted
  afterEach(async () => {
    return emulator.stop()
  })

  test("basic script", async () => {
    const code = `
      pub fun main():Int{
        return 42
      }
    `

    const [result, error] = await shallResolve(
      executeScript({
        code,
      })
    )

    expect(result).toBe(42)
    expect(error).toBe(null)
  })
})
```

## shallHavePath(account, path)

Asserts that the given account has the given path enabled.

#### Arguments

| Name      | Type     | Description                                               |
| --------- | -------- | --------------------------------------------------------- |
| `account` | `string` | The address or name of the account to check for the path. |
| `path`    | `string` | The path to check for.                                    |

#### Returns

| Type            | Description                                                                                   |
| --------------- | --------------------------------------------------------------------------------------------- |
| `Promise<void>` | A Promise that resolves when the assertion is complete, or rejects with an error if it fails. |

#### Usage

```javascript
import path from "path"
import {init, emulator, shallPass, executeScript} from "js-testing-framework"

// We need to set timeout for a higher number, cause some interactions might need more time
jest.setTimeout(10000)

describe("interactions - sendTransaction", () => {
  // Instantiate emulator and path to Cadence files
  beforeEach(async () => {
    const basePath = path.resolve(__dirname, "./cadence")
    await init(basePath)
    return emulator.start()
  })

  // Stop emulator, so it could be restarted
  afterEach(async () => {
    return emulator.stop()
  })

  describe("check path with Jest helper", () => {
    test("pass account address", async () => {
      const Alice = await getAccountAddress("Alice")
      await shallHavePath(Alice, "/storage/flowTokenVault")
    })

    test("pass account name", async () => {
      await shallHavePath("Alice", "/storage/flowTokenVault")
    })
  })
})
```

## shallHaveStorageValue(account, params)

Asserts that the given account has the expected storage value at the given path.

#### Arguments

| Name              | Type                                            | Description                                                                                            |
| ----------------- | ----------------------------------------------- | ------------------------------------------------------------------------------------------------------ |
| `account`         | `string`                                        | The address or name of the account to check for the storage value.                                     |
| `params`          | `{pathName: string, key?: string, expect: any}` | An object containing the path name, optional key, and expected value of the storage at the given path. |
| `params.pathName` | `string`                                        | The path of the storage value to retrieve.                                                             |
| `params.key`      | `string` (optional)                             | The key of the value to retrieve from the storage at the given path, if applicable.                    |
| `expect`          | `any`                                           | The expected value of the storage at the given path and key (if applicable).                           |

#### Returns

| Type            | Description                                                                                   |
| --------------- | --------------------------------------------------------------------------------------------- |
| `Promise<void>` | A Promise that resolves when the assertion is complete, or rejects with an error if it fails. |
---
title: Send Transactions
sidebar_label: Send Transactions
description: How to send transactions
---

Another common case is interactions that mutate network state - sending tokens from one account to another, minting new NFT, etc. Framework provides `sendTransaction` method to achieve this. This method have 2 different signatures.

> ⚠️ **Required:** Your project must follow the [required structure](./structure.md) it must be [initialized](./init.md) to use the following functions.

## `sendTransaction(props)`

Send transaction to network.
Provides explicit control over how you pass values.

#### Arguments

`props` object accepts following fields:

| Name           | Type                                                                                                       | Optional | Description                                                                                                                                                      |
| -------------- | ---------------------------------------------------------------------------------------------------------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `code`         | string                                                                                                     | ✅       | string representation of Cadence transaction                                                                                                                     |
| `name`         | string                                                                                                     | ✅       | name of the file in `transaction` folder to use (sans `.cdc` extension)                                                                                          |
| `args`         | [any]                                                                                                      | ✅       | an array of arguments to pass to transaction. Optional if transaction does not expect any arguments.                                                             |
| `signers`      | [[Address](../clients/fcl-js/api.md#address) or [SignerInfo](./api.md#signerinfoobject)] | ✅       | an array of [Address](../clients/fcl-js/api.md#address) or [SignerInfo](./api.md#signerinfoobject) objects representing transaction autorizers |
| `addressMap`   | [AddressMap](./api.md#addressmap)                                                                          | ✅       | name/address map to use as lookup table for addresses in import statements                                                                                       |
| `transformers` | [[CadenceTransformer](./api.md#cadencetransformer)]                                                        | ✅       | an array of operators to modify the code, before submitting it to network                                                                                        |

> ⚠️ **Required:** Either `code` or `name` field shall be specified. Method will throw an error if both of them are empty.
> If `name` field provided, framework will source code from file and override value passed via `code` field.

> 📣 if `signers` field not provided, service account will be used to authorize the transaction.

> 📣 Pass `addressMap` only in cases, when you would want to override deployed contract. Otherwide
> imports can be resolved automatically without explicitly passing them via `addressMap` field

#### Usage

```javascript
import path from "path"
import {
  init,
  emulator,
  sendTransaction,
  getAccountAddress,
} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  // Init framework
  await init(basePath)
  // Start emulator
  await emulator.start()

  // Define code and arguments we want to pass
  const code = `
    transaction(message: String){
      prepare(signer: AuthAccount){
        log(message)
      }
    }
  `
  const args = ["Hello, from Cadence"]
  const Alice = await getAccountAddress("Alice")
  const signers = [Alice]

  const [result, error] = await sendTransaction({code, args, signers})
  console.log({result}, {error})

  // Stop emulator instance
  await emulator.stop()
}

main()
```

## `sendTransaction(name, signers, args)`

This signature provides simplified way to send a transaction, since most of the time you will utilize existing
Cadence files.

| Name      | Type                                                                                                             | Optional | Description                                                                                                                                                             |
| --------- | ---------------------------------------------------------------------------------------------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `name`    | string                                                                                                           | ✅       | name of the file in `transaction` folder to use (sans `.cdc` extension)                                                                                                 |
| `args`    | [any]                                                                                                            | ✅       | an array of arguments to pass to transaction. Optional if transaction does not expect any arguments.                                                                    |
| `signers` | [[Address](../clients/fcl-js/api.md#address) or [SignerInfoObject](./api.md#signerinfoobject)] | ✅       | an array of [Address](../clients/fcl-js/api.md#address) or array of [SignerInfoObject](./api.md#signerinfoobject) representing transaction autorizers |

#### Usage

```javascript
import path from "path"
import {
  init,
  emulator,
  sendTransaction,
  shallPass,
} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  // Init framework
  await init(basePath)
  // Start emulator
  await emulator.start()

  // Define arguments we want to pass
  const args = ["Hello, Cadence"]

  const [result, error, logs] = await shallPass(
    sendTransaction("log-message", [], args)
  )
  console.log({result}, {error}, {logs})

  // Stop the emulator instance
  await emulator.stop()
}

main()
```
---
title: Folder Structure
sidebar_label: Folder Structure
description: How to structure your Cadence files
---

Currently, Framework expects a specific hierarchy of files inside your base directory.
There are no rules that enforce the name of the base directory, but there should be 3 folders inside with names:

- `contracts`
- `transactions`
- `scripts`

Each of those folders shall store corresponding templates types, i.e. `contracts` folder stores contract templates.

You can have nested folders inside them, but templates in each of those root folders would be treated as of certain
type.

## Usage

#### File is in the root of `scripts` folder

For this simple case you just need to specify name of the file

```javascript
// Let's assume your base folder is one level above your test
const basePath = path.resolve("../cadence")
const [result, error] = await executeScript("log-message")
```

#### File is in nested folder

Let's assume template you want to execute is in `scripts/utility/log-message`
In this case you will need to provide a path relative to `scripts` folder (no `/` prefix needed)

```javascript
// Let's assume your base folder is one level above your test
const basePath = path.resolve("../cadence")
const [result, error] = await executeScript("utility/log-message")
```
---
title: Template Code
sidebar_label: Templates
description: How to manage load Cadence template code
---

The Flow JS Testing Framework is essentially a set of helper methods. They can be used in an
opinionated way, envisioned by Flow Team. Or they can work as building blocks, allowing developers to build their own
testing solution as they see fit. Following methods used inside other framework methods, but we feel encouraged to list
them here as well.

## `getTemplate(file, addressMap, byAddress)`

Returns Cadence template as string with addresses replaced using addressMap

| Name         | Type                              | Optional | Description                                                                                               |
| ------------ | --------------------------------- | -------- | --------------------------------------------------------------------------------------------------------- |
| `file`       | string                            |          | relative (to the place from where the script was called) or absolute path to the file containing the code |
| `addressMap` | [AddressMap](./api.md#addressmap) | ✅       | object to use for address mapping of existing deployed contracts. Default: `{}`                           |
| `byAddress`  | boolean                           | ✅       | whether addressMap is `{name:address}` or `{address:address}` type. Default: `false`                      |

#### Returns

| Type   | Description                 |
| ------ | --------------------------- |
| string | content of a specified file |

#### Usage

```javascript
import path from "path"
import {init, getTemplate} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")
  init(basePath)

  const template = await getTemplate("../cadence/scripts/get-name.cdc")
  console.log({template})
}

main()
```

## `getContractCode(name, addressMap)`

Returns Cadence template from file with `name` in `_basepath_/contracts` folder

#### Arguments

| Name         | Type                              | Optional | Description                                                      |
| ------------ | --------------------------------- | -------- | ---------------------------------------------------------------- |
| `name`       | string                            |          | name of the contract template                                    |
| `addressMap` | [AddressMap](./api.md#addressmap) | ✅       | object to use for address mapping of existing deployed contracts |

#### Returns

| Type   | Description                                  |
| ------ | -------------------------------------------- |
| string | Cadence template code for specified contract |

#### Usage

```javascript
import path from "path"
import {init, emulator, getContractCode} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  await init(basePath)
  await emulator.start()

  // Let's assume we need to import MessageContract
  await deployContractByName({name: "MessageContract"})
  const MessageContract = await getContractAddress("MessageContract")
  const addressMap = {MessageContract}

  const contractTemplate = await getContractCode("HelloWorld", {
    MessageContract,
  })
  console.log({contractTemplate})

  await emulator.stop()
}

main()
```

## `getTransactionCode(name, addressMap)`

Returns Cadence template from file with `name` in `_basepath_/transactions` folder

#### Arguments

| Name         | Type                              | Optional | Description                                                      |
| ------------ | --------------------------------- | -------- | ---------------------------------------------------------------- |
| `name`       | string                            |          | name of the transaction template                                 |
| `addressMap` | [AddressMap](./api.md#addressmap) | ✅       | object to use for address mapping of existing deployed contracts |

#### Returns

| Type   | Description                                     |
| ------ | ----------------------------------------------- |
| string | Cadence template code for specified transaction |

#### Usage

```javascript
import path from "path"
import {init, emulator, getTransactionCode} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  await init(basePath)
  await emulator.start()

  // Let's assume we need to import MessageContract
  await deployContractByName({name: "MessageContract"})
  const MessageContract = await getContractAddress("MessageContract")
  const addressMap = {MessageContract}

  const txTemplate = await getTransactionCode({
    name: "set-message",
    addressMap,
  })
  console.log({txTemplate})

  await emulator.stop()
}

main()
```

## `getScriptCode(name, addressMap)`

Returns Cadence template from file with `name` in `_basepath_/scripts` folder

#### Arguments

| Name         | Type                              | Optional | Description                                                      |
| ------------ | --------------------------------- | -------- | ---------------------------------------------------------------- |
| `name`       | string                            |          | name of the script template                                      |
| `addressMap` | [AddressMap](./api.md#addressmap) | ✅       | object to use for address mapping of existing deployed contracts |

#### Returns

| Type   | Description                                |
| ------ | ------------------------------------------ |
| string | Cadence template code for specified script |

#### Usage

```javascript
import path from "path"
import {init, emulator, getScriptCode} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")

  await init(basePath)
  await emulator.start()

  // Let's assume we need to import MessageContract
  await deployContractByName({name: "MessageContract"})
  const MessageContract = await getContractAddress("MessageContract")
  const addressMap = {MessageContract}

  const scriptTemplate = await getScriptCode({
    name: "get-message",
    addressMap,
  })

  console.log({scriptTemplate})
  await emulator.stop()
}

main()
```

## Examples

If you don't have any contract dependencies, you can use those methods without specifying address map as second parameter.

```javascript
import path from "path"
import {
  init,
  getContractCode,
  getTransactionCode,
  getScriptCode,
} from "@onflow/flow-js-testing"

const main = async () => {
  const basePath = path.resolve(__dirname, "../cadence")
  await init(basePath)

  const contractWallet = await getContractCode({name: "Wallet"})
  const txGetCapability = await getTransactionCode({name: "get-capability"})
  const scriptGetBalance = await getScriptCode({name: "get-balance"})

  console.log({contractWallet, txGetCapability, scriptGetBalance})
}
main()
```
### `AddressMap`

Object to use for address mapping of existing deployed contracts. Key shall be `string` and value shall be [Address](../clients/fcl-js/api.md#address)

#### Example

```javascript
const addressMap = {
  Messanger: "0x01cf0e2f2f715450",
  Logger: "0x179b6b1cb6755e31",
}
```

### `Interaction`

Interaction is a Promise or function returning a promise.

#### Example

```javascript
const ix = async () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(1337)
    })
  }, 500)
}
```
---
sidebar_position: 1
title: Tools
description: Essential tools for the Flow blockchain ecosystem
---

import DocCardList from '@theme/DocCardList';
import { useDocsSidebar, isSamePath } from '@docusaurus/theme-common/internal';
import { useLocation } from '@docusaurus/router';

<DocCardList items={[
  ...useDocsSidebar().items.filter(item => !isSamePath(item.href, useLocation().pathname)),
  {
    type: 'link',
    label: 'Flowser',
    href: 'https://flowser.dev/',
    description: 'Flowser combines all the tools for local development and gives you a clear UI to inspect the local Flow network.',
    customProps: {
      icon: 'https://flowser.dev/icon.png',
      author: {
        name: 'Flowser',
        profileImage:
          'https://flowser.dev/icon.png',
      },
      twitterLink: 'https://twitter.com/onflowser',
      githubLink: 'https://github.com/onflowser/flowser'
    }
  },
  {
    type: 'link',
    label: 'Overflow',
    href: 'https://github.com/bjartek/overflow',
    description: 'Overflow is a Go-based DSL for testing and running interactive stories',
    customProps: {
      icon: '',
      author: {
        name: 'bjartek',
        profileImage:
          'https://avatars.githubusercontent.com/u/10621?v=4',
      },
      discordLink: 'https://discord.gg/t6GEtHnWFh',
      githubLink: 'https://github.com/bjartek/overflow'
    }
  },
]}/>
---
title: NFT Catalog
sidebar_label: NFT Catalog
description: The NFT Catalog is an on chain registry listing NFT collections that exists on Flow which adhere to the NFT metadata standard.
---

The NFT Catalog is an on chain registry listing NFT collections that exists on Flow which adhere to the NFT metadata standard. This empowers dApp developers to easily build on top of and discover interoperable NFT collections on Flow.

## Live Site

Checkout the catalog [site](https://www.flow-nft-catalog.com/) to submit your NFT collection both on testnet and mainnet.

## Contract Addresses

`NFTCatalog.cdc`: This contract contains the NFT Catalog

| Network | Address            |
| ------- | ------------------ |
| Mainnet | 0x49a7cda3a1eecc29 |
| Testnet | 0x324c34e1c517e4db |

`NFTRetrieval.cdc`: This contract contains helper functions to make it easier to discover NFTs within accounts and from the catalog

| Network | Address            |
| ------- | ------------------ |
| Mainnet | 0x49a7cda3a1eecc29 |
| Testnet | 0x324c34e1c517e4db |

## Submitting a Collection to the NFT Catalog

1. Visit [here](https://www.flow-nft-catalog.com/v)
2. Enter the address containing the NFT contract which contains the collection and select the contract.

 <img width="1509" alt="Screen Shot 2023-02-08 at 9 40 01 AM" src="https://user-images.githubusercontent.com/5430668/217561873-54beb50e-0ea2-46fb-b9f8-8dbe758ee12f.png" />

3. Enter the storage path where the NFTs are stored and enter an address that holds a sample NFT or log in if you have access to an account that owns the NFT.
   <img width="1508" alt="Screen Shot 2023-02-08 at 9 42 54 AM" src="https://user-images.githubusercontent.com/5430668/217562366-e6cbf3cb-38b8-45cb-943e-e20185565743.png" />

4. The application will verify that your NFT collection implements the required Metadata views.

    1. The required metadata views include…
        1. NFT Display
            1. How to display an individual NFT part of the collection
        2. External URL
            1. A website for the NFT collection
        3. Collection Data
            1. Information needed to store and retrieve an NFT
        4. Collection Display
            1. How to display information about the NFT collection the NFT belongs to
        5. Royalties
            1. Any royalties that should be accounted for during marketplace transactions
    2. You can find sample implementations of all these views in this example NFT [contract](https://github.com/onflow/flow-nft/blob/master/contracts/ExampleNFT.cdc).
    3. If you are not implementing a view, the app will communicate this and you can update your NFT contract and try resubmitting.

     <img width="738" alt="Screen Shot 2023-02-08 at 9 46 56 AM" src="https://user-images.githubusercontent.com/5430668/217563435-86863297-183b-4345-9615-61f9d4212fe9.png" />

5. Submit proposal transaction to the NFT catalog by entering a unique url safe identifier for the collection and a message including any additional context (like contact information).

 <img width="1503" alt="Screen Shot 2023-02-08 at 9 48 45 AM" src="https://user-images.githubusercontent.com/5430668/217563785-65065f51-37bc-49c7-8b3e-ba5d1dda3b24.png" />

6. Once submitted you can view all proposals [here](https://www.flow-nft-catalog.com/proposals/mainnet) to track the review of your NFT.

If you would like to make a proposal manually, you may submit the following transaction with all parameters filled in: [https://github.com/dapperlabs/nft-catalog/blob/main/cadence/transactions/propose_nft_to_catalog.cdc](https://github.com/dapperlabs/nft-catalog/blob/main/cadence/transactions/propose_nft_to_catalog.cdc)

Proposals should be reviewed and approved within a few days. Reasons for a proposal being rejected may include:

-   Providing duplicate path or name information of an existing collection on the catalog
-   Providing a not url safe or inaccurate name as the identifier

## Using the Catalog (For marketplaces and other NFT applications)

All of the below examples use the catalog in mainnet, you may replace the imports to the testnet address when using the testnet network.

**Example 1 - Retrieve all NFT collections on the catalog**

```swift
import NFTCatalog from 0x49a7cda3a1eecc29

/*
	The catalog is returned as a `String: NFTCatalogMetadata`
	The key string is intended to be a unique identifier for a specific collection.
	The NFTCatalogMetadata contains collection-level views corresponding to each
	collection identifier.
*/
pub fun main(): {String : NFTCatalog.NFTCatalogMetadata} {
    return NFTCatalog.getCatalog()

}
```

**Example 2 - Retrieve all collection names in the catalog**

```swift
import NFTCatalog from 0x49a7cda3a1eecc29

pub fun main(): [String] {
		let catalog: {String : NFTCatalog.NFTCatalogMetadata} = NFTCatalog.getCatalog()
		let catalogNames: [String] = []
		for collectionIdentifier in catalog.keys {
			catalogNames.append(catalog[collectionIdentifier]!.collectionDisplay.name)
    }
    return catalogNames
}
```

**Example 3 - Retrieve NFT collections and counts owned by an account**

```swift
import MetadataViews from 0x1d7e57aa55817448
import NFTCatalog from 0x49a7cda3a1eecc29
import NFTRetrieval from 0x49a7cda3a1eecc29

pub fun main(ownerAddress: Address) : {String : Number} {
    let catalog = NFTCatalog.getCatalog()
    let account = getAuthAccount(ownerAddress)
    let items : {String : Number} = {}

    for key in catalog.keys {
        let value = catalog[key]!
        let tempPathStr = "catalog".concat(key)
        let tempPublicPath = PublicPath(identifier: tempPathStr)!
        account.link<&{MetadataViews.ResolverCollection}>(
            tempPublicPath,
            target: value.collectionData.storagePath
        )
        let collectionCap = account.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)
        if !collectionCap.check() {
            continue
        }
        let count = NFTRetrieval.getNFTCountFromCap(collectionIdentifier : key, collectionCap : collectionCap)
        if count != 0 {
            items[key] = count
        }
    }

    return items
}
```

`Sample Response...`

```text
{
    "schmoes_prelaunch_token": 1
}
```

**Example 4 - Retrieve all NFTs including metadata owned by an account**

```swift
import MetadataViews from 0x1d7e57aa55817448
import NFTCatalog from 0x49a7cda3a1eecc29
import NFTRetrieval from 0x49a7cda3a1eecc29

pub struct NFT {
    pub let id : UInt64
    pub let name : String
    pub let description : String
    pub let thumbnail : String
    pub let externalURL : String
    pub let storagePath : StoragePath
    pub let publicPath : PublicPath
    pub let privatePath: PrivatePath
    pub let publicLinkedType: Type
    pub let privateLinkedType: Type
    pub let collectionName : String
    pub let collectionDescription: String
    pub let collectionSquareImage : String
    pub let collectionBannerImage : String
    pub let royalties: [MetadataViews.Royalty]

    init(
            id: UInt64,
            name : String,
            description : String,
            thumbnail : String,
            externalURL : String,
            storagePath : StoragePath,
            publicPath : PublicPath,
            privatePath : PrivatePath,
            publicLinkedType : Type,
            privateLinkedType : Type,
						collectionIdentifier: String,
            collectionName : String,
            collectionDescription : String,
            collectionSquareImage : String,
            collectionBannerImage : String,
            royalties : [MetadataViews.Royalty]
    ) {
        self.id = id
        self.name = name
        self.description = description
        self.thumbnail = thumbnail
        self.externalURL = externalURL
        self.storagePath = storagePath
        self.publicPath = publicPath
        self.privatePath = privatePath
        self.publicLinkedType = publicLinkedType
        self.privateLinkedType = privateLinkedType
				self.collectionIdentifier = collectionIdentifier
        self.collectionName = collectionName
        self.collectionDescription = collectionDescription
        self.collectionSquareImage = collectionSquareImage
        self.collectionBannerImage = collectionBannerImage
        self.royalties = royalties
    }
}

pub fun main(ownerAddress: Address) : { String : [NFT] } {
    let catalog = NFTCatalog.getCatalog()
    let account = getAuthAccount(ownerAddress)
    let items : [NFTRetrieval.BaseNFTViewsV1] = []

    let data : {String : [NFT] } = {}

    for key in catalog.keys {
        let value = catalog[key]!
        let tempPathStr = "catalog".concat(key)
        let tempPublicPath = PublicPath(identifier: tempPathStr)!
        account.link<&{MetadataViews.ResolverCollection}>(
            tempPublicPath,
            target: value.collectionData.storagePath
        )
        let collectionCap = account.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)
        if !collectionCap.check() {
            continue
        }
        let views = NFTRetrieval.getNFTViewsFromCap(collectionIdentifier : key, collectionCap : collectionCap)

        let items : [NFT] = []
        for view in views {
            let displayView = view.display
            let externalURLView = view.externalURL
            let collectionDataView = view.collectionData
            let collectionDisplayView = view.collectionDisplay
            let royaltyView = view.royalties
            if (displayView == nil || externalURLView == nil || collectionDataView == nil || collectionDisplayView == nil || royaltyView == nil) {
                // This NFT does not have the proper views implemented. Skipping....
                continue
            }

            items.append(
                NFT(
                    id: view.id,
                    name : displayView!.name,
                    description : displayView!.description,
                    thumbnail : displayView!.thumbnail.uri(),
                    externalURL : externalURLView!.url,
                    storagePath : collectionDataView!.storagePath,
                    publicPath : collectionDataView!.publicPath,
                    privatePath : collectionDataView!.providerPath,
                    publicLinkedType : collectionDataView!.publicLinkedType,
                    privateLinkedType : collectionDataView!.providerLinkedType,
										collectionIdentifier: key,
                    collectionName : collectionDisplayView!.name,
                    collectionDescription : collectionDisplayView!.description,
                    collectionSquareImage : collectionDisplayView!.squareImage.file.uri(),
                    collectionBannerImage : collectionDisplayView!.bannerImage.file.uri(),
                    royalties : royaltyView!.getRoyalties()
                )
            )
        }
        data[key] = items
    }
    return data
}
```

`Sample Response...`

```text
{
    "FlovatarComponent": [],
    "schmoes_prelaunch_token": [
        s.aa16be98aac20e8073f923261531cbbdfae1464f570f5be796b57cdc97656248.NFT(
            id: 1006,
            name: "Schmoes Pre Launch Token #1006",
            description: "",
            thumbnail: "https://gateway.pinata.cloud/ipfs/QmXQ1iBke5wjcjYG22ACVXsCvtMJKEkwFiMf96UChP8uJq",
            externalURL: "https://schmoes.io",
            storagePath: /storage/SchmoesPreLaunchTokenCollection,
            publicPath: /public/SchmoesPreLaunchTokenCollection,
            privatePath: /private/SchmoesPreLaunchTokenCollection,
            publicLinkedType: Type<&A.6c4fe48768523577.SchmoesPreLaunchToken.Collection{A.1d7e57aa55817448.NonFungibleToken.CollectionPublic,A.  1d7e57aa55817448.NonFungibleToken.Receiver,A.1d7e57aa55817448.MetadataViews.ResolverCollection}>(),
            privateLinkedType: Type<&A.6c4fe48768523577.SchmoesPreLaunchToken.Collection{A.1d7e57aa55817448.NonFungibleToken.CollectionPublic,A.1d7e57aa55817448.NonFungibleToken.Provider,A.1d7e57aa55817448.MetadataViews.ResolverCollection}>(),
            collectionName: "Schmoes Pre Launch Token",
            collectionDescription: "",
            collectionSquareImage: "https://gateway.pinata.cloud/ipfs/QmXQ1iBke5wjcjYG22ACVXsCvtMJKEkwFiMf96UChP8uJq",
            collectionBannerImage: "https://gateway.pinata.cloud/ipfs/QmXQ1iBke5wjcjYG22ACVXsCvtMJKEkwFiMf96UChP8uJq",
            royalties: []
        )
    ],
    "Flovatar": []
}
```

**Example 5 - Retrieve all NFTs including metadata owned by an account for large wallets**

For Wallets that have a lot of NFTs you may run into memory issues. The common pattern to get around this for now is to retrieve just the ID's in a wallet by calling the following script

```swift
import MetadataViews from 0x1d7e57aa55817448
import NFTCatalog from 0x49a7cda3a1eecc29
import NFTRetrieval from 0x49a7cda3a1eecc29

pub fun main(ownerAddress: Address) : {String : [UInt64]} {
    let catalog = NFTCatalog.getCatalog()
    let account = getAuthAccount(ownerAddress)

    let items : {String : [UInt64]} = {}

    for key in catalog.keys {
        let value = catalog[key]!
        let tempPathStr = "catalogIDs".concat(key)
        let tempPublicPath = PublicPath(identifier: tempPathStr)!
        account.link<&{MetadataViews.ResolverCollection}>(
            tempPublicPath,
            target: value.collectionData.storagePath
        )

        let collectionCap = account.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)
        if !collectionCap.check() {
            continue
        }

        let ids = NFTRetrieval.getNFTIDsFromCap(collectionIdentifier : key, collectionCap : collectionCap)

        if ids.length > 0 {
            items[key] = ids
        }
    }
    return items

}
```

and then use the ids to retrieve the full metadata for only those ids by calling the following script and passing in a map of collectlionIdentifer -> [ids]

```swift
import MetadataViews from 0x1d7e57aa55817448
import NFTCatalog from 0x49a7cda3a1eecc29
import NFTRetrieval from 0x49a7cda3a1eecc29

pub struct NFT {
    pub let id : UInt64
    pub let name : String
    pub let description : String
    pub let thumbnail : String
    pub let externalURL : String
    pub let storagePath : StoragePath
    pub let publicPath : PublicPath
    pub let privatePath: PrivatePath
    pub let publicLinkedType: Type
    pub let privateLinkedType: Type
    pub let collectionName : String
    pub let collectionDescription: String
    pub let collectionSquareImage : String
    pub let collectionBannerImage : String
    pub let royalties: [MetadataViews.Royalty]

    init(
            id: UInt64,
            name : String,
            description : String,
            thumbnail : String,
            externalURL : String,
            storagePath : StoragePath,
            publicPath : PublicPath,
            privatePath : PrivatePath,
            publicLinkedType : Type,
            privateLinkedType : Type,
            collectionName : String,
            collectionDescription : String,
            collectionSquareImage : String,
            collectionBannerImage : String,
            royalties : [MetadataViews.Royalty]
    ) {
        self.id = id
        self.name = name
        self.description = description
        self.thumbnail = thumbnail
        self.externalURL = externalURL
        self.storagePath = storagePath
        self.publicPath = publicPath
        self.privatePath = privatePath
        self.publicLinkedType = publicLinkedType
        self.privateLinkedType = privateLinkedType
        self.collectionName = collectionName
        self.collectionDescription = collectionDescription
        self.collectionSquareImage = collectionSquareImage
        self.collectionBannerImage = collectionBannerImage
        self.royalties = royalties
    }
}

pub fun main(ownerAddress: Address, collections: {String : [UInt64]}) : {String : [NFT] } {
    let data : {String : [NFT] } = {}

    let catalog = NFTCatalog.getCatalog()
    let account = getAuthAccount(ownerAddress)
    for collectionIdentifier in collections.keys {
        if catalog.containsKey(collectionIdentifier) {
            let value = catalog[collectionIdentifier]!
            let tempPathStr = "catalog".concat(collectionIdentifier)
            let tempPublicPath = PublicPath(identifier: tempPathStr)!
            account.link<&{MetadataViews.ResolverCollection}>(
                tempPublicPath,
                target: value.collectionData.storagePath
            )

            let collectionCap = account.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)

            if !collectionCap.check() {
                return data
            }

            let views = NFTRetrieval.getNFTViewsFromIDs(collectionIdentifier : collectionIdentifier, ids: collections[collectionIdentifier]!, collectionCap : collectionCap)

            let items : [NFT] = []

            for view in views {
                    let displayView = view.display
                    let externalURLView = view.externalURL
                    let collectionDataView = view.collectionData
                    let collectionDisplayView = view.collectionDisplay
                    let royaltyView = view.royalties
                    if (displayView == nil || externalURLView == nil || collectionDataView == nil || collectionDisplayView == nil || royaltyView == nil) {
                        // Bad NFT. Skipping....
                        continue
                    }

                    items.append(
                        NFT(
                            id: view.id,
                            name : displayView!.name,
                            description : displayView!.description,
                            thumbnail : displayView!.thumbnail.uri(),
                            externalURL : externalURLView!.url,
                            storagePath : collectionDataView!.storagePath,
                            publicPath : collectionDataView!.publicPath,
                            privatePath : collectionDataView!.providerPath,
                            publicLinkedType : collectionDataView!.publicLinkedType,
                            privateLinkedType : collectionDataView!.providerLinkedType,
                            collectionName : collectionDisplayView!.name,
                            collectionDescription : collectionDisplayView!.description,
                            collectionSquareImage : collectionDisplayView!.squareImage.file.uri(),
                            collectionBannerImage : collectionDisplayView!.bannerImage.file.uri(),
                            royalties : royaltyView!.getRoyalties()
                        )
                    )
                }

                data[collectionIdentifier] = items
        }
    }


    return data
}
```

**Example 6 - Retrieve all MetadataViews for NFTs in a wallet**

If you're looking for some MetadataViews that aren't in the [core view list](https://github.com/onflow/flow-nft/blob/master/contracts/MetadataViews.cdc#L36) you can leverage this script to grab all the views each NFT supports. Note: You lose some typing here but get more data.

```swift
import MetadataViews from 0x1d7e57aa55817448
import NFTCatalog from 0x49a7cda3a1eecc29
import NFTRetrieval from 0x49a7cda3a1eecc29

pub struct NFTCollectionData {
    pub let storagePath : StoragePath
    pub let publicPath : PublicPath
    pub let privatePath: PrivatePath
    pub let publicLinkedType: Type
    pub let privateLinkedType: Type

    init(
            storagePath : StoragePath,
            publicPath : PublicPath,
            privatePath : PrivatePath,
            publicLinkedType : Type,
            privateLinkedType : Type,
    ) {
        self.storagePath = storagePath
        self.publicPath = publicPath
        self.privatePath = privatePath
        self.publicLinkedType = publicLinkedType
        self.privateLinkedType = privateLinkedType
    }
}

pub fun main(ownerAddress: Address) : { String : {String : AnyStruct} }  {
    let catalog = NFTCatalog.getCatalog()
    let account = getAuthAccount(ownerAddress)
    let items : [MetadataViews.NFTView] = []

    let data : { String : {String : AnyStruct} } = {}

    for key in catalog.keys {
        let value = catalog[key]!
        let tempPathStr = "catalog".concat(key)
        let tempPublicPath = PublicPath(identifier: tempPathStr)!
        account.link<&{MetadataViews.ResolverCollection}>(
            tempPublicPath,
            target: value.collectionData.storagePath
        )
        let collectionCap = account.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempPublicPath)
        if !collectionCap.check() {
            continue
        }

        var views = NFTRetrieval.getAllMetadataViewsFromCap(collectionIdentifier : key, collectionCap : collectionCap)

        if views.keys.length == 0 {
            continue
        }

        // Cadence doesn't support function return types, lets manually get rid of it
        let nftCollectionDisplayView = views[Type<MetadataViews.NFTCollectionData>().identifier] as! MetadataViews.NFTCollectionData?
        let collectionDataView = NFTCollectionData(
                    storagePath : nftCollectionDisplayView!.storagePath,
                    publicPath : nftCollectionDisplayView!.publicPath,
                    privatePath : nftCollectionDisplayView!.providerPath,
                    publicLinkedType : nftCollectionDisplayView!.publicLinkedType,
                    privateLinkedType : nftCollectionDisplayView!.providerLinkedType,
        )
        views.insert(key: Type<MetadataViews.NFTCollectionData>().identifier, collectionDataView)

        data[key] = views
    }

    return data
}
```

**Example 7 - Setup a user’s account to receive a specific collection**

1. Run the following script to retrieve some collection-level information for an NFT collection identifier from the catalog

```swift
import MetadataViews from 0x1d7e57aa55817448
import NFTCatalog from 0x49a7cda3a1eecc29
import NFTRetrieval from 0x49a7cda3a1eecc29

pub struct NFTCollection {
    pub let storagePath : StoragePath
    pub let publicPath : PublicPath
    pub let privatePath: PrivatePath
    pub let publicLinkedType: Type
    pub let privateLinkedType: Type
    pub let collectionName : String
    pub let collectionDescription: String
    pub let collectionSquareImage : String
    pub let collectionBannerImage : String

    init(
            storagePath : StoragePath,
            publicPath : PublicPath,
            privatePath : PrivatePath,
            publicLinkedType : Type,
            privateLinkedType : Type,
            collectionName : String,
            collectionDescription : String,
            collectionSquareImage : String,
            collectionBannerImage : String
    ) {
        self.storagePath = storagePath
        self.publicPath = publicPath
        self.privatePath = privatePath
        self.publicLinkedType = publicLinkedType
        self.privateLinkedType = privateLinkedType
        self.collectionName = collectionName
        self.collectionDescription = collectionDescription
        self.collectionSquareImage = collectionSquareImage
        self.collectionBannerImage = collectionBannerImage
    }
}

pub fun main(collectionIdentifier : String) : NFT? {
        let catalog = NFTCatalog.getCatalog()

        assert(catalog.containsKey(collectionIdentifier), message: "Invalid Collection")

              return NFTCollection(
                  storagePath : collectionDataView!.storagePath,
                  publicPath : collectionDataView!.publicPath,
                  privatePath : collectionDataView!.providerPath,
                  publicLinkedType : collectionDataView!.publicLinkedType,
                  privateLinkedType : collectionDataView!.providerLinkedType,
                  collectionName : collectionDisplayView!.name,
                  collectionDescription : collectionDisplayView!.description,
                  collectionSquareImage : collectionDisplayView!.squareImage.file.uri(),
                  collectionBannerImage : collectionDisplayView!.bannerImage.file.uri()
              )
          }

        panic("Invalid Token ID")
}
```

2. This script result can then be used to form a transaction by inserting the relevant variables from above into a transaction template like the following:

```swift
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
{ADDITIONAL_IMPORTS}

transaction {

    prepare(signer: AuthAccount) {
        // Create a new empty collection
        let collection <- {CONTRACT_NAME}.createEmptyCollection()

        // save it to the account
        signer.save(<-collection, to: {STORAGE_PATH})

        // create a public capability for the collection
        signer.link<&{PUBLIC_LINKED_TYPE}>(
            {PUBLIC_PATH},
            target: {STORAGE_PATH}
        )

				// create a private capability for the collection
        signer.link<&{PRIVATE_LINKED_TYPE}>(
            {PRIVATE_PATH},
            target: {STORAGE_PATH}
        )
    }
}
```

## Developer Usage

### 1. [Install the Flow CLI](https://github.com/onflow/flow-cli)

### 2. [Install Node](https://nodejs.org/en/)

### 3. Clone the project

```sh
git clone --depth=1 https://github.com/onflow/nft-catalog.git
```

### 4. Install packages

-   Run `npm install` in the root of the project

### 5. Run Test Suite

-   Run `npm test` in the root of the project

## Cadence Generation

Using the NFT Catalog, you can generate common scripts and transactions to be run against the Flow Blockchain to support your application.

### Generate from Javascript

#### Installation

```
npm install @onflow/fcl
npm install flow-catalog
```

or

```
yarn add @onflow/fcl
yarn add flow-catalog
```

#### Usage

_1. Retrieve a list of transactions available for code generation:_
NOTE: In order to properly bootstrap the method, you will need to run and `await` on the `getAddressMaps()` method, passing it into all of the methods as shown below.

```
import { getAddressMaps, scripts } from "flow-catalog";
import * as fcl from "@onflow/fcl"

const main = async () => {
    const addressMap = await getAddressMaps();
    console.log(await scripts.getSupportedGeneratedTransactions(addressMap));
};

main();
```

_2. Provide a Catalog collection identifier to generate code_

```
const getTemplatedTransactionCode = async function() {
  const catalogAddressMap = await getAddressMaps()
  const result = await cadence.scripts.genTx({

    /*
        'CollectionInitialization' is one of the available transactions from step 1.
        'Flunks' is the collection identifier in this case
        'Flow' is a fungible token identifier (if applicable to the transaction being used)
    */

    args: ['CollectionInitialization', 'Flunks', 'flow'],
    addressMap: catalogAddressMap
  })
  return result
}
```

_3. Use the generated code in a transaction_

```
const txId = await fcl.mutate({
  cadence: await getTemplatedTransactionCode()[0],
  limit: 9999,
  args: (arg: any, t: any) => []
});
const transaction = await fcl.tx(txId).onceSealed()
return transaction
```

### Generate from non-Javascript environments

Cadence scripts and transactions can be generated directly on-chain via scripts. You will need to be able to run cadence scripts to continue.

_1. Retrieve a list of transactions available for code generation_

Run the following script to retrieve available code generation methods: https://github.com/dapperlabs/nft-catalog/blob/main/cadence/scripts/get_supported_generated_transactions.cdc

_2. Provide a catalog collection identifier to generate code_

You may use the following script to generate code: https://github.com/dapperlabs/nft-catalog/blob/main/cadence/scripts/gen_tx.cdc

For example, from the CLI this may be run like the following:
`flow -n mainnet scripts execute ./get_tx.cdc CollectionInitialization Flunks flow`

In the above example, `CollectionInitialization` is one of the supported transactions returned from step 1, `Flunks` is the name of an entry on the catalog (https://www.flow-nft-catalog.com/catalog/mainnet/Flunks), and `flow` is a fungible token identifier.

## NPM Module

We exposed an interface to the catalog via a consumable NPM module. This library will expose a number of methods that can be called to interact with the catalog.

### Methods

Method signatures and their associating parameters/responses can be found in the `cadence/` folder of this repo.

#### Scripts

```
checkForRecommendedV1Views
genTx
getAllNftsInAccount
getExamplenftCollectionLength
getExamplenftType
getNftCatalog
getNftCatalogProposals
getNftCollectionsForNftType
getNftIdsInAccount
getNftInAccount
getNftInAccountFromPath
getNftMetadataForCollectionIdentifier
getNftProposalForId
getNftsCountInAccount
getNftsInAccount
getNftsInAccountFromIds
getNftsInAccountFromPath
getSupportedGeneratedTransactions
hasAdminProxy
isCatalogAdmin
```

#### Transactions

```
addToNftCatalog
addToNftCatalogAdmin
approveNftCatalogProposal
mintExampleNft
mintNonstandardNft
proposeNftToCatalog
rejectNftCatalogProposal
removeFromNftCatalog
removeNftCatalogProposal
sendAdminCapabilityToProxy
setupExamplenftCollection
setupNftCatalogAdminProxy
setupNonstandardnftCollection
setupStorefront
transferExamplenft
updateNftCatalogEntry
withdrawNftProposalFromCatalog
```

### Installation

```
npm install flow-catalog
```

or

```
yarn add flow-catalog
```

### Usage

Methods can be imported as follows, all nested methods live under the `scripts` or `transactions` variable.

NOTE: In order to properly bootstrap the method, you will need to run and `await` on the `getAddressMaps()` method, passing it into all of the methods as shown below.

```
import { getAddressMaps, scripts } from "flow-catalog";

const main = async () => {
    const addressMap = await getAddressMaps();
    console.log(await scripts.getNftCatalog(addressMap));
};

main();
```

The response of any method is a tuple-array, with the first element being the result, and the second being the error (if applicable).

For example, the result of the method above would look like -

```
[
  {
    BILPlayerCollection: {
      contractName: 'Player',
      contractAddress: '0x9e6cdb88e34fa1f3',
      nftType: [Object],
      collectionData: [Object],
      collectionDisplay: [Object]
    },
    ...
    SoulMadeComponent: {
      contractName: 'SoulMadeComponent',
      contractAddress: '0x421c19b7dc122357',
      nftType: [Object],
      collectionData: [Object],
      collectionDisplay: [Object]
    }
  },
  null
]
```

## License

The works in these files:

-   [FungibleToken.cdc](https://github.com/onflow/nft-catalog/tree/main/cadence/contracts/FungibleToken.cdc)
-   [NonFungibleToken.cdc](https://github.com/onflow/nft-catalog/tree/main/cadence/contracts/NonFungibleToken.cdc)
-   [ExampleNFT.cdc](https://github.com/onflow/nft-catalog/tree/main/cadence/contracts/ExampleNFT.cdc)
-   [MetadataViews.cdc](https://github.com/onflow/nft-catalog/tree/main/cadence/contracts/MetadataViews.cdc)
-   [NFTCatalog.cdc](https://github.com/onflow/nft-catalog/tree/main/cadence/contracts/NFTCatalog.cdc)
-   [NFTCatalogAdmin.cdc](https://github.com/onflow/nft-catalog/tree/main/cadence/contracts/NFTCatalogAdmin.cdc)
-   [NFTRetrieval.cdc](https://github.com/onflow/nft-catalog/tree/main/cadence/contracts/NFTRetrieval.cdc)

are under the [Unlicense](https://github.com/onflow/nft-catalog/blob/main/LICENSE).
---
title: Cadence VS Code Extension
---

This extension integrates [Cadence](../../build/guides/smart-contracts/cadence.md), the resource-oriented smart contract programming language of [Flow](https://www.onflow.org/), into [Visual Studio Code](https://code.visualstudio.com/).
It provides features like syntax highlighting, type checking, code completion, etc.

Note that most editing features (type checking, code completion, etc.) are implemented in the [Cadence Language Server](https://github.com/onflow/cadence/tree/master/languageserver).

## Features

- Syntax highlighting (including in Markdown code fences)
- Run the emulator, submit transactions, scripts from the editor

## Installation

To install the extension, ensure you [have VS Code installed](https://code.visualstudio.com/docs/setup/mac)
and have configured the [`code` command line interface](https://code.visualstudio.com/docs/setup/mac#_launching-from-the-command-line).

### Using the Flow CLI

The recommended way to install the latest released version is to use the Flow CLI.

```shell script
brew install flow-cli
```

Check that it's been installed correctly.

```shell script
flow version
```

Next, use the CLI to install the VS Code extension.

```shell script
flow cadence install-vscode-extension
```

Restart VS Code and the extension should be installed!

## Developing the Extension

### Pre-requisites

- Must have Typescript installed globally: `npm i -g typescript`

### Getting Started

- Run the Typescript watcher: `tsc -watch -p ./`
- Launch the extension by pressing `F5` in VSCode
- Manually reload the extension host when you make changes to TypeScript code

### Configuration for Extension Host if Missing (`launch.json`):

```
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "extensionHost",
      "request": "launch",
      "name": "Launch Extension",
      "runtimeExecutable": "${execPath}",
      "args": ["--extensionDevelopmentPath=${workspaceFolder}"],
      "outFiles": ["${workspaceFolder}/out/**/*.js"]
    }
  ]
}

```

### Building

If you are building the extension from source, you need to build both the
extension itself and the Flow CLI (if you don't already have a version installed).
Unless you're developing the extension or need access to unreleased features,
you should use the Flow CLI install option (above). It's much easier!

If you haven't already, install dependencies.

```shell script
npm install
```

Next, build and package the extension.

```shell script
npm run package
```

This will result in a `.vsix` file containing the packaged extension.

Install the packaged extension.

```shell script
code --install-extension cadence-*.vsix
```

Restart VS Code and the extension should be installed!
---
title: Dapp Architectures on the Flow Blockchain
sidebar_label: Dapp Architectures on the Flow Blockchain
---

## Introduction
This document showcases the common solution architectures that the Flow blockchain dapps can follow. In addition, it shows interaction sequences between the solution components for the common user journeys.

The audience for this document is someone who is at the beginning of the Flow dapp development process. For developers with Ethereum experience, we also contrast Ethereum dapp architecture with Flow dapp architecture.

Read this document as a companion guide to the [Flow Developer Onboarding Guide](https://docs.google.com/document/d/14eQE0wq60IRgD3N5jtwpW8RxexFt_hB3EHnDg_uBl8k/edit).

<Callout type="info">
We mention various third-party services and software products in this document.That is not an endorsement. Developers should evaluate these products independently according to their needs. 
</Callout>

## Dapp Architectures
### Non-Custodial Flow Dapp Architecture
Non-custodial dapps let their users hold NFTs and other assets in user-controlled wallets like Blocto wallet. 

![Non-custodial flow dapp architecture diagram](architectureImages/image4.png)

In non-custodial scenarios, note the following aspects of the dapp design :
- **Interaction with wallets**: Flow Client Library (FCL) abstracts out the wallet interactions for Flow dapps. 
Integrating with FCL makes a dapp wallet-agnostic, and any future FCL-compatible wallet will be able to use it.
- **Managing blockchain transactions**: User transactions will typically be submitted to the blockchain by the FCL code in the UI client after obtaining signatures from the wallet services.
But sometimes, dapps need to submit transactions to the blockchain from their backend (minting NFTs, for example).
Several SDKs are available to interact with the Flow blockchain, including some that are community-run. The SDKs interact with the access nodes of the Flow blockchain.
We recommend maintaining a queuing infrastructure within the dapp’s backend to handle the scalability surge.
There are some third-party services available that make managing transactions from the dapp backend easier :
- [QuickNode](https://www.quicknode.com/chains/flow): QuickNode provides a reliable node service to access Flow blockchain. QuickNode's service is designed to optimize developer productivity by eliminating the complexities of setting up and maintaining their own nodes. By leveraging QuickNode's infrastructure, developers can focus on building and deploying decentralized applications (dApps) without the hassle of managing the underlying blockchain infrastructure.
- [Alchemy](https://www.alchemy.com/flow): To get a dedicated Flow blockchain access node, Alchemy provides a managed access node service for the Flow dapp developers.
Alchemy can allow dapp devs to bypass the rate limits imposed by official Flow access nodes without the operational overhead of running an access node.
- [Tatum](https://apidoc.tatum.io/): Tatum provides REST APIs to let dapps perform high-level blockchain operations like creating Flow accounts, sending NFTs, or FLOW tokens to an address.
In some cases, Tatum will totally obviate the need to use the Flow SDK, or implement your own smart contract.
- [Wallet-API](https://github.com/flow-hydraulics/flow-wallet-api/): Wallet-API can be a convenient way to manage both the transactions and the keys for your admin accounts in the backend.
- **Organizing/accessing blockchain data**: Dapps often have their business logic respond to the current and past events and transactions on the Flow blockchain.
One option is to listen to the events, maintain them, and index them.
Third-party services like [Graffle](https://graffle.io/) and Tatum also provide REST APIs, and programmatic notifications/webhooks to receive Flow blockchain data such as events and transactions.
Specifically, Graffle can provide easy access to the past and real-time events on the Flow blockchain.
These third-party services can insulate your application from the requirement of being aware of [sporks](../references/run-and-secure/node-operation/spork.mdx#past-and-upcoming-sporks).
Otherwise, you will have to add logic in your application to navigate across [past sporks](../references/run-and-secure/node-operation/spork.mdx#past-and-upcoming-sporks) when looking up past blockchain data.

<Callout type="info">
With any of these payment rails choices, dapp developers should do their own legal/compliance due diligence.
</Callout>

- **Payment rails**: 
- **Dapp-User payments**: If a dapp is selling an item directly to the user, it can use either of these two approaches:
- **Credit Card/ACH**: Dapps can process payments using traditional Web2.0 methods and transfer NFTs if the payment completes successfully. Some payment processors, like [Moonpay](https://www.moonpay.com/buy/flow), offer turnkey solutions to enable simple NFT purchases using credit cards.
- **Crypto/Stablecoin**: Users can pay dapps using FLOW token or stablecoins like USDC from their wallets.
- **User-User (P2P) payments**: P2P payments (most commonly seen on the marketplace dapps) will involve users paying each other using FLOW tokens or stablecoins like USDC held in their wallets.

### Custodial Flow Dapp Architecture
Custodial dapps will store keys for the Flow accounts of their users in their backend, which insulates users from managing wallet accounts. 

![Custodial flow dapp architecture diagram](architectureImages/image2.png))

In custodial scenarios, note the following aspects of the dapp design:
- **Interaction with wallets**: Custodial wallets do not involve external user wallets.
But, the dapp backend needs to maintain “wallets” for each user by storing and managing their Flow account keys.
We provide a turnkey solution called Wallet API for managing custodial wallets and submitting/managing transactions for those custodial wallets.
When using “Wallet API”, make sure that your UI client/frontend is integrated with the “FCL shim” for “Wallet API”. This will allow you to easily switch between custodial and non-custodial wallets in the event of a design change.
Always store users’ Flow account private keys in a KMS or a similar secure key vault product. Usage of KMS makes sure the private keys never see the light of the day. “Wallet API” is already integrated with Google Cloud KMS.
- **Managing blockchain transactions**: This is exactly the same as managing blockchain transactions with [non-custodial dapp architecture](#non-custodial-flow-dapp-architecture), note that the “Wallet API” module does most of the heavy lifting for submitting and managing transactions.
- **Organizing/accessing blockchain data**: Accessing blockchain data works exactly the same way as in [non-custodial dapp architecture](#non-custodial-flow-dapp-architecture).
- **Payment rails**: 
With any of these payment rails choices, dapp developers should **do their own legal and compliance due diligence**.
With payment providers like Stripe, there might be a risk of being de-platformed at the payment providers' whim.
Also, when hosting a P2P marketplace, there may be Money Service Business (MSB) licensing issues.
- **Dapp-User payments**: If a dapp is selling an item to the user, the dapp can follow either of two approaches:
- **Credit Card/ACH**: Dapps can process payments using traditional Web2.0 methods and transfer NFTs if the payment is successful.
- **Crypto/Stablecoin**: This can work in two ways:
Load Crypto/Stablecoin in the Flow account: Dapps will have to expose the Flow account details to the user, and the user will load up crypto/stablecoin in that account using an on-ramp like [MoonPay](https://www.moonpay.com/buy/flow). 
- **Send Crypto/Stablecoin to the payment processor**: If the dapp’s payment processor also accepts crypto, then the dapp developer will be able to accept payment in crypto from the user without saddling the user with the Flow account details.
- **User-to-User (P2P) payments**: 
**Credit Card/ACH**: With this approach, sellers are on-boarded onto the payment processor’s system, potentially as sub-merchants, and the buyers pay using a credit card or ACH through the payment processor.
All the money settlement happens in FIAT.
Only NFT gets transferred on the blockchain upon successful transaction completion. 
- **Crypto/Stablecoin** With this approach, buyers will directly send USDC or FLOW to the sellers.
Dapps will have to expose the flow account details to the user and the users will load up crypto/stablecoin in their account using on-ramps like [MoonPay](https://www.moonpay.com/buy/flow).
### Backend-less Flow Dapp Architecture
For some use-cases, developers can create a backend-less dapp.
To interact with a dapp without a backend, a user typically interacts with a static webpage.

For such a dapp all the business logic will reside on the blockchain smart contracts and the frontend. Dapp state however, is saved on the blockchain.  For efficiently querying past blockchain data, these dapps can rely on external services like Graffle. 

Dapp developers and admins will configure and update their dapps by directly interacting with the blockchain.
Backend-less dapps provide a high degree of decentralization. These dapps can continue providing services to their users even when the dapp development teams are no longer around.

![Non-custodial flow dapp architecture diagram](architectureImages/image3.png)

## Dapp Interaction Sequences
### NFT Purchase in a Non-Custodial Dapp
The following sequence diagrams show how two different NFT purchase flows can happen in a non-custodial dapp:
1. NFT buyer pays using a credit card through the dapp’s payment processor, and the dapp developer receives payment in FIAT.
2. NFT buyer pays the dapp developer using crypto/stablecoin tokens.

![Non-custodial flow dapp architecture diagram](architectureImages/image7.png)

You can find the diagram [source here](https://sequencediagram.org/index.html#initialData=C4S2BsFMAIDFwPYHdoDkEDsC0BhArgM7AIAmIAhuNACLkAOdasAKtAAp4BOAxgBbkEYSML2g5OkMsBzlOJAFzQA8nVCZoAYgCMAKD3luxTtACC4EN0h66s0NxA2MwaACIAQokMIAOhgAU8MjQAOqUUM4AypCcAG4WkACULtAC0EhhkMB6Ojacdg7kTq60DL5+wZAARqYMSSkENPR01rYWBUUuqCzQEUaQAGacmMC+EQC2tmLDnAYj-oEoHgjcANZ85CAYdaldzNkA5kN4jG54AJ5MezqHCMdiEuTAMAum3IbQANoqahiUfpgwUBjGCYcBnBIAXR0ZniAB4sAA+dLgcKKajIDCIcgkaCVTzEFIMaHmSzwpEZYCKcSQR4wPHLAkGbi3Jy+QibfbQSATEBUbEkCQEAg6SAYEh6DAIJ7QBAxaKmEmQAA0jQYijYQziBBA6hhlgA5A0XkznP0EMZgLxAWc6CD+pcGgQEOAcZULpaYCVmnrIIivYoolB3h7LtACZVzsS4X6muryBczRaraH2RhOdwJFJoNxZDi-L1OA5EjpJdLZfLkeEVbtFMwZhgCP15SHdmGEAr4oaQhTsqKSEA)

![Non-custodial flow dapp architecture diagram](architectureImages/image8.png)

You can find the diagram [source here](https://sequencediagram.org/index.html#initialData=C4S2BsFMAIDFwPYHdoDkEDsC0BhArgM7AIAmIAhuNACLkAOdasAKtAAp4BOAxgBbkEYSML2g5OkMsBzlOJAFzQA8nVCZoAYgBMAKD2QMoYAE9oAWQSY65Y3vLdinaAEFwIbpD3XOobiGuG0ABEAEKIDggAOhgAFPDI0ADqlFDA0ADKkJwAbu6QAJRB0ALQSCmQwHo63r7+5IFBtAzRMYmQAEYuDIXFBDT0dF6ytQFpQagsGY6QAGacmMDR6QC2w2ILnPaLsfEoYQjcANZ85CAYPSUTzFUA5vN4jOKQ5MAw9STQADII5B+7LtwHDpXHkADxYAB8ZXAqUU1GQGEQv2g7XCxGKDGBbg84Kh5WAiieLxgqIO6Ps3AQeEM0UIZxu0EgqxAVF+JAkBAIegwCFe0AQ2Sy5ksGGsxgANKV8YoQnhTLAAKrpajQOkYBlPKQyOQ6AwkPR3KmMWWmK5VLF5SHQ2Hsea5AggdT-CnbGYIJzAXgwEx0GAIGZMZgEaIEBDgD7tUyemDUZyYkEeSFNOiKTJQByB6Do9py7m8v2CpzWiqSq6KACM+WgzE2GAIMyFiuV0BikAAjnhKFmEFmvdA6Jw8vyA1cq3MEMsXNjIAByPrF7ZaKs1+r1oVXbtTvJzpL46IAZirTZVID6wFra84Eg+6Oj-QYO4X0XQr0Urio-t7b3aApgREgdB9Nw9QojAJCYDAZzFNADrqlAxTEMs7gouExz8FBwAAB4YFUepAA)

<Callout type="info">
NFT buyers may also use on-ramp providers like Moonpay, Wyre, or Ramp to purchase crypto using their credit cards.  
</Callout>

The sequence diagrams above show interactions with the mobile app version of the Blocto wallet.
You can use the Blocto wallet purely from the web as well, inside of the dapp, giving a compelling user experience (see [Vault by CNN](https://vault.cnn.com/)).
### NFT Purchase in a Custodial App
The following diagram shows NFT purchases using a credit card in a custodial dapp environment. Payment processing is done off-chain and the dapp collects the payment in FIAT.
The only transactions that happen on the blockchain are the NFT minting (and storage for those dapps holding an inventory), and transfers to the buyer’s account.

![Non-custodial flow dapp architecture diagram](architectureImages/image1.png)

You can find the diagram [source here](https://sequencediagram.org/index.html#initialData=C4S2BsFMAIDFwPYHdoDkEDsC0BhArgM7AIAmIAhuNACLkAOdasAKtAAp4BOAxgBbkEYSML2g5OkMsBzlOJAFzQA8nVCZoAYgBMAKD2QMoYAE9oAWQSY65Y3vLdinaAEFwIbpD3XOobiGuG0ABEAEKIDggAOhgAFPDI0ADqlFDA0ADKkJwAbu6QAJRB0ALQSCmQwHo63r7+5IFBtAzRMYmQAEYuDIXFBDT0dF6ytQFpQagsGY6QAGacmMDR6QC2w2ILnPaLsfEoYQjcANZ85CAYPSUTzFUA5vN4jOKQ5MAw9STQADII5B+7LtwHDpXHkADxYAB8ZXAqUU1GQGEQv2g7XCxGKDGBbg84Kh5WAiieLxgqIO6Ps3AQeEM0UIZxu0EgqxAVF+JAkBAIegwCFe0AQ2Sy5ksGGsxgANKV8YoQnhTLAAKrpajQOkYBlPKQyOQ6AwkPR3KmMWWmK5VLF5SHQ2Hsea5AggdT-CnbGYIJzAXgwEx0GAIGZMZgEaIEBDgD7tUyemDUZyYkEeSFNOiKTJQByB6Do9py7m8v2CpzWiqSq6KACM+WgzE2GAIMyFiuV0BikAAjnhKFmEFmvdA6Jw8vyA1cq3MEMsXNjIAByPrF7ZaKs1+r1oVXbtTvJzpL46IAZirTZVID6wFra84Eg+6Oj-QYO4X0XQr0Urio-t7b3aApgREgdB9Nw9QojAJCYDAZzFNADrqlAxTEMs7gouExz8FBwAAB4YFUepAA)
## Appendix
### Ethereum Dapp Architecture
Ethereum is one of the major general-purpose smart contract blockchain platforms. Dapps developing on Ethereum are primarily focused on decentralization. We discuss some of the common patterns with Ethereum dapps and what are their equivalents on the Flow blockchain.

![Non-custodial flow dapp architecture diagram](architectureImages/image6.png)

Common themes among dapps built on Ethereum:
- **Interaction with wallets**: Most Ethereum dapps integrate with the web3js library in the frontend to abstract out interaction with wallets. Due to web3js, the dapps do not have to be aware of the intricacies of individual wallets. On the Flow blockchain, the equivalent of web3js is FCL. 
- **Managing blockchain transactions**: There is no official Ethereum node offering access APIs for submitting transactions. Ethereum dapp projects generally do not run their own full node. Instead, they rely on a service like that from Infura (or Alchemy) to reliably submit and manage their transactions. Alchemy provides services for the Flow blockchain as well. Tatum and Graffle provide equivalent services on the Flow blockchain as Infura on Ethereum.
- **Organizing/accessing blockchain data**: There are many mature Ethereum ecosystem projects like Etherscan that collect, maintain, and index blockchain data, and provide blockchain access services through APIs. Most Ethereum dapps use these services for querying the blockchain. Graffle and Flowdiver are the equivalents of Etherscan on the Flow blockchain.
- **Payment rails**: Due to the focus on decentralization Ethereum dapps mostly rely on tokens including stablecoins for payment on-ramp/off-ramp. 


The following diagram shows an example interaction sequence with an Ethereum Dapp.

![Non-custodial flow dapp architecture diagram](architectureImages/image5.png)

You can find the diagram [source here](https://sequencediagram.org/index.html#initialData=C4S2BsFMAIFFgBaQE6QK4FtoBECGAHfaAOQDEAVaABTWQGMFcBnGAVReWlPAHsB3AFADIAO1DAAntABEsAB4NcIgOaQAOiIAUAYR4gRAI2aQAlNOjM4CxisgDoA3HWA9OAQXAg6d-LmSg6EF8xGQ8vSAByJmgAdVxwKGANTQBZSGBcFOYAazMLaLSMrKZsoV9-LyClYBk8QmSYyANoN0I8yzr8Mr8AqpDpMkoAZRdUDSGMHuhdMWQnJK14JFRMdujBoREeYBgeADcUFs9vABorRVsALmgARhNoIZBlETQiADNXCxELOjoeNDEGgATPcAOI8aCIZD-ZQICzQADSAE1tNAGJA6NkNABme4AGX02UhSGgRhERKcfwBwCYm22uwO7mOkDOhUyOWud2gAEkREwMgliTBIHIdnyQDxvh9OAxoRh1CIQdBQaIULgdl8ACbQJi4A7wliQbX4BBzFgCZTQ17QABCaCkrCG2G0AjC3gAtAA+eQXVTXO0Op0un02VRe6Bs4rZa54ni4bWO53QSXQPjxRLCESaoQWq1EAMkCiu5lezrXIaQKDOQuUFyk+0CTpeyMch6ibXAOZ8+YSqWfAj4aF7eLF8LN9LskrXVqD-YwTtKXXOXsCFslL2Da7kLtMN6HRMuwbjoqt7eLvecDbthxAA)
---
title: NFT Drop Strategies
sidebar_label: NFT Drop Strategies
---

## Exploring Different Strategies for NFT Drops

This is a brief overview of different strategies for releasing NFTs.
Each strategy focuses on a few key aspects of NFT drops:
- Where are the NFTs sold?
- When are the NFTs minted?
- Who is responsible for payment processing?
- When do buyers receive their NFTs?
- How much do buyers trust your project?
- How much do you trust NFT buyers?
  
## On-chain Sale of Pre-Minted NFTs

With this strategy, the NFTs are pre-minted, so they are all minted before being sold.
Then they are bought and sold in an on-chain storefront, this means that completed transactions are reflected on the blockchain. 

This allows a dapp to grow without dealing with additional payment rails because the blockchain handles the payment.
NFT buyers like this strategy because they don't have to trust the dapp to complete a transaction successfully, all they need is their wallet.
This strategy doesn't need a backend, which lowers the costs and complexity for developers.
However, while the lack of Know Your Customer (KYC) makes this strategy frictionless for buyers and developers, it also leaves the dapp susceptible to bot attacks because the developer can't verify that the customers are real people.

Real-world examples of dapps using this strategy include: [Viv3](https://viv3.com/), [BloctoBay](https://bay.blocto.app/), [Chainmonsters](https://chainmonsters.com/), and [NBA Topshot](https://nbatopshot.com/).
![On-chain pre-minted NFT diagram](NFTimages/image1.png)

## Off-chain Sale of Pre-Minted NFTs

Pre-minting the NFTs and selling them through the dapp’s website is a similar alternative strategy.
This allows the dapp developers to have greater control over the NFT sale process, allowing developers to prevent bots from accessing the storefront. 

Another benefit to this strategy is that developers can implement traditional payment rails, like credit cards, into the storefront in addition to crypto payments.
This benefits both NFT sellers and buyers because they can use whichever payment method is most convenient, which opens up an NFT storefront to a broader buying audience.

This strategy requires NFT buyers to trust the dapp more, especially with crypto payments, because they are irreversible.
Integrating payment processors for traditional payment rails may also be a challenge in some markets, leading to very different user experiences for NFT buyers.
As a storefront owner, you also risk chargeback issues when you implement traditional payment rails.

Real-world examples include [CNN Vault](https://vault.cnn.com/) and [RCRDSHP](https://app.rcrdshp.com/).

![Off-chain pre-minted NFT diagram](NFTimages/image2.png)

## Pre-sale of NFTs With Deferred Delivery

Pre-selling claims to NFTs and agreeing to deliver them at a later date is also a popular strategy.
This is a great way to gauge interest in your project before investing in content or technology.
Buyers receive their NFTs when your dapp is built, and you're ready to deliver content.
You can implement smart contracts for NFT pre-sales, and you can handle the transaction either on-chain or off-chain.

For this strategy to succeed, NFT buyers need to have a lot of trust in your project.
Buyers can't choose which NFT they buy because it doesn't exist yet, and this strategy doesn't leave much room for secondary markets.

![Pre-sale NFT deferred delivery diagram](NFTimages/image3.png)

## On-chain On-demand Mint and Sale of NFTs

With this strategy, NFTs are minted and sold when a buyer wants to buy them.
This strategy is less common than others because building it can be complex.
To accomplish this you need to have custom NFT sale contracts for each buyer, and you need to generate unique content for each user.
Generating purely random and unique content is challenging, and managing content drops is also a difficult problem to solve.
Also, because transactions are on-chain, your dapp will be susceptible to bot attacks.

But, there are some very unique benefits to this strategy.
The scarcity of the NFTs is predictable, and your dapp will never have unsold inventory.
This strategy also makes your project as decentralized as possible, because you don't need to maintain a centralized inventory or payment process.

Real-world examples include: [Bitku](https://bitku.art), AMM driven NFT minting, and [CryptoPiggos](https://www.flowverse.co/applications/cryptopiggos)
![On-chain on-demand NFT diagram](NFTimages/image4.png)

## Off-chain On-demand Mint and Sale of NFTs 

This strategy also uses on-demand minting, however, transactions are made off-chain so that developers can have greater control over the NFT sale process.
With on-demand minting, a dapp using this strategy will never have unsold inventory, and it benefits from the ability to implement traditional payment rails, like credit cards.
Developers can also use KYC to prevent bots or other unauthorized buyers, from buying NFTs.

While this strategy has some very unique benefits, it is complex to set up, which leads to unique challenges.
The combination of off-chain transactions and on-demand minting means that this strategy needs more blockchain transactions to complete the NFT purchase flow.
Also, like other off-chain strategies, NFT buyers need to trust the dapp, and payment processors may be challenging to implement in some markets.

A real-world example of this strategy is [Dooverse](https://dooverse.io/).

![Off-chain on-demand NFT diagram](NFTimages/image5.png)

## On-chain Sale of NFTs Gated by Vouchers

The final strategy we're looking at allows NFT buyers to register on your website for vouchers that they can exchange for NFTs.
The vouchers act as authorization for a buyer, allowing your website to control who is allowed to buy your NFTs, while still gaining the benefits of on-chain transactions.
This is a great way to implement on-chain transactions while preventing bots and unauthorized buyers from accessing your NFTs.

However, this 2-step process may be too much friction for some NFT buyers, which may limit your NFT sales.
Additionally, the voucher system is imperfect, and there may be an unauthorized secondary market for your project's vouchers.
Real-world examples of this strategy include [JAMBB](https://www.jambb.com/) and [RoundLabs/Faze](https://www.onflow.org/post/alpha-innovation-series-round-labs-on-cadence-and-building-on-flow).
![On-chain NFT with vouchers diagram](NFTimages/image6.png)

## Conclusion

Choosing an NFT drop strategy can be challenging.
Each strategy comes with its own benefits and challenges, and it's important to weigh which factors are most important for your project.
For more examples of real-world NFT projects using a variety of different strategies, have a look at [Flowverse](https://www.flowverse.co/)
{
    "label": "Tutorials",
    "position": 2
  }---
title: Smart Contract Testing Guidelines
sidebar_label: Smart Contract Testing
sidebar_position: 2
---

Achieving good test coverage is vital for assuring the quality of code written to be deployed on the Flow blockchain.

Automated tests can be run locally in the Flow emulator, and on the Flow testnet. These tests should include both unit tests; to exercise each feature of a contract, and integration tests; to exercise the behavior of different parts of the project as a whole.

Human-driven tests, in which individual testers work manually through user stories via the project's user interface or custom transactions, can also be performed locally. Tests with groups of testers can be performed similarly on testnet in a similar manner.

Finally, unstructured closed testing with a limited audience on testnet can gain valuable information about performance and security by capturing usage data from more organic interaction with the project's smart contracts over days or weeks.

## Testing Requirements

It is suggested to follow the following best practices:

- Every publicly exposed feature of a contract and its resources should have unit tests that check both for success with correct input _and_ for failure with incorrect input.
  These tests should be capable of being run locally with the Flow emulator, with no or minimal extra resources or configuration, and with a single command.
- Each user story or workflow that uses the smart contracts should have an integration test that ensures that the series of steps required to complete it does so successfully with test data.

Make sure you test all contracts - and the integration into your application extensively before proceeding to the mainnet.
You should aim to replicate all conditions as closely as possible to the usage patterns on mainnet.

## Writing Tests

There are official SDKs for Flow in both Go and JavaScript.

In both cases, the code will need to deploy the contracts, configure accounts to interact with them and send transactions to them. It will then have to wait for the transactions to be sealed and check the results by catching exceptions, checking for events, and querying state using scripts.

### Go Tests

Tests in Go can be written using [flow-go-sdk](https://github.com/onflow/flow-go-sdk) and the go test command.

You can find examples of Go tests in the following projects: [flow-core-contracts](https://github.com/onflow/flow-core-contracts/tree/master/lib/go/test), [flow-nft](https://github.com/onflow/flow-nft/tree/master/lib/go/test), [flow-ft](https://github.com/onflow/flow-ft/tree/master/lib/go/test).

> **Note**: These tests are tied to the emulator but can be refactored to run on testnet

### JavaScript Tests

Tests in JavaScript can be written using [flow-js-testing](https://github.com/onflow/flow-js-testing).
---
title: Off-chain Dapp Infrastructure
sidebar_label: Off-chain Infrastructure
---

In addition to on-chain smart contracts, dapps also rely on off-chain infrastructure. For example, users often interact with a dapp through a web interface. In addition to this, some dapps rely on backend servers to query and index data from the blockchain. This section covers best practices for off-chain infrastructure on Flow.

## Writing Data to Flow

All data written to the blockchain happens in a transaction. For user-facing dapps, transactions either originate from a user account or an admin account. For most dapps, the large majority of transactions will be user transactions. 

### User Transactions

User transactions are transactions that are authorized by the users of your dapp. These transactions originate from the user’s wallet, as mentioned in the 
[User Accounts & Wallets](./user-accounts-and-wallets.md) section. For example, a user may sign a transaction to purchase an NFT from your dapp.

A user transaction is initialized by your dapp (e.g. by a button click) through FCL, which then passes the transaction to the user’s wallet, which in turn signs the transaction and submits it to Flow. This all happens from the dapp client, typically a browser app. By using FCL, your dapp does not need to be involved in the transaction signing -- it constructs the transaction, passes it to the wallet, and then waits for the final result.

### Admin Transactions

Admin transactions are transactions that originate from the backend of your dapp, or from a separate administration interface that you control. These transactions perform the administrative duties required to operate your dapp, and are signed by an administrator account controlled by you, the dapp developer.

For example, you may send an admin transaction that mints a batch of NFTs for purchase, or a transaction that adds an additional gameplay level to your game.

For one-off administrative actions that do not require automation, such as contract deployment, you can use the [Flow CLI](../tools/flow-cli/).

## Reading Data From Flow

Your dapp will also need to read data from Flow, and in particular, the state of your smart contracts. There are several ways to query state on Flow.

### Events

Events are data objects emitted at the end of a transaction that describe the state changes that occurred in the transaction. For example, a transaction that transfers FLOW tokens between accounts [will emit events](https://flowdiver.io/transaction/2f50695c3c506b8214d18f49220c986d24d19d8762a2805b3609aee3d529de88) that describe the sender, recipient and amount of FLOW transferred. Event types are [defined inside your Cadence contracts](https://github.com/onflow/flow-core-contracts/blob/master/contracts/FlowToken.cdc#L8-L27). 

Events can be used to notify your off-chain infrastructure of important state changes in your smart contracts. For example, if a user purchases an NFT from your storefront smart contract, an event will be emitted that describes this purchase. Your web application, which displays the NFTs for sale, can then capture that event and remove the NFT from the sale list.

You can query events through the Flow Access API using the available [Flow SDKs](../tools/clients/index.md). Event data is returned in [JSON-Cadence format](https://cadence-lang.org/docs/json-cadence-spec).

#### Event Reflection Database

Some applications, especially those with existing backend servers, opt to store application state in an off-chain database that merely reflects the state of on-chain contracts. A reflection database has the following benefits:

* **Unified on and off-chain state**. For dapps that rely on both on and off-chain state, it’s useful to store all data in a central database to allow for atomic queries (i.e. ACID) and high scalability.
* **Fast and flexible queries.** Database systems can be tuned and optimized (e.g. using indices) to best serve the data needs of your dapp, whereas the blockchain itself does not provide this level of customization.

#### Event Providers

Third-party event providers, such as [Graffle](https://graffle.io/), can simplify event filtering and stream events directly to your frontend or backend infrastructure.

### Cadence Script Queries

At any point, your dapp can execute a query to read the state of your contracts. This is done using Cadence scripts, which are written similarly to transactions, but are read-only and cannot mutate the blockchain state. 

Events follow a push model, whereas script queries follow a pull model. Your dapp may need to check the state of your contracts without waiting for an event to be emitted. 

You can execute scripts through the Flow Access API using the available [Flow SDKs](../tools/clients/index.md). Like events, script results are returned in [JSON-Cadence format](https://cadence-lang.org/docs/json-cadence-spec).
---
title: The Anatomy of a Flow Dapp
sidebar_label: Anatomy of a Flow Dapp
sidebar_position: 1
---

The diagram below outlines the components of a typical dapp built on the Flow blockchain. While many dapps are structured differently, this architecture introduces fundamental concepts that will be discussed throughout this guide.

![Flow Dapp Anatomy](flow-dapp-anatomy.png)

## Dapp Client

The dapp client is the interface through which users interact with your dapp. Web and mobile applications are common examples of dapp clients.

## Smart Contract

A smart contract is a collection of code, deployed to a permanent location on the blockchain, that defines the core logic for a dapp.

## User Account

A user account is a record on the blockchain that stores the digital assets owned by a single user.

## Transaction

A transaction is a piece of code submitted to the blockchain that mutates the state of one or more user accounts and smart contracts. All transactions originate from at least one user account. In most cases, a transaction passes data between a user account and a smart contract.

## State Query

A state query is a request made to the blockchain that returns information about the state of your dapp’s smart contracts.

## User Wallet

A user wallet is software or hardware that controls access to a user’s account on the blockchain. The application client typically connects to the user’s wallet in order to send transactions to the blockchain. In many cases, the dapp physically transmits the transaction to the blockchain on behalf of the user. However, it’s important to note that the wallet has final say on what is signed or not, and therefore, has control over any transactions that interact with the user’s account.

## Flow Client Library (FCL)

The Flow Client Library is a framework that provides a standard interface to connect client applications and user wallets.

THanks for reading and happy hacking! 🚀

# How to Launch a Fungible Token on Flow

*DISCLAIMER:  PLEASE READ THE ENTIRETY OF THIS "DISCLAIMER" SECTION CAREFULLY BEFORE READING THIS GUIDE.  THE INFORMATION CONTAINED WITHIN IS FOR COMMUNITY DISCUSSION AND CONTAINS GENERAL INFORMATION ONLY.  NOTHING HEREIN CONSTITUTES LEGAL, FINANCIAL, BUSINESS, REGULATORY, OR TAX ADVICE OR GUIDANCE AS TO ANY POTENTIAL TOKEN LAUNCH OR PROJECT IN ANY SPECIFIC JURISDICTION.  ANYONE READING THIS GUIDE MUST CONSULT LEGAL, FINANCIAL, TAX, REGULATORY, AND OTHER PROFESSIONAL ADVISORS OR EXPERTS FOR FURTHER GUIDANCE BEFORE LAUNCHING ANY TOKEN OR TOKEN-RELATED PROJECT.  IT IS IMPERATIVE THAT INDEPENDENT LEGAL ADVICE IS SOUGHT TO DETERMINE THE LEGAL, REGULATORY, SECURITIES, OR OTHER REQUIREMENTS RELATED TO ANY AND ALL JURISDICTIONS WHERE A TOKEN LAUNCH OR SALE MAY OCCUR.*  

## Introduction
Launching a token is no easy feat. There is a lot that goes into bringing a token from nothing to market: strong tokenomics, private or public sale, distribution, and finally an organized launch on centralized and decentralized exchanges. 

Many dApp teams we speak to on a daily basis are somewhat humbled by the magnitude of the work ahead of them. We have spent many hours breaking down this process into manageable chunks and accompanying teams from their tokenomics design to their negotiations with market-makers. This guide is our attempt to make this knowledge more broadly available to help dApps realize their full potential on Flow.

In this guide, we will explore everything you need to know when launching a token, from the why to the how. The guide will be broken down into 4 parts:

1) **Prep work**: what you need to think about before you launch your token.
2) **Token allocation**: the process by which you will decide who gets how many tokens.
3) **Token distribution**: when and how you are going to get your tokens in your community’s hands.
4) **Token launch:** (nearly) everything you need to know to maximize the chances of success of your token listing.

Let’s dive in.

## Step 0: Prep Work

### Define Your Universe

Before launching your token, you will first need to take a step back and take an objective look at your dApp.

**So, what does your dApp do?**
Let’s start with something easy: what is the problem you are trying to solve and how are you solving it? Why is it crucial for your dApp to leverage a blockchain, instead of being a standard web2 application? You should be able to explain what you do in one or two concise sentences.

**Who are your users?**
You may have more than one type of user. Understanding each user’s journey on your dApp will be key in defining incentives that will make each user type “tick”.

For example, your users could be categorized in any of the following, non-exhaustive buckets: 

- Developers / builders
- Creators / content producers
- Curators
- Consumers
- Merchants
- Promoters
- Gamers
- Voters

You can also draw inspiration from this map of the Flow ecosystem. 

![flow ecosystem](flow-ecosystem.png)

Write down the list that is most relevant to your dApp and for each type of user, outline succinctly what behavior is expected of them, and what will incentivize them to display this behavior. A good way to summarize the way users interact with your dApp (and with one another) is to draw up a flowchart showing the flow of incentives and behaviors for each user type. For now, ignore the token and only focus on the high-level behaviors/incentives.

**What Are Your Token’s Objectives?**

**Why do you need a token for your dApp?**

Not all dApps need a token! In many instances, a token is not necessary for a dApp to be successful. Before you start designing your tokenomics and planning for the token launch, list the problems that your token will help solve.

**How will your token enable network dynamics?**

A successful token should be able to allow network effects to flourish on your dApp. An endless stream of new users buying your token and engaging with your dApp should not be a requisite for your token to succeed, but a consequence of carefully designed tokenomics. 

A simple way to lay out the expected network effects is to draw a flywheel: what would it look like? Which category of user is most crucial for the flywheel to function? 

## Tokenomics

Now that you have a clear understanding of your dApp’s objectives, it’s time to look at how your token will fit into the picture. This is where tokenomics come in. At a high level, tokenomics is the process by which you define the supply and plan for the demand dynamics of your token.

## Supply

A token’s supply, and how that supply evolves over time, is one of the most important factors in your token’s ability to provide and sustain substantial value to your users. Keep in mind that you, as the creator of the dApp, have more or less absolute control over such supply as long as you are transparent from the start over the evolution of such supply. 

A token supply is typically born from:

1) Tokens sold - privately or publicly
2) Tokens given for free - a.k.a. airdropped tokens 
3) Tokens earned - typically from performing certain actions beneficial to the dApp
4) Fixed or growing supply?

One of the first questions you will face when determining your token supply is whether to have a fixed or growing supply.

Let’s take a first look at the pros and cons of each option:


|     |  Fixed Supply   | Variable Supply    |
| --- | --- | --- |
|  Pros   |  <ul><li>A growth of the network value goes directly to existing token holders</li></ul>   | <ul><li>Strong mechanism to onboard new users due to inflation (aka new tokens being created and distributed, usually for free)</li><li>Powerful tool to increase token supply as dApp demand rises</li></ul>     |
|  Cons   |  <ul><li>Token price may become prohibitively high for new entrants, hampering your user growth - may or may not be a problem, depending on how you denominate the assets on your dApp (USD or your token)</li><li>Potential for early adopters to yield an outsized influence</li></ul>   | <ul><li>Potential downward pressure on the value of the token as new demand needs to be created to match the new supply</li><li>Dilutes existing holders</li></ul>     |

Think about the pros and cons of each, as outlined above, and what fits best your dApp’s objectives. 

It has been common to see dApps that did not want to choose between each model and eventually opted for a dual token model: 
- The “in-app currency” token that has an increasing supply
- The “network/governance” token that has a fixed supply and is supposed to capture the network growth

We go into further detail in the section “One Token vs. Two Token Model”.

## Airdrops

Airdrops can be very advantageous in the early days of a token launch, as they reward your community and incentivize early users to start utilizing your token. However, it is not uncommon to see recipients of airdrops simply turn around and liquidate, therefore hurting the token value. To protect against this eventuality, you may want to introduce features that encourage your users to behave in a way that is supportive of the growth of your network. 

Some examples of this include: 

- Limiting your airdropped tokens to **only be used internally within your dApp**, akin to airline miles. A token that is not withdrawable is a token that cannot be sold. This limitation can be lifted once the supply/demand dynamics are more established.
- Introduce a **lockup period or vesting** that users will have to wait out before coming into full possession of their tokens. You can also add a spin to this by tying the unlock to a specific behavior: participation, engagement etc.
- **Dividing your airdrop** into multiple smaller airdrops, and make each airdrop dependent on the previous one. For example, if a user has liquidated tokens from the first airdrop, then they are no longer eligible to receive the second airdrop.

On Flow, creating an airdrop is easy: you can utilize tools like [Drizzle](https://www.drizzle33.app/) to easily airdrop and raffle fungible tokens and NFTs on the Flow blockchain, and even set your own requirements when establishing which users will be able to participate in the drop.

If you are interested in digging in deeper, please check out [Drizzle’s Github page](https://github.com/33-Labs/drizzle) for sample transactions on how to create an airdrop, determine who’s eligible for the drop,  and more.

## Demand

We usually recommend starting the tokenomics work by defining the vectors of demand for your token. ** Creating supply is easy, creating demand is hard.**

_How will you generate sustainable demand for your tokens?_

When thinking about the demand vectors for your token, think about the benefits you are providing with your token, and how your tokens can be used to pay for these benefits. Conceptually, the actions that provide the most value/enjoyment to your users should be where the demand for your token should be the highest. 

Let’s use an example to dig further into this. 

Your dApp is a racing car game. Through user testing, you notice that users spend a lot more time playing the game once they start upgrading their vehicles. Naturally, you decide to require your own token to pay for such upgrades. Did you just create net new demand for your token?

The answer is, it depends on where those spent tokens go:

- If the dApp collects the tokens as payments, and uses those as revenue to finance further development, you have not created any demand. Indeed:
  - The user bought your tokens on an exchange
  - The user sent the dApp the tokens to purchase the upgrades
  - The dApp sold these tokens on an exchange to finance its activity
  - Net net, a token was bought, a token was sold, nothing has changed!

If some or all of the tokens spent by users are destroyed or placed in long-term holds, then you have created net new demand. Remember, the more intense the token supply is, the stronger your demand mechanisms will need to be.

By matching net new supply (aka faucets) with net new demand (aka sink) mechanisms like burning or long-term locking, you will then be able to keep your supply and demand balance in check which will go a long way to reduce the long-term volatility of your token.


## One Token vs. Two Token Model


|     |  One Token Model   | Two Token Model |
| --- | --- | --- |
|  Pros   |  <ul><li>Easier to launch</li><li>Only one supply/demand model to optimize for</li></ul>   | <ul><li>Ability to segregate the distribution strategies to suit the purpose (e.g.,  currency vs governance)</li></ul>     |
|  Cons   |  <ul><li>May limit accessibility of the token to target audience</li></ul>   | <ul><li>Contagion risk: if token1 has poor S/D dynamics, may take token2 with it</li></ul>     |


While a two-token model can work if done properly, many dApps have proven in the past that this is a tough feat to achieve.

As mentioned earlier, dual-token models are made of one currency token for which supply can grow indefinitely and one governance token for which supply is fixed. Dapps often make the mistake to concentrate value capture towards the governance token and consider the currency token as an afterthought. The very real risk of such a construct is that the currency token starts suffering from hyperinflation and enters a death spiral, forming a sort of black hole that swallows everything around it: governance token first, and then currency token after.

However, there are precedents that have launched a dual-token model successfully. MakerDAO, for one, is a great example of this. 

[MakerDAO](https://makerdao.com/en/) is an open-source project on the Ethereum blockchain and DAO (Decentralized Autonomous Organization) that manages the Maker Protocol and the MKR and DAI currencies. While MKR is the governance token that gives holders executive voting and governance polling rights for all things related to the Maker Protocol (and thus the DAI token), the DAI stablecoin acts as a decentralized, unbiased, collateral-backed cryptocurrency that is soft-pegged to the US Dollar. 

MKR holders manage the Maker Protocol and the financial risks of DAI to ensure its stability, transparency, and overall efficiency. MKR voting weight is designed to be proportional to the amount of MKR a voter stakes in the voting contract, and voting rights in return allow holders to decide on key parameters of the DAI stablecoin, like stability fees and collateral types/rates. 

DAI’s first mover status, and its lack of off-market yield opportunities (like the ones offered on UST) have undoubtedly been the bedrock of DAI/MKR success. DAI careful supply scaling - by adding collateral assets slowly and thoughtfully - have allowed DAI to maintain its peg without threatening the stability of its ecosystem.

While designing a successful dual-token model can be challenging, we cannot repeat this enough: if you do not do the necessary prep work on how to best balance your supply and demand, then the market will eventually find this balance for you.

## Step 1: Token Allocation

### Industry Standards
While there are a number of ways you can split your token allocation. We have recorded for you the range we typically see across the industry:

- **Community**: 40-75%
- **Public Sales**: 0-10%
- **Airdrops**: 0-10%
- **Investors**: 5-15%
- **Team**: 5-20%
- **Advisors**: 0-5%

![token allocation](token-allocation.png)

Importantly, this type of pie chart only captures **half** of the allocation picture. The other half consists of showing how each slice of the pie receives that allocation **over time**. This is where vesting/unlock comes in. Typically we see, an allocation over time that looks something like this:

![token distribution](token-distribution.png)

In the example above, we’re using a 100 million fixed token supply model, and distributing the tokens on a 6-year timeline. The x-axis represents the years since launch, and the y-axis represents the token supply in circulation. As you can see, the number of tokens in circulating supply increases gradually over time and starts to taper off as we get closer to the 6-year mark. Token allocations for team members, investors, and advisors start vesting a year after launch at the cliff date, while airdrop, public sale, and community allocations unlock right at launch, at year zero.

Keep in mind that this is only an example, and there is no hard requirement to follow cliffs, multi-year unlocks, or any other locking/vesting features. These are just tools at your disposal that will allow you to fine tune the rate at which tokens enter the circulating supply.

## Private vs. Public Sales

A private sale is usually the first way a dApp fundraises, typically before a potential public fundraise. Not anyone can invest in a private sale - usually, anyone participating in these sales have conversed with and have some sort of relationship with the fundraising team. Investors in private sales are usually angel investors, VCs, family offices, or other investment funds.

In private sales, token sales can either take place on their own or alongside equity investments in the dApp. If a token sale is done alongside an equity investment, then a [SAFT](https://www.investopedia.com/terms/s/simple-agreement-future-tokens-saft.asp) (simple agreement for future token) is signed alongside a [SAFE](https://www.finra.org/investors/insights/safe-securities) (simple agreement for future equity). 

With a SAFT, the dApp team is agreeing to allocate a certain amount of tokens to investors alongside with an equity investment. In the case of a pre-existing token, the investor may agree to purchase the tokens at a discounted price. If the token has yet to launch, then both parties can work towards favorable terms.

The reasons for going private before a public sale are two-fold:

1) **Operationally**, it is much easier to handle a small number of investors,
2) **Logistically**, it is much less risky to face a handful of accredited investors than to face a myriad of retail investors located in multiple jurisdictions.

A public sale, on the other hand, is the first time a token can be purchased by the general public. Anyone interested in the token can purchase it through centralized platforms (a.k.a. ICO platforms) such as CoinList or TokenSoft or decentralized platforms (a.k.a. IDO) such as Blocto Launchpad or Metapier.

During a public sale, anyone purchasing a token is basically subscribing to buy a predetermined number of tokens at a specific price and signing a token purchase agreement, which is a contract with future rights to a specific unit of tokens on a future date.

## Token Sale: Dynamic vs. Fixed Price

A question that will invariably come up if you decide to undergo a token sale is what price you should sell your token at. 

There are two avenues you can take when it comes to determining the price at which your token will be sold during such a sale:

1) Dynamic price
2) Fixed price

When you choose to use a dynamic price, you are basically letting the market determine the price of your token. One of the most popular ways to achieve such price discovery is by holding a reverse dutch auction, during which time you are agreeing to sell a set amount of tokens, for which the initial bid price is set by the highest bidder. As bidding progresses, the bid price goes down until there are no more tokens left to sell. The last bid price is the final clearing price of the auction and all bidders receive their tokens at that set clearing price. 

If you choose to go with a fixed price for your launch, then you are setting the initial price. That initial price typical is obtained via a mix of:

  1) Analyzing the tokenomics of dApps with similar business models as yours. What does their market value look like? How does your project compare to it? From there, adjust for differences in market sizes and product offerings to estimate your market value and price.
  2) Using your last fundraise price (if you did conduct a fundraise) to help set your initial token price.

## ICO vs. IDO

An ICO (initial coin offering) is a popular method for fundraising involving the public sale of a token. Usually, in an ICO, tokens are sold to the public in exchange for stablecoins. The  process often involves creating a website for the token that includes the whitepaper and details of the token launch, followed by an intensive period of marketing and community engagement efforts to drum up pre-launch interest. The ICO platform is usually responsible for the operational aspects of the sale (KYC, payment rails, token allocation and tracking), while the dApp is responsible for marketing and community engagement.

An IDO (initial DEX offering), on the other hand, is a public sale that is made via a smart contract. While an IDO is a powerful tool for fundraising, remember that is not the same as getting listed on a DEX, which we will cover in the next section. You can easily organize your own IDO on Flow by using a Launchpad like [Metapier](https://docs.google.com/forms/d/1lP72QLwODk3_Yx5Zcy0LSWFAQ5n5tu6rFAPnTw-E4LU/viewform?edit_requested=true).

To illustrate an example of an IDO, let’s look at the launch of $BLT ([Blocto Token](https://token.blocto.app/)), the [Blocto](https://swap.blocto.app/#/IDO) app’s native token: 

When Blocto was initially launching their $BLT token, they conducted an IDO on their [launchpad](https://swap.blocto.app/#/IDO) that allowed any token buyers to see the terms and requirements for the token sale, and the details (number of tokens offered, sale terms, payment terms, and admission fees). From there, anyone interested in the IDO was able to buy a predetermined amount of $BLT tokens at the specified price. 

Since then, Blocto has [expanded its offerings](https://swap.blocto.app/#/IDO) to include IDOs for other tokens launching on Flow, such as $STARLY in addition to their own $BLT token. Another launchpad option on Flow is [Metapier](https://docs.google.com/forms/d/1lP72QLwODk3_Yx5Zcy0LSWFAQ5n5tu6rFAPnTw-E4LU/viewform?edit_requested=true), built by the team behind the ultra successful DoDo.

## Step 2: Token Distribution

Token distribution describes the process by which tokens allocated to various users during Step 1 get transferred to users’ wallets.

It is a common misconception to think that token distribution has to happen at the same time as token launch (the time at which the token starts trading on a CEX and/or DEX). In fact, we strongly recommend dApps to separate those steps. The logic behind this is that token distribution and token launch are significant events in the life of a dApp that need the full focus of the G2M team. 

Dapps often ask us how to keep distribution and launch separate in a world where anybody can start a new liquidity pool with a dApp token and FLOW. Indeed, the creation of such a liquidity pool would effectively get secondary trading going on the same day as the token distribution, thus preventing the dApp from taking things at their own speed. This is a major risk that can be managed with a bit of planning. Let us show you how.

## On-Chain vs. Off-Chain Distribution

There are two types of distribution you can choose:

1) **On-Chain Distribution**: the traditional way of distributing tokens. Tokens are transferred to users’ wallets on-chain.
2) **Off-Chain Distribution**: a mock distribution where tokens appear in the user’s wallet once they are connected to the dApp, but do not actually exist on-chain. The logic is similar to that of airline miles.

For an off-chain distribution, preventing users from sending their token to a DEX is easy, because tokens do not exist on-chain but only in a database run centrally by the dApp.

For an on-chain distribution, the objective is to let users spend the token on the dApp but forbid them to withdraw to any other address. This can be done on Flow by requiring a certain block height to be reached to unlock tokens on Flow. If interested in learning more about how you can build this into your smart contract, please reach out to the Flow team on [Discord](https://discord.com/invite/flow).  

## Vesting/Unlock Schedules

Distributions do not need to make all tokens allocated available immediately. That is where vesting/unlock schedules come in.

As mentioned in [Step 0: Prep Work](#step-0-prep-work), successful token launches achieve a balance between supply and demand early. Using an intentional vesting schedule for your token will allow you to fine-tune the rate at which new tokens enter the circulating supply, thereby helping you only introduce the quantity needed by your dApp at this point in time. 

How many tokens do you need circulating on the first day of launch to meet the forecasted demand? What about one week, one month, and one year post-launch? Figure out what circulating supply is actually needed by your dApp at these various dates, and from there, walk back the number of tokens that need to enter the circulating supply.

## Step 3: Token Launch

### Launching a Token: What Does It Mean?

Launching a token basically involves everything needed to get a token trading on a CEX and/or a DEX. This means figuring out what type of exchange to list on, what market makers to work with, if any, and plan for the changes for your dApp once your token is freely trading.
Exchange Listings

When it comes to listing on exchanges, you can choose to list on centralized exchanges (CEX), decentralized exchanges (DEX), or both.


|     |  CEX   | DEX |
| --- | --- | --- |
|  Pros   |  <ul><li>Increases the reach of your token</li><li>Easier for non-crypto users to discover and buy your token</li><li>Maximizes trading volumes</li><li>Makes price discovery more efficient</li><li>Brings legitimacy to your dApp</li></ul>   | <ul><li>Fast and easy launch</li><li>Users can buy tokens without KYC/ID verification</li></ul>     |
|  Cons   |  <ul><li>Takes more time to launch on a CEX</li><li>Longer due diligence process</li><li>Usually requires hiring a market maker</li><li>Might require paying a fee to the exchange</li></ul>   | <ul><li>Exposure to impermanent loss</li><li>Lower liquidity requirement compared to CEX</li><li>Lack of demonstrating KYC compliance</li></ul>     |

While listing on a DEX is very fast and easy, it is ultimately more beneficial to line up your listings and launch on CEXs on the same day as DEX launches. 

Being available on a variety of CEXs is very beneficial to increase the reach of your token, CEX makes price discovery more efficient, they also tends to increase trading volumes as CEX and DEX are constantly arbitraged against one another, finally many users look to the list of CEXs a token list on to get a sense of its legitimacy.

## DEX launches

Launching on a DEX simply means creating a liquidity pool that will hold a certain quantity of your token, as well as a certain quantity of another token of your choosing. On Flow, the most logical choice is to take advantage of FLOW’s pre-existing liquidity on BloctoSwap or IncrementFi.

The quantity of your token vs. the quantity of FLOW that you deposit will determine the initial price for your token. This is because liquidity pools assume equal USD value of each token. Thus, if you deposit $50,000 worth of FLOW in the pool and 10,000 of your own token, the initial price will start at $5 per token.

Of course, the price will not stay static! As users buy and sell your token, the inventory of both tokens will change, thereby changing the price of your token. For more details, you can read about AMMs here.

### Liquidity requirements

As described above, the price at which your token will trade will be determined by the quantity available in the pool vs. FLOW. Thus, the lower the quantity of the FLOW used to pair with your token, the more volatility your token will experience.

Let’s go through an example to clarify this, using an imaginary liquidity pool made of FLOW and a new token named TKN:
**FLOW/USD** = $2
**TKN/USD** = $1 

Liquidity pool **FLOW/TKN** is made of 5,000 **FLOW** and 10,000 **TKN**, for a Total Value Locked = 5,000 x $2 + 10,000 x $1 = $20,000

In the case of a constant product AMM, we have **x * y = k**, where **x** and **y** are the quantity of respectively **FLOW** and **TKN** in the liquidity pool.

k = 5,000 x 10,000 = 50,000,000 (k is a constant here).

Alice comes in to buy **TKN** with 2,500 **FLOW** tokens, the new **FLOW** inventory becomes 7,500 **FLOW** (2,500 new **FLOW** tokens + 5,000 original **FLOW** tokens). 

Now, let’s figure out the **TKN** inventory: 

**TKN** inventory = 50,000,000 / 7,500 **FLOW** = 6,666 **TKN** - or 3,334 **TKN** received by Alice in exchange for her 2,500 **FLOW**

This means that the user has paid 2,500 **FLOW** (equivalent to $5,000) to receive 3,334 **TKN**, which means that Alice bought **TKN** at $5,000 / 3,334 = $1.5 per **TKN**. This is 50% higher than the price Alice saw when browsing **TKN** on the DEX!

This price difference is called slippage, and is directly proportional to the size of the TVL in the pool.

As a result, we recommend dApps to launch a liquidity pool with at least $100,000 worth of tokens per side (i.e. a Total Value Locked of $200,000 at minimum). This means that the dApp should come up with $100,000 worth of FLOW prior to listing, which is not a trivial amount. Thankfully, a dApp can easily borrow FLOW while paying an interest rate in their own token using [boolean.xyz](https://docs.google.com/forms/d/e/1FAIpQLSeyMnRWSTtQv0YiK1-Qwc0xoKdBHFhVX3hQZk8s9BsT7-5LCQ/viewform).

### Do you need a Market Maker to be listed on a DEX?
While you do not necessarily need a Market Maker to create a liquidity pool (LP), remember that any liquidity deposited in an LP will have exposure to impermanent loss. And the greater the exposure, the greater the risk of impermanent loss. 

_Ask yourself_: are you okay with taking this risk, and what are the tradeoffs if you do decide to take it? This is a complex topic that will be the subject of a future post.

## CEX launches

### The role of Market-Makers
If you choose to list on a centralized exchange, then you will be required to hire a market maker, whose job will be to populate the order book of the various trading pairs supported on each CEX. Hiring a market-maker typically takes up to 6 weeks. 

### Exchange listing negotiations
Listing on a centralized exchange can take anywhere between 1 to 2 months between initial conversation and full due diligence. Typically exchanges will be interested in seeing your whitepaper, your effective token allocation, the vesting and unlock schedule for each category of holders of your token as well as any metric that captures the vibrancy and engagement of your community.

Some exchanges require payment of listing fees, but many do not. As a result, make sure that before agreeing to a listing fee you have a good understanding of the benefits you will gain from listing on a given exchange.

## Getting your Flow token created

While this guide does not cover the technicals of creating your fungible token, please find a couple of resources that may be helpful as you get ready to launch your token: 

- [Flow Token List](https://github.com/FlowFans/flow-token-list) - how to add a token to the Flow native token list
- [Flowdiver Request Form](https://docs.google.com/forms/d/e/1FAIpQLSdMiIkj2goF3Ib7wJHRb-YNvruwBghq1NP1IOfz4p2smIFp0w/viewform) | Token Metadata - please fill this out to update your token metadata on Flowdiver
- [Flow Developer Portal](https://developers.flow.com) - documentation, guides, and resources for developers building on Flow

## Final Words

We have given in this guide a number of guidelines and templates to help you get around the cold start problem. You should not consider them as hard rules that you have to follow to ensure a successful token launch. Web 3.0 allows a near infinite creativity space, and we hope you take maximum advantage of that, especially when designing your tokenomics. If you have an idea that sounds crazy, or that you are concerned it might not work, we would love to hear about it and brainstorm with you.

Building a token on Flow unleashes a world of opportunities - for your users, for your team, and for those that believe in bringing your vision to life in a decentralized, permissionless way. Moreover, creating a token for your community is an incredible opportunity to create a macroeconomic landscape in a micro setting. This is a great way to test out what works best for your community and your product, and put the power back in the hands of your largest supporters. 
---
sidebar_position: 1
---

import DocCardList from '@theme/DocCardList';
import { useDocsSidebar, isSamePath } from '@docusaurus/theme-common/internal';
import { useLocation } from '@docusaurus/router';

<DocCardList items={useDocsSidebar().items.filter(item => !isSamePath(item.href, useLocation().pathname))}/>
---
sidebar_position: -1
---

# Developer Onboarding

This guide is for software development teams that are planning to build a decentralized application (dapp) on the Flow blockchain. The goal of this guide is to help you make key decisions that will affect the scope and structure of your dapp before you start building.

This document assumes that you have a basic understanding of general blockchain systems, including smart contracts, public-key cryptography, accounts, and transactions.
---
title: Mainnet Account Setup Guidelines
sidebar_label: Mainnet Account Setup
sidebar_position: 5
---

In order to deploy your smart contracts to the mainnet, you need to register, fund, and setup a new account.

> **Note**: This account will be used for production purposes. Make sure you handle keys appropriately. Using a Key Management Service is the best practice. By default, this command generates an ECDSA key pair on the P-256 curve. Keep in mind the CLI is intended for development purposes only and is not recommended for production use. Handling keys using a Key Management Service is the best practice.

## Create an account
You can easily create a new funded account on mainnet using the Flow CLI. You only need to run a single command `flow accounts create` and select a name for the account and the network, which in this case is `mainnet`. After that the account private key is saved into a seperate file called `{name}.pkey`. We advice switching to KMS system for production use which you [can read more about here](../tools/flow-cli/flow.json/configuration.md#advanced-format-1).

```
flow accounts create

Enter an account name: mike
✔ Testnet

🎉 New account created with address 0x77e6ae4c8c2f1dd6 and name mike on Testnet network.

Here’s a summary of all the actions that were taken:
 - Added the new account to flow.json.
 - Saved the private key to mike.pkey.
 - Added mike.pkey to .gitignore.
```


Read more about the command in the [CLI account creation documentation](../tools/flow-cli/accounts/create-accounts.md#interactive-mode).
---
title: Smart Contracts for Flow Dapps
sidebar_label: Smart Contracts
---

At its core, a decentralized application is defined by the [smart contracts](https://en.wikipedia.org/wiki/Smart_contract) it uses on the blockchain. Rather than relying on centralized application servers and databases, dapps model their core application logic using smart contracts, often referred to as the “on-chain” code.

It is therefore helpful to develop a clear model for your dapp that takes into account the data and logic that will exist in your smart contracts. In particular, it is important to differentiate between the parts of your dapp that must live on chain and those that should live off chain.

## How to Write Smart Contracts on Flow

Smart contracts on the Flow blockchain are implemented in [Cadence](https://github.com/onflow/cadence), a resource-oriented programming language specifically designed for smart contract development.

### Onboard to Cadence

To get started with Cadence, we recommended covering the introductory tutorials available in the [Flow Playground](https://play.onflow.org/), a simple web IDE designed for learning Cadence.

### Configure Your Local Environment

To build confidently, you will want to set up the appropriate local environment and have an adequate test suite to ensure your smart contracts operate as intended. To do this, familiarize yourself with the following tools:

- [Flow CLI](../tools/flow-cli/): A utility to directly interact with the chain and manage accounts and contracts.
- [Flow Emulator](../tools/emulator/): A lightweight server that simulates the Flow blockchain (strongly recommended during development).
- [Flow Dev Wallet](https://github.com/onflow/fcl-dev-wallet/): A utility to simulate user wallets in development.
- [Visual Studio Code Extension](../tools/vscode-extension/): An IDE integration for developing smart contracts.
- [JS Testing Framework](https://github.com/onflow/flow-js-testing): A framework to test your smart contracts.

## Storing Data on Flow

All dapps will store important data on the blockchain, and some more than others -- especially NFT dapps. You’ll want to consider the following when storing data on the Flow blockchain.

### What does your data need to represent?

Permanence is a key property of blockchains; users trust that the data they store will continue to exist for years to come, and this is a defining characteristic of assets like NFTs. Therefore, well-designed digital assets store the information necessary to retain their value without external dependencies.

### Storage Limits & Fees

However, there are practical constraints to storing data on a blockchain. Developer and user accounts must retain a small amount of FLOW tokens, known as the storage fee, for bytes of data stored in their accounts. The minimum storage fee will grant each account a minimum storage amount. If an account holds assets that demand more bytes of storage, the account will need to retain more FLOW tokens to increase the storage amount according to Flow's [fee schedule](../build/basics/fees.md#fees). A more compact data model can keep storage needs down. \
 \
Furthermore, a single Flow transaction has a size limit of 4MB, which limits the rate at which large amounts of data can be transferred to the blockchain.

Lastly, a blockchain is not a content delivery network and therefore cannot serve media assets, such as videos, at the speeds expected by modern applications.

For these reasons, it usually isn’t practical to store large media assets such as videos and high-definition images on the Flow blockchain. Instead, consider using an external storage solution.

### External Storage Networks

Decentralized storage networks such as IPFS allow you to store large digital assets off chain, but without relying on centralized servers. Rather than saving an entire asset to the Flow blockchain, you can save the content hash (known as a CID on IPFS) on the blockchain and then store the source file off-chain. This way, users can verify that the media file matches the digital asset.

IPFS files can be uploaded via a pinning service such as Pinata; see their [NFT tutorial](https://medium.com/pinata/how-to-create-nfts-like-nba-top-shot-with-flow-and-ipfs-701296944bf) for an example of how to use Pinata with Flow.

It’s worth noting that IPFS files are served through [gateways](https://docs.ipfs.io/concepts/ipfs-gateway/), many of which leverage caching to provide fast response times. Cloudflare provides a [public IPFS Gateway](https://developers.cloudflare.com/distributed-web/ipfs-gateway), and Pinata also supports [dedicated gateways with custom domains](https://medium.com/pinata/announcing-dedicated-ipfs-gateways-60f599949ce).

## Using Existing Standards

The Flow blockchain has existing smart contract standards for both fungible and non-fungible tokens that you should implement when building your contracts.

### Non-Fungible Tokens (NFTs)

All NFTs on the Flow blockchain implement the [NonFungibleToken](../references/core-contracts/08-non-fungible-token.md) interface, allowing them to be compatible with wallets, marketplaces and other cross-app experiences.

- [Non-Fungible Token (NFT) contract interface](../references/core-contracts/08-non-fungible-token.md)

### NFT Sales and Trading

Flow has a standard contract to facilitate both the direct sales and peer-to-peer trading of NFTs. The NFT storefront contract is useful for dapps that want to provide an NFT marketplace experience.

- [NFT Storefront contract](https://github.com/onflow/nft-storefront)

### Fungible Tokens

Fungible tokens (i.e. coins, currencies) on the Flow blockchain, including the default cryptocurrency token FLOW, implement the [FungibleToken](../references/core-contracts/02-fungible-token.md) interface.

- [Fungible Token contract interface](../references/core-contracts/02-fungible-token.md)
---
title: Testnet Testing Guidelines
sidebar_label: Testnet Testing
sidebar_position: 4
---

It is critical to test your applications and contracts thoroughly on the testnet as part of your road to the mainnet. Testing will help you understand how to create stable and robust applications using the Flow development stack.

## Testing Your Application

### Automated Testing of Contract Code

All contracts should include test coverage for _all contract functions_. Make sure you've accounted for success and failure cases appropriately.

Tests should also be runnable in automated environments (CI). You can use the [JavaScript testing framework](https://github.com/onflow/flow-js-testing) to create tests for your smart contract code.

### Stress Testing Live Applications Before Mainnet

Once you deployed your application to the testnet, you should record how your application handles non-trivial amounts of traffic to ensure there are no issues.

You should also get familiar with the [Cadence anti-patterns](https://cadence-lang.org/docs/anti-patterns) to avoid avoid problematic or unintended behavior.
---
title: Flow User Accounts & Wallets
sidebar_label: User Accounts & Wallets
---

Each Flow blockchain user owns an account that holds their digital assets (e.g. currencies or NFTs). A Flow account is identified by an 8-byte address and is controlled by one or more public/private key pairs. Whoever has access to the private key can sign a transaction to access the assets inside the account.

## Interacting with User Accounts & Wallets

Most blockchain users manage their accounts with the help of a crypto wallet, and the same is true on Flow. In short, a wallet is a piece of software or hardware that stores the private key associated with an account.

When talking about user accounts and wallets, we use the term _custodian_ to refer to the party that stores the private key for a user account. Hardware wallets, like those provided by Ledger, allow users to be their own custodian, whereas hosted software wallets, like those provided by Dapper Wallet, can act as the custodian on behalf of the user.

## Connecting Wallets & Dapps

Dapps allow users to store their data in their own accounts, rather than a centralized database. But in order for dapps to work, they still need to be able to securely access a user’s account from time to time.

For example, to purchase an NFT from an artist on the [Versus auction website](https://www.versus-flow.art/), a user will need to send a transaction that transfers funds from their account to the Versus contract account. This transaction is prepared and initialized by the Versus application before being approved by the user.

### Flow Client Library (FCL)

The Flow Client Library (FCL) is a framework that [standardizes and simplifies the way dapps and wallets interact with each other](https://www.onflow.org/post/inside-flow-the-power-of-simplicity-with-fcl). By using FCL, a dapp developer can support a variety of wallet providers with a few lines of code.

FCL provides the following functionality out of the box:

* User registration and login
* Transaction signing and submission

FCL-powered dapps are free to construct transactions which are then passed to the user’s wallet for signing, all without gaining access to the user’s private key. Users can onboard themselves to any FCL-enabled dapp in the Flow blockchain ecosystem and can use the same wallet provider across different dapps.

In addition to the above, FCL-powered dapps have the following benefits:

* **Network effects:** FCL is an evolving ecosystem that will support additional wallets, payment providers and identity management solutions as it grows. FCL-powered dapps and their users will benefit directly from this growth.
* **Reduced technical complexity:** your dapp does not need to secure private keys or sign transactions, and can instead rely on 3rd-party wallet providers to manage this complexity.
* **Fee payments:** in many cases, wallet providers will cover storage and account creation fees for their wallet users, meaning you don’t have to.

_Sample interaction: a user clicks a button to purchase an NFT from your storefront. Your dapp submits a transaction request to the user’s wallet. The wallet displays a prompt to the user, asking them to approve or deny the transaction. After approval, the wallet signs and submits the transaction, then delivers the result to your dapp._

### Dapp Custody

If your dapp does not use FCL, you will need to run your own wallet infrastructure and act as the custodian for your users, rather than relying on 3rd-party wallets. In this case, you as the dapp developer are responsible for securing your users’ private keys.

Under this model, the accounts in your control can only be used with your application. Users will need separate accounts for other applications.

_Sample interaction: a user clicks a button to purchase an NFT from your storefront. This sends an API request to your dapp’s backend, which holds the user’s private key. Your dapp backend then signs and submits a transaction on behalf of the user._

Should your dapp take custody of user accounts? In most cases, no. We hope that you are able to focus on the experience you wish to create, without the complexity, legal responsibility, and limitations that come with being a custodian. We also want users to be able to freely experience many dapps without needing to manage a separate account for each.

With that said, there are circumstances where you may want to be a custodian:

* You are building an dapp on a platform not yet supported by FCL wallets (e.g. mobile, game console).
* You have business or product needs that necessitate a custodial approach (e.g. fraud protection, users who want a custodial option).

If you do need to build your own wallet, we recommend using the [open-source Wallet API](https://github.com/flow-hydraulics/flow-wallet-api), a service you can deploy as part of your infrastructure to manage blockchain accounts and keys.

### Recommendation

Unless you have a specific use case that requires you to manage your users’ private keys, we recommend building an FCL-powered dapp that connects with existing wallet providers: 

* [Blocto](https://blocto.portto.io/en/) is a web, iOS and Android wallet that powers FCL-enabled applications like [Vault by CNN](https://vault.cnn.com/), [MotoGP Ignition](https://motogp-ignition.com/) and [Versus](https://www.versus-flow.art/).
* [Dapper Wallet](https://www.meetdapper.com/) (used by [NBA Top Shot](https://nbatopshot.com/)) is an FCL-compatible wallet that will soon become available to more Flow developers.
