This is a list of example smart contract code written in Cadence. Each contract is inside "double quotations" and separated by -------

"/*
Capsuletest

This is the contract for Capsuletest NFTs!

This was implemented using Niftory interfaces. For full details on how this
contract functions, please see the Niftory and NFTRegistry contracts.

*/

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import ViewResolver from 0x1d7e57aa55817448

import MutableMetadata from 0x7ec1f607f0872a9e
import MutableMetadataTemplate from 0x7ec1f607f0872a9e
import MutableMetadataSet from 0x7ec1f607f0872a9e
import MutableMetadataSetManager from 0x7ec1f607f0872a9e
import MetadataViewsManager from 0x7ec1f607f0872a9e

import NiftoryNonFungibleToken from 0x7ec1f607f0872a9e
import NiftoryNFTRegistry from 0x7ec1f607f0872a9e

import NiftoryMetadataViewsResolvers from 0x7ec1f607f0872a9e
import NiftoryNonFungibleTokenProxy from 0x7ec1f607f0872a9e

pub contract Capsuletest: NonFungibleToken, ViewResolver {

  // ========================================================================
  // Constants
  // ========================================================================

  // Suggested paths where collection could be stored
  pub let COLLECTION_PRIVATE_PATH: PrivatePath
  pub let COLLECTION_PUBLIC_PATH: PublicPath
  pub let COLLECTION_STORAGE_PATH: StoragePath

  // Accessor token to be used with NiftoryNFTRegistry to retrieve
  // meta-information about this NFT project
  pub let REGISTRY_ADDRESS: Address
  pub let REGISTRY_BRAND: String

  // ========================================================================
  // Attributes
  // ========================================================================

  // Arbitrary metadata for this NFT contract
  pub var metadata: AnyStruct?

  // Number of NFTs created
  pub var totalSupply: UInt64

  // ========================================================================
  // Contract Events
  // ========================================================================

  // This contract was initialized
  pub event ContractInitialized()

  // A withdrawal of NFT `id` has occurred from the `from` Address
  pub event Withdraw(id: UInt64, from: Address?)

  // A deposit of an NFT `id` has occurred to the `to` Address
  pub event Deposit(id: UInt64, to: Address?)

  ///////////////////////////////////////////////////////////////////////////

  // Contract metadata was modified
  pub event ContractMetadataUpdated()

  // Metadata Views Manager was locked
  pub event MetadataViewsManagerLocked()

  // Metadata Views Resolver was added
  pub event MetadataViewsResolverAdded(type: Type)

  // Metadata Views Resolver was removed
  pub event MetadataViewsResolverRemoved(type: Type)

  // Set Manager Name or Description updated
  pub event SetManagerMetadataUpdated()

  // Set added to Set Manager
  pub event SetAddedToSetManager(setID: Int)

  ///////////////////////////////////////////////////////////////////////////

  // Set `setId` was locked (no new templates can be added)
  pub event SetLocked(setId: Int)

  // The metadata for Set `setId` was locked and cannot be modified
  pub event SetMetadataLocked(setId: Int)

  // Set `setId` was modified
  pub event SetMetadataModified(setId: Int)

  // A new Template `templateId` was added to Set `setId`
  pub event TemplateAddedToSet(setId: Int, templateId: Int)

  ///////////////////////////////////////////////////////////////////////////

  // Template `templateId` was locked in Set `setId`, which disables minting
  pub event TemplateLocked(setId: Int, templateId: Int)

  // Template `templateId` of Set `setId` had it's maxMint set to `maxMint`
  pub event TemplateMaxMintSet(setId: Int, templateId: Int, maxMint: UInt64)

  // Template `templateId` of Set `setId` has minted NFT with serial `serial`
  pub event NFTMinted(id: UInt64, setId: Int, templateId: Int, serial: UInt64)

  ///////////////////////////////////////////////////////////////////////////

  // The metadata for NFT/Template `templateId` of Set `setId` was locked
  pub event NFTMetadataLocked(setId: Int, templateId: Int)

  // The metadata for NFT/Template `templateId` of Set `setId` was modified
  pub event NFTMetadataModified(setId: Int, templateId: Int)

  ///////////////////////////////////////////////////////////////////////////

  // NFT `serial` from Template `templateId` of Set `setId` was burned
  pub event NFTBurned(setId: Int, templateId: Int, serial: UInt64)

  // ========================================================================
  // NFT
  // ========================================================================

  pub resource NFT:
    NonFungibleToken.INFT,
    MetadataViews.Resolver,
    NiftoryNonFungibleToken.NFTPublic
  {
    pub let id: UInt64
    pub let setId: Int
    pub let templateId: Int
    pub let serial: UInt64

    pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
      return Capsuletest.contract()
    }

    pub fun set(): &MutableMetadataSet.Set{MutableMetadataSet.Public} {
      return self
        .contract()
        .getSetManagerPublic()
        .getSet(self.setId)
    }

    pub fun metadata(): &MutableMetadata.Metadata{MutableMetadata.Public} {
      return self
        .set()
        .getTemplate(self.templateId)
        .metadata()
    }

    pub fun getViews(): [Type] {
      return self
        .contract()
        .getMetadataViewsManagerPublic()
        .getViews()
    }

    pub fun resolveView(_ view: Type): AnyStruct? {
      let nftRef = &self as &{NiftoryNonFungibleToken.NFTPublic}
      return self
        .contract()
        .getMetadataViewsManagerPublic()
        .resolveView(view: view, nftRef: nftRef)
    }

    init(setId: Int, templateId: Int, serial: UInt64) {
      self.id = Capsuletest.totalSupply
      Capsuletest.totalSupply =
        Capsuletest.totalSupply + 1
      self.setId = setId
      self.templateId = templateId
      self.serial = serial
    }

    destroy() {
      emit NFTBurned(
        setId: self.setId,
        templateId: self.templateId,
        serial: self.serial
      )
    }
  }

  // ========================================================================
  // Collection
  // ========================================================================

  pub resource Collection:
    NonFungibleToken.Provider,
    NonFungibleToken.Receiver,
    NonFungibleToken.CollectionPublic,
    MetadataViews.ResolverCollection,
    NiftoryNonFungibleToken.CollectionPublic,
    NiftoryNonFungibleToken.CollectionPrivate
  {
    pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

    pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
      return Capsuletest.contract()
    }

    pub fun getIDs(): [UInt64] {
      return self.ownedNFTs.keys
    }

    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
      pre {
        self.ownedNFTs[id] != nil : "NFT "
          .concat(id.toString())
          .concat(" does not exist in collection.")
      }
      return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
    }

    pub fun borrow(id: UInt64): &NFT{NiftoryNonFungibleToken.NFTPublic} {
      pre {
        self.ownedNFTs[id] != nil : "NFT does not exist in collection."
      }
      let nftRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let fullNft = nftRef as! &NFT
      return fullNft
    }

    pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {
      pre {
        self.ownedNFTs[id] != nil : "NFT does not exist in collection."
      }
      let nftRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let fullNft = nftRef as! &NFT
      return fullNft
    }

    pub fun deposit(token: @NonFungibleToken.NFT) {
      let token <- token as! @Capsuletest.NFT
      let id: UInt64 = token.id
      let oldToken <- self.ownedNFTs[id] <- token
      emit Deposit(id: id, to: self.owner?.address)
      destroy oldToken
    }

    pub fun depositBulk(tokens: @[NonFungibleToken.NFT]) {
      while tokens.length > 0 {
        let token <- tokens.removeLast() as! @Capsuletest.NFT
        self.deposit(token: <-token)
      }
      destroy tokens
    }

    pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
      pre {
        self.ownedNFTs[withdrawID] != nil
          : "NFT "
            .concat(withdrawID.toString())
            .concat(" does not exist in collection.")
      }
      let token <-self.ownedNFTs.remove(key: withdrawID)!
      emit Withdraw(id: token.id, from: self.owner?.address)
      return <-token
    }

    pub fun withdrawBulk(withdrawIDs: [UInt64]): @[NonFungibleToken.NFT] {
      let tokens: @[NonFungibleToken.NFT] <- []
      while withdrawIDs.length > 0 {
        tokens.append(<- self.withdraw(withdrawID: withdrawIDs.removeLast()))
      }
      return <-tokens
    }

    init() {
      self.ownedNFTs <- {}
    }

    destroy() {
      destroy self.ownedNFTs
    }
  }

  pub fun createEmptyCollection(): @Collection {
    return <-create Collection()
  }

  // ========================================================================
  // Manager
  // ========================================================================

  pub resource Manager:
    NiftoryNonFungibleToken.ManagerPublic,
    NiftoryNonFungibleToken.ManagerPrivate
  {
    // ========================================================================
    // Public
    // ========================================================================

    pub fun metadata(): AnyStruct? {
      return Capsuletest.metadata
    }

    pub fun getSetManagerPublic():
      &MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public}
    {
      return NiftoryNFTRegistry
        .getSetManagerPublic(
          Capsuletest.REGISTRY_ADDRESS,
          Capsuletest.REGISTRY_BRAND
        )
    }

    pub fun getMetadataViewsManagerPublic():
      &MetadataViewsManager.Manager{MetadataViewsManager.Public}
    {
      return NiftoryNFTRegistry
        .getMetadataViewsManagerPublic(
          Capsuletest.REGISTRY_ADDRESS,
          Capsuletest.REGISTRY_BRAND
        )
    }

    pub fun getNFTCollectionData(): MetadataViews.NFTCollectionData {
      return NiftoryNFTRegistry
        .buildNFTCollectionData(
          Capsuletest.REGISTRY_ADDRESS,
          Capsuletest.REGISTRY_BRAND,
          (fun (): @NonFungibleToken.Collection {
            return <-Capsuletest.createEmptyCollection()
          })
        )
    }

    // ========================================================================
    // Contract metadata
    // ========================================================================

    pub fun modifyContractMetadata(): auth &AnyStruct {
      emit ContractMetadataUpdated()
      let maybeMetadata = Capsuletest.metadata
      if maybeMetadata == nil {
        let blankMetadata: {String: String} = {}
        Capsuletest.metadata = blankMetadata
      }
      return (&Capsuletest.metadata as auth &AnyStruct?)!
    }

    pub fun replaceContractMetadata(_ metadata: AnyStruct?) {
      emit ContractMetadataUpdated()
      Capsuletest.metadata = metadata
    }

    // ========================================================================
    // Metadata Views Manager
    // ========================================================================

    access(self) fun _getMetadataViewsManagerPrivate():
      &MetadataViewsManager.Manager{MetadataViewsManager.Private}
    {
      let record =
        NiftoryNFTRegistry.getRegistryRecord(
          Capsuletest.REGISTRY_ADDRESS,
          Capsuletest.REGISTRY_BRAND
        )
      let manager =
        Capsuletest.account
          .getCapability<&MetadataViewsManager.Manager{MetadataViewsManager.Private}>(
            record.metadataViewsManager.paths.private
          ).borrow()!
      return manager
    }

    pub fun lockMetadataViewsManager() {
      self._getMetadataViewsManagerPrivate().lock()
      emit MetadataViewsManagerLocked()
    }

    pub fun setMetadataViewsResolver(
      _ resolver: AnyStruct{MetadataViewsManager.Resolver}
    ) {
      self._getMetadataViewsManagerPrivate().addResolver(resolver)
      emit MetadataViewsResolverAdded(type: resolver.type)
    }

    pub fun removeMetadataViewsResolver(_ type: Type) {
      self._getMetadataViewsManagerPrivate().removeResolver(type)
      emit MetadataViewsResolverRemoved(type: type)
    }

    // ========================================================================
    // Set Manager
    // ========================================================================

    access(self) fun _getSetManagerPrivate():
      &MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public, MutableMetadataSetManager.Private}
    {
      let record =
        NiftoryNFTRegistry.getRegistryRecord(
          Capsuletest.REGISTRY_ADDRESS,
          Capsuletest.REGISTRY_BRAND
        )
      let setManager =
        Capsuletest.account
          .getCapability<&MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public, MutableMetadataSetManager.Private}>(
            record.setManager.paths.private
          ).borrow()!
      return setManager
    }

    pub fun setMetadataManagerName(_ name: String) {
      self._getSetManagerPrivate().setName(name)
      emit SetManagerMetadataUpdated()
    }

    pub fun setMetadataManagerDescription(_ description: String) {
      self._getSetManagerPrivate().setDescription(description)
      emit SetManagerMetadataUpdated()
    }

    pub fun addSet(_ set: @MutableMetadataSet.Set) {
      let setManager = self._getSetManagerPrivate()
      let setId = setManager.numSets()
      setManager.addSet(<-set)
      emit SetAddedToSetManager(setID: setId)
    }

    // ========================================================================
    // Set
    // ========================================================================

    access(self) fun _getSetMutable(_ setId: Int):
      &MutableMetadataSet.Set{MutableMetadataSet.Private,
        MutableMetadataSet.Public} {
      return self._getSetManagerPrivate().getSetMutable(setId)
    }

    pub fun lockSet(setId: Int) {
      self._getSetMutable(setId).lock()
      emit SetLocked(setId: setId)
    }

    pub fun lockSetMetadata(setId: Int) {
      self._getSetMutable(setId).metadataMutable().lock()
      emit SetMetadataLocked(setId: setId)
    }

    pub fun modifySetMetadata(setId: Int): auth &AnyStruct {
      emit SetMetadataModified(setId: setId)
      return self._getSetMutable(setId).metadataMutable().getMutable()
    }

    pub fun replaceSetMetadata(setId: Int, new: AnyStruct) {
      self._getSetMutable(setId).metadataMutable().replace(new)
      emit SetMetadataModified(setId: setId)
    }

    pub fun addTemplate(
      setId: Int,
      template: @MutableMetadataTemplate.Template
    ) {
      let set = self._getSetMutable(setId)
      let templateId = set.numTemplates()
      set.addTemplate(<-template)
      emit TemplateAddedToSet(setId: setId, templateId: templateId)
    }

    // ========================================================================
    // Minting
    // ========================================================================

    access(self) fun _getTemplateMutable(_ setId: Int, _ templateId: Int):
      &MutableMetadataTemplate.Template{MutableMetadataTemplate.Public,
        MutableMetadataTemplate.Private} {
      return self._getSetMutable(setId).getTemplateMutable(templateId)
    }

    pub fun lockTemplate(setId: Int, templateId: Int) {
      self._getTemplateMutable(setId, templateId).lock()
      emit TemplateLocked(setId: setId, templateId: templateId)
    }

    pub fun setTemplateMaxMint(setId: Int, templateId: Int, max: UInt64) {
      self._getTemplateMutable(setId, templateId).setMaxMint(max)
      emit TemplateMaxMintSet(
        setId: setId,
        templateId: templateId,
        maxMint: max
      )
    }

    pub fun mint(setId: Int, templateId: Int): @NonFungibleToken.NFT {
      let template = self._getTemplateMutable(setId, templateId)
      template.registerMint()
      let serial = template.minted()
      let nft <-create NFT(
        setId: setId,
        templateId: templateId,
        serial: serial
      )
      emit NFTMinted(
        id: nft.id,
        setId: setId,
        templateId: templateId,
        serial: serial
      )
      return <-nft
    }

    pub fun mintBulk(
      setId: Int,
      templateId: Int,
      numToMint: UInt64,
    ): @[NonFungibleToken.NFT] {
      pre {
        numToMint > 0: "Must mint at least one NFT"
      }
      let template = self._getTemplateMutable(setId, templateId)
      let nfts: @[NonFungibleToken.NFT] <- []
      var leftToMint = numToMint
      while leftToMint > 0 {
        template.registerMint()
        let serial = template.minted()
        let nft <-create NFT(
          setId: setId,
          templateId: templateId,
          serial: serial
        )
        emit NFTMinted(
          id: nft.id,
          setId: setId,
          templateId: templateId,
          serial: serial
        )
        nfts.append(<-nft)
        leftToMint = leftToMint - 1
      }
      return <-nfts
    }

    // ========================================================================
    // NFT metadata
    // ========================================================================

    access(self) fun _getNFTMetadata(_ setId: Int, _ templateId: Int):
      &MutableMetadata.Metadata{MutableMetadata.Public,
        MutableMetadata.Private
      } {
        return self._getTemplateMutable(setId, templateId).metadataMutable()
    }

    pub fun lockNFTMetadata(setId: Int, templateId: Int) {
      self._getNFTMetadata(setId, templateId).lock()
      emit NFTMetadataLocked(setId: setId, templateId: templateId)
    }

    pub fun modifyNFTMetadata(setId: Int, templateId: Int): auth &AnyStruct {
      emit NFTMetadataModified(setId: setId, templateId: templateId)
      return self._getNFTMetadata(setId, templateId).getMutable()
    }

    pub fun replaceNFTMetadata(setId: Int, templateId: Int, new: AnyStruct) {
      self._getNFTMetadata(setId, templateId).replace(new)
      emit NFTMetadataModified(setId: setId, templateId: templateId)
    }
  }

  // ========================================================================
  // Contract functions
  // ========================================================================

  pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
    return NiftoryNFTRegistry
      .getNFTManagerPublic(
        Capsuletest.REGISTRY_ADDRESS,
        Capsuletest.REGISTRY_BRAND
      )
  }

  pub fun getViews(): [Type] {
    let possibleViews = [
      Type<MetadataViews.NFTCollectionDisplay>(),
      Type<MetadataViews.ExternalURL>()
    ]
    let views: [Type] = [Type<MetadataViews.NFTCollectionData>()]

    let viewManager = self.contract().getMetadataViewsManagerPublic()
    for view in possibleViews {
      if viewManager.inspectView(view: view) != nil {
        views.append(view)
      }
    }
    return views
  }

  pub fun resolveView(_ view: Type): AnyStruct? {
    let viewManager = self.contract().getMetadataViewsManagerPublic()
    switch view {

      case Type<MetadataViews.NFTCollectionData>():
        return self.contract().getNFTCollectionData()

      case Type<MetadataViews.NFTCollectionDisplay>():
        let maybeView = viewManager.inspectView(
          view: Type<MetadataViews.NFTCollectionDisplay>()
        )
        if maybeView == nil {
          return nil
        }
        let view = maybeView!

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver

          // External URL
          let externalURL = MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultExternalURLPrefix,
              uri: resolver.defaultExternalURL
            )
          )

          // Square image
          let squareImageURL = NiftoryMetadataViewsResolvers._prefixUri(
            allowedPrefixes:
              NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
            default: resolver.defaultSquareImagePrefix,
            uri: resolver.defaultSquareImage
          )
          let squareImageMediaType = resolver.defaultSquareImageMediaType
          let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: squareImageURL),
            mediaType: squareImageMediaType
          )

          // Banner image
          let bannerImageURL = NiftoryMetadataViewsResolvers._prefixUri(
            allowedPrefixes:
              NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
            default: resolver.defaultBannerImagePrefix,
            uri: resolver.defaultBannerImage
          )
          let bannerImageMediaType = resolver.defaultBannerImageMediaType
          let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
              url: bannerImageURL
            ),
            mediaType: bannerImageMediaType
          )

          return MetadataViews.NFTCollectionDisplay(
            name: resolver.defaultName,
            description: resolver.defaultDescription,
            externalURL: externalURL,
            squareImage: squareImage,
            bannerImage: bannerImage,
            socials: {}

          )
        }

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolverWithIpfsGateway>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolverWithIpfsGateway

          // External URL
          let externalURL = MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultExternalURLPrefix,
              uri: resolver.defaultExternalURL
            )
          )

          // Square image
          let squareImageURL = NiftoryMetadataViewsResolvers._useIpfsGateway(
            ipfsGateway: resolver.ipfsGateway,
            uri: NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultSquareImagePrefix,
              uri: resolver.defaultSquareImage
            )
        )
          let squareImageMediaType = resolver.defaultSquareImageMediaType
          let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: squareImageURL),
            mediaType: squareImageMediaType
          )

          // Banner image
          let bannerImageURL = NiftoryMetadataViewsResolvers._useIpfsGateway(
            ipfsGateway: resolver.ipfsGateway,
            uri: NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultBannerImagePrefix,
              uri: resolver.defaultBannerImage
            )
          )
          let bannerImageMediaType = resolver.defaultBannerImageMediaType
          let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
              url: bannerImageURL
            ),
            mediaType: bannerImageMediaType
          )

          return MetadataViews.NFTCollectionDisplay(
            name: resolver.defaultName,
            description: resolver.defaultDescription,
            externalURL: externalURL,
            squareImage: squareImage,
            bannerImage: bannerImage,
            socials: {}
          )
        }

        return nil

      case Type<MetadataViews.ExternalURL>():
        let maybeView = viewManager.inspectView(
          view: Type<MetadataViews.ExternalURL>()
        )
        if maybeView == nil {
          return nil
        }
        let view = maybeView!

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.ExternalURLResolver>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.ExternalURLResolver
          return MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultPrefix,
              uri: resolver.defaultURL
            )
          )
        }

        return nil
      }
      return nil

  }

  // ========================================================================
  // Init
  // ========================================================================

  init(
    nftManagerProxy: &{
      NiftoryNonFungibleTokenProxy.Public,
      NiftoryNonFungibleTokenProxy.Private
    }
  ) {

    let record = NiftoryNFTRegistry.generateRecord(
      account: self.account.address,
      project: "clgdcdy480000mn0w62mjpm8r_Capsuletest"
    )

    self.REGISTRY_ADDRESS = 0x32d62d5c43ad1038
    self.REGISTRY_BRAND = "clgdcdy480000mn0w62mjpm8r_Capsuletest"

    self.COLLECTION_PUBLIC_PATH = record.collectionPaths.public
    self.COLLECTION_PRIVATE_PATH = record.collectionPaths.private
    self.COLLECTION_STORAGE_PATH = record.collectionPaths.storage

    // No metadata to start with
    self.metadata = nil

    // Initialize the total supply to 0.
    self.totalSupply = 0

    // The Manager for this NFT
    //
    // NFT Manager storage
    let nftManager <- create Manager()

    // Save a MutableSetManager to this contract's storage, as the source of
    // this NFT contract's metadata.
    //
    // MutableMetadataSetManager storage
    self
      .account
      .save<@MutableMetadataSetManager.Manager>(
        <-MutableMetadataSetManager.create(
          name: "Capsuletest",
          description: "The set manager for Capsuletest."
        ),
        to: record.setManager.paths.storage
      )

    // MutableMetadataSetManager public
    self
      .account
      .link<&MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public}>(
        record.setManager.paths.public,
        target: record.setManager.paths.storage
      )

    // MutableMetadataSetManager private
    self
      .account
      .link<&
        MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public,
        MutableMetadataSetManager.Private
      }>(
        record.setManager.paths.private,
        target: record.setManager.paths.storage
      )

    // Save a MetadataViewsManager to this contract's storage, which will
    // allow observers to inspect standardized metadata through any of its
    // configured MetadataViews resolvers.
    //
    // MetadataViewsManager storage
    self
      .account
      .save<@MetadataViewsManager.Manager>(
        <-MetadataViewsManager.create(),
        to: record.metadataViewsManager.paths.storage
      )

    // MetadataViewsManager public
    self
      .account
      .link<&MetadataViewsManager.Manager{MetadataViewsManager.Public}>(
        record.metadataViewsManager.paths.public,
        target: record.metadataViewsManager.paths.storage
      )

    // MetadataViewsManager private
    self
      .account
      .link<&
        MetadataViewsManager.Manager{MetadataViewsManager.Private,
        MetadataViewsManager.Public
      }>(
        record.metadataViewsManager.paths.private,
        target: record.metadataViewsManager.paths.storage
      )

    let contractName = "Capsuletest"

    // Royalties
    let royaltiesResolver = NiftoryMetadataViewsResolvers.RoyaltiesResolver(
        royalties: MetadataViews.Royalties([])
    )
    nftManager.setMetadataViewsResolver(royaltiesResolver)

    // Collection Data
    let collectionDataResolver
        = NiftoryMetadataViewsResolvers.NFTCollectionDataResolver()
    nftManager.setMetadataViewsResolver(collectionDataResolver)

    // Display
    let displayResolver = NiftoryMetadataViewsResolvers.DisplayResolver(
        "title",
        contractName.concat("NFT"),
        "description",
        contractName.concat(" NFT"),
        "mediaUrl",
        "ipfs://",
        "ipfs://bafybeig6la3me5x3veull7jzxmwle4sfuaguou2is3o3z44ayhe7ihlqpa/NiftoryBanner.png"
    )
    nftManager.setMetadataViewsResolver(displayResolver)

    // Collection Display
    let collectionResolver = NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver(
        "title",
        contractName,
        "description",
        contractName.concat(" Collection"),
        "domainUrl",
        "https://",
        "https://niftory.com",
        "squareImage",
        "ipfs://",
        "ipfs://bafybeihc76uodw2at2xi2l5jydpvscj5ophfpqgblbrmsfpeffhcmgdtl4/squareImage.png",
        "squareImageMediaType",
        "image/png",
        "bannerImage",
        "ipfs://",
        "ipfs://bafybeig6la3me5x3veull7jzxmwle4sfuaguou2is3o3z44ayhe7ihlqpa/NiftoryBanner.png",
        "bannerImageMediaType",
        "image/png",
        []
    )
    nftManager.setMetadataViewsResolver(collectionResolver)

    // ExternalURL
    let externalURLResolver = NiftoryMetadataViewsResolvers.ExternalURLResolver(
        "domainUrl",
        "https://",
        "https://niftory.com"
    )
    nftManager.setMetadataViewsResolver(externalURLResolver)

    // Save NFT Manager
    self
      .account
      .save<@Manager>(
        <-nftManager,
        to: record.nftManager.paths.storage
      )

    // NFT Manager public
    self
      .account
      .link<&{NiftoryNonFungibleToken.ManagerPublic}>(
        record.nftManager.paths.public,
        target: record.nftManager.paths.storage
      )

    // NFT Manager private
    self
      .account
      .link<&
        Manager{NiftoryNonFungibleToken.ManagerPublic,
        NiftoryNonFungibleToken.ManagerPrivate
      }>(
        record.nftManager.paths.private,
        target: record.nftManager.paths.storage
      )

      nftManagerProxy.add(
        registryAddress: self.REGISTRY_ADDRESS,
        brand: self.REGISTRY_BRAND,
        cap: self.account
              .getCapability<&{
                NiftoryNonFungibleToken.ManagerPrivate,
                NiftoryNonFungibleToken.ManagerPublic
              }>(
                record.nftManager.paths.private
              )
      )
  }
}"
-------
"//import FungibleToken from 0xf233dcee88fe0abe
//import NonFungibleToken from 0x1d7e57aa55817448
//import FlowToken from 0x1654653399040a61
//import FlovatarDustCollectibleTemplate from 0x921ea449dffec68a
//import MetadataViews from 0x1d7e57aa55817448
//import FlovatarDustToken from 0x921ea449dffec68a
import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import FlowToken from 0x1654653399040a61
import FlovatarDustCollectibleTemplate from 0x921ea449dffec68a
import FlovatarDustCollectibleAccessory from 0x921ea449dffec68a
import MetadataViews from 0x1d7e57aa55817448
import FlovatarDustToken from 0x921ea449dffec68a

/*

 The contract that defines the Dust Collectible NFT and a Collection to manage them


This contract contains also the Admin resource that can be used to manage and generate the Dust Collectible Templates.

 */

pub contract FlovatarDustCollectible: NonFungibleToken {

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let AdminStoragePath: StoragePath

    // These will be used in the Marketplace to pay out
    // royalties to the creator and to the marketplace
    access(account) var royaltyCut: UFix64
    access(account) var marketplaceCut: UFix64

    // Here we keep track of all the Flovatar unique combinations and names
    // that people will generate to make sure that there are no duplicates
    pub var totalSupply: UInt64
    access(contract) let mintedCombinations: {String: Bool}
    access(contract) let mintedNames: {String: Bool}

    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event Created(id: UInt64, mint: UInt64, series: UInt64, address: Address)
    pub event Updated(id: UInt64)
    pub event Destroyed(id: UInt64)
    pub event NameSet(id: UInt64, name: String)
    pub event PositionChanged(id: UInt64, position: String)
    pub event StoryAdded(id: UInt64, story: String)


    pub struct Royalties{
        pub let royalty: [Royalty]
        init(royalty: [Royalty]) {
            self.royalty=royalty
        }
    }

    pub enum RoyaltyType: UInt8{
        pub case fixed
        pub case percentage
    }

    pub struct Royalty{
        pub let wallet:Capability<&{FungibleToken.Receiver}>
        pub let cut: UFix64

        //can be percentage
        pub let type: RoyaltyType

        init(wallet:Capability<&{FungibleToken.Receiver}>, cut: UFix64, type: RoyaltyType ){
            if(! wallet.check()){
                //panic("Capability not valid!")
            }
            self.wallet = wallet
            self.cut = cut
            self.type = type
        }
    }



    // The public interface can show metadata and the content for the Flovatar.
    // In addition to it, it provides methods to access the additional optional
    // components (accessory, hat, eyeglasses, background) for everyone.
    pub resource interface Public {
        pub let id: UInt64
        pub let mint: UInt64
        pub let series: UInt64
        pub let combination: String
        pub let creatorAddress: Address
        pub let createdAt: UFix64
        access(contract) let royalties: Royalties

        // these three are added because I think they will be in the standard. At least Dieter thinks it will be needed
        access(contract) var name: String
        pub let description: String
        pub let schema: String?

        pub fun getName(): String
        pub fun getSvg(): String
        pub fun getRoyalties(): Royalties
        pub fun getBio(): {String: String}
        pub fun getMetadata(): {String: String}
        pub fun getLayers(): {UInt32: UInt64?}
        pub fun getAccessories(): [UInt64]
        pub fun getSeries(): FlovatarDustCollectibleTemplate.CollectibleSeriesData?
    }

    //The private interface can update the Accessory, Hat, Eyeglasses and Background
    //for the Flovatar and is accessible only to the owner of the NFT
    pub resource interface Private {
        pub fun setName(name: String, vault: @FungibleToken.Vault): String
        pub fun addStory(text: String, vault: @FungibleToken.Vault): String
        pub fun setPosition(latitude: Fix64, longitude: Fix64, vault: @FungibleToken.Vault): String
        pub fun setAccessory(layer: UInt32, accessory: @FlovatarDustCollectibleAccessory.NFT): @FlovatarDustCollectibleAccessory.NFT?
        pub fun removeAccessory(layer: UInt32): @FlovatarDustCollectibleAccessory.NFT?
    }

    //The NFT resource that implements both Private and Public interfaces
    pub resource NFT: NonFungibleToken.INFT, Public, Private, MetadataViews.Resolver {
        pub let id: UInt64
        pub let mint: UInt64
        pub let series: UInt64
        pub let combination: String
        pub let creatorAddress: Address
        pub let createdAt: UFix64
        access(contract) let royalties: Royalties

        access(contract) var name: String
        pub let description: String
        pub let schema: String?
        access(self) let bio: {String: String}
        access(self) let metadata: {String: String}
        access(self) let layers: {UInt32: UInt64?}
        access(self) let accessories: @{UInt32: FlovatarDustCollectibleAccessory.NFT}

        init(series: UInt64,
            layers: {UInt32: UInt64?},
            creatorAddress: Address,
            royalties: Royalties) {
            FlovatarDustCollectible.totalSupply = FlovatarDustCollectible.totalSupply + UInt64(1)
            FlovatarDustCollectibleTemplate.increaseTotalMintedCollectibles(series: series)
            let coreLayers: {UInt32: UInt64} = FlovatarDustCollectible.getCoreLayers(series: series, layers: layers)

            self.id = FlovatarDustCollectible.totalSupply
            self.mint = FlovatarDustCollectibleTemplate.getTotalMintedCollectibles(series: series)!
            self.series = series
            self.combination = FlovatarDustCollectible.getCombinationString(series: series, layers: coreLayers)
            self.creatorAddress = creatorAddress
            self.createdAt = getCurrentBlock().timestamp
            self.royalties = royalties

            self.schema = nil
            self.name = ""
            self.description = ""
            self.bio = {}
            self.metadata = {}
            self.layers = layers
            self.accessories <- {}
        }

        destroy() {
            destroy self.accessories
            emit Destroyed(id: self.id)
        }

        pub fun getID(): UInt64 {
            return self.id
        }

        pub fun getMetadata(): {String: String} {
            return self.metadata
        }

        pub fun getRoyalties(): Royalties {
            return self.royalties
        }

        pub fun getBio(): {String: String} {
            return self.bio
        }

        pub fun getName(): String {
            return self.name
        }

        pub fun getSeries(): FlovatarDustCollectibleTemplate.CollectibleSeriesData? {
            return FlovatarDustCollectibleTemplate.getCollectibleSeries(id: self.series)
        }

        // This will allow to change the Name of the Flovatar only once.
        // It checks for the current name is empty, otherwise it will throw an error.
        // $DUST vault must contain 100 tokens that will be burned in the process
        pub fun setName(name: String, vault: @FungibleToken.Vault): String {
            pre {
                // TODO: Make sure that the text of the name is sanitized
                //and that bad words are not accepted?
                name.length > 2 : "The name is too short"
                name.length < 32 : "The name is too long"
                self.name == "" : "The name has already been set"
                vault.balance == 100.0 : "The amount of $DUST is not correct"
                vault.isInstance(Type<@FlovatarDustToken.Vault>()) : "Vault not of the right Token Type"
            }

            // Makes sure that the name is available and not taken already
            if(FlovatarDustCollectible.checkNameAvailable(name: name) == false){
                panic("This name has already been taken")
            }

            destroy vault
            self.name = name


            // Adds the name to the array to remember it
            FlovatarDustCollectible.addMintedName(name: name)
            emit NameSet(id: self.id, name: name)

            return self.name
        }

        // This will allow to add a text Story to the Flovatar Bio.
        // The String will be concatenated each time.
        // There is a limit of 300 characters per story but there is no limit in the full concatenated story length
        // $DUST vault must contain 50 tokens that will be burned in the process
        pub fun addStory(text: String, vault: @FungibleToken.Vault): String {
            pre {
                // TODO: Make sure that the text of the name is sanitized
                //and that bad words are not accepted?
                text.length > 0 : "The text is too short"
                text.length <= 300 : "The text is too long"
                vault.balance == 50.0 : "The amount of $DUST is not correct"
                vault.isInstance(Type<@FlovatarDustToken.Vault>()) : "Vault not of the right Token Type"
            }

            destroy vault
            let currentStory: String = self.bio["story"] ?? ""
            let story: String = currentStory.concat(" ").concat(text)
            self.bio.insert(key: "story", story)

            emit StoryAdded(id: self.id, story: story)

            return story
        }


        // This will allow to set the GPS location of a Flovatar
        // It can be run multiple times and each time it will override the previous state
        // $DUST vault must contain 10 tokens that will be burned in the process
        pub fun setPosition(latitude: Fix64, longitude: Fix64, vault: @FungibleToken.Vault): String {
            pre {
                latitude >= -90.0 : "The latitude is out of range"
                latitude <= 90.0 : "The latitude is out of range"
                longitude >= -180.0 : "The longitude is out of range"
                longitude <= 180.0 : "The longitude is out of range"
                vault.balance == 10.0 : "The amount of $DUST is not correct"
                vault.isInstance(Type<@FlovatarDustToken.Vault>()) : "Vault not of the right Token Type"
            }

            destroy vault
            let position: String = latitude.toString().concat(",").concat(longitude.toString())
            self.bio.insert(key: "position", position)

            emit PositionChanged(id: self.id, position: position)

            return position
        }

        pub fun getLayers(): {UInt32: UInt64?} {
            return self.layers
        }


        pub fun getAccessories(): [UInt64] {
            let accessoriesIds: [UInt64] = []
            for k in self.accessories.keys {
                let accessoryId = self.accessories[k]?.id
                if(accessoryId != nil){
                    accessoriesIds.append(accessoryId!)
                }
            }
            return accessoriesIds
        }
        // This will allow to change the Accessory of the Flovatar any time.
        // It checks for the right category and series before executing.
        pub fun setAccessory(layer: UInt32, accessory: @FlovatarDustCollectibleAccessory.NFT): @FlovatarDustCollectibleAccessory.NFT? {
            pre {
                accessory.getSeries() == self.series : "The accessory belongs to a different series"
            }

            if(FlovatarDustCollectibleTemplate.isCollectibleLayerAccessory(layer: layer, series: self.series)){
                emit Updated(id: self.id)

                self.layers[layer] = accessory.templateId

                let oldAccessory <- self.accessories[layer] <- accessory
                return <- oldAccessory
            }

            panic("The Layer is out of range or it's not an accessory")
        }

        // This will allow to remove the Accessory of the Flovatar any time.
        pub fun removeAccessory(layer: UInt32): @FlovatarDustCollectibleAccessory.NFT? {
            if(FlovatarDustCollectibleTemplate.isCollectibleLayerAccessory(layer: layer, series: self.series)){
                emit Updated(id: self.id)
                self.layers[layer] = nil
                let accessory <- self.accessories[layer] <- nil
                return <-accessory
            }

            panic("The Layer is out of range or it's not an accessory")
        }


        // This function will return the full SVG of the Flovatar. It will take the
        // optional components (Accessory, Hat, Eyeglasses and Background) from their
        // original Template resources, while all the other unmutable components are
        // taken from the Metadata directly.
        pub fun getSvg(): String {
            let series = FlovatarDustCollectibleTemplate.getCollectibleSeries(id: self.series)

            let layersArr: [String] = []

            for k in series!.layers.keys {
                layersArr.append("")
            }

            var svg: String = series!.svgPrefix

            for k in self.layers.keys {
                if(self.layers[k] != nil){
                    let layer = self.layers[k]!
                    if(layer != nil){
                        let tempSvg = FlovatarDustCollectibleTemplate.getCollectibleTemplateSvg(id: layer!)
                        //svg = svg.concat(tempSvg!)
                        layersArr[(k-UInt32(1))] = tempSvg!
                    }
                }
            }

            for tempLayer in layersArr {
                svg = svg.concat(tempLayer)
            }

            svg = svg.concat(series!.svgSuffix)

            return svg

        }


        pub fun getViews() : [Type] {
            var views : [Type]=[]
            views.append(Type<MetadataViews.NFTCollectionData>())
            views.append(Type<MetadataViews.NFTCollectionDisplay>())
            views.append(Type<MetadataViews.Display>())
            views.append(Type<MetadataViews.Royalties>())
            views.append(Type<MetadataViews.Edition>())
            views.append(Type<MetadataViews.ExternalURL>())
            views.append(Type<MetadataViews.Serial>())
            views.append(Type<MetadataViews.Traits>())
            return views
        }
        pub fun resolveView(_ type: Type): AnyStruct? {

            if type == Type<MetadataViews.ExternalURL>() {
                return MetadataViews.ExternalURL("https://flovatar.com/collectibles/".concat(self.id.toString()))
            }

            if type == Type<MetadataViews.Royalties>() {
                let royalties : [MetadataViews.Royalty] = []
                var count: Int = 0
                for royalty in self.royalties.royalty {
                    royalties.append(MetadataViews.Royalty(recepient: royalty.wallet, cut: royalty.cut, description: "Flovatar Royalty ".concat(count.toString())))
                    count = count + Int(1)
                }
                return MetadataViews.Royalties(cutInfos: royalties)
            }

            if type == Type<MetadataViews.Serial>() {
                return MetadataViews.Serial(self.id)
            }

            if type ==  Type<MetadataViews.Editions>() {
                let series = self.getSeries()
                var maxMint: UInt64 = series!.maxMintable
                if(maxMint == UInt64(0)){
                    maxMint = UInt64(999999)
                }
                let editionInfo = MetadataViews.Edition(name: "Flovatar Stardust Collectible Series ".concat(self.series.toString()), number: self.mint, max: maxMint)
                let editionList: [MetadataViews.Edition] = [editionInfo]
                return MetadataViews.Editions(
                    editionList
                )
            }

            if type == Type<MetadataViews.NFTCollectionDisplay>() {
                let mediaSquare = MetadataViews.Media(
                    file: MetadataViews.HTTPFile(
                        url: "https://images.flovatar.com/logo.svg"
                    ),
                    mediaType: "image/svg+xml"
                )
                let mediaBanner = MetadataViews.Media(
                    file: MetadataViews.HTTPFile(
                        url: "https://images.flovatar.com/logo-horizontal.svg"
                    ),
                    mediaType: "image/svg+xml"
                )
                return MetadataViews.NFTCollectionDisplay(
                    name: "Flovatar Stardust Collectible",
                    description: "The Flovatar Stardust Collectibles are the next generation of composable and customizable NFTs that populate the Flovatar Universe and can be minted exclusively by using the $DUST token.",
                    externalURL: MetadataViews.ExternalURL("https://flovatar.com"),
                    squareImage: mediaSquare,
                    bannerImage: mediaBanner,
                    socials: {
                        "discord": MetadataViews.ExternalURL("https://discord.gg/flovatar"),
                        "twitter": MetadataViews.ExternalURL("https://twitter.com/flovatar"),
                        "instagram": MetadataViews.ExternalURL("https://instagram.com/flovatar_nft"),
                        "tiktok": MetadataViews.ExternalURL("https://www.tiktok.com/@flovatar")
                    }
                )
            }

            if type == Type<MetadataViews.Display>() {
                return MetadataViews.Display(
                    name: self.name == "" ? "Stardust Collectible #".concat(self.id.toString()) : self.name,
                    description: self.description,
                    thumbnail: MetadataViews.HTTPFile(
                        url: "https://images.flovatar.com/collectible/svg/".concat(self.id.toString()).concat(".svg")
                    )
                )
            }

            if type == Type<MetadataViews.Traits>() {
                let traits: [MetadataViews.Trait] = []

                let series = self.getSeries()

                for k in self.layers.keys {
                    if(self.layers[k] != nil){
                        let layer = series!.layers[k]!
                        if(self.layers[k] != nil){
                            let layerSelf = self.layers[k]!
                            if(layer != nil){
                                let template = FlovatarDustCollectibleTemplate.getCollectibleTemplate(id: layerSelf!)
                                let trait = MetadataViews.Trait(name: layer!.name, value: template!.name, displayType:"String", rarity: MetadataViews.Rarity(score:nil, max:nil, description: template!.rarity))
                                traits.append(trait)
                            }
                        }
                    }
                }

                return MetadataViews.Traits(traits)
            }

            if type == Type<MetadataViews.NFTCollectionData>() {
                return MetadataViews.NFTCollectionData(
                storagePath: FlovatarDustCollectible.CollectionStoragePath,
                publicPath: FlovatarDustCollectible.CollectionPublicPath,
                providerPath: /private/FlovatarDustCollectibleCollection,
                publicCollection: Type<&FlovatarDustCollectible.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, FlovatarDustCollectible.CollectionPublic}>(),
                publicLinkedType: Type<&FlovatarDustCollectible.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, FlovatarDustCollectible.CollectionPublic}>(),
                providerLinkedType: Type<&FlovatarDustCollectible.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, FlovatarDustCollectible.CollectionPublic}>(),
                createEmptyCollectionFunction: fun(): @NonFungibleToken.Collection {return <- FlovatarDustCollectible.createEmptyCollection()}
                )
            }


            return nil
        }
    }


    // Standard NFT collectionPublic interface that can also borrowFlovatar as the correct type
    pub resource interface CollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowDustCollectible(id: UInt64): &FlovatarDustCollectible.NFT{FlovatarDustCollectible.Public, MetadataViews.Resolver}? {
            // If the result isn't nil, the id of the returned reference
            // should be the same as the argument to the function
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow Flovatar Dust Collectible reference: The ID of the returned reference is incorrect"
            }
        }
    }

    // Main Collection to manage all the Flovatar NFT
    pub resource Collection: CollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with an `UInt64` ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        // withdraw removes an NFT from the collection and moves it to the caller
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <- token
        }

        // deposit takes a NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @FlovatarDustCollectible.NFT

            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        // getIDs returns an array of the IDs that are in the collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT gets a reference to an NFT in the collection
        // so that the caller can read its metadata and call its methods
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        // borrowFlovatar returns a borrowed reference to a Flovatar
        // so that the caller can read data and call methods from it.
        pub fun borrowDustCollectible(id: UInt64): &FlovatarDustCollectible.NFT{FlovatarDustCollectible.Public, MetadataViews.Resolver}? {
            if self.ownedNFTs[id] != nil {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                let collectibleNFT = ref as! &FlovatarDustCollectible.NFT
                return collectibleNFT as &FlovatarDustCollectible.NFT{FlovatarDustCollectible.Public, MetadataViews.Resolver}
            } else {
                return nil
            }
        }

        // borrowFlovatarPrivate returns a borrowed reference to a Flovatar using the Private interface
        // so that the caller can read data and call methods from it, like setting the optional components.
        pub fun borrowDustCollectiblePrivate(id: UInt64): &{FlovatarDustCollectible.Private}? {
            if self.ownedNFTs[id] != nil {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &FlovatarDustCollectible.NFT
            } else {
                return nil
            }
        }

        destroy() {
            destroy self.ownedNFTs
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            pre {
                self.ownedNFTs[id] != nil : "NFT does not exist"
            }
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let collectibleNFT = nft as! &FlovatarDustCollectible.NFT
            return collectibleNFT as &AnyResource{MetadataViews.Resolver}
        }
    }

    // public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    // This struct is used to send a data representation of the Flovatar Dust Collectibles
    // when retrieved using the contract helper methods outside the collection.
    pub struct FlovatarDustCollectibleData {
        pub let id: UInt64
        pub let mint: UInt64
        pub let series: UInt64
        pub let name: String
        pub let svg: String?
        pub let combination: String
        pub let creatorAddress: Address
        pub let layers: {UInt32: UInt64?}
        pub let bio: {String: String}
        pub let metadata: {String: String}
        init(
            id: UInt64,
            mint: UInt64,
            series: UInt64,
            name: String,
            svg: String?,
            combination: String,
            creatorAddress: Address,
            layers: {UInt32: UInt64?},
            bio: {String: String},
            metadata: {String: String}
            ) {
            self.id = id
            self.mint = mint
            self.series = series
            self.name = name
            self.svg = svg
            self.combination = combination
            self.creatorAddress = creatorAddress
            self.layers = layers
            self.bio = bio
            self.metadata = metadata
        }
    }


    // This function will look for a specific Flovatar on a user account and return a FlovatarData if found
    pub fun getCollectible(address: Address, collectibleId: UInt64) : FlovatarDustCollectibleData? {

        let account = getAccount(address)

        if let collectibleCollection = account.getCapability(self.CollectionPublicPath).borrow<&FlovatarDustCollectible.Collection{FlovatarDustCollectible.CollectionPublic}>()  {
            if let collectible = collectibleCollection.borrowDustCollectible(id: collectibleId) {
                return FlovatarDustCollectibleData(
                    id: collectibleId,
                    mint: collectible!.mint,
                    series: collectible!.series,
                    name: collectible!.getName(),
                    svg: collectible!.getSvg(),
                    combination: collectible!.combination,
                    creatorAddress: collectible!.creatorAddress,
                    layers: collectible!.getLayers(),
                    bio: collectible!.getBio(),
                    metadata: collectible!.getMetadata()
                )
            }
        }
        return nil
    }

    // This function will return all Flovatars on a user account and return an array of FlovatarData
    pub fun getCollectibles(address: Address) : [FlovatarDustCollectibleData] {

        var dustCollectibleData: [FlovatarDustCollectibleData] = []
        let account = getAccount(address)

        if let collectibleCollection = account.getCapability(self.CollectionPublicPath).borrow<&FlovatarDustCollectible.Collection{FlovatarDustCollectible.CollectionPublic}>()  {
            for id in collectibleCollection.getIDs() {
                if let collectible = collectibleCollection.borrowDustCollectible(id: id) {
                    dustCollectibleData.append(FlovatarDustCollectibleData(
                        id: id,
                        mint: collectible!.mint,
                        series: collectible!.series,
                        name: collectible!.getName(),
                        svg: nil,
                        combination: collectible!.combination,
                        creatorAddress: collectible!.creatorAddress,
                        layers: collectible!.getLayers(),
                        bio: collectible!.getBio(),
                        metadata: collectible!.getMetadata()
                    ))
                }
            }
        }
        return dustCollectibleData
    }


    // This returns all the previously minted combinations, so that duplicates won't be allowed
    pub fun getMintedCombinations() : [String] {
        return FlovatarDustCollectible.mintedCombinations.keys
    }
    // This returns all the previously minted names, so that duplicates won't be allowed
    pub fun getMintedNames() : [String] {
        return FlovatarDustCollectible.mintedNames.keys
    }

    // This function will add a minted combination to the array
    access(account) fun addMintedCombination(combination: String) {
        FlovatarDustCollectible.mintedCombinations.insert(key: combination, true)
    }
    // This function will add a new name to the array
    access(account) fun addMintedName(name: String) {
        FlovatarDustCollectible.mintedNames.insert(key: name, true)
    }

    pub fun getCoreLayers(series: UInt64, layers: {UInt32: UInt64?}): {UInt32: UInt64}{
        let coreLayers: {UInt32: UInt64} = {}
        for k in layers.keys {
            if(!FlovatarDustCollectibleTemplate.isCollectibleLayerAccessory(layer: k, series: series)){
                let templateId = layers[k]!
                let template = FlovatarDustCollectibleTemplate.getCollectibleTemplate(id: templateId!)!
                if(template.series != series){
                    panic("Template belonging to the wrong Dust Collectible Series")
                }
                if(template.layer != k){
                    panic("Template belonging to the wrong Layer")
                }
                coreLayers[k] = templateId!
            }
        }

        return coreLayers
    }

    // This helper function will generate a string from a list of components,
    // to be used as a sort of barcode to keep the inventory of the minted
    // Flovatars and to avoid duplicates
    pub fun getCombinationString(
        series: UInt64,
        layers: {UInt32: UInt64}
    ) : String {
        var combination = "S".concat(series.toString())
        var i: UInt32 = UInt32(2)
        while(i <  UInt32(7)){
            if(layers[i] != nil){
                let layerId = layers[i]!
                combination = combination.concat("-L").concat(i.toString()).concat("_").concat(layerId.toString())
            }
            i = i + UInt32(1)
        }
        //Disabling because is not ordered and will generate duplicates
        //for k in layers.keys {
        //    if(layers[k] != nil){
        //        let layerId = layers[k]!
        //        combination = combination.concat("-L").concat(k.toString()).concat("_").concat(layerId.toString())
        //    }
        //}

        return combination
    }

    // This function will get a list of component IDs and will check if the
    // generated string is unique or if someone already used it before.
    pub fun checkCombinationAvailable(
        series: UInt64,
        layers: {UInt32: UInt64}
    ) : Bool {
        let combinationString = FlovatarDustCollectible.getCombinationString(
            series: series,
            layers: layers
        )
        return ! FlovatarDustCollectible.mintedCombinations.containsKey(combinationString)
    }

    // This will check if a specific Name has already been taken
    // and assigned to some Flovatar
    pub fun checkNameAvailable(name: String) : Bool {
        return name.length > 2 && name.length < 20 && ! FlovatarDustCollectible.mintedNames.containsKey(name)
    }


    // This is a public function that anyone can call to generate a new Flovatar Dust Collectible
    // A list of components resources needs to be passed to executed.
    // It will check first for uniqueness of the combination + name and will then
    // generate the Flovatar and burn all the passed components.
    // The Spark NFT will entitle to use any common basic component (body, hair, etc.)
    // In order to use special rare components a boost of the same rarity will be needed
    // for each component used
    pub fun createDustCollectible(
        series: UInt64,
        layers: [UInt32],
        templateIds: [UInt64?],
        address: Address,
        vault: @FungibleToken.Vault
    ) : @FlovatarDustCollectible.NFT {
        pre {
            vault.isInstance(Type<@FlovatarDustToken.Vault>()) : "Vault not of the right Token Type"
        }

        let seriesData = FlovatarDustCollectibleTemplate.getCollectibleSeries(id: series)
        if(seriesData == nil){
            panic("Dust Collectible Series not found!")
        }
        if(seriesData!.layers.length != layers.length){
            panic("The amount of layers is not matching!")
        }
        if(templateIds.length != layers.length){
            panic("The amount of layers and templates is not matching!")
        }
        let mintedCollectibles = FlovatarDustCollectibleTemplate.getTotalMintedCollectibles(series: series)
        if(mintedCollectibles != nil){
            if(mintedCollectibles! >= seriesData!.maxMintable){
                panic("Reached the maximum mint number for this Series!")
            }
        }

        let templates: [FlovatarDustCollectibleTemplate.CollectibleTemplateData] = []
        var totalPrice: UFix64 = 0.0
        let coreLayers: {UInt32: UInt64} = {}
        let fullLayers: {UInt32: UInt64?} = {}

        var i: UInt32 = UInt32(0)
        while(i <  UInt32(layers.length)){
            let layerId: UInt32 = layers[i]!
            let templateId: UInt64? = templateIds[i] ?? nil
            if(!FlovatarDustCollectibleTemplate.isCollectibleLayerAccessory(layer: layerId, series: series)){
                if(templateId == nil){
                    panic("Core Layer missing ".concat(layerId.toString()).concat(" - ").concat(i.toString()).concat("/").concat(layers.length.toString()))
                }
                let template = FlovatarDustCollectibleTemplate.getCollectibleTemplate(id: templateId!)!
                if(template.series != series){
                    panic("Template belonging to the wrong Dust Collectible Series")
                }
                if(template.layer != layerId){
                    panic("Template belonging to the wrong Layer")
                }

                let totalMintedComponents: UInt64 = FlovatarDustCollectibleTemplate.getTotalMintedComponents(id: template.id)!
                // Makes sure that the original minting limit set for each Template has not been reached
                if(totalMintedComponents >= template.maxMintableComponents) {
                    panic("Reached maximum mintable count for this trait")
                }

                coreLayers[layerId] = template.id
                fullLayers[layerId] = template.id
                templates.append(template)
                totalPrice = totalPrice + FlovatarDustCollectibleTemplate.getTemplateCurrentPrice(id: template.id)!

                FlovatarDustCollectibleTemplate.increaseTotalMintedComponents(id: template.id)
                FlovatarDustCollectibleTemplate.increaseTemplatesCurrentPrice(id: template.id)
                FlovatarDustCollectibleTemplate.setLastComponentMintedAt(id: template.id, value: getCurrentBlock().timestamp)
            } else {
                fullLayers[layerId] = nil
            }

            i = i + UInt32(1)
        }

        if(totalPrice > vault.balance){
            panic("Not enough tokens provided")
        }


        // Generates the combination string to check for uniqueness.
        // This is like a barcode that defines exactly which components were used
        // to create the Flovatar
        let combinationString = FlovatarDustCollectible.getCombinationString(
            series: series,
            layers: coreLayers
            )

        // Makes sure that the combination is available and not taken already
        if(FlovatarDustCollectible.mintedCombinations.containsKey(combinationString) == true) {
            panic("This combination has already been taken")
        }

        let royalties: [Royalty] = []

        let creatorAccount = getAccount(address)
        royalties.append(Royalty(
            wallet: creatorAccount.getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),
            cut: FlovatarDustCollectible.getRoyaltyCut(),
            type: RoyaltyType.percentage
        ))

        royalties.append(Royalty(
            wallet: self.account.getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),
            cut: FlovatarDustCollectible.getMarketplaceCut(),
            type: RoyaltyType.percentage
        ))

        // Mint the new Flovatar NFT by passing the metadata to it
        var newNFT <- create NFT(series: series, layers: fullLayers, creatorAddress: address, royalties: Royalties(royalty: royalties))

        // Adds the combination to the arrays to remember it
        FlovatarDustCollectible.addMintedCombination(combination: combinationString)


        // Emits the Created event to notify about its existence
        emit Created(id: newNFT.id, mint: newNFT.mint, series: newNFT.series, address: address)

        destroy vault

        return <- newNFT
    }



    // These functions will return the current Royalty cuts for
    // both the Creator and the Marketplace.
    pub fun getRoyaltyCut(): UFix64{
        return self.royaltyCut
    }
    pub fun getMarketplaceCut(): UFix64{
        return self.marketplaceCut
    }
    // Only Admins will be able to call the set functions to
    // manage Royalties and Marketplace cuts.
    access(account) fun setRoyaltyCut(value: UFix64){
        self.royaltyCut = value
    }
    access(account) fun setMarketplaceCut(value: UFix64){
        self.marketplaceCut = value
    }




    // This is the main Admin resource that will allow the owner
    // to generate new Templates, Components and Packs
    pub resource Admin {

        //This will create a new FlovatarComponentTemplate that
        // contains all the SVG and basic informations to represent
        // a specific part of the Flovatar (body, hair, eyes, mouth, etc.)
        // More info in the FlovatarComponentTemplate.cdc file
        pub fun createCollectibleSeries(
                        name: String,
                        description: String,
                        svgPrefix: String,
                        svgSuffix: String,
                        priceIncrease: UFix64,
                        layers: {UInt32: FlovatarDustCollectibleTemplate.Layer},
                        colors: {UInt32: String},
                        metadata: {String: String},
                        maxMintable: UInt64
                    ) : @FlovatarDustCollectibleTemplate.CollectibleSeries {
            return <- FlovatarDustCollectibleTemplate.createCollectibleSeries(
                name: name,
                description: description,
                svgPrefix: svgPrefix,
                svgSuffix: svgSuffix,
                priceIncrease: priceIncrease,
                layers: layers,
                colors: colors,
                metadata: metadata,
                maxMintable: maxMintable
            )
        }
        //This will create a new FlovatarComponentTemplate that
        // contains all the SVG and basic informations to represent
        // a specific part of the Flovatar (body, hair, eyes, mouth, etc.)
        // More info in the FlovatarComponentTemplate.cdc file
        pub fun createCollectibleTemplate(
                        name: String,
                        description: String,
                        series: UInt64,
                        layer: UInt32,
                        metadata: {String: String},
                        rarity: String,
                        basePrice: UFix64,
                        svg: String,
                        maxMintableComponents: UInt64
                    ) : @FlovatarDustCollectibleTemplate.CollectibleTemplate {
            return <- FlovatarDustCollectibleTemplate.createCollectibleTemplate(
                name: name,
                description: description,
                series: series,
                layer: layer,
                metadata: metadata,
                rarity: rarity,
                basePrice: basePrice,
                svg: svg,
                maxMintableComponents: maxMintableComponents
            )
        }

        //This will mint a new Component based from a selected Template
        pub fun createCollectible(templateId: UInt64) : @FlovatarDustCollectibleAccessory.NFT {
            return <- FlovatarDustCollectibleAccessory.createCollectibleAccessoryInternal(templateId: templateId)
        }
        //This will mint Components in batch and return a Collection instead of the single NFT
        pub fun batchCreateCollectibles(templateId: UInt64, quantity: UInt64) : @FlovatarDustCollectibleAccessory.Collection {
            return <- FlovatarDustCollectibleAccessory.batchCreateCollectibleAccessory(templateId: templateId, quantity: quantity)
        }


        // With this function you can generate a new Admin resource
        // and pass it to another user if needed
        pub fun createNewAdmin(): @Admin {
            return <-create Admin()
        }

        // Helper functions to update the Royalty cut
        pub fun setRoyaltyCut(value: UFix64) {
            FlovatarDustCollectible.setRoyaltyCut(value: value)
        }

        // Helper functions to update the Marketplace cut
        pub fun setMarketplaceCut(value: UFix64) {
            FlovatarDustCollectible.setMarketplaceCut(value: value)
        }
    }





	init() {
        self.CollectionPublicPath = /public/FlovatarDustCollectibleCollection
        self.CollectionStoragePath = /storage/FlovatarDustCollectibleCollection
        self.AdminStoragePath = /storage/FlovatarDustCollectibleAdmin

        // Initialize the total supply
        self.totalSupply = UInt64(0)
        self.mintedCombinations = {}
        self.mintedNames = {}

        // Set the default Royalty and Marketplace cuts
        self.royaltyCut = 0.01
        self.marketplaceCut = 0.05

        self.account.save<@NonFungibleToken.Collection>(<- FlovatarDustCollectible.createEmptyCollection(), to: FlovatarDustCollectible.CollectionStoragePath)
        self.account.link<&{FlovatarDustCollectible.CollectionPublic}>(FlovatarDustCollectible.CollectionPublicPath, target: FlovatarDustCollectible.CollectionStoragePath)

        // Put the Admin resource in storage
        self.account.save<@Admin>(<- create Admin(), to: self.AdminStoragePath)

        emit ContractInitialized()
	}
}
"
-------
"/**

# Common lending errors

# Author: Increment Labs

*/
pub contract LendingError {
    pub enum ErrorCode: UInt8 {
        pub case NO_ERROR
        /// Pool related:
        pub case INVALID_PARAMETERS
        pub case INVALID_USER_CERTIFICATE
        pub case INVALID_POOL_CERTIFICATE
        pub case CANNOT_ACCESS_POOL_PUBLIC_CAPABILITY
        pub case CANNOT_ACCESS_COMPTROLLER_PUBLIC_CAPABILITY // 5
        pub case CANNOT_ACCESS_INTEREST_RATE_MODEL_CAPABILITY
        pub case POOL_INITIALIZED
        pub case EMPTY_FUNGIBLE_TOKEN_VAULT
        pub case MISMATCHED_INPUT_VAULT_TYPE_WITH_POOL
        pub case INSUFFICIENT_POOL_LIQUIDITY // 10
        pub case REDEEM_FAILED_NO_ENOUGH_LP_TOKEN
        pub case SAME_LIQUIDATOR_AND_BORROWER
        pub case EXTERNAL_SEIZE_FROM_SELF
        pub case EXCEED_TOTAL_RESERVES
        /// Comptroller:
        pub case ADD_MARKET_DUPLICATED // 15
        pub case ADD_MARKET_NO_ORACLE_PRICE
        pub case UNKNOWN_MARKET
        pub case MARKET_NOT_OPEN
        pub case REDEEM_NOT_ALLOWED_POSITION_UNDER_WATER
        pub case BORROW_NOT_ALLOWED_EXCEED_BORROW_CAP // 20
        pub case BORROW_NOT_ALLOWED_POSITION_UNDER_WATER
        pub case LIQUIDATION_NOT_ALLOWED_SEIZE_MORE_THAN_BALANCE
        pub case LIQUIDATION_NOT_ALLOWED_POSITION_ABOVE_WATER
        pub case LIQUIDATION_NOT_ALLOWED_TOO_MUCH_REPAY
        pub case SUPPLY_NOT_ALLOWED_EXCEED_SUPPLY_CAP // 25

        pub case FLASHLOAN_EXECUTOR_SETUP
    }

    pub fun ErrorEncode(msg: String, err: ErrorCode): String {
        return "[IncErrorMsg:".concat(msg).concat("]").concat(
               "[IncErrorCode:").concat(err.rawValue.toString()).concat("]")
    }

    init() {
    }
}"
-------
"//import FungibleToken from 0xf233dcee88fe0abe
//import NonFungibleToken from 0x1d7e57aa55817448
//import FlowToken from 0x1654653399040a61
//import FlovatarComponentTemplate from 0x921ea449dffec68a
//import FlovatarComponent from 0x921ea449dffec68a
//import FlovatarPack from 0x921ea449dffec68a
//import MetadataViews from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import FlowToken from 0x1654653399040a61
import FlovatarComponentTemplate from 0x921ea449dffec68a
import FlovatarComponent from 0x921ea449dffec68a
import FlovatarPack from 0x921ea449dffec68a
import MetadataViews from 0x1d7e57aa55817448

/*

The contract that defines the Flobot NFT and a Collection to manage them

Base components that will be used to generate the unique combination of the Flobot
'body', 'hair', 'facialhair', 'eyes', 'nose', 'mouth', 'clothing'

Extra components that can be added in a second moment
'accessory', 'hat', eyeglass', 'background'


This contract contains also the Admin resource that can be used to manage and generate all the other ones (Components, Templates, Packs).

 */

pub contract Flobot: NonFungibleToken {

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let AdminStoragePath: StoragePath

    // These will be used in the Marketplace to pay out
    // royalties to the creator and to the marketplace
    access(account) var royaltyCut: UFix64
    access(account) var marketplaceCut: UFix64

    // Here we keep track of all the Flobot unique combinations and names
    // that people will generate to make sure that there are no duplicates
    pub var totalSupply: UInt64
    access(contract) let mintedCombinations: {String: Bool}
    access(contract) let mintedNames: {String: Bool}

    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event Created(id: UInt64, metadata: Metadata)
    pub event Updated(id: UInt64)
    pub event NameSet(id: UInt64, name: String)


    pub struct Royalties{
        pub let royalty: [Royalty]
        init(royalty: [Royalty]) {
            self.royalty=royalty
        }
    }

    pub enum RoyaltyType: UInt8{
        pub case fixed
        pub case percentage
    }

    pub struct Royalty{
        pub let wallet:Capability<&{FungibleToken.Receiver}>
        pub let cut: UFix64

        //can be percentage
        pub let type: RoyaltyType

        init(wallet:Capability<&{FungibleToken.Receiver}>, cut: UFix64, type: RoyaltyType ){
            self.wallet=wallet
            self.cut=cut
            self.type=type
        }
    }


    // This Metadata struct contains all the most important informations about the Flobot
    pub struct Metadata {
        pub let mint: UInt64
        pub let series: UInt32
        pub let combination: String
        pub let rarity: String
        pub let creatorAddress: Address
        access(self) let components: {String: UInt64}


        init(
            mint: UInt64,
            series: UInt32,
            combination: String,
            rarity: String,
            creatorAddress: Address,
            components: {String: UInt64}
        ) {
                self.mint = mint
                self.series = series
                self.combination = combination
                self.rarity = rarity
                self.creatorAddress = creatorAddress
                self.components = components
        }
        pub fun getComponents(): {String: UInt64} {
            return self.components
        }
    }

    // The public interface can show metadata and the content for the Flobot.
    // In addition to it, it provides methods to access the additional optional
    // components (accessory, hat, eyeglasses, background) for everyone.
    pub resource interface Public {
        pub let id: UInt64
        access(contract) let metadata: Metadata
        access(contract) let royalties: Royalties

        // these three are added because I think they will be in the standard. At least Dieter thinks it will be needed
        access(contract) var name: String
        pub let description: String
        pub let schema: String?

        pub fun getName(): String
        pub fun getBackground(): UInt64?

        pub fun getSvg(): String
        pub fun getMetadata(): Metadata
        pub fun getRoyalties(): Royalties
        pub fun getBio(): {String: String}
    }

    //The private interface can update the Accessory, Hat, Eyeglasses and Background
    //for the Flobot and is accessible only to the owner of the NFT
    pub resource interface Private {
        pub fun setName(name: String): String
        pub fun setBackground(component: @FlovatarComponent.NFT): @FlovatarComponent.NFT?
        pub fun removeBackground(): @FlovatarComponent.NFT?
    }

    //The NFT resource that implements both Private and Public interfaces
    pub resource NFT: NonFungibleToken.INFT, Public, Private, MetadataViews.Resolver {
        pub let id: UInt64
        access(contract) let metadata: Metadata
        access(contract) let royalties: Royalties
        access(contract) var background: @FlovatarComponent.NFT?

        access(contract) var name: String
        pub let description: String
        pub let schema: String?
        access(self) let bio: {String: String}

        init(metadata: Metadata,
            royalties: Royalties) {
            Flobot.totalSupply = Flobot.totalSupply + UInt64(1)

            self.id = Flobot.totalSupply
            self.metadata = metadata
            self.royalties = royalties
            self.background <- nil

            self.schema = nil
            self.name = ""
            self.description = ""
            self.bio = {}
        }

        destroy() {
            destroy self.background
        }

        pub fun getID(): UInt64 {
            return self.id
        }

        pub fun getMetadata(): Metadata {
            return self.metadata
        }

        pub fun getRoyalties(): Royalties {
            return self.royalties
        }

        pub fun getBio(): {String: String} {
            return self.bio
        }

        pub fun getName(): String {
            return self.name
        }

        // This will allow to change the Name of the Flobot only once.
        // It checks for the current name is empty, otherwise it will throw an error.
        pub fun setName(name: String): String {
            pre {
                // TODO: Make sure that the text of the name is sanitized
                //and that bad words are not accepted?
                name.length > 2 : "The name is too short"
                name.length < 32 : "The name is too long"
                self.name == "" : "The name has already been set"
            }

            // Makes sure that the name is available and not taken already
            if(Flobot.checkNameAvailable(name: name) == false){
                panic("This name has already been taken")
            }

            // DISABLING THIS FUNCTIONALITY TO BE INTRODUCED AT A LATER DATE
            //self.name = name


            // Adds the name to the array to remember it
            //Flobot.addMintedName(name: name)
            //emit NameSet(id: self.id, name: name)

            return self.name
        }


        pub fun getBackground(): UInt64? {
            return self.background?.templateId
        }

        // This will allow to change the Background of the Flobot any time.
        // It checks for the right category and series before executing.
        pub fun setBackground(component: @FlovatarComponent.NFT): @FlovatarComponent.NFT? {
            pre {
                component.getCategory() == "background" : "The component needs to be a background"
                (component.getSeries() == self.metadata.series || component.getSeries() == UInt32(1)) : "The accessory belongs to a different series"
            }

            emit Updated(id: self.id)

            let compNFT <- self.background <- component
            return <-compNFT
        }

        // This will allow to remove the Background of the Flobot any time.
        pub fun removeBackground(): @FlovatarComponent.NFT? {
            emit Updated(id: self.id)
            let compNFT <- self.background <- nil
            return <-compNFT
        }

        // This function will return the full SVG of the Flobot. It will take the
        // optional components (Accessory, Hat, Eyeglasses and Background) from their
        // original Template resources, while all the other unmutable components are
        // taken from the Metadata directly.
        pub fun getSvg(): String {
            var svg: String = "<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 3000 3000' width='100%' height='100%'>"

            if let background = self.getBackground() {
                if let template = FlovatarComponentTemplate.getComponentTemplate(id: background) {
                    svg = svg.concat(template.svg!)
                }
            }

            svg = svg.concat(self.getTraitsSvg())

            svg = svg.concat("</svg>")

            return svg

        }
        pub fun getSvgNoBg(): String {
            var svg: String = "<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 3000 3000' width='100%' height='100%'>"

            svg = svg.concat(self.getTraitsSvg())

            svg = svg.concat("</svg>")

            return svg

        }

        pub fun getTraitsSvg(): String {
            var svg: String = ""

            let components: {String: UInt64} = self.metadata.getComponents()

            let armsTemplate: FlovatarComponentTemplate.ComponentTemplateData = FlovatarComponentTemplate.getComponentTemplate(id: components["arms"]!)!
            let legsTemplate: FlovatarComponentTemplate.ComponentTemplateData = FlovatarComponentTemplate.getComponentTemplate(id: components["legs"]!)!
            let bodyTemplate: FlovatarComponentTemplate.ComponentTemplateData = FlovatarComponentTemplate.getComponentTemplate(id: components["body"]!)!
            let headTemplate: FlovatarComponentTemplate.ComponentTemplateData = FlovatarComponentTemplate.getComponentTemplate(id: components["head"]!)!
            let faceTemplate: FlovatarComponentTemplate.ComponentTemplateData = FlovatarComponentTemplate.getComponentTemplate(id: components["face"]!)!

            svg = svg.concat(armsTemplate.svg!)
            svg = svg.concat(legsTemplate.svg!)
            svg = svg.concat(bodyTemplate.svg!)
            svg = svg.concat(headTemplate.svg!)
            svg = svg.concat(faceTemplate.svg!)


            return svg

        }


        pub fun getViews() : [Type] {
            var views : [Type]=[]
            views.append(Type<MetadataViews.NFTCollectionData>())
            views.append(Type<MetadataViews.NFTCollectionDisplay>())
            views.append(Type<MetadataViews.Display>())
            views.append(Type<MetadataViews.Royalties>())
            views.append(Type<MetadataViews.Edition>())
            views.append(Type<MetadataViews.ExternalURL>())
            views.append(Type<MetadataViews.Serial>())
            views.append(Type<MetadataViews.Traits>())
            return views
        }
        pub fun resolveView(_ type: Type): AnyStruct? {

            if type == Type<MetadataViews.ExternalURL>() {
                return MetadataViews.ExternalURL("https://flovatar.com/flobots/".concat(self.id.toString()))
            }

            if type == Type<MetadataViews.Royalties>() {
                let royalties : [MetadataViews.Royalty] = []
                var count: Int = 0
                for royalty in self.royalties.royalty {
                    royalties.append(MetadataViews.Royalty(recepient: royalty.wallet, cut: royalty.cut, description: "Flovatar Royalty ".concat(count.toString())))
                    count = count + Int(1)
                }
                return MetadataViews.Royalties(cutInfos: royalties)
            }

            if type == Type<MetadataViews.Serial>() {
                return MetadataViews.Serial(self.id)
            }

            if type ==  Type<MetadataViews.Editions>() {
                let editionInfo = MetadataViews.Edition(name: "Flobots", number: self.id, max: UInt64(9999))
                let editionList: [MetadataViews.Edition] = [editionInfo]
                return MetadataViews.Editions(
                    editionList
                )
            }

            if type == Type<MetadataViews.NFTCollectionDisplay>() {
                let mediaSquare = MetadataViews.Media(
                    file: MetadataViews.HTTPFile(
                        url: "https://images.flovatar.com/logo.svg"
                    ),
                    mediaType: "image/svg+xml"
                )
                let mediaBanner = MetadataViews.Media(
                    file: MetadataViews.HTTPFile(
                        url: "https://images.flovatar.com/logo-horizontal.svg"
                    ),
                    mediaType: "image/svg+xml"
                )
                return MetadataViews.NFTCollectionDisplay(
                    name: "Flovatar Flobot",
                    description: "Flovatar is pioneering a new way to unleash community creativity in Web3 by allowing users to be co-creators of their prized NFTs, instead of just being passive collectors.",
                    externalURL: MetadataViews.ExternalURL("https://flovatar.com"),
                    squareImage: mediaSquare,
                    bannerImage: mediaBanner,
                    socials: {
                        "discord": MetadataViews.ExternalURL("https://discord.gg/flovatar"),
                        "twitter": MetadataViews.ExternalURL("https://twitter.com/flovatar"),
                        "instagram": MetadataViews.ExternalURL("https://instagram.com/flovatar_nft"),
                        "tiktok": MetadataViews.ExternalURL("https://www.tiktok.com/@flovatar")
                    }
                )
            }

            if type == Type<MetadataViews.NFTCollectionData>() {
                return MetadataViews.NFTCollectionData(
                storagePath: Flobot.CollectionStoragePath,
                publicPath: Flobot.CollectionPublicPath,
                providerPath: /private/FlobotCollection,
                publicCollection: Type<&Flobot.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Flobot.CollectionPublic}>(),
                publicLinkedType: Type<&Flobot.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Flobot.CollectionPublic}>(),
                providerLinkedType: Type<&Flobot.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, Flobot.CollectionPublic}>(),
                createEmptyCollectionFunction: fun(): @NonFungibleToken.Collection {return <- Flobot.createEmptyCollection()}
                )
            }

            if type == Type<MetadataViews.Display>() {
                return MetadataViews.Display(
                    name: self.name == "" ? "Flobot #".concat(self.id.toString()) : self.name,
                    description: self.description,
                    thumbnail: MetadataViews.HTTPFile(
                        url: "https://images.flovatar.com/flobot/svg/".concat(self.id.toString()).concat(".svg")
                    )
                )
            }

            if type == Type<MetadataViews.Traits>() {
                let traits: [MetadataViews.Trait] = []
                let components: {String: UInt64} = self.metadata.getComponents()

                for k in components.keys {
                    if let template = FlovatarComponentTemplate.getComponentTemplate(id: components[k]!) {
                        let trait = MetadataViews.Trait(name: k, value: template.name, displayType:"String", rarity: MetadataViews.Rarity(score:nil, max:nil, description: template.rarity))
                        traits.append(trait)
                    }
                }
                if let background = self.getBackground() {
                    if let template = FlovatarComponentTemplate.getComponentTemplate(id: background) {
                        let trait = MetadataViews.Trait(name: template.category, value: template.name, displayType:"String", rarity: MetadataViews.Rarity(score:nil, max:nil, description: template.rarity))
                        traits.append(trait)
                    }
                }

                return MetadataViews.Traits(traits)
            }

            if type == Type<MetadataViews.Rarity>() {
                var score:UFix64 = 10.0
                if(self.metadata.rarity == "legendary"){
                    score = 100.0
                } else if(self.metadata.rarity == "epic"){
                     score = 50.0
                 }
                return MetadataViews.Rarity(score: score, max: 100.0, description: nil)
            }

            return nil
        }
    }


    // Standard NFT collectionPublic interface that can also borrowFlobot as the correct type
    pub resource interface CollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowFlobot(id: UInt64): &Flobot.NFT{Flobot.Public, MetadataViews.Resolver}? {
            // If the result isn't nil, the id of the returned reference
            // should be the same as the argument to the function
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow Flobot reference: The ID of the returned reference is incorrect"
            }
        }
    }

    // Main Collection to manage all the Flobot NFT
    pub resource Collection: CollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with an `UInt64` ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        // withdraw removes an NFT from the collection and moves it to the caller
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <- token
        }

        // deposit takes a NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @Flobot.NFT

            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        // getIDs returns an array of the IDs that are in the collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT gets a reference to an NFT in the collection
        // so that the caller can read its metadata and call its methods
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        // borrowFlobot returns a borrowed reference to a Flobot
        // so that the caller can read data and call methods from it.
        pub fun borrowFlobot(id: UInt64): &Flobot.NFT{Flobot.Public, MetadataViews.Resolver}? {
            if self.ownedNFTs[id] != nil {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                let flobotNFT = ref as! &Flobot.NFT
                return flobotNFT as &Flobot.NFT{Flobot.Public, MetadataViews.Resolver}
            } else {
                return nil
            }
        }

        // borrowFlobotPrivate returns a borrowed reference to a Flobot using the Private interface
        // so that the caller can read data and call methods from it, like setting the optional components.
        pub fun borrowFlobotPrivate(id: UInt64): &{Flobot.Private}? {
            if self.ownedNFTs[id] != nil {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &Flobot.NFT
            } else {
                return nil
            }
        }

        destroy() {
            destroy self.ownedNFTs
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            pre {
                self.ownedNFTs[id] != nil : "NFT does not exist"
            }
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let flobotNFT = nft as! &Flobot.NFT
            return flobotNFT as &AnyResource{MetadataViews.Resolver}
        }
    }

    // public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    // This struct is used to send a data representation of the Flobots
    // when retrieved using the contract helper methods outside the collection.
    pub struct FlobotData {
        pub let id: UInt64
        pub let name: String
        pub let metadata: Flobot.Metadata
        pub let backgroundId: UInt64?
        pub let bio: {String: String}
        init(
            id: UInt64,
            name: String,
            metadata: Flobot.Metadata,
            backgroundId: UInt64?,
            bio: {String: String}
            ) {
            self.id = id
            self.name = name
            self.metadata = metadata
            self.backgroundId = backgroundId
            self.bio = bio
        }
    }


    // This function will look for a specific Flobot on a user account and return a FlobotData if found
    pub fun getFlobot(address: Address, flobotId: UInt64) : FlobotData? {

        let account = getAccount(address)

        if let flobotCollection = account.getCapability(self.CollectionPublicPath).borrow<&{Flobot.CollectionPublic}>()  {
            if let flobot = flobotCollection.borrowFlobot(id: flobotId) {
                return FlobotData(
                    id: flobotId,
                    name: flobot!.getName(),
                    metadata: flobot!.getMetadata(),
                    backgroundId: flobot!.getBackground(),
                    bio: flobot!.getBio()
                )
            }
        }
        return nil
    }

    // This function will return all Flobots on a user account and return an array of FlobotData
    pub fun getFlobots(address: Address) : [FlobotData] {

        var flobotData: [FlobotData] = []
        let account = getAccount(address)

        if let flobotCollection = account.getCapability(self.CollectionPublicPath).borrow<&{Flobot.CollectionPublic}>()  {
            for id in flobotCollection.getIDs() {
                var flobot = flobotCollection.borrowFlobot(id: id)
                flobotData.append(FlobotData(
                    id: id,
                    name: flobot!.getName(),
                    metadata: flobot!.getMetadata(),
                    backgroundId: flobot!.getBackground(),
                    bio: flobot!.getBio()
                    ))
            }
        }
        return flobotData
    }


    // This returns all the previously minted combinations, so that duplicates won't be allowed
    pub fun getMintedCombinations() : [String] {
        return Flobot.mintedCombinations.keys
    }
    // This returns all the previously minted names, so that duplicates won't be allowed
    pub fun getMintedNames() : [String] {
        return Flobot.mintedNames.keys
    }

    // This function will add a minted combination to the array
    access(account) fun addMintedCombination(combination: String) {
        Flobot.mintedCombinations.insert(key: combination, true)
    }
    // This function will add a new name to the array
    access(account) fun addMintedName(name: String) {
        Flobot.mintedNames.insert(key: name, true)
    }

    // This helper function will generate a string from a list of components,
    // to be used as a sort of barcode to keep the inventory of the minted
    // Flobots and to avoid duplicates
    pub fun getCombinationString(
        body: UInt64,
        head: UInt64,
        arms: UInt64,
        legs: UInt64,
        face: UInt64
    ) : String {
        return "B".concat(body.toString()).concat("H").concat(head.toString()).concat("A").concat(arms.toString()).concat("L").concat(legs.toString()).concat("F").concat(face.toString())
    }

    // This function will get a list of component IDs and will check if the
    // generated string is unique or if someone already used it before.
    pub fun checkCombinationAvailable(
        body: UInt64,
        head: UInt64,
        arms: UInt64,
        legs: UInt64,
        face: UInt64
    ) : Bool {
        let combinationString = Flobot.getCombinationString(
            body: body,
            head: head,
            arms: arms,
            legs: legs,
            face: face
        )
        return ! Flobot.mintedCombinations.containsKey(combinationString)
    }

    // This will check if a specific Name has already been taken
    // and assigned to some Flobot
    pub fun checkNameAvailable(name: String) : Bool {
        return name.length > 2 && name.length < 20 && ! Flobot.mintedNames.containsKey(name)
    }


    // This is a public function that anyone can call to generate a new Flobot
    // A list of components resources needs to be passed to executed.
    // It will check first for uniqueness of the combination + name and will then
    // generate the Flobot and burn all the passed components.
    // The Spark NFT will entitle to use any common basic component (body, hair, etc.)
    // In order to use special rare components a boost of the same rarity will be needed
    // for each component used
    pub fun createFlobot(
        flobotkit: @[FlovatarComponent.NFT],
        body: UInt64,
        head: UInt64,
        arms: UInt64,
        legs: UInt64,
        face: UInt64,
        background: @FlovatarComponent.NFT?,
        address: Address
    ) : @Flobot.NFT {

        var i: Int = 0
        var flobotkitSeries:UInt32 = UInt32(0)
        var flobotkitRarity: String = ""
        var checkFlobotRarity:Bool = false
        var checkFlobotSeries:Bool = false

        while( i < flobotkit.length) {
            if(flobotkit[i].getCategory() != "flobotkit") {
                panic("The Flobot Kit belongs to the wrong category")
            }
            if(flobotkit[i].getSeries() != UInt32(2)) {
                panic("The Flobot Kit doesn't belong to the correct series")
            }
            if(flobotkitRarity != flobotkit[i].getRarity()){
                if(flobotkitRarity != ""){
                    checkFlobotRarity = true
                }
                flobotkitRarity = flobotkit[i].getRarity()
            }
            if(flobotkitSeries != flobotkit[i].getSeries()){
                if(flobotkitSeries != UInt32(0)){
                    checkFlobotSeries = true
                }
                flobotkitSeries = flobotkit[i].getSeries()
            }
            i = i + 1
        }

        if(checkFlobotRarity){
            panic("The Flobot Kits need to belong to the same Rarity level")
        }
        if(checkFlobotSeries){
            panic("The Flobot Kits need to belong to the same Series")
        }
        if(flobotkit.length != 1 && flobotkit.length != 5){
            panic("You need to pass either 1 Flobot Kit or 5 of them to access the next rarity level")
        }

        if(flobotkit.length == 5){
            if(flobotkitRarity == "common"){
                flobotkitRarity = "epic"
            } else if(flobotkitRarity == "epic"){
               flobotkitRarity = "legendary"
            } else {
                panic("Impossible to upgrade the Rarity level for the Flobot Kit")
            }
        }


        let bodyTemplate: FlovatarComponentTemplate.ComponentTemplateData = FlovatarComponentTemplate.getComponentTemplate(id: body)!
        let headTemplate: FlovatarComponentTemplate.ComponentTemplateData = FlovatarComponentTemplate.getComponentTemplate(id: head)!
        let armsTemplate: FlovatarComponentTemplate.ComponentTemplateData = FlovatarComponentTemplate.getComponentTemplate(id: arms)!
        let legsTemplate: FlovatarComponentTemplate.ComponentTemplateData = FlovatarComponentTemplate.getComponentTemplate(id: legs)!
        let faceTemplate: FlovatarComponentTemplate.ComponentTemplateData = FlovatarComponentTemplate.getComponentTemplate(id: face)!


        // Make sure that all components belong to the correct category
        if(bodyTemplate.category != "body") { panic("The body component belongs to the wrong category") }
        if(headTemplate.category != "head") { panic("The head component belongs to the wrong category") }
        if(armsTemplate.category != "arms") { panic("The arms component belongs to the wrong category") }
        if(legsTemplate.category != "legs") { panic("The legs component belongs to the wrong category") }
        if(faceTemplate.category != "face") { panic("The face component belongs to the wrong category") }


        // Make sure that all the components belong to the same series like the flobotkit
        if(bodyTemplate.series != flobotkitSeries) { panic("The body doesn't belong to the correct series") }
        if(headTemplate.series != flobotkitSeries) { panic("The head doesn't belong to the correct series") }
        if(armsTemplate.series != flobotkitSeries) { panic("The arms doesn't belong to the correct series") }
        if(legsTemplate.series != flobotkitSeries) { panic("The legs doesn't belong to the correct series") }
        if(faceTemplate.series != flobotkitSeries) { panic("The face doesn't belong to the correct series") }

        var flobotRarity: String = "common"

        if(bodyTemplate.rarity == "rare" ) { flobotRarity = "rare" }
        if(headTemplate.rarity == "rare" ) { flobotRarity = "rare" }
        if(armsTemplate.rarity == "rare" ) { flobotRarity = "rare" }
        if(legsTemplate.rarity == "rare" ) { flobotRarity = "rare" }
        if(faceTemplate.rarity == "rare" ) { flobotRarity = "rare" }

        if(bodyTemplate.rarity == "epic" ) { flobotRarity = "epic" }
        if(headTemplate.rarity == "epic" ) { flobotRarity = "epic" }
        if(armsTemplate.rarity == "epic" ) { flobotRarity = "epic" }
        if(legsTemplate.rarity == "epic" ) { flobotRarity = "epic" }
        if(faceTemplate.rarity == "epic" ) { flobotRarity = "epic" }

        if(bodyTemplate.rarity == "legendary" ) { flobotRarity = "legendary" }
        if(headTemplate.rarity == "legendary" ) { flobotRarity = "legendary" }
        if(armsTemplate.rarity == "legendary" ) { flobotRarity = "legendary" }
        if(legsTemplate.rarity == "legendary" ) { flobotRarity = "legendary" }
        if(faceTemplate.rarity == "legendary" ) { flobotRarity = "legendary" }


        if(background != nil){
            if(background?.getSeries() != UInt32(1) && !(background?.checkCategorySeries(category: "background", series: flobotkitSeries)!)){
                panic("The background component belongs to the wrong category or the wrong series")
            }
        }




        if(flobotRarity != flobotkitRarity){
            if((flobotRarity == "rare" && flobotkitRarity == "common")
                || (flobotRarity == "epic" && (flobotkitRarity == "common" || flobotkitRarity == "rare"))
                || flobotRarity == "legendary" && (flobotkitRarity == "common" || flobotkitRarity == "rare" || flobotkitRarity == "epic")){
                panic("The Rarity of your Flobot Constructor Kit is not high enough")
            }
        }




        // Generates the combination string to check for uniqueness.
        // This is like a barcode that defines exactly which components were used
        // to create the Flobot
        let combinationString = Flobot.getCombinationString(
            body: body,
            head: head,
            arms: arms,
            legs: legs,
            face: face)

        // Makes sure that the combination is available and not taken already
        if(Flobot.mintedCombinations.containsKey(combinationString) == true) {
            panic("This combination has already been taken")
        }


        // Creates the metadata for the new Flobot
        let metadata = Metadata(
            mint: Flobot.totalSupply + UInt64(1),
            series: flobotkitSeries,
            combination: combinationString,
            rarity: flobotRarity,
            creatorAddress: address,
            components: {
                "body": body,
                "head": head,
                "arms": arms,
                "legs": legs,
                "face": face
            }
        )

        let royalties: [Royalty] = []

        let creatorAccount = getAccount(address)
        royalties.append(Royalty(
            wallet: creatorAccount.getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),
            cut: Flobot.getRoyaltyCut(),
            type: RoyaltyType.percentage
        ))

        royalties.append(Royalty(
            wallet: self.account.getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),
            cut: Flobot.getMarketplaceCut(),
            type: RoyaltyType.percentage
        ))

        // Mint the new Flobot NFT by passing the metadata to it
        var newNFT <- create NFT(metadata: metadata, royalties: Royalties(royalty: royalties))

        // Adds the combination to the arrays to remember it
        Flobot.addMintedCombination(combination: combinationString)


        // Checks for any additional optional component (accessory, hat,
        // eyeglasses, background) and assigns it to the Flobot if present.

        if(background != nil){
            let temp <- newNFT.setBackground(component: <-background!)
            destroy temp
        } else {
            destroy background
        }

        // Emits the Created event to notify about its existence
        emit Created(id: newNFT.id, metadata: metadata)

        // Destroy all the flobotkit and the rarity boost since they are not needed anymore.

        destroy flobotkit

        return <- newNFT
    }



    // These functions will return the current Royalty cuts for
    // both the Creator and the Marketplace.
    pub fun getRoyaltyCut(): UFix64{
        return self.royaltyCut
    }
    pub fun getMarketplaceCut(): UFix64{
        return self.marketplaceCut
    }
    // Only Admins will be able to call the set functions to
    // manage Royalties and Marketplace cuts.
    access(account) fun setRoyaltyCut(value: UFix64){
        self.royaltyCut = value
    }
    access(account) fun setMarketplaceCut(value: UFix64){
        self.marketplaceCut = value
    }




    // This is the main Admin resource that will allow the owner
    // to generate new Templates, Components and Packs
    pub resource Admin {


        // With this function you can generate a new Admin resource
        // and pass it to another user if needed
        pub fun createNewAdmin(): @Admin {
            return <-create Admin()
        }

        // Helper functions to update the Royalty cut
        pub fun setRoyaltyCut(value: UFix64) {
            Flobot.setRoyaltyCut(value: value)
        }

        // Helper functions to update the Marketplace cut
        pub fun setMarketplaceCut(value: UFix64) {
            Flobot.setMarketplaceCut(value: value)
        }
    }





	init() {
        self.CollectionPublicPath = /public/FlobotCollection
        self.CollectionStoragePath = /storage/FlobotCollection
        self.AdminStoragePath = /storage/FlobotAdmin

        // Initialize the total supply
        self.totalSupply = UInt64(0)
        self.mintedCombinations = {}
        self.mintedNames = {}

        // Set the default Royalty and Marketplace cuts
        self.royaltyCut = 0.01
        self.marketplaceCut = 0.05

        self.account.save<@NonFungibleToken.Collection>(<- Flobot.createEmptyCollection(), to: Flobot.CollectionStoragePath)
        self.account.link<&{Flobot.CollectionPublic}>(Flobot.CollectionPublicPath, target: Flobot.CollectionStoragePath)

        // Put the Admin resource in storage
        self.account.save<@Admin>(<- create Admin(), to: self.AdminStoragePath)

        emit ContractInitialized()
	}
}
"
-------
"/**

# The contract implementation of the lending pool.

# Author: Increment Labs

Core functionalities of the lending pool smart contract supporting cross-market supply, redeem, borrow, repay, and liquidation.
Multiple LendingPool contracts will be deployed for each of the different pooled underlying FungibleTokens.

*/
import FungibleToken from 0xf233dcee88fe0abe
import LendingInterfaces from 0x2df970b6cdee5735
import LendingConfig from 0x2df970b6cdee5735
import LendingError from 0x2df970b6cdee5735

pub contract LendingPool {
    /// Account address the pool is deployed to, i.e. the pool 'contract address'
    pub let poolAddress: Address
    /// Initial exchange rate (when LendingPool.totalSupply == 0) between the virtual lpToken and pool underlying token
    pub let scaledInitialExchangeRate: UInt256
    /// Block number that interest was last accrued at
    pub var accrualBlockNumber: UInt256
    /// Accumulator of the total earned interest rate since the opening of the market, scaled up by 1e18
    pub var scaledBorrowIndex: UInt256
    /// Total amount of outstanding borrows of the underlying in this market, scaled up by 1e18
    pub var scaledTotalBorrows: UInt256
    /// Total amount of reserves of the underlying held in this market, scaled up by 1e18
    pub var scaledTotalReserves: UInt256
    /// Total number of virtual lpTokens, scaled up by 1e18
    pub var scaledTotalSupply: UInt256
    /// Fraction of generated interest added to protocol reserves, scaled up by 1e18
    /// Must be in [0.0, 1.0] x scaleFactor
    pub var scaledReserveFactor: UInt256
    /// Share of seized collateral that is added to reserves when liquidation happenes, e.g. 0.028 x 1e18.
    /// Must be in [0.0, 1.0] x scaleFactor
    pub var scaledPoolSeizeShare: UInt256
    /// { supplierAddress => # of virtual lpToken the supplier owns, scaled up by 1e18 }
    access(self) let accountLpTokens: {Address: UInt256}
    /// Reserved parameter fields: {ParamName: Value}
    /// Used fields:
    ///   |__ 1. "flashloanRateBps" -> UInt64
    ///   |__ 2. "isFlashloanOpen" -> Bool
    access(self) let _reservedFields: {String: AnyStruct}

    /// BorrowSnapshot
    ///
    /// Container for borrow balance information
    ///
    pub struct BorrowSnapshot {
        /// Total balance (with accrued interest), after applying the most recent balance-change action
        pub var scaledPrincipal: UInt256
        /// Global borrowIndex as of the most recent balance-change action
        pub var scaledInterestIndex: UInt256

        init(principal: UInt256, interestIndex: UInt256) {
            self.scaledPrincipal = principal
            self.scaledInterestIndex = interestIndex
        }
    }

    // { borrowerAddress => BorrowSnapshot }
    access(self) let accountBorrows: {Address: BorrowSnapshot}

    /// Model used to calculate underlying asset's borrow interest rate
    pub var interestRateModelAddress: Address?
    pub var interestRateModelCap: Capability<&{LendingInterfaces.InterestRateModelPublic}>?

    /// The address of the comptroller contract
    pub var comptrollerAddress: Address?
    pub var comptrollerCap: Capability<&{LendingInterfaces.ComptrollerPublic}>?

    /// Save underlying asset deposited into this pool
    access(self) let underlyingVault: @FungibleToken.Vault
    /// Underlying type
    access(self) let underlyingAssetType: Type

    /// Path
    pub let PoolAdminStoragePath: StoragePath
    pub let UnderlyingAssetVaultStoragePath: StoragePath
    pub let PoolPublicStoragePath: StoragePath
    pub let PoolPublicPublicPath: PublicPath

    /// Event emitted when interest is accrued
    pub event AccrueInterest(_ scaledCashPrior: UInt256, _ scaledInterestAccumulated: UInt256, _ scaledBorrowIndexNew: UInt256, _ scaledTotalBorrowsNew: UInt256)
    /// Event emitted when underlying asset is deposited into pool
    pub event Supply(supplier: Address, scaledSuppliedUnderlyingAmount: UInt256, scaledMintedLpTokenAmount: UInt256)
    /// Event emitted when virtual lpToken is burnt and redeemed for underlying asset
    pub event Redeem(redeemer: Address, scaledLpTokenToRedeem: UInt256, scaledRedeemedUnderlyingAmount: UInt256)
    /// Event emitted when user borrows underlying from the pool
    pub event Borrow(borrower: Address, scaledBorrowAmount: UInt256, scaledBorrowerTotalBorrows: UInt256, scaledPoolTotalBorrows: UInt256)
    /// Event emitted when user repays underlying to pool
    pub event Repay(borrower: Address, scaledActualRepayAmount: UInt256, scaledBorrowerTotalBorrows: UInt256, scaledPoolTotalBorrows: UInt256)
    /// Event emitted when pool reserves get added
    pub event ReservesAdded(donator: Address, scaledAddedUnderlyingAmount: UInt256, scaledNewTotalReserves: UInt256)
    /// Event emitted when pool reserves is reduced
    pub event ReservesReduced(scaledReduceAmount: UInt256, scaledNewTotalReserves: UInt256)
    /// Event emitted when liquidation happenes
    pub event Liquidate(liquidator: Address, borrower: Address, scaledActualRepaidUnderlying: UInt256, collateralPoolToSeize: Address, scaledCollateralPoolLpTokenSeized: UInt256)
    /// Event emitted when interestRateModel is changed
    pub event NewInterestRateModel(_ oldInterestRateModelAddress: Address?, _ newInterestRateModelAddress: Address)
    /// Event emitted when the reserveFactor is changed
    pub event NewReserveFactor(_ oldReserveFactor: UFix64, _ newReserveFactor: UFix64)
    /// Event emitted when the poolSeizeShare is changed
    pub event NewPoolSeizeShare(_ oldPoolSeizeShare: UFix64, _ newPoolSeizeShare: UFix64)
    /// Event emitted when the comptroller is changed
    pub event NewComptroller(_ oldComptrollerAddress: Address?, _ newComptrollerAddress: Address)
    /// Event emitted when the flashloanRateChanged is changed
    pub event FlashloanRateChanged(oldRateBps: UInt64, newRateBps: UInt64)
    /// Event emitted when the isFlashloanOpen is changed
    pub event FlashloanOpen(isOpen: Bool)
    /// Event emitted when the flashloan is executed
    pub event Flashloan(executor: Address, executorType: Type, originator: Address, amount: UFix64)

    // Return underlying asset's type of current pool
    pub fun getUnderlyingAssetType(): String {
        return self.underlyingAssetType.identifier
    }

    // Gets current underlying balance of this pool, scaled up by 1e18
    pub fun getPoolCash(): UInt256 {
        return LendingConfig.UFix64ToScaledUInt256(self.underlyingVault.balance)
    }

    /// Cal accrue interest
    ///
    /// @Return 0. currentBlockNumber - The block number of current calculation of interest
    ///         1. scaledBorrowIndexNew - The new accumulator of the total earned interest rate since the opening of the market
    ///         2. scaledTotalBorrowsNew - The new total borrows after accrue interest
    ///         3. scaledTotalReservesNew - The new total reserves after accrue interest
    ///
    /// Calculates interest accrued from the last checkpointed block to the current block
    /// This function is a readonly function and can be called by scripts.
    ///
    pub fun accrueInterestReadonly(): [UInt256; 4] {
        pre {
            self.interestRateModelCap != nil && self.interestRateModelCap!.check() == true:
                LendingError.ErrorEncode(
                    msg: "Cannot borrow reference to InterestRateModel in pool ".concat(LendingPool.poolAddress.toString()),
                    err: LendingError.ErrorCode.CANNOT_ACCESS_INTEREST_RATE_MODEL_CAPABILITY
                )
        }
        let currentBlockNumber = UInt256(getCurrentBlock().height)
        let accrualBlockNumberPrior = self.accrualBlockNumber

        let scaledCashPrior = self.getPoolCash()
        let scaledBorrowPrior = self.scaledTotalBorrows
        let scaledReservesPrior = self.scaledTotalReserves
        let scaledBorrowIndexPrior = self.scaledBorrowIndex

        // Get scaled borrow interest rate per block
        let scaledBorrowRatePerBlock =
            self.interestRateModelCap!.borrow()!.getBorrowRate(cash: scaledCashPrior, borrows: scaledBorrowPrior, reserves: scaledReservesPrior)
        let blockDelta = currentBlockNumber - accrualBlockNumberPrior
        let scaledInterestFactor = scaledBorrowRatePerBlock * blockDelta
        let scaleFactor = LendingConfig.scaleFactor
        let scaledInterestAccumulated = scaledInterestFactor * scaledBorrowPrior / scaleFactor
        let scaledTotalBorrowsNew = scaledInterestAccumulated + scaledBorrowPrior
        let scaledTotalReservesNew = self.scaledReserveFactor * scaledInterestAccumulated / scaleFactor + scaledReservesPrior
        let scaledBorrowIndexNew = scaledInterestFactor * scaledBorrowIndexPrior / scaleFactor + scaledBorrowIndexPrior

        return [
            currentBlockNumber,
            scaledBorrowIndexNew,
            scaledTotalBorrowsNew,
            scaledTotalReservesNew
        ]
    }

    /// Accrue Interest
    ///
    /// Applies accrued interest to total borrows and reserves.
    ///
    pub fun accrueInterest() {
        // Return early if accrue 0 interest
        if (UInt256(getCurrentBlock().height) == self.accrualBlockNumber) {
            return
        }
        let scaledCashPrior = self.getPoolCash()
        let scaledBorrowPrior = self.scaledTotalBorrows

        let res = self.accrueInterestReadonly()

        // Write calculated values into contract storage
        self.accrualBlockNumber = res[0]
        self.scaledBorrowIndex = res[1]
        self.scaledTotalBorrows = res[2]
        self.scaledTotalReserves = res[3]

        emit AccrueInterest(scaledCashPrior, res[2]-scaledBorrowPrior, self.scaledBorrowIndex, self.scaledTotalBorrows)
    }

    /// Calculates the exchange rate from the underlying to virtual lpToken (i.e. how many UnderlyingToken per virtual lpToken)
    /// Note: It doesn't call accrueInterest() first to update with latest states which is used in calculating the exchange rate.
    ///
    pub fun underlyingToLpTokenRateSnapshotScaled(): UInt256 {
        if (self.scaledTotalSupply == 0) {
            return self.scaledInitialExchangeRate
        } else {
            return (self.getPoolCash() + self.scaledTotalBorrows - self.scaledTotalReserves) * LendingConfig.scaleFactor / self.scaledTotalSupply
        }
    }

    /// Calculates the scaled borrow balance of borrower address based on stored states
    /// Note: It doesn't call accrueInterest() first to update with latest states which is used in calculating the borrow balance.
    ///
    pub fun borrowBalanceSnapshotScaled(borrowerAddress: Address): UInt256 {
        if (self.accountBorrows.containsKey(borrowerAddress) == false) {
            return 0
        }
        let borrower = self.accountBorrows[borrowerAddress]!
        return borrower.scaledPrincipal * self.scaledBorrowIndex / borrower.scaledInterestIndex
    }

    /// Supplier deposits underlying asset's Vault into the pool.
    ///
    /// @Param SupplierAddr - The address of the account which is supplying the assets
    /// @Param InUnderlyingVault - The vault for deposit and its type should match the pool's underlying token type
    ///
    /// Interest will be accrued up to the current block.
    /// The lending pool will mint the corresponding lptoken according to the current
    /// exchange rate of lptoken as the user's deposit certificate and save it in the contract.
    ///
    pub fun supply(supplierAddr: Address, inUnderlyingVault: @FungibleToken.Vault) {
        pre {
            inUnderlyingVault.balance > 0.0:
                LendingError.ErrorEncode(msg: "Supplied zero", err: LendingError.ErrorCode.EMPTY_FUNGIBLE_TOKEN_VAULT)
            inUnderlyingVault.isInstance(self.underlyingAssetType):
                LendingError.ErrorEncode(
                    msg: "Supplied vault and pool underlying type mismatch",
                    err: LendingError.ErrorCode.MISMATCHED_INPUT_VAULT_TYPE_WITH_POOL
                )
        }

        // 1. Accrues interests and checkpoints latest states
        self.accrueInterest()

        // 2. Check whether or not supplyAllowed()
        let scaledAmount = LendingConfig.UFix64ToScaledUInt256(inUnderlyingVault.balance)
        let err = self.comptrollerCap!.borrow()!.supplyAllowed(
            poolCertificate: <- create PoolCertificate(),
            poolAddress: self.poolAddress,
            supplierAddress: supplierAddr,
            supplyUnderlyingAmountScaled: scaledAmount
        )
        assert(err == nil, message: err ?? "")

        // 3. Deposit into underlying vault and mint corresponding PoolTokens
        let underlyingToken2LpTokenRateScaled = self.underlyingToLpTokenRateSnapshotScaled()
        let scaledMintVirtualAmount = scaledAmount * LendingConfig.scaleFactor / underlyingToken2LpTokenRateScaled
        // mint pool tokens for supply certificate
        self.accountLpTokens[supplierAddr] = scaledMintVirtualAmount + (self.accountLpTokens[supplierAddr] ?? 0)
        self.scaledTotalSupply = self.scaledTotalSupply + scaledMintVirtualAmount
        self.underlyingVault.deposit(from: <-inUnderlyingVault)

        emit Supply(supplier: supplierAddr, scaledSuppliedUnderlyingAmount: scaledAmount, scaledMintedLpTokenAmount: scaledMintVirtualAmount)
    }

    /// Redeems lpTokens for the underlying asset's vault
    /// or
    /// Redeems lpTokens for a specified amount of underlying asset
    ///
    /// @Param redeemer - The address of the account which is redeeming the tokens
    /// @Param numLpTokenToRedeem - The number of lpTokens to redeem into underlying (only one of numLpTokenToRedeem or numUnderlyingToRedeem may be non-zero)
    /// @Param numUnderlyingToRedeem - The amount of underlying to receive from redeeming lpTokens
    /// @Return The redeemed vault resource of pool's underlying token
    ///
    /// Since redeemer decreases his overall collateral ratio across all markets, safety check happenes inside comptroller.
    ///
    access(self) fun redeemInternal(
        redeemer: Address,
        numLpTokenToRedeem: UFix64,
        numUnderlyingToRedeem: UFix64
    ): @FungibleToken.Vault {
        pre {
            numLpTokenToRedeem == 0.0 || numUnderlyingToRedeem == 0.0:
                LendingError.ErrorEncode(
                    msg: "numLpTokenToRedeem or numUnderlyingToRedeem must be 0.0.",
                    err: LendingError.ErrorCode.INVALID_PARAMETERS
                )
            self.accountLpTokens.containsKey(redeemer):
                LendingError.ErrorEncode(
                    msg: "redeemer has no supply to redeem from",
                    err: LendingError.ErrorCode.REDEEM_FAILED_NO_ENOUGH_LP_TOKEN
                )
        }

        // 1. Accrues interests and checkpoints latest states
        self.accrueInterest()

        // 2. Check whether or not redeemAllowed()
        var scaledLpTokenToRedeem: UInt256 = 0
        var scaledUnderlyingToRedeem: UInt256 = 0
        let scaledUnderlyingToLpRate = self.underlyingToLpTokenRateSnapshotScaled()
        let scaleFactor = LendingConfig.scaleFactor
        if (numLpTokenToRedeem == 0.0) {
            // redeem all
            // the special value of `UFIx64.max` indicating to redeem all virtual LP tokens the redeemer has
            if numUnderlyingToRedeem == UFix64.max {
                scaledLpTokenToRedeem = self.accountLpTokens[redeemer]!
                scaledUnderlyingToRedeem = scaledLpTokenToRedeem * scaledUnderlyingToLpRate / scaleFactor
            } else {
                scaledLpTokenToRedeem = LendingConfig.UFix64ToScaledUInt256(numUnderlyingToRedeem) * scaleFactor / scaledUnderlyingToLpRate
                scaledUnderlyingToRedeem = LendingConfig.UFix64ToScaledUInt256(numUnderlyingToRedeem)
            }
        } else {
            if numLpTokenToRedeem == UFix64.max {
                scaledLpTokenToRedeem = self.accountLpTokens[redeemer]!
            } else {
                scaledLpTokenToRedeem = LendingConfig.UFix64ToScaledUInt256(numLpTokenToRedeem)
            }
            scaledUnderlyingToRedeem = scaledLpTokenToRedeem * scaledUnderlyingToLpRate / scaleFactor
        }

        assert(scaledLpTokenToRedeem <= self.accountLpTokens[redeemer]!, message:
            LendingError.ErrorEncode(
                msg: "exceeded redeemer lp token balance",
                err: LendingError.ErrorCode.REDEEM_FAILED_NO_ENOUGH_LP_TOKEN
            )
        )

        let err = self.comptrollerCap!.borrow()!.redeemAllowed(
            poolCertificate: <- create PoolCertificate(),
            poolAddress: self.poolAddress,
            redeemerAddress: redeemer,
            redeemLpTokenAmountScaled: scaledLpTokenToRedeem,
        )
        assert(err == nil, message: err ?? "")

        // 3. Burn virtual lpTokens, withdraw from underlying vault and return it
        assert(scaledUnderlyingToRedeem <= self.getPoolCash(), message:
            LendingError.ErrorEncode(
                msg: "insufficient pool liquidity to redeem",
                err: LendingError.ErrorCode.INSUFFICIENT_POOL_LIQUIDITY
            )
        )

        self.scaledTotalSupply = self.scaledTotalSupply - scaledLpTokenToRedeem
        if (self.accountLpTokens[redeemer] == scaledLpTokenToRedeem) {
            self.accountLpTokens.remove(key: redeemer)
        } else {
            self.accountLpTokens[redeemer] = self.accountLpTokens[redeemer]! - scaledLpTokenToRedeem
        }
        emit Redeem(
            redeemer: redeemer,
            scaledLpTokenToRedeem: scaledLpTokenToRedeem,
            scaledRedeemedUnderlyingAmount: scaledUnderlyingToRedeem
        )
        let amountUnderlyingToRedeem = LendingConfig.ScaledUInt256ToUFix64(scaledUnderlyingToRedeem)
        return <- self.underlyingVault.withdraw(amount: amountUnderlyingToRedeem)
    }

    /// User redeems lpTokens for the underlying asset's vault
    ///
    /// @Param userCertificateCap - User identity certificate and it can provide a valid user address proof
    /// @Param numLpTokenToRedeem - The number of lpTokens to redeem into underlying
    /// @Return The redeemed vault resource of pool's underlying token
    ///
    /// @Notice It is more convenient to use a resource certificate on flow for authentication than signing a signature.
    ///
    /// RedeemerAddress is inferred from the private capability to the IdentityCertificate resource,
    /// which is stored in user account and can only be given by its owner.
    /// The special value of numLpTokenToRedeem `UFIx64.max` indicating to redeem all virtual LP tokens the redeemer has.
    ///
    pub fun redeem(
        userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>,
        numLpTokenToRedeem: UFix64
    ): @FungibleToken.Vault {
        pre {
            numLpTokenToRedeem > 0.0: LendingError.ErrorEncode(msg: "Redeemed zero", err: LendingError.ErrorCode.INVALID_PARAMETERS)
            userCertificateCap.check() && userCertificateCap.borrow()!.owner != nil:
                LendingError.ErrorEncode(
                    msg: "Cannot borrow reference to IdentityCertificate",
                    err: LendingError.ErrorCode.INVALID_USER_CERTIFICATE
                )
            self.checkUserCertificateType(certCap: userCertificateCap):
                LendingError.ErrorEncode(
                    msg: "Certificate not issued by system",
                    err: LendingError.ErrorCode.INVALID_USER_CERTIFICATE
                )
        }

        let redeemerAddress = userCertificateCap.borrow()!.owner!.address
        let res <- self.redeemInternal(
            redeemer: redeemerAddress,
            numLpTokenToRedeem: numLpTokenToRedeem,
            numUnderlyingToRedeem: 0.0
        )

        return <- res
    }

    /// User redeems lpTokens for a specified amount of underlying asset
    ///
    /// @Param userCertificateCap - User identity certificate and it can provide a valid user address proof
    /// @Param numUnderlyingToRedeem - The amount of underlying to receive from redeeming lpTokens
    /// @Return The redeemed vault resource of pool's underlying token
    ///
    /// @Notice It is more convenient to use a resource certificate on flow for authentication than signing a signature.
    ///
    /// RedeemerAddress is inferred from the private capability to the IdentityCertificate resource,
    /// which is stored in user account and can only be given by its owner.
    /// The special value of numUnderlyingToRedeem `UFIx64.max` indicating to redeem all the underlying liquidity.
    ///
    pub fun redeemUnderlying(
        userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>,
        numUnderlyingToRedeem: UFix64
    ): @FungibleToken.Vault {
        pre {
            numUnderlyingToRedeem > 0.0: LendingError.ErrorEncode(msg: "Redeemed zero", err: LendingError.ErrorCode.INVALID_PARAMETERS)
            userCertificateCap.check() && userCertificateCap.borrow()!.owner != nil:
                LendingError.ErrorEncode(
                    msg: "Cannot borrow reference to IdentityCertificate",
                    err: LendingError.ErrorCode.INVALID_USER_CERTIFICATE
                )
            self.checkUserCertificateType(certCap: userCertificateCap):
                LendingError.ErrorEncode(
                    msg: "Certificate not issued by system",
                    err: LendingError.ErrorCode.INVALID_USER_CERTIFICATE
                )
        }
        let redeemerAddress = userCertificateCap.borrow()!.owner!.address
        let res <- self.redeemInternal(
            redeemer: redeemerAddress,
            numLpTokenToRedeem: 0.0,
            numUnderlyingToRedeem: numUnderlyingToRedeem
        )

        return <- res
    }

    /// User borrows underlying asset from the pool.
    ///
    /// @Param userCertificateCap - User identity certificate and it can provide a valid user address proof
    /// @Param borrowAmount - The amount of the underlying asset to borrow
    /// @Return The vault of borrow asset
    ///
    /// @Notice It is more convenient to use a resource certificate on flow for authentication than signing a signature.
    ///
    /// Since borrower would decrease his overall collateral ratio across all markets, safety check happenes inside comptroller
    ///
    pub fun borrow(
        userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>,
        borrowAmount: UFix64,
    ): @FungibleToken.Vault {
        pre {
            borrowAmount > 0.0: LendingError.ErrorEncode(msg: "borrowAmount zero", err: LendingError.ErrorCode.INVALID_PARAMETERS)
            userCertificateCap.check() && userCertificateCap.borrow()!.owner != nil:
                LendingError.ErrorEncode(
                    msg: "Cannot borrow reference to IdentityCertificate",
                    err: LendingError.ErrorCode.INVALID_USER_CERTIFICATE
                )
            self.checkUserCertificateType(certCap: userCertificateCap):
                LendingError.ErrorEncode(
                    msg: "Certificate not issued by system",
                    err: LendingError.ErrorCode.INVALID_USER_CERTIFICATE
                )
        }
        // 1. Accrues interests and checkpoints latest states
        self.accrueInterest()

        // 2. Pool liquidity check
        let scaledBorrowAmount = LendingConfig.UFix64ToScaledUInt256(borrowAmount)
        assert(scaledBorrowAmount <= self.getPoolCash(), message:
            LendingError.ErrorEncode(
                msg: "insufficient pool liquidity to borrow",
                err: LendingError.ErrorCode.INSUFFICIENT_POOL_LIQUIDITY
            )
        )

        // 3. Check whether or not borrowAllowed()
        let borrower = userCertificateCap.borrow()!.owner!.address
        let err = self.comptrollerCap!.borrow()!.borrowAllowed(
            poolCertificate: <- create PoolCertificate(),
            poolAddress: self.poolAddress,
            borrowerAddress: borrower,
            borrowUnderlyingAmountScaled: scaledBorrowAmount
        )
        assert(err == nil, message: err ?? "")

        // 4. Updates borrow states, withdraw from pool underlying vault and deposits into borrower's account
        self.scaledTotalBorrows = self.scaledTotalBorrows + scaledBorrowAmount
        let scaledBorrowBalanceNew = scaledBorrowAmount + self.borrowBalanceSnapshotScaled(borrowerAddress: borrower)
        self.accountBorrows[borrower] = BorrowSnapshot(principal: scaledBorrowBalanceNew, interestIndex: self.scaledBorrowIndex)
        emit Borrow(borrower: borrower, scaledBorrowAmount: scaledBorrowAmount, scaledBorrowerTotalBorrows: scaledBorrowBalanceNew, scaledPoolTotalBorrows: self.scaledTotalBorrows)

        let res <- self.underlyingVault.withdraw(amount: borrowAmount)
        return <- res
    }

    /// Repay the borrower's borrow
    ///
    /// @Param borrower - The address of the borrower
    /// @Param borrowAmount - The amount to repay
    /// @Return The overpaid vault will be returned.
    ///
    /// @Note: Caller ensures that LendingPool.accrueInterest() has been called with latest states checkpointed
    ///
    access(self) fun repayBorrowInternal(borrower: Address, repayUnderlyingVault: @FungibleToken.Vault): @FungibleToken.Vault? {
        // Check whether or not repayAllowed()
        let scaledRepayAmount = LendingConfig.UFix64ToScaledUInt256(repayUnderlyingVault.balance)
        let scaledAccountTotalBorrows = self.borrowBalanceSnapshotScaled(borrowerAddress: borrower)
        let scaledActualRepayAmount = scaledAccountTotalBorrows > scaledRepayAmount ? scaledRepayAmount : scaledAccountTotalBorrows

        let err = self.comptrollerCap!.borrow()!.repayAllowed(
            poolCertificate: <- create PoolCertificate(),
            poolAddress: self.poolAddress,
            borrowerAddress: borrower,
            repayUnderlyingAmountScaled: scaledActualRepayAmount
        )
        assert(err == nil, message: err ?? "")

        // Updates borrow states, deposit repay Vault into pool underlying vault and return any remaining Vault
        let scaledAccountTotalBorrowsNew = scaledAccountTotalBorrows > scaledRepayAmount ? scaledAccountTotalBorrows - scaledRepayAmount : (0 as UInt256)
        self.scaledTotalBorrows = self.scaledTotalBorrows - scaledActualRepayAmount
        emit Repay(borrower: borrower, scaledActualRepayAmount: scaledActualRepayAmount, scaledBorrowerTotalBorrows: scaledAccountTotalBorrowsNew, scaledPoolTotalBorrows: self.scaledTotalBorrows)
        if (scaledAccountTotalBorrows > scaledRepayAmount) {
            self.accountBorrows[borrower] = BorrowSnapshot(principal: scaledAccountTotalBorrowsNew, interestIndex: self.scaledBorrowIndex)
            self.underlyingVault.deposit(from: <-repayUnderlyingVault)
            return nil
        } else {
            self.accountBorrows.remove(key: borrower)
            let surplusAmount = LendingConfig.ScaledUInt256ToUFix64(scaledRepayAmount - scaledAccountTotalBorrows)
            self.underlyingVault.deposit(from: <-repayUnderlyingVault)
            return <- self.underlyingVault.withdraw(amount: surplusAmount)
        }
    }

    /// Anyone can repay borrow with a underlying Vault and receives a new underlying Vault if there's still any remaining left.
    ///
    /// @Param borrower - The address of the borrower
    /// @Param borrowAmount - The amount to repay
    /// @Return The overpaid vault will be returned.
    ///
    /// @Note: Note that the borrower address can potentially not be the same as the repayer address (which means someone can repay on behave of borrower),
    ///        this is allowed as there's no safety issue to do so.
    ///
    pub fun repayBorrow(borrower: Address, repayUnderlyingVault: @FungibleToken.Vault): @FungibleToken.Vault? {
        pre {
            repayUnderlyingVault.balance > 0.0: LendingError.ErrorEncode(msg: "Repaid zero", err: LendingError.ErrorCode.EMPTY_FUNGIBLE_TOKEN_VAULT)
            repayUnderlyingVault.isInstance(self.underlyingAssetType):
                LendingError.ErrorEncode(
                    msg: "Repaid vault and pool underlying type mismatch",
                    err: LendingError.ErrorCode.MISMATCHED_INPUT_VAULT_TYPE_WITH_POOL
                )
        }
        // Accrues interests and checkpoints latest states
        self.accrueInterest()

        let res <- self.repayBorrowInternal(borrower: borrower, repayUnderlyingVault: <-repayUnderlyingVault)

        return <- res
    }

    /// Liquidates the borrowers collateral.
    ///
    /// @Param liquidator - The address of the liquidator who will receive the collateral lpToken transfer
    /// @Param borrower - The borrower to be liquidated
    /// @Param poolCollateralizedToSeize - The market address in which to seize collateral from the borrower
    /// @Param repayUnderlyingVault - The amount of the underlying borrowed asset in this pool to repay
    /// @Return The overLiquidate vault will be returned.
    ///
    /// The collateral lpTokens seized is transferred to the liquidator.
    ///
    pub fun liquidate(
        liquidator: Address,
        borrower: Address,
        poolCollateralizedToSeize: Address,
        repayUnderlyingVault: @FungibleToken.Vault
    ): @FungibleToken.Vault? {
        pre {
            repayUnderlyingVault.balance > 0.0: LendingError.ErrorEncode(msg: "Liquidator repaid zero", err: LendingError.ErrorCode.EMPTY_FUNGIBLE_TOKEN_VAULT)
            repayUnderlyingVault.isInstance(self.underlyingAssetType):
                LendingError.ErrorEncode(
                    msg: "Liquidator repaid vault and pool underlying type mismatch",
                    err: LendingError.ErrorCode.MISMATCHED_INPUT_VAULT_TYPE_WITH_POOL
                )
        }
        // 1. Accrues interests and checkpoints latest states
        self.accrueInterest()

        // 2. Check whether or not liquidateAllowed()
        let scaledUnderlyingAmountToRepay = LendingConfig.UFix64ToScaledUInt256(repayUnderlyingVault.balance)
        let err = self.comptrollerCap!.borrow()!.liquidateAllowed(
            poolCertificate: <- create PoolCertificate(),
            poolBorrowed: self.poolAddress,
            poolCollateralized: poolCollateralizedToSeize,
            borrower: borrower,
            repayUnderlyingAmountScaled: scaledUnderlyingAmountToRepay
        )
        assert(err == nil, message: err ?? "")

        // 3. Liquidator repays on behave of borrower
        assert(liquidator != borrower, message:
            LendingError.ErrorEncode(
                msg: "liquidator and borrower cannot be the same",
                err: LendingError.ErrorCode.SAME_LIQUIDATOR_AND_BORROWER
            )
        )
        let remainingVault <- self.repayBorrowInternal(borrower: borrower, repayUnderlyingVault: <-repayUnderlyingVault)

        let scaledRemainingAmount = LendingConfig.UFix64ToScaledUInt256(remainingVault?.balance ?? 0.0)
        let scaledActualRepayAmount = scaledUnderlyingAmountToRepay - scaledRemainingAmount
        // Calculate collateralLpTokenSeizedAmount based on actualRepayAmount
        let scaledCollateralLpTokenSeizedAmount = self.comptrollerCap!.borrow()!.calculateCollateralPoolLpTokenToSeize(
            borrower: borrower,
            borrowPool: self.poolAddress,
            collateralPool: poolCollateralizedToSeize,
            actualRepaidBorrowAmountScaled: scaledActualRepayAmount
        )

        // 4. seizeInternal if current pool is also borrower's collateralPool; otherwise seize external collateralPool
        if (poolCollateralizedToSeize == self.poolAddress) {
            self.seizeInternal(
                liquidator: liquidator,
                borrower: borrower,
                scaledBorrowerLpTokenToSeize: scaledCollateralLpTokenSeizedAmount
            )
        } else {
            // Seize external
            let externalPoolPublicRef = getAccount(poolCollateralizedToSeize)
                .getCapability<&{LendingInterfaces.PoolPublic}>(LendingConfig.PoolPublicPublicPath).borrow()
                    ?? panic(
                        LendingError.ErrorEncode(
                            msg: "Cannot borrow reference to external PoolPublic resource",
                            err: LendingError.ErrorCode.CANNOT_ACCESS_POOL_PUBLIC_CAPABILITY
                        )
                    )
            externalPoolPublicRef.seize(
                seizerPoolCertificate: <- create PoolCertificate(),
                seizerPool: self.poolAddress,
                liquidator: liquidator,
                borrower: borrower,
                scaledBorrowerCollateralLpTokenToSeize: scaledCollateralLpTokenSeizedAmount
            )
        }

        emit Liquidate(
            liquidator: liquidator,
            borrower: borrower,
            scaledActualRepaidUnderlying: scaledActualRepayAmount,
            collateralPoolToSeize: poolCollateralizedToSeize,
            scaledCollateralPoolLpTokenSeized: scaledCollateralLpTokenSeizedAmount
        )

        return <-remainingVault
    }

    /// External seize, transfers collateral tokens (this market) to the liquidator.
    ///
    /// @Param seizerPoolCertificate - Pool's certificate guarantee that this interface can only be called by other valid markets
    /// @Param seizerPool - The external pool seizing the current collateral pool (i.e. borrowPool)
    /// @Param liquidator - The address of the liquidator who will receive the collateral lpToken transfer
    /// @Param borrower - The borrower to be liquidated
    /// @Param scaledBorrowerCollateralLpTokenToSeize - The amount of collateral lpTokens that will be seized from borrower to liquidator
    ///
    /// Only used for "external" seize. Run-time type check of pool certificate ensures it can only be called by other supported markets.
    ///
    pub fun seize(
        seizerPoolCertificate: @{LendingInterfaces.IdentityCertificate},
        seizerPool: Address,
        liquidator: Address,
        borrower: Address,
        scaledBorrowerCollateralLpTokenToSeize: UInt256
    ) {
        pre {
            seizerPool != self.poolAddress:
                LendingError.ErrorEncode(
                    msg: "External seize only, seizerPool cannot be current pool",
                    err: LendingError.ErrorCode.EXTERNAL_SEIZE_FROM_SELF
                )
        }
        // 1. Check and verify caller from another LendingPool contract
        let err = self.comptrollerCap!.borrow()!.callerAllowed(
            callerCertificate: <- seizerPoolCertificate,
            callerAddress: seizerPool
        )
        assert(err == nil, message: err ?? "")

        // 2. Accrues interests and checkpoints latest states
        self.accrueInterest()

        // 3. seizeInternal
        self.seizeInternal(
            liquidator: liquidator,
            borrower: borrower,
            scaledBorrowerLpTokenToSeize: scaledBorrowerCollateralLpTokenToSeize
        )
    }

    /// Internal seize
    ///
    /// @Param liquidator - The address of the liquidator who will receive the collateral lpToken transfer
    /// @Param borrower - The borrower to be liquidated
    /// @Param scaledBorrowerLpTokenToSeize - The amount of collateral lpTokens that will be seized from borrower to liquidator
    ///
    /// Caller ensures accrueInterest() has been called
    ///
    access(self) fun seizeInternal(
        liquidator: Address,
        borrower: Address,
        scaledBorrowerLpTokenToSeize: UInt256
    ) {
        pre {
            liquidator != borrower:
                LendingError.ErrorEncode(
                    msg: "seize: liquidator == borrower",
                    err: LendingError.ErrorCode.SAME_LIQUIDATOR_AND_BORROWER
                )
        }

        let err = self.comptrollerCap!.borrow()!.seizeAllowed(
            poolCertificate: <- create PoolCertificate(),
            borrowPool: self.poolAddress,
            collateralPool: self.poolAddress,
            liquidator: liquidator,
            borrower: borrower,
            seizeCollateralPoolLpTokenAmountScaled: scaledBorrowerLpTokenToSeize
        )
        assert(err == nil, message: err ?? "")

        let scaleFactor = LendingConfig.scaleFactor
        let scaledProtocolSeizedLpTokens = scaledBorrowerLpTokenToSeize * self.scaledPoolSeizeShare / scaleFactor
        let scaledLiquidatorSeizedLpTokens = scaledBorrowerLpTokenToSeize - scaledProtocolSeizedLpTokens
        let scaledUnderlyingToLpTokenRate = self.underlyingToLpTokenRateSnapshotScaled()
        let scaledAddedUnderlyingReserves = scaledUnderlyingToLpTokenRate * scaledProtocolSeizedLpTokens / scaleFactor
        self.scaledTotalReserves = self.scaledTotalReserves + scaledAddedUnderlyingReserves
        self.scaledTotalSupply = self.scaledTotalSupply - scaledProtocolSeizedLpTokens
        // in-place liquidation: only virtual lpToken records get updated, no token deposit / withdraw needs to happen
        if (self.accountLpTokens[borrower] == scaledBorrowerLpTokenToSeize) {
            self.accountLpTokens.remove(key: borrower)
        } else {
            self.accountLpTokens[borrower] = self.accountLpTokens[borrower]! - scaledBorrowerLpTokenToSeize
        }
        self.accountLpTokens[liquidator] = scaledLiquidatorSeizedLpTokens + (self.accountLpTokens[liquidator] ?? 0)

        emit ReservesAdded(donator: self.poolAddress, scaledAddedUnderlyingAmount: scaledAddedUnderlyingReserves, scaledNewTotalReserves: self.scaledTotalReserves)
    }

    /// An executor contract can request to use the whole liquidity of current LendingPool and perform custom operations (like arbitrage, liquidation, et al.), as long as:
    ///   1. executor implements FlashLoanExecutor resource interface and sets up corresponding resource to receive & process requested tokens, and
    ///   2. executor repays back requested amount + fees (dominated by 'flashloanRateBps x amount'), and
    /// all in one atomic function call.
    /// @params: User-definited extra data passed to executor for further auth/check/decode
    ///
    pub fun flashloan(executorCap: Capability<&{LendingInterfaces.FlashLoanExecutor}>, requestedAmount: UFix64, params: {String: AnyStruct}) {
        pre {
            self.isFlashloanOpen(): LendingError.ErrorEncode(
                    msg: "LendingError: flashloan is not open",
                    err: LendingError.ErrorCode.MARKET_NOT_OPEN
                )
            requestedAmount > 0.0 && requestedAmount < self.underlyingVault.balance: LendingError.ErrorEncode(
                    msg: "LendingError: flashloan invalid requested amount",
                    err: LendingError.ErrorCode.INSUFFICIENT_POOL_LIQUIDITY
                )
            executorCap.check(): LendingError.ErrorEncode(
                    msg: "LendingError: flashloan executor resource not properly setup",
                    err: LendingError.ErrorCode.FLASHLOAN_EXECUTOR_SETUP
                )
        }
        // Accrues interests and checkpoints latest states
        self.accrueInterest()

        let requestedAmountScaled = LendingConfig.UFix64ToScaledUInt256(requestedAmount)
        let tokenOut <-self.underlyingVault.withdraw(amount: requestedAmount)
        self.scaledTotalBorrows = self.scaledTotalBorrows + requestedAmountScaled

        let tokenIn <- executorCap.borrow()!.executeAndRepay(loanedToken: <- tokenOut, params: params)
        assert(tokenIn.isInstance(self.underlyingAssetType), message:
            LendingError.ErrorEncode(
                msg: "LendingError: flashloan repaid incompatible token",
                err: LendingError.ErrorCode.INVALID_PARAMETERS
            )
        )
        assert(tokenIn.balance >= requestedAmount * (1.0 + UFix64(self.getFlashloanRateBps()) / 10000.0), message:
            LendingError.ErrorEncode(
                msg: "LendingError: flashloan insufficient repayment",
                err: LendingError.ErrorCode.INVALID_PARAMETERS
            )
        )

        self.underlyingVault.deposit(from: <- tokenIn)
        self.scaledTotalBorrows = self.scaledTotalBorrows - requestedAmountScaled

        emit Flashloan(executor: executorCap.borrow()!.owner!.address, executorType: executorCap.borrow()!.getType(), originator: self.account.address, amount: requestedAmount)
    }

    /// Check whether or not the given certificate is issued by system
    ///
    access(self) fun checkUserCertificateType(certCap: Capability<&{LendingInterfaces.IdentityCertificate}>): Bool {
        return certCap.borrow()!.isInstance(self.comptrollerCap!.borrow()!.getUserCertificateType())
    }

    pub fun getFlashloanRateBps(): UInt64 {
        return (self._reservedFields["flashloanRateBps"] as! UInt64?) ?? 5
    }

    pub fun isFlashloanOpen(): Bool {
        return (self._reservedFields["isFlashloanOpen"] as! Bool?) ?? false
    }

    /// PoolCertificate
    ///
    /// Inherited from IdentityCertificate.
    /// Proof of identity for the pool.
    ///
    pub resource PoolCertificate: LendingInterfaces.IdentityCertificate {}

    /// PoolPublic
    ///
    /// The external interfaces of the pool, and will be exposed as a public capability.
    ///
    pub resource PoolPublic: LendingInterfaces.PoolPublic {

        pub fun getPoolAddress(): Address {
            return LendingPool.poolAddress
        }

        pub fun getUnderlyingTypeString(): String {
            let underlyingType = LendingPool.getUnderlyingAssetType()
            // "A.1654653399040a61.FlowToken.Vault" => "FlowToken"
            return underlyingType.slice(from: 19, upTo: underlyingType.length - 6)
        }

        pub fun getUnderlyingAssetType(): String {
            return LendingPool.getUnderlyingAssetType()
        }

        pub fun getUnderlyingToLpTokenRateScaled(): UInt256 {
            return LendingPool.underlyingToLpTokenRateSnapshotScaled()
        }

        pub fun getAccountLpTokenBalanceScaled(account: Address): UInt256 {
            return LendingPool.accountLpTokens[account] ?? 0
        }

        pub fun getAccountBorrowBalanceScaled(account: Address): UInt256 {
            return LendingPool.borrowBalanceSnapshotScaled(borrowerAddress: account)
        }

        pub fun getAccountBorrowPrincipalSnapshotScaled(account: Address): UInt256 {
            if (LendingPool.accountBorrows.containsKey(account) == false) {
                return 0
            } else {
                return LendingPool.accountBorrows[account]!.scaledPrincipal
            }
        }

        pub fun getAccountBorrowIndexSnapshotScaled(account: Address): UInt256 {
            if (LendingPool.accountBorrows.containsKey(account) == false) {
                return 0
            } else {
                return LendingPool.accountBorrows[account]!.scaledInterestIndex
            }
        }

        pub fun getAccountSnapshotScaled(account: Address): [UInt256; 5] {
            return [
                self.getUnderlyingToLpTokenRateScaled(),
                self.getAccountLpTokenBalanceScaled(account: account),
                self.getAccountBorrowBalanceScaled(account: account),
                self.getAccountBorrowPrincipalSnapshotScaled(account: account),
                self.getAccountBorrowIndexSnapshotScaled(account: account)
            ]
        }

        pub fun getAccountRealtimeScaled(account: Address): [UInt256; 5] {
            let accrueInterestRealtimeRes = self.accrueInterestReadonly()
            let poolBorrowIndexRealtime = accrueInterestRealtimeRes[1]
            let poolTotalBorrowRealtime = accrueInterestRealtimeRes[2]
            let poolTotalReserveRealtime = accrueInterestRealtimeRes[3]

            let underlyingTolpTokenRateRealtime = (LendingPool.getPoolCash() + poolTotalBorrowRealtime - poolTotalReserveRealtime) * LendingConfig.scaleFactor / LendingPool.scaledTotalSupply

            var borrowBalanceRealtimeScaled:UInt256 = 0
            if (LendingPool.accountBorrows.containsKey(account)) {
                borrowBalanceRealtimeScaled = self.getAccountBorrowPrincipalSnapshotScaled(account: account) * poolBorrowIndexRealtime / self.getAccountBorrowIndexSnapshotScaled(account: account)
            }

            return [
                underlyingTolpTokenRateRealtime,
                self.getAccountLpTokenBalanceScaled(account: account),
                borrowBalanceRealtimeScaled,
                self.getAccountBorrowPrincipalSnapshotScaled(account: account),
                self.getAccountBorrowIndexSnapshotScaled(account: account)
            ]
        }

        pub fun getPoolReserveFactorScaled(): UInt256 {
            return LendingPool.scaledReserveFactor
        }

        pub fun getInterestRateModelAddress(): Address {
            return LendingPool.interestRateModelAddress!
        }

        pub fun getPoolTotalBorrowsScaled(): UInt256 {
            return LendingPool.scaledTotalBorrows
        }

        pub fun getPoolAccrualBlockNumber(): UInt256 {
            return LendingPool.accrualBlockNumber
        }

        pub fun getPoolBorrowIndexScaled(): UInt256 {
            return LendingPool.scaledBorrowIndex
        }

        pub fun getPoolTotalLpTokenSupplyScaled(): UInt256 {
            return LendingPool.scaledTotalSupply
        }

        pub fun getPoolTotalSupplyScaled(): UInt256 {
            return LendingPool.getPoolCash() + LendingPool.scaledTotalBorrows
        }

        pub fun getPoolTotalReservesScaled(): UInt256 {
            return LendingPool.scaledTotalReserves
        }

        pub fun getPoolCash(): UInt256 {
            return LendingPool.getPoolCash()
        }

        pub fun getPoolSupplierCount(): UInt256 {
            return UInt256(LendingPool.accountLpTokens.length)
        }

        pub fun getPoolBorrowerCount(): UInt256 {
            return UInt256(LendingPool.accountBorrows.length)
        }

        pub fun getPoolSupplierList(): [Address] {
            return LendingPool.accountLpTokens.keys
        }

        pub fun getPoolSupplierSlicedList(from: UInt64, to: UInt64): [Address] {
            pre {
                from <= to && to < UInt64(LendingPool.accountLpTokens.length):
                    LendingError.ErrorEncode(
                        msg: "Index out of range",
                        err: LendingError.ErrorCode.INVALID_PARAMETERS
                    )
            }
            let borrowers: &[Address] = &LendingPool.accountLpTokens.keys as &[Address]
            let list: [Address] = []
            var i = from
            while i <= to {
                list.append(borrowers[i])
                i = i + 1
            }
            return list
        }

        pub fun getPoolBorrowerList(): [Address] {
            return LendingPool.accountBorrows.keys
        }

        pub fun getPoolBorrowerSlicedList(from: UInt64, to: UInt64): [Address] {
            pre {
                from <= to && to < UInt64(LendingPool.accountBorrows.length):
                    LendingError.ErrorEncode(
                        msg: "Index out of range",
                        err: LendingError.ErrorCode.INVALID_PARAMETERS
                    )
            }
            let borrowers: &[Address] = &LendingPool.accountBorrows.keys as &[Address]
            let list: [Address] = []
            var i = from
            while i <= to {
                list.append(borrowers[i])
                i = i + 1
            }
            return list
        }

        pub fun getPoolBorrowRateScaled(): UInt256 {
            return LendingPool.interestRateModelCap!.borrow()!.getBorrowRate(
                cash: LendingPool.getPoolCash(),
                borrows: LendingPool.scaledTotalBorrows,
                reserves: LendingPool.scaledTotalReserves
            )
        }

        pub fun getPoolBorrowAprScaled(): UInt256 {
            let scaledBorrowRatePerBlock =
                LendingPool.interestRateModelCap!.borrow()!.getBorrowRate(
                    cash: LendingPool.getPoolCash(),
                    borrows: LendingPool.scaledTotalBorrows,
                    reserves: LendingPool.scaledTotalReserves
                )
            let blocksPerYear = LendingPool.interestRateModelCap!.borrow()!.getBlocksPerYear()
            return scaledBorrowRatePerBlock * blocksPerYear
        }

        pub fun getPoolSupplyAprScaled(): UInt256 {
            let scaledSupplyRatePerBlock =
                LendingPool.interestRateModelCap!.borrow()!.getSupplyRate(
                    cash: LendingPool.getPoolCash(),
                    borrows: LendingPool.scaledTotalBorrows,
                    reserves: LendingPool.scaledTotalReserves,
                    reserveFactor: LendingPool.scaledReserveFactor
                )
            let blocksPerYear = LendingPool.interestRateModelCap!.borrow()!.getBlocksPerYear()
            return scaledSupplyRatePerBlock * blocksPerYear
        }

        /// The default flashloan rate is 5 bps (0.05%)
        pub fun getFlashloanRateBps(): UInt64 {
            return LendingPool.getFlashloanRateBps()
        }

        pub fun accrueInterest() {
            LendingPool.accrueInterest()
        }

        pub fun accrueInterestReadonly(): [UInt256; 4] {
            return LendingPool.accrueInterestReadonly()
        }

        pub fun getPoolCertificateType(): Type {
            return Type<@LendingPool.PoolCertificate>()
        }

        pub fun seize(
            seizerPoolCertificate: @{LendingInterfaces.IdentityCertificate},
            seizerPool: Address,
            liquidator: Address,
            borrower: Address,
            scaledBorrowerCollateralLpTokenToSeize: UInt256
        ) {
            LendingPool.seize(
                seizerPoolCertificate: <- seizerPoolCertificate,
                seizerPool: seizerPool,
                liquidator: liquidator,
                borrower: borrower,
                scaledBorrowerCollateralLpTokenToSeize: scaledBorrowerCollateralLpTokenToSeize
            )
        }

        pub fun supply(supplierAddr: Address, inUnderlyingVault: @FungibleToken.Vault) {
            LendingPool.supply(supplierAddr: supplierAddr, inUnderlyingVault: <-inUnderlyingVault)
        }

        pub fun redeem(userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>, numLpTokenToRedeem: UFix64): @FungibleToken.Vault {
            return <-LendingPool.redeem(userCertificateCap: userCertificateCap, numLpTokenToRedeem: numLpTokenToRedeem)
        }

        pub fun redeemUnderlying(userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>, numUnderlyingToRedeem: UFix64): @FungibleToken.Vault {
            return <-LendingPool.redeemUnderlying(userCertificateCap: userCertificateCap, numUnderlyingToRedeem: numUnderlyingToRedeem)
        }

        pub fun borrow(userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>, borrowAmount: UFix64): @FungibleToken.Vault {
            return <-LendingPool.borrow(userCertificateCap: userCertificateCap, borrowAmount: borrowAmount)
        }

        pub fun repayBorrow(borrower: Address, repayUnderlyingVault: @FungibleToken.Vault): @FungibleToken.Vault? {
            return <-LendingPool.repayBorrow(borrower: borrower, repayUnderlyingVault: <-repayUnderlyingVault)
        }

        pub fun liquidate(liquidator: Address, borrower: Address, poolCollateralizedToSeize: Address, repayUnderlyingVault: @FungibleToken.Vault): @FungibleToken.Vault? {
            return <-LendingPool.liquidate(liquidator: liquidator, borrower: borrower, poolCollateralizedToSeize: poolCollateralizedToSeize, repayUnderlyingVault: <-repayUnderlyingVault)
        }

        pub fun flashloan(executorCap: Capability<&{LendingInterfaces.FlashLoanExecutor}>, requestedAmount: UFix64, params: {String: AnyStruct}) {
            LendingPool.flashloan(executorCap: executorCap, requestedAmount: requestedAmount, params: params)
        }
    }

    /// PoolAdmin
    ///
    pub resource PoolAdmin: LendingInterfaces.PoolAdminPublic {
        /// Admin function to call accrueInterest() to checkpoint latest states, and then update the interest rate model
        pub fun setInterestRateModel(newInterestRateModelAddress: Address) {
            post {
                LendingPool.interestRateModelCap != nil && LendingPool.interestRateModelCap!.check() == true:
                    LendingError.ErrorEncode(
                        msg: "Invalid contract address of the new interest rate",
                        err: LendingError.ErrorCode.CANNOT_ACCESS_INTEREST_RATE_MODEL_CAPABILITY
                    )
            }
            LendingPool.accrueInterest()

            if (newInterestRateModelAddress != LendingPool.interestRateModelAddress) {
                let oldInterestRateModelAddress = LendingPool.interestRateModelAddress
                LendingPool.interestRateModelAddress = newInterestRateModelAddress
                LendingPool.interestRateModelCap = getAccount(newInterestRateModelAddress)
                    .getCapability<&{LendingInterfaces.InterestRateModelPublic}>(LendingConfig.InterestRateModelPublicPath)
                emit NewInterestRateModel(oldInterestRateModelAddress, newInterestRateModelAddress)
            }
            return
        }

        /// Admin function to call accrueInterest() to checkpoint latest states, and then update reserveFactor
        pub fun setReserveFactor(newReserveFactor: UFix64) {
            pre {
                newReserveFactor <= 1.0:
                LendingError.ErrorEncode(
                    msg: "Reserve factor out of range 1.0",
                    err: LendingError.ErrorCode.INVALID_PARAMETERS
                )
            }
            LendingPool.accrueInterest()

            let oldReserveFactor = LendingConfig.ScaledUInt256ToUFix64(LendingPool.scaledReserveFactor)
            LendingPool.scaledReserveFactor = LendingConfig.UFix64ToScaledUInt256(newReserveFactor)

            emit NewReserveFactor(oldReserveFactor, newReserveFactor)
            return
        }

        /// Admin function to update poolSeizeShare
        pub fun setPoolSeizeShare(newPoolSeizeShare: UFix64) {
            pre {
                newPoolSeizeShare <= 1.0:
                LendingError.ErrorEncode(
                    msg: "Pool seize share factor out of range 1.0",
                    err: LendingError.ErrorCode.INVALID_PARAMETERS
                )
            }
            let oldPoolSeizeShare = LendingConfig.ScaledUInt256ToUFix64(LendingPool.scaledPoolSeizeShare)
            LendingPool.scaledPoolSeizeShare = LendingConfig.UFix64ToScaledUInt256(newPoolSeizeShare)

            emit NewPoolSeizeShare(oldPoolSeizeShare, newPoolSeizeShare)
            return
        }

        /// Admin function to set comptroller
        pub fun setComptroller(newComptrollerAddress: Address) {
            post {
                LendingPool.comptrollerCap != nil && LendingPool.comptrollerCap!.check() == true:
                    LendingError.ErrorEncode(
                        msg: "Cannot borrow reference to ComptrollerPublic resource",
                        err: LendingError.ErrorCode.CANNOT_ACCESS_COMPTROLLER_PUBLIC_CAPABILITY
                    )
            }

            if (newComptrollerAddress != LendingPool.comptrollerAddress) {
                let oldComptrollerAddress = LendingPool.comptrollerAddress
                LendingPool.comptrollerAddress = newComptrollerAddress
                LendingPool.comptrollerCap = getAccount(newComptrollerAddress)
                    .getCapability<&{LendingInterfaces.ComptrollerPublic}>(LendingConfig.ComptrollerPublicPath)
                emit NewComptroller(oldComptrollerAddress, newComptrollerAddress)
            }
        }

        /// Admin function to initialize pool.
        /// Note: can be called only once
        pub fun initializePool(
            reserveFactor: UFix64,
            poolSeizeShare: UFix64,
            interestRateModelAddress: Address
        ) {
            pre {
                LendingPool.accrualBlockNumber == 0 && LendingPool.scaledBorrowIndex == 0:
                    LendingError.ErrorEncode(
                        msg: "Pool can only be initialized once",
                        err: LendingError.ErrorCode.POOL_INITIALIZED
                    )
                reserveFactor <= 1.0 && poolSeizeShare <= 1.0:
                    LendingError.ErrorEncode(
                        msg: "ReserveFactor | poolSeizeShare out of range 1.0",
                        err: LendingError.ErrorCode.INVALID_PARAMETERS
                    )
            }
            post {
                LendingPool.interestRateModelCap != nil && LendingPool.interestRateModelCap!.check() == true:
                    LendingError.ErrorEncode(
                        msg: "InterestRateModel not properly initialized",
                        err: LendingError.ErrorCode.CANNOT_ACCESS_INTEREST_RATE_MODEL_CAPABILITY
                    )
            }
            LendingPool.accrualBlockNumber = UInt256(getCurrentBlock().height)
            LendingPool.scaledBorrowIndex = LendingConfig.scaleFactor
            LendingPool.scaledReserveFactor = LendingConfig.UFix64ToScaledUInt256(reserveFactor)
            LendingPool.scaledPoolSeizeShare = LendingConfig.UFix64ToScaledUInt256(poolSeizeShare)
            LendingPool.interestRateModelAddress = interestRateModelAddress
            LendingPool.interestRateModelCap = getAccount(interestRateModelAddress)
                .getCapability<&{LendingInterfaces.InterestRateModelPublic}>(LendingConfig.InterestRateModelPublicPath)
        }

        /// Admin function to withdraw pool reserve
        pub fun withdrawReserves(reduceAmount: UFix64): @FungibleToken.Vault {
            LendingPool.accrueInterest()

            let reduceAmountScaled = reduceAmount == UFix64.max ? LendingPool.scaledTotalReserves : LendingConfig.UFix64ToScaledUInt256(reduceAmount)
            assert(reduceAmountScaled <= LendingPool.scaledTotalReserves, message:
                LendingError.ErrorEncode(
                    msg: "exceeded pool total reserve",
                    err: LendingError.ErrorCode.EXCEED_TOTAL_RESERVES
                )
            )
            assert(reduceAmountScaled <= LendingPool.getPoolCash(), message:
                LendingError.ErrorEncode(
                    msg: "insufficient pool liquidity to withdraw reserve",
                    err: LendingError.ErrorCode.INSUFFICIENT_POOL_LIQUIDITY
                )
            )
            LendingPool.scaledTotalReserves = LendingPool.scaledTotalReserves - reduceAmountScaled

            emit ReservesReduced(scaledReduceAmount: reduceAmountScaled, scaledNewTotalReserves: LendingPool.scaledTotalReserves)

            return <- LendingPool.underlyingVault.withdraw(amount: LendingConfig.ScaledUInt256ToUFix64(reduceAmountScaled))
        }

        pub fun setFlashloanRateBps(rateBps: UInt64) {
            pre {
                rateBps >= 0 && rateBps <= 10000:
                    LendingError.ErrorEncode(
                        msg: "LendingPool: flashloan rateBps should be in [0, 10000]",
                        err: LendingError.ErrorCode.INVALID_PARAMETERS
                    )
            }
            emit FlashloanRateChanged(oldRateBps: LendingPool.getFlashloanRateBps(), newRateBps: rateBps)
            LendingPool._reservedFields["flashloanRateBps"] = rateBps
        }

        pub fun setFlashloanOpen(isOpen: Bool) {
            emit FlashloanOpen(isOpen: isOpen)
            LendingPool._reservedFields["isFlashloanOpen"] = isOpen
        }
    }

    init() {
        self.PoolAdminStoragePath = /storage/incrementLendingPoolAdmin
        self.UnderlyingAssetVaultStoragePath = /storage/poolUnderlyingAssetVault
        self.PoolPublicStoragePath = /storage/incrementLendingPoolPublic
        self.PoolPublicPublicPath = /public/incrementLendingPoolPublic

        self.poolAddress = self.account.address
        self.scaledInitialExchangeRate = LendingConfig.scaleFactor
        self.accrualBlockNumber = 0
        self.scaledBorrowIndex = 0
        self.scaledTotalBorrows = 0
        self.scaledTotalReserves = 0
        self.scaledReserveFactor = 0
        self.scaledPoolSeizeShare = 0
        self.scaledTotalSupply = 0
        self.accountLpTokens = {}
        self.accountBorrows = {}
        self.interestRateModelAddress = nil
        self.interestRateModelCap = nil
        self.comptrollerAddress = nil
        self.comptrollerCap = nil
        self._reservedFields = {}
        self.underlyingVault <- self.account.load<@FungibleToken.Vault>(from: self.UnderlyingAssetVaultStoragePath)
            ?? panic("Deployer should own zero-balanced underlying asset vault first")
        self.underlyingAssetType = self.underlyingVault.getType()
        assert(self.underlyingVault.balance == 0.0, message: "Must initialize pool with zero-balanced underlying asset vault")

        // save pool admin
        destroy <-self.account.load<@AnyResource>(from: self.PoolAdminStoragePath)
        self.account.save(<-create PoolAdmin(), to: self.PoolAdminStoragePath)
        // save pool public interface
        self.account.unlink(self.PoolPublicPublicPath)
        destroy <-self.account.load<@AnyResource>(from: self.PoolPublicStoragePath)
        self.account.save(<-create PoolPublic(), to: self.PoolPublicStoragePath)
        self.account.unlink(self.PoolPublicPublicPath)
        self.account.link<&{LendingInterfaces.PoolPublic}>(LendingConfig.PoolPublicPublicPath, target: self.PoolPublicStoragePath)
    }
}
"
-------
"/**

# The contract implementation of the lending pool.

# Author: Increment Labs

Core functionalities of the lending pool smart contract supporting cross-market supply, redeem, borrow, repay, and liquidation.
Multiple LendingPool contracts will be deployed for each of the different pooled underlying FungibleTokens.

*/
import FungibleToken from 0xf233dcee88fe0abe
import LendingInterfaces from 0x2df970b6cdee5735
import LendingConfig from 0x2df970b6cdee5735
import LendingError from 0x2df970b6cdee5735

pub contract LendingPool {
    /// Account address the pool is deployed to, i.e. the pool 'contract address'
    pub let poolAddress: Address
    /// Initial exchange rate (when LendingPool.totalSupply == 0) between the virtual lpToken and pool underlying token
    pub let scaledInitialExchangeRate: UInt256
    /// Block number that interest was last accrued at
    pub var accrualBlockNumber: UInt256
    /// Accumulator of the total earned interest rate since the opening of the market, scaled up by 1e18
    pub var scaledBorrowIndex: UInt256
    /// Total amount of outstanding borrows of the underlying in this market, scaled up by 1e18
    pub var scaledTotalBorrows: UInt256
    /// Total amount of reserves of the underlying held in this market, scaled up by 1e18
    pub var scaledTotalReserves: UInt256
    /// Total number of virtual lpTokens, scaled up by 1e18
    pub var scaledTotalSupply: UInt256
    /// Fraction of generated interest added to protocol reserves, scaled up by 1e18
    /// Must be in [0.0, 1.0] x scaleFactor
    pub var scaledReserveFactor: UInt256
    /// Share of seized collateral that is added to reserves when liquidation happenes, e.g. 0.028 x 1e18.
    /// Must be in [0.0, 1.0] x scaleFactor
    pub var scaledPoolSeizeShare: UInt256
    /// { supplierAddress => # of virtual lpToken the supplier owns, scaled up by 1e18 }
    access(self) let accountLpTokens: {Address: UInt256}
    /// Reserved parameter fields: {ParamName: Value}
    /// Used fields:
    ///   |__ 1. "flashloanRateBps" -> UInt64
    ///   |__ 2. "isFlashloanOpen" -> Bool
    access(self) let _reservedFields: {String: AnyStruct}

    /// BorrowSnapshot
    ///
    /// Container for borrow balance information
    ///
    pub struct BorrowSnapshot {
        /// Total balance (with accrued interest), after applying the most recent balance-change action
        pub var scaledPrincipal: UInt256
        /// Global borrowIndex as of the most recent balance-change action
        pub var scaledInterestIndex: UInt256

        init(principal: UInt256, interestIndex: UInt256) {
            self.scaledPrincipal = principal
            self.scaledInterestIndex = interestIndex
        }
    }

    // { borrowerAddress => BorrowSnapshot }
    access(self) let accountBorrows: {Address: BorrowSnapshot}

    /// Model used to calculate underlying asset's borrow interest rate
    pub var interestRateModelAddress: Address?
    pub var interestRateModelCap: Capability<&{LendingInterfaces.InterestRateModelPublic}>?

    /// The address of the comptroller contract
    pub var comptrollerAddress: Address?
    pub var comptrollerCap: Capability<&{LendingInterfaces.ComptrollerPublic}>?

    /// Save underlying asset deposited into this pool
    access(self) let underlyingVault: @FungibleToken.Vault
    /// Underlying type
    access(self) let underlyingAssetType: Type

    /// Path
    pub let PoolAdminStoragePath: StoragePath
    pub let UnderlyingAssetVaultStoragePath: StoragePath
    pub let PoolPublicStoragePath: StoragePath
    pub let PoolPublicPublicPath: PublicPath

    /// Event emitted when interest is accrued
    pub event AccrueInterest(_ scaledCashPrior: UInt256, _ scaledInterestAccumulated: UInt256, _ scaledBorrowIndexNew: UInt256, _ scaledTotalBorrowsNew: UInt256)
    /// Event emitted when underlying asset is deposited into pool
    pub event Supply(supplier: Address, scaledSuppliedUnderlyingAmount: UInt256, scaledMintedLpTokenAmount: UInt256)
    /// Event emitted when virtual lpToken is burnt and redeemed for underlying asset
    pub event Redeem(redeemer: Address, scaledLpTokenToRedeem: UInt256, scaledRedeemedUnderlyingAmount: UInt256)
    /// Event emitted when user borrows underlying from the pool
    pub event Borrow(borrower: Address, scaledBorrowAmount: UInt256, scaledBorrowerTotalBorrows: UInt256, scaledPoolTotalBorrows: UInt256)
    /// Event emitted when user repays underlying to pool
    pub event Repay(borrower: Address, scaledActualRepayAmount: UInt256, scaledBorrowerTotalBorrows: UInt256, scaledPoolTotalBorrows: UInt256)
    /// Event emitted when pool reserves get added
    pub event ReservesAdded(donator: Address, scaledAddedUnderlyingAmount: UInt256, scaledNewTotalReserves: UInt256)
    /// Event emitted when pool reserves is reduced
    pub event ReservesReduced(scaledReduceAmount: UInt256, scaledNewTotalReserves: UInt256)
    /// Event emitted when liquidation happenes
    pub event Liquidate(liquidator: Address, borrower: Address, scaledActualRepaidUnderlying: UInt256, collateralPoolToSeize: Address, scaledCollateralPoolLpTokenSeized: UInt256)
    /// Event emitted when interestRateModel is changed
    pub event NewInterestRateModel(_ oldInterestRateModelAddress: Address?, _ newInterestRateModelAddress: Address)
    /// Event emitted when the reserveFactor is changed
    pub event NewReserveFactor(_ oldReserveFactor: UFix64, _ newReserveFactor: UFix64)
    /// Event emitted when the poolSeizeShare is changed
    pub event NewPoolSeizeShare(_ oldPoolSeizeShare: UFix64, _ newPoolSeizeShare: UFix64)
    /// Event emitted when the comptroller is changed
    pub event NewComptroller(_ oldComptrollerAddress: Address?, _ newComptrollerAddress: Address)
    /// Event emitted when the flashloanRateChanged is changed
    pub event FlashloanRateChanged(oldRateBps: UInt64, newRateBps: UInt64)
    /// Event emitted when the isFlashloanOpen is changed
    pub event FlashloanOpen(isOpen: Bool)
    /// Event emitted when the flashloan is executed
    pub event Flashloan(executor: Address, executorType: Type, originator: Address, amount: UFix64)

    // Return underlying asset's type of current pool
    pub fun getUnderlyingAssetType(): String {
        return self.underlyingAssetType.identifier
    }

    // Gets current underlying balance of this pool, scaled up by 1e18
    pub fun getPoolCash(): UInt256 {
        return LendingConfig.UFix64ToScaledUInt256(self.underlyingVault.balance)
    }

    /// Cal accrue interest
    ///
    /// @Return 0. currentBlockNumber - The block number of current calculation of interest
    ///         1. scaledBorrowIndexNew - The new accumulator of the total earned interest rate since the opening of the market
    ///         2. scaledTotalBorrowsNew - The new total borrows after accrue interest
    ///         3. scaledTotalReservesNew - The new total reserves after accrue interest
    ///
    /// Calculates interest accrued from the last checkpointed block to the current block
    /// This function is a readonly function and can be called by scripts.
    ///
    pub fun accrueInterestReadonly(): [UInt256; 4] {
        pre {
            self.interestRateModelCap != nil && self.interestRateModelCap!.check() == true:
                LendingError.ErrorEncode(
                    msg: "Cannot borrow reference to InterestRateModel in pool ".concat(LendingPool.poolAddress.toString()),
                    err: LendingError.ErrorCode.CANNOT_ACCESS_INTEREST_RATE_MODEL_CAPABILITY
                )
        }
        let currentBlockNumber = UInt256(getCurrentBlock().height)
        let accrualBlockNumberPrior = self.accrualBlockNumber

        let scaledCashPrior = self.getPoolCash()
        let scaledBorrowPrior = self.scaledTotalBorrows
        let scaledReservesPrior = self.scaledTotalReserves
        let scaledBorrowIndexPrior = self.scaledBorrowIndex

        // Get scaled borrow interest rate per block
        let scaledBorrowRatePerBlock =
            self.interestRateModelCap!.borrow()!.getBorrowRate(cash: scaledCashPrior, borrows: scaledBorrowPrior, reserves: scaledReservesPrior)
        let blockDelta = currentBlockNumber - accrualBlockNumberPrior
        let scaledInterestFactor = scaledBorrowRatePerBlock * blockDelta
        let scaleFactor = LendingConfig.scaleFactor
        let scaledInterestAccumulated = scaledInterestFactor * scaledBorrowPrior / scaleFactor
        let scaledTotalBorrowsNew = scaledInterestAccumulated + scaledBorrowPrior
        let scaledTotalReservesNew = self.scaledReserveFactor * scaledInterestAccumulated / scaleFactor + scaledReservesPrior
        let scaledBorrowIndexNew = scaledInterestFactor * scaledBorrowIndexPrior / scaleFactor + scaledBorrowIndexPrior

        return [
            currentBlockNumber,
            scaledBorrowIndexNew,
            scaledTotalBorrowsNew,
            scaledTotalReservesNew
        ]
    }

    /// Accrue Interest
    ///
    /// Applies accrued interest to total borrows and reserves.
    ///
    pub fun accrueInterest() {
        // Return early if accrue 0 interest
        if (UInt256(getCurrentBlock().height) == self.accrualBlockNumber) {
            return
        }
        let scaledCashPrior = self.getPoolCash()
        let scaledBorrowPrior = self.scaledTotalBorrows

        let res = self.accrueInterestReadonly()

        // Write calculated values into contract storage
        self.accrualBlockNumber = res[0]
        self.scaledBorrowIndex = res[1]
        self.scaledTotalBorrows = res[2]
        self.scaledTotalReserves = res[3]

        emit AccrueInterest(scaledCashPrior, res[2]-scaledBorrowPrior, self.scaledBorrowIndex, self.scaledTotalBorrows)
    }

    /// Calculates the exchange rate from the underlying to virtual lpToken (i.e. how many UnderlyingToken per virtual lpToken)
    /// Note: It doesn't call accrueInterest() first to update with latest states which is used in calculating the exchange rate.
    ///
    pub fun underlyingToLpTokenRateSnapshotScaled(): UInt256 {
        if (self.scaledTotalSupply == 0) {
            return self.scaledInitialExchangeRate
        } else {
            return (self.getPoolCash() + self.scaledTotalBorrows - self.scaledTotalReserves) * LendingConfig.scaleFactor / self.scaledTotalSupply
        }
    }

    /// Calculates the scaled borrow balance of borrower address based on stored states
    /// Note: It doesn't call accrueInterest() first to update with latest states which is used in calculating the borrow balance.
    ///
    pub fun borrowBalanceSnapshotScaled(borrowerAddress: Address): UInt256 {
        if (self.accountBorrows.containsKey(borrowerAddress) == false) {
            return 0
        }
        let borrower = self.accountBorrows[borrowerAddress]!
        return borrower.scaledPrincipal * self.scaledBorrowIndex / borrower.scaledInterestIndex
    }

    /// Supplier deposits underlying asset's Vault into the pool.
    ///
    /// @Param SupplierAddr - The address of the account which is supplying the assets
    /// @Param InUnderlyingVault - The vault for deposit and its type should match the pool's underlying token type
    ///
    /// Interest will be accrued up to the current block.
    /// The lending pool will mint the corresponding lptoken according to the current
    /// exchange rate of lptoken as the user's deposit certificate and save it in the contract.
    ///
    pub fun supply(supplierAddr: Address, inUnderlyingVault: @FungibleToken.Vault) {
        pre {
            inUnderlyingVault.balance > 0.0:
                LendingError.ErrorEncode(msg: "Supplied zero", err: LendingError.ErrorCode.EMPTY_FUNGIBLE_TOKEN_VAULT)
            inUnderlyingVault.isInstance(self.underlyingAssetType):
                LendingError.ErrorEncode(
                    msg: "Supplied vault and pool underlying type mismatch",
                    err: LendingError.ErrorCode.MISMATCHED_INPUT_VAULT_TYPE_WITH_POOL
                )
        }

        // 1. Accrues interests and checkpoints latest states
        self.accrueInterest()

        // 2. Check whether or not supplyAllowed()
        let scaledAmount = LendingConfig.UFix64ToScaledUInt256(inUnderlyingVault.balance)
        let err = self.comptrollerCap!.borrow()!.supplyAllowed(
            poolCertificate: <- create PoolCertificate(),
            poolAddress: self.poolAddress,
            supplierAddress: supplierAddr,
            supplyUnderlyingAmountScaled: scaledAmount
        )
        assert(err == nil, message: err ?? "")

        // 3. Deposit into underlying vault and mint corresponding PoolTokens
        let underlyingToken2LpTokenRateScaled = self.underlyingToLpTokenRateSnapshotScaled()
        let scaledMintVirtualAmount = scaledAmount * LendingConfig.scaleFactor / underlyingToken2LpTokenRateScaled
        // mint pool tokens for supply certificate
        self.accountLpTokens[supplierAddr] = scaledMintVirtualAmount + (self.accountLpTokens[supplierAddr] ?? 0)
        self.scaledTotalSupply = self.scaledTotalSupply + scaledMintVirtualAmount
        self.underlyingVault.deposit(from: <-inUnderlyingVault)

        emit Supply(supplier: supplierAddr, scaledSuppliedUnderlyingAmount: scaledAmount, scaledMintedLpTokenAmount: scaledMintVirtualAmount)
    }

    /// Redeems lpTokens for the underlying asset's vault
    /// or
    /// Redeems lpTokens for a specified amount of underlying asset
    ///
    /// @Param redeemer - The address of the account which is redeeming the tokens
    /// @Param numLpTokenToRedeem - The number of lpTokens to redeem into underlying (only one of numLpTokenToRedeem or numUnderlyingToRedeem may be non-zero)
    /// @Param numUnderlyingToRedeem - The amount of underlying to receive from redeeming lpTokens
    /// @Return The redeemed vault resource of pool's underlying token
    ///
    /// Since redeemer decreases his overall collateral ratio across all markets, safety check happenes inside comptroller.
    ///
    access(self) fun redeemInternal(
        redeemer: Address,
        numLpTokenToRedeem: UFix64,
        numUnderlyingToRedeem: UFix64
    ): @FungibleToken.Vault {
        pre {
            numLpTokenToRedeem == 0.0 || numUnderlyingToRedeem == 0.0:
                LendingError.ErrorEncode(
                    msg: "numLpTokenToRedeem or numUnderlyingToRedeem must be 0.0.",
                    err: LendingError.ErrorCode.INVALID_PARAMETERS
                )
            self.accountLpTokens.containsKey(redeemer):
                LendingError.ErrorEncode(
                    msg: "redeemer has no supply to redeem from",
                    err: LendingError.ErrorCode.REDEEM_FAILED_NO_ENOUGH_LP_TOKEN
                )
        }

        // 1. Accrues interests and checkpoints latest states
        self.accrueInterest()

        // 2. Check whether or not redeemAllowed()
        var scaledLpTokenToRedeem: UInt256 = 0
        var scaledUnderlyingToRedeem: UInt256 = 0
        let scaledUnderlyingToLpRate = self.underlyingToLpTokenRateSnapshotScaled()
        let scaleFactor = LendingConfig.scaleFactor
        if (numLpTokenToRedeem == 0.0) {
            // redeem all
            // the special value of `UFIx64.max` indicating to redeem all virtual LP tokens the redeemer has
            if numUnderlyingToRedeem == UFix64.max {
                scaledLpTokenToRedeem = self.accountLpTokens[redeemer]!
                scaledUnderlyingToRedeem = scaledLpTokenToRedeem * scaledUnderlyingToLpRate / scaleFactor
            } else {
                scaledLpTokenToRedeem = LendingConfig.UFix64ToScaledUInt256(numUnderlyingToRedeem) * scaleFactor / scaledUnderlyingToLpRate
                scaledUnderlyingToRedeem = LendingConfig.UFix64ToScaledUInt256(numUnderlyingToRedeem)
            }
        } else {
            if numLpTokenToRedeem == UFix64.max {
                scaledLpTokenToRedeem = self.accountLpTokens[redeemer]!
            } else {
                scaledLpTokenToRedeem = LendingConfig.UFix64ToScaledUInt256(numLpTokenToRedeem)
            }
            scaledUnderlyingToRedeem = scaledLpTokenToRedeem * scaledUnderlyingToLpRate / scaleFactor
        }

        assert(scaledLpTokenToRedeem <= self.accountLpTokens[redeemer]!, message:
            LendingError.ErrorEncode(
                msg: "exceeded redeemer lp token balance",
                err: LendingError.ErrorCode.REDEEM_FAILED_NO_ENOUGH_LP_TOKEN
            )
        )

        let err = self.comptrollerCap!.borrow()!.redeemAllowed(
            poolCertificate: <- create PoolCertificate(),
            poolAddress: self.poolAddress,
            redeemerAddress: redeemer,
            redeemLpTokenAmountScaled: scaledLpTokenToRedeem,
        )
        assert(err == nil, message: err ?? "")

        // 3. Burn virtual lpTokens, withdraw from underlying vault and return it
        assert(scaledUnderlyingToRedeem <= self.getPoolCash(), message:
            LendingError.ErrorEncode(
                msg: "insufficient pool liquidity to redeem",
                err: LendingError.ErrorCode.INSUFFICIENT_POOL_LIQUIDITY
            )
        )

        self.scaledTotalSupply = self.scaledTotalSupply - scaledLpTokenToRedeem
        if (self.accountLpTokens[redeemer] == scaledLpTokenToRedeem) {
            self.accountLpTokens.remove(key: redeemer)
        } else {
            self.accountLpTokens[redeemer] = self.accountLpTokens[redeemer]! - scaledLpTokenToRedeem
        }
        emit Redeem(
            redeemer: redeemer,
            scaledLpTokenToRedeem: scaledLpTokenToRedeem,
            scaledRedeemedUnderlyingAmount: scaledUnderlyingToRedeem
        )
        let amountUnderlyingToRedeem = LendingConfig.ScaledUInt256ToUFix64(scaledUnderlyingToRedeem)
        return <- self.underlyingVault.withdraw(amount: amountUnderlyingToRedeem)
    }

    /// User redeems lpTokens for the underlying asset's vault
    ///
    /// @Param userCertificateCap - User identity certificate and it can provide a valid user address proof
    /// @Param numLpTokenToRedeem - The number of lpTokens to redeem into underlying
    /// @Return The redeemed vault resource of pool's underlying token
    ///
    /// @Notice It is more convenient to use a resource certificate on flow for authentication than signing a signature.
    ///
    /// RedeemerAddress is inferred from the private capability to the IdentityCertificate resource,
    /// which is stored in user account and can only be given by its owner.
    /// The special value of numLpTokenToRedeem `UFIx64.max` indicating to redeem all virtual LP tokens the redeemer has.
    ///
    pub fun redeem(
        userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>,
        numLpTokenToRedeem: UFix64
    ): @FungibleToken.Vault {
        pre {
            numLpTokenToRedeem > 0.0: LendingError.ErrorEncode(msg: "Redeemed zero", err: LendingError.ErrorCode.INVALID_PARAMETERS)
            userCertificateCap.check() && userCertificateCap.borrow()!.owner != nil:
                LendingError.ErrorEncode(
                    msg: "Cannot borrow reference to IdentityCertificate",
                    err: LendingError.ErrorCode.INVALID_USER_CERTIFICATE
                )
            self.checkUserCertificateType(certCap: userCertificateCap):
                LendingError.ErrorEncode(
                    msg: "Certificate not issued by system",
                    err: LendingError.ErrorCode.INVALID_USER_CERTIFICATE
                )
        }

        let redeemerAddress = userCertificateCap.borrow()!.owner!.address
        let res <- self.redeemInternal(
            redeemer: redeemerAddress,
            numLpTokenToRedeem: numLpTokenToRedeem,
            numUnderlyingToRedeem: 0.0
        )

        return <- res
    }

    /// User redeems lpTokens for a specified amount of underlying asset
    ///
    /// @Param userCertificateCap - User identity certificate and it can provide a valid user address proof
    /// @Param numUnderlyingToRedeem - The amount of underlying to receive from redeeming lpTokens
    /// @Return The redeemed vault resource of pool's underlying token
    ///
    /// @Notice It is more convenient to use a resource certificate on flow for authentication than signing a signature.
    ///
    /// RedeemerAddress is inferred from the private capability to the IdentityCertificate resource,
    /// which is stored in user account and can only be given by its owner.
    /// The special value of numUnderlyingToRedeem `UFIx64.max` indicating to redeem all the underlying liquidity.
    ///
    pub fun redeemUnderlying(
        userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>,
        numUnderlyingToRedeem: UFix64
    ): @FungibleToken.Vault {
        pre {
            numUnderlyingToRedeem > 0.0: LendingError.ErrorEncode(msg: "Redeemed zero", err: LendingError.ErrorCode.INVALID_PARAMETERS)
            userCertificateCap.check() && userCertificateCap.borrow()!.owner != nil:
                LendingError.ErrorEncode(
                    msg: "Cannot borrow reference to IdentityCertificate",
                    err: LendingError.ErrorCode.INVALID_USER_CERTIFICATE
                )
            self.checkUserCertificateType(certCap: userCertificateCap):
                LendingError.ErrorEncode(
                    msg: "Certificate not issued by system",
                    err: LendingError.ErrorCode.INVALID_USER_CERTIFICATE
                )
        }
        let redeemerAddress = userCertificateCap.borrow()!.owner!.address
        let res <- self.redeemInternal(
            redeemer: redeemerAddress,
            numLpTokenToRedeem: 0.0,
            numUnderlyingToRedeem: numUnderlyingToRedeem
        )

        return <- res
    }

    /// User borrows underlying asset from the pool.
    ///
    /// @Param userCertificateCap - User identity certificate and it can provide a valid user address proof
    /// @Param borrowAmount - The amount of the underlying asset to borrow
    /// @Return The vault of borrow asset
    ///
    /// @Notice It is more convenient to use a resource certificate on flow for authentication than signing a signature.
    ///
    /// Since borrower would decrease his overall collateral ratio across all markets, safety check happenes inside comptroller
    ///
    pub fun borrow(
        userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>,
        borrowAmount: UFix64,
    ): @FungibleToken.Vault {
        pre {
            borrowAmount > 0.0: LendingError.ErrorEncode(msg: "borrowAmount zero", err: LendingError.ErrorCode.INVALID_PARAMETERS)
            userCertificateCap.check() && userCertificateCap.borrow()!.owner != nil:
                LendingError.ErrorEncode(
                    msg: "Cannot borrow reference to IdentityCertificate",
                    err: LendingError.ErrorCode.INVALID_USER_CERTIFICATE
                )
            self.checkUserCertificateType(certCap: userCertificateCap):
                LendingError.ErrorEncode(
                    msg: "Certificate not issued by system",
                    err: LendingError.ErrorCode.INVALID_USER_CERTIFICATE
                )
        }
        // 1. Accrues interests and checkpoints latest states
        self.accrueInterest()

        // 2. Pool liquidity check
        let scaledBorrowAmount = LendingConfig.UFix64ToScaledUInt256(borrowAmount)
        assert(scaledBorrowAmount <= self.getPoolCash(), message:
            LendingError.ErrorEncode(
                msg: "insufficient pool liquidity to borrow",
                err: LendingError.ErrorCode.INSUFFICIENT_POOL_LIQUIDITY
            )
        )

        // 3. Check whether or not borrowAllowed()
        let borrower = userCertificateCap.borrow()!.owner!.address
        let err = self.comptrollerCap!.borrow()!.borrowAllowed(
            poolCertificate: <- create PoolCertificate(),
            poolAddress: self.poolAddress,
            borrowerAddress: borrower,
            borrowUnderlyingAmountScaled: scaledBorrowAmount
        )
        assert(err == nil, message: err ?? "")

        // 4. Updates borrow states, withdraw from pool underlying vault and deposits into borrower's account
        self.scaledTotalBorrows = self.scaledTotalBorrows + scaledBorrowAmount
        let scaledBorrowBalanceNew = scaledBorrowAmount + self.borrowBalanceSnapshotScaled(borrowerAddress: borrower)
        self.accountBorrows[borrower] = BorrowSnapshot(principal: scaledBorrowBalanceNew, interestIndex: self.scaledBorrowIndex)
        emit Borrow(borrower: borrower, scaledBorrowAmount: scaledBorrowAmount, scaledBorrowerTotalBorrows: scaledBorrowBalanceNew, scaledPoolTotalBorrows: self.scaledTotalBorrows)

        let res <- self.underlyingVault.withdraw(amount: borrowAmount)
        return <- res
    }

    /// Repay the borrower's borrow
    ///
    /// @Param borrower - The address of the borrower
    /// @Param borrowAmount - The amount to repay
    /// @Return The overpaid vault will be returned.
    ///
    /// @Note: Caller ensures that LendingPool.accrueInterest() has been called with latest states checkpointed
    ///
    access(self) fun repayBorrowInternal(borrower: Address, repayUnderlyingVault: @FungibleToken.Vault): @FungibleToken.Vault? {
        // Check whether or not repayAllowed()
        let scaledRepayAmount = LendingConfig.UFix64ToScaledUInt256(repayUnderlyingVault.balance)
        let scaledAccountTotalBorrows = self.borrowBalanceSnapshotScaled(borrowerAddress: borrower)
        let scaledActualRepayAmount = scaledAccountTotalBorrows > scaledRepayAmount ? scaledRepayAmount : scaledAccountTotalBorrows

        let err = self.comptrollerCap!.borrow()!.repayAllowed(
            poolCertificate: <- create PoolCertificate(),
            poolAddress: self.poolAddress,
            borrowerAddress: borrower,
            repayUnderlyingAmountScaled: scaledActualRepayAmount
        )
        assert(err == nil, message: err ?? "")

        // Updates borrow states, deposit repay Vault into pool underlying vault and return any remaining Vault
        let scaledAccountTotalBorrowsNew = scaledAccountTotalBorrows > scaledRepayAmount ? scaledAccountTotalBorrows - scaledRepayAmount : (0 as UInt256)
        self.scaledTotalBorrows = self.scaledTotalBorrows - scaledActualRepayAmount
        emit Repay(borrower: borrower, scaledActualRepayAmount: scaledActualRepayAmount, scaledBorrowerTotalBorrows: scaledAccountTotalBorrowsNew, scaledPoolTotalBorrows: self.scaledTotalBorrows)
        if (scaledAccountTotalBorrows > scaledRepayAmount) {
            self.accountBorrows[borrower] = BorrowSnapshot(principal: scaledAccountTotalBorrowsNew, interestIndex: self.scaledBorrowIndex)
            self.underlyingVault.deposit(from: <-repayUnderlyingVault)
            return nil
        } else {
            self.accountBorrows.remove(key: borrower)
            let surplusAmount = LendingConfig.ScaledUInt256ToUFix64(scaledRepayAmount - scaledAccountTotalBorrows)
            self.underlyingVault.deposit(from: <-repayUnderlyingVault)
            return <- self.underlyingVault.withdraw(amount: surplusAmount)
        }
    }

    /// Anyone can repay borrow with a underlying Vault and receives a new underlying Vault if there's still any remaining left.
    ///
    /// @Param borrower - The address of the borrower
    /// @Param borrowAmount - The amount to repay
    /// @Return The overpaid vault will be returned.
    ///
    /// @Note: Note that the borrower address can potentially not be the same as the repayer address (which means someone can repay on behave of borrower),
    ///        this is allowed as there's no safety issue to do so.
    ///
    pub fun repayBorrow(borrower: Address, repayUnderlyingVault: @FungibleToken.Vault): @FungibleToken.Vault? {
        pre {
            repayUnderlyingVault.balance > 0.0: LendingError.ErrorEncode(msg: "Repaid zero", err: LendingError.ErrorCode.EMPTY_FUNGIBLE_TOKEN_VAULT)
            repayUnderlyingVault.isInstance(self.underlyingAssetType):
                LendingError.ErrorEncode(
                    msg: "Repaid vault and pool underlying type mismatch",
                    err: LendingError.ErrorCode.MISMATCHED_INPUT_VAULT_TYPE_WITH_POOL
                )
        }
        // Accrues interests and checkpoints latest states
        self.accrueInterest()

        let res <- self.repayBorrowInternal(borrower: borrower, repayUnderlyingVault: <-repayUnderlyingVault)

        return <- res
    }

    /// Liquidates the borrowers collateral.
    ///
    /// @Param liquidator - The address of the liquidator who will receive the collateral lpToken transfer
    /// @Param borrower - The borrower to be liquidated
    /// @Param poolCollateralizedToSeize - The market address in which to seize collateral from the borrower
    /// @Param repayUnderlyingVault - The amount of the underlying borrowed asset in this pool to repay
    /// @Return The overLiquidate vault will be returned.
    ///
    /// The collateral lpTokens seized is transferred to the liquidator.
    ///
    pub fun liquidate(
        liquidator: Address,
        borrower: Address,
        poolCollateralizedToSeize: Address,
        repayUnderlyingVault: @FungibleToken.Vault
    ): @FungibleToken.Vault? {
        pre {
            repayUnderlyingVault.balance > 0.0: LendingError.ErrorEncode(msg: "Liquidator repaid zero", err: LendingError.ErrorCode.EMPTY_FUNGIBLE_TOKEN_VAULT)
            repayUnderlyingVault.isInstance(self.underlyingAssetType):
                LendingError.ErrorEncode(
                    msg: "Liquidator repaid vault and pool underlying type mismatch",
                    err: LendingError.ErrorCode.MISMATCHED_INPUT_VAULT_TYPE_WITH_POOL
                )
        }
        // 1. Accrues interests and checkpoints latest states
        self.accrueInterest()

        // 2. Check whether or not liquidateAllowed()
        let scaledUnderlyingAmountToRepay = LendingConfig.UFix64ToScaledUInt256(repayUnderlyingVault.balance)
        let err = self.comptrollerCap!.borrow()!.liquidateAllowed(
            poolCertificate: <- create PoolCertificate(),
            poolBorrowed: self.poolAddress,
            poolCollateralized: poolCollateralizedToSeize,
            borrower: borrower,
            repayUnderlyingAmountScaled: scaledUnderlyingAmountToRepay
        )
        assert(err == nil, message: err ?? "")

        // 3. Liquidator repays on behave of borrower
        assert(liquidator != borrower, message:
            LendingError.ErrorEncode(
                msg: "liquidator and borrower cannot be the same",
                err: LendingError.ErrorCode.SAME_LIQUIDATOR_AND_BORROWER
            )
        )
        let remainingVault <- self.repayBorrowInternal(borrower: borrower, repayUnderlyingVault: <-repayUnderlyingVault)

        let scaledRemainingAmount = LendingConfig.UFix64ToScaledUInt256(remainingVault?.balance ?? 0.0)
        let scaledActualRepayAmount = scaledUnderlyingAmountToRepay - scaledRemainingAmount
        // Calculate collateralLpTokenSeizedAmount based on actualRepayAmount
        let scaledCollateralLpTokenSeizedAmount = self.comptrollerCap!.borrow()!.calculateCollateralPoolLpTokenToSeize(
            borrower: borrower,
            borrowPool: self.poolAddress,
            collateralPool: poolCollateralizedToSeize,
            actualRepaidBorrowAmountScaled: scaledActualRepayAmount
        )

        // 4. seizeInternal if current pool is also borrower's collateralPool; otherwise seize external collateralPool
        if (poolCollateralizedToSeize == self.poolAddress) {
            self.seizeInternal(
                liquidator: liquidator,
                borrower: borrower,
                scaledBorrowerLpTokenToSeize: scaledCollateralLpTokenSeizedAmount
            )
        } else {
            // Seize external
            let externalPoolPublicRef = getAccount(poolCollateralizedToSeize)
                .getCapability<&{LendingInterfaces.PoolPublic}>(LendingConfig.PoolPublicPublicPath).borrow()
                    ?? panic(
                        LendingError.ErrorEncode(
                            msg: "Cannot borrow reference to external PoolPublic resource",
                            err: LendingError.ErrorCode.CANNOT_ACCESS_POOL_PUBLIC_CAPABILITY
                        )
                    )
            externalPoolPublicRef.seize(
                seizerPoolCertificate: <- create PoolCertificate(),
                seizerPool: self.poolAddress,
                liquidator: liquidator,
                borrower: borrower,
                scaledBorrowerCollateralLpTokenToSeize: scaledCollateralLpTokenSeizedAmount
            )
        }

        emit Liquidate(
            liquidator: liquidator,
            borrower: borrower,
            scaledActualRepaidUnderlying: scaledActualRepayAmount,
            collateralPoolToSeize: poolCollateralizedToSeize,
            scaledCollateralPoolLpTokenSeized: scaledCollateralLpTokenSeizedAmount
        )

        return <-remainingVault
    }

    /// External seize, transfers collateral tokens (this market) to the liquidator.
    ///
    /// @Param seizerPoolCertificate - Pool's certificate guarantee that this interface can only be called by other valid markets
    /// @Param seizerPool - The external pool seizing the current collateral pool (i.e. borrowPool)
    /// @Param liquidator - The address of the liquidator who will receive the collateral lpToken transfer
    /// @Param borrower - The borrower to be liquidated
    /// @Param scaledBorrowerCollateralLpTokenToSeize - The amount of collateral lpTokens that will be seized from borrower to liquidator
    ///
    /// Only used for "external" seize. Run-time type check of pool certificate ensures it can only be called by other supported markets.
    ///
    pub fun seize(
        seizerPoolCertificate: @{LendingInterfaces.IdentityCertificate},
        seizerPool: Address,
        liquidator: Address,
        borrower: Address,
        scaledBorrowerCollateralLpTokenToSeize: UInt256
    ) {
        pre {
            seizerPool != self.poolAddress:
                LendingError.ErrorEncode(
                    msg: "External seize only, seizerPool cannot be current pool",
                    err: LendingError.ErrorCode.EXTERNAL_SEIZE_FROM_SELF
                )
        }
        // 1. Check and verify caller from another LendingPool contract
        let err = self.comptrollerCap!.borrow()!.callerAllowed(
            callerCertificate: <- seizerPoolCertificate,
            callerAddress: seizerPool
        )
        assert(err == nil, message: err ?? "")

        // 2. Accrues interests and checkpoints latest states
        self.accrueInterest()

        // 3. seizeInternal
        self.seizeInternal(
            liquidator: liquidator,
            borrower: borrower,
            scaledBorrowerLpTokenToSeize: scaledBorrowerCollateralLpTokenToSeize
        )
    }

    /// Internal seize
    ///
    /// @Param liquidator - The address of the liquidator who will receive the collateral lpToken transfer
    /// @Param borrower - The borrower to be liquidated
    /// @Param scaledBorrowerLpTokenToSeize - The amount of collateral lpTokens that will be seized from borrower to liquidator
    ///
    /// Caller ensures accrueInterest() has been called
    ///
    access(self) fun seizeInternal(
        liquidator: Address,
        borrower: Address,
        scaledBorrowerLpTokenToSeize: UInt256
    ) {
        pre {
            liquidator != borrower:
                LendingError.ErrorEncode(
                    msg: "seize: liquidator == borrower",
                    err: LendingError.ErrorCode.SAME_LIQUIDATOR_AND_BORROWER
                )
        }

        let err = self.comptrollerCap!.borrow()!.seizeAllowed(
            poolCertificate: <- create PoolCertificate(),
            borrowPool: self.poolAddress,
            collateralPool: self.poolAddress,
            liquidator: liquidator,
            borrower: borrower,
            seizeCollateralPoolLpTokenAmountScaled: scaledBorrowerLpTokenToSeize
        )
        assert(err == nil, message: err ?? "")

        let scaleFactor = LendingConfig.scaleFactor
        let scaledProtocolSeizedLpTokens = scaledBorrowerLpTokenToSeize * self.scaledPoolSeizeShare / scaleFactor
        let scaledLiquidatorSeizedLpTokens = scaledBorrowerLpTokenToSeize - scaledProtocolSeizedLpTokens
        let scaledUnderlyingToLpTokenRate = self.underlyingToLpTokenRateSnapshotScaled()
        let scaledAddedUnderlyingReserves = scaledUnderlyingToLpTokenRate * scaledProtocolSeizedLpTokens / scaleFactor
        self.scaledTotalReserves = self.scaledTotalReserves + scaledAddedUnderlyingReserves
        self.scaledTotalSupply = self.scaledTotalSupply - scaledProtocolSeizedLpTokens
        // in-place liquidation: only virtual lpToken records get updated, no token deposit / withdraw needs to happen
        if (self.accountLpTokens[borrower] == scaledBorrowerLpTokenToSeize) {
            self.accountLpTokens.remove(key: borrower)
        } else {
            self.accountLpTokens[borrower] = self.accountLpTokens[borrower]! - scaledBorrowerLpTokenToSeize
        }
        self.accountLpTokens[liquidator] = scaledLiquidatorSeizedLpTokens + (self.accountLpTokens[liquidator] ?? 0)

        emit ReservesAdded(donator: self.poolAddress, scaledAddedUnderlyingAmount: scaledAddedUnderlyingReserves, scaledNewTotalReserves: self.scaledTotalReserves)
    }

    /// An executor contract can request to use the whole liquidity of current LendingPool and perform custom operations (like arbitrage, liquidation, et al.), as long as:
    ///   1. executor implements FlashLoanExecutor resource interface and sets up corresponding resource to receive & process requested tokens, and
    ///   2. executor repays back requested amount + fees (dominated by 'flashloanRateBps x amount'), and
    /// all in one atomic function call.
    /// @params: User-definited extra data passed to executor for further auth/check/decode
    ///
    pub fun flashloan(executorCap: Capability<&{LendingInterfaces.FlashLoanExecutor}>, requestedAmount: UFix64, params: {String: AnyStruct}) {
        pre {
            self.isFlashloanOpen(): LendingError.ErrorEncode(
                    msg: "LendingError: flashloan is not open",
                    err: LendingError.ErrorCode.MARKET_NOT_OPEN
                )
            requestedAmount > 0.0 && requestedAmount < self.underlyingVault.balance: LendingError.ErrorEncode(
                    msg: "LendingError: flashloan invalid requested amount",
                    err: LendingError.ErrorCode.INSUFFICIENT_POOL_LIQUIDITY
                )
            executorCap.check(): LendingError.ErrorEncode(
                    msg: "LendingError: flashloan executor resource not properly setup",
                    err: LendingError.ErrorCode.FLASHLOAN_EXECUTOR_SETUP
                )
        }
        // Accrues interests and checkpoints latest states
        self.accrueInterest()

        let requestedAmountScaled = LendingConfig.UFix64ToScaledUInt256(requestedAmount)
        let tokenOut <-self.underlyingVault.withdraw(amount: requestedAmount)
        self.scaledTotalBorrows = self.scaledTotalBorrows + requestedAmountScaled

        let tokenIn <- executorCap.borrow()!.executeAndRepay(loanedToken: <- tokenOut, params: params)
        assert(tokenIn.isInstance(self.underlyingAssetType), message:
            LendingError.ErrorEncode(
                msg: "LendingError: flashloan repaid incompatible token",
                err: LendingError.ErrorCode.INVALID_PARAMETERS
            )
        )
        assert(tokenIn.balance >= requestedAmount * (1.0 + UFix64(self.getFlashloanRateBps()) / 10000.0), message:
            LendingError.ErrorEncode(
                msg: "LendingError: flashloan insufficient repayment",
                err: LendingError.ErrorCode.INVALID_PARAMETERS
            )
        )

        self.underlyingVault.deposit(from: <- tokenIn)
        self.scaledTotalBorrows = self.scaledTotalBorrows - requestedAmountScaled

        emit Flashloan(executor: executorCap.borrow()!.owner!.address, executorType: executorCap.borrow()!.getType(), originator: self.account.address, amount: requestedAmount)
    }

    /// Check whether or not the given certificate is issued by system
    ///
    access(self) fun checkUserCertificateType(certCap: Capability<&{LendingInterfaces.IdentityCertificate}>): Bool {
        return certCap.borrow()!.isInstance(self.comptrollerCap!.borrow()!.getUserCertificateType())
    }

    pub fun getFlashloanRateBps(): UInt64 {
        return (self._reservedFields["flashloanRateBps"] as! UInt64?) ?? 5
    }

    pub fun isFlashloanOpen(): Bool {
        return (self._reservedFields["isFlashloanOpen"] as! Bool?) ?? false
    }

    /// PoolCertificate
    ///
    /// Inherited from IdentityCertificate.
    /// Proof of identity for the pool.
    ///
    pub resource PoolCertificate: LendingInterfaces.IdentityCertificate {}

    /// PoolPublic
    ///
    /// The external interfaces of the pool, and will be exposed as a public capability.
    ///
    pub resource PoolPublic: LendingInterfaces.PoolPublic {

        pub fun getPoolAddress(): Address {
            return LendingPool.poolAddress
        }

        pub fun getUnderlyingTypeString(): String {
            let underlyingType = LendingPool.getUnderlyingAssetType()
            // "A.1654653399040a61.FlowToken.Vault" => "FlowToken"
            return underlyingType.slice(from: 19, upTo: underlyingType.length - 6)
        }

        pub fun getUnderlyingAssetType(): String {
            return LendingPool.getUnderlyingAssetType()
        }

        pub fun getUnderlyingToLpTokenRateScaled(): UInt256 {
            return LendingPool.underlyingToLpTokenRateSnapshotScaled()
        }

        pub fun getAccountLpTokenBalanceScaled(account: Address): UInt256 {
            return LendingPool.accountLpTokens[account] ?? 0
        }

        pub fun getAccountBorrowBalanceScaled(account: Address): UInt256 {
            return LendingPool.borrowBalanceSnapshotScaled(borrowerAddress: account)
        }

        pub fun getAccountBorrowPrincipalSnapshotScaled(account: Address): UInt256 {
            if (LendingPool.accountBorrows.containsKey(account) == false) {
                return 0
            } else {
                return LendingPool.accountBorrows[account]!.scaledPrincipal
            }
        }

        pub fun getAccountBorrowIndexSnapshotScaled(account: Address): UInt256 {
            if (LendingPool.accountBorrows.containsKey(account) == false) {
                return 0
            } else {
                return LendingPool.accountBorrows[account]!.scaledInterestIndex
            }
        }

        pub fun getAccountSnapshotScaled(account: Address): [UInt256; 5] {
            return [
                self.getUnderlyingToLpTokenRateScaled(),
                self.getAccountLpTokenBalanceScaled(account: account),
                self.getAccountBorrowBalanceScaled(account: account),
                self.getAccountBorrowPrincipalSnapshotScaled(account: account),
                self.getAccountBorrowIndexSnapshotScaled(account: account)
            ]
        }

        pub fun getAccountRealtimeScaled(account: Address): [UInt256; 5] {
            let accrueInterestRealtimeRes = self.accrueInterestReadonly()
            let poolBorrowIndexRealtime = accrueInterestRealtimeRes[1]
            let poolTotalBorrowRealtime = accrueInterestRealtimeRes[2]
            let poolTotalReserveRealtime = accrueInterestRealtimeRes[3]

            let underlyingTolpTokenRateRealtime = (LendingPool.getPoolCash() + poolTotalBorrowRealtime - poolTotalReserveRealtime) * LendingConfig.scaleFactor / LendingPool.scaledTotalSupply

            var borrowBalanceRealtimeScaled:UInt256 = 0
            if (LendingPool.accountBorrows.containsKey(account)) {
                borrowBalanceRealtimeScaled = self.getAccountBorrowPrincipalSnapshotScaled(account: account) * poolBorrowIndexRealtime / self.getAccountBorrowIndexSnapshotScaled(account: account)
            }

            return [
                underlyingTolpTokenRateRealtime,
                self.getAccountLpTokenBalanceScaled(account: account),
                borrowBalanceRealtimeScaled,
                self.getAccountBorrowPrincipalSnapshotScaled(account: account),
                self.getAccountBorrowIndexSnapshotScaled(account: account)
            ]
        }

        pub fun getPoolReserveFactorScaled(): UInt256 {
            return LendingPool.scaledReserveFactor
        }

        pub fun getInterestRateModelAddress(): Address {
            return LendingPool.interestRateModelAddress!
        }

        pub fun getPoolTotalBorrowsScaled(): UInt256 {
            return LendingPool.scaledTotalBorrows
        }

        pub fun getPoolAccrualBlockNumber(): UInt256 {
            return LendingPool.accrualBlockNumber
        }

        pub fun getPoolBorrowIndexScaled(): UInt256 {
            return LendingPool.scaledBorrowIndex
        }

        pub fun getPoolTotalLpTokenSupplyScaled(): UInt256 {
            return LendingPool.scaledTotalSupply
        }

        pub fun getPoolTotalSupplyScaled(): UInt256 {
            return LendingPool.getPoolCash() + LendingPool.scaledTotalBorrows
        }

        pub fun getPoolTotalReservesScaled(): UInt256 {
            return LendingPool.scaledTotalReserves
        }

        pub fun getPoolCash(): UInt256 {
            return LendingPool.getPoolCash()
        }

        pub fun getPoolSupplierCount(): UInt256 {
            return UInt256(LendingPool.accountLpTokens.length)
        }

        pub fun getPoolBorrowerCount(): UInt256 {
            return UInt256(LendingPool.accountBorrows.length)
        }

        pub fun getPoolSupplierList(): [Address] {
            return LendingPool.accountLpTokens.keys
        }

        pub fun getPoolSupplierSlicedList(from: UInt64, to: UInt64): [Address] {
            pre {
                from <= to && to < UInt64(LendingPool.accountLpTokens.length):
                    LendingError.ErrorEncode(
                        msg: "Index out of range",
                        err: LendingError.ErrorCode.INVALID_PARAMETERS
                    )
            }
            let borrowers: &[Address] = &LendingPool.accountLpTokens.keys as &[Address]
            let list: [Address] = []
            var i = from
            while i <= to {
                list.append(borrowers[i])
                i = i + 1
            }
            return list
        }

        pub fun getPoolBorrowerList(): [Address] {
            return LendingPool.accountBorrows.keys
        }

        pub fun getPoolBorrowerSlicedList(from: UInt64, to: UInt64): [Address] {
            pre {
                from <= to && to < UInt64(LendingPool.accountBorrows.length):
                    LendingError.ErrorEncode(
                        msg: "Index out of range",
                        err: LendingError.ErrorCode.INVALID_PARAMETERS
                    )
            }
            let borrowers: &[Address] = &LendingPool.accountBorrows.keys as &[Address]
            let list: [Address] = []
            var i = from
            while i <= to {
                list.append(borrowers[i])
                i = i + 1
            }
            return list
        }

        pub fun getPoolBorrowRateScaled(): UInt256 {
            return LendingPool.interestRateModelCap!.borrow()!.getBorrowRate(
                cash: LendingPool.getPoolCash(),
                borrows: LendingPool.scaledTotalBorrows,
                reserves: LendingPool.scaledTotalReserves
            )
        }

        pub fun getPoolBorrowAprScaled(): UInt256 {
            let scaledBorrowRatePerBlock =
                LendingPool.interestRateModelCap!.borrow()!.getBorrowRate(
                    cash: LendingPool.getPoolCash(),
                    borrows: LendingPool.scaledTotalBorrows,
                    reserves: LendingPool.scaledTotalReserves
                )
            let blocksPerYear = LendingPool.interestRateModelCap!.borrow()!.getBlocksPerYear()
            return scaledBorrowRatePerBlock * blocksPerYear
        }

        pub fun getPoolSupplyAprScaled(): UInt256 {
            let scaledSupplyRatePerBlock =
                LendingPool.interestRateModelCap!.borrow()!.getSupplyRate(
                    cash: LendingPool.getPoolCash(),
                    borrows: LendingPool.scaledTotalBorrows,
                    reserves: LendingPool.scaledTotalReserves,
                    reserveFactor: LendingPool.scaledReserveFactor
                )
            let blocksPerYear = LendingPool.interestRateModelCap!.borrow()!.getBlocksPerYear()
            return scaledSupplyRatePerBlock * blocksPerYear
        }

        /// The default flashloan rate is 5 bps (0.05%)
        pub fun getFlashloanRateBps(): UInt64 {
            return LendingPool.getFlashloanRateBps()
        }

        pub fun accrueInterest() {
            LendingPool.accrueInterest()
        }

        pub fun accrueInterestReadonly(): [UInt256; 4] {
            return LendingPool.accrueInterestReadonly()
        }

        pub fun getPoolCertificateType(): Type {
            return Type<@LendingPool.PoolCertificate>()
        }

        pub fun seize(
            seizerPoolCertificate: @{LendingInterfaces.IdentityCertificate},
            seizerPool: Address,
            liquidator: Address,
            borrower: Address,
            scaledBorrowerCollateralLpTokenToSeize: UInt256
        ) {
            LendingPool.seize(
                seizerPoolCertificate: <- seizerPoolCertificate,
                seizerPool: seizerPool,
                liquidator: liquidator,
                borrower: borrower,
                scaledBorrowerCollateralLpTokenToSeize: scaledBorrowerCollateralLpTokenToSeize
            )
        }

        pub fun supply(supplierAddr: Address, inUnderlyingVault: @FungibleToken.Vault) {
            LendingPool.supply(supplierAddr: supplierAddr, inUnderlyingVault: <-inUnderlyingVault)
        }

        pub fun redeem(userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>, numLpTokenToRedeem: UFix64): @FungibleToken.Vault {
            return <-LendingPool.redeem(userCertificateCap: userCertificateCap, numLpTokenToRedeem: numLpTokenToRedeem)
        }

        pub fun redeemUnderlying(userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>, numUnderlyingToRedeem: UFix64): @FungibleToken.Vault {
            return <-LendingPool.redeemUnderlying(userCertificateCap: userCertificateCap, numUnderlyingToRedeem: numUnderlyingToRedeem)
        }

        pub fun borrow(userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>, borrowAmount: UFix64): @FungibleToken.Vault {
            return <-LendingPool.borrow(userCertificateCap: userCertificateCap, borrowAmount: borrowAmount)
        }

        pub fun repayBorrow(borrower: Address, repayUnderlyingVault: @FungibleToken.Vault): @FungibleToken.Vault? {
            return <-LendingPool.repayBorrow(borrower: borrower, repayUnderlyingVault: <-repayUnderlyingVault)
        }

        pub fun liquidate(liquidator: Address, borrower: Address, poolCollateralizedToSeize: Address, repayUnderlyingVault: @FungibleToken.Vault): @FungibleToken.Vault? {
            return <-LendingPool.liquidate(liquidator: liquidator, borrower: borrower, poolCollateralizedToSeize: poolCollateralizedToSeize, repayUnderlyingVault: <-repayUnderlyingVault)
        }

        pub fun flashloan(executorCap: Capability<&{LendingInterfaces.FlashLoanExecutor}>, requestedAmount: UFix64, params: {String: AnyStruct}) {
            LendingPool.flashloan(executorCap: executorCap, requestedAmount: requestedAmount, params: params)
        }
    }

    /// PoolAdmin
    ///
    pub resource PoolAdmin: LendingInterfaces.PoolAdminPublic {
        /// Admin function to call accrueInterest() to checkpoint latest states, and then update the interest rate model
        pub fun setInterestRateModel(newInterestRateModelAddress: Address) {
            post {
                LendingPool.interestRateModelCap != nil && LendingPool.interestRateModelCap!.check() == true:
                    LendingError.ErrorEncode(
                        msg: "Invalid contract address of the new interest rate",
                        err: LendingError.ErrorCode.CANNOT_ACCESS_INTEREST_RATE_MODEL_CAPABILITY
                    )
            }
            LendingPool.accrueInterest()

            if (newInterestRateModelAddress != LendingPool.interestRateModelAddress) {
                let oldInterestRateModelAddress = LendingPool.interestRateModelAddress
                LendingPool.interestRateModelAddress = newInterestRateModelAddress
                LendingPool.interestRateModelCap = getAccount(newInterestRateModelAddress)
                    .getCapability<&{LendingInterfaces.InterestRateModelPublic}>(LendingConfig.InterestRateModelPublicPath)
                emit NewInterestRateModel(oldInterestRateModelAddress, newInterestRateModelAddress)
            }
            return
        }

        /// Admin function to call accrueInterest() to checkpoint latest states, and then update reserveFactor
        pub fun setReserveFactor(newReserveFactor: UFix64) {
            pre {
                newReserveFactor <= 1.0:
                LendingError.ErrorEncode(
                    msg: "Reserve factor out of range 1.0",
                    err: LendingError.ErrorCode.INVALID_PARAMETERS
                )
            }
            LendingPool.accrueInterest()

            let oldReserveFactor = LendingConfig.ScaledUInt256ToUFix64(LendingPool.scaledReserveFactor)
            LendingPool.scaledReserveFactor = LendingConfig.UFix64ToScaledUInt256(newReserveFactor)

            emit NewReserveFactor(oldReserveFactor, newReserveFactor)
            return
        }

        /// Admin function to update poolSeizeShare
        pub fun setPoolSeizeShare(newPoolSeizeShare: UFix64) {
            pre {
                newPoolSeizeShare <= 1.0:
                LendingError.ErrorEncode(
                    msg: "Pool seize share factor out of range 1.0",
                    err: LendingError.ErrorCode.INVALID_PARAMETERS
                )
            }
            let oldPoolSeizeShare = LendingConfig.ScaledUInt256ToUFix64(LendingPool.scaledPoolSeizeShare)
            LendingPool.scaledPoolSeizeShare = LendingConfig.UFix64ToScaledUInt256(newPoolSeizeShare)

            emit NewPoolSeizeShare(oldPoolSeizeShare, newPoolSeizeShare)
            return
        }

        /// Admin function to set comptroller
        pub fun setComptroller(newComptrollerAddress: Address) {
            post {
                LendingPool.comptrollerCap != nil && LendingPool.comptrollerCap!.check() == true:
                    LendingError.ErrorEncode(
                        msg: "Cannot borrow reference to ComptrollerPublic resource",
                        err: LendingError.ErrorCode.CANNOT_ACCESS_COMPTROLLER_PUBLIC_CAPABILITY
                    )
            }

            if (newComptrollerAddress != LendingPool.comptrollerAddress) {
                let oldComptrollerAddress = LendingPool.comptrollerAddress
                LendingPool.comptrollerAddress = newComptrollerAddress
                LendingPool.comptrollerCap = getAccount(newComptrollerAddress)
                    .getCapability<&{LendingInterfaces.ComptrollerPublic}>(LendingConfig.ComptrollerPublicPath)
                emit NewComptroller(oldComptrollerAddress, newComptrollerAddress)
            }
        }

        /// Admin function to initialize pool.
        /// Note: can be called only once
        pub fun initializePool(
            reserveFactor: UFix64,
            poolSeizeShare: UFix64,
            interestRateModelAddress: Address
        ) {
            pre {
                LendingPool.accrualBlockNumber == 0 && LendingPool.scaledBorrowIndex == 0:
                    LendingError.ErrorEncode(
                        msg: "Pool can only be initialized once",
                        err: LendingError.ErrorCode.POOL_INITIALIZED
                    )
                reserveFactor <= 1.0 && poolSeizeShare <= 1.0:
                    LendingError.ErrorEncode(
                        msg: "ReserveFactor | poolSeizeShare out of range 1.0",
                        err: LendingError.ErrorCode.INVALID_PARAMETERS
                    )
            }
            post {
                LendingPool.interestRateModelCap != nil && LendingPool.interestRateModelCap!.check() == true:
                    LendingError.ErrorEncode(
                        msg: "InterestRateModel not properly initialized",
                        err: LendingError.ErrorCode.CANNOT_ACCESS_INTEREST_RATE_MODEL_CAPABILITY
                    )
            }
            LendingPool.accrualBlockNumber = UInt256(getCurrentBlock().height)
            LendingPool.scaledBorrowIndex = LendingConfig.scaleFactor
            LendingPool.scaledReserveFactor = LendingConfig.UFix64ToScaledUInt256(reserveFactor)
            LendingPool.scaledPoolSeizeShare = LendingConfig.UFix64ToScaledUInt256(poolSeizeShare)
            LendingPool.interestRateModelAddress = interestRateModelAddress
            LendingPool.interestRateModelCap = getAccount(interestRateModelAddress)
                .getCapability<&{LendingInterfaces.InterestRateModelPublic}>(LendingConfig.InterestRateModelPublicPath)
        }

        /// Admin function to withdraw pool reserve
        pub fun withdrawReserves(reduceAmount: UFix64): @FungibleToken.Vault {
            LendingPool.accrueInterest()

            let reduceAmountScaled = reduceAmount == UFix64.max ? LendingPool.scaledTotalReserves : LendingConfig.UFix64ToScaledUInt256(reduceAmount)
            assert(reduceAmountScaled <= LendingPool.scaledTotalReserves, message:
                LendingError.ErrorEncode(
                    msg: "exceeded pool total reserve",
                    err: LendingError.ErrorCode.EXCEED_TOTAL_RESERVES
                )
            )
            assert(reduceAmountScaled <= LendingPool.getPoolCash(), message:
                LendingError.ErrorEncode(
                    msg: "insufficient pool liquidity to withdraw reserve",
                    err: LendingError.ErrorCode.INSUFFICIENT_POOL_LIQUIDITY
                )
            )
            LendingPool.scaledTotalReserves = LendingPool.scaledTotalReserves - reduceAmountScaled

            emit ReservesReduced(scaledReduceAmount: reduceAmountScaled, scaledNewTotalReserves: LendingPool.scaledTotalReserves)

            return <- LendingPool.underlyingVault.withdraw(amount: LendingConfig.ScaledUInt256ToUFix64(reduceAmountScaled))
        }

        pub fun setFlashloanRateBps(rateBps: UInt64) {
            pre {
                rateBps >= 0 && rateBps <= 10000:
                    LendingError.ErrorEncode(
                        msg: "LendingPool: flashloan rateBps should be in [0, 10000]",
                        err: LendingError.ErrorCode.INVALID_PARAMETERS
                    )
            }
            emit FlashloanRateChanged(oldRateBps: LendingPool.getFlashloanRateBps(), newRateBps: rateBps)
            LendingPool._reservedFields["flashloanRateBps"] = rateBps
        }

        pub fun setFlashloanOpen(isOpen: Bool) {
            emit FlashloanOpen(isOpen: isOpen)
            LendingPool._reservedFields["isFlashloanOpen"] = isOpen
        }
    }

    init() {
        self.PoolAdminStoragePath = /storage/incrementLendingPoolAdmin
        self.UnderlyingAssetVaultStoragePath = /storage/poolUnderlyingAssetVault
        self.PoolPublicStoragePath = /storage/incrementLendingPoolPublic
        self.PoolPublicPublicPath = /public/incrementLendingPoolPublic

        self.poolAddress = self.account.address
        self.scaledInitialExchangeRate = LendingConfig.scaleFactor
        self.accrualBlockNumber = 0
        self.scaledBorrowIndex = 0
        self.scaledTotalBorrows = 0
        self.scaledTotalReserves = 0
        self.scaledReserveFactor = 0
        self.scaledPoolSeizeShare = 0
        self.scaledTotalSupply = 0
        self.accountLpTokens = {}
        self.accountBorrows = {}
        self.interestRateModelAddress = nil
        self.interestRateModelCap = nil
        self.comptrollerAddress = nil
        self.comptrollerCap = nil
        self._reservedFields = {}
        self.underlyingVault <- self.account.load<@FungibleToken.Vault>(from: self.UnderlyingAssetVaultStoragePath)
            ?? panic("Deployer should own zero-balanced underlying asset vault first")
        self.underlyingAssetType = self.underlyingVault.getType()
        assert(self.underlyingVault.balance == 0.0, message: "Must initialize pool with zero-balanced underlying asset vault")

        // save pool admin
        destroy <-self.account.load<@AnyResource>(from: self.PoolAdminStoragePath)
        self.account.save(<-create PoolAdmin(), to: self.PoolAdminStoragePath)
        // save pool public interface
        self.account.unlink(self.PoolPublicPublicPath)
        destroy <-self.account.load<@AnyResource>(from: self.PoolPublicStoragePath)
        self.account.save(<-create PoolPublic(), to: self.PoolPublicStoragePath)
        self.account.unlink(self.PoolPublicPublicPath)
        self.account.link<&{LendingInterfaces.PoolPublic}>(LendingConfig.PoolPublicPublicPath, target: self.PoolPublicStoragePath)
    }
}
"
-------
"/*

 This contract defines the Dust Collectible Templates and the Collection to manage them.
 Dust Collectible Templates are the building blocks (lego bricks) of the final Dust Collectible,

 Templates are NOT using the NFT standard and will be always linked only to the contract's owner account.

 Templates are organized in Series, Layers and have maximum mint number along with some other variables.

 */

pub contract FlovatarDustCollectibleTemplate {

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath


    // Counter for all the Templates ever minted
    pub var totalSupply: UInt64
    pub var totalSeriesSupply: UInt64
    //These counters will keep track of how many Components were minted for each Template
    access(contract) let totalMintedComponents: { UInt64: UInt64 }
    access(contract) let totalMintedCollectibles: { UInt64: UInt64 }
    access(contract) let templatesCurrentPrice: { UInt64: UFix64 }
    access(contract) let lastComponentMintedAt: { UInt64: UFix64 }

    // Event to notify about the Template creation
    pub event ContractInitialized()
    pub event Created(id: UInt64, name: String, series: UInt64, layer: UInt32, maxMintableComponents: UInt64)
    pub event CreatedSeries(id: UInt64, name: String, maxMintable: UInt64)

    pub struct Layer{
        pub let id: UInt32
        pub let name: String
        pub let isAccessory: Bool

        init(id: UInt32, name: String, isAccessory: Bool){
            self.id = id
            self.name = name
            self.isAccessory = isAccessory
        }
    }

    pub resource interface PublicSeries {
        pub let id: UInt64
        pub let name: String
        pub let description: String
        pub let svgPrefix: String
        pub let svgSuffix: String
        pub let priceIncrease: UFix64
        access(contract) let layers: {UInt32: Layer}
        access(contract) let colors: {UInt32: String}
        access(contract) let metadata: {String: String}
        pub let maxMintable: UInt64
        pub fun getLayers(): {UInt32: Layer}
        pub fun getColors(): {UInt32: String}
        pub fun getMetadata(): {String: String}
    }

    // The Series resource implementing the public interface as well
    pub resource CollectibleSeries: PublicSeries {
        pub let id: UInt64
        pub let name: String
        pub let description: String
        pub let svgPrefix: String
        pub let svgSuffix: String
        pub let priceIncrease: UFix64
        access(contract) let layers: {UInt32: Layer}
        access(contract) let colors: {UInt32: String}
        access(contract) let metadata: {String: String}
        pub let maxMintable: UInt64

        pub fun getLayers(): {UInt32: Layer} {
            return self.layers
        }
        pub fun getColors(): {UInt32: String} {
            return self.colors
        }
        pub fun getMetadata(): {String: String} {
            return self.metadata
        }

        init(
            name: String,
            description: String,
            svgPrefix: String,
            svgSuffix: String,
            priceIncrease: UFix64,
            layers: {UInt32: Layer},
            colors: {UInt32: String},
            metadata: {String: String},
            maxMintable: UInt64
        ) {
            // increments the counter and stores it as the ID
            FlovatarDustCollectibleTemplate.totalSeriesSupply = FlovatarDustCollectibleTemplate.totalSeriesSupply + UInt64(1)
            self.id = FlovatarDustCollectibleTemplate.totalSeriesSupply
            self.name = name
            self.description = description
            self.svgPrefix = svgPrefix
            self.svgSuffix = svgSuffix
            self.priceIncrease = priceIncrease
            self.layers = layers
            self.colors = colors
            self.metadata = metadata
            self.maxMintable = maxMintable
        }
   }

    // The public interface providing the SVG and all the other
    // metadata like name, series, layer, etc.
    pub resource interface Public {
        pub let id: UInt64
        pub let name: String
        pub let description: String
        pub let series: UInt64
        pub let layer: UInt32
        access(contract) let metadata: {String: String}
        pub let rarity: String
        pub let basePrice: UFix64
        pub let svg: String
        pub let maxMintableComponents: UInt64

        pub fun getMetadata(): {String: String} {
            return self.metadata
        }
    }

    // The Template resource implementing the public interface as well
    pub resource CollectibleTemplate: Public {
        pub let id: UInt64
        pub let name: String
        pub let description: String
        pub let series: UInt64
        pub let layer: UInt32
        access(contract) let metadata: {String: String}
        pub let rarity: String
        pub let basePrice: UFix64
        pub let svg: String
        pub let maxMintableComponents: UInt64

        // Initialize a Template with all the necessary data
        init(
            name: String,
            description: String,
            series: UInt64,
            layer: UInt32,
            metadata: {String: String},
            rarity: String,
            basePrice: UFix64,
            svg: String,
            maxMintableComponents: UInt64
        ) {
            // increments the counter and stores it as the ID
            FlovatarDustCollectibleTemplate.totalSupply = FlovatarDustCollectibleTemplate.totalSupply + UInt64(1)
            self.id = FlovatarDustCollectibleTemplate.totalSupply
            self.name = name
            self.description = description
            self.series = series
            self.layer = layer
            self.metadata = metadata
            self.rarity = rarity
            self.basePrice = basePrice
            self.svg = svg
            self.maxMintableComponents = maxMintableComponents
        }
    }

    // Standard CollectionPublic interface that can also borrow Component Templates
    pub resource interface CollectionPublic {
        pub fun getIDs(): [UInt64]
        pub fun getSeriesIDs(): [UInt64]
        pub fun borrowCollectibleTemplate(id: UInt64): &{FlovatarDustCollectibleTemplate.Public}?
        pub fun borrowCollectibleSeries(id: UInt64): &{FlovatarDustCollectibleTemplate.PublicSeries}?
    }

    // The main Collection that manages the Templates and that implements also the Public interface
    pub resource Collection: CollectionPublic {
        // Dictionary of Component Templates
        pub var ownedCollectibleTemplates: @{UInt64: FlovatarDustCollectibleTemplate.CollectibleTemplate}
        pub var ownedCollectibleSeries: @{UInt64: FlovatarDustCollectibleTemplate.CollectibleSeries}

        init () {
            self.ownedCollectibleTemplates <- {}
            self.ownedCollectibleSeries <- {}
        }



        // deposit takes a Component Template and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun deposit(collectibleTemplate: @FlovatarDustCollectibleTemplate.CollectibleTemplate) {

            let id: UInt64 = collectibleTemplate.id

            // add the new Component Template to the dictionary which removes the old one
            let oldCollectibleTemplate <- self.ownedCollectibleTemplates[id] <- collectibleTemplate

            destroy oldCollectibleTemplate
        }

        // deposit takes a Series and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun depositSeries(collectibleSeries: @FlovatarDustCollectibleTemplate.CollectibleSeries) {

            let id: UInt64 = collectibleSeries.id

            // add the new Component Template to the dictionary which removes the old one
            let oldCollectibleTemplate <- self.ownedCollectibleSeries[id] <- collectibleSeries

            destroy oldCollectibleTemplate
        }

        // getIDs returns an array of the IDs that are in the collection
        pub fun getIDs(): [UInt64] {
            return self.ownedCollectibleTemplates.keys
        }

        // getIDs returns an array of the IDs that are in the collection
        pub fun getSeriesIDs(): [UInt64] {
            return self.ownedCollectibleSeries.keys
        }

        // borrowCollectibleTemplate returns a borrowed reference to a Component Template
        // so that the caller can read data and call methods from it.
        pub fun borrowCollectibleTemplate(id: UInt64): &{FlovatarDustCollectibleTemplate.Public}? {
            if self.ownedCollectibleTemplates[id] != nil {
                let ref = (&self.ownedCollectibleTemplates[id] as auth &FlovatarDustCollectibleTemplate.CollectibleTemplate?)!
                return ref as! &FlovatarDustCollectibleTemplate.CollectibleTemplate
            } else {
                return nil
            }
        }

        // borrowCollectibleTemplate returns a borrowed reference to a Component Template
        // so that the caller can read data and call methods from it.
        pub fun borrowCollectibleSeries(id: UInt64): &{FlovatarDustCollectibleTemplate.PublicSeries}? {
            if self.ownedCollectibleSeries[id] != nil {
                let ref = (&self.ownedCollectibleSeries[id] as auth &FlovatarDustCollectibleTemplate.CollectibleSeries?)!
                return ref as! &FlovatarDustCollectibleTemplate.CollectibleSeries
            } else {
                return nil
            }
        }

        destroy() {
            destroy self.ownedCollectibleTemplates
            destroy self.ownedCollectibleSeries
        }
    }

    // This function can only be called by the account owner to create an empty Collection
    access(account) fun createEmptyCollection(): @FlovatarDustCollectibleTemplate.Collection {
        return <- create Collection()
    }




    // This struct is used to send a data representation of the Templates
    // when retrieved using the contract helper methods outside the collection.
    pub struct CollectibleSeriesData {
        pub let id: UInt64
        pub let name: String
        pub let description: String
        pub let svgPrefix: String
        pub let svgSuffix: String
        pub let priceIncrease: UFix64
        pub let layers: {UInt32: Layer}
        pub let colors: {UInt32: String}
        pub let metadata: {String: String}
        pub let maxMintable: UInt64
        pub let totalMintedCollectibles: UInt64

        init(
            id: UInt64,
            name: String,
            description: String,
            svgPrefix: String,
            svgSuffix: String,
            priceIncrease: UFix64,
            layers: {UInt32: Layer},
            colors: {UInt32: String},
            metadata: {String: String},
            maxMintable: UInt64
        ) {
            self.id = id
            self.name = name
            self.description = description
            self.svgPrefix = svgPrefix
            self.svgSuffix = svgSuffix
            self.priceIncrease = priceIncrease
            self.layers = layers
            self.colors = colors
            self.metadata = metadata
            self.maxMintable = maxMintable
            self.totalMintedCollectibles = FlovatarDustCollectibleTemplate.getTotalMintedCollectibles(series: id)!
        }
    }

    // This struct is used to send a data representation of the Templates
    // when retrieved using the contract helper methods outside the collection.
    pub struct CollectibleTemplateData {
        pub let id: UInt64
        pub let name: String
        pub let description: String
        pub let series: UInt64
        pub let layer: UInt32
        pub let metadata: {String: String}
        pub let rarity: String
        pub let basePrice: UFix64
        pub let svg: String?
        pub let maxMintableComponents: UInt64
        pub let totalMintedComponents: UInt64
        pub let currentPrice: UFix64
        pub let lastComponentMintedAt: UFix64

        init(
            id: UInt64,
            name: String,
            description: String,
            series: UInt64,
            layer: UInt32,
            metadata: {String: String},
            rarity: String,
            basePrice: UFix64,
            svg: String?,
            maxMintableComponents: UInt64
        ) {
            self.id = id
            self.name = name
            self.description = description
            self.series = series
            self.layer = layer
            self.metadata = metadata
            self.rarity = rarity
            self.basePrice = basePrice
            self.svg = svg
            self.maxMintableComponents = maxMintableComponents
            self.totalMintedComponents = FlovatarDustCollectibleTemplate.getTotalMintedComponents(id: id)!
            self.currentPrice = FlovatarDustCollectibleTemplate.getTemplateCurrentPrice(id: id)!
            self.lastComponentMintedAt = FlovatarDustCollectibleTemplate.getLastComponentMintedAt(id: id)!
        }
    }

    // Get all the Component Templates from the account.
    // We hide the SVG field because it might be too big to execute in a script
    pub fun getCollectibleTemplates() : [CollectibleTemplateData] {
        var collectibleTemplateData: [CollectibleTemplateData] = []

        if let collectibleTemplateCollection = self.account.getCapability(self.CollectionPublicPath).borrow<&{FlovatarDustCollectibleTemplate.CollectionPublic}>()  {
            for id in collectibleTemplateCollection.getIDs() {
                var collectibleTemplate = collectibleTemplateCollection.borrowCollectibleTemplate(id: id)
                collectibleTemplateData.append(CollectibleTemplateData(
                    id: id,
                    name: collectibleTemplate!.name,
                    description: collectibleTemplate!.description,
                    series: collectibleTemplate!.series,
                    layer: collectibleTemplate!.layer,
                    metadata: collectibleTemplate!.metadata,
                    rarity: collectibleTemplate!.rarity,
                    basePrice: collectibleTemplate!.basePrice,
                    svg: nil,
                    maxMintableComponents: collectibleTemplate!.maxMintableComponents
                    ))
            }
        }
        return collectibleTemplateData
    }


    // Get all the Series from the account.
    // We hide the SVG field because it might be too big to execute in a script
    pub fun getCollectibleSeriesAll() : [CollectibleSeriesData] {
        var collectibleSeriesData: [CollectibleSeriesData] = []

        if let collectibleTemplateCollection = self.account.getCapability(self.CollectionPublicPath).borrow<&{FlovatarDustCollectibleTemplate.CollectionPublic}>()  {
            for id in collectibleTemplateCollection.getSeriesIDs() {
                var collectibleSeries = collectibleTemplateCollection.borrowCollectibleSeries(id: id)
                collectibleSeriesData.append(CollectibleSeriesData(
                    id: id,
                    name: collectibleSeries!.name,
                    description: collectibleSeries!.description,
                    svgPrefix: collectibleSeries!.svgPrefix,
                    svgSuffix: collectibleSeries!.svgSuffix,
                    priceIncrease: collectibleSeries!.priceIncrease,
                    layers: collectibleSeries!.layers,
                    colors: collectibleSeries!.colors,
                    metadata: collectibleSeries!.metadata,
                    maxMintable: collectibleSeries!.maxMintable
                    ))
            }
        }
        return collectibleSeriesData
    }

    // Gets a specific Template from its ID
    pub fun getCollectibleTemplate(id: UInt64) : CollectibleTemplateData? {
        if let collectibleTemplateCollection = self.account.getCapability(self.CollectionPublicPath).borrow<&{FlovatarDustCollectibleTemplate.CollectionPublic}>()  {
            if let collectibleTemplate = collectibleTemplateCollection.borrowCollectibleTemplate(id: id) {
                return CollectibleTemplateData(
                    id: id,
                    name: collectibleTemplate!.name,
                    description: collectibleTemplate!.description,
                    series: collectibleTemplate!.series,
                    layer: collectibleTemplate!.layer,
                    metadata: collectibleTemplate!.metadata,
                    rarity: collectibleTemplate!.rarity,
                    basePrice: collectibleTemplate!.basePrice,
                    svg: collectibleTemplate!.svg,
                    maxMintableComponents: collectibleTemplate!.maxMintableComponents
                    )
            }
        }
        return nil
    }

    // Gets the SVG of a specific Template from its ID
    pub fun getCollectibleTemplateSvg(id: UInt64) : String? {
        if let collectibleTemplateCollection = self.account.getCapability(self.CollectionPublicPath).borrow<&{FlovatarDustCollectibleTemplate.CollectionPublic}>()  {
            if let collectibleTemplate = collectibleTemplateCollection.borrowCollectibleTemplate(id: id) {
                return collectibleTemplate!.svg
            }
        }
        return nil
    }


    // Gets a specific Series from its ID
    pub fun getCollectibleSeries(id: UInt64) : CollectibleSeriesData? {
        if let collectibleTemplateCollection = self.account.getCapability(self.CollectionPublicPath).borrow<&{FlovatarDustCollectibleTemplate.CollectionPublic}>()  {
            if let collectibleSeries = collectibleTemplateCollection.borrowCollectibleSeries(id: id) {
                return CollectibleSeriesData(
                    id: id,
                    name: collectibleSeries!.name,
                    description: collectibleSeries!.description,
                    svgPrefix: collectibleSeries!.svgPrefix,
                    svgSuffix: collectibleSeries!.svgSuffix,
                    priceIncrease: collectibleSeries!.priceIncrease,
                    layers: collectibleSeries!.layers,
                    colors: collectibleSeries!.colors,
                    metadata: collectibleSeries!.metadata,
                    maxMintable: collectibleSeries!.maxMintable
                    )
            }
        }
        return nil
    }

    pub fun isCollectibleLayerAccessory(layer: UInt32, series: UInt64): Bool {
        let series = FlovatarDustCollectibleTemplate.getCollectibleSeries(id: series)!
        if let layer = series.layers[layer] {
            if(layer.isAccessory){
                return true
            }
        }
        return false
    }

    // Returns the amount of minted Components for a specific Template
    pub fun getTotalMintedComponents(id: UInt64) : UInt64? {
        return FlovatarDustCollectibleTemplate.totalMintedComponents[id]
    }
    // Returns the amount of minted Collectibles for a specific Series
    pub fun getTotalMintedCollectibles(series: UInt64) : UInt64? {
        return FlovatarDustCollectibleTemplate.totalMintedCollectibles[series]
    }
    // Returns the current price for a specific Template
    pub fun getTemplateCurrentPrice(id: UInt64) : UFix64? {
        return FlovatarDustCollectibleTemplate.templatesCurrentPrice[id]
    }

    // Returns the timestamp of the last time a Component for a specific Template was minted
    pub fun getLastComponentMintedAt(id: UInt64) : UFix64? {
        return FlovatarDustCollectibleTemplate.lastComponentMintedAt[id]
    }

    // This function is used within the contract to set the new counter for each Template
    access(account) fun setTotalMintedComponents(id: UInt64, value: UInt64) {
        FlovatarDustCollectibleTemplate.totalMintedComponents[id] = value
    }
    // This function is used within the contract to set the new counter for each Template
    access(account) fun increaseTotalMintedComponents(id: UInt64) {
        let totMintedComponents: UInt64? = FlovatarDustCollectibleTemplate.totalMintedComponents[id]
        if(totMintedComponents != nil){
            FlovatarDustCollectibleTemplate.totalMintedComponents[id] = totMintedComponents! + UInt64(1)
        }
    }
    // This function is used within the contract to set the new counter for each Series
    access(account) fun setTotalMintedCollectibles(series: UInt64, value: UInt64) {
        FlovatarDustCollectibleTemplate.totalMintedCollectibles[series] = value
    }
    // This function is used within the contract to set the new counter for each Template
    access(account) fun increaseTotalMintedCollectibles(series: UInt64) {
        let totMintedCollectibles: UInt64? = FlovatarDustCollectibleTemplate.totalMintedCollectibles[series]
        if(totMintedCollectibles != nil){
            FlovatarDustCollectibleTemplate.totalMintedCollectibles[series] = totMintedCollectibles! + UInt64(1)
        }
    }
    // This function is used within the contract to set the new counter for each Template
    access(account) fun setTemplatesCurrentPrice(id: UInt64, value: UFix64) {
        FlovatarDustCollectibleTemplate.templatesCurrentPrice[id] = value
    }
    // This function is used within the contract to set the new counter for each Template
    access(account) fun increaseTemplatesCurrentPrice(id: UInt64) {
        let currentPrice: UFix64? = FlovatarDustCollectibleTemplate.templatesCurrentPrice[id]
        if(currentPrice != nil){
            let template = FlovatarDustCollectibleTemplate.getCollectibleTemplate(id: id)
            let series = FlovatarDustCollectibleTemplate.getCollectibleSeries(id: template!.series)
            FlovatarDustCollectibleTemplate.templatesCurrentPrice[id] = currentPrice! * (UFix64(1.0) + series!.priceIncrease)
        }
    }
    // This function is used within the contract to set the timestamp
    // when a Component for a specific Template was minted
    access(account) fun setLastComponentMintedAt(id: UInt64, value: UFix64) {
        FlovatarDustCollectibleTemplate.lastComponentMintedAt[id] = value
    }


    access(account) fun createCollectibleTemplate(
        name: String,
        description: String,
        series: UInt64,
        layer: UInt32,
        metadata: {String: String},
        rarity: String,
        basePrice: UFix64,
        svg: String,
        maxMintableComponents: UInt64
    ) : @FlovatarDustCollectibleTemplate.CollectibleTemplate {

        var newCollectibleTemplate <- create CollectibleTemplate(
            name: name,
            description: description,
            series: series,
            layer: layer,
            metadata: metadata,
            rarity: rarity,
            basePrice: basePrice,
            svg: svg,
            maxMintableComponents: maxMintableComponents
        )

        // Emits the Created event to notify about the new Template
        emit Created(id: newCollectibleTemplate.id, name: newCollectibleTemplate.name, series: newCollectibleTemplate.series, layer: newCollectibleTemplate.layer, maxMintableComponents: newCollectibleTemplate.maxMintableComponents)

        // Set the counter for the minted Components of this Template to 0
        FlovatarDustCollectibleTemplate.setTotalMintedComponents(id: newCollectibleTemplate.id, value: UInt64(0))
        FlovatarDustCollectibleTemplate.setTemplatesCurrentPrice(id: newCollectibleTemplate.id, value: basePrice)
        FlovatarDustCollectibleTemplate.setLastComponentMintedAt(id: newCollectibleTemplate.id, value: UFix64(0))

        return <- newCollectibleTemplate
    }

    access(account) fun createCollectibleSeries(
        name: String,
        description: String,
        svgPrefix: String,
        svgSuffix: String,
        priceIncrease: UFix64,
        layers: {UInt32: Layer},
        colors: {UInt32: String},
        metadata: {String: String},
        maxMintable: UInt64
    ) : @FlovatarDustCollectibleTemplate.CollectibleSeries {

        var newCollectibleSeries <- create CollectibleSeries(
            name: name,
            description: description,
            svgPrefix: svgPrefix,
            svgSuffix: svgSuffix,
            priceIncrease: priceIncrease,
            layers: layers,
            colors: colors,
            metadata: metadata,
            maxMintable: maxMintable
        )

        // Emits the Created event to notify about the new Template
        emit CreatedSeries(id: newCollectibleSeries.id, name: newCollectibleSeries.name, maxMintable: newCollectibleSeries.maxMintable)

        // Set the counter for the minted Collectibles of this Series to 0
        FlovatarDustCollectibleTemplate.setTotalMintedCollectibles(series: newCollectibleSeries.id, value: UInt64(0))

        return <- newCollectibleSeries
    }
	init() {
        self.CollectionPublicPath=/public/FlovatarDustCollectibleTemplateCollection
        self.CollectionStoragePath=/storage/FlovatarDustCollectibleTemplateCollection

        // Initialize the total supply
        self.totalSupply = 0
        self.totalSeriesSupply = 0
        self.totalMintedComponents = {}
        self.totalMintedCollectibles = {}
        self.templatesCurrentPrice = {}
        self.lastComponentMintedAt = {}

        self.account.save<@FlovatarDustCollectibleTemplate.Collection>(<- FlovatarDustCollectibleTemplate.createEmptyCollection(), to: FlovatarDustCollectibleTemplate.CollectionStoragePath)
        self.account.link<&{FlovatarDustCollectibleTemplate.CollectionPublic}>(FlovatarDustCollectibleTemplate.CollectionPublicPath, target: FlovatarDustCollectibleTemplate.CollectionStoragePath)

        emit ContractInitialized()
	}
}
"
-------
"
/*
*
*  Manages the process of collecting votes for the root quorum certificate of the upcoming
*  epoch for all collection node clusters assigned for the upcoming epoch.
*
*  When collector nodes are first registered, they can request a Voter object from this contract.
*  They'll use this object for every subsequent epoch where they are a staked collector node.
*
*  At the beginning of each EpochSetup phase, the admin initializes this contract with
*  the collector clusters for the upcoming epoch. Each collector node has a single vote
*  that is allocated for them and they can only call their `vote` function once.
*
*  Once all the clusters have received enough identical votes to surpass their weight threshold,
*  The QC generation phase is finished and the admin will end the voting.
*  At any point, anyone can query the voting information for the clusters
*  by using the `getClusters` function.
*
*  This contract is a member of a series of epoch smart contracts which coordinates the
*  process of transitioning between epochs in Flow.
*/

import Crypto

pub contract FlowClusterQC {

    // ================================================================================
    // CONTRACT VARIABLES
    // ================================================================================

    /// Indicates whether votes are currently being collected.
    /// If false, no node operator will be able to submit votes
    pub var inProgress: Bool

    /// The collection node clusters for the current epoch
    access(account) var clusters: [Cluster]

    /// Indicates if a voter resource has already been claimed by a node ID
    /// from the identity table contract
    /// Node IDs have to claim a voter once
    /// one node will use the same specific ID and Voter resource for all time
    /// `nil` means that there is no voting capability for the node ID
    /// false means that a voter capability for the ID, but it hasn't been claimed
    /// true means that the voter capability has been claimed by the node
    access(account) var voterClaimed: {String: Bool}

    /// Indicates what cluster a node is in for the current epoch
    /// Value is a cluster index
    access(contract) var nodeCluster: {String: UInt16}

    // ================================================================================
    // CONTRACT CONSTANTS
    // ================================================================================

    /// Canonical paths for admin and voter resources
    pub let AdminStoragePath: StoragePath
    pub let VoterStoragePath: StoragePath

    /// Represents a collection node cluster for a given epoch.
    pub struct Cluster {

        /// The index of the cluster within the cluster array. This uniquely identifies
        /// a cluster for a given epoch
        pub let index: UInt16

        /// Weights for each nodeID in the cluster
        pub let nodeWeights: {String: UInt64}

        /// The total node weight of all the nodes in the cluster
        pub let totalWeight: UInt64

        /// Votes that nodes claim at the beginning of each EpochSetup phase
        /// Key is node ID from the identity table contract
        /// Vote resources without signatures or messages for each node are stored here
        /// at the beginning of each epoch setup phase.
        /// When a node submits a vote, the vote function takes it out of this map,
        /// adds their signature and message, then adds it back to this vote list.
        /// If a node has voted, their `signature` and `message` field will be non-`nil`
        /// If a node hasn't voted, their `signature` and `message` field will be `nil`
        pub var generatedVotes: {String: Vote}

        /// Tracks each unique vote and how much combined weight has been sent for the vote
        pub var uniqueVoteMessageTotalWeights: {String: UInt64}

        init(index: UInt16, nodeWeights: {String: UInt64}) {
            self.index = index
            self.nodeWeights = nodeWeights

            var totalWeight: UInt64 = 0
            for weight in nodeWeights.values {
                totalWeight = totalWeight + weight
            }
            self.totalWeight = totalWeight
            self.generatedVotes = {}
            self.uniqueVoteMessageTotalWeights = {}
        }

        /// Returns the number of nodes in the cluster
        pub fun size(): UInt16 {
            return UInt16(self.nodeWeights.length)
        }

        /// Returns the minimum sum of vote weight required in order to be able to generate a
        /// valid quorum certificate for this cluster.
        pub fun voteThreshold(): UInt64 {
            if self.totalWeight == 0 as UInt64 {
                return 0 as UInt64
            }

            let floorOneThird = self.totalWeight / UInt64(3) // integer division, includes floor

            var res = UInt64(2) * floorOneThird

            let divRemainder = self.totalWeight % UInt64(3)

            if divRemainder <= UInt64(1) {
                res = res + UInt64(1)
            } else {
                res = res + divRemainder
            }

            return res
        }

        /// Returns the status of this cluster's QC process
        /// If there is a number of weight for identical votes exceeding the `voteThreshold`,
        /// Then this cluster's QC generation is considered complete and this method returns
        /// the vote message that reached quorum
        /// If no vote is found to reach quorum, then `nil` is returned
        pub fun isComplete(): String? {
            for message in self.uniqueVoteMessageTotalWeights.keys {
                if self.uniqueVoteMessageTotalWeights[message]! >= self.voteThreshold() {
                    return message
                }
            }
            return nil
        }

        /// Generates the Quorum Certificate for this cluster
        /// If the cluster is not complete, this returns `nil`
        pub fun generateQuorumCertificate(): ClusterQC? {

            // Only generate the QC if the voting is complete for this cluster
            if let quorumMessage = self.isComplete() {

                // Create a new empty QC
                var certificate: ClusterQC = ClusterQC(index: self.index, signatures: [], message: quorumMessage, voterIDs: [])

                // Add the signatures, messages, and node IDs only for votes
                // that match the votes that reached quorum
                for vote in self.generatedVotes.values {

                    // Only count votes that were submitted
                    if let submittedMessage = vote.message {
                        if submittedMessage == quorumMessage {
                            certificate.addSignature(vote.signature!)
                            certificate.addVoterID(vote.nodeID)
                        }
                    }
                }

                return certificate
            } else {
                return nil
            }
        }

        /// Gets a vote that was generated for a node ID
        access(contract) fun getGeneratedVote(nodeId: String): Vote? {
            return self.generatedVotes[nodeId]
        }

        /// Sets the vote for the specified node ID
        access(contract) fun setGeneratedVote(nodeId: String, vote: Vote) {
            self.generatedVotes[nodeId] = vote
        }

        /// Gets the total weight commited for a unique vote
        access(contract) fun getUniqueVoteMessageTotalWeight(vote: String): UInt64? {
            return self.uniqueVoteMessageTotalWeights[vote]
        }

        /// Sets the total weight for a unique vote
        access(contract) fun setUniqueVoteMessageTotalWeight(vote: String, weight: UInt64) {
            self.uniqueVoteMessageTotalWeights[vote] = weight
        }
    }

    /// `Vote` represents a vote from one collection node.
    /// It simply contains strings with the signed message
    /// the hex encoded message itself. Votes are aggregated to build quorum certificates
    pub struct Vote {

        /// The node ID from the staking contract
        pub var nodeID: String

        /// The signed message from the node (using the nodes `stakingKey`)
        pub(set) var signature: String?

        /// The hex-encoded message for the vote
        pub(set) var message: String?

        /// The index of the cluster that this vote (and node) is in
        pub let clusterIndex: UInt16

        /// The weight of the vote (and node)
        pub let weight: UInt64

        init(nodeID: String, clusterIndex: UInt16, voteWeight: UInt64) {
            pre {
                nodeID.length == 64: "Voter ID must be a valid length node ID"
            }
            self.signature = nil
            self.message = nil
            self.nodeID = nodeID
            self.clusterIndex = clusterIndex
            self.weight = voteWeight
        }
    }

    /// Represents the quorum certificate for a specific cluster
    /// and all the nodes/votes in the cluster
    pub struct ClusterQC {

        /// The index of the qc in the cluster record
        pub let index: UInt16

        /// The vote signatures from all the nodes in the cluster
        pub var voteSignatures: [String]

        /// The vote message from all the valid voters in the cluster
        pub var voteMessage: String

        /// The node IDs that correspond to each vote
        pub var voterIDs: [String]

        init(index: UInt16, signatures: [String], message: String, voterIDs: [String]) {
            self.index = index
            self.voteSignatures = signatures
            self.voteMessage = message
            self.voterIDs = voterIDs
        }

        pub fun addSignature(_ signature: String) {
            self.voteSignatures.append(signature)
        }

        pub fun addVoterID(_ voterID: String) {
            self.voterIDs.append(voterID)
        }
    }

    /// The Voter resource is generated for each collection node after they register.
    /// Each resource instance is good for all future potential epochs, but will
    /// only be valid if the node operator has been confirmed as a collector node for the next epoch.
    pub resource Voter {

        /// The nodeID of the voter (from the staking contract)
        pub let nodeID: String

        /// The staking key of the node (from the staking contract)
        pub var stakingKey: String

        init(nodeID: String, stakingKey: String) {
            pre {
                !FlowClusterQC.voterIsClaimed(nodeID): "Cannot create a Voter resource for a node ID that has already been claimed"
            }

            self.nodeID = nodeID
            self.stakingKey = stakingKey
            FlowClusterQC.voterClaimed[nodeID] = true
        }

        // If the voter resource is destroyed, a new one could potentially be claimed
        destroy () {
            FlowClusterQC.voterClaimed[self.nodeID] = nil
        }

        /// Submits the given vote. Can be called only once per epoch
        ///
        /// Params: voteSignature: Signed `voteMessage` with the nodes `stakingKey`
        ///         voteMessage: Hex-encoded message
        ///
        pub fun vote(voteSignature: String, voteMessage: String) {
            pre {
                FlowClusterQC.inProgress: "Voting phase is not in progress"
                voteSignature.length > 0: "Vote signature must not be empty"
                voteMessage.length > 0: "Vote message must not be empty"
                !FlowClusterQC.nodeHasVoted(self.nodeID): "Vote must not have been cast already"
            }

            // Get the public key object from the stored key
            let publicKey = PublicKey(
                publicKey: self.stakingKey.decodeHex(),
                signatureAlgorithm: SignatureAlgorithm.BLS_BLS12_381
            )

            // Check to see that the signature on the message is valid
            let isValid = publicKey.verify(
                signature: voteSignature.decodeHex(),
                signedData: voteMessage.decodeHex(),
                domainSeparationTag: "FLOW-Collector_Vote-V00-CS00-with-",
                hashAlgorithm: HashAlgorithm.KMAC128_BLS_BLS12_381
            )

            // Assert the validity
            assert (
                isValid,
                message: "Vote Signature cannot be verified"
            )

            // Get the cluster that this node belongs to
            let clusterIndex = FlowClusterQC.nodeCluster[self.nodeID]
                ?? panic("This node cannot vote during the current epoch")
            let cluster = FlowClusterQC.clusters[clusterIndex]!

            // Get this node's allocated vote
            let vote = cluster.getGeneratedVote(nodeId: self.nodeID)!

            // Set the signature and message fields
            vote.signature = voteSignature
            vote.message = voteMessage

            // Set the new total weight for the vote
            let totalWeight = cluster.getUniqueVoteMessageTotalWeight(vote: voteMessage) ?? 0
            var newWeight = totalWeight + vote.weight
            cluster.setUniqueVoteMessageTotalWeight(vote: voteMessage, weight: newWeight)

            // Save the modified vote and cluster back
            cluster.setGeneratedVote(nodeId: self.nodeID, vote: vote)
            FlowClusterQC.clusters[clusterIndex] = cluster
        }

    }

    /// Interface that only contains operations that are part
    /// of the regular automated functioning of the epoch process
    /// These are accessed by the `FlowEpoch` contract through a capability
    pub resource interface EpochOperations {
        pub fun createVoter(nodeID: String, stakingKey: String): @Voter
        pub fun startVoting(clusters: [Cluster])
        pub fun stopVoting()
        pub fun forceStopVoting()
    }

    /// The Admin resource provides the ability to create to Voter resource objects,
    /// begin voting, and end voting for an epoch
    pub resource Admin: EpochOperations {

        /// Creates a new Voter resource for a collection node
        /// This function will be publicly accessible in the FlowEpoch
        /// contract, which will restrict the creation to only collector nodes
        pub fun createVoter(nodeID: String, stakingKey: String): @Voter {
            return <-create Voter(nodeID: nodeID, stakingKey: stakingKey)
        }

        /// Configures the contract for the next epoch's clusters
        ///
        /// NOTE: This will be called by the top-level FlowEpochs contract upon
        /// transitioning to the Epoch Setup Phase.
        ///
        /// CAUTION: calling this erases the votes for the current/previous epoch.
        pub fun startVoting(clusters: [Cluster]) {
            FlowClusterQC.inProgress = true
            FlowClusterQC.clusters = clusters

            var clusterIndex: UInt16 = 0
            for cluster in clusters {

                // Create a new Vote struct for each participating node
                for nodeID in cluster.nodeWeights.keys {
                    cluster.setGeneratedVote(nodeId: nodeID,vote: Vote(nodeID: nodeID, clusterIndex: clusterIndex, voteWeight: cluster.nodeWeights[nodeID]!))
                    FlowClusterQC.nodeCluster[nodeID] = clusterIndex
                }

                FlowClusterQC.clusters[clusterIndex] = cluster
                clusterIndex = clusterIndex + UInt16(1)
            }
        }

        /// Stops voting for the current epoch. Can only be called once a 2/3
        /// majority of each cluster has submitted a vote.
        pub fun stopVoting() {
            pre {
                FlowClusterQC.votingCompleted(): "Voting must be complete before it can be stopped"
            }
            FlowClusterQC.inProgress = false
        }

        /// Force a stop of the voting period
        /// Should only be used if the protocol halts and needs to be reset
        pub fun forceStopVoting() {
            FlowClusterQC.inProgress = false
        }
    }

    /// Returns a boolean telling if the voter is registered for the current voting phase
    pub fun voterIsRegistered(_ nodeID: String): Bool {
        return FlowClusterQC.nodeCluster[nodeID] != nil
    }

    /// Returns a boolean telling if the node has claimed their `Voter` resource object
    /// The object can only be claimed once, but if the node destroys their `Voter` object,
    /// It could be claimed again
    pub fun voterIsClaimed(_ nodeID: String): Bool {
        return FlowClusterQC.voterClaimed[nodeID] != nil
    }

    /// Returns whether this voter has successfully submitted a vote for this epoch.
    pub fun nodeHasVoted(_ nodeID: String): Bool {

        // Get the cluster that this node belongs to
        if let clusterIndex = FlowClusterQC.nodeCluster[nodeID] {
            let cluster = FlowClusterQC.clusters[clusterIndex]

            // If the node is registered for this epoch,
            // check to see if they have voted
            if cluster.nodeWeights[nodeID] != nil {
                return cluster.generatedVotes[nodeID]!.signature != nil
            }
        }

        return false
    }

    /// Gets all of the collector clusters for the current epoch
    pub fun getClusters(): [Cluster] {
        return self.clusters
    }

    /// Returns true if we have collected enough votes for all clusters.
    pub fun votingCompleted(): Bool {
        for cluster in FlowClusterQC.clusters {
            if cluster.isComplete() == nil {
                return false
            }
        }
        return true
    }

    init() {
        self.AdminStoragePath = /storage/flowEpochsQCAdmin
        self.VoterStoragePath = /storage/flowEpochsQCVoter

        self.inProgress = false

        self.clusters = []
        self.voterClaimed = {}
        self.nodeCluster = {}

        self.account.save(<-create Admin(), to: self.AdminStoragePath)
    }
}"
-------
"/*
EventTickets

This is the contract for EventTickets NFTs!

This was implemented using Niftory interfaces. For full details on how this
contract functions, please see the Niftory and NFTRegistry contracts.

*/

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import ViewResolver from 0x1d7e57aa55817448

import MutableMetadata from 0x7ec1f607f0872a9e
import MutableMetadataTemplate from 0x7ec1f607f0872a9e
import MutableMetadataSet from 0x7ec1f607f0872a9e
import MutableMetadataSetManager from 0x7ec1f607f0872a9e
import MetadataViewsManager from 0x7ec1f607f0872a9e

import NiftoryNonFungibleToken from 0x7ec1f607f0872a9e
import NiftoryNFTRegistry from 0x7ec1f607f0872a9e

import NiftoryMetadataViewsResolvers from 0x7ec1f607f0872a9e
import NiftoryNonFungibleTokenProxy from 0x7ec1f607f0872a9e

pub contract EventTickets: NonFungibleToken, ViewResolver {

  // ========================================================================
  // Constants
  // ========================================================================

  // Suggested paths where collection could be stored
  pub let COLLECTION_PRIVATE_PATH: PrivatePath
  pub let COLLECTION_PUBLIC_PATH: PublicPath
  pub let COLLECTION_STORAGE_PATH: StoragePath

  // Accessor token to be used with NiftoryNFTRegistry to retrieve
  // meta-information about this NFT project
  pub let REGISTRY_ADDRESS: Address
  pub let REGISTRY_BRAND: String

  // ========================================================================
  // Attributes
  // ========================================================================

  // Arbitrary metadata for this NFT contract
  pub var metadata: AnyStruct?

  // Number of NFTs created
  pub var totalSupply: UInt64

  // ========================================================================
  // Contract Events
  // ========================================================================

  // This contract was initialized
  pub event ContractInitialized()

  // A withdrawal of NFT `id` has occurred from the `from` Address
  pub event Withdraw(id: UInt64, from: Address?)

  // A deposit of an NFT `id` has occurred to the `to` Address
  pub event Deposit(id: UInt64, to: Address?)

  ///////////////////////////////////////////////////////////////////////////

  // Contract metadata was modified
  pub event ContractMetadataUpdated()

  // Metadata Views Manager was locked
  pub event MetadataViewsManagerLocked()

  // Metadata Views Resolver was added
  pub event MetadataViewsResolverAdded(type: Type)

  // Metadata Views Resolver was removed
  pub event MetadataViewsResolverRemoved(type: Type)

  // Set Manager Name or Description updated
  pub event SetManagerMetadataUpdated()

  // Set added to Set Manager
  pub event SetAddedToSetManager(setID: Int)

  ///////////////////////////////////////////////////////////////////////////

  // Set `setId` was locked (no new templates can be added)
  pub event SetLocked(setId: Int)

  // The metadata for Set `setId` was locked and cannot be modified
  pub event SetMetadataLocked(setId: Int)

  // Set `setId` was modified
  pub event SetMetadataModified(setId: Int)

  // A new Template `templateId` was added to Set `setId`
  pub event TemplateAddedToSet(setId: Int, templateId: Int)

  ///////////////////////////////////////////////////////////////////////////

  // Template `templateId` was locked in Set `setId`, which disables minting
  pub event TemplateLocked(setId: Int, templateId: Int)

  // Template `templateId` of Set `setId` had it's maxMint set to `maxMint`
  pub event TemplateMaxMintSet(setId: Int, templateId: Int, maxMint: UInt64)

  // Template `templateId` of Set `setId` has minted NFT with serial `serial`
  pub event NFTMinted(id: UInt64, setId: Int, templateId: Int, serial: UInt64)

  ///////////////////////////////////////////////////////////////////////////

  // The metadata for NFT/Template `templateId` of Set `setId` was locked
  pub event NFTMetadataLocked(setId: Int, templateId: Int)

  // The metadata for NFT/Template `templateId` of Set `setId` was modified
  pub event NFTMetadataModified(setId: Int, templateId: Int)

  ///////////////////////////////////////////////////////////////////////////

  // NFT `serial` from Template `templateId` of Set `setId` was burned
  pub event NFTBurned(setId: Int, templateId: Int, serial: UInt64)

  // ========================================================================
  // NFT
  // ========================================================================

  pub resource NFT:
    NonFungibleToken.INFT,
    MetadataViews.Resolver,
    NiftoryNonFungibleToken.NFTPublic
  {
    pub let id: UInt64
    pub let setId: Int
    pub let templateId: Int
    pub let serial: UInt64

    pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
      return EventTickets.contract()
    }

    pub fun set(): &MutableMetadataSet.Set{MutableMetadataSet.Public} {
      return self
        .contract()
        .getSetManagerPublic()
        .getSet(self.setId)
    }

    pub fun metadata(): &MutableMetadata.Metadata{MutableMetadata.Public} {
      return self
        .set()
        .getTemplate(self.templateId)
        .metadata()
    }

    pub fun getViews(): [Type] {
      return self
        .contract()
        .getMetadataViewsManagerPublic()
        .getViews()
    }

    pub fun resolveView(_ view: Type): AnyStruct? {
      let nftRef = &self as &{NiftoryNonFungibleToken.NFTPublic}
      return self
        .contract()
        .getMetadataViewsManagerPublic()
        .resolveView(view: view, nftRef: nftRef)
    }

    init(setId: Int, templateId: Int, serial: UInt64) {
      self.id = EventTickets.totalSupply
      EventTickets.totalSupply =
        EventTickets.totalSupply + 1
      self.setId = setId
      self.templateId = templateId
      self.serial = serial
    }

    destroy() {
      emit NFTBurned(
        setId: self.setId,
        templateId: self.templateId,
        serial: self.serial
      )
    }
  }

  // ========================================================================
  // Collection
  // ========================================================================

  pub resource Collection:
    NonFungibleToken.Provider,
    NonFungibleToken.Receiver,
    NonFungibleToken.CollectionPublic,
    MetadataViews.ResolverCollection,
    NiftoryNonFungibleToken.CollectionPublic,
    NiftoryNonFungibleToken.CollectionPrivate
  {
    pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

    pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
      return EventTickets.contract()
    }

    pub fun getIDs(): [UInt64] {
      return self.ownedNFTs.keys
    }

    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
      pre {
        self.ownedNFTs[id] != nil : "NFT "
          .concat(id.toString())
          .concat(" does not exist in collection.")
      }
      return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
    }

    pub fun borrow(id: UInt64): &NFT{NiftoryNonFungibleToken.NFTPublic} {
      pre {
        self.ownedNFTs[id] != nil : "NFT does not exist in collection."
      }
      let nftRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let fullNft = nftRef as! &NFT
      return fullNft
    }

    pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {
      pre {
        self.ownedNFTs[id] != nil : "NFT does not exist in collection."
      }
      let nftRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let fullNft = nftRef as! &NFT
      return fullNft
    }

    pub fun deposit(token: @NonFungibleToken.NFT) {
      let token <- token as! @EventTickets.NFT
      let id: UInt64 = token.id
      let oldToken <- self.ownedNFTs[id] <- token
      emit Deposit(id: id, to: self.owner?.address)
      destroy oldToken
    }

    pub fun depositBulk(tokens: @[NonFungibleToken.NFT]) {
      while tokens.length > 0 {
        let token <- tokens.removeLast() as! @EventTickets.NFT
        self.deposit(token: <-token)
      }
      destroy tokens
    }

    pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
      pre {
        self.ownedNFTs[withdrawID] != nil
          : "NFT "
            .concat(withdrawID.toString())
            .concat(" does not exist in collection.")
      }
      let token <-self.ownedNFTs.remove(key: withdrawID)!
      emit Withdraw(id: token.id, from: self.owner?.address)
      return <-token
    }

    pub fun withdrawBulk(withdrawIDs: [UInt64]): @[NonFungibleToken.NFT] {
      let tokens: @[NonFungibleToken.NFT] <- []
      while withdrawIDs.length > 0 {
        tokens.append(<- self.withdraw(withdrawID: withdrawIDs.removeLast()))
      }
      return <-tokens
    }

    init() {
      self.ownedNFTs <- {}
    }

    destroy() {
      destroy self.ownedNFTs
    }
  }

  pub fun createEmptyCollection(): @Collection {
    return <-create Collection()
  }

  // ========================================================================
  // Manager
  // ========================================================================

  pub resource Manager:
    NiftoryNonFungibleToken.ManagerPublic,
    NiftoryNonFungibleToken.ManagerPrivate
  {
    // ========================================================================
    // Public
    // ========================================================================

    pub fun metadata(): AnyStruct? {
      return EventTickets.metadata
    }

    pub fun getSetManagerPublic():
      &MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public}
    {
      return NiftoryNFTRegistry
        .getSetManagerPublic(
          EventTickets.REGISTRY_ADDRESS,
          EventTickets.REGISTRY_BRAND
        )
    }

    pub fun getMetadataViewsManagerPublic():
      &MetadataViewsManager.Manager{MetadataViewsManager.Public}
    {
      return NiftoryNFTRegistry
        .getMetadataViewsManagerPublic(
          EventTickets.REGISTRY_ADDRESS,
          EventTickets.REGISTRY_BRAND
        )
    }

    pub fun getNFTCollectionData(): MetadataViews.NFTCollectionData {
      return NiftoryNFTRegistry
        .buildNFTCollectionData(
          EventTickets.REGISTRY_ADDRESS,
          EventTickets.REGISTRY_BRAND,
          (fun (): @NonFungibleToken.Collection {
            return <-EventTickets.createEmptyCollection()
          })
        )
    }

    // ========================================================================
    // Contract metadata
    // ========================================================================

    pub fun modifyContractMetadata(): auth &AnyStruct {
      emit ContractMetadataUpdated()
      let maybeMetadata = EventTickets.metadata
      if maybeMetadata == nil {
        let blankMetadata: {String: String} = {}
        EventTickets.metadata = blankMetadata
      }
      return (&EventTickets.metadata as auth &AnyStruct?)!
    }

    pub fun replaceContractMetadata(_ metadata: AnyStruct?) {
      emit ContractMetadataUpdated()
      EventTickets.metadata = metadata
    }

    // ========================================================================
    // Metadata Views Manager
    // ========================================================================

    access(self) fun _getMetadataViewsManagerPrivate():
      &MetadataViewsManager.Manager{MetadataViewsManager.Private}
    {
      let record =
        NiftoryNFTRegistry.getRegistryRecord(
          EventTickets.REGISTRY_ADDRESS,
          EventTickets.REGISTRY_BRAND
        )
      let manager =
        EventTickets.account
          .getCapability<&MetadataViewsManager.Manager{MetadataViewsManager.Private}>(
            record.metadataViewsManager.paths.private
          ).borrow()!
      return manager
    }

    pub fun lockMetadataViewsManager() {
      self._getMetadataViewsManagerPrivate().lock()
      emit MetadataViewsManagerLocked()
    }

    pub fun setMetadataViewsResolver(
      _ resolver: AnyStruct{MetadataViewsManager.Resolver}
    ) {
      self._getMetadataViewsManagerPrivate().addResolver(resolver)
      emit MetadataViewsResolverAdded(type: resolver.type)
    }

    pub fun removeMetadataViewsResolver(_ type: Type) {
      self._getMetadataViewsManagerPrivate().removeResolver(type)
      emit MetadataViewsResolverRemoved(type: type)
    }

    // ========================================================================
    // Set Manager
    // ========================================================================

    access(self) fun _getSetManagerPrivate():
      &MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public, MutableMetadataSetManager.Private}
    {
      let record =
        NiftoryNFTRegistry.getRegistryRecord(
          EventTickets.REGISTRY_ADDRESS,
          EventTickets.REGISTRY_BRAND
        )
      let setManager =
        EventTickets.account
          .getCapability<&MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public, MutableMetadataSetManager.Private}>(
            record.setManager.paths.private
          ).borrow()!
      return setManager
    }

    pub fun setMetadataManagerName(_ name: String) {
      self._getSetManagerPrivate().setName(name)
      emit SetManagerMetadataUpdated()
    }

    pub fun setMetadataManagerDescription(_ description: String) {
      self._getSetManagerPrivate().setDescription(description)
      emit SetManagerMetadataUpdated()
    }

    pub fun addSet(_ set: @MutableMetadataSet.Set) {
      let setManager = self._getSetManagerPrivate()
      let setId = setManager.numSets()
      setManager.addSet(<-set)
      emit SetAddedToSetManager(setID: setId)
    }

    // ========================================================================
    // Set
    // ========================================================================

    access(self) fun _getSetMutable(_ setId: Int):
      &MutableMetadataSet.Set{MutableMetadataSet.Private,
        MutableMetadataSet.Public} {
      return self._getSetManagerPrivate().getSetMutable(setId)
    }

    pub fun lockSet(setId: Int) {
      self._getSetMutable(setId).lock()
      emit SetLocked(setId: setId)
    }

    pub fun lockSetMetadata(setId: Int) {
      self._getSetMutable(setId).metadataMutable().lock()
      emit SetMetadataLocked(setId: setId)
    }

    pub fun modifySetMetadata(setId: Int): auth &AnyStruct {
      emit SetMetadataModified(setId: setId)
      return self._getSetMutable(setId).metadataMutable().getMutable()
    }

    pub fun replaceSetMetadata(setId: Int, new: AnyStruct) {
      self._getSetMutable(setId).metadataMutable().replace(new)
      emit SetMetadataModified(setId: setId)
    }

    pub fun addTemplate(
      setId: Int,
      template: @MutableMetadataTemplate.Template
    ) {
      let set = self._getSetMutable(setId)
      let templateId = set.numTemplates()
      set.addTemplate(<-template)
      emit TemplateAddedToSet(setId: setId, templateId: templateId)
    }

    // ========================================================================
    // Minting
    // ========================================================================

    access(self) fun _getTemplateMutable(_ setId: Int, _ templateId: Int):
      &MutableMetadataTemplate.Template{MutableMetadataTemplate.Public,
        MutableMetadataTemplate.Private} {
      return self._getSetMutable(setId).getTemplateMutable(templateId)
    }

    pub fun lockTemplate(setId: Int, templateId: Int) {
      self._getTemplateMutable(setId, templateId).lock()
      emit TemplateLocked(setId: setId, templateId: templateId)
    }

    pub fun setTemplateMaxMint(setId: Int, templateId: Int, max: UInt64) {
      self._getTemplateMutable(setId, templateId).setMaxMint(max)
      emit TemplateMaxMintSet(
        setId: setId,
        templateId: templateId,
        maxMint: max
      )
    }

    pub fun mint(setId: Int, templateId: Int): @NonFungibleToken.NFT {
      let template = self._getTemplateMutable(setId, templateId)
      template.registerMint()
      let serial = template.minted()
      let nft <-create NFT(
        setId: setId,
        templateId: templateId,
        serial: serial
      )
      emit NFTMinted(
        id: nft.id,
        setId: setId,
        templateId: templateId,
        serial: serial
      )
      return <-nft
    }

    pub fun mintBulk(
      setId: Int,
      templateId: Int,
      numToMint: UInt64,
    ): @[NonFungibleToken.NFT] {
      pre {
        numToMint > 0: "Must mint at least one NFT"
      }
      let template = self._getTemplateMutable(setId, templateId)
      let nfts: @[NonFungibleToken.NFT] <- []
      var leftToMint = numToMint
      while leftToMint > 0 {
        template.registerMint()
        let serial = template.minted()
        let nft <-create NFT(
          setId: setId,
          templateId: templateId,
          serial: serial
        )
        emit NFTMinted(
          id: nft.id,
          setId: setId,
          templateId: templateId,
          serial: serial
        )
        nfts.append(<-nft)
        leftToMint = leftToMint - 1
      }
      return <-nfts
    }

    // ========================================================================
    // NFT metadata
    // ========================================================================

    access(self) fun _getNFTMetadata(_ setId: Int, _ templateId: Int):
      &MutableMetadata.Metadata{MutableMetadata.Public,
        MutableMetadata.Private
      } {
        return self._getTemplateMutable(setId, templateId).metadataMutable()
    }

    pub fun lockNFTMetadata(setId: Int, templateId: Int) {
      self._getNFTMetadata(setId, templateId).lock()
      emit NFTMetadataLocked(setId: setId, templateId: templateId)
    }

    pub fun modifyNFTMetadata(setId: Int, templateId: Int): auth &AnyStruct {
      emit NFTMetadataModified(setId: setId, templateId: templateId)
      return self._getNFTMetadata(setId, templateId).getMutable()
    }

    pub fun replaceNFTMetadata(setId: Int, templateId: Int, new: AnyStruct) {
      self._getNFTMetadata(setId, templateId).replace(new)
      emit NFTMetadataModified(setId: setId, templateId: templateId)
    }
  }

  // ========================================================================
  // Contract functions
  // ========================================================================

  pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
    return NiftoryNFTRegistry
      .getNFTManagerPublic(
        EventTickets.REGISTRY_ADDRESS,
        EventTickets.REGISTRY_BRAND
      )
  }

  pub fun getViews(): [Type] {
    let possibleViews = [
      Type<MetadataViews.NFTCollectionDisplay>(),
      Type<MetadataViews.ExternalURL>()
    ]
    let views: [Type] = [Type<MetadataViews.NFTCollectionData>()]

    let viewManager = self.contract().getMetadataViewsManagerPublic()
    for view in possibleViews {
      if viewManager.inspectView(view: view) != nil {
        views.append(view)
      }
    }
    return views
  }

  pub fun resolveView(_ view: Type): AnyStruct? {
    let viewManager = self.contract().getMetadataViewsManagerPublic()
    switch view {

      case Type<MetadataViews.NFTCollectionData>():
        return self.contract().getNFTCollectionData()

      case Type<MetadataViews.NFTCollectionDisplay>():
        let maybeView = viewManager.inspectView(
          view: Type<MetadataViews.NFTCollectionDisplay>()
        )
        if maybeView == nil {
          return nil
        }
        let view = maybeView!

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver

          // External URL
          let externalURL = MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultExternalURLPrefix,
              uri: resolver.defaultExternalURL
            )
          )

          // Square image
          let squareImageURL = NiftoryMetadataViewsResolvers._prefixUri(
            allowedPrefixes:
              NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
            default: resolver.defaultSquareImagePrefix,
            uri: resolver.defaultSquareImage
          )
          let squareImageMediaType = resolver.defaultSquareImageMediaType
          let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: squareImageURL),
            mediaType: squareImageMediaType
          )

          // Banner image
          let bannerImageURL = NiftoryMetadataViewsResolvers._prefixUri(
            allowedPrefixes:
              NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
            default: resolver.defaultBannerImagePrefix,
            uri: resolver.defaultBannerImage
          )
          let bannerImageMediaType = resolver.defaultBannerImageMediaType
          let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
              url: bannerImageURL
            ),
            mediaType: bannerImageMediaType
          )

          return MetadataViews.NFTCollectionDisplay(
            name: resolver.defaultName,
            description: resolver.defaultDescription,
            externalURL: externalURL,
            squareImage: squareImage,
            bannerImage: bannerImage,
            socials: {}

          )
        }

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolverWithIpfsGateway>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolverWithIpfsGateway

          // External URL
          let externalURL = MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultExternalURLPrefix,
              uri: resolver.defaultExternalURL
            )
          )

          // Square image
          let squareImageURL = NiftoryMetadataViewsResolvers._useIpfsGateway(
            ipfsGateway: resolver.ipfsGateway,
            uri: NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultSquareImagePrefix,
              uri: resolver.defaultSquareImage
            )
        )
          let squareImageMediaType = resolver.defaultSquareImageMediaType
          let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: squareImageURL),
            mediaType: squareImageMediaType
          )

          // Banner image
          let bannerImageURL = NiftoryMetadataViewsResolvers._useIpfsGateway(
            ipfsGateway: resolver.ipfsGateway,
            uri: NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultBannerImagePrefix,
              uri: resolver.defaultBannerImage
            )
          )
          let bannerImageMediaType = resolver.defaultBannerImageMediaType
          let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
              url: bannerImageURL
            ),
            mediaType: bannerImageMediaType
          )

          return MetadataViews.NFTCollectionDisplay(
            name: resolver.defaultName,
            description: resolver.defaultDescription,
            externalURL: externalURL,
            squareImage: squareImage,
            bannerImage: bannerImage,
            socials: {}
          )
        }

        return nil

      case Type<MetadataViews.ExternalURL>():
        let maybeView = viewManager.inspectView(
          view: Type<MetadataViews.ExternalURL>()
        )
        if maybeView == nil {
          return nil
        }
        let view = maybeView!

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.ExternalURLResolver>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.ExternalURLResolver
          return MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultPrefix,
              uri: resolver.defaultURL
            )
          )
        }

        return nil
      }
      return nil

  }

  // ========================================================================
  // Init
  // ========================================================================

  init(
    nftManagerProxy: &{
      NiftoryNonFungibleTokenProxy.Public,
      NiftoryNonFungibleTokenProxy.Private
    }
  ) {

    let record = NiftoryNFTRegistry.generateRecord(
      account: self.account.address,
      project: "clejac4nb0000mn0uhu59tjry_EventTickets"
    )

    self.REGISTRY_ADDRESS = 0x32d62d5c43ad1038
    self.REGISTRY_BRAND = "clejac4nb0000mn0uhu59tjry_EventTickets"

    self.COLLECTION_PUBLIC_PATH = record.collectionPaths.public
    self.COLLECTION_PRIVATE_PATH = record.collectionPaths.private
    self.COLLECTION_STORAGE_PATH = record.collectionPaths.storage

    // No metadata to start with
    self.metadata = nil

    // Initialize the total supply to 0.
    self.totalSupply = 0

    // The Manager for this NFT
    //
    // NFT Manager storage
    let nftManager <- create Manager()

    // Save a MutableSetManager to this contract's storage, as the source of
    // this NFT contract's metadata.
    //
    // MutableMetadataSetManager storage
    self
      .account
      .save<@MutableMetadataSetManager.Manager>(
        <-MutableMetadataSetManager.create(
          name: "EventTickets",
          description: "The set manager for EventTickets."
        ),
        to: record.setManager.paths.storage
      )

    // MutableMetadataSetManager public
    self
      .account
      .link<&MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public}>(
        record.setManager.paths.public,
        target: record.setManager.paths.storage
      )

    // MutableMetadataSetManager private
    self
      .account
      .link<&
        MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public,
        MutableMetadataSetManager.Private
      }>(
        record.setManager.paths.private,
        target: record.setManager.paths.storage
      )

    // Save a MetadataViewsManager to this contract's storage, which will
    // allow observers to inspect standardized metadata through any of its
    // configured MetadataViews resolvers.
    //
    // MetadataViewsManager storage
    self
      .account
      .save<@MetadataViewsManager.Manager>(
        <-MetadataViewsManager.create(),
        to: record.metadataViewsManager.paths.storage
      )

    // MetadataViewsManager public
    self
      .account
      .link<&MetadataViewsManager.Manager{MetadataViewsManager.Public}>(
        record.metadataViewsManager.paths.public,
        target: record.metadataViewsManager.paths.storage
      )

    // MetadataViewsManager private
    self
      .account
      .link<&
        MetadataViewsManager.Manager{MetadataViewsManager.Private,
        MetadataViewsManager.Public
      }>(
        record.metadataViewsManager.paths.private,
        target: record.metadataViewsManager.paths.storage
      )

    let contractName = "EventTickets"

    // Royalties
    let royaltiesResolver = NiftoryMetadataViewsResolvers.RoyaltiesResolver(
        royalties: MetadataViews.Royalties([])
    )
    nftManager.setMetadataViewsResolver(royaltiesResolver)

    // Collection Data
    let collectionDataResolver
        = NiftoryMetadataViewsResolvers.NFTCollectionDataResolver()
    nftManager.setMetadataViewsResolver(collectionDataResolver)

    // Display
    let displayResolver = NiftoryMetadataViewsResolvers.DisplayResolver(
        "title",
        contractName.concat("NFT"),
        "description",
        contractName.concat(" NFT"),
        "mediaUrl",
        "ipfs://",
        "ipfs://bafybeig6la3me5x3veull7jzxmwle4sfuaguou2is3o3z44ayhe7ihlqpa/NiftoryBanner.png"
    )
    nftManager.setMetadataViewsResolver(displayResolver)

    // Collection Display
    let collectionResolver = NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver(
        "title",
        contractName,
        "description",
        contractName.concat(" Collection"),
        "domainUrl",
        "https://",
        "https://niftory.com",
        "squareImage",
        "ipfs://",
        "ipfs://bafybeihc76uodw2at2xi2l5jydpvscj5ophfpqgblbrmsfpeffhcmgdtl4/squareImage.png",
        "squareImageMediaType",
        "image/png",
        "bannerImage",
        "ipfs://",
        "ipfs://bafybeig6la3me5x3veull7jzxmwle4sfuaguou2is3o3z44ayhe7ihlqpa/NiftoryBanner.png",
        "bannerImageMediaType",
        "image/png",
        []
    )
    nftManager.setMetadataViewsResolver(collectionResolver)

    // ExternalURL
    let externalURLResolver = NiftoryMetadataViewsResolvers.ExternalURLResolver(
        "domainUrl",
        "https://",
        "https://niftory.com"
    )
    nftManager.setMetadataViewsResolver(externalURLResolver)

    // Save NFT Manager
    self
      .account
      .save<@Manager>(
        <-nftManager,
        to: record.nftManager.paths.storage
      )

    // NFT Manager public
    self
      .account
      .link<&{NiftoryNonFungibleToken.ManagerPublic}>(
        record.nftManager.paths.public,
        target: record.nftManager.paths.storage
      )

    // NFT Manager private
    self
      .account
      .link<&
        Manager{NiftoryNonFungibleToken.ManagerPublic,
        NiftoryNonFungibleToken.ManagerPrivate
      }>(
        record.nftManager.paths.private,
        target: record.nftManager.paths.storage
      )

      nftManagerProxy.add(
        registryAddress: self.REGISTRY_ADDRESS,
        brand: self.REGISTRY_BRAND,
        cap: self.account
              .getCapability<&{
                NiftoryNonFungibleToken.ManagerPrivate,
                NiftoryNonFungibleToken.ManagerPublic
              }>(
                record.nftManager.paths.private
              )
      )
  }
}"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448

pub contract Swap {

    // Swap fee: 2.5%
    pub fun Fee(): UFix64 {
        return 0.025
    }

    // Swap fee receiver address
    pub fun FeeAddress(): Address {
        return 0x3896d4b8f0636f6d
    }

    // An order has been created
    pub event OrderCreated(
        orderID: UInt64,
        address: Address,
        nftType: Type,
        nftUUID: UInt64,
        nftID: UInt64,
        currency: Type,
        price: UFix64,
        expiry: UInt64
    )

    // An order has been canceled
    pub event OrderCanceled(
        orderID: UInt64,
        nftType: Type,
        nftUUID: UInt64,
        nftID: UInt64,
        currency: Type,
        price: UFix64,
        expiry: UInt64
    )

    // An order has been filled
    pub event OrderFilled(
        orderID: UInt64,
        nftType: Type,
        nftUUID: UInt64,
        nftID: UInt64,
        currency: Type,
        price: UFix64,
        expiry: UInt64
    )

    // The storage location of the Swap resource
    pub let SwapStoragePath: StoragePath

    // The public location of the Swap link
    pub let SwapPublicPath: PublicPath

    // A struct representing a payment that must be sent when an order is executed
    pub struct Payment {
        // The receiver for the payment of a sell order
        pub let receiver: Capability<&{FungibleToken.Receiver}>

        // The amount of the FungibleToken that will be paid
        pub let amount: UFix64

        init(receiver: Capability<&{FungibleToken.Receiver}>, amount: UFix64) {
            self.receiver = receiver
            self.amount = amount
        }
    }

    // A struct containing an order's data
    pub struct OrderDetails {
        // Whether this order has been filled or not
        pub var filled: Bool
        // The Type of the NonFungibleToken.NFT
        pub let nftType: Type
        // The Resource ID of the NFT
        pub let nftUUID: UInt64
        // The unique identifier of the NFT in the contract
        pub let nftID: UInt64
        // The Type of the FungibleToken that payments must be made in
        pub let currency: Type
        // The amount that must be paid in the specified FungibleToken
        pub let price: UFix64
        // This specifies the division of payment between recipients
        pub let payments: [Payment]
        // This specifies the division of royalties between recipients
        pub let royalties: [Payment]
        // This specifies the division of fees between recipients
        pub let fees: [Payment]
        // Time when order expires
        pub let expiry: UInt64

        // Set an order to filled so it can't be executed again
        access(contract) fun setToFilled() {
            self.filled = true
        }

        init (
            nftType: Type,
            nftUUID: UInt64,
            nftID: UInt64,
            currency: Type,
            payments: [Payment],
            royalties: [Payment],
            fees: [Payment],
            expiry: UInt64
        ) {

            pre {
                // Validate the UUID and ID when sell order
                nftUUID != nil && nftID != nil: "sell orders require the UUID and ID of the NFT"

                // Validate the expiry timestamp
                expiry > UInt64(getCurrentBlock().timestamp) : "expiry should be in the future"

                // Validate the existance of at least one payment recipient when sell order
                payments.length > 0: "sell orders must have at least one payment recipient"
            }

            self.filled = false
            self.nftType = nftType
            self.nftUUID = nftUUID
            self.nftID = nftID
            self.currency = currency
            self.payments = payments
            self.royalties = royalties
            self.fees = fees
            self.expiry = expiry

            var price = 0.0
            for payment in self.payments {
                payment.receiver.borrow() ?? panic("cannot borrow payment receiver")
                price = price + payment.amount
            }
            assert(price > 0.0, message: "item price must not be 0")
            let priceBeforeFees = price

            var totalFeeAmount = 0.0
            for fee in self.fees {
                totalFeeAmount = totalFeeAmount + fee.amount
                price = price + fee.amount
            }

            // Add the royalties
            var totalRoyalties = 0.0
            for royalty in self.royalties {
                royalty.receiver.borrow() ?? panic("cannot borrow royalty receiver")
                price = price + royalty.amount
                totalRoyalties = totalRoyalties + royalty.amount
            }

            assert(totalFeeAmount/(priceBeforeFees+totalFeeAmount+totalRoyalties) >= Swap.Fee(), message: "fee is lower than required fee")
            assert(totalRoyalties/(priceBeforeFees+totalFeeAmount+totalRoyalties) <= 0.1, message: "royalties are over 10%")

            self.price = price
        }
    }

    // An interface providing a public interface to an Order.
    pub resource interface OrderPublic {

        pub fun borrowNFT(): &NonFungibleToken.NFT?

        // Get the token in exchange of the currency vault
        pub fun fill(
            payment: @FungibleToken.Vault,
        ): @NonFungibleToken.NFT

        // Get the details of an Order
        pub fun getDetails(): OrderDetails

        // For a sell Order, checks whether the NFT is present in provided capability
        // `false` means the NFT was transfered out of the account
        pub fun isValid(): Bool
    }

    // A resource that allows an NFT to be sold for an amount of a given FungibleToken,
    // and for the proceeds of that sale to be split between several recipients.
    pub resource Order: OrderPublic {
        // The details of the Order
        access(self) let details: OrderDetails

        // A capability allowing this resource to withdraw any NFT with the given ID from its collection.
        access(contract) let nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>

        // Return the reference of the NFT that is for sale.
        // If the NFT is absent, it will return nil.
        pub fun borrowNFT(): &NonFungibleToken.NFT? {
            // Sell orders require the NFT type and ID
            let ref = self.nftProviderCapability.borrow()!.borrowNFT(id: self.details.nftID)
            if ref.isInstance(self.details.nftType) && ref.id == self.details.nftID {
                return ref as! &NonFungibleToken.NFT
            }
            return nil
        }

        // Get the details of an order.
        pub fun getDetails(): OrderDetails {
            return self.details
        }

        // For a sell Order, checks whether the NFT is present in provided capability
        // `false` means the NFT was transfered out of the account
        pub fun isValid(): Bool {
            if let providerRef = self.nftProviderCapability.borrow() {
                let availableIDs = providerRef.getIDs()
                return availableIDs.contains(self.details.nftID)
            }
            return false
        }

        // Fill the order
        // Send payments and returns the token to the buyer
        pub fun fill(
            payment: @FungibleToken.Vault,
        ): @NonFungibleToken.NFT {

            pre {
                self.details.filled == false: "order has already been filled"
                payment.isInstance(self.details.currency): "payment is not in required currency"
                payment.balance == self.details.price: "payment price is different"
                self.details.expiry > UInt64(getCurrentBlock().timestamp): "order is expired"
                self.owner != nil : "resource doesn't have the assigned owner"
            }

            // Make sure the order cannot be filled again
            self.details.setToFilled()

            // Fetch the token to return to the buyer
            let nft <-self.nftProviderCapability.borrow()!.withdraw(withdrawID: self.details.nftID)

            // Check if the withdrawn NFT has the specified Type and ID
            assert(nft.isInstance(self.details.nftType), message: "withdrawn NFT is not of specified type")
            assert(nft.id == self.details.nftID, message: "withdrawn NFT does not have specified ID")

            // Rather than aborting the transaction if any receiver is absent when we try to pay it,
            // we send the payment to the first valid receiver, which should be the seller.
            var residualReceiver: &{FungibleToken.Receiver}? = nil

            // Pay each beneficiary their amount of the payment
            // Set the first valid receiver as the residual receiver
            for p in self.details.payments {
                if let receiver = p.receiver.borrow() {
                   let vault <- payment.withdraw(amount: p.amount)
                    receiver.deposit(from: <-vault)
                    if (residualReceiver == nil) {
                        residualReceiver = receiver
                    }
                }
            }

            // Pay royalties
            for r in self.details.royalties {
                if let receiver = r.receiver.borrow() {
                   let vault <- payment.withdraw(amount: r.amount)
                    receiver.deposit(from: <-vault)
                }
            }

            // Pay fees to the fee receiver defined in the contract
            let feeAddress = Swap.FeeAddress()
            let feeReceiver = getAccount(feeAddress).getCapability<&AnyResource{FungibleToken.Receiver}>(/public/flowTokenReceiver)
            for f in self.details.fees {
                if let receiver = feeReceiver.borrow() {
                   let vault <- payment.withdraw(amount: f.amount)
                    receiver.deposit(from: <-vault)
                }
            }

            // At least one receiver was valid and paid
            assert(residualReceiver != nil, message: "no valid payment receivers")

            // At this point, if all receivers were valid, then the payment Vault will have
            // zero tokens left, and this will be a no-op that consumes the empty vault
            // otherwise the remaining payment will be deposited to the residual receiver
            residualReceiver!.deposit(from: <-payment)

            emit OrderFilled(
                orderID: self.uuid,
                nftType: self.details.nftType,
                nftUUID: self.details.nftUUID,
                nftID: self.details.nftID,
                currency: self.details.currency,
                price: self.details.price,
                expiry: self.details.expiry
            )

            return <-nft
        }

        destroy () {
            if !self.details.filled {
                emit OrderCanceled(
                    orderID: self.uuid,
                    nftType: self.details.nftType,
                    nftUUID: self.details.nftUUID,
                    nftID: self.details.nftID,
                    currency: self.details.currency,
                    price: self.details.price,
                    expiry: self.details.expiry
                )
            }
        }

        init (
            nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,
            nftType: Type,
            nftUUID: UInt64,
            nftID: UInt64,
            currency: Type,
            payments: [Payment],
            royalties: [Payment],
            fees: [Payment],
            expiry: UInt64
        ) {
            // Store the order instructions
            self.details = OrderDetails(
                nftType: nftType,
                nftUUID: nftUUID,
                nftID: nftID,
                currency: currency,
                payments: payments,
                royalties: royalties,
                fees: fees,
                expiry: expiry
            )

            // Store the NFT provider
            self.nftProviderCapability = nftProviderCapability


            // Check that the provider has the NFT
            let provider = self.nftProviderCapability.borrow()
            assert(provider != nil, message: "cannot borrow nftProviderCapability")

            let nft = provider!.borrowNFT(id: self.details.nftID)
            assert(nft.isInstance(self.details.nftType), message: "token is not of specified type")
            assert(nft.id == self.details.nftID, message: "token does not have specified ID")
        }
    }

    // An interface for adding and removing orders
    pub resource interface PortfolioManager {

        // Allows the portfolio owner to create a sell order
        pub fun createSellOrder(
            nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,
            nftType: Type,
            nftID: UInt64,
            currency: Type,
            payments: [Payment],
            royalties: [Payment],
            fees: [Payment],
            expiry: UInt64
        ): UInt64

        // Allows the portfolio owner to cancel any orders, filled or not
        pub fun cancelOrder(orderID: UInt64)
    }


    // An interface to allow order filling
    pub resource interface PortfolioPublic {
        pub fun getOrderIDs(): [UInt64]
        pub fun getSellOrderIDs(nftType: Type, nftID: UInt64): [UInt64]
        pub fun borrowOrder(orderID: UInt64): &Order{OrderPublic}?
        pub fun clean(orderID: UInt64)
   }

    // A resource that allows its owner to manage a portfolio, and anyone to interact with them
    // in order to query their details and fill the NFTs that they represent.
    pub resource Portfolio : PortfolioManager, PortfolioPublic {
        // The dictionary of orders uuids to order resources.
        access(contract) var orders: @{UInt64: Order}
        // Dictionary to keep track of sell order ids for an NFT
        // nftType.identifier -> nftID -> orderID
        access(contract) var sellOrders: {String: {UInt64 : UInt64}}
        // Create and publish a sell order for an NFT
         pub fun createSellOrder(
            nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,
            nftType: Type,
            nftID: UInt64,
            currency: Type,
            payments: [Payment],
            royalties: [Payment],
            fees: [Payment],
            expiry: UInt64
         ): UInt64 {

            // Check that the seller does indeed hold the NFT
            let collectionRef = nftProviderCapability.borrow()
                ?? panic("Could not borrow reference to collection")
            let nftRef = collectionRef.borrowNFT(id: nftID)

            let uuid = nftRef.uuid
            let order <- create Order(
                nftProviderCapability: nftProviderCapability,
                nftType: nftType,
                nftUUID: uuid,
                nftID: nftID,
                currency: currency,
                payments: payments,
                royalties: royalties,
                fees: fees,
                expiry: expiry
            )

            let orderID = order.uuid
            let price = order.getDetails().price

            // Add the new order to the dictionary.
            let oldOrder <- self.orders[orderID] <- order

            // Note that oldOrder will always be nil, but we have to handle it.
            destroy oldOrder

            // Add the `orderID` in the tracked sell orders and remove any previous sell order for the same nft
            if self.sellOrders.containsKey(nftType.identifier) {
                if self.sellOrders[nftType.identifier]!.containsKey(nftID) {
                    let previousOrderID = self.sellOrders[nftType.identifier]![nftID]!
                    self.cancelOrder(orderID: previousOrderID)
                }
            }
            self.addSellOrder(nftIdentifier: nftType.identifier, nftID: nftID, orderID: orderID)

            emit OrderCreated(
                orderID: orderID,
                address: self.owner?.address!,
                nftType: nftType,
                nftUUID: uuid,
                nftID: nftID,
                currency: currency,
                price: price,
                expiry: expiry
            )

            return orderID
        }

        // Helper function that allows to add a sell order for a given nft in a map
        access(contract) fun addSellOrder(nftIdentifier: String, nftID: UInt64, orderID: UInt64) {
             if !self.sellOrders.containsKey(nftIdentifier) {
                self.sellOrders.insert(key: nftIdentifier, {nftID: orderID})
            } else {
                if !self.sellOrders[nftIdentifier]!.containsKey(nftID) {
                    self.sellOrders[nftIdentifier]!.insert(key: nftID, orderID)
                } else {
                    self.sellOrders[nftIdentifier]!.remove(key: nftID)
                    self.sellOrders[nftIdentifier]!.insert(key: nftID, orderID)
                }
            }
        }

        // Helper function that allows to remove existing sell orders of given nft from a map
        access(contract) fun removeSellOrder(nftIdentifier: String, nftID: UInt64, orderID: UInt64) {
            if self.sellOrders.containsKey(nftIdentifier) {
                if self.sellOrders[nftIdentifier]!.containsKey(nftID) {
                    if self.sellOrders[nftIdentifier]![nftID]! == orderID {
                        self.sellOrders[nftIdentifier]!.remove(key: nftID)
                    }
                }
            }
        }

        // Remove an order that has not yet been filled and destroy it.
        // It can only be executed by the PortfolioManager resource owner.
        pub fun cancelOrder(orderID: UInt64) {
            let order <- self.orders.remove(key: orderID)
                ?? panic("missing Order")

            let details = order.getDetails()
            self.removeSellOrder(nftIdentifier: details.nftType.identifier, nftID: details.nftID, orderID: orderID)

            // This will emit an OrderCanceled event.
            destroy order
        }

        // Returns an array of all the orderIDs that are in the collection
        pub fun getOrderIDs(): [UInt64] {
            return self.orders.keys
        }

        // Returns the sell orderID of the given `nftType` and `nftID`
        pub fun getSellOrderIDs(nftType: Type, nftID: UInt64): [UInt64] {
            if self.sellOrders.containsKey(nftType.identifier) {
                if self.sellOrders[nftType.identifier]!.containsKey(nftID) {
                    return [self.sellOrders[nftType.identifier]![nftID]!]
                }
            }
            return []
        }

        // Allows anyone to clean filled or invalid orders
        pub fun clean(orderID: UInt64) {
            pre {
                self.orders[orderID] != nil: "could not find order with given id"
                (self.borrowOrder(orderID: orderID)!.getDetails().filled == true || self.borrowOrder(orderID: orderID)!.getDetails().expiry <= UInt64(getCurrentBlock().timestamp)): "order not filled or expired"
            }

            let orderRef = self.borrowOrder(orderID: orderID)!
            let details = orderRef.getDetails()

            var shouldClean = false
            if details.expiry <= UInt64(getCurrentBlock().timestamp) {
                // Order is expired and should be cleaned
                shouldClean = true
            } else {
                if details.filled == true {
                    // Order was filled and should be cleaned
                     shouldClean = true
                } else {
                    if !orderRef.isValid() {
                        // Order does not have NFT and should be cleaned
                        shouldClean = true
                    }
                }
            }

            assert(shouldClean, message: "given order is valid")

            let order <- self.orders.remove(key: orderID)!
            self.removeSellOrder(nftIdentifier: details.nftType.identifier, nftID: details.nftID, orderID: orderID)

            destroy order
        }

        // Returns a read-only view of the order
        pub fun borrowOrder(orderID: UInt64): &Order{OrderPublic}? {
             if self.orders[orderID] != nil {
                return &self.orders[orderID] as &Order{OrderPublic}?
            } else {
                return nil
            }
        }

        destroy () {
            destroy self.orders
        }

        init () {
            self.orders <- {}
            self.sellOrders = {}
        }
    }

    // Make creating a Portfolio publicly accessible
    pub fun createPortfolio(): @Portfolio {
        return <-create Portfolio()
    }

    init () {
        self.SwapStoragePath = /storage/Swap
        self.SwapPublicPath = /public/Swap
    }
}
 "
-------
"pub contract AFLMetadataHelper {

    access(contract) let metadataByTemplateId: {UInt64: {String: String}}

    pub let AdminStoragePath: StoragePath

    pub fun getMetadataForTemplate(id: UInt64): {String: String} {
        if (self.metadataByTemplateId[id] == nil) {
            return {}
        }
        return self.metadataByTemplateId[id]!
    }

    pub resource Admin {
        pub fun updateMetadataForTemplate(id: UInt64, metadata: {String: String}) {
            if (AFLMetadataHelper.metadataByTemplateId[id] == nil) {
                AFLMetadataHelper.metadataByTemplateId[id] = {}
            }
            AFLMetadataHelper.metadataByTemplateId[id] = metadata
        }

        pub fun addMetadataToTemplate(id: UInt64, key: String, value: String) {
            if (AFLMetadataHelper.metadataByTemplateId[id] == nil) {
                AFLMetadataHelper.metadataByTemplateId[id] = {}
            }
            let templateRef = &AFLMetadataHelper.metadataByTemplateId[id]! as &{String:String}
            templateRef[key] = value
        }

        pub fun removeMetadataFromTemplate(id: UInt64, key: String) {
            let templateRef = &AFLMetadataHelper.metadataByTemplateId[id]! as &{String:String}
            templateRef[key] = nil
        }

        pub fun removeAllExtendedMetadataFromTemplate(id: UInt64) {
            AFLMetadataHelper.metadataByTemplateId[id] = {}
        }
    }

    init() {
        self.AdminStoragePath = /storage/AFLMetadataHelperAdmin
        self.metadataByTemplateId = {}
        let admin <- create Admin()
        self.account.save(<- admin, to: self.AdminStoragePath)
    }
}"
-------
"/**

# The Comptroller contract of LendingPools.

# Author: Increment Labs

The Comptroller contract manages market parameters and provides safety auditing before actions being applied to LendingPools.

*/
import LendingInterfaces from 0x2df970b6cdee5735
import LendingConfig from 0x2df970b6cdee5735
import LendingError from 0x2df970b6cdee5735

pub contract LendingComptroller {
    /// Account address LendingComptroller contract is deployed to, i.e. 'the contract address'
    pub let comptrollerAddress: Address

    /// The storage path for the Admin resource
    pub let AdminStoragePath: StoragePath
    /// The storage path for the Comptroller resource
    pub let ComptrollerStoragePath: StoragePath
    pub let ComptrollerPublicPath: PublicPath
    /// The private path for the capability to Comptroller resource for admin functions
    pub let ComptrollerPrivatePath: PrivatePath
    /// Reserved parameter fields: {ParamName: Value}
    access(self) let _reservedFields: {String: AnyStruct}

    /// events
    pub event MarketAdded(market: Address, marketType: String, liquidationPenalty: UFix64, collateralFactor: UFix64)
    pub event NewOracle(_ oldOracleAddress: Address?, _ newOracleAddress: Address)
    pub event NewCloseFactor(_ oldCloseFactor: UFix64, _ newCloseFactor: UFix64)
    pub event ConfigMarketParameters(
        market: Address,
        oldIsOpen: Bool?, newIsOpen: Bool?,
        oldIsMining: Bool?, newIsMining: Bool?,
        oldLiquidationPenalty: UFix64?, newLiquidationPenalty: UFix64?,
        oldCollateralFactor: UFix64?, newCollateralFactor: UFix64?,
        oldBorrowCap: UFix64?, newBorrowCap: UFix64?,
        oldSupplyCap: UFix64?, newSupplyCap: UFix64?
    )

    /// Market
    ///
    pub struct Market {
        /// Contains functions to query public market data
        pub let poolPublicCap: Capability<&{LendingInterfaces.PoolPublic}>
        /// Whether market open
        pub var isOpen: Bool
        /// Whether or not liquidity mining is enabled for this market
        pub var isMining: Bool
        /// When liquidation happenes, liquidators repay part of the borrowed amount on behalf of the borrower,
        /// and in return they receive corresponding amount of collateral with an additional incentive.
        /// It's an incentive for the liquidator but a penalty for the liquidated borrower.
        /// Must be in [0.0, 1.0] x scaleFactor
        pub var scaledLiquidationPenalty: UInt256
        /// The most one can borrow against his collateral in this market
        /// Must be in [0.0, 1.0] x scaleFactor
        pub var scaledCollateralFactor: UInt256
        /// maximum totalBorrows this market can reach.
        /// Any borrow request that makes totalBorrows greater than borrowCap would be rejected
        /// Note: value of 0 represents unlimited cap when market.isOpen is set
        pub var scaledBorrowCap: UInt256
        /// maximum Supply amount this market can reach.
        /// Note: value of 0 represents unlimited cap when market.isOpen is set
        pub var scaledSupplyCap: UInt256
        /// Reserved parameter fields: {ParamName: Value}
        access(self) let _reservedFields: {String: AnyStruct}


        pub fun setMarketStatus(isOpen: Bool) {
            if (self.isOpen != isOpen) {
                self.isOpen = isOpen
            }
        }

        pub fun setMiningStatus(isMining: Bool) {
            if (self.isMining != isMining) {
                self.isMining = isMining
            }
        }

        pub fun setLiquidationPenalty(newLiquidationPenalty: UFix64) {
            pre {
                newLiquidationPenalty <= 1.0: LendingError.ErrorEncode(msg: "newLiquidationPenalty out of range 1.0", err: LendingError.ErrorCode.INVALID_PARAMETERS)
            }
            let scaledNewLiquidationPenalty = LendingConfig.UFix64ToScaledUInt256(newLiquidationPenalty)
            if (self.scaledLiquidationPenalty != scaledNewLiquidationPenalty) {
                self.scaledLiquidationPenalty = scaledNewLiquidationPenalty
            }
        }

        pub fun setCollateralFactor(newCollateralFactor: UFix64) {
            pre {
                newCollateralFactor <= 1.0: LendingError.ErrorEncode(msg: "newCollateralFactor out of range 1.0", err: LendingError.ErrorCode.INVALID_PARAMETERS)
            }
            let scaledNewCollateralFactor = LendingConfig.UFix64ToScaledUInt256(newCollateralFactor)
            if (self.scaledCollateralFactor != scaledNewCollateralFactor) {
                self.scaledCollateralFactor = scaledNewCollateralFactor
            }
        }

        pub fun setBorrowCap(newBorrowCap: UFix64) {
            let scaledNewBorrowCap = LendingConfig.UFix64ToScaledUInt256(newBorrowCap)
            if (self.scaledBorrowCap != scaledNewBorrowCap) {
                self.scaledBorrowCap = scaledNewBorrowCap
            }
        }

        pub fun setSupplyCap(newSupplyCap: UFix64) {
            let scaledNewSupplyCap = LendingConfig.UFix64ToScaledUInt256(newSupplyCap)
            if (self.scaledSupplyCap != scaledNewSupplyCap) {
                self.scaledSupplyCap = scaledNewSupplyCap
            }
        }

        init(
            poolPublicCap: Capability<&{LendingInterfaces.PoolPublic}>,
            isOpen: Bool,
            isMining: Bool,
            liquidationPenalty: UFix64,
            collateralFactor: UFix64,
            borrowCap: UFix64,
            supplyCap: UFix64
        ) {
            pre {
                collateralFactor <= 1.0: LendingError.ErrorEncode(msg: "collateralFactor out of range 1.0", err: LendingError.ErrorCode.INVALID_PARAMETERS)
                liquidationPenalty <= 1.0: LendingError.ErrorEncode(msg: "liquidationPenalty out of range 1.0", err: LendingError.ErrorCode.INVALID_PARAMETERS)
            }
            self.poolPublicCap = poolPublicCap
            self.isOpen = isOpen
            self.isMining = isMining
            self.scaledLiquidationPenalty = LendingConfig.UFix64ToScaledUInt256(liquidationPenalty)
            self.scaledCollateralFactor = LendingConfig.UFix64ToScaledUInt256(collateralFactor)
            self.scaledBorrowCap = LendingConfig.UFix64ToScaledUInt256(borrowCap)
            self.scaledSupplyCap = LendingConfig.UFix64ToScaledUInt256(supplyCap)
            self._reservedFields = {}
        }
    }

    /// UserCertificate
    ///
    /// This certificate identifies account address and needs to be stored in storage path locally.
    /// User should keep it safe and never give this resource's capability to others
    /// It is more convenient to use a resource certificate on flow for authentication than signing a signature.
    ///
    pub resource UserCertificate: LendingInterfaces.IdentityCertificate {}

    /// Anyone can apply for a user certificate
    ///
    pub fun IssueUserCertificate(): @UserCertificate {
        return <- create UserCertificate()
    }

    /// Comptroller
    ///
    pub resource Comptroller: LendingInterfaces.ComptrollerPublic {
        /// Oracle cap
        access(self) var oracleCap: Capability<&{LendingInterfaces.OraclePublic}>?
        /// Multiplier used to calculate the maximum repayAmount when liquidating a borrow. [0.0, 1.0] x scaleFactor
        access(self) var scaledCloseFactor: UInt256
        /// { poolAddress => Market States }
        access(self) let markets: {Address: Market}
        /// { accountAddress => markets the account has either provided liquidity to or borrowed from }
        access(self) let accountMarketsIn: {Address: [Address]}
        /// Reserved parameter fields: {ParamName: Value}
        access(self) let _reservedFields: {String: AnyStruct}

        /// Supply audit
        ///
        /// @Param poolCertificate - Can only be called by one of the valid LendPools
        /// @Param poolAddress - Caller address
        /// @Param supplierAddress - The address of supply
        /// @Param supplyUnderlyingAmountScaled - Supply amount scaled by 1e18
        /// @Return error code
        ///
        pub fun supplyAllowed(
            poolCertificate: @{LendingInterfaces.IdentityCertificate},
            poolAddress: Address,
            supplierAddress: Address,
            supplyUnderlyingAmountScaled: UInt256
        ): String? {
            let err = self.callerAllowed(callerCertificate: <- poolCertificate, callerAddress: poolAddress)
            if (err != nil) {
                return err
            }

            // Supply limit check if not unlimited supplyCap
            let market = self.markets[poolAddress]!
            let scaledSupplyCap = market.scaledSupplyCap
            let poolRef = market.poolPublicCap.borrow()!

            if (scaledSupplyCap != 0) {
                let scaledTotalSupplyNew = supplyUnderlyingAmountScaled + poolRef.getPoolCash() + poolRef.getPoolTotalBorrowsScaled()

                if (scaledTotalSupplyNew > scaledSupplyCap) {
                    return LendingError.ErrorEncode(msg: "supply too much, exceed market supplyCap", err: LendingError.ErrorCode.SUPPLY_NOT_ALLOWED_EXCEED_SUPPLY_CAP)
                }
            }

            // Add to user markets list
            if (self.accountMarketsIn.containsKey(supplierAddress) == false) {
                self.accountMarketsIn[supplierAddress] = [poolAddress]
            } else if (self.accountMarketsIn[supplierAddress]!.contains(poolAddress) == false) {
                self.accountMarketsIn[supplierAddress]!.append(poolAddress)
            }

            return nil
        }

        /// Redeem audit
        ///
        /// @Param poolCertificate - Can only be called by one of the valid LendPools
        /// @Param poolAddress - Caller address
        /// @Param redeemerAddress - The address of redeemer
        /// @Param redeemLpTokenAmountScaled - Redeem amount scaled by 1e18
        /// @Return error code
        ///
        /// Since borrower would decrease his overall collateral ratio across all markets, safety check is important.
        ///
        pub fun redeemAllowed(
            poolCertificate: @{LendingInterfaces.IdentityCertificate},
            poolAddress: Address,
            redeemerAddress: Address,
            redeemLpTokenAmountScaled: UInt256
        ): String? {
            let err = self.callerAllowed(callerCertificate: <- poolCertificate, callerAddress: poolAddress)
            if (err != nil) {
                return err
            }

            // Hypothetical account liquidity check if virtual lpToken was redeemed
            // liquidity[0] - cross-market collateral value
            // liquidity[1] - cross-market borrow value
            // liquidity[2] - cross-market supply value
            let scaledLiquidity: [UInt256;3] = self.getHypotheticalAccountLiquidity(
                account: redeemerAddress,
                poolToModify: poolAddress,
                scaledAmountLPTokenToRedeem: redeemLpTokenAmountScaled,
                scaledAmountUnderlyingToBorrow: 0
            )
            if (scaledLiquidity[1] > scaledLiquidity[0]) {
                return LendingError.ErrorEncode(msg: "redeem too much", err: LendingError.ErrorCode.REDEEM_NOT_ALLOWED_POSITION_UNDER_WATER)
            }

            // Remove pool out of user markets list if necessary
            self.removePoolFromAccountMarketsOnCondition(
                poolAddress: poolAddress,
                account: redeemerAddress,
                scaledRedeemOrRepayAmount: redeemLpTokenAmountScaled
            )

            return nil
        }

        /// Borrow audit
        ///
        /// @Param poolCertificate - Can only be called by one of the valid LendPools
        /// @Param poolAddress - Caller address
        /// @Param borrowerAddress - The address of borrower
        /// @Param borrowUnderlyingAmountScaled - Borrow amount scaled by 1e18
        /// @Return error code
        ///
        pub fun borrowAllowed(
            poolCertificate: @{LendingInterfaces.IdentityCertificate},
            poolAddress: Address,
            borrowerAddress: Address,
            borrowUnderlyingAmountScaled: UInt256
        ): String? {
            let err = self.callerAllowed(callerCertificate: <- poolCertificate, callerAddress: poolAddress)
            if (err != nil) {
                return err
            }

            // 1. totalBorrows limit check if not unlimited borrowCap
            let scaledBorrowCap = self.markets[poolAddress]!.scaledBorrowCap
            if (scaledBorrowCap != 0) {
                let scaledTotalBorrowsNew = self.markets[poolAddress]!.poolPublicCap.borrow()!.getPoolTotalBorrowsScaled() + borrowUnderlyingAmountScaled
                if (scaledTotalBorrowsNew > scaledBorrowCap) {
                    return LendingError.ErrorEncode(msg: "borrow too much, exceed market borrowCap", err: LendingError.ErrorCode.BORROW_NOT_ALLOWED_EXCEED_BORROW_CAP)
                }
            }

            // 2. Add to user markets list
            if (self.accountMarketsIn.containsKey(borrowerAddress) == false) {
                self.accountMarketsIn[borrowerAddress] = [poolAddress]
            } else if (self.accountMarketsIn[borrowerAddress]!.contains(poolAddress) == false) {
                self.accountMarketsIn[borrowerAddress]!.append(poolAddress)
            }

            // 3. Hypothetical account liquidity check after underlying was borrowed
            // liquidity[0] - cross-market collateral value
            // liquidity[1] - cross-market borrow value
            // liquidity[2] - cross-market supply value
            let scaledLiquidity: [UInt256; 3] = self.getHypotheticalAccountLiquidity(
                account: borrowerAddress,
                poolToModify: poolAddress,
                scaledAmountLPTokenToRedeem: 0,
                scaledAmountUnderlyingToBorrow: borrowUnderlyingAmountScaled
            )
            if (scaledLiquidity[1] > scaledLiquidity[0]) {
                return LendingError.ErrorEncode(msg: "borrow too much, more than collaterized position value", err: LendingError.ErrorCode.BORROW_NOT_ALLOWED_POSITION_UNDER_WATER)
            }

            return nil
        }

        /// Repay audit
        ///
        /// @Param poolCertificate - Can only be called by one of the valid LendPools
        /// @Param poolAddress - Caller address
        /// @Param borrowerAddress - The address of borrower
        /// @Param repayUnderlyingAmountScaled - Repay amount scaled by 1e18
        /// @Return error code
        ///
        pub fun repayAllowed(
            poolCertificate: @{LendingInterfaces.IdentityCertificate},
            poolAddress: Address,
            borrowerAddress: Address,
            repayUnderlyingAmountScaled: UInt256
        ): String? {
            let err = self.callerAllowed(callerCertificate: <- poolCertificate, callerAddress: poolAddress)
            if (err != nil) {
                return err
            }

            // Remove pool out of user markets list if necessary
            self.removePoolFromAccountMarketsOnCondition(
                poolAddress: poolAddress,
                account: borrowerAddress,
                scaledRedeemOrRepayAmount: repayUnderlyingAmountScaled
            )

            return nil
        }

        /// Liquidation audit
        ///
        /// @Param poolCertificate - Can only be called by one of the valid LendPools
        /// @Param poolAddress - Caller address
        /// @Param poolCollateralized - The address of collateral pool holded by borrower to be repaid.
        /// @Param borrower - The address of borrower
        /// @Param repayUnderlyingAmountScaled - The amount repaid on behalf of the liquidator.
        /// @Return error code
        ///
        pub fun liquidateAllowed(
            poolCertificate: @{LendingInterfaces.IdentityCertificate},
            poolBorrowed: Address,
            poolCollateralized: Address,
            borrower: Address,
            repayUnderlyingAmountScaled: UInt256
        ): String? {
            pre {
                self.markets[poolCollateralized]?.isOpen == true: LendingError.ErrorEncode(msg: "collateral market not open", err: LendingError.ErrorCode.MARKET_NOT_OPEN)
            }

            let err = self.callerAllowed(callerCertificate: <- poolCertificate, callerAddress: poolBorrowed)
            if (err != nil) {
                return err
            }

            // Current account liquidity check
            // liquidity[0] - cross-market collateral value
            // liquidity[1] - cross-market borrow value
            // liquidity[2] - cross-market supply value
            let scaledLiquidity: [UInt256;3] = self.getHypotheticalAccountLiquidity(
                account: borrower,
                poolToModify: 0x0,
                scaledAmountLPTokenToRedeem: 0,
                scaledAmountUnderlyingToBorrow: 0
            )
            if (scaledLiquidity[0] >= scaledLiquidity[1]) {
                return LendingError.ErrorEncode(msg: "borrower account fully collaterized", err: LendingError.ErrorCode.LIQUIDATION_NOT_ALLOWED_POSITION_ABOVE_WATER)
            }

            let scaledBorrowBalance = self.markets[poolBorrowed]!.poolPublicCap.borrow()!.getAccountBorrowBalanceScaled(account: borrower)
            // liquidator cannot repay more than closeFactor * borrow
            if (repayUnderlyingAmountScaled > scaledBorrowBalance * self.scaledCloseFactor / LendingConfig.scaleFactor) {
                return LendingError.ErrorEncode(msg: "liquidator repaid more than closeFactor x accountBorrow", err: LendingError.ErrorCode.LIQUIDATION_NOT_ALLOWED_TOO_MUCH_REPAY)
            }

            return nil
        }

        /// Seize audit
        ///
        /// @Param poolCertificate - Can only be called by one of the valid LendPools
        /// @Param poolAddress - Caller address
        /// @Param collateralPool - The address of collateral pool holded by borrower to be repaid
        /// @Param liquidator - The address of liquidator
        /// @Param borrower - The address of borrower
        /// @Param seizeCollateralPoolLpTokenAmountScaled - The amount of Lptoken that the borrower will be liquidated.
        /// @Return error code
        ///
        pub fun seizeAllowed(
            poolCertificate: @{LendingInterfaces.IdentityCertificate},
            borrowPool: Address,
            collateralPool: Address,
            liquidator: Address,
            borrower: Address,
            seizeCollateralPoolLpTokenAmountScaled: UInt256
        ): String? {
            pre {
                self.markets[collateralPool]?.isOpen == true: LendingError.ErrorEncode(msg: "Collateral market not open", err: LendingError.ErrorCode.MARKET_NOT_OPEN)
            }

            let err = self.callerAllowed(callerCertificate: <- poolCertificate, callerAddress: borrowPool)
            if (err != nil) {
                return err
            }

            // Add to liquidator markets list
            if (self.accountMarketsIn.containsKey(liquidator) == false) {
                self.accountMarketsIn[liquidator] = [collateralPool]
            } else if (self.accountMarketsIn[liquidator]!.contains(collateralPool) == false) {
                self.accountMarketsIn[liquidator]!.append(collateralPool)
            }

            // Remove pool out of user markets list if necessary
            self.removePoolFromAccountMarketsOnCondition(
                poolAddress: collateralPool,
                account: borrower,
                scaledRedeemOrRepayAmount: seizeCollateralPoolLpTokenAmountScaled
            )

            return nil
        }

        /// Given actualRepaidBorrowAmount underlying of borrowPool, calculate seized number of lpTokens of collateralPool
        /// Called in LendingPool.liquidate()
        ///
        pub fun calculateCollateralPoolLpTokenToSeize(
            borrower: Address,
            borrowPool: Address,
            collateralPool: Address,
            actualRepaidBorrowAmountScaled: UInt256
        ): UInt256 {
            let borrowPoolUnderlyingPriceUSD = self.oracleCap!.borrow()!.getUnderlyingPrice(pool: borrowPool)
            assert(
                borrowPoolUnderlyingPriceUSD != 0.0,
                message: LendingError.ErrorEncode(msg: "Price feed not available for market ".concat(borrowPool.toString()), err: LendingError.ErrorCode.UNKNOWN_MARKET)
            )
            let collateralPoolUnderlyingPriceUSD = self.oracleCap!.borrow()!.getUnderlyingPrice(pool: collateralPool)
            assert(
                collateralPoolUnderlyingPriceUSD != 0.0,
                message: LendingError.ErrorEncode(msg: "Price feed not available for market ".concat(collateralPool.toString()), err: LendingError.ErrorCode.UNKNOWN_MARKET)
            )
            // 1. Accrue interests first to use latest collateralPool states to do calculation
            self.markets[collateralPool]!.poolPublicCap.borrow()!.accrueInterest()

            // 2. Calculate collateralPool lpTokenSeizedAmount
            let scaledCollateralUnderlyingToLpTokenRate = self.markets[collateralPool]!.poolPublicCap.borrow()!.getUnderlyingToLpTokenRateScaled()
            let scaledCollateralPoolLiquidationIncentive = self.markets[collateralPool]!.scaledLiquidationPenalty
            let scaledBorrowPoolUnderlyingPriceUSD = LendingConfig.UFix64ToScaledUInt256(borrowPoolUnderlyingPriceUSD)
            let scaledCollateralPoolUnderlyingPriceUSD = LendingConfig.UFix64ToScaledUInt256(collateralPoolUnderlyingPriceUSD)
            let scaleFactor = LendingConfig.scaleFactor


            let scaledActualRepaidBorrowWithIncentiveInUSD =
                scaledBorrowPoolUnderlyingPriceUSD * (scaleFactor + scaledCollateralPoolLiquidationIncentive) / scaleFactor *
                    actualRepaidBorrowAmountScaled / scaleFactor
            let scaledCollateralPoolLpTokenPriceUSD = scaledCollateralPoolUnderlyingPriceUSD * scaledCollateralUnderlyingToLpTokenRate / scaleFactor
            let scaledCollateralLpTokenSeizedAmount = scaledActualRepaidBorrowWithIncentiveInUSD * scaleFactor / scaledCollateralPoolLpTokenPriceUSD

            // 3. borrower collateralPool lpToken balance check
            let scaledLpTokenAmount = self.markets[collateralPool]!.poolPublicCap.borrow()!.getAccountLpTokenBalanceScaled(account: borrower)
            assert(
                scaledCollateralLpTokenSeizedAmount <= scaledLpTokenAmount,
                message: LendingError.ErrorEncode(
                    msg: "Liquidation seized too much, more than borrower collateralPool supply balance".concat((scaledCollateralLpTokenSeizedAmount).toString().concat(" <= ").concat(scaledLpTokenAmount.toString())),
                    err: LendingError.ErrorCode.LIQUIDATION_NOT_ALLOWED_SEIZE_MORE_THAN_BALANCE
                )
            )
            return scaledCollateralLpTokenSeizedAmount
        }

        pub fun getUserCertificateType(): Type {
            return Type<@LendingComptroller.UserCertificate>()
        }

        pub fun callerAllowed(
            callerCertificate: @{LendingInterfaces.IdentityCertificate},
            callerAddress: Address
        ): String? {
            if (self.markets[callerAddress]?.isOpen != true) {
                destroy callerCertificate
                return LendingError.ErrorEncode(msg: "Market not open", err: LendingError.ErrorCode.MARKET_NOT_OPEN)
            }
            let callerPoolCertificateType = self.markets[callerAddress]!.poolPublicCap.borrow()!.getPoolCertificateType()
            if (callerCertificate.isInstance(callerPoolCertificateType)) {
                destroy callerCertificate
                return nil
            } else {
                let errMsg = callerCertificate.getType().identifier.concat("!=").concat(callerPoolCertificateType.identifier)
                destroy callerCertificate
                return LendingError.ErrorEncode(msg: "not called from valid market contract".concat(errMsg), err: LendingError.ErrorCode.INVALID_POOL_CERTIFICATE)
            }
        }

        /// Remove pool out of user markets list if necessary
        access(self) fun removePoolFromAccountMarketsOnCondition(
            poolAddress: Address,
            account: Address,
            scaledRedeemOrRepayAmount: UInt256
        ): Bool {
            // snapshot[1] - lpTokenBalance; snapshot[2] - borrowBalance
            let snapshot = self.markets[poolAddress]!.poolPublicCap.borrow()!.getAccountSnapshotScaled(account: account)
            if (snapshot[1] == 0 && snapshot[2] == scaledRedeemOrRepayAmount || (snapshot[1] == scaledRedeemOrRepayAmount && snapshot[2] == 0)) {
                var id = 0
                let marketsIn: &[Address] = &(self.accountMarketsIn[account]!) as &[Address]
                while (id < marketsIn.length) {
                    if (marketsIn[id] == poolAddress) {
                        marketsIn.remove(at: id)
                        return true
                    }
                    id = id + 1
                }
            }
            return false
        }

        /// Calculate what the account liquidity would be if the given amounts were redeemed / borrowed
        ///
        /// @Param account - Target account
        /// @Param poolToModify - The market to hypothetically redeem/borrow from
        /// @Param scaledAmountLPTokenToRedeem - The number of LPTokens to hypothetically redeem
        /// @Param scaledAmountUnderlyingToBorrow - The amount of underlying to hypothetically borrow
        /// @Return: 0. hypothetical cross-market total collateral value normalized in usd
        ///          1. hypothetical cross-market total borrow value normalized in usd
        ///          2. hypothetical cross-market total supply value normalized in usd
        ///
        access(self) fun getHypotheticalAccountLiquidity(
            account: Address,
            poolToModify: Address,
            scaledAmountLPTokenToRedeem: UInt256,
            scaledAmountUnderlyingToBorrow: UInt256
        ): [UInt256; 3] {
            if (self.accountMarketsIn.containsKey(account) == false) {
                return [0, 0, 0]
            }
            // Cross-market total supply value applies with hypothetical side effects, normalized in usd
            var sumScaledSupplyWithEffectsNormalized: UInt256 = 0
            // Cross-market total collateral value applies with hypothetical side effects, normalized in usd
            var sumScaledCollateralWithEffectsNormalized: UInt256 = 0
            // Cross-market total borrow value applies with hypothetical side-effects, normalized in usd
            var sumScaledBorrowWithEffectsNormalized: UInt256 = 0
            for poolAddress in self.accountMarketsIn[account]! {
                let scaledCollateralFactor = self.markets[poolAddress]!.scaledCollateralFactor
                let scaledAccountSnapshot = self.markets[poolAddress]!.poolPublicCap.borrow()!.getAccountSnapshotScaled(account: account)
                let scaledUnderlyingToLpTokenRate = scaledAccountSnapshot[0]
                let scaledLpTokenAmount = scaledAccountSnapshot[1]
                let scaledBorrowBalance = scaledAccountSnapshot[2]
                let underlyingPriceInUSD = self.oracleCap!.borrow()!.getUnderlyingPrice(pool: poolAddress)
                assert(
                    underlyingPriceInUSD != 0.0,
                    message: LendingError.ErrorEncode(msg: "Price feed not available for market ".concat(poolAddress.toString()), err: LendingError.ErrorCode.UNKNOWN_MARKET)
                )
                let scaledUnderlyingPriceInUSD = LendingConfig.UFix64ToScaledUInt256(underlyingPriceInUSD)
                let scaleFactor = LendingConfig.scaleFactor
                if (scaledLpTokenAmount > 0) {
                    sumScaledCollateralWithEffectsNormalized = sumScaledCollateralWithEffectsNormalized +
                        scaledCollateralFactor * scaledUnderlyingPriceInUSD / scaleFactor *
                            scaledUnderlyingToLpTokenRate / scaleFactor * scaledLpTokenAmount / scaleFactor
                    sumScaledSupplyWithEffectsNormalized = sumScaledSupplyWithEffectsNormalized +
                        scaledUnderlyingPriceInUSD * scaledUnderlyingToLpTokenRate / scaleFactor * scaledLpTokenAmount / scaleFactor
                }
                if (scaledBorrowBalance > 0) {
                    sumScaledBorrowWithEffectsNormalized = sumScaledBorrowWithEffectsNormalized +
                        scaledBorrowBalance * scaledUnderlyingPriceInUSD / scaleFactor
                }
                if (poolAddress == poolToModify) {
                    // Apply hypothetical redeem side-effect
                    if (scaledAmountLPTokenToRedeem > 0) {
                        sumScaledCollateralWithEffectsNormalized = sumScaledCollateralWithEffectsNormalized -
                            scaledCollateralFactor * scaledUnderlyingPriceInUSD / scaleFactor *
                                scaledUnderlyingToLpTokenRate / scaleFactor * scaledAmountLPTokenToRedeem / scaleFactor
                        sumScaledSupplyWithEffectsNormalized = sumScaledSupplyWithEffectsNormalized -
                            scaledUnderlyingPriceInUSD * scaledUnderlyingToLpTokenRate / scaleFactor * scaledAmountLPTokenToRedeem / scaleFactor
                    }
                    // Apply hypothetical borrow side-effect
                    if (scaledAmountUnderlyingToBorrow > 0) {
                        sumScaledBorrowWithEffectsNormalized = sumScaledBorrowWithEffectsNormalized +
                            scaledAmountUnderlyingToBorrow * scaledUnderlyingPriceInUSD / scaleFactor
                    }
                }
            }
            return [sumScaledCollateralWithEffectsNormalized, sumScaledBorrowWithEffectsNormalized, sumScaledSupplyWithEffectsNormalized]
        }

        access(contract) fun addMarket(poolAddress: Address, liquidationPenalty: UFix64, collateralFactor: UFix64) {
            pre {
                self.markets.containsKey(poolAddress) == false:
                    LendingError.ErrorEncode(
                        msg: "Market has already been added",
                        err: LendingError.ErrorCode.ADD_MARKET_DUPLICATED
                    )

                self.oracleCap!.borrow()!.getUnderlyingPrice(pool: poolAddress) != 0.0:
                    LendingError.ErrorEncode(
                        msg: "Price feed for market is not available yet",
                        err: LendingError.ErrorCode.ADD_MARKET_NO_ORACLE_PRICE
                    )

            }
            // Add a new market with collateralFactor of 0.0 and borrowCap of 0.0
            let poolPublicCap = getAccount(poolAddress).getCapability<&{LendingInterfaces.PoolPublic}>(LendingConfig.PoolPublicPublicPath)
            assert(poolPublicCap.check() == true, message:
                LendingError.ErrorEncode(
                    msg: "Cannot borrow reference to PoolPublic resource",
                    err: LendingError.ErrorCode.CANNOT_ACCESS_POOL_PUBLIC_CAPABILITY
                )
            )

            self.markets[poolAddress] =
                Market(poolPublicCap: poolPublicCap, isOpen: false, isMining: false, liquidationPenalty: liquidationPenalty, collateralFactor: collateralFactor, borrowCap: 0.0, supplyCap: 0.0)
            emit MarketAdded(
                market: poolAddress,
                marketType: poolPublicCap.borrow()!.getUnderlyingTypeString(),
                liquidationPenalty: liquidationPenalty,
                collateralFactor: collateralFactor
            )
        }

        /// Tune parameters of an already-listed market
        access(contract) fun configMarket(pool: Address, isOpen: Bool?, isMining: Bool?, liquidationPenalty: UFix64?, collateralFactor: UFix64?, borrowCap: UFix64?, supplyCap: UFix64?) {
            pre {
                self.markets.containsKey(pool):
                    LendingError.ErrorEncode(
                        msg: "Market has not been added yet",
                        err: LendingError.ErrorCode.UNKNOWN_MARKET
                    )
            }
            let oldOpen = self.markets[pool]?.isOpen
            if (isOpen != nil) {
                self.markets[pool]!.setMarketStatus(isOpen: isOpen!)
            }
            let oldMining = self.markets[pool]?.isMining
            if (isMining != nil) {
                self.markets[pool]!.setMiningStatus(isMining: isMining!)
            }
            let oldCollateralFactor = LendingConfig.ScaledUInt256ToUFix64(self.markets[pool]?.scaledCollateralFactor ?? 0)
            if (collateralFactor != nil) {
                self.markets[pool]!.setCollateralFactor(newCollateralFactor: collateralFactor!)
            }
            let oldLiquidationPenalty = LendingConfig.ScaledUInt256ToUFix64(self.markets[pool]?.scaledLiquidationPenalty ?? 0)
            if (liquidationPenalty != nil) {
                self.markets[pool]!.setLiquidationPenalty(newLiquidationPenalty: liquidationPenalty!)
            }
            let oldBorrowCap = LendingConfig.ScaledUInt256ToUFix64(self.markets[pool]?.scaledBorrowCap ?? 0)
            if (borrowCap != nil) {
                self.markets[pool]!.setBorrowCap(newBorrowCap: borrowCap!)
            }
            let oldSupplyCap = LendingConfig.ScaledUInt256ToUFix64(self.markets[pool]?.scaledSupplyCap ?? 0)
            if (supplyCap != nil) {
                self.markets[pool]!.setSupplyCap(newSupplyCap: supplyCap!)
            }
            emit ConfigMarketParameters(
                market: pool,
                oldIsOpen: oldOpen, newIsOpen: self.markets[pool]?.isOpen,
                oldIsMining: oldMining, newIsMining: self.markets[pool]?.isMining,
                oldLiquidationPenalty: oldLiquidationPenalty, newLiquidationPenalty: liquidationPenalty,
                oldCollateralFactor: oldCollateralFactor, newCollateralFactor: collateralFactor,
                oldBorrowCap: oldBorrowCap, newBorrowCap: borrowCap,
                oldSupplyCap: oldSupplyCap, newSupplyCap: supplyCap
            )
        }

        access(contract) fun configOracle(oracleAddress: Address) {
            let oldOracleAddress = (self.oracleCap != nil)? self.oracleCap!.borrow()!.owner?.address : nil
            self.oracleCap = getAccount(oracleAddress).getCapability<&{LendingInterfaces.OraclePublic}>(LendingConfig.OraclePublicPath)
            emit NewOracle(oldOracleAddress, self.oracleCap!.borrow()!.owner!.address)
        }

        access(contract) fun setCloseFactor(newCloseFactor: UFix64) {
            pre {
                newCloseFactor <= 1.0:
                    LendingError.ErrorEncode(
                        msg: "newCloseFactor out of range 1.0",
                        err: LendingError.ErrorCode.INVALID_PARAMETERS
                    )
            }
            let oldCloseFactor = LendingConfig.ScaledUInt256ToUFix64(self.scaledCloseFactor)
            self.scaledCloseFactor = LendingConfig.UFix64ToScaledUInt256(newCloseFactor)
            emit NewCloseFactor(oldCloseFactor, newCloseFactor)
        }

        pub fun getPoolPublicRef(poolAddr: Address): &{LendingInterfaces.PoolPublic} {
            pre {
                self.markets.containsKey(poolAddr):
                    LendingError.ErrorEncode(
                        msg: "Invalid market address",
                        err: LendingError.ErrorCode.UNKNOWN_MARKET
                    )
            }
            return self.markets[poolAddr]!.poolPublicCap.borrow() ?? panic(
                LendingError.ErrorEncode(
                    msg: "Cannot borrow reference to PoolPublic",
                    err: LendingError.ErrorCode.CANNOT_ACCESS_POOL_PUBLIC_CAPABILITY
                )
            )
        }

        pub fun getAllMarkets(): [Address] {
            return self.markets.keys
        }

        pub fun getMarketInfo(poolAddr: Address): {String: AnyStruct} {
            pre {
                self.markets.containsKey(poolAddr):
                    LendingError.ErrorEncode(
                        msg: "Invalid market address",
                        err: LendingError.ErrorCode.UNKNOWN_MARKET
                    )
            }
            let market = self.markets[poolAddr]!
            let poolRef = market.poolPublicCap.borrow()!
            var oraclePrice = 0.0
            if(self.oracleCap != nil && self.oracleCap!.check()) {
                oraclePrice = self.oracleCap!.borrow()!.getUnderlyingPrice(pool: poolAddr)
            }

            let accrueInterestRealtimeRes = poolRef.accrueInterestReadonly()

            return {
                "isOpen": market.isOpen,
                "isMining": market.isMining,
                "marketAddress": poolAddr,
                "marketType": poolRef.getUnderlyingTypeString(),
                "marketSupplyScaled": (poolRef.getPoolCash()+accrueInterestRealtimeRes[2]).toString(),
                "marketBorrowScaled": accrueInterestRealtimeRes[2].toString(),
                "marketReserveScaled": poolRef.getPoolTotalReservesScaled().toString(),
                "marketSupplyApr": poolRef.getPoolSupplyAprScaled().toString(),
                "marketBorrowApr": poolRef.getPoolBorrowAprScaled().toString(),
                "marketLiquidationPenalty": market.scaledLiquidationPenalty.toString(),
                "marketCollateralFactor": market.scaledCollateralFactor.toString(),
                "marketBorrowCap": market.scaledBorrowCap.toString(),
                "marketSupplyCap": market.scaledSupplyCap.toString(),
                "marketOraclePriceUsd": LendingConfig.UFix64ToScaledUInt256(oraclePrice).toString(),
                "marketSupplierCount": poolRef.getPoolSupplierCount().toString(),
                "marketBorrowerCount": poolRef.getPoolBorrowerCount().toString(),
                "marketReserveFactor": poolRef.getPoolReserveFactorScaled().toString()
            }
        }

        pub fun getUserMarkets(userAddr: Address): [Address] {
            if (self.accountMarketsIn.containsKey(userAddr) == false) {
                return []
            }
            return self.accountMarketsIn[userAddr]!
        }

        /// Return the current account cross-market liquidity snapshot:
        /// [cross-market account collateral value in usd, cross-market account borrows in usd, cross-market account supplies in usd]
        /// Used in liquidation allowance check, or LTV (loan-to-value) ratio calculation
        pub fun getUserCrossMarketLiquidity(userAddr: Address): [String; 3] {
            let scaledLiquidity = self.getHypotheticalAccountLiquidity(
                account: userAddr,
                poolToModify: 0x0,
                scaledAmountLPTokenToRedeem: 0,
                scaledAmountUnderlyingToBorrow: 0
            )
            return [scaledLiquidity[0].toString(), scaledLiquidity[1].toString(), scaledLiquidity[2].toString()]
        }

        pub fun getUserMarketInfo(userAddr: Address, poolAddr: Address): {String: AnyStruct} {
            pre {
                self.markets.containsKey(poolAddr):
                    LendingError.ErrorEncode(
                        msg: "Invalid market address",
                        err: LendingError.ErrorCode.UNKNOWN_MARKET
                    )
            }
            if (self.accountMarketsIn.containsKey(userAddr) == false || self.accountMarketsIn[userAddr]!.contains(poolAddr) == false) {
                return {}
            }
            let market = self.markets[poolAddr]!
            let poolRef = market.poolPublicCap.borrow()!

            let scaledAccountSnapshot = poolRef.getAccountSnapshotScaled(account: userAddr)
            let scaledAccountRealtime = poolRef.getAccountRealtimeScaled(account: userAddr)

            return {
                "userSupplyScaled": (scaledAccountRealtime[1] * scaledAccountRealtime[0] / LendingConfig.scaleFactor).toString(),
                "userBorrowScaled": scaledAccountRealtime[2].toString(),
                "userBorrowPrincipalSnapshotScaled": scaledAccountSnapshot[3].toString(),
                "userBorrowIndexSnapshotScaled": scaledAccountSnapshot[4].toString(),
                "userLpTokenBalanceScaled": scaledAccountSnapshot[1].toString()
            }
        }

        init() {
            self.oracleCap = nil
            self.scaledCloseFactor = 0
            self.markets = {}
            self.accountMarketsIn = {}
            self._reservedFields = {}
        }
    }

    /// Admin
    ///
    pub resource Admin {
        /// Admin function to list a new asset pool to the lending market
        /// Note: Do not list a new asset pool before the oracle feed is ready
        pub fun addMarket(poolAddress: Address, liquidationPenalty: UFix64, collateralFactor: UFix64) {
            let comptrollerRef = LendingComptroller.account.borrow<&Comptroller>(from: LendingComptroller.ComptrollerStoragePath) ?? panic("lost local comptroller")
            comptrollerRef.addMarket(poolAddress: poolAddress, liquidationPenalty: liquidationPenalty, collateralFactor: collateralFactor)
        }
        /// Admin function to config parameters of a listed-market
        pub fun configMarket(pool: Address, isOpen: Bool?, isMining: Bool?, liquidationPenalty: UFix64?, collateralFactor: UFix64?, borrowCap: UFix64?, supplyCap: UFix64?) {
            let comptrollerRef = LendingComptroller.account.borrow<&Comptroller>(from: LendingComptroller.ComptrollerStoragePath) ?? panic("lost local comptroller")
            comptrollerRef.configMarket(
                pool: pool,
                isOpen: isOpen,
                isMining: isMining,
                liquidationPenalty: liquidationPenalty,
                collateralFactor: collateralFactor,
                borrowCap: borrowCap,
                supplyCap: supplyCap
            )
        }
        /// Admin function to set a new oracle
        pub fun configOracle(oracleAddress: Address) {
            let comptrollerRef = LendingComptroller.account.borrow<&Comptroller>(from: LendingComptroller.ComptrollerStoragePath) ?? panic("lost local comptroller")
            comptrollerRef.configOracle(oracleAddress: oracleAddress)
        }
        /// Admin function to set closeFactor
        pub fun setCloseFactor(closeFactor: UFix64) {
            let comptrollerRef = LendingComptroller.account.borrow<&Comptroller>(from: LendingComptroller.ComptrollerStoragePath) ?? panic("lost local comptroller")
            comptrollerRef.setCloseFactor(newCloseFactor: closeFactor)
        }
    }

    init() {
        self.AdminStoragePath = /storage/comptrollerAdmin
        self.ComptrollerStoragePath = /storage/comptrollerModule
        self.ComptrollerPublicPath = /public/comptrollerModule
        self.ComptrollerPrivatePath = /private/comptrollerModule
        self.comptrollerAddress = self.account.address
        self._reservedFields = {}

        destroy <-self.account.load<@AnyResource>(from: self.AdminStoragePath)
        self.account.save(<-create Admin(), to: self.AdminStoragePath)

        destroy <-self.account.load<@AnyResource>(from: self.ComptrollerStoragePath)
        self.account.save(<-create Comptroller(), to: self.ComptrollerStoragePath)
        self.account.unlink(self.ComptrollerPublicPath)
        self.account.link<&{LendingInterfaces.ComptrollerPublic}>(self.ComptrollerPublicPath, target: self.ComptrollerStoragePath)
    }
}
"
-------
"/*
*
*  Manages the process of generating a group key with the participation of all the consensus nodes
*  for the upcoming epoch.
*
*  When consensus nodes are first confirmed, they can request a Participant object from this contract
*  They'll use this object for every subsequent epoch that they are a staked consensus node.
*
*  At the beginning of each EpochSetup phase, the admin initializes this contract with
*  the list of consensus nodes for the upcoming epoch. Each consensus node
*  can post as many messages as they want to the DKG "whiteboard" with the `Participant.postMessage()` method,
*  but each node can only submit a final submission once per epoch via the `Participant.sendFinalSubmission() method.
*
*  Once a >50% threshold of consensus nodes have submitted the exact same set of keys,
*  the DKG phase is technically finished.
*  Anyone can query the state of the submissions with the FlowDKG.getFinalSubmissions()
*  or FlowDKG.dkgCompleted() methods.
*  Consensus nodes can continue to submit final messages even after the required amount have been submitted though.
*
*  This contract is a member of a series of epoch smart contracts which coordinates the
*  process of transitioning between epochs in Flow.
*/

pub contract FlowDKG {

    // ===================================================================
    // DKG EVENTS
    // ===================================================================

    /// Emitted when the admin enables the DKG
    pub event StartDKG()

    /// Emitted when the admin ends the DKG after enough submissions have been recorded
    pub event EndDKG(finalSubmission: [String?]?)

    /// Emitted when a consensus node has posted a message to the DKG whiteboard
    pub event BroadcastMessage(nodeID: String, content: String)

    // ================================================================================
    // CONTRACT VARIABLES
    // ================================================================================

    /// The length of keys that have to be submitted as a final submission
    pub let submissionKeyLength: Int

    /// Indicates if the DKG is enabled or not
    pub var dkgEnabled: Bool

    /// Indicates if a Participant resource has already been claimed by a node ID
    /// from the identity table contract
    /// Node IDs have to claim a participant once
    /// one node will use the same specific ID and Participant resource for all time
    /// `nil` or false means that there is no voting capability for the node ID
    /// true means that the participant capability has been claimed by the node
    access(account) var nodeClaimed: {String: Bool}

    /// Record of whiteboard messages for the current epoch
    /// This is reset at the beginning of every DKG phase (once per epoch)
    access(account) var whiteboardMessages: [Message]

    /// Tracks a node's final submission for the current epoch
    /// Key: node ID
    /// Value: Set of public keys from the final submission
    /// If the value is `nil`, the node is not registered as a consensus node
    /// If the value is an empty array, the node has not submitted yet
    /// This mapping is reset at the beginning of every DKG phase (once per epoch)
    access(account) var finalSubmissionByNodeID: {String: [String?]}

    /// Array of unique final submissions from nodes
    /// if a final submission is sent that matches one that already has been submitted
    /// this array will not change at all
    access(account) var uniqueFinalSubmissions: [[String?]]

    /// Tracks how many submissions have been sent
    /// for each unique final submission
    access(account) var uniqueFinalSubmissionCount: {Int: UInt64}

    // ================================================================================
    // CONTRACT CONSTANTS
    // ================================================================================

    // Canonical paths for admin and participant resources
    pub let AdminStoragePath: StoragePath
    pub let ParticipantStoragePath: StoragePath
    pub let ParticipantPublicPath: PublicPath

    /// Struct to represent a single whiteboard message
    pub struct Message {

        /// The ID of the node who submitted the message
        pub let nodeID: String

        /// The content of the message
        /// We make no assumptions or assertions about the content of the message
        pub let content: String

        init(nodeID: String, content: String) {
            self.nodeID = nodeID
            self.content = content
        }
    }

    /// The Participant resource is generated for each consensus node when they register.
    /// Each resource instance is good for all future potential epochs, but will
    /// only be valid if the node operator has been confirmed as a consensus node for the next epoch.
    pub resource Participant {

        /// The node ID of the participant
        pub let nodeID: String

        init(nodeID: String) {
            pre {
                FlowDKG.participantIsClaimed(nodeID) == nil:
                    "Cannot create a Participant resource for a node ID that has already been claimed"
            }
            self.nodeID = nodeID
            FlowDKG.nodeClaimed[nodeID] = true
        }

        /// If the Participant resource is destroyed,
        /// It could potentially be claimed again
        destroy () {
            FlowDKG.nodeClaimed[self.nodeID] = false
        }

        /// Posts a whiteboard message to the contract
        pub fun postMessage(_ content: String) {
            pre {
                FlowDKG.participantIsRegistered(self.nodeID):
                    "Cannot send whiteboard message if not registered for the current epoch"
                content.length > 0:
                    "Cannot post an empty message to the whiteboard"
            }

            // create the message struct
            let message = Message(nodeID: self.nodeID, content: content)

            // add the message to the message record
            FlowDKG.whiteboardMessages.append(message)

            emit BroadcastMessage(nodeID: self.nodeID, content: content)

        }

        /// Sends the final key vector submission.
        /// Can only be called by consensus nodes that are registered
        /// and can only be called once per consensus node per epoch
        pub fun sendFinalSubmission(_ submission: [String?]) {
            pre {
                FlowDKG.participantIsRegistered(self.nodeID):
                    "Cannot send final submission if not registered for the current epoch"
                !FlowDKG.nodeHasSubmitted(self.nodeID):
                    "Cannot submit a final submission twice"
                submission.length == FlowDKG.getConsensusNodeIDs().length + 1:
                    "Submission must have number of elements equal to the number of nodes participating in the DKG plus 1"
            }

            // iterate through each key in the vector
            // and make sure all of them are the correct length
            for key in submission {
                // nil keys are a valid submission
                if let keyValue = key {
                    // If a key length is incorrect, it is an invalid submission
                    if keyValue.length != FlowDKG.submissionKeyLength {
                        panic("Submission key length is not correct!")
                    }
                }
            }

            var finalSubmissionIndex = 0

            // iterate through all the existing unique submissions
            // If this participant's submission matches one of the existing ones,
            // add to the counter for that submission
            // Otherwise, track the new submission and set its counter to 1
            while finalSubmissionIndex <= FlowDKG.uniqueFinalSubmissions.length {
                // If no matches were found, add this submission as a new unique one
                // and emit an event
                if finalSubmissionIndex == FlowDKG.uniqueFinalSubmissions.length {
                    FlowDKG.uniqueFinalSubmissionCount[finalSubmissionIndex] = 1
                    FlowDKG.uniqueFinalSubmissions.append(submission)
                    break
                }

                let existingSubmission = FlowDKG.uniqueFinalSubmissions[finalSubmissionIndex]

                // If the submissions are equal,
                // update the counter for this submission and emit the event
                if FlowDKG.submissionsEqual(existingSubmission, submission) {
                    FlowDKG.uniqueFinalSubmissionCount[finalSubmissionIndex] = FlowDKG.uniqueFinalSubmissionCount[finalSubmissionIndex]! + (1 as UInt64)
                    break
                }

                // update the index counter
                finalSubmissionIndex = finalSubmissionIndex + 1
            }

            FlowDKG.finalSubmissionByNodeID[self.nodeID] = submission
        }
    }

    /// Interface that only contains operations that are part
    /// of the regular automated functioning of the epoch process
    /// These are accessed by the `FlowEpoch` contract through a capability
    pub resource interface EpochOperations {
        pub fun createParticipant(nodeID: String): @Participant
        pub fun startDKG(nodeIDs: [String])
        pub fun endDKG()
        pub fun forceEndDKG()
    }

    /// The Admin resource provides the ability to begin and end voting for an epoch
    pub resource Admin: EpochOperations {

        /// Sets the optional safe DKG success threshold
        /// Set the threshold to nil if it isn't needed
        pub fun setSafeSuccessThreshold(newThresholdPercentage: UFix64?) {
            pre {
                !FlowDKG.dkgEnabled: "Cannot set the dkg success threshold while the DKG is enabled"
                newThresholdPercentage == nil ||  newThresholdPercentage! < 1.0: "The threshold percentage must be in [0,1)"
            }

            FlowDKG.account.load<UFix64>(from: /storage/flowDKGSafeThreshold)

            // If newThresholdPercentage is nil, we exit here. Since we loaded from
            // storage previously, this results in /storage/flowDKGSafeThreshold being empty
            if let percentage = newThresholdPercentage {
                FlowDKG.account.save<UFix64>(percentage, to: /storage/flowDKGSafeThreshold)
            }
        }

        /// Creates a new Participant resource for a consensus node
        pub fun createParticipant(nodeID: String): @Participant {
            let participant <-create Participant(nodeID: nodeID)
            FlowDKG.nodeClaimed[nodeID] = true
            return <-participant
        }

        /// Resets all the fields for tracking the current DKG process
        /// and sets the given node IDs as registered
        pub fun startDKG(nodeIDs: [String]) {
            pre {
                FlowDKG.dkgEnabled == false: "Cannot start the DKG when it is already running"
            }

            FlowDKG.finalSubmissionByNodeID = {}
            for id in nodeIDs {
                FlowDKG.finalSubmissionByNodeID[id] = []
            }

            // Clear all of the contract fields
            FlowDKG.whiteboardMessages = []
            FlowDKG.uniqueFinalSubmissions = []
            FlowDKG.uniqueFinalSubmissionCount = {}

            FlowDKG.dkgEnabled = true

            emit StartDKG()
        }

        /// Disables the DKG and closes the opportunity for messages and submissions
        /// until the next time the DKG is enabled
        pub fun endDKG() {
            pre {
                FlowDKG.dkgEnabled == true: "Cannot end the DKG when it is already disabled"
                FlowDKG.dkgCompleted() != nil: "Cannot end the DKG until enough final arrays have been submitted"
            }

            FlowDKG.dkgEnabled = false

            emit EndDKG(finalSubmission: FlowDKG.dkgCompleted())
        }

        /// Ends the DKG without checking if it is completed
        /// Should only be used if something goes wrong with the DKG,
        /// the protocol halts, or needs to be reset for some reason
        pub fun forceEndDKG() {
            FlowDKG.dkgEnabled = false

            emit EndDKG(finalSubmission: FlowDKG.dkgCompleted())
        }
    }

    /// Checks if two final submissions are equal by comparing each element
    /// Each element has to be exactly the same and in the same order
    access(account) fun submissionsEqual(_ existingSubmission: [String?], _ submission: [String?]): Bool {

        // If the submission length is different than the one being compared to, it is not equal
        if submission.length != existingSubmission.length {
            return false
        }

        var index = 0

        // Check each key in the submiission to make sure that it matches
        // the existing one
        for key in submission {

            // if a key is different, stop checking this submission
            // and return false
            if key != existingSubmission[index] {
                return false
            }

            index = index + 1
        }

        return true
    }

    /// Returns true if a node is registered as a consensus node for the proposed epoch
    pub fun participantIsRegistered(_ nodeID: String): Bool {
        return FlowDKG.finalSubmissionByNodeID[nodeID] != nil
    }

    /// Returns true if a consensus node has claimed their Participant resource
    /// which is valid for all future epochs where the node is registered
    pub fun participantIsClaimed(_ nodeID: String): Bool? {
        return FlowDKG.nodeClaimed[nodeID]
    }

    /// Gets an array of all the whiteboard messages
    /// that have been submitted by all nodes in the DKG
    pub fun getWhiteBoardMessages(): [Message] {
        return self.whiteboardMessages
    }

    /// Returns whether this node has successfully submitted a final submission for this epoch.
    pub fun nodeHasSubmitted(_ nodeID: String): Bool {
        if let submission = self.finalSubmissionByNodeID[nodeID] {
            return submission.length > 0
        } else {
            return false
        }
    }

    /// Gets the specific final submission for a node ID
    /// If the node hasn't submitted or registered, this returns `nil`
    pub fun getNodeFinalSubmission(_ nodeID: String): [String?]? {
        if let submission = self.finalSubmissionByNodeID[nodeID] {
            if submission.length > 0 {
                return submission
            } else {
                return nil
            }
        } else {
            return nil
        }
    }

    /// Get the list of all the consensus node IDs participating
    pub fun getConsensusNodeIDs(): [String] {
        return self.finalSubmissionByNodeID.keys
    }

    /// Get the array of all the unique final submissions
    pub fun getFinalSubmissions(): [[String?]] {
        return self.uniqueFinalSubmissions
    }

    /// Gets the native threshold that the submission count needs to exceed to be considered complete [t=floor((n-1)/2)]
    /// This function returns the NON-INCLUSIVE lower bound of honest participants.
    /// For the DKG to succeed, the number of honest participants must EXCEED this threshold value.
    ///
    /// Example:
    /// We have 10 DKG nodes (n=10)
    /// The threshold value is t=floor(10-1)/2) (t=4)
    /// There must be AT LEAST 5 honest nodes for the DKG to succeed
    pub fun getNativeSuccessThreshold(): UInt64 {
        return UInt64((self.getConsensusNodeIDs().length-1)/2)
    }

    /// Gets the safe threshold that the submission count needs to exceed to be considered complete.
    /// (always greater than or equal to the native success threshold)
    ///
    /// This function returns the NON-INCLUSIVE lower bound of honest participants. If this function
    /// returns threshold t, there must be AT LEAST t+1 honest nodes for the DKG to succeed.
    pub fun getSafeSuccessThreshold(): UInt64 {
        var threshold = self.getNativeSuccessThreshold()

        // Get the safety rate percentage
        if let safetyRate = self.getSafeThresholdPercentage() {

            let safeThreshold = UInt64(safetyRate * UFix64(self.getConsensusNodeIDs().length))

            if safeThreshold > threshold {
                threshold = safeThreshold
            }
        }

        return threshold
    }

    /// Gets the safe threshold percentage. This value must be either nil (semantically: 0) or in [0, 1.0)
    /// This safe threshold is used to artificially increase the DKG participation requirements to
    /// ensure a lower-bound number of Random Beacon Committee members (beyond the bare minimum required
    /// by the DKG protocol).
    pub fun getSafeThresholdPercentage(): UFix64? {
        let safetyRate = self.account.copy<UFix64>(from: /storage/flowDKGSafeThreshold)
        return safetyRate
    }

    /// Returns the final set of keys if any one set of keys has strictly more than (nodes-1)/2 submissions
    /// Returns nil if not found (incomplete)
    pub fun dkgCompleted(): [String?]? {
        if !self.dkgEnabled { return nil }

        var index = 0

        for submission in self.uniqueFinalSubmissions {
            if self.uniqueFinalSubmissionCount[index]! > self.getSafeSuccessThreshold() {
                var foundNil: Bool = false
                for key in submission {
                    if key == nil {
                        foundNil = true
                        break
                    }
                }
                if foundNil { continue }
                return submission
            }
            index = index + 1
        }

        return nil
    }

    init() {
        self.submissionKeyLength = 192

        self.AdminStoragePath = /storage/flowEpochsDKGAdmin
        self.ParticipantStoragePath = /storage/flowEpochsDKGParticipant
        self.ParticipantPublicPath = /public/flowEpochsDKGParticipant

        self.dkgEnabled = false

        self.finalSubmissionByNodeID = {}
        self.uniqueFinalSubmissionCount = {}
        self.uniqueFinalSubmissions = []

        self.nodeClaimed = {}
        self.whiteboardMessages = []

        self.account.save(<-create Admin(), to: self.AdminStoragePath)
    }
}
 "
-------
"//import FungibleToken from 0xf233dcee88fe0abe
//import NonFungibleToken from 0x1d7e57aa55817448
//import FlowToken from 0x1654653399040a61
//import FlovatarComponentTemplate from 0x921ea449dffec68a
//import FlovatarComponent from 0x921ea449dffec68a
//import Crypto
//import FlowUtilityToken from 0xead892083b3e2c6c
import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import FlowToken from 0x1654653399040a61
import FlovatarComponentTemplate from 0x921ea449dffec68a
import FlovatarComponent from 0x921ea449dffec68a
import Crypto
import FlowUtilityToken from 0xead892083b3e2c6c
import FlovatarDustToken from 0x921ea449dffec68a

/*

 This contract defines the Flovatar Packs and a Collection to manage them.

 Each Pack will contain one item for each required Component (body, hair, eyes, nose, mouth, clothing),
 and two other Components that are optional (facial hair, accessory, hat, eyeglasses, background).

 Packs will be pre-minted and can be purchased from the contract owner's account by providing a
 verified signature that is different for each Pack (more info in the purchase function).

 Once purchased, packs cannot be re-sold and users will only be able to open them to receive
 the contained Components into their collection.

 */

pub contract FlovatarPack {

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath

    // Counter for all the Packs ever minted
    pub var totalSupply: UInt64

    // Standard events that will be emitted
    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event Created(id: UInt64, prefix: String)
    pub event Opened(id: UInt64)
    pub event Purchased(id: UInt64)

    // The public interface contains only the ID and the price of the Pack
    pub resource interface Public {
        pub let id: UInt64
        pub let price: UFix64
        pub let sparkCount: UInt32
        pub let series: UInt32
        pub let name: String
    }

    // The Pack resource that implements the Public interface and that contains
    // different Components in a Dictionary
    pub resource Pack: Public {
        pub let id: UInt64
        pub let price: UFix64
        pub let sparkCount: UInt32
        pub let series: UInt32
        pub let name: String
        access(account) let components: @[FlovatarComponent.NFT]
        access(account) var randomString: String

        // Initializes the Pack with all the Components.
        // It receives also the price and a random String that will signed by
        // the account owner to validate the purchase process.
        init(
            components: @[FlovatarComponent.NFT],
            randomString: String,
            price: UFix64,
            sparkCount: UInt32,
            series: UInt32,
            name: String
        ) {

            // Makes sure that if it's set to have a spark component, this one is present in the array

            var sparkCountCheck: UInt32 = 0
            if(sparkCount > 0){
                var i: Int = 0
                while(i < components.length){
                    if(components[i].getCategory() == "spark"){
                        sparkCountCheck = sparkCountCheck + 1
                    }
                    i = i + 1
                }
            }

            if(sparkCount != sparkCountCheck){
                panic("There is a mismatch in the spark count")
            }




            // Increments the total supply counter
            FlovatarPack.totalSupply = FlovatarPack.totalSupply + UInt64(1)
            self.id = FlovatarPack.totalSupply

            // Moves all the components into the array
            self.components <- []
            while(components.length > 0){
                self.components.append(<- components.remove(at: 0))
            }

            destroy components

            // Sets the randomString text and the price
            self.randomString = randomString
            self.price = price
            self.sparkCount = sparkCount
            self.series = series
            self.name = name
        }

        destroy() {
            destroy self.components
        }

        // This function is used to retrieve the random string to match it
        // against the signature passed during the purchase process
        access(contract) fun getRandomString(): String {
            return self.randomString
        }

        // This function reset the randomString so that after the purchase nobody
        // will be able to re-use the verified signature
        access(contract) fun setRandomString(randomString: String) {
            self.randomString = randomString
        }

        pub fun removeComponent(at: Int): @FlovatarComponent.NFT {
            return <- self.components.remove(at: at)
        }

    }

    //Pack CollectionPublic interface that allows users to purchase a Pack
    pub resource interface CollectionPublic {
        pub fun getIDs(): [UInt64]
        pub fun deposit(token: @FlovatarPack.Pack)
        pub fun purchase(tokenId: UInt64, recipientCap: Capability<&{FlovatarPack.CollectionPublic}>, buyTokens: @FungibleToken.Vault, signature: String)
        pub fun purchaseWithDust(tokenId: UInt64, recipientCap: Capability<&{FlovatarPack.CollectionPublic}>, buyTokens: @FungibleToken.Vault, signature: String)
        pub fun purchaseDapper(tokenId: UInt64, recipientCap: Capability<&{FlovatarPack.CollectionPublic}>, buyTokens: @FungibleToken.Vault, signature: String, expectedPrice: UFix64)
    }

    // Main Collection that implements the Public interface and that
    // will handle the purchase transactions
    pub resource Collection: CollectionPublic {
        // Dictionary of all the Packs owned
        access(account) let ownedPacks: @{UInt64: FlovatarPack.Pack}
        // Capability to send the FLOW tokens to the owner's account
        access(account) let ownerVault: Capability<&AnyResource{FungibleToken.Receiver}>

        // Initializes the Collection with the vault receiver capability
        init (ownerVault: Capability<&{FungibleToken.Receiver}>) {
            self.ownedPacks <- {}
            self.ownerVault = ownerVault
        }

        // getIDs returns an array of the IDs that are in the collection
        pub fun getIDs(): [UInt64] {
            return self.ownedPacks.keys
        }

        // deposit takes a Pack and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun deposit(token: @FlovatarPack.Pack) {
            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedPacks[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        // withdraw removes a Pack from the collection and moves it to the caller
        pub fun withdraw(withdrawID: UInt64): @FlovatarPack.Pack {
            let token <- self.ownedPacks.remove(key: withdrawID) ?? panic("Missing Pack")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        // This function allows any Pack owner to open the pack and receive its content
        // into the owner's Component Collection.
        // The pack is destroyed after the Components are delivered.
        pub fun openPack(id: UInt64) {

            // Gets the Component Collection Public capability to be able to
            // send there the Components contained in the Pack
            let recipientCap = self.owner!.getCapability<&{FlovatarComponent.CollectionPublic}>(FlovatarComponent.CollectionPublicPath)
            let recipient = recipientCap.borrow()!

            // Removed the pack from the collection
            let pack <- self.withdraw(withdrawID: id)

            // Removes all the components from the Pack and deposits them to the
            // Component Collection of the owner

            while(pack.components.length > 0){
                recipient.deposit(token: <- pack.removeComponent(at: 0))
            }

            // Emits the event to notify that the pack was opened
            emit Opened(id: pack.id)

            destroy pack
        }

        // Gets the price for a specific Pack
        access(account) fun getPrice(id: UInt64): UFix64 {
            let pack: &FlovatarPack.Pack = (&self.ownedPacks[id] as auth &FlovatarPack.Pack?)!
            return pack.price
        }

        // Gets the random String for a specific Pack
        access(account) fun getRandomString(id: UInt64): String {
            let pack: &FlovatarPack.Pack = (&self.ownedPacks[id] as auth &FlovatarPack.Pack?)!
            return pack.getRandomString()
        }

        // Sets the random String for a specific Pack
        access(account) fun setRandomString(id: UInt64, randomString: String) {
            let pack: &FlovatarPack.Pack = (&self.ownedPacks[id] as auth &FlovatarPack.Pack?)!
            pack.setRandomString(randomString: randomString)
        }


        // This function provides the ability for anyone to purchase a Pack
        // It receives as parameters the Pack ID, the Pack Collection Public capability to receive the pack,
        // a vault containing the necessary FLOW token, and finally a signature to validate the process.
        // The signature is generated off-chain by the smart contract's owner account using the Crypto library
        // to generate a hash from the original random String contained in each Pack.
        // This will guarantee that the contract owner will be able to decide which user can buy a pack, by
        // providing them the correct signature.
        //
        pub fun purchase(tokenId: UInt64, recipientCap: Capability<&{FlovatarPack.CollectionPublic}>, buyTokens: @FungibleToken.Vault, signature: String) {

            // Checks that the pack is still available and that the FLOW tokens are sufficient
            pre {
                self.ownedPacks.containsKey(tokenId) == true : "Pack not found!"
                self.getPrice(id: tokenId) <= buyTokens.balance : "Not enough tokens to buy the Pack!"
                buyTokens.isInstance(Type<@FlowToken.Vault>()) : "Vault not of the right Token Type"
            }

            // Gets the Crypto.KeyList and the public key of the collection's owner
            let keyList = Crypto.KeyList()
            let accountKey = self.owner!.keys.get(keyIndex: 0)!.publicKey

            // Adds the public key to the keyList
            keyList.add(
                PublicKey(
                    publicKey: accountKey.publicKey,
                    signatureAlgorithm: accountKey.signatureAlgorithm
                ),
                hashAlgorithm: HashAlgorithm.SHA3_256,
                weight: 1.0
            )

            // Creates a Crypto.KeyListSignature from the signature provided in the parameters
            let signatureSet: [Crypto.KeyListSignature] = []
            signatureSet.append(
                Crypto.KeyListSignature(
                    keyIndex: 0,
                    signature: signature.decodeHex()
                )
            )

            // Verifies that the signature is valid and that it was generated from the
            // owner of the collection
            if(!keyList.verify(signatureSet: signatureSet, signedData: self.getRandomString(id: tokenId).utf8)){
                panic("Unable to validate the signature for the pack!")
            }


            // Borrows the recipient's capability and withdraws the Pack from the collection.
            // If this fails the transaction will revert but the signature will be exposed.
            // For this reason in case it happens, the randomString will be reset when the purchase
            // reservation timeout expires by the web server back-end.
            let recipient = recipientCap.borrow()!
            let pack <- self.withdraw(withdrawID: tokenId)

            // Borrows the owner's capability for the Vault and deposits the FLOW tokens
            let vaultRef = self.ownerVault.borrow() ?? panic("Could not borrow reference to owner pack vault")
            vaultRef.deposit(from: <-buyTokens)


            // Resets the randomString so that the provided signature will become useless
            let packId: UInt64 = pack.id
            pack.setRandomString(randomString: unsafeRandom().toString())

            // Deposits the Pack to the recipient's collection
            recipient.deposit(token: <- pack)

            // Emits an even to notify about the purchase
            emit Purchased(id: packId)

        }
        //
        pub fun purchaseDapper(tokenId: UInt64, recipientCap: Capability<&{FlovatarPack.CollectionPublic}>, buyTokens: @FungibleToken.Vault, signature: String, expectedPrice: UFix64) {

            // Checks that the pack is still available and that the FLOW tokens are sufficient
            pre {
                self.ownedPacks.containsKey(tokenId) == true : "Pack not found!"
                self.getPrice(id: tokenId) <= buyTokens.balance : "Not enough tokens to buy the Pack!"
                self.getPrice(id: tokenId) == expectedPrice : "Price not set as expected!"
                buyTokens.isInstance(Type<@FlowUtilityToken.Vault>()) : "Vault not of the right Token Type"
            }

            // Gets the Crypto.KeyList and the public key of the collection's owner
            let keyList = Crypto.KeyList()
            let accountKey = self.owner!.keys.get(keyIndex: 0)!.publicKey

            // Adds the public key to the keyList
            keyList.add(
                PublicKey(
                    publicKey: accountKey.publicKey,
                    signatureAlgorithm: accountKey.signatureAlgorithm
                ),
                hashAlgorithm: HashAlgorithm.SHA3_256,
                weight: 1.0
            )

            // Creates a Crypto.KeyListSignature from the signature provided in the parameters
            let signatureSet: [Crypto.KeyListSignature] = []
            signatureSet.append(
                Crypto.KeyListSignature(
                    keyIndex: 0,
                    signature: signature.decodeHex()
                )
            )

            // Verifies that the signature is valid and that it was generated from the
            // owner of the collection
            if(!keyList.verify(signatureSet: signatureSet, signedData: self.getRandomString(id: tokenId).utf8)){
                panic("Unable to validate the signature for the pack!")
            }


            // Borrows the recipient's capability and withdraws the Pack from the collection.
            // If this fails the transaction will revert but the signature will be exposed.
            // For this reason in case it happens, the randomString will be reset when the purchase
            // reservation timeout expires by the web server back-end.
            let recipient = recipientCap.borrow()!
            let pack <- self.withdraw(withdrawID: tokenId)

            // Borrows the owner's capability for the Vault and deposits the FLOW tokens
            let dapperMarketVault = getAccount(0x8a86f18e0e05bd9f).getCapability<&{FungibleToken.Receiver}>(/public/flowUtilityTokenReceiver)
            let vaultRef = dapperMarketVault.borrow() ?? panic("Could not borrow reference to owner pack vault")
            vaultRef.deposit(from: <-buyTokens)


            // Resets the randomString so that the provided signature will become useless
            let packId: UInt64 = pack.id
            pack.setRandomString(randomString: unsafeRandom().toString())

            // Deposits the Pack to the recipient's collection
            recipient.deposit(token: <- pack)

            // Emits an even to notify about the purchase
            emit Purchased(id: packId)
        }



        pub fun purchaseWithDust(tokenId: UInt64, recipientCap: Capability<&{FlovatarPack.CollectionPublic}>, buyTokens: @FungibleToken.Vault, signature: String) {

            // Checks that the pack is still available and that the FLOW tokens are sufficient
            pre {
                self.ownedPacks.containsKey(tokenId) == true : "Pack not found!"
                self.getPrice(id: tokenId) <= buyTokens.balance : "Not enough tokens to buy the Pack!"
                buyTokens.isInstance(Type<@FlovatarDustToken.Vault>()) : "Vault not of the right Token Type"
            }

            // Gets the Crypto.KeyList and the public key of the collection's owner
            let keyList = Crypto.KeyList()
            let accountKey = self.owner!.keys.get(keyIndex: 0)!.publicKey

            // Adds the public key to the keyList
            keyList.add(
                PublicKey(
                    publicKey: accountKey.publicKey,
                    signatureAlgorithm: accountKey.signatureAlgorithm
                ),
                hashAlgorithm: HashAlgorithm.SHA3_256,
                weight: 1.0
            )

            // Creates a Crypto.KeyListSignature from the signature provided in the parameters
            let signatureSet: [Crypto.KeyListSignature] = []
            signatureSet.append(
                Crypto.KeyListSignature(
                    keyIndex: 0,
                    signature: signature.decodeHex()
                )
            )

            // Verifies that the signature is valid and that it was generated from the
            // owner of the collection
            if(!keyList.verify(signatureSet: signatureSet, signedData: self.getRandomString(id: tokenId).utf8)){
                panic("Unable to validate the signature for the pack!")
            }


            // Borrows the recipient's capability and withdraws the Pack from the collection.
            // If this fails the transaction will revert but the signature will be exposed.
            // For this reason in case it happens, the randomString will be reset when the purchase
            // reservation timeout expires by the web server back-end.
            let recipient = recipientCap.borrow()!
            let pack <- self.withdraw(withdrawID: tokenId)

            if(pack.name != "Dust Flobit Pack"){
                panic("Wrong type of Pack selected")
            }

            // Burn the DUST Tokens
            destroy(buyTokens)

            // Resets the randomString so that the provided signature will become useless
            let packId: UInt64 = pack.id
            pack.setRandomString(randomString: unsafeRandom().toString())

            // Deposits the Pack to the recipient's collection
            recipient.deposit(token: <- pack)

            // Emits an even to notify about the purchase
            emit Purchased(id: packId)

        }

        destroy() {
            destroy self.ownedPacks
        }
    }



    // public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(ownerVault: Capability<&{FungibleToken.Receiver}>): @FlovatarPack.Collection {
        return <- create Collection(ownerVault: ownerVault)
    }

    // Get all the packs from a specific account
    pub fun getPacks(address: Address) : [UInt64]? {

        let account = getAccount(address)

        if let packCollection = account.getCapability(self.CollectionPublicPath).borrow<&{FlovatarPack.CollectionPublic}>()  {
            return packCollection.getIDs();
        }
        return nil
    }



    // This method can only be called from another contract in the same account (The Flovatar Admin resource)
    // It creates a new pack from a list of Components, the random String and the price.
    // Some Components are required and others are optional
    access(account) fun createPack(
            components: @[FlovatarComponent.NFT],
            randomString: String,
            price: UFix64,
            sparkCount: UInt32,
            series: UInt32,
            name: String
        ) : @FlovatarPack.Pack {

        var newPack <- create Pack(
            components: <-components,
            randomString: randomString,
            price: price,
            sparkCount: sparkCount,
            series: series,
            name: name
        )

        // Emits an event to notify that a Pack was created.
        // Sends the first 4 digits of the randomString to be able to sync the ID with the off-chain DB
        // that will store also the signatures once they are generated
        emit Created(id: newPack.id, prefix: randomString.slice(from: 0, upTo: 4))

        return <- newPack
    }

	init() {
        let wallet =  self.account.getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver)

        self.CollectionPublicPath=/public/FlovatarPackCollection
        self.CollectionStoragePath=/storage/FlovatarPackCollection

        // Initialize the total supply
        self.totalSupply = 0

        self.account.save<@FlovatarPack.Collection>(<- FlovatarPack.createEmptyCollection(ownerVault: wallet), to: FlovatarPack.CollectionStoragePath)
        self.account.link<&{FlovatarPack.CollectionPublic}>(FlovatarPack.CollectionPublicPath, target: FlovatarPack.CollectionStoragePath)

        emit ContractInitialized()
	}
}

"
-------
"// CREATED BY: Touchstone (https://touchstone.city/), a platform crafted by your best friends at Emerald City DAO (https://ecdao.org/).
// STATEMENT: This contract promises to keep the 5% royalty off of primary sales and 2.5% off of secondary sales to Emerald City DAO or risk permanent suspension from participation in the DAO and its tools.

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import FlowToken from 0x1654653399040a61
import MintVerifiers from 0x7a696d6136e1dce2
import FUSD from 0x3c5959b568896393
import EmeraldPass from 0x6a07dbeb03167a13

pub contract TouchstoneShotCaller: NonFungibleToken {

	// Collection Information
	access(self) let collectionInfo: {String: AnyStruct}

	// Contract Information
	pub var nextEditionId: UInt64
	pub var nextMetadataId: UInt64
	pub var totalSupply: UInt64

	// Events
	pub event ContractInitialized()
	pub event Withdraw(id: UInt64, from: Address?)
	pub event Deposit(id: UInt64, to: Address?)
	pub event TouchstonePurchase(id: UInt64, recipient: Address, metadataId: UInt64, name: String, description: String, image: MetadataViews.IPFSFile, price: UFix64)
	pub event Minted(id: UInt64, recipient: Address, metadataId: UInt64)
	pub event MintBatch(metadataIds: [UInt64], recipients: [Address])

	// Paths
	pub let CollectionStoragePath: StoragePath
	pub let CollectionPublicPath: PublicPath
	pub let CollectionPrivatePath: PrivatePath
	pub let AdministratorStoragePath: StoragePath

	// Maps metadataId of NFT to NFTMetadata
	access(account) let metadatas: {UInt64: NFTMetadata}

	// Maps the metadataId of an NFT to the primary buyer
	access(account) let primaryBuyers: {Address: {UInt64: [UInt64]}}

	access(account) let nftStorage: @{Address: {UInt64: NFT}}

	pub struct NFTMetadata {
		pub let metadataId: UInt64
		pub let name: String
		pub let description: String
		// The main image of the NFT
		pub let image: MetadataViews.IPFSFile
		// An optional thumbnail that can go along with it
		// for easier loading
		pub let thumbnail: MetadataViews.IPFSFile?
		// If price is nil, defaults to the collection price
		pub let price: UFix64?
		pub var extra: {String: AnyStruct}
		pub let supply: UInt64
		pub let purchasers: {UInt64: Address}

		access(account) fun purchased(serial: UInt64, buyer: Address) {
			self.purchasers[serial] = buyer
		}

		init(_name: String, _description: String, _image: MetadataViews.IPFSFile, _thumbnail: MetadataViews.IPFSFile?, _price: UFix64?, _extra: {String: AnyStruct}, _supply: UInt64) {
			self.metadataId = TouchstoneShotCaller.nextMetadataId
			self.name = _name
			self.description = _description
			self.image = _image
			self.thumbnail = _thumbnail
			self.price = _price
			self.extra = _extra
			self.supply = _supply
			self.purchasers = {}
		}
	}

	pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
		// The 'id' is the same as the 'uuid'
		pub let id: UInt64
		// The 'metadataId' is what maps this NFT to its 'NFTMetadata'
		pub let metadataId: UInt64
		pub let serial: UInt64

		pub fun getMetadata(): NFTMetadata {
			return TouchstoneShotCaller.getNFTMetadata(self.metadataId)!
		}

		pub fun getViews(): [Type] {
			return [
				Type<MetadataViews.Display>(),
				Type<MetadataViews.ExternalURL>(),
				Type<MetadataViews.NFTCollectionData>(),
				Type<MetadataViews.NFTCollectionDisplay>(),
				Type<MetadataViews.Royalties>(),
				Type<MetadataViews.Serial>(),
				Type<MetadataViews.Traits>(),
				Type<MetadataViews.NFTView>()
			]
		}

		pub fun resolveView(_ view: Type): AnyStruct? {
			switch view {
				case Type<MetadataViews.Display>():
					let metadata = self.getMetadata()
					return MetadataViews.Display(
						name: metadata.name,
						description: metadata.description,
						thumbnail: metadata.thumbnail ?? metadata.image
					)
				case Type<MetadataViews.NFTCollectionData>():
					return MetadataViews.NFTCollectionData(
						storagePath: TouchstoneShotCaller.CollectionStoragePath,
						publicPath: TouchstoneShotCaller.CollectionPublicPath,
						providerPath: TouchstoneShotCaller.CollectionPrivatePath,
						publicCollection: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
						publicLinkedType: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
						providerLinkedType: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, NonFungibleToken.Provider}>(),
						createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
								return <- TouchstoneShotCaller.createEmptyCollection()
						})
					)
				case Type<MetadataViews.ExternalURL>():
          return MetadataViews.ExternalURL("https://touchstone.city/discover/".concat(self.owner!.address.toString()).concat("/TouchstoneShotCaller"))
				case Type<MetadataViews.NFTCollectionDisplay>():
					let squareMedia = MetadataViews.Media(
						file: TouchstoneShotCaller.getCollectionAttribute(key: "image") as! MetadataViews.IPFSFile,
						mediaType: "image"
					)

					// If a banner image exists, use it
					// Otherwise, default to the main square image
					var bannerMedia: MetadataViews.Media? = nil
					if let bannerImage = TouchstoneShotCaller.getOptionalCollectionAttribute(key: "bannerImage") as! MetadataViews.IPFSFile? {
						bannerMedia = MetadataViews.Media(
							file: bannerImage,
							mediaType: "image"
						)
					}
					return MetadataViews.NFTCollectionDisplay(
						name: TouchstoneShotCaller.getCollectionAttribute(key: "name") as! String,
						description: TouchstoneShotCaller.getCollectionAttribute(key: "description") as! String,
						externalURL: MetadataViews.ExternalURL("https://touchstone.city/discover/".concat(self.owner!.address.toString()).concat("/TouchstoneShotCaller")),
						squareImage: squareMedia,
						bannerImage: bannerMedia ?? squareMedia,
						socials: TouchstoneShotCaller.getCollectionAttribute(key: "socials") as! {String: MetadataViews.ExternalURL}
					)
				case Type<MetadataViews.Royalties>():
					return MetadataViews.Royalties([
						// This is for Emerald City in favor of producing Touchstone, a free platform for our users. Failure to keep this in the contract may result in permanent suspension from Emerald City.
						MetadataViews.Royalty(
							recepient: getAccount(0x5643fd47a29770e7).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),
							cut: 0.025, // 2.5% royalty on secondary sales
							description: "Emerald City DAO receives a 2.5% royalty from secondary sales because this collection was created using Touchstone (https://touchstone.city/), a tool for creating your own NFT collections, crafted by Emerald City DAO."
						)
					])
				case Type<MetadataViews.Serial>():
					return MetadataViews.Serial(
						self.serial
					)
				case Type<MetadataViews.Traits>():
					return MetadataViews.dictToTraits(dict: self.getMetadata().extra, excludedNames: nil)
				case Type<MetadataViews.NFTView>():
					return MetadataViews.NFTView(
						id: self.id,
						uuid: self.uuid,
						display: self.resolveView(Type<MetadataViews.Display>()) as! MetadataViews.Display?,
						externalURL: self.resolveView(Type<MetadataViews.ExternalURL>()) as! MetadataViews.ExternalURL?,
						collectionData: self.resolveView(Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?,
						collectionDisplay: self.resolveView(Type<MetadataViews.NFTCollectionDisplay>()) as! MetadataViews.NFTCollectionDisplay?,
						royalties: self.resolveView(Type<MetadataViews.Royalties>()) as! MetadataViews.Royalties?,
						traits: self.resolveView(Type<MetadataViews.Traits>()) as! MetadataViews.Traits?
					)
			}
			return nil
		}

		init(_metadataId: UInt64, _serial: UInt64, _recipient: Address) {
			pre {
				TouchstoneShotCaller.metadatas[_metadataId] != nil:
					"This NFT does not exist yet."
				_serial < TouchstoneShotCaller.getNFTMetadata(_metadataId)!.supply:
					"This serial does not exist for this metadataId."
				!TouchstoneShotCaller.getNFTMetadata(_metadataId)!.purchasers.containsKey(_serial):
					"This serial has already been purchased."
			}
			self.id = self.uuid
			self.metadataId = _metadataId
			self.serial = _serial

			// Update the buyers list so we keep track of who is purchasing
			if let buyersRef = &TouchstoneShotCaller.primaryBuyers[_recipient] as &{UInt64: [UInt64]}? {
				if let metadataIdMap = &buyersRef[_metadataId] as &[UInt64]? {
					metadataIdMap.append(_serial)
				} else {
					buyersRef[_metadataId] = [_serial]
				}
			} else {
				TouchstoneShotCaller.primaryBuyers[_recipient] = {_metadataId: [_serial]}
			}

			// Update who bought this serial inside NFTMetadata so it cannot be purchased again.
			let metadataRef = (&TouchstoneShotCaller.metadatas[_metadataId] as &NFTMetadata?)!
			metadataRef.purchased(serial: _serial, buyer: _recipient)

			TouchstoneShotCaller.totalSupply = TouchstoneShotCaller.totalSupply + 1
			emit Minted(id: self.id, recipient: _recipient, metadataId: _metadataId)
		}
	}

	pub resource Collection: NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
		// dictionary of NFT conforming tokens
		// NFT is a resource type with an 'UInt64' ID field
		pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

		// withdraw removes an NFT from the collection and moves it to the caller
		pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
			let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

			emit Withdraw(id: token.id, from: self.owner?.address)

			return <-token
		}

		// deposit takes a NFT and adds it to the collections dictionary
		// and adds the ID to the id array
		pub fun deposit(token: @NonFungibleToken.NFT) {
			let token <- token as! @NFT

			let id: UInt64 = token.id

			// add the new token to the dictionary
			self.ownedNFTs[id] <-! token

			emit Deposit(id: id, to: self.owner?.address)
		}

		// getIDs returns an array of the IDs that are in the collection
		pub fun getIDs(): [UInt64] {
			return self.ownedNFTs.keys
		}

		// borrowNFT gets a reference to an NFT in the collection
		// so that the caller can read its metadata and call its methods
		pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
			return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
		}

		pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
			let token = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
			let nft = token as! &NFT
			return nft as &AnyResource{MetadataViews.Resolver}
		}

		pub fun claim() {
			if let storage = &TouchstoneShotCaller.nftStorage[self.owner!.address] as &{UInt64: NFT}? {
				for id in storage.keys {
					self.deposit(token: <- storage.remove(key: id)!)
				}
			}
		}

		init () {
			self.ownedNFTs <- {}
		}

		destroy() {
			destroy self.ownedNFTs
		}
	}

	// A function to mint NFTs.
	// You can only call this function if minting
	// is currently active.
	pub fun mintNFT(metadataId: UInt64, recipient: &{NonFungibleToken.Receiver}, payment: @FlowToken.Vault, serial: UInt64): UInt64 {
		pre {
			self.canMint(): "Minting is currently closed by the Administrator!"
			payment.balance == self.getPriceOfNFT(metadataId):
				"Payment does not match the price. You passed in ".concat(payment.balance.toString()).concat(" but this NFT costs ").concat(self.getPriceOfNFT(metadataId)!.toString())
		}
		let price: UFix64 = self.getPriceOfNFT(metadataId)!

		// Confirm recipient passes all verifiers
		for verifier in self.getMintVerifiers() {
			let params = {"minter": recipient.owner!.address}
			if let error = verifier.verify(params) {
				panic(error)
			}
		}

		// Handle Emerald City DAO royalty (5%)
		let EmeraldCityTreasury = getAccount(0x5643fd47a29770e7).getCapability(/public/flowTokenReceiver)
								.borrow<&FlowToken.Vault{FungibleToken.Receiver}>()!
		let emeraldCityCut: UFix64 = 0.05 * price

		// Handle royalty to user that was configured upon creation
		if let royalty = TouchstoneShotCaller.getOptionalCollectionAttribute(key: "royalty") as! MetadataViews.Royalty? {
			royalty.receiver.borrow()!.deposit(from: <- payment.withdraw(amount: price * royalty.cut))
		}

		EmeraldCityTreasury.deposit(from: <- payment.withdraw(amount: emeraldCityCut))

		// Give the rest to the collection owner
		let paymentRecipient = self.account.getCapability(/public/flowTokenReceiver)
								.borrow<&FlowToken.Vault{FungibleToken.Receiver}>()!
		paymentRecipient.deposit(from: <- payment)

		// Mint the nft
		let nft <- create NFT(_metadataId: metadataId, _serial: serial, _recipient: recipient.owner!.address)
		let nftId: UInt64 = nft.id
		let metadata = self.getNFTMetadata(metadataId)!
		self.collectionInfo["profit"] = (self.getCollectionAttribute(key: "profit") as! UFix64) + price

		// Emit event
		emit TouchstonePurchase(id: nftId, recipient: recipient.owner!.address, metadataId: metadataId, name: metadata.name, description: metadata.description, image: metadata.image, price: price)

		// Deposit nft
		recipient.deposit(token: <- nft)

		return nftId
	}

	pub resource Administrator {
		pub fun createNFTMetadata(name: String, description: String, imagePath: String, thumbnailPath: String?, ipfsCID: String, price: UFix64?, extra: {String: AnyStruct}, supply: UInt64) {
			TouchstoneShotCaller.metadatas[TouchstoneShotCaller.nextMetadataId] = NFTMetadata(
				_name: name,
				_description: description,
				_image: MetadataViews.IPFSFile(
					cid: ipfsCID,
					path: imagePath
				),
				_thumbnail: thumbnailPath == nil ? nil : MetadataViews.IPFSFile(cid: ipfsCID, path: thumbnailPath),
				_price: price,
				_extra: extra,
				_supply: supply
			)
			TouchstoneShotCaller.nextMetadataId = TouchstoneShotCaller.nextMetadataId + 1
		}

		// mintNFT mints a new NFT and deposits
		// it in the recipients collection
		pub fun mintNFT(metadataId: UInt64, serial: UInt64, recipient: Address) {
			pre {
				EmeraldPass.isActive(user: TouchstoneShotCaller.account.address): "You must have an active Emerald Pass subscription to airdrop NFTs. You can purchase Emerald Pass at https://pass.ecdao.org/"
			}
			let nft <- create NFT(_metadataId: metadataId, _serial: serial, _recipient: recipient)
			if let recipientCollection = getAccount(recipient).getCapability(TouchstoneShotCaller.CollectionPublicPath).borrow<&TouchstoneShotCaller.Collection{NonFungibleToken.CollectionPublic}>() {
				recipientCollection.deposit(token: <- nft)
			} else {
				if let storage = &TouchstoneShotCaller.nftStorage[recipient] as &{UInt64: NFT}? {
					storage[nft.id] <-! nft
				} else {
					TouchstoneShotCaller.nftStorage[recipient] <-! {nft.id: <- nft}
				}
			}
		}

		pub fun mintBatch(metadataIds: [UInt64], serials: [UInt64], recipients: [Address]) {
			pre {
				metadataIds.length == recipients.length: "You need to pass in an equal number of metadataIds and recipients."
			}
			var i = 0
			while i < metadataIds.length {
				self.mintNFT(metadataId: metadataIds[i], serial: serials[i], recipient: recipients[i])
				i = i + 1
			}

			emit MintBatch(metadataIds: metadataIds, recipients: recipients)
		}

		// create a new Administrator resource
		pub fun createAdmin(): @Administrator {
			return <- create Administrator()
		}

		// change piece of collection info
		pub fun changeField(key: String, value: AnyStruct) {
			TouchstoneShotCaller.collectionInfo[key] = value
		}
	}

	// public function that anyone can call to create a new empty collection
	pub fun createEmptyCollection(): @NonFungibleToken.Collection {
		return <- create Collection()
	}

	// Get information about a NFTMetadata
	pub fun getNFTMetadata(_ metadataId: UInt64): NFTMetadata? {
		return self.metadatas[metadataId]
	}

	pub fun getNFTMetadatas(): {UInt64: NFTMetadata} {
		return self.metadatas
	}

	pub fun getPrimaryBuyers(): {Address: {UInt64: [UInt64]}} {
		return self.primaryBuyers
	}

	pub fun getCollectionInfo(): {String: AnyStruct} {
		let collectionInfo = self.collectionInfo
		collectionInfo["metadatas"] = self.metadatas
		collectionInfo["primaryBuyers"] = self.primaryBuyers
		collectionInfo["totalSupply"] = self.totalSupply
		collectionInfo["nextMetadataId"] = self.nextMetadataId
		collectionInfo["version"] = 1
		return collectionInfo
	}

	pub fun getCollectionAttribute(key: String): AnyStruct {
		return self.collectionInfo[key] ?? panic(key.concat(" is not an attribute in this collection."))
	}

	pub fun getOptionalCollectionAttribute(key: String): AnyStruct? {
		return self.collectionInfo[key]
	}

	pub fun getMintVerifiers(): [{MintVerifiers.IVerifier}] {
		return self.getCollectionAttribute(key: "mintVerifiers") as! [{MintVerifiers.IVerifier}]
	}

	pub fun canMint(): Bool {
		return self.getCollectionAttribute(key: "minting") as! Bool
	}

	// Returns nil if an NFT with this metadataId doesn't exist
	pub fun getPriceOfNFT(_ metadataId: UInt64): UFix64? {
		if let metadata: TouchstoneShotCaller.NFTMetadata = self.getNFTMetadata(metadataId) {
			let defaultPrice: UFix64 = self.getCollectionAttribute(key: "price") as! UFix64
			if self.getCollectionAttribute(key: "lotteryBuying") as! Bool {
				return defaultPrice
			}
			return metadata.price ?? defaultPrice
		}
		// If the metadataId doesn't exist
		return nil
	}

	// Returns an mapping of `id` to NFTMetadata
	// for the NFTs a user can claim
	pub fun getClaimableNFTs(user: Address): {UInt64: NFTMetadata} {
		let answer: {UInt64: NFTMetadata} = {}
		if let storage = &TouchstoneShotCaller.nftStorage[user] as &{UInt64: NFT}? {
			for id in storage.keys {
				let nftRef = (&storage[id] as &NFT?)!
				answer[id] = self.getNFTMetadata(nftRef.metadataId)
			}
		}
		return answer
	}

	init(
		_name: String,
		_description: String,
		_imagePath: String,
		_bannerImagePath: String?,
		_minting: Bool,
		_royalty: MetadataViews.Royalty?,
		_defaultPrice: UFix64,
		_paymentType: String,
		_ipfsCID: String,
		_lotteryBuying: Bool,
		_socials: {String: MetadataViews.ExternalURL},
		_mintVerifiers: [{MintVerifiers.IVerifier}]
	) {
		// Collection Info
		self.collectionInfo = {}
		self.collectionInfo["name"] = _name
		self.collectionInfo["description"] = _description
		self.collectionInfo["image"] = MetadataViews.IPFSFile(
			cid: _ipfsCID,
			path: _imagePath
		)
		if let bannerImagePath = _bannerImagePath {
			self.collectionInfo["bannerImage"] = MetadataViews.IPFSFile(
				cid: _ipfsCID,
				path: _bannerImagePath
			)
		}
		self.collectionInfo["ipfsCID"] = _ipfsCID
		self.collectionInfo["socials"] = _socials
		self.collectionInfo["minting"] = _minting
		self.collectionInfo["lotteryBuying"] = _lotteryBuying
		if let royalty = _royalty {
			assert(royalty.receiver.check(), message: "The passed in royalty receiver is not valid. The royalty account must set up the intended payment token.")
			assert(royalty.cut <= 0.95, message: "The royalty cut cannot be bigger than 95% because 5% goes to Emerald City treasury for primary sales.")
			self.collectionInfo["royalty"] = royalty
		}
		self.collectionInfo["price"] = _defaultPrice
		self.collectionInfo["paymentType"] = _paymentType
		self.collectionInfo["dateCreated"] = getCurrentBlock().timestamp
		self.collectionInfo["mintVerifiers"] = _mintVerifiers
		self.collectionInfo["profit"] = 0.0

		self.nextEditionId = 0
		self.nextMetadataId = 0
		self.totalSupply = 0
		self.metadatas = {}
		self.primaryBuyers = {}
		self.nftStorage <- {}

		// Set the named paths
		// We include the user's address in the paths.
		// This is to prevent clashing with existing
		// Collection paths in the ecosystem.
		self.CollectionStoragePath = /storage/TouchstoneShotCallerCollection_0x2287416bcd8fbeb4
		self.CollectionPublicPath = /public/TouchstoneShotCallerCollection_0x2287416bcd8fbeb4
		self.CollectionPrivatePath = /private/TouchstoneShotCallerCollection_0x2287416bcd8fbeb4
		self.AdministratorStoragePath = /storage/TouchstoneShotCallerAdministrator_0x2287416bcd8fbeb4

		// Create a Collection resource and save it to storage
		let collection <- create Collection()
		self.account.save(<- collection, to: self.CollectionStoragePath)

		// create a public capability for the collection
		self.account.link<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(
			self.CollectionPublicPath,
			target: self.CollectionStoragePath
		)

		// Create a Administrator resource and save it to storage
		let administrator <- create Administrator()
		self.account.save(<- administrator, to: self.AdministratorStoragePath)

		emit ContractInitialized()
	}
}
 "
-------
"import JoyridePayments from 0xecfad18ba9582d4f

pub contract JoyrideGameShim {
    pub event PlayerTransaction(gameID: String)
    pub event FinalizeTransaction(gameID: String)
    pub event RefundTransaction(gameID: String)

    //Fake Token Events for User Mapping
    pub event TokensWithdrawn(amount: UFix64, from: Address?)
    pub event TokensDeposited(amount: UFix64, to: Address?)

    pub fun GameIDtoStoragePath(_ gameID:String) : StoragePath {
      return StoragePath(identifier: "JoyrideGame_".concat(gameID))!
    }

    pub fun GameIDtoCapabilityPath(_ gameID:String) : PrivatePath {
      return PrivatePath(identifier: "JoyrideGame_".concat(gameID))!
    }

    pub fun CreateJoyrideGame(paymentsAdmin: Capability<&{JoyridePayments.WalletAdmin}>,gameID:String) : @JoyrideGameShim.JoyrideGame {
      return <- create JoyrideGameShim.JoyrideGame(paymentsAdmin:paymentsAdmin, gameID:gameID)
    }

    pub resource interface JoyrideGameData {
      pub fun readGameInfo(_ key:String) : AnyStruct
      pub fun setGameInfo(_ key:String, value:AnyStruct)
    }

    pub resource JoyrideGame: JoyrideGameData, JoyridePayments.WalletAdmin
    {
      access(self) let gameInfo:{String:AnyStruct}
      access(self) var paymentsAdmin: Capability<&{JoyridePayments.WalletAdmin}>

      init(paymentsAdmin: Capability<&{JoyridePayments.WalletAdmin}>, gameID:String) {
        self.gameInfo = {"gameID":gameID}
        self.paymentsAdmin = paymentsAdmin
      }

      pub fun readGameInfo(_ key:String) : AnyStruct {
        return self.gameInfo[key]
      }

      pub fun setGameInfo(_ key:String, value:AnyStruct) {
        self.gameInfo[key] = value
      }

      pub fun PlayerTransaction(playerID: String, tokenContext: String, amount:Fix64, gameID: String, txID: String, reward: Bool, notes: String) : Bool {
        if(!self.gameInfo.containsKey("gameID")) {
            panic("gameID not set")
        }
        let _gameID = self.readGameInfo("gameID")! as! String
        if(gameID != _gameID) { panic("Incorrect GameID for Shim") }

        emit JoyrideGameShim.PlayerTransaction(gameID: gameID)
        return self.paymentsAdmin.borrow()!.PlayerTransaction(playerID: playerID, tokenContext: tokenContext, amount: amount, gameID: gameID, txID: txID, reward: reward, notes: notes)
      }

      pub fun FinalizeTransactionWithDevPercentage(txID: String, profit: UFix64, devPercentage: UFix64) : Bool {
        emit JoyrideGameShim.FinalizeTransaction(gameID: self.readGameInfo("gameID")! as! String)
        return self.paymentsAdmin.borrow()!.FinalizeTransactionWithDevPercentage(txID: txID, profit: profit, devPercentage: devPercentage)
      }

      pub fun RefundTransaction(txID: String) : Bool {
        emit JoyrideGameShim.RefundTransaction(gameID: self.readGameInfo("gameID")! as! String)
        return self.paymentsAdmin.borrow()!.RefundTransaction(txID: txID)
      }
    }
}
"
-------
"//  SPDX-License-Identifier: UNLICENSED
//
//
import NonFungibleToken from 0x1d7e57aa55817448
import Anique from 0xe2e1689b53e92a82

pub contract chiharasan: NonFungibleToken, Anique {
    // -----------------------------------------------------------------------
    // chiharasan contract Events
    // -----------------------------------------------------------------------

    // Events for Contract-Related actions
    //
    // Emitted when the chiharasan contract is created
    pub event ContractInitialized()

    // Events for Item-Related actions
    //
    // Emitted when a new Item struct is created
    pub event ItemCreated(id: UInt32, metadata: {String:String})

    // Events for Collectible-Related actions
    //
    // Emitted when an CollectibleData NFT is minted
    pub event CollectibleMinted(collectibleID: UInt64, itemID: UInt32, serialNumber: UInt32)
    // Emitted when an CollectibleData NFT is destroyed
    pub event CollectibleDestroyed(collectibleID: UInt64)

    // events for Collection-related actions
    //
    // Emitted when an CollectibleData is withdrawn from a Collection
    pub event Withdraw(id: UInt64, from: Address?)
    // Emitted when an CollectibleData is deposited into a Collection
    pub event Deposit(id: UInt64, to: Address?)

    // paths
    pub let collectionStoragePath: StoragePath
    pub let collectionPublicPath: PublicPath
    pub let collectionPrivatePath: PrivatePath
    pub let adminStoragePath: StoragePath
    pub let saleCollectionStoragePath: StoragePath
    pub let saleCollectionPublicPath: PublicPath

    // -----------------------------------------------------------------------
    // chiharasan contract-level fields.
    // These contain actual values that are stored in the smart contract.
    // -----------------------------------------------------------------------

    // fields for Item-related
    //
    // variable size dictionary of Item resources
    access(self) var items: @{UInt32: Item}

    // The ID that is used to create Items.
    pub var nextItemID: UInt32

    // fields for Collectible-related
    //
    // Total number of CollectibleData NFTs that have been minted ever.
    pub var totalSupply: UInt64

    // -----------------------------------------------------------------------
    // chiharasan contract-level Composite Type definitions
    // -----------------------------------------------------------------------

    // The structure that represents Item
    // each digital content which chiharasan deal with on Flow
    //
    pub struct ItemData {

        pub let itemID: UInt32

        pub let metadata: {String: String}

        init(itemID: UInt32) {
            let item = (&chiharasan.items[itemID] as &Item?)!

            self.itemID = item.itemID
            self.metadata = item.metadata
        }
   }

    // Item is a resource type that contains the functions to mint Collectibles.
    //
    // It is stored in a private field in the contract so that
    // the admin resource can call its methods and that there can be
    // public getters for some of its fields
    //
    // The admin can mint Collectibles that refer from Item.
    pub resource Item {

        // unique ID for the Item
        pub let itemID: UInt32

        // Stores all the metadata about the item as a string mapping
        // This is not the long term way NFT metadata will be stored. It's a temporary
        // construct while we figure out a better way to do metadata.
        //
        pub let metadata: {String: String}

        // The number of Collectibles that have been minted per Item.
        access(contract) var numberMintedPerItem: UInt32

        init(metadata: {String: String}) {
            pre {
                metadata.length != 0: "New Item metadata cannot be empty"
            }
            self.itemID = chiharasan.nextItemID
            self.metadata = metadata
            self.numberMintedPerItem = 0

            // increment the nextItemID so that it isn't used again
            chiharasan.nextItemID = chiharasan.nextItemID + 1

            emit ItemCreated(id: self.itemID, metadata: metadata)
        }

        // mintCollectible mints a new Collectible and returns the newly minted Collectible
        //
        // Returns: The NFT that was minted
        //
        pub fun mintCollectible(): @NFT {
            // get the number of Collectibles that have been minted for this Item
            // to use as this Collectible's serial number
            let numInItem = self.numberMintedPerItem

            // mint the new Collectible
            let newCollectible: @NFT <- create NFT(serialNumber: numInItem + 1,
                                              itemID: self.itemID)

            // Increment the count of Collectibles minted for this Item
            self.numberMintedPerItem = numInItem + 1

            return <-newCollectible
        }

        // batchMintCollectible mints an arbitrary quantity of Collectibles
        // and returns them as a Collection
        //
        // Parameters: itemID: the ID of the Item that the Collectibles are minted for
        //             quantity: The quantity of Collectibles to be minted
        //
        // Returns: Collection object that contains all the Collectibles that were minted
        //
        pub fun batchMintCollectible(quantity: UInt64): @Collection {
            let newCollection <- create Collection()

            var i: UInt64 = 0
            while i < quantity {
                newCollection.deposit(token: <-self.mintCollectible())
                i = i + 1
            }

            return <-newCollection
        }

        // Returns: the number of Collectibles
        pub fun getNumberMinted(): UInt32 {
            return self.numberMintedPerItem
        }
    }

    // The structure holds metadata of an Collectible
    pub struct CollectibleData {
        // The ID of the Item that the Collectible references
        pub let itemID: UInt32

        // The place in the Item that this Collectible was minted
        pub let serialNumber: UInt32

        init(itemID: UInt32, serialNumber: UInt32) {
            self.itemID = itemID
            self.serialNumber = serialNumber
        }
    }

    // The resource that represents the CollectibleData NFTs
    //
    pub resource NFT: NonFungibleToken.INFT, Anique.INFT {

        // Global unique collectibleData ID
        pub let id: UInt64

        // Struct of Collectible metadata
        pub let data: CollectibleData

        init(serialNumber: UInt32, itemID: UInt32) {
            // Increment the global Collectible IDs
            chiharasan.totalSupply = chiharasan.totalSupply + 1

            // set id
            self.id = chiharasan.totalSupply

            // Set the metadata struct
            self.data = CollectibleData(itemID: itemID, serialNumber: serialNumber)

            emit CollectibleMinted(collectibleID: self.id, itemID: itemID, serialNumber: self.data.serialNumber)
        }

        destroy() {
            emit CollectibleDestroyed(collectibleID: self.id)
        }
    }

    // interface that represents chiharasan collections to public
    // extends of NonFungibleToken.CollectionPublic
    pub resource interface CollectionPublic {

        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT

        // deposit multi tokens
        pub fun batchDeposit(tokens: @Anique.Collection)

        // contains NFT
        pub fun contains(id: UInt64): Bool

        // borrow NFT as chiharasan token
        pub fun borrowchiharasanCollectible(id: UInt64): auth &NFT
    }

    // Collection is a resource that every user who owns NFTs
    // will store in their account to manage their NFTs
    //
    pub resource Collection: CollectionPublic, NonFungibleToken.Receiver, NonFungibleToken.Provider, NonFungibleToken.CollectionPublic {
        // Dictionary of CollectibleData conforming tokens
        // NFT is a resource type with a UInt64 ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init() {
            self.ownedNFTs <- {}
        }

        // withdraw removes a Collectible from the Collection and moves it to the caller
        //
        // Parameters: withdrawID: The ID of the NFT
        // that is to be removed from the Collection
        //
        // returns: @NonFungibleToken.NFT the token that was withdrawn
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {

            // Remove the nft from the Collection
            let token <- self.ownedNFTs.remove(key: withdrawID)
                ?? panic("Cannot withdraw: Collectible does not exist in the collection")

            emit Withdraw(id: token.id, from: self.owner?.address)

            // Return the withdrawn token
            return <- token
        }

        // batchWithdraw withdraws multiple tokens and returns them as a Collection
        //
        // Parameters: collectibleIds: An array of IDs to withdraw
        //
        // Returns: @NonFungibleToken.Collection: A collection that contains
        //                                        the withdrawn collectibles
        //
        pub fun batchWithdraw(collectibleIds: [UInt64]): @Anique.Collection {
            // Create a new empty Collection
            var batchCollection <- create Collection()

            // Iterate through the collectibleIds and withdraw them from the Collection
            for collectibleID in collectibleIds {
                batchCollection.deposit(token: <-self.withdraw(withdrawID: collectibleID))
            }

            // Return the withdrawn tokens
            return <-batchCollection
        }

        // deposit takes a Collectible and adds it to the Collections dictionary
        //
        // Parameters: token: the NFT to be deposited in the collection
        //
        pub fun deposit(token: @NonFungibleToken.NFT) {

            // Cast the deposited token as an chiharasan NFT to make sure
            // it is the correct type
            let token <- token as! @chiharasan.NFT

            // Get the token's ID
            let id = token.id

            // Add the new token to the dictionary
            let oldToken <- self.ownedNFTs[id] <- token

            // Only emit a deposit event if the Collection
            // is in an account's storage
            if self.owner?.address != nil {
                emit Deposit(id: id, to: self.owner?.address)
            }

            // Destroy the empty old token that was "removed"
            destroy oldToken
        }

        // batchDeposit takes a Collection object as an argument
        // and deposits each contained NFT into this Collection
        pub fun batchDeposit(tokens: @Anique.Collection) {

            // Get an array of the IDs to be deposited
            let keys = tokens.getIDs()

            // Iterate through the keys in the collection and deposit each one
            for key in keys {
                self.deposit(token: <-tokens.withdraw(withdrawID: key))
            }

            // Destroy the empty Collection
            destroy tokens
        }

        // getIDs returns an array of the IDs that are in the Collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // contains returns whether ID is in the Collection
        pub fun contains(id: UInt64): Bool {
            return self.ownedNFTs[id] != nil
        }

        // borrowNFT Returns a borrowed reference to a Collectible in the Collection
        // so that the caller can read its ID
        //
        // Parameters: id: The ID of the NFT to get the reference for
        //
        // Returns: A reference to the NFT
        //
        // Note: This only allows the caller to read the ID of the NFT,
        // not any chiharasan specific data. Please use borrowCollectible to
        // read Collectible data.
        //
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowAniqueNFT(id: UInt64): auth &Anique.NFT {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            return nft as! auth &Anique.NFT
        }

        // borrowchiharasanCollectible returns a borrowed reference
        // to an chiharasan Collectible
        pub fun borrowchiharasanCollectible(id: UInt64): auth &NFT {
            pre {
                self.ownedNFTs[id] != nil: "NFT does not exist in the collection!"
            }
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            return nft as! auth &NFT
        }

        // If a transaction destroys the Collection object,
        // All the NFTs contained within are also destroyed!
        //
        destroy() {
            destroy self.ownedNFTs
        }
    }

    // Admin is a special authorization resource that
    // allows the owner to perform important functions to modify the
    // various aspects of the Items, CollectibleDatas, etc.
    //
    pub resource Admin {

        // createItem creates a new Item struct
        // and stores it in the Items dictionary field in the chiharasan smart contract
        //
        // Parameters: metadata: A dictionary mapping metadata titles to their data
        //                       example: {"Title": "Excellent Anime", "Author": "John Smith"}
        //
        // Returns: the ID of the new Item object
        //
        pub fun createItem(metadata: {String: String}): UInt32 {
            // Create the new Item
            var newItem <- create Item(metadata: metadata)
            let itemId = newItem.itemID

            // Store it in the contract storage
            chiharasan.items[newItem.itemID] <-! newItem

            return itemId
        }

        // borrowItem returns a reference to a Item in the chiharasan
        // contract so that the admin can call methods on it
        //
        // Parameters: itemID: The ID of the Item that you want to
        // get a reference to
        //
        // Returns: A reference to the Item with all of the fields
        // and methods exposed
        //
        pub fun borrowItem(itemID: UInt32): &Item {
            pre {
                chiharasan.items[itemID] != nil: "Cannot borrow Item: The Item doesn't exist"
            }

            return (&chiharasan.items[itemID] as &Item?)!
        }

        // createNewAdmin creates a new Admin resource
        //
        pub fun createNewAdmin(): @Admin {
            return <-create Admin()
        }
    }

    // -----------------------------------------------------------------------
    // chiharasan contract-level function definitions
    // -----------------------------------------------------------------------

    // createEmptyCollection creates a new, empty Collection object so that
    // a user can store it in their account storage.
    // Once they have a Collection in their storage, they are able to receive
    // Collectibles in transactions.
    //
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <-create chiharasan.Collection()
    }

    // getNumCollectiblesInItem return the number of Collectibles that have been
    //                        minted from a certain Item.
    //
    // Parameters: itemID: The id of the Item that is being searched
    //
    // Returns: The total number of Collectibles
    //          that have been minted from a Item
    pub fun getNumCollectiblesInItem(itemID: UInt32): UInt32 {
        let item = (&chiharasan.items[itemID] as &Item?)!
        return item.numberMintedPerItem
    }

    // -----------------------------------------------------------------------
    // chiharasan initialization function
    // -----------------------------------------------------------------------
    //
    init() {
        // Initialize contract fields
        self.items <- {}
        self.nextItemID = 1
        self.totalSupply = 0

        self.collectionStoragePath     = /storage/chiharasanCollection
        self.collectionPublicPath      =  /public/chiharasanCollection
        self.collectionPrivatePath     = /private/chiharasanCollection
        self.adminStoragePath          = /storage/chiharasanAdmin
        self.saleCollectionStoragePath = /storage/chiharasanSaleCollection
        self.saleCollectionPublicPath  =  /public/chiharasanSaleCollection

        // Put a new Collection in storage
        self.account.save<@Collection>(<- create Collection(), to: self.collectionStoragePath)

        // Create a public capability for the Collection
        self.account.link<&{CollectionPublic}>(self.collectionPublicPath, target: self.collectionStoragePath)

        // Put the Admin in storage
        self.account.save<@Admin>(<- create Admin(), to: self.adminStoragePath)

        emit ContractInitialized()
    }
}
"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import AFLNFT from 0x8f9231920da9af6d
import FiatToken from 0xb19436aae4d94622
import StorageHelper from 0x8f9231920da9af6d

pub contract AFLMarketplace {
    // Capability to receive USDC marketplace fee from each sale
    access(contract) var marketplaceWallet: Capability<&FiatToken.Vault{FungibleToken.Receiver}>
     // Market fee percentage
    access(contract) var cutPercentage : UFix64

    // commented out for testnet
    // Storage Path for Admin resource
    // pub let AdminStoragePath: StoragePath
    // Storage Path for SaleCollection resource
    // pub let SaleCollectionStoragePath: StoragePath
    // Storage Path for SalePublic resource
    // pub let SaleCollectionPublicPath: PublicPath

    // Emitted when a new AFLNFT is put up for sale
    pub event ForSale(id: UInt64, price: UFix64, owner: Address?)
    // Emitted when the price of an NFT is changed
    pub event PriceChanged(id: UInt64, newPrice: UFix64, owner: Address?)
    // Emitted when a token is purchased
    pub event TokenPurchased(id: UInt64, price: UFix64, owner: Address?, to: Address?)
    // Emitted when a seller withdraws their NFT from the sale
    pub event SaleCanceled(id: UInt64, owner: Address?)
    // Emitted when the cut percentage of the sale has been changed by the owner
    pub event CutPercentageChanged(newPercent: UFix64, owner: Address?)
    // Emitted when a new sale collection is created
    pub event SaleCollectionCreated(owner: Address?)
    // Emitted when marketplace wallet is changed
    pub event MarketplaceWalletChanged(address: Address)


    // SalePublic
    //
    // The interface that a user can publish a capability to their sale
    // to allow others to access their sale
    pub resource interface SalePublic {
        pub fun purchase(tokenID: UInt64, recipientCap: Capability<&{AFLNFT.AFLNFTCollectionPublic}>, buyTokens: @FungibleToken.Vault)
        pub fun getPrice(tokenID: UInt64): UFix64?
        pub fun getIDs(): [UInt64]
        pub fun getDetails(): {UInt64: UFix64}
        pub fun borrowMoment(id: UInt64): &AFLNFT.NFT? {
            // If the result isn't nil, the id of the returned reference
            // should be the same as the argument to the function
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow Moment reference: The ID of the returned reference is incorrect"
            }
        }
    }

    // SaleCollection
    //
    // NFT Collection object that allows a user to put their NFT up for sale
    // where others can send fungible tokens to purchase it
    //
    pub resource SaleCollection: SalePublic {

        // Dictionary of the NFTs that the user is putting up for sale
        pub var forSale: @{UInt64: AFLNFT.NFT}
        // Dictionary of the flow prices for each NFT by ID
        access(self) var prices: {UInt64: UFix64}

        // The fungible token vault of the owner of this sale.
        // When someone buys a token, this resource can deposit
        // tokens into their account.
        access(account) let ownerVault: Capability<&FiatToken.Vault{FungibleToken.Receiver}>

        init (vault: Capability<&FiatToken.Vault{FungibleToken.Receiver}>) {
            pre {
                // Check that both capabilities are for fungible token Vault receivers
                vault.check():
                    "Owner's Receiver Capability is invalid!"
            }

            // create an empty collection to store the moments that are for sale
            self.forSale <-{}
            self.ownerVault = vault
            // prices are initially empty because there are no moments for sale
            self.prices = {}
        }

        // listForSale lists an NFT for sale in this sale collection
        // at the specified price
        //
        // Parameters: token: The NFT to be put up for sale
        //             price: The price of the NFT
        pub fun listForSale(token: @AFLNFT.NFT, price: UFix64) {

            // get the ID of the token
            let id = token.id

            // get the templateID
            let templateID = AFLNFT.getNFTData(nftId: id).templateId

            let teamBadgeIds: [UInt64] = [22436, 22437, 22438, 22439, 22440, 22441, 22442, 22443, 22444, 22445, 22446, 22447, 22448, 22449, 22450, 22451, 22452, 22453] // mainnet templateIds for team badges
            assert(!teamBadgeIds.contains(templateID), message: "Team Badges cannot be listed for sale.")

            // Set the token's price
            self.prices[token.id] = price

            let oldToken <- self.forSale[id] <- token

            destroy oldToken

            emit ForSale(id: id, price: price, owner: self.owner?.address)
        }

        // Withdraw removes a moment that was listed for sale
        // and clears its price
        //
        // Parameters: tokenID: the ID of the token to withdraw from the sale
        //
        // Returns: @AFLNFT.NFT: The nft that was withdrawn from the sale
        pub fun withdraw(tokenID: UInt64): @AFLNFT.NFT {
            // remove the price
            self.prices.remove(key: tokenID)
            // remove and return the token
            let token <- self.forSale.remove(key: tokenID) ?? panic("missing NFT")

            emit SaleCanceled(id: tokenID, owner: self.owner!.address)
            return <-token
        }

        // purchase lets a user send tokens to purchase an NFT that is for sale
        // the purchased NFT is returned to the transaction context that called it
        //
        // Parameters: tokenID: the ID of the NFT to purchase
        //             butTokens: the fungible tokens that are used to buy the NFT

        pub fun purchase(tokenID: UInt64, recipientCap: Capability<&{AFLNFT.AFLNFTCollectionPublic}>, buyTokens: @FungibleToken.Vault) {
            pre {
                buyTokens.getType() == self.ownerVault.borrow()!.getType():
                    "The tokens being sent to purchase the NFT must be the same type as the listing"
                self.forSale[tokenID] != nil && self.prices[tokenID] != nil:
                    "No token matching this ID for sale!"
                buyTokens.balance >= (self.prices[tokenID] ?? UFix64(0)):
                    "Not enough tokens to buy the NFT!"
            }

            StorageHelper.topUpAccount(address: recipientCap.address)

            let recipient = recipientCap.borrow()!
            // Read the price for the token
            let salePrice = self.prices[tokenID]!

            // Set the price for the token to nil
            self.prices[tokenID] = nil

            let saleOwnerVaultRef = self.ownerVault.borrow() ?? panic("could not borrow reference to the owner vault")

            // remove price
            self.prices.remove(key: tokenID)
            // remove and return the token
            let token <- self.forSale.remove(key: tokenID) ?? panic("missing NFT")

            let marketplaceWallet = AFLMarketplace.marketplaceWallet.borrow() ?? panic("Couldn't borrow Vault reference")
            let marketplaceAmount = salePrice * AFLMarketplace.cutPercentage

            // withdraw and deposit marketplace fee
            let tempMarketplaceWallet <- buyTokens.withdraw(amount: marketplaceAmount)
            marketplaceWallet.deposit(from: <- tempMarketplaceWallet)

            // deposit remaining tokens to sale owner and transfer nft to recipient
            saleOwnerVaultRef.deposit(from: <- buyTokens)
            recipient.deposit(token: <- token)

            emit TokenPurchased(id: tokenID, price: salePrice, owner: self.owner?.address, to: recipient.owner!.address)
        }

        // changePrice changes the price of a token that is currently for sale
        //
        // Parameters: tokenID: The ID of the NFT's price that is changing
        //             newPrice: The new price for the NFT
        pub fun changePrice(tokenID: UInt64, newPrice: UFix64) {
            pre {
                self.prices[tokenID] != nil: "Cannot change the price for a token that is not for sale"
            }
            // Set the new price
            self.prices[tokenID] = newPrice

            emit PriceChanged(id: tokenID, newPrice: newPrice, owner: self.owner?.address)
        }


        // getPrice returns the price of a specific token in the sale
        //
        // Parameters: tokenID: The ID of the NFT whose price to get
        //
        // Returns: UFix64: The price of the token
        pub fun getPrice(tokenID: UInt64): UFix64? {
            return self.prices[tokenID]
        }

        /// getDetails returns the prices of all tokens listed for sale
        pub fun getDetails(): {UInt64: UFix64} {
            return self.prices
        }

        // getIDs returns an array of token IDs that are for sale
        pub fun getIDs(): [UInt64] {
            return self.forSale.keys
        }

        // borrowMoment Returns a borrowed reference to a Moment in the collection
        // so that the caller can read data from it
        //
        // Parameters: id: The ID of the moment to borrow a reference to
        //
        // Returns: &AFL.NFT? Optional reference to a moment for sale
        //                        so that the caller can read its data
        //
        pub fun borrowMoment(id: UInt64): &AFLNFT.NFT? {
            if self.forSale[id] != nil{
                return (&self.forSale[id] as &AFLNFT.NFT?)!
            }
            else {
                return  nil
            }
        }

        // If the sale collection is destroyed,
        // destroy the tokens that are for sale inside of it
        destroy() {
            destroy self.forSale
        }
    }

    // createCollection returns a new collection resource to the caller
    pub fun createSaleCollection(ownerVault: Capability<&FiatToken.Vault{FungibleToken.Receiver}>): @SaleCollection {
        emit SaleCollectionCreated(owner: ownerVault.address)
        return <- create SaleCollection(vault: ownerVault)
    }

    pub resource AFLMarketAdmin {
        // changePercentage changes the cut percentage of the tokens that are for sale
        //
        // Parameters: newPercent: The new cut percentage for the sale
        pub fun changePercentage(_ newPercent: UFix64) {
            pre {
                newPercent <= 1.0: "Cannot set cut percentage to greater than 100%"
            }
            AFLMarketplace.cutPercentage = newPercent
            emit CutPercentageChanged(newPercent: newPercent, owner: self.owner!.address)
        }

        pub fun changeMarketplaceWallet(_ newCap: Capability<&FiatToken.Vault{FungibleToken.Receiver}>) {
            AFLMarketplace.marketplaceWallet = newCap
            emit MarketplaceWalletChanged(address: newCap.address)
        }
    }

    pub fun getPercentage(): UFix64 {
        return AFLMarketplace.cutPercentage
    }

    init(){
        self.cutPercentage = 0.10

        // commented out for testnet update
        // self.AdminStoragePath = /storage/AFLMarketAdmin
        // self.SaleCollectionStoragePath = /storage/AFLMarketplaceSaleCollection
        // self.SaleCollectionPublicPath = /public/AFLMarketplaceSaleCollection

        self.marketplaceWallet = self.account.getCapability<&FiatToken.Vault{FungibleToken.Receiver}>(/public/FiatTokenVaultReceiver)
        // self.account.save(<- create AFLMarketAdmin(), to: AFLMarketplace.AdminStoragePath)
        self.account.save(<- create AFLMarketAdmin(), to: /storage/AFLMarketAdmin)
    }
}
"
-------
"import GameEngine from 0x9d041d36947924c0

pub contract GamePieces {
  /*
  pub struct SideScrollPlayer: GameEngine.GameObject {
    pub var doesTick: Bool
    pub var lastMoveTick: UInt64?

    pub fun tick(
      input: GameEngine.GameTickInput,
      callbacks: {String: AnyStruct}
    ): [[AnyStruct{GameEngine.GameObject}?]] {
      let position: [Int] = (callbacks["getPosition"] as! ((): [Int])?)!()
      let curRow = position[0]!
      let curCol = position[1]!

      var direction: String? = nil
      for e in input.events {
        if (e.type == "right") {
          direction = e.type
        }
        if (e.type == "left") {
          direction = e.type
        }
      }

      var newGameboard = input.gameboard
      var canMove = true
      if (self.lastMoveTick != nil && input.tickCount - self.lastMoveTick! < 1) {
        canMove = false
      }
      if (canMove && direction != nil) {
        var newPlayer = SideScrollPlayer()
        newPlayer.doesTick = false
        let myRow = newGameboard[curRow]!
        if (direction == "left" && curCol > 0) {
          myRow[curCol - 1] = newPlayer
          myRow[curCol] = nil
        }
        if (direction == "right" && curCol + 1 < myRow.length) {
          myRow[curCol + 1] = newPlayer
          myRow[curCol] = nil
        }
        newGameboard[curRow] = myRow
        self.lastMoveTick = input.tickCount
      }
      return newGameboard
    }

    init() {
      self.doesTick = true
      self.lastMoveTick = nil
    }
  }

  pub struct Asteroid: GameEngine.GameObject {
    pub var doesTick: Bool

    pub fun tick(
      input: GameEngine.GameTickInput,
      callbacks: {String: AnyStruct}
    ): [[AnyStruct{GameEngine.GameObject}?]] {
      let position: [Int] = (callbacks["getPosition"] as! ((): [Int])?)!()
      let curRow = position[0]
      let curCol = position[1]

      let curGameboard = input.gameboard
      let newRow = curRow + 1
      let newCol = curCol
      let newGameboard = curGameboard

      // Replace current asteroid row with nil
      var oldRow = newGameboard[curRow]!
      oldRow[curCol] = nil
      newGameboard[curRow] = oldRow

      // Add new asteroid row if we aren't past the height of the board
      if (newRow < newGameboard.length) {
        var movedRow = newGameboard[newRow]!
        let newAsteroid = Asteroid()
        newAsteroid.doesTick = false
        movedRow[newCol] = newAsteroid
        newGameboard[newRow] = movedRow
      }

      return newGameboard
    }

    init() {
      self.doesTick = true
    }
  }

  pub struct Consumable: GameEngine.GameObject {
    pub var doesTick: Bool

    pub fun tick(
      input: GameEngine.GameTickInput,
      callbacks: {String: AnyStruct}
    ): [[AnyStruct{GameEngine.GameObject}?]] {
      let position: [Int] = (callbacks["getPosition"] as! ((): [Int])?)!()
      let curRow = position[0]
      let curCol = position[1]

      return input.gameboard
    }

    init() {
      self.doesTick = true
    }
  }

  pub struct SnakeTail: GameEngine.GameObject {
    pub var doesTick: Bool

    pub fun tick(
      input: GameEngine.GameTickInput,
      callbacks: {String: AnyStruct}
    ): [[AnyStruct{GameEngine.GameObject}?]] {
      let position: [Int] = (callbacks["getPosition"] as! ((): [Int])?)!()
      let curRow = position[0]
      let curCol = position[1]

      return input.gameboard
    }

    init() {
      self.doesTick = true
    }
  }
  */
}"
-------
"/// # Capability Factory
///
/// This contract defines a Factory interface and a Manager resource to contain Factory implementations, as well as a
/// Getter interface for retrieval of contained Factories.
///
/// A Factory is defines a method getCapability() which defines the retrieval pattern of a Capability from a given
/// account at the specified path. This pattern arose out of a need to retrieve arbitrary & castable Capabilities from
/// an account under the static typing constraints inherent to Cadence.
///
/// The Manager resource is a container for Factories, and implements the Getter interface.
///
/// **Note:** It's generally an anti-pattern to pass around AuthAccount references; however, the need for castable
/// Capabilities is critical to the use case of Hybrid Custody. It's advised to use Factories sparingly and only for
/// cases where Capabilities must be castable by the caller.
///
pub contract CapabilityFactory {

    pub let StoragePath: StoragePath
    pub let PrivatePath: PrivatePath
    pub let PublicPath: PublicPath

    /// Factory structures a common interface for Capability retrieval from a given account at a specified path
    ///
    pub struct interface Factory {
        pub fun getCapability(acct: &AuthAccount, path: CapabilityPath): Capability
    }

    /// Getter defines an interface for retrieval of a Factory if contained within the implementing resource
    ///
    pub resource interface Getter {
        pub fun getSupportedTypes(): [Type]
        pub fun getFactory(_ t: Type): {CapabilityFactory.Factory}?
    }

    /// Manager is a resource that contains Factories and implements the Getter interface for retrieval of contained
    /// Factories
    ///
    pub resource Manager: Getter {
        /// Mapping of Factories indexed on Type of Capability they retrieve
        pub let factories: {Type: {CapabilityFactory.Factory}}

        /// Retrieves a list of Types supported by contained Factories
        ///
        /// @return List of Types supported by the Manager
        ///
        pub fun getSupportedTypes(): [Type] {
            return self.factories.keys
        }

        /// Retrieves a Factory from the Manager, returning it or nil if it doesn't exist
        ///
        /// @param t: Type the Factory is indexed on
        ///
        pub fun getFactory(_ t: Type): {CapabilityFactory.Factory}? {
            return self.factories[t]
        }

        /// Adds a Factory to the Manager, conditioned on the Factory not already existing
        ///
        /// @param t: Type of Capability the Factory retrieves
        /// @param f: Factory to add
        ///
        pub fun addFactory(_ t: Type, _ f: {CapabilityFactory.Factory}) {
            pre {
                !self.factories.containsKey(t): "Factory of given type already exists"
            }
            self.factories[t] = f
        }

        /// Updates a Factory in the Manager, adding if it didn't already exist
        ///
        /// @param t: Type of Capability the Factory retrieves
        /// @param f: Factory to replace existing Factory
        ///
        pub fun updateFactory(_ t: Type, _ f: {CapabilityFactory.Factory}) {
            self.factories[t] = f
        }

        /// Removes a Factory from the Manager, returning it or nil if it didn't exist
        ///
        /// @param t: Type the Factory is indexed on
        ///
        pub fun removeFactory(_ t: Type): {CapabilityFactory.Factory}? {
            return self.factories.remove(key: t)
        }

        init () {
            self.factories = {}
        }
    }

    /// Creates a Manager resource
    ///
    /// @return Manager resource
    pub fun createFactoryManager(): @Manager {
        return <- create Manager()
    }

    init() {
        let identifier = "CapabilityFactory_".concat(self.account.address.toString())
        self.StoragePath = StoragePath(identifier: identifier)!
        self.PrivatePath = PrivatePath(identifier: identifier)!
        self.PublicPath = PublicPath(identifier: identifier)!
    }
}"
-------
"import CapabilityFactory from 0xd8a7e05a7ac670c0
import NonFungibleToken from 0x1d7e57aa55817448

pub contract NFTProviderFactory {
    pub struct Factory: CapabilityFactory.Factory {
        pub fun getCapability(acct: &AuthAccount, path: CapabilityPath): Capability {
            return acct.getCapability<&{NonFungibleToken.Provider}>(path)
        }
    }
}"
-------
"/*
MomentableArt

This is the contract for MomentableArt NFTs!

This was implemented using Niftory interfaces. For full details on how this
contract functions, please see the Niftory and NFTRegistry contracts.

*/

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import ViewResolver from 0x1d7e57aa55817448

import MutableMetadata from 0x7ec1f607f0872a9e
import MutableMetadataTemplate from 0x7ec1f607f0872a9e
import MutableMetadataSet from 0x7ec1f607f0872a9e
import MutableMetadataSetManager from 0x7ec1f607f0872a9e
import MetadataViewsManager from 0x7ec1f607f0872a9e

import NiftoryNonFungibleToken from 0x7ec1f607f0872a9e
import NiftoryNFTRegistry from 0x7ec1f607f0872a9e

import NiftoryMetadataViewsResolvers from 0x7ec1f607f0872a9e
import NiftoryNonFungibleTokenProxy from 0x7ec1f607f0872a9e

pub contract MomentableArt: NonFungibleToken, ViewResolver {

  // ========================================================================
  // Constants
  // ========================================================================

  // Suggested paths where collection could be stored
  pub let COLLECTION_PRIVATE_PATH: PrivatePath
  pub let COLLECTION_PUBLIC_PATH: PublicPath
  pub let COLLECTION_STORAGE_PATH: StoragePath

  // Accessor token to be used with NiftoryNFTRegistry to retrieve
  // meta-information about this NFT project
  pub let REGISTRY_ADDRESS: Address
  pub let REGISTRY_BRAND: String

  // ========================================================================
  // Attributes
  // ========================================================================

  // Arbitrary metadata for this NFT contract
  pub var metadata: AnyStruct?

  // Number of NFTs created
  pub var totalSupply: UInt64

  // ========================================================================
  // Contract Events
  // ========================================================================

  // This contract was initialized
  pub event ContractInitialized()

  // A withdrawal of NFT `id` has occurred from the `from` Address
  pub event Withdraw(id: UInt64, from: Address?)

  // A deposit of an NFT `id` has occurred to the `to` Address
  pub event Deposit(id: UInt64, to: Address?)

  ///////////////////////////////////////////////////////////////////////////

  // Contract metadata was modified
  pub event ContractMetadataUpdated()

  // Metadata Views Manager was locked
  pub event MetadataViewsManagerLocked()

  // Metadata Views Resolver was added
  pub event MetadataViewsResolverAdded(type: Type)

  // Metadata Views Resolver was removed
  pub event MetadataViewsResolverRemoved(type: Type)

  // Set Manager Name or Description updated
  pub event SetManagerMetadataUpdated()

  // Set added to Set Manager
  pub event SetAddedToSetManager(setID: Int)

  ///////////////////////////////////////////////////////////////////////////

  // Set `setId` was locked (no new templates can be added)
  pub event SetLocked(setId: Int)

  // The metadata for Set `setId` was locked and cannot be modified
  pub event SetMetadataLocked(setId: Int)

  // Set `setId` was modified
  pub event SetMetadataModified(setId: Int)

  // A new Template `templateId` was added to Set `setId`
  pub event TemplateAddedToSet(setId: Int, templateId: Int)

  ///////////////////////////////////////////////////////////////////////////

  // Template `templateId` was locked in Set `setId`, which disables minting
  pub event TemplateLocked(setId: Int, templateId: Int)

  // Template `templateId` of Set `setId` had it's maxMint set to `maxMint`
  pub event TemplateMaxMintSet(setId: Int, templateId: Int, maxMint: UInt64)

  // Template `templateId` of Set `setId` has minted NFT with serial `serial`
  pub event NFTMinted(id: UInt64, setId: Int, templateId: Int, serial: UInt64)

  ///////////////////////////////////////////////////////////////////////////

  // The metadata for NFT/Template `templateId` of Set `setId` was locked
  pub event NFTMetadataLocked(setId: Int, templateId: Int)

  // The metadata for NFT/Template `templateId` of Set `setId` was modified
  pub event NFTMetadataModified(setId: Int, templateId: Int)

  ///////////////////////////////////////////////////////////////////////////

  // NFT `serial` from Template `templateId` of Set `setId` was burned
  pub event NFTBurned(setId: Int, templateId: Int, serial: UInt64)

  // ========================================================================
  // NFT
  // ========================================================================

  pub resource NFT:
    NonFungibleToken.INFT,
    MetadataViews.Resolver,
    NiftoryNonFungibleToken.NFTPublic
  {
    pub let id: UInt64
    pub let setId: Int
    pub let templateId: Int
    pub let serial: UInt64

    pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
      return MomentableArt.contract()
    }

    pub fun set(): &MutableMetadataSet.Set{MutableMetadataSet.Public} {
      return self
        .contract()
        .getSetManagerPublic()
        .getSet(self.setId)
    }

    pub fun metadata(): &MutableMetadata.Metadata{MutableMetadata.Public} {
      return self
        .set()
        .getTemplate(self.templateId)
        .metadata()
    }

    pub fun getViews(): [Type] {
      return self
        .contract()
        .getMetadataViewsManagerPublic()
        .getViews()
    }

    pub fun resolveView(_ view: Type): AnyStruct? {
      let nftRef = &self as &{NiftoryNonFungibleToken.NFTPublic}
      return self
        .contract()
        .getMetadataViewsManagerPublic()
        .resolveView(view: view, nftRef: nftRef)
    }

    init(setId: Int, templateId: Int, serial: UInt64) {
      self.id = MomentableArt.totalSupply
      MomentableArt.totalSupply =
        MomentableArt.totalSupply + 1
      self.setId = setId
      self.templateId = templateId
      self.serial = serial
    }

    destroy() {
      emit NFTBurned(
        setId: self.setId,
        templateId: self.templateId,
        serial: self.serial
      )
    }
  }

  // ========================================================================
  // Collection
  // ========================================================================

  pub resource Collection:
    NonFungibleToken.Provider,
    NonFungibleToken.Receiver,
    NonFungibleToken.CollectionPublic,
    MetadataViews.ResolverCollection,
    NiftoryNonFungibleToken.CollectionPublic,
    NiftoryNonFungibleToken.CollectionPrivate
  {
    pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

    pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
      return MomentableArt.contract()
    }

    pub fun getIDs(): [UInt64] {
      return self.ownedNFTs.keys
    }

    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
      pre {
        self.ownedNFTs[id] != nil : "NFT "
          .concat(id.toString())
          .concat(" does not exist in collection.")
      }
      return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
    }

    pub fun borrow(id: UInt64): &NFT{NiftoryNonFungibleToken.NFTPublic} {
      pre {
        self.ownedNFTs[id] != nil : "NFT does not exist in collection."
      }
      let nftRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let fullNft = nftRef as! &NFT
      return fullNft
    }

    pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {
      pre {
        self.ownedNFTs[id] != nil : "NFT does not exist in collection."
      }
      let nftRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let fullNft = nftRef as! &NFT
      return fullNft
    }

    pub fun deposit(token: @NonFungibleToken.NFT) {
      let token <- token as! @MomentableArt.NFT
      let id: UInt64 = token.id
      let oldToken <- self.ownedNFTs[id] <- token
      emit Deposit(id: id, to: self.owner?.address)
      destroy oldToken
    }

    pub fun depositBulk(tokens: @[NonFungibleToken.NFT]) {
      while tokens.length > 0 {
        let token <- tokens.removeLast() as! @MomentableArt.NFT
        self.deposit(token: <-token)
      }
      destroy tokens
    }

    pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
      pre {
        self.ownedNFTs[withdrawID] != nil
          : "NFT "
            .concat(withdrawID.toString())
            .concat(" does not exist in collection.")
      }
      let token <-self.ownedNFTs.remove(key: withdrawID)!
      emit Withdraw(id: token.id, from: self.owner?.address)
      return <-token
    }

    pub fun withdrawBulk(withdrawIDs: [UInt64]): @[NonFungibleToken.NFT] {
      let tokens: @[NonFungibleToken.NFT] <- []
      while withdrawIDs.length > 0 {
        tokens.append(<- self.withdraw(withdrawID: withdrawIDs.removeLast()))
      }
      return <-tokens
    }

    init() {
      self.ownedNFTs <- {}
    }

    destroy() {
      destroy self.ownedNFTs
    }
  }

  pub fun createEmptyCollection(): @Collection {
    return <-create Collection()
  }

  // ========================================================================
  // Manager
  // ========================================================================

  pub resource Manager:
    NiftoryNonFungibleToken.ManagerPublic,
    NiftoryNonFungibleToken.ManagerPrivate
  {
    // ========================================================================
    // Public
    // ========================================================================

    pub fun metadata(): AnyStruct? {
      return MomentableArt.metadata
    }

    pub fun getSetManagerPublic():
      &MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public}
    {
      return NiftoryNFTRegistry
        .getSetManagerPublic(
          MomentableArt.REGISTRY_ADDRESS,
          MomentableArt.REGISTRY_BRAND
        )
    }

    pub fun getMetadataViewsManagerPublic():
      &MetadataViewsManager.Manager{MetadataViewsManager.Public}
    {
      return NiftoryNFTRegistry
        .getMetadataViewsManagerPublic(
          MomentableArt.REGISTRY_ADDRESS,
          MomentableArt.REGISTRY_BRAND
        )
    }

    pub fun getNFTCollectionData(): MetadataViews.NFTCollectionData {
      return NiftoryNFTRegistry
        .buildNFTCollectionData(
          MomentableArt.REGISTRY_ADDRESS,
          MomentableArt.REGISTRY_BRAND,
          (fun (): @NonFungibleToken.Collection {
            return <-MomentableArt.createEmptyCollection()
          })
        )
    }

    // ========================================================================
    // Contract metadata
    // ========================================================================

    pub fun modifyContractMetadata(): auth &AnyStruct {
      emit ContractMetadataUpdated()
      let maybeMetadata = MomentableArt.metadata
      if maybeMetadata == nil {
        let blankMetadata: {String: String} = {}
        MomentableArt.metadata = blankMetadata
      }
      return (&MomentableArt.metadata as auth &AnyStruct?)!
    }

    pub fun replaceContractMetadata(_ metadata: AnyStruct?) {
      emit ContractMetadataUpdated()
      MomentableArt.metadata = metadata
    }

    // ========================================================================
    // Metadata Views Manager
    // ========================================================================

    access(self) fun _getMetadataViewsManagerPrivate():
      &MetadataViewsManager.Manager{MetadataViewsManager.Private}
    {
      let record =
        NiftoryNFTRegistry.getRegistryRecord(
          MomentableArt.REGISTRY_ADDRESS,
          MomentableArt.REGISTRY_BRAND
        )
      let manager =
        MomentableArt.account
          .getCapability<&MetadataViewsManager.Manager{MetadataViewsManager.Private}>(
            record.metadataViewsManager.paths.private
          ).borrow()!
      return manager
    }

    pub fun lockMetadataViewsManager() {
      self._getMetadataViewsManagerPrivate().lock()
      emit MetadataViewsManagerLocked()
    }

    pub fun setMetadataViewsResolver(
      _ resolver: AnyStruct{MetadataViewsManager.Resolver}
    ) {
      self._getMetadataViewsManagerPrivate().addResolver(resolver)
      emit MetadataViewsResolverAdded(type: resolver.type)
    }

    pub fun removeMetadataViewsResolver(_ type: Type) {
      self._getMetadataViewsManagerPrivate().removeResolver(type)
      emit MetadataViewsResolverRemoved(type: type)
    }

    // ========================================================================
    // Set Manager
    // ========================================================================

    access(self) fun _getSetManagerPrivate():
      &MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public, MutableMetadataSetManager.Private}
    {
      let record =
        NiftoryNFTRegistry.getRegistryRecord(
          MomentableArt.REGISTRY_ADDRESS,
          MomentableArt.REGISTRY_BRAND
        )
      let setManager =
        MomentableArt.account
          .getCapability<&MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public, MutableMetadataSetManager.Private}>(
            record.setManager.paths.private
          ).borrow()!
      return setManager
    }

    pub fun setMetadataManagerName(_ name: String) {
      self._getSetManagerPrivate().setName(name)
      emit SetManagerMetadataUpdated()
    }

    pub fun setMetadataManagerDescription(_ description: String) {
      self._getSetManagerPrivate().setDescription(description)
      emit SetManagerMetadataUpdated()
    }

    pub fun addSet(_ set: @MutableMetadataSet.Set) {
      let setManager = self._getSetManagerPrivate()
      let setId = setManager.numSets()
      setManager.addSet(<-set)
      emit SetAddedToSetManager(setID: setId)
    }

    // ========================================================================
    // Set
    // ========================================================================

    access(self) fun _getSetMutable(_ setId: Int):
      &MutableMetadataSet.Set{MutableMetadataSet.Private,
        MutableMetadataSet.Public} {
      return self._getSetManagerPrivate().getSetMutable(setId)
    }

    pub fun lockSet(setId: Int) {
      self._getSetMutable(setId).lock()
      emit SetLocked(setId: setId)
    }

    pub fun lockSetMetadata(setId: Int) {
      self._getSetMutable(setId).metadataMutable().lock()
      emit SetMetadataLocked(setId: setId)
    }

    pub fun modifySetMetadata(setId: Int): auth &AnyStruct {
      emit SetMetadataModified(setId: setId)
      return self._getSetMutable(setId).metadataMutable().getMutable()
    }

    pub fun replaceSetMetadata(setId: Int, new: AnyStruct) {
      self._getSetMutable(setId).metadataMutable().replace(new)
      emit SetMetadataModified(setId: setId)
    }

    pub fun addTemplate(
      setId: Int,
      template: @MutableMetadataTemplate.Template
    ) {
      let set = self._getSetMutable(setId)
      let templateId = set.numTemplates()
      set.addTemplate(<-template)
      emit TemplateAddedToSet(setId: setId, templateId: templateId)
    }

    // ========================================================================
    // Minting
    // ========================================================================

    access(self) fun _getTemplateMutable(_ setId: Int, _ templateId: Int):
      &MutableMetadataTemplate.Template{MutableMetadataTemplate.Public,
        MutableMetadataTemplate.Private} {
      return self._getSetMutable(setId).getTemplateMutable(templateId)
    }

    pub fun lockTemplate(setId: Int, templateId: Int) {
      self._getTemplateMutable(setId, templateId).lock()
      emit TemplateLocked(setId: setId, templateId: templateId)
    }

    pub fun setTemplateMaxMint(setId: Int, templateId: Int, max: UInt64) {
      self._getTemplateMutable(setId, templateId).setMaxMint(max)
      emit TemplateMaxMintSet(
        setId: setId,
        templateId: templateId,
        maxMint: max
      )
    }

    pub fun mint(setId: Int, templateId: Int): @NonFungibleToken.NFT {
      let template = self._getTemplateMutable(setId, templateId)
      template.registerMint()
      let serial = template.minted()
      let nft <-create NFT(
        setId: setId,
        templateId: templateId,
        serial: serial
      )
      emit NFTMinted(
        id: nft.id,
        setId: setId,
        templateId: templateId,
        serial: serial
      )
      return <-nft
    }

    pub fun mintBulk(
      setId: Int,
      templateId: Int,
      numToMint: UInt64,
    ): @[NonFungibleToken.NFT] {
      pre {
        numToMint > 0: "Must mint at least one NFT"
      }
      let template = self._getTemplateMutable(setId, templateId)
      let nfts: @[NonFungibleToken.NFT] <- []
      var leftToMint = numToMint
      while leftToMint > 0 {
        template.registerMint()
        let serial = template.minted()
        let nft <-create NFT(
          setId: setId,
          templateId: templateId,
          serial: serial
        )
        emit NFTMinted(
          id: nft.id,
          setId: setId,
          templateId: templateId,
          serial: serial
        )
        nfts.append(<-nft)
        leftToMint = leftToMint - 1
      }
      return <-nfts
    }

    // ========================================================================
    // NFT metadata
    // ========================================================================

    access(self) fun _getNFTMetadata(_ setId: Int, _ templateId: Int):
      &MutableMetadata.Metadata{MutableMetadata.Public,
        MutableMetadata.Private
      } {
        return self._getTemplateMutable(setId, templateId).metadataMutable()
    }

    pub fun lockNFTMetadata(setId: Int, templateId: Int) {
      self._getNFTMetadata(setId, templateId).lock()
      emit NFTMetadataLocked(setId: setId, templateId: templateId)
    }

    pub fun modifyNFTMetadata(setId: Int, templateId: Int): auth &AnyStruct {
      emit NFTMetadataModified(setId: setId, templateId: templateId)
      return self._getNFTMetadata(setId, templateId).getMutable()
    }

    pub fun replaceNFTMetadata(setId: Int, templateId: Int, new: AnyStruct) {
      self._getNFTMetadata(setId, templateId).replace(new)
      emit NFTMetadataModified(setId: setId, templateId: templateId)
    }
  }

  // ========================================================================
  // Contract functions
  // ========================================================================

  pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
    return NiftoryNFTRegistry
      .getNFTManagerPublic(
        MomentableArt.REGISTRY_ADDRESS,
        MomentableArt.REGISTRY_BRAND
      )
  }

  pub fun getViews(): [Type] {
    let possibleViews = [
      Type<MetadataViews.NFTCollectionDisplay>(),
      Type<MetadataViews.ExternalURL>()
    ]
    let views: [Type] = [Type<MetadataViews.NFTCollectionData>()]

    let viewManager = self.contract().getMetadataViewsManagerPublic()
    for view in possibleViews {
      if viewManager.inspectView(view: view) != nil {
        views.append(view)
      }
    }
    return views
  }

  pub fun resolveView(_ view: Type): AnyStruct? {
    let viewManager = self.contract().getMetadataViewsManagerPublic()
    switch view {

      case Type<MetadataViews.NFTCollectionData>():
        return self.contract().getNFTCollectionData()

      case Type<MetadataViews.NFTCollectionDisplay>():
        let maybeView = viewManager.inspectView(
          view: Type<MetadataViews.NFTCollectionDisplay>()
        )
        if maybeView == nil {
          return nil
        }
        let view = maybeView!

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver

          // External URL
          let externalURL = MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultExternalURLPrefix,
              uri: resolver.defaultExternalURL
            )
          )

          // Square image
          let squareImageURL = NiftoryMetadataViewsResolvers._prefixUri(
            allowedPrefixes:
              NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
            default: resolver.defaultSquareImagePrefix,
            uri: resolver.defaultSquareImage
          )
          let squareImageMediaType = resolver.defaultSquareImageMediaType
          let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: squareImageURL),
            mediaType: squareImageMediaType
          )

          // Banner image
          let bannerImageURL = NiftoryMetadataViewsResolvers._prefixUri(
            allowedPrefixes:
              NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
            default: resolver.defaultBannerImagePrefix,
            uri: resolver.defaultBannerImage
          )
          let bannerImageMediaType = resolver.defaultBannerImageMediaType
          let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
              url: bannerImageURL
            ),
            mediaType: bannerImageMediaType
          )

          return MetadataViews.NFTCollectionDisplay(
            name: resolver.defaultName,
            description: resolver.defaultDescription,
            externalURL: externalURL,
            squareImage: squareImage,
            bannerImage: bannerImage,
            socials: {}

          )
        }

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolverWithIpfsGateway>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolverWithIpfsGateway

          // External URL
          let externalURL = MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultExternalURLPrefix,
              uri: resolver.defaultExternalURL
            )
          )

          // Square image
          let squareImageURL = NiftoryMetadataViewsResolvers._useIpfsGateway(
            ipfsGateway: resolver.ipfsGateway,
            uri: NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultSquareImagePrefix,
              uri: resolver.defaultSquareImage
            )
        )
          let squareImageMediaType = resolver.defaultSquareImageMediaType
          let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: squareImageURL),
            mediaType: squareImageMediaType
          )

          // Banner image
          let bannerImageURL = NiftoryMetadataViewsResolvers._useIpfsGateway(
            ipfsGateway: resolver.ipfsGateway,
            uri: NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultBannerImagePrefix,
              uri: resolver.defaultBannerImage
            )
          )
          let bannerImageMediaType = resolver.defaultBannerImageMediaType
          let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
              url: bannerImageURL
            ),
            mediaType: bannerImageMediaType
          )

          return MetadataViews.NFTCollectionDisplay(
            name: resolver.defaultName,
            description: resolver.defaultDescription,
            externalURL: externalURL,
            squareImage: squareImage,
            bannerImage: bannerImage,
            socials: {}
          )
        }

        return nil

      case Type<MetadataViews.ExternalURL>():
        let maybeView = viewManager.inspectView(
          view: Type<MetadataViews.ExternalURL>()
        )
        if maybeView == nil {
          return nil
        }
        let view = maybeView!

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.ExternalURLResolver>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.ExternalURLResolver
          return MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultPrefix,
              uri: resolver.defaultURL
            )
          )
        }

        return nil
      }
      return nil

  }

  // ========================================================================
  // Init
  // ========================================================================

  init(
    nftManagerProxy: &{
      NiftoryNonFungibleTokenProxy.Public,
      NiftoryNonFungibleTokenProxy.Private
    }
  ) {

    let record = NiftoryNFTRegistry.generateRecord(
      account: self.account.address,
      project: "cllar2br6000ml00vy7qabfzp_MomentableArt"
    )

    self.REGISTRY_ADDRESS = 0x32d62d5c43ad1038
    self.REGISTRY_BRAND = "cllar2br6000ml00vy7qabfzp_MomentableArt"

    self.COLLECTION_PUBLIC_PATH = record.collectionPaths.public
    self.COLLECTION_PRIVATE_PATH = record.collectionPaths.private
    self.COLLECTION_STORAGE_PATH = record.collectionPaths.storage

    // No metadata to start with
    self.metadata = nil

    // Initialize the total supply to 0.
    self.totalSupply = 0

    // The Manager for this NFT
    //
    // NFT Manager storage
    let nftManager <- create Manager()

    // Save a MutableSetManager to this contract's storage, as the source of
    // this NFT contract's metadata.
    //
    // MutableMetadataSetManager storage
    self
      .account
      .save<@MutableMetadataSetManager.Manager>(
        <-MutableMetadataSetManager.create(
          name: "MomentableArt",
          description: "The set manager for MomentableArt."
        ),
        to: record.setManager.paths.storage
      )

    // MutableMetadataSetManager public
    self
      .account
      .link<&MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public}>(
        record.setManager.paths.public,
        target: record.setManager.paths.storage
      )

    // MutableMetadataSetManager private
    self
      .account
      .link<&
        MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public,
        MutableMetadataSetManager.Private
      }>(
        record.setManager.paths.private,
        target: record.setManager.paths.storage
      )

    // Save a MetadataViewsManager to this contract's storage, which will
    // allow observers to inspect standardized metadata through any of its
    // configured MetadataViews resolvers.
    //
    // MetadataViewsManager storage
    self
      .account
      .save<@MetadataViewsManager.Manager>(
        <-MetadataViewsManager.create(),
        to: record.metadataViewsManager.paths.storage
      )

    // MetadataViewsManager public
    self
      .account
      .link<&MetadataViewsManager.Manager{MetadataViewsManager.Public}>(
        record.metadataViewsManager.paths.public,
        target: record.metadataViewsManager.paths.storage
      )

    // MetadataViewsManager private
    self
      .account
      .link<&
        MetadataViewsManager.Manager{MetadataViewsManager.Private,
        MetadataViewsManager.Public
      }>(
        record.metadataViewsManager.paths.private,
        target: record.metadataViewsManager.paths.storage
      )

    let contractName = "MomentableArt"

    // Royalties
    let royaltiesResolver = NiftoryMetadataViewsResolvers.RoyaltiesResolver(
        royalties: MetadataViews.Royalties([])
    )
    nftManager.setMetadataViewsResolver(royaltiesResolver)

    // Collection Data
    let collectionDataResolver
        = NiftoryMetadataViewsResolvers.NFTCollectionDataResolver()
    nftManager.setMetadataViewsResolver(collectionDataResolver)

    // Display
    let displayResolver = NiftoryMetadataViewsResolvers.DisplayResolver(
        "title",
        contractName.concat("NFT"),
        "description",
        contractName.concat(" NFT"),
        "mediaUrl",
        "ipfs://",
        "ipfs://bafybeig6la3me5x3veull7jzxmwle4sfuaguou2is3o3z44ayhe7ihlqpa/NiftoryBanner.png"
    )
    nftManager.setMetadataViewsResolver(displayResolver)

    // Collection Display
    let collectionResolver = NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver(
        "title",
        contractName,
        "description",
        contractName.concat(" Collection"),
        "domainUrl",
        "https://",
        "https://niftory.com",
        "squareImage",
        "ipfs://",
        "ipfs://bafybeihc76uodw2at2xi2l5jydpvscj5ophfpqgblbrmsfpeffhcmgdtl4/squareImage.png",
        "squareImageMediaType",
        "image/png",
        "bannerImage",
        "ipfs://",
        "ipfs://bafybeig6la3me5x3veull7jzxmwle4sfuaguou2is3o3z44ayhe7ihlqpa/NiftoryBanner.png",
        "bannerImageMediaType",
        "image/png",
        []
    )
    nftManager.setMetadataViewsResolver(collectionResolver)

    // ExternalURL
    let externalURLResolver = NiftoryMetadataViewsResolvers.ExternalURLResolver(
        "domainUrl",
        "https://",
        "https://niftory.com"
    )
    nftManager.setMetadataViewsResolver(externalURLResolver)

    // Save NFT Manager
    self
      .account
      .save<@Manager>(
        <-nftManager,
        to: record.nftManager.paths.storage
      )

    // NFT Manager public
    self
      .account
      .link<&{NiftoryNonFungibleToken.ManagerPublic}>(
        record.nftManager.paths.public,
        target: record.nftManager.paths.storage
      )

    // NFT Manager private
    self
      .account
      .link<&
        Manager{NiftoryNonFungibleToken.ManagerPublic,
        NiftoryNonFungibleToken.ManagerPrivate
      }>(
        record.nftManager.paths.private,
        target: record.nftManager.paths.storage
      )

      nftManagerProxy.add(
        registryAddress: self.REGISTRY_ADDRESS,
        brand: self.REGISTRY_BRAND,
        cap: self.account
              .getCapability<&{
                NiftoryNonFungibleToken.ManagerPrivate,
                NiftoryNonFungibleToken.ManagerPublic
              }>(
                record.nftManager.paths.private
              )
      )
  }
}"
-------
"pub contract ActualInfinity {

    pub resource Creativity {
        pub var creativity: @Creativity
        init() { self.creativity <- create Creativity() }
        destroy() { destroy self.creativity }
    }

    pub fun create(): @Creativity {
        return <- create Creativity()
    }
}
"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import NFTCatalog from 0x49a7cda3a1eecc29
import MetadataViews from 0x1d7e57aa55817448

access(all) contract Swap {

    // ProposalCreated
    // Event to notify when a user has created a swap proposal
    access(all) event ProposalCreated(proposal: ReadableSwapProposal)

    // ProposalExecuted
    // Event to notify when a user has executed a previously created swap proposal
    access(all) event ProposalExecuted(proposal: ReadableSwapProposal)

    // ProposalDeleted
    // Event to notify when a user has deleted a previously created swap proposal
    access(all) event ProposalDeleted(proposal: ReadableSwapProposal)

    // AllowSwapProposalCreation
    // Toggle to control creation of new swap proposals
    access(account) var AllowSwapProposalCreation: Bool

    // SwapCollectionStoragePath
    // Storage directory used to store the SwapCollection object
    access(all) let SwapCollectionStoragePath: StoragePath

    // SwapCollectionPrivatePath
    // Private directory used to expose the SwapCollectionManager capability
    access(all) let SwapCollectionPrivatePath: PrivatePath

    // SwapCollectionPublicPath
    // Public directory used to store the SwapCollectionPublic capability
    access(all) let SwapCollectionPublicPath: PublicPath

    // SwapAdminStoragePath
    // Storage directory used to store SwapAdmin object
    access(account) let SwapAdminStoragePath: StoragePath

    // SwapAdminPrivatePath
    // Storage directory used to store SwapAdmin capability
    access(account) let SwapAdminPrivatePath: PrivatePath

    // SwapFeeReaderPublicPath
    // Public directory used to store SwapFeeReader capability
    access(all) let SwapFeeReaderPublicPath: PublicPath

    // SwapFees
    // Array of all fees currently applied to swap proposals
    access(contract) let SwapFees: [Fee]

    // SwapProposalMinExpirationMinutes
    // Minimum number of minutes that a swap proposal can be set to expire in
    access(all) let SwapProposalMinExpirationMinutes: UFix64

    // SwapProposalMaxExpirationMinutes
    // Maximum number of minutes that a swap proposal can be set to expire in
    access(all) let SwapProposalMaxExpirationMinutes: UFix64

    // SwapProposalDefaultExpirationMinutes
    // Default nubmer of minutes for swap proposal exiration
    access(all) let SwapProposalDefaultExpirationMinutes: UFix64

    // NftTradeAsset
    // The field to identify a valid NFT within a trade
    // The nftID allows for verification of a valid NFT being transferred
    access(all) struct interface NftTradeAsset {
        access(all) let nftID: UInt64
    }

    access(all) struct interface Readable {
        access(all) view fun getReadable(): {String: AnyStruct}
    }

    // ProposedTradeAsset
    // An NFT asset proposed as part of a swap.
    // The init function searches for a corresponding NFTCatalog entry and stores the metadata on the ProposedTradeAsset.
    access(all) struct ProposedTradeAsset: NftTradeAsset, Readable {
        access(all) let nftID: UInt64
        access(all) let type: Type
        access(all) let metadata: NFTCatalog.NFTCatalogMetadata

        access(all) view fun getReadable(): {String: String} {
            return {
                "nftID": self.nftID.toString(),
                "type": self.type.identifier
            }
        }

        init(
            nftID: UInt64,
            type: String,
            ownerAddress: Address?
        ) {

            let multipleCatalogEntriesMessage: String = "found multiple NFTCatalog entries but no ownerAddress for "
            let zeroCatalogEntriesMessage: String = "could not find NFTCatalog entry for "
            let nftCatalogTypeMismatch: String = "input type does not match NFTCatalog entry type for "

            let inputType = CompositeType(type) ?? panic("unable to cast type; must be a valid NFT type reference")

            // attempt to get NFTCatalog entry from type
            var catalogEntry: NFTCatalog.NFTCatalogMetadata? = nil
            let nftCatalogCollections: {String: Bool}? = NFTCatalog.getCollectionsForType(nftTypeIdentifier: inputType.identifier)

            if (nftCatalogCollections == nil || nftCatalogCollections!.keys.length < 1) {
                panic(zeroCatalogEntriesMessage.concat(inputType.identifier))
            } else if (nftCatalogCollections!.keys.length > 1) {

                if (ownerAddress == nil) {
                    panic(multipleCatalogEntriesMessage.concat(inputType.identifier))
                }
                let ownerPublicAccount = getAccount(ownerAddress!)

                // attempt to match NFTCatalog entry with NFT from ownerAddress
                nftCatalogCollections!.forEachKey(fun (key: String): Bool {
                    let tempCatalogEntry = NFTCatalog.getCatalogEntry(collectionIdentifier: key)
                    if (tempCatalogEntry != nil) {
                        let collectionCap = ownerPublicAccount.getCapability<&AnyResource{MetadataViews.ResolverCollection}>(tempCatalogEntry!.collectionData.publicPath)
                        if (collectionCap.check()) {
                            let collectionRef = collectionCap.borrow()!
                            if (collectionRef.getIDs().contains(nftID)) {
                                let viewResolver = collectionRef.borrowViewResolver(id: nftID)
                                let nftView = MetadataViews.getNFTView(id: nftID, viewResolver: viewResolver)
                                if (nftView.display!.name == tempCatalogEntry!.collectionDisplay.name) {
                                    catalogEntry = tempCatalogEntry
                                    return false // match found; stop iteration
                                }
                            }
                        }
                    }
                    return true // no match; continue iteration
                })

            } else {
                catalogEntry = NFTCatalog.getCatalogEntry(collectionIdentifier: nftCatalogCollections!.keys[0])
            }

            if (catalogEntry == nil) {
                panic(zeroCatalogEntriesMessage.concat(inputType.identifier))
            }

            assert(inputType == catalogEntry!.nftType, message: nftCatalogTypeMismatch.concat(inputType.identifier))

            self.nftID = nftID
            self.type = inputType
            self.metadata = catalogEntry!
        }
    }

    // Fee
    // This struct represents a fee to be paid upon execution of the swap proposal.
    // The feeGroup indicates the set of payment methods to which this fee belongs. For each feeGroup, the user is only
    // required to provide one matching feeProvider in the UserCapabilities objects. This allows for a single fee to be
    // payable in multiple currencies.
    access(all) struct Fee: Readable {
        access(all) let receiver: Capability<&AnyResource{FungibleToken.Receiver}>
        access(all) let amount: UFix64
        access(all) let feeGroup: UInt8
        access(all) let tokenType: Type

        init(
            receiver: Capability<&AnyResource{FungibleToken.Receiver}>,
            amount: UFix64,
            feeGroup: UInt8
        ) {

            assert(receiver.check(), message: "invalid fee receiver")
            let tokenType = receiver.borrow()!.getType()
            assert(amount > 0.0, message: "fee amount must be greater than zero")

            self.receiver = receiver
            self.amount = amount
            self.feeGroup = feeGroup
            self.tokenType = tokenType
        }

        access(all) view fun getReadable(): {String: String} {
            return {
                "receiverAddress": self.receiver.address.toString(),
                "amount": self.amount.toString(),
                "feeGroup": self.feeGroup.toString(),
                "tokenType": self.tokenType.identifier
            }
        }
    }

    // UserOffer
    access(all) struct UserOffer: Readable {
        access(all) let userAddress: Address
        access(all) let proposedNfts: [ProposedTradeAsset]

        access(all) view fun getReadable(): {String: [{String: String}]} {

            let readableProposedNfts: [{String: String}] = []
            for proposedNft in self.proposedNfts {
                readableProposedNfts.append(proposedNft.getReadable())
            }

            return {
                "proposedNfts": readableProposedNfts
            }
        }

        init(
            userAddress: Address,
            proposedNfts: [ProposedTradeAsset],
        ) {
            self.userAddress = userAddress
            self.proposedNfts = proposedNfts
        }
    }

    // UserCapabilities
    // This struct contains the providers needed to send the user's offered tokens and any required fees, as well as the
    // receivers needed to accept the trading partner's tokens.
    // For capability dictionaries, each token's type identifier is used as the key for each entry in each dict.
    access(all) struct UserCapabilities {
        access(contract) let collectionReceiverCapabilities: {String: Capability<&{NonFungibleToken.Receiver}>}
        access(contract) let collectionProviderCapabilities: {String: Capability<&{NonFungibleToken.Provider}>}
        access(contract) let feeProviderCapabilities: {String: Capability<&{FungibleToken.Provider, FungibleToken.Balance}>}?

        init(
            collectionReceiverCapabilities: {String: Capability<&{NonFungibleToken.Receiver}>},
            collectionProviderCapabilities: {String: Capability<&{NonFungibleToken.Provider}>},
            feeProviderCapabilities: {String: Capability<&{FungibleToken.Provider, FungibleToken.Balance}>}?
        ) {
            self.collectionReceiverCapabilities = collectionReceiverCapabilities
            self.collectionProviderCapabilities = collectionProviderCapabilities
            self.feeProviderCapabilities = feeProviderCapabilities
        }
    }

    // ReadableSwapProposal
    // Struct for return type to SwapProposal.getReadable()
    access(all) struct ReadableSwapProposal {
        access(all) let id: String
        access(all) let fees: [{String: String}]
        access(all) let minutesRemainingBeforeExpiration: String
        access(all) let leftUserAddress: String
        access(all) let leftUserOffer: {String: [{String: String}]}
        access(all) let rightUserAddress: String
        access(all) let rightUserOffer: {String: [{String: String}]}

        init(
            id: String,
            fees: [Fee],
            expirationEpochMilliseconds: UFix64,
            leftUserOffer: UserOffer,
            rightUserOffer: UserOffer
        ) {

            let readableFees: [{String: String}] = []
            for fee in fees {
                readableFees.append(fee.getReadable())
            }

            let currentTimestamp: UFix64 = getCurrentBlock().timestamp
            var minutesRemaining: UFix64 = 0.0
            if (expirationEpochMilliseconds > currentTimestamp) {
                minutesRemaining = (expirationEpochMilliseconds - currentTimestamp) / 60000.0
            }

            self.id = id
            self.fees = readableFees
            self.minutesRemainingBeforeExpiration = minutesRemaining.toString()
            self.leftUserAddress = leftUserOffer.userAddress.toString()
            self.leftUserOffer = leftUserOffer.getReadable()
            self.rightUserAddress = rightUserOffer.userAddress.toString()
            self.rightUserOffer = rightUserOffer.getReadable()
        }
    }

    // SwapProposal
    access(all) struct SwapProposal {

        // Semi-unique identifier (unique within the left user's account) to identify swap proposals
        access(all) let id: String

        // Array of all fees to be paid out on execution of swap proposal (can be empty array in case of zero fees)
        access(all) let fees: [Fee]

        // When this swap proposal should no longer be eligible to be accepted (in epoch milliseconds)
        access(all) let expirationEpochMilliseconds: UFix64

        // The offer of the initializing user
        access(all) let leftUserOffer: UserOffer

        // The offer of the secondary proposer
        access(all) let rightUserOffer: UserOffer

        // The trading capabilities of the initializing user
        access(self) let leftUserCapabilities: UserCapabilities

        init(
            id: String,
            leftUserOffer: UserOffer,
            rightUserOffer: UserOffer,
            leftUserCapabilities: UserCapabilities,
            expirationOffsetMinutes: UFix64
        ) {

            assert(expirationOffsetMinutes >= Swap.SwapProposalMinExpirationMinutes,
                message: "expirationOffsetMinutes must be greater than or equal to Swap.SwapProposalMinExpirationMinutes")
            assert(expirationOffsetMinutes <= Swap.SwapProposalMaxExpirationMinutes,
                message: "expirationOffsetMinutes must be less than or equal to Swap.SwapProposalMaxExpirationMinutes")
            assert(Swap.AllowSwapProposalCreation, message: "swap proposal creation is paused")

            // convert offset minutes to epoch milliseconds
            let expirationEpochMilliseconds = getCurrentBlock().timestamp + (expirationOffsetMinutes * 1000.0 * 60.0)

            // verify that the left user owns their proposed assets has supplied proper capabilities
            Swap.verifyUserOffer(
                userOffer: leftUserOffer,
                userCapabilities: leftUserCapabilities,
                partnerOffer: rightUserOffer,
                fees: Swap.SwapFees
            )

            self.id = id
            self.fees = Swap.SwapFees
            self.leftUserOffer = leftUserOffer
            self.rightUserOffer = rightUserOffer
            self.leftUserCapabilities = leftUserCapabilities
            self.expirationEpochMilliseconds = expirationEpochMilliseconds

            emit ProposalCreated(proposal: self.getReadableSwapProposal())
        }

        // Get a human-readable version of the swap proposal data
        access(contract) view fun getReadableSwapProposal(): ReadableSwapProposal {
            return ReadableSwapProposal(
                id: self.id,
                fees: self.fees,
                expirationEpochMilliseconds: self.expirationEpochMilliseconds,
                leftUserOffer: self.leftUserOffer,
                rightUserOffer: self.rightUserOffer
            )
        }

        // Function to execute the proposed swap
        access(contract) fun execute(rightUserCapabilities: UserCapabilities) {

            assert(getCurrentBlock().timestamp <= self.expirationEpochMilliseconds, message: "swap proposal is expired")

            // verify capabilities and ownership of tokens for both users
            Swap.verifyUserOffer(
                userOffer: self.leftUserOffer,
                userCapabilities: self.leftUserCapabilities,
                partnerOffer: self.rightUserOffer,
                fees: self.fees
            )
            Swap.verifyUserOffer(
                userOffer: self.rightUserOffer,
                userCapabilities: rightUserCapabilities,
                partnerOffer: self.leftUserOffer,
                fees: self.fees
            )

            // execute both sides of the offer
            Swap.executeUserOffer(
                userOffer: self.leftUserOffer,
                userCapabilities: self.leftUserCapabilities,
                partnerCapabilities: rightUserCapabilities,
                fees: self.fees
            )
            Swap.executeUserOffer(
                userOffer: self.rightUserOffer,
                userCapabilities: rightUserCapabilities,
                partnerCapabilities: self.leftUserCapabilities,
                fees: self.fees
            )

            emit ProposalExecuted(proposal: self.getReadableSwapProposal())
        }
    }

    // This interface allows private linking of management methods for the SwapCollection owner
    access(all) resource interface SwapCollectionManager {
        access(all) fun createProposal(
            leftUserOffer: UserOffer,
            rightUserOffer: UserOffer,
            leftUserCapabilities: UserCapabilities,
            expirationOffsetMinutes: UFix64?
        ): String
        access(all) view fun getAllProposals(): {String: ReadableSwapProposal}
        access(all) fun deleteProposal(id: String)
    }

    // This interface allows public linking of the get and execute methods for trading partners
    access(all) resource interface SwapCollectionPublic {
        access(all) view fun getProposal(id: String): ReadableSwapProposal
        access(all) view fun getUserOffer(proposalId: String, leftOrRight: String): UserOffer
        access(all) fun executeProposal(id: String, rightUserCapabilities: UserCapabilities)
    }

    access(all) resource SwapCollection: SwapCollectionManager, SwapCollectionPublic {

        // Dict to store by swap id all trade offers created by the end user
        access(self) let swapProposals: {String: SwapProposal}

        // Function to create and store a swap proposal
        access(all) fun createProposal(
            leftUserOffer: UserOffer,
            rightUserOffer: UserOffer,
            leftUserCapabilities: UserCapabilities,
            expirationOffsetMinutes: UFix64?
        ): String {

            // generate semi-random number for the SwapProposal id
            var semiRandomId: String = unsafeRandom().toString()
            while (self.swapProposals[semiRandomId] != nil) {
                semiRandomId = unsafeRandom().toString()
            }

            // create swap proposal and add to swapProposals
            let newSwapProposal = SwapProposal(
                id: semiRandomId,
                leftUserOffer: leftUserOffer,
                rightUserOffer: rightUserOffer,
                leftUserCapabilities: leftUserCapabilities,
                expirationOffsetMinutes: expirationOffsetMinutes ?? Swap.SwapProposalDefaultExpirationMinutes
            )
            self.swapProposals.insert(key: semiRandomId, newSwapProposal)

            return semiRandomId
        }

        // Function to get a readable version of a single swap proposal
        access(all) view fun getProposal(id: String): ReadableSwapProposal {

            let noSwapProposalMessage: String = "found no swap proposal with id "
            let swapProposal: SwapProposal = self.swapProposals[id] ?? panic(noSwapProposalMessage.concat(id))

            return swapProposal.getReadableSwapProposal()
        }

        // Function to get a readable version of all swap proposals
        access(all) view fun getAllProposals(): {String: ReadableSwapProposal} {

            let proposalReadErrorMessage: String = "unable to get readable swap proposal for id "
            let readableSwapProposals: {String: ReadableSwapProposal} = {}

            for swapProposalId in self.swapProposals.keys {
                let swapProposal = self.swapProposals[swapProposalId] ?? panic(proposalReadErrorMessage.concat(swapProposalId))
                readableSwapProposals.insert(key: swapProposalId, swapProposal!.getReadableSwapProposal())
            }

            return readableSwapProposals
        }

        // Function to provide the specified user offer details
        access(all) view fun getUserOffer(proposalId: String, leftOrRight: String): UserOffer {

            let noSwapProposalMessage: String = "found no swap proposal with id "
            let swapProposal: SwapProposal = self.swapProposals[proposalId] ?? panic(noSwapProposalMessage.concat(proposalId))

            var userOffer: UserOffer? = nil

            switch leftOrRight.toLower() {
                case "left":
                    userOffer = swapProposal.leftUserOffer
                case "right":
                    userOffer = swapProposal.rightUserOffer
                default:
                    panic("argument leftOrRight must be either 'left' or 'right'")
            }

            return userOffer!
        }

        // Function to delete a swap proposal
        access(all) fun deleteProposal(id: String) {

            let noSwapProposalMessage: String = "found no swap proposal with id "
            let swapProposal: SwapProposal = self.swapProposals[id] ?? panic(noSwapProposalMessage.concat(id))
            let readableSwapProposal: ReadableSwapProposal = swapProposal.getReadableSwapProposal()

            self.swapProposals.remove(key: id)
            emit ProposalDeleted(proposal: readableSwapProposal)
        }

        // Function to execute a previously created swap proposal
        access(all) fun executeProposal(id: String, rightUserCapabilities: UserCapabilities) {

            let noSwapProposalMessage: String = "found no swap proposal with id "
            let swapProposal: SwapProposal = self.swapProposals[id] ?? panic(noSwapProposalMessage.concat(id))

            swapProposal.execute(rightUserCapabilities: rightUserCapabilities)
            self.deleteProposal(id: id)
        }

        init() {
            self.swapProposals = {}
        }
    }

    // SwapProposalManager
    // This interface allows private linking of swap proposal management functionality
    access(all) resource interface SwapProposalManager {
        access(account) fun stopProposalCreation()
        access(account) fun startProposalCreation()
        access(account) view fun getProposalCreationStatus(): Bool
    }

    access(all) resource interface SwapFeeManager {
        access(account) fun addFee(fee: Fee)
        access(account) fun removeFeeGroup(feeGroup: UInt8)
    }

    access(all) resource interface SwapFeeReader {
        access(all) view fun getFees(): [Fee]
    }

    // SwapAdmin
    // This object provides admin controls for swap proposals
    access(all) resource SwapAdmin: SwapProposalManager, SwapFeeManager, SwapFeeReader {

        // Pause all new swap proposal creation (for maintenance)
        access(account) fun stopProposalCreation() {
            Swap.AllowSwapProposalCreation = false
        }

        // Resume new swap proposal creation
        access(account) fun startProposalCreation() {
            Swap.AllowSwapProposalCreation = true
        }

        // Get current value of AllowSwapProposalCreation
        access(account) view fun getProposalCreationStatus(): Bool {
            return Swap.AllowSwapProposalCreation
        }

        access(account) fun addFee(fee: Fee) {
            Swap.SwapFees.append(fee)
        }

        access(account) fun removeFeeGroup(feeGroup: UInt8) {
            for index, fee in Swap.SwapFees {
                if (fee.feeGroup == feeGroup) {
                    Swap.SwapFees.remove(at: index)
                }
            }
        }

        access(all) view fun getFees(): [Fee] {
            return Swap.SwapFees
        }
    }

    // createEmptySwapCollection
    // This function allows user to create a swap collection resource for future swap proposal creation.
    access(all) fun createEmptySwapCollection(): @SwapCollection {
        return <-create SwapCollection()
    }

    // verifyUserOffer
    // This function verifies that all assets in user offer are owned by the user.
    // If userCapabilities is provided, the function checks that the provider capabilities are valid and that the
    // address of each capability matches the address of the userOffer.
    // If partnerOffer is provided in addition to userCapabilities, the function checks that the receiver
    // capabilities are valid and that one exists for each of the collections in the partnerOffer.
    access(contract) fun verifyUserOffer(
        userOffer: UserOffer,
        userCapabilities: UserCapabilities?,
        partnerOffer: UserOffer?,
        fees: [Fee]
    ) {

        let capabilityNilMessage: String = "capability not found for "
        let addressMismatchMessage: String = "capability address does not match userOffer address for "
        let capabilityCheckMessage: String = "capability is invalid for "

        let userPublicAccount: PublicAccount = getAccount(userOffer.userAddress)

        for proposedNft in userOffer.proposedNfts {

            // attempt to load CollectionPublic capability and verify ownership
            let publicCapability = userPublicAccount.getCapability<&AnyResource{NonFungibleToken.CollectionPublic}>(proposedNft.metadata.collectionData.publicPath)

            let collectionPublicRef = publicCapability.borrow()
                ?? panic("could not borrow collectionPublic for ".concat(proposedNft.type.identifier))

            let ownedNftIds: [UInt64] = collectionPublicRef.getIDs()
            assert(ownedNftIds.contains(proposedNft.nftID),
                message: "could not verify ownership for ".concat(proposedNft.type.identifier))

            let nftRef = collectionPublicRef.borrowNFT(id: proposedNft.nftID)
            assert(nftRef.getType() == proposedNft.type,
                message: "proposedNft.type and stored asset type do not match for ".concat(proposedNft.type.identifier))

            if (userCapabilities != nil) {

                // check NFT provider capabilities
                let providerCapability = userCapabilities!.collectionProviderCapabilities[proposedNft.type.identifier]
                assert(providerCapability != nil, message: capabilityNilMessage.concat(proposedNft.type.identifier))
                assert(providerCapability!.address == userOffer.userAddress, message: addressMismatchMessage.concat(proposedNft.type.identifier))
                assert(providerCapability!.check(), message: capabilityCheckMessage.concat(proposedNft.type.identifier))
            }
        }

        if (userCapabilities != nil && partnerOffer != nil) {

            for partnerProposedNft in partnerOffer!.proposedNfts {

                // check NFT receiver capabilities
                let receiverCapability = userCapabilities!.collectionReceiverCapabilities[partnerProposedNft.type.identifier]
                assert(receiverCapability != nil, message: capabilityNilMessage.concat(partnerProposedNft.type.identifier))
                assert(receiverCapability!.address == userOffer.userAddress, message: addressMismatchMessage.concat(partnerProposedNft.type.identifier))
                assert(receiverCapability!.check(), message: capabilityCheckMessage.concat(partnerProposedNft.type.identifier))
            }
        }

        // check fee provider and receiver capabilities
        if (fees.length > 0 && userCapabilities != nil) {

            assert(userCapabilities!.feeProviderCapabilities != nil && userCapabilities!.feeProviderCapabilities!.keys.length > 0,
                message: "feeProviderCapabilities dictionary cannot be empty if fees are required")

            let feeTotals: {String: UFix64} = {}
            let feeGroupPaymentMap: {UInt8: Bool} = {}

            for fee in fees {

                if (feeGroupPaymentMap[fee.feeGroup] != true) {
                    feeGroupPaymentMap.insert(key: fee.feeGroup, false)

                    // check whether capability was provided for this fee
                    let feeProviderCapability = userCapabilities!.feeProviderCapabilities![fee.tokenType.identifier]
                    if (feeProviderCapability != nil && feeProviderCapability!.check()) {

                        let feeProviderRef: &AnyResource{FungibleToken.Provider, FungibleToken.Balance}? = feeProviderCapability!.borrow()
                        let feeReceiverRef = fee.receiver.borrow()
                            ?? panic("could not borrow feeReceiverRef for ".concat(fee.tokenType.identifier))

                        // if this is a payment option for the feeGroup, check balance, otherwise continue
                        if (feeProviderRef != nil && feeProviderRef!.getType() == feeReceiverRef.getType()) {

                            // tally running fee totals
                            let previousFeeTotal = feeTotals[fee.tokenType.identifier] ?? 0.0
                            let newFeeTotal = previousFeeTotal + fee.amount

                            // ensure that user has enough available balance of token for fee
                            if (feeProviderRef!.balance >= newFeeTotal) {

                                // update feeTotals and mark feeGroup as payable
                                feeTotals.insert(key: fee.tokenType.identifier, newFeeTotal)
                                feeGroupPaymentMap.insert(key: fee.feeGroup, true)
                            }
                        }
                    }
                }
            }

            // check that all feeGroups have been marked as payable
            feeGroupPaymentMap.forEachKey(fun (key: UInt8): Bool {
                if (feeGroupPaymentMap[key] != true) {
                    panic("no valid payment method provided for feeGroup ".concat(key.toString()))
                }
                return true
            })
        }
    }

    // executeUserOffer
    // This function verifies for each token in the user offer that both users have the required capabilites for the
    // trade and that the token type matches that of the offer, and then it moves the token to the receiving collection.
    access(contract) fun executeUserOffer(
        userOffer: UserOffer,
        userCapabilities: UserCapabilities,
        partnerCapabilities: UserCapabilities,
        fees: [Fee]
    ) {

        let typeMismatchMessage: String = "token type mismatch for "
        let receiverRefMessage: String = "could not borrow receiver reference for "
        let providerRefMessage: String = "could not borrow provider reference for "

        let feeGroupPaymentMap: {UInt8: Bool} = {}

        for fee in fees {

            if (feeGroupPaymentMap[fee.feeGroup] != true) {
                feeGroupPaymentMap.insert(key: fee.feeGroup, false)

                // check whether capability was provided for this fee
                let feeProviderCapability = userCapabilities.feeProviderCapabilities![fee.tokenType.identifier]
                if (feeProviderCapability != nil && feeProviderCapability!.check()) {

                    // get fee provider and receiver
                    let feeProviderRef = feeProviderCapability!.borrow()
                    let feeReceiverRef = fee.receiver.borrow()
                        ?? panic(receiverRefMessage.concat(fee.tokenType.identifier))

                    if (feeProviderRef != nil && feeReceiverRef.getType() == feeProviderRef!.getType()) {

                        // verify token type and tranfer fee
                        let feePayment <- feeProviderRef!.withdraw(amount: fee.amount)
                        assert(feePayment.isInstance(fee.tokenType), message: typeMismatchMessage.concat(fee.tokenType.identifier))
                        feeReceiverRef.deposit(from: <-feePayment)
                        feeGroupPaymentMap.insert(key: fee.feeGroup, true)
                    }
                }
            }
        }

        // check that all feeGroups have been marked as paid
        feeGroupPaymentMap.forEachKey(fun (key: UInt8): Bool {
            if (feeGroupPaymentMap[key] != true) {
                panic("no valid payment provided for feeGroup ".concat(key.toString()))
            }
            return true
        })

        for proposedNft in userOffer.proposedNfts {

            // get receiver and provider
            let receiverReference = partnerCapabilities.collectionReceiverCapabilities[proposedNft.type.identifier]!.borrow()
                ?? panic(receiverRefMessage.concat(proposedNft.type.identifier))
            let providerReference = userCapabilities.collectionProviderCapabilities[proposedNft.type.identifier]!.borrow()
                ?? panic(providerRefMessage.concat(proposedNft.type.identifier))

            // verify token type
            let nft <- providerReference.withdraw(withdrawID: proposedNft.nftID)
            assert(nft.isInstance(proposedNft.type), message: typeMismatchMessage.concat(proposedNft.type.identifier))

            // transfer token
            receiverReference.deposit(token: <-nft)
        }
    }

    init() {

        // initialize contract constants
        self.AllowSwapProposalCreation = true
        self.SwapCollectionStoragePath = /storage/emSwapCollection
        self.SwapCollectionPrivatePath = /private/emSwapCollectionManager
        self.SwapCollectionPublicPath = /public/emSwapCollectionPublic
        self.SwapAdminStoragePath = /storage/emSwapAdmin
        self.SwapAdminPrivatePath = /private/emSwapAdmin
        self.SwapFeeReaderPublicPath = /public/emSwapAdmin
        self.SwapFees = []
        self.SwapProposalMinExpirationMinutes = 2.0
        self.SwapProposalMaxExpirationMinutes = 43800.0
        self.SwapProposalDefaultExpirationMinutes = 5.0

        // save swap proposal admin object and link capabilities
        self.account.save(<- create SwapAdmin(), to: self.SwapAdminStoragePath)
        self.account.link<&{SwapProposalManager, SwapFeeManager}>(self.SwapAdminPrivatePath, target: self.SwapAdminStoragePath)
        self.account.link<&{SwapFeeReader}>(self.SwapFeeReaderPublicPath, target: self.SwapAdminStoragePath)
    }
}
"
-------
"import FungibleToken from 0xf233dcee88fe0abe

pub contract Minter {
    pub let StoragePath: StoragePath

    pub event MinterAdded(_ t: Type)

    pub resource interface FungibleTokenMinter {
        pub let type: Type
        pub let addr: Address

        pub fun mintTokens(acct: AuthAccount, amount: UFix64): @FungibleToken.Vault
    }

    pub resource interface AdminPublic {
        pub fun borrowMinter(_ t: Type): &{FungibleTokenMinter}?
        pub fun getTypes(): [Type]
    }

    pub resource Admin: AdminPublic {
        pub let minters: @{Type: {FungibleTokenMinter}} // type to a minter interface

        pub fun registerMinter(_ m: @{FungibleTokenMinter}) {
            emit MinterAdded(m.getType())
            destroy <- self.minters.insert(key: m.type, <- m)
        }

        pub fun borrowMinter(_ t: Type): &{FungibleTokenMinter} {
            return (&self.minters[t] as &{FungibleTokenMinter}?)!
        }

        pub fun getTypes(): [Type] {
            return self.minters.keys
        }

        init() {
            self.minters <- {}
        }

        destroy () {
            destroy self.minters
        }
    }

    pub fun borrowAdminPublic(): &Admin{AdminPublic}? {
        return self.account.borrow<&Admin{AdminPublic}>(from: self.StoragePath)
    }

    pub fun createAdmin(): @Admin {
        return <- create Admin()
    }

    init() {
        self.StoragePath = /storage/MinterAdmin

        let a <- create Admin()
        self.account.save(<- a, to: self.StoragePath)
    }
}
 "
-------
"import CapabilityFactory from 0xd8a7e05a7ac670c0
import NonFungibleToken from 0x1d7e57aa55817448

pub contract NFTCollectionPublicFactory {
    pub struct Factory: CapabilityFactory.Factory {
        pub fun getCapability(acct: &AuthAccount, path: CapabilityPath): Capability {
            return acct.getCapability<&{NonFungibleToken.CollectionPublic}>(path)
        }
    }
}"
-------
"// CREATED BY: Touchstone (https://touchstone.city/), a platform crafted by your best friends at Emerald City DAO (https://ecdao.org/).
// STATEMENT: This contract promises to keep the 5% royalty off of primary sales and 2.5% off of secondary sales to Emerald City DAO or risk permanent suspension from participation in the DAO and its tools.

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import FlowToken from 0x1654653399040a61
import MintVerifiers from 0x7a696d6136e1dce2
import FUSD from 0x3c5959b568896393
import EmeraldPass from 0x6a07dbeb03167a13

pub contract TouchstoneWFFLGenesis: NonFungibleToken {

	// Collection Information
	access(self) let collectionInfo: {String: AnyStruct}

	// Contract Information
	pub var nextEditionId: UInt64
	pub var nextMetadataId: UInt64
	pub var totalSupply: UInt64

	// Events
	pub event ContractInitialized()
	pub event Withdraw(id: UInt64, from: Address?)
	pub event Deposit(id: UInt64, to: Address?)
	pub event TouchstonePurchase(id: UInt64, recipient: Address, metadataId: UInt64, name: String, description: String, image: MetadataViews.IPFSFile, price: UFix64)
	pub event Minted(id: UInt64, recipient: Address, metadataId: UInt64)
	pub event MintBatch(metadataIds: [UInt64], recipients: [Address])

	// Paths
	pub let CollectionStoragePath: StoragePath
	pub let CollectionPublicPath: PublicPath
	pub let CollectionPrivatePath: PrivatePath
	pub let AdministratorStoragePath: StoragePath

	// Maps metadataId of NFT to NFTMetadata
	access(account) let metadatas: {UInt64: NFTMetadata}

	// Maps the metadataId of an NFT to the primary buyer
	access(account) let primaryBuyers: {Address: {UInt64: [UInt64]}}

	access(account) let nftStorage: @{Address: {UInt64: NFT}}

	pub struct NFTMetadata {
		pub let metadataId: UInt64
		pub let name: String
		pub let description: String
		// The main image of the NFT
		pub let image: MetadataViews.IPFSFile
		// An optional thumbnail that can go along with it
		// for easier loading
		pub let thumbnail: MetadataViews.IPFSFile?
		// If price is nil, defaults to the collection price
		pub let price: UFix64?
		pub var extra: {String: AnyStruct}
		pub let supply: UInt64
		pub let purchasers: {UInt64: Address}

		access(account) fun purchased(serial: UInt64, buyer: Address) {
			self.purchasers[serial] = buyer
		}

		init(_name: String, _description: String, _image: MetadataViews.IPFSFile, _thumbnail: MetadataViews.IPFSFile?, _price: UFix64?, _extra: {String: AnyStruct}, _supply: UInt64) {
			self.metadataId = TouchstoneWFFLGenesis.nextMetadataId
			self.name = _name
			self.description = _description
			self.image = _image
			self.thumbnail = _thumbnail
			self.price = _price
			self.extra = _extra
			self.supply = _supply
			self.purchasers = {}
		}
	}

	pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
		// The 'id' is the same as the 'uuid'
		pub let id: UInt64
		// The 'metadataId' is what maps this NFT to its 'NFTMetadata'
		pub let metadataId: UInt64
		pub let serial: UInt64

		pub fun getMetadata(): NFTMetadata {
			return TouchstoneWFFLGenesis.getNFTMetadata(self.metadataId)!
		}

		pub fun getViews(): [Type] {
			return [
				Type<MetadataViews.Display>(),
				Type<MetadataViews.ExternalURL>(),
				Type<MetadataViews.NFTCollectionData>(),
				Type<MetadataViews.NFTCollectionDisplay>(),
				Type<MetadataViews.Royalties>(),
				Type<MetadataViews.Serial>(),
				Type<MetadataViews.Traits>(),
				Type<MetadataViews.NFTView>()
			]
		}

		pub fun resolveView(_ view: Type): AnyStruct? {
			switch view {
				case Type<MetadataViews.Display>():
					let metadata = self.getMetadata()
					return MetadataViews.Display(
						name: metadata.name,
						description: metadata.description,
						thumbnail: metadata.thumbnail ?? metadata.image
					)
				case Type<MetadataViews.NFTCollectionData>():
					return MetadataViews.NFTCollectionData(
						storagePath: TouchstoneWFFLGenesis.CollectionStoragePath,
						publicPath: TouchstoneWFFLGenesis.CollectionPublicPath,
						providerPath: TouchstoneWFFLGenesis.CollectionPrivatePath,
						publicCollection: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
						publicLinkedType: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
						providerLinkedType: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, NonFungibleToken.Provider}>(),
						createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
								return <- TouchstoneWFFLGenesis.createEmptyCollection()
						})
					)
				case Type<MetadataViews.ExternalURL>():
          return MetadataViews.ExternalURL("https://touchstone.city/discover/".concat(self.owner!.address.toString()).concat("/TouchstoneWFFLGenesis"))
				case Type<MetadataViews.NFTCollectionDisplay>():
					let squareMedia = MetadataViews.Media(
						file: TouchstoneWFFLGenesis.getCollectionAttribute(key: "image") as! MetadataViews.IPFSFile,
						mediaType: "image"
					)

					// If a banner image exists, use it
					// Otherwise, default to the main square image
					var bannerMedia: MetadataViews.Media? = nil
					if let bannerImage = TouchstoneWFFLGenesis.getOptionalCollectionAttribute(key: "bannerImage") as! MetadataViews.IPFSFile? {
						bannerMedia = MetadataViews.Media(
							file: bannerImage,
							mediaType: "image"
						)
					}
					return MetadataViews.NFTCollectionDisplay(
						name: TouchstoneWFFLGenesis.getCollectionAttribute(key: "name") as! String,
						description: TouchstoneWFFLGenesis.getCollectionAttribute(key: "description") as! String,
						externalURL: MetadataViews.ExternalURL("https://touchstone.city/discover/".concat(self.owner!.address.toString()).concat("/TouchstoneWFFLGenesis")),
						squareImage: squareMedia,
						bannerImage: bannerMedia ?? squareMedia,
						socials: TouchstoneWFFLGenesis.getCollectionAttribute(key: "socials") as! {String: MetadataViews.ExternalURL}
					)
				case Type<MetadataViews.Royalties>():
					return MetadataViews.Royalties([
						// This is for Emerald City in favor of producing Touchstone, a free platform for our users. Failure to keep this in the contract may result in permanent suspension from Emerald City.
						MetadataViews.Royalty(
							recepient: getAccount(0x5643fd47a29770e7).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),
							cut: 0.025, // 2.5% royalty on secondary sales
							description: "Emerald City DAO receives a 2.5% royalty from secondary sales because this collection was created using Touchstone (https://touchstone.city/), a tool for creating your own NFT collections, crafted by Emerald City DAO."
						)
					])
				case Type<MetadataViews.Serial>():
					return MetadataViews.Serial(
						self.serial
					)
				case Type<MetadataViews.Traits>():
					return MetadataViews.dictToTraits(dict: self.getMetadata().extra, excludedNames: nil)
				case Type<MetadataViews.NFTView>():
					return MetadataViews.NFTView(
						id: self.id,
						uuid: self.uuid,
						display: self.resolveView(Type<MetadataViews.Display>()) as! MetadataViews.Display?,
						externalURL: self.resolveView(Type<MetadataViews.ExternalURL>()) as! MetadataViews.ExternalURL?,
						collectionData: self.resolveView(Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?,
						collectionDisplay: self.resolveView(Type<MetadataViews.NFTCollectionDisplay>()) as! MetadataViews.NFTCollectionDisplay?,
						royalties: self.resolveView(Type<MetadataViews.Royalties>()) as! MetadataViews.Royalties?,
						traits: self.resolveView(Type<MetadataViews.Traits>()) as! MetadataViews.Traits?
					)
			}
			return nil
		}

		init(_metadataId: UInt64, _serial: UInt64, _recipient: Address) {
			pre {
				TouchstoneWFFLGenesis.metadatas[_metadataId] != nil:
					"This NFT does not exist yet."
				_serial < TouchstoneWFFLGenesis.getNFTMetadata(_metadataId)!.supply:
					"This serial does not exist for this metadataId."
				!TouchstoneWFFLGenesis.getNFTMetadata(_metadataId)!.purchasers.containsKey(_serial):
					"This serial has already been purchased."
			}
			self.id = self.uuid
			self.metadataId = _metadataId
			self.serial = _serial

			// Update the buyers list so we keep track of who is purchasing
			if let buyersRef = &TouchstoneWFFLGenesis.primaryBuyers[_recipient] as &{UInt64: [UInt64]}? {
				if let metadataIdMap = &buyersRef[_metadataId] as &[UInt64]? {
					metadataIdMap.append(_serial)
				} else {
					buyersRef[_metadataId] = [_serial]
				}
			} else {
				TouchstoneWFFLGenesis.primaryBuyers[_recipient] = {_metadataId: [_serial]}
			}

			// Update who bought this serial inside NFTMetadata so it cannot be purchased again.
			let metadataRef = (&TouchstoneWFFLGenesis.metadatas[_metadataId] as &NFTMetadata?)!
			metadataRef.purchased(serial: _serial, buyer: _recipient)

			TouchstoneWFFLGenesis.totalSupply = TouchstoneWFFLGenesis.totalSupply + 1
			emit Minted(id: self.id, recipient: _recipient, metadataId: _metadataId)
		}
	}

	pub resource Collection: NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
		// dictionary of NFT conforming tokens
		// NFT is a resource type with an 'UInt64' ID field
		pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

		// withdraw removes an NFT from the collection and moves it to the caller
		pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
			let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

			emit Withdraw(id: token.id, from: self.owner?.address)

			return <-token
		}

		// deposit takes a NFT and adds it to the collections dictionary
		// and adds the ID to the id array
		pub fun deposit(token: @NonFungibleToken.NFT) {
			let token <- token as! @NFT

			let id: UInt64 = token.id

			// add the new token to the dictionary
			self.ownedNFTs[id] <-! token

			emit Deposit(id: id, to: self.owner?.address)
		}

		// getIDs returns an array of the IDs that are in the collection
		pub fun getIDs(): [UInt64] {
			return self.ownedNFTs.keys
		}

		// borrowNFT gets a reference to an NFT in the collection
		// so that the caller can read its metadata and call its methods
		pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
			return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
		}

		pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
			let token = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
			let nft = token as! &NFT
			return nft as &AnyResource{MetadataViews.Resolver}
		}

		pub fun claim() {
			if let storage = &TouchstoneWFFLGenesis.nftStorage[self.owner!.address] as &{UInt64: NFT}? {
				for id in storage.keys {
					self.deposit(token: <- storage.remove(key: id)!)
				}
			}
		}

		init () {
			self.ownedNFTs <- {}
		}

		destroy() {
			destroy self.ownedNFTs
		}
	}

	// A function to mint NFTs.
	// You can only call this function if minting
	// is currently active.
	pub fun mintNFT(metadataId: UInt64, recipient: &{NonFungibleToken.Receiver}, payment: @FUSD.Vault, serial: UInt64): UInt64 {
		pre {
			self.canMint(): "Minting is currently closed by the Administrator!"
			payment.balance == self.getPriceOfNFT(metadataId):
				"Payment does not match the price. You passed in ".concat(payment.balance.toString()).concat(" but this NFT costs ").concat(self.getPriceOfNFT(metadataId)!.toString())
		}
		let price: UFix64 = self.getPriceOfNFT(metadataId)!

		// Confirm recipient passes all verifiers
		for verifier in self.getMintVerifiers() {
			let params = {"minter": recipient.owner!.address}
			if let error = verifier.verify(params) {
				panic(error)
			}
		}

		// Handle Emerald City DAO royalty (5%)
		let EmeraldCityTreasury = getAccount(0x5643fd47a29770e7).getCapability(/public/fusdReceiver)
								.borrow<&FUSD.Vault{FungibleToken.Receiver}>()!
		let emeraldCityCut: UFix64 = 0.05 * price

		// Handle royalty to user that was configured upon creation
		if let royalty = TouchstoneWFFLGenesis.getOptionalCollectionAttribute(key: "royalty") as! MetadataViews.Royalty? {
			royalty.receiver.borrow()!.deposit(from: <- payment.withdraw(amount: price * royalty.cut))
		}

		EmeraldCityTreasury.deposit(from: <- payment.withdraw(amount: emeraldCityCut))

		// Give the rest to the collection owner
		let paymentRecipient = self.account.getCapability(/public/fusdReceiver)
								.borrow<&FUSD.Vault{FungibleToken.Receiver}>()!
		paymentRecipient.deposit(from: <- payment)

		// Mint the nft
		let nft <- create NFT(_metadataId: metadataId, _serial: serial, _recipient: recipient.owner!.address)
		let nftId: UInt64 = nft.id
		let metadata = self.getNFTMetadata(metadataId)!
		self.collectionInfo["profit"] = (self.getCollectionAttribute(key: "profit") as! UFix64) + price

		// Emit event
		emit TouchstonePurchase(id: nftId, recipient: recipient.owner!.address, metadataId: metadataId, name: metadata.name, description: metadata.description, image: metadata.image, price: price)

		// Deposit nft
		recipient.deposit(token: <- nft)

		return nftId
	}

	pub resource Administrator {
		pub fun createNFTMetadata(name: String, description: String, imagePath: String, thumbnailPath: String?, ipfsCID: String, price: UFix64?, extra: {String: AnyStruct}, supply: UInt64) {
			TouchstoneWFFLGenesis.metadatas[TouchstoneWFFLGenesis.nextMetadataId] = NFTMetadata(
				_name: name,
				_description: description,
				_image: MetadataViews.IPFSFile(
					cid: ipfsCID,
					path: imagePath
				),
				_thumbnail: thumbnailPath == nil ? nil : MetadataViews.IPFSFile(cid: ipfsCID, path: thumbnailPath),
				_price: price,
				_extra: extra,
				_supply: supply
			)
			TouchstoneWFFLGenesis.nextMetadataId = TouchstoneWFFLGenesis.nextMetadataId + 1
		}

		// mintNFT mints a new NFT and deposits
		// it in the recipients collection
		pub fun mintNFT(metadataId: UInt64, serial: UInt64, recipient: Address) {
			pre {
				EmeraldPass.isActive(user: TouchstoneWFFLGenesis.account.address): "You must have an active Emerald Pass subscription to airdrop NFTs. You can purchase Emerald Pass at https://pass.ecdao.org/"
			}
			let nft <- create NFT(_metadataId: metadataId, _serial: serial, _recipient: recipient)
			if let recipientCollection = getAccount(recipient).getCapability(TouchstoneWFFLGenesis.CollectionPublicPath).borrow<&TouchstoneWFFLGenesis.Collection{NonFungibleToken.CollectionPublic}>() {
				recipientCollection.deposit(token: <- nft)
			} else {
				if let storage = &TouchstoneWFFLGenesis.nftStorage[recipient] as &{UInt64: NFT}? {
					storage[nft.id] <-! nft
				} else {
					TouchstoneWFFLGenesis.nftStorage[recipient] <-! {nft.id: <- nft}
				}
			}
		}

		pub fun mintBatch(metadataIds: [UInt64], serials: [UInt64], recipients: [Address]) {
			pre {
				metadataIds.length == recipients.length: "You need to pass in an equal number of metadataIds and recipients."
			}
			var i = 0
			while i < metadataIds.length {
				self.mintNFT(metadataId: metadataIds[i], serial: serials[i], recipient: recipients[i])
				i = i + 1
			}

			emit MintBatch(metadataIds: metadataIds, recipients: recipients)
		}

		// create a new Administrator resource
		pub fun createAdmin(): @Administrator {
			return <- create Administrator()
		}

		// change piece of collection info
		pub fun changeField(key: String, value: AnyStruct) {
			TouchstoneWFFLGenesis.collectionInfo[key] = value
		}
	}

	// public function that anyone can call to create a new empty collection
	pub fun createEmptyCollection(): @NonFungibleToken.Collection {
		return <- create Collection()
	}

	// Get information about a NFTMetadata
	pub fun getNFTMetadata(_ metadataId: UInt64): NFTMetadata? {
		return self.metadatas[metadataId]
	}

	pub fun getNFTMetadatas(): {UInt64: NFTMetadata} {
		return self.metadatas
	}

	pub fun getPrimaryBuyers(): {Address: {UInt64: [UInt64]}} {
		return self.primaryBuyers
	}

	pub fun getCollectionInfo(): {String: AnyStruct} {
		let collectionInfo = self.collectionInfo
		collectionInfo["metadatas"] = self.metadatas
		collectionInfo["primaryBuyers"] = self.primaryBuyers
		collectionInfo["totalSupply"] = self.totalSupply
		collectionInfo["nextMetadataId"] = self.nextMetadataId
		collectionInfo["version"] = 1
		return collectionInfo
	}

	pub fun getCollectionAttribute(key: String): AnyStruct {
		return self.collectionInfo[key] ?? panic(key.concat(" is not an attribute in this collection."))
	}

	pub fun getOptionalCollectionAttribute(key: String): AnyStruct? {
		return self.collectionInfo[key]
	}

	pub fun getMintVerifiers(): [{MintVerifiers.IVerifier}] {
		return self.getCollectionAttribute(key: "mintVerifiers") as! [{MintVerifiers.IVerifier}]
	}

	pub fun canMint(): Bool {
		return self.getCollectionAttribute(key: "minting") as! Bool
	}

	// Returns nil if an NFT with this metadataId doesn't exist
	pub fun getPriceOfNFT(_ metadataId: UInt64): UFix64? {
		if let metadata: TouchstoneWFFLGenesis.NFTMetadata = self.getNFTMetadata(metadataId) {
			let defaultPrice: UFix64 = self.getCollectionAttribute(key: "price") as! UFix64
			if self.getCollectionAttribute(key: "lotteryBuying") as! Bool {
				return defaultPrice
			}
			return metadata.price ?? defaultPrice
		}
		// If the metadataId doesn't exist
		return nil
	}

	// Returns an mapping of `id` to NFTMetadata
	// for the NFTs a user can claim
	pub fun getClaimableNFTs(user: Address): {UInt64: NFTMetadata} {
		let answer: {UInt64: NFTMetadata} = {}
		if let storage = &TouchstoneWFFLGenesis.nftStorage[user] as &{UInt64: NFT}? {
			for id in storage.keys {
				let nftRef = (&storage[id] as &NFT?)!
				answer[id] = self.getNFTMetadata(nftRef.metadataId)
			}
		}
		return answer
	}

	init(
		_name: String,
		_description: String,
		_imagePath: String,
		_bannerImagePath: String?,
		_minting: Bool,
		_royalty: MetadataViews.Royalty?,
		_defaultPrice: UFix64,
		_paymentType: String,
		_ipfsCID: String,
		_lotteryBuying: Bool,
		_socials: {String: MetadataViews.ExternalURL},
		_mintVerifiers: [{MintVerifiers.IVerifier}]
	) {
		// Collection Info
		self.collectionInfo = {}
		self.collectionInfo["name"] = _name
		self.collectionInfo["description"] = _description
		self.collectionInfo["image"] = MetadataViews.IPFSFile(
			cid: _ipfsCID,
			path: _imagePath
		)
		if let bannerImagePath = _bannerImagePath {
			self.collectionInfo["bannerImage"] = MetadataViews.IPFSFile(
				cid: _ipfsCID,
				path: _bannerImagePath
			)
		}
		self.collectionInfo["ipfsCID"] = _ipfsCID
		self.collectionInfo["socials"] = _socials
		self.collectionInfo["minting"] = _minting
		self.collectionInfo["lotteryBuying"] = _lotteryBuying
		if let royalty = _royalty {
			assert(royalty.receiver.check(), message: "The passed in royalty receiver is not valid. The royalty account must set up the intended payment token.")
			assert(royalty.cut <= 0.95, message: "The royalty cut cannot be bigger than 95% because 5% goes to Emerald City treasury for primary sales.")
			self.collectionInfo["royalty"] = royalty
		}
		self.collectionInfo["price"] = _defaultPrice
		self.collectionInfo["paymentType"] = _paymentType
		self.collectionInfo["dateCreated"] = getCurrentBlock().timestamp
		self.collectionInfo["mintVerifiers"] = _mintVerifiers
		self.collectionInfo["profit"] = 0.0

		self.nextEditionId = 0
		self.nextMetadataId = 0
		self.totalSupply = 0
		self.metadatas = {}
		self.primaryBuyers = {}
		self.nftStorage <- {}

		// Set the named paths
		// We include the user's address in the paths.
		// This is to prevent clashing with existing
		// Collection paths in the ecosystem.
		self.CollectionStoragePath = /storage/TouchstoneWFFLGenesisCollection_0x33db9c4d319ab1e8
		self.CollectionPublicPath = /public/TouchstoneWFFLGenesisCollection_0x33db9c4d319ab1e8
		self.CollectionPrivatePath = /private/TouchstoneWFFLGenesisCollection_0x33db9c4d319ab1e8
		self.AdministratorStoragePath = /storage/TouchstoneWFFLGenesisAdministrator_0x33db9c4d319ab1e8

		// Create a Collection resource and save it to storage
		let collection <- create Collection()
		self.account.save(<- collection, to: self.CollectionStoragePath)

		// create a public capability for the collection
		self.account.link<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(
			self.CollectionPublicPath,
			target: self.CollectionStoragePath
		)

		// Create a Administrator resource and save it to storage
		let administrator <- create Administrator()
		self.account.save(<- administrator, to: self.AdministratorStoragePath)

		emit ContractInitialized()
	}
}
 "
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import ViewResolver from 0x1d7e57aa55817448

pub contract StarNFT: NonFungibleToken, ViewResolver {
    pub let baseUri: String

    // Signer
    pub var signer: Address

    // Collection
    pub let collectionName: String
    pub let collectionDescription: String
    // External link to a URL to view more information about this collection.
    pub let collectionExternalURL: MetadataViews.ExternalURL
    // Square-sized image to represent this collection.
    pub let collectionSquareImage: MetadataViews.Media
    // Banner-sized image for this collection, recommended to have a size near 1200x630.
    pub let collectionBannerImage: MetadataViews.Media
    // Social links to reach this collection's social homepages.
    // Possible keys may be "instagram", "twitter", "discord", etc.
    pub let collectionSocials: {String: MetadataViews.ExternalURL}

    pub var totalSupply: UInt64

    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event Minted(id: UInt64, address: Address)

    pub event Claim(campaign_id: UInt256, verify_id: UInt256, minter: Address, owner: Address, nft_id: UInt64)
    pub event Transfer(id: UInt64, from: Address, to: Address)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let OwnerStoragePath: StoragePath

    /// Maps each token ID to its owner address
    access(self) let owners: [Address]

    /// Maps each verify ID to its minted status
    access(self) let minted: {UInt256: Bool}

    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        /// The unique ID of each NFT
        pub let id: UInt64

        /// Metadata fields
        pub let name: String
        pub let description: String
        pub let thumbnail: String
        access(self) let metadata: {String: String}

        init(
            id: UInt64,
            name: String,
            description: String,
            thumbnail: String,
            metadata: {String: String}
        ) {
            self.id = id
            self.name = name
            self.description = description
            self.thumbnail = thumbnail
            self.metadata = metadata
        }

        /// Function that returns all the Metadata Views implemented by a Non Fungible Token
        ///
        /// @return An array of Types defining the implemented views. This value will be used by
        ///         developers to know which parameter to pass to the resolveView() method.
        ///
        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.Editions>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.Traits>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.name,
                        description: self.description,
                        thumbnail: MetadataViews.HTTPFile(
                            url: self.thumbnail
                        )
                    )

                case Type<MetadataViews.Editions>():
                    // There is no max number of NFTs that can be minted from this contract
                    // so the max edition field value is set to nil
                    let editionInfo = MetadataViews.Edition(
                        name: self.name.concat(" NFT Edition"),
                        number: self.id, max: nil
                    )
                    let editionList: [MetadataViews.Edition] = [editionInfo]
                    return MetadataViews.Editions(
                        editionList
                    )

                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(
                        self.id
                    )

                case Type<MetadataViews.Royalties>():
                    return MetadataViews.Royalties([])

                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL(
                        StarNFT.baseUri.concat(self.id.toString()).concat(".json")
                    )

                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: StarNFT.CollectionStoragePath,
                        publicPath: StarNFT.CollectionPublicPath,
                        providerPath: /private/StarNFTCollection,
                        publicCollection: Type<&StarNFT.Collection{StarNFT.StarNFTCollectionPublic,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(),
                        publicLinkedType: Type<&StarNFT.Collection{StarNFT.StarNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&StarNFT.Collection{StarNFT.StarNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(),
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                            return <-StarNFT.createEmptyCollection()
                        })
                    )

                case Type<MetadataViews.NFTCollectionDisplay>():
                    return MetadataViews.NFTCollectionDisplay(
                        name: StarNFT.collectionName,
                        description: StarNFT.collectionDescription,
                        externalURL: StarNFT.collectionExternalURL,
                        squareImage: StarNFT.collectionSquareImage,
                        bannerImage: StarNFT.collectionBannerImage,
                        socials: StarNFT.collectionSocials,
                    )

                case Type<MetadataViews.Traits>():
                    return MetadataViews.dictToTraits(dict: self.metadata, excludedNames: [])
                }
                return nil
            }
        }

        /// Defines the methods that are particular to this NFT contract collection
        ///
        pub resource interface StarNFTCollectionPublic {
            pub fun deposit(token: @NonFungibleToken.NFT)
            pub fun getIDs(): [UInt64]
            pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver}
            pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
            pub fun borrowStarNFT(id: UInt64): &StarNFT.NFT? {
                post {
                    (result == nil) || (result?.id == id):
                        "Cannot borrow StarNFT reference: The ID of the returned reference is incorrect"
                }
            }
        }

    /// The resource that will be holding the NFTs inside any account.
    /// In order to be able to manage NFTs any account will need to create
    /// an empty collection first
    ///
    pub resource Collection: StarNFTCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with an `UInt64` ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        /// Removes an NFT from the collection and moves it to the caller
        ///
        /// @param withdrawID: The ID of the NFT that wants to be withdrawn
        /// @return The NFT resource that has been taken out of the collection
        ///
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        /// Adds an NFT to the collections dictionary and adds the ID to the id array
        ///
        /// @param token: The NFT resource to be included in the collection
        ///
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @StarNFT.NFT

            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token

            StarNFT.owners[id] = self.owner!.address

            emit Deposit(id: id, to: self.owner!.address)

            destroy oldToken
        }

        // transfer takes an NFT ID and a reference to a recipient's collection
        // and transfers the NFT corresponding to that ID to the recipient
        pub fun transfer(id: UInt64, recipient: &{NonFungibleToken.CollectionPublic}) {
            post {
                self.ownedNFTs[id] == nil: "The specified NFT was not transferred"
                recipient.borrowNFT(id: id) != nil: "Recipient did not receive the intended NFT"
            }

            let nft: @NonFungibleToken.NFT <- self.withdraw(withdrawID: id)

            emit Transfer(id: id, from: recipient.owner!.address, to: self.owner!.address)

            recipient.deposit(token: <- nft)
        }

        // burn destroys an NFT
        pub fun burn(id: UInt64) {
            post {
                self.ownedNFTs[id] == nil: "The specified NFT was not burned"
            }

            destroy <- self.withdraw(withdrawID: id)
        }

        /// Helper method for getting the collection IDs
        ///
        /// @return An array containing the IDs of the NFTs in the collection
        ///
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        /// Gets a reference to an NFT in the collection so that
        /// the caller can read its metadata and call its methods
        ///
        /// @param id: The ID of the wanted NFT
        /// @return A reference to the wanted NFT resource
        ///
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        /// Gets a reference to an NFT in the collection so that
        /// the caller can read its metadata and call its methods
        ///
        /// @param id: The ID of the wanted NFT
        /// @return A reference to the wanted NFT resource
        ///
        pub fun borrowStarNFT(id: UInt64): &StarNFT.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorized reference to allow downcasting
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &StarNFT.NFT
            }

            return nil
        }

        /// Gets a reference to the NFT only conforming to the `{MetadataViews.Resolver}`
        /// interface so that the caller can retrieve the views that the NFT
        /// is implementing and resolve them
        ///
        /// @param id: The ID of the wanted NFT
        /// @return The resource reference conforming to the Resolver interface
        ///
        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let starNFT = nft as! &StarNFT.NFT
            return starNFT
        }


        destroy() {
            destroy self.ownedNFTs
        }
    }

    /// Allows anyone to create a new empty collection
    ///
    /// @return The new Collection resource
    ///
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    /// Allows anyone to claim an NFT with a valid claim signature from Galxe
    ///
    pub fun claim(
        chain_id: String,
        campaign_id: UInt256,
        verify_id: UInt256,
        cap: UInt256,
        recipient: Address,
        signature: String,
        name: String,
        description: String,
        thumbnail: String,
        metadata: {String: String}
    ) {
        // check if verify_id is already minted
        if StarNFT.minted[verify_id] != nil {
            panic("NFT already minted")
        }

        // turn metadata into a string to verify signature
        var metadataStr = "{"
        metadata.forEachKey(fun (key: String): Bool {
            metadataStr = metadataStr.concat(key).concat(":").concat(metadata[key]!).concat(",")
            return true
        })
        // Removing the trailing comma and space
        if (metadataStr.length > 1) {
            metadataStr = metadataStr.slice(from: 0, upTo: metadataStr.length-1)
        }
        metadataStr = metadataStr.concat("}")

        // get current contract address
        let acct = self.account.address.toString()
        let contractAddr = "A.".concat(acct.slice(from: 2, upTo: acct.length)).concat(".StarNFT")

        let message = "NFT(chain_id:String,contract:String,campaign_id:u64,verify_id:u64,cap:u64,owner:u64,name:String,description:String,thumbnail:String:metadata:{String: String})"
            .concat(chain_id)
            .concat(contractAddr)
            .concat(campaign_id.toString())
            .concat(verify_id.toString())
            .concat(cap.toString())
            .concat(recipient.toString())
            .concat(String.encodeHex(HashAlgorithm.SHA3_256.hash(name.utf8)))
            .concat(String.encodeHex(HashAlgorithm.SHA3_256.hash(description.utf8)))
            .concat(String.encodeHex(HashAlgorithm.SHA3_256.hash(thumbnail.utf8)))
            .concat(String.encodeHex(HashAlgorithm.SHA3_256.hash(metadataStr.utf8)))
        log(message)
        if !self.verifyClaimSignature(
            address: self.signer,
            signature: signature,
            signedData: message.utf8
        ) {
            panic("Invalid signature")
        }

        // Increment the totalSupply for a new ID
        let id = StarNFT.totalSupply

        // Create the new NFT
        var newNFT <- create NFT(
            id: id,
            name: name,
            description: description,
            thumbnail: thumbnail,
            metadata: metadata
        )

        StarNFT.minted[verify_id] = true
        emit Minted(id: id, address: recipient)

        // Get the collection of the current account using a borrowed reference
        let receiver = getAccount(recipient)
            .getCapability(StarNFT.CollectionPublicPath)
            .borrow<&{NonFungibleToken.CollectionPublic}>()
            ?? panic("Could not get receiver reference to the NFT Collection")

        // Update the owners mapping
        StarNFT.owners.append(recipient)

        // Deposit the new NFT into the current account's collection
        receiver.deposit(token: <-newNFT)

        // Increment the total supply
        StarNFT.totalSupply = StarNFT.totalSupply + 1

        let minter = self.account.address

        emit Claim(campaign_id: campaign_id, verify_id: verify_id, minter: minter, owner: recipient, nft_id: id)
    }

    access(self) fun verifyClaimSignature(address: Address, signature: String, signedData: [UInt8]): Bool {
        let signatureBytes = signature.decodeHex()
	    let account = getAccount(self.signer)
	    let keys = account.keys
        var i = 0
        while true {
            if let key = keys.get(keyIndex: i) {
                if key.isRevoked {
                    // do not check revoked keys
                    i = i + 1
                    continue
                }
                let pk = PublicKey(
                        publicKey: key.publicKey.publicKey,
                        signatureAlgorithm: key.publicKey.signatureAlgorithm
                )
                if pk.verify(
                    signature: signatureBytes,
                    signedData: signedData,
                    domainSeparationTag: "",
                    hashAlgorithm: HashAlgorithm.SHA3_256
                ) {
                    return true
                }
            } else {
                return false
            }
            i = i + 1
        }

        return false
    }

    /// Resource that an admin or something similar would own to have admin operations access
    ///
    pub resource Owner {
        pub fun updateSigner(newSigner: Address) {
            StarNFT.signer = newSigner
        }
    }

    // Gets the owner of the given token ID
    pub fun ownerOf(tokenId: UInt64): Address? {
        if tokenId >= 0 {
            return StarNFT.owners[tokenId]
        }
        return nil
    }

    init() {
        self.baseUri = "https://graphigo.stg.galaxy.eco/metadata/0x123/"

        // Initialize signer
        self.signer = self.account.address

        // Initialize collection metadatas
        self.collectionName = "collection name"
        self.collectionDescription = "collection description"
        self.collectionExternalURL = MetadataViews.ExternalURL("https://galxe.com")
        self.collectionSquareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
                url: "https://bafybeifvcfyaljvjl4ei67llykxa2b7kpgpuzh4xcwnkxa6relbyg7kore.ipfs.nftstorage.link"
            ),
            mediaType: "image/png"
        )
        self.collectionBannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
                url: "https://bafybeifvcfyaljvjl4ei67llykxa2b7kpgpuzh4xcwnkxa6relbyg7kore.ipfs.nftstorage.link"
            ),
            mediaType: "image/png"
        )
        self.collectionSocials = {
            "twitter": MetadataViews.ExternalURL("https://twitter.com/oyyblin")
        }

        // Initialize contract internal metadatas
        // Initialize the total supply
        self.totalSupply = 0

        // Initalize mapping from ID to address
        self.owners = []

        // Initialize mapping from verify_id to bool
        self.minted = {}

        // Set the named paths
        self.CollectionStoragePath = /storage/StarNFTCollection
        self.CollectionPublicPath = /public/StarNFTCollection
        self.OwnerStoragePath = /storage/StarNFTOwner

        // Create a Collection resource and save it to storage
        let collection <- create Collection()
        self.account.save(<-collection, to: self.CollectionStoragePath)

        // create a public capability for the collection
        self.account.link<&StarNFT.Collection{NonFungibleToken.CollectionPublic, StarNFT.StarNFTCollectionPublic, MetadataViews.ResolverCollection}>(
            self.CollectionPublicPath,
            target: self.CollectionStoragePath
        )

        emit ContractInitialized()
    }
}
 "
-------
"// SPDX-License-Identifier: MIT

import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import Debug from 0xe81193c424cfd3fb
import Clock from 0xe81193c424cfd3fb
import Templates from 0xe81193c424cfd3fb
import Wearables from 0xe81193c424cfd3fb
import Doodles from 0xe81193c424cfd3fb
import MetadataViews from 0x1d7e57aa55817448
import Redeemables from 0xe81193c424cfd3fb
import TransactionsRegistry from 0xe81193c424cfd3fb

pub contract Admin {

	//store the proxy for the admin
	pub let AdminProxyPublicPath: PublicPath
	pub let AdminProxyStoragePath: StoragePath
	pub let AdminServerStoragePath: StoragePath
	pub let AdminServerPrivatePath: PrivatePath


	// This is just an empty resource to signal that you can control the admin, more logic can be added here or changed later if you want to
	pub resource Server {

	}

	/// ==================================================================================
	// Admin things
	/// ===================================================================================

	//Admin client to use for capability receiver pattern
	pub fun createAdminProxyClient() : @AdminProxy {
		return <- create AdminProxy()
	}

	//interface to use for capability receiver pattern
	pub resource interface AdminProxyClient {
		pub fun addCapability(_ cap: Capability<&Server>)
	}


	//admin proxy with capability receiver
	pub resource AdminProxy: AdminProxyClient {

		access(self) var capability: Capability<&Server>?

		pub fun addCapability(_ cap: Capability<&Server>) {
			pre {
				cap.check() : "Invalid server capablity"
				self.capability == nil : "Server already set"
			}
			self.capability = cap
		}

		pub fun registerWearableSet(_ s: Wearables.Set) {
			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}
			Wearables.addSet(s)
		}

		pub fun retireWearableSet(_ id:UInt64) {
			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}
			Wearables.retireSet(id)
		}

		pub fun registerWearablePosition(_ p: Wearables.Position) {
			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}
			Wearables.addPosition(p)
		}

		pub fun retireWearablePosition(_ id:UInt64) {
			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}
			Wearables.retirePosition(id)
		}

		pub fun registerWearableTemplate(_ t: Wearables.Template) {
			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}
			Wearables.addTemplate(t)
		}

		pub fun retireWearableTemplate(_ id:UInt64) {
			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}
			Wearables.retireTemplate(id)
		}

		pub fun mintWearable(
			recipient: &{NonFungibleToken.Receiver},
			template: UInt64,
			context: {String : String}
		){

			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}

			Wearables.mintNFT(
				recipient: recipient,
				template: template,
				context: context
			)
		}

		pub fun mintEditionWearable(
			recipient: &{NonFungibleToken.Receiver},
			data: Wearables.WearableMintData,
			context: {String : String}
		){

			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}

			Wearables.mintEditionNFT(
				recipient: recipient,
				template: data.template,
				setEdition: data.setEdition,
				positionEdition: data.positionEdition,
				templateEdition: data.templateEdition,
				taggedTemplateEdition: data.taggedTemplateEdition,
				tagEditions: data.tagEditions,
				context: context
			)
		}

		pub fun advanceClock(_ time: UFix64) {
			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}
			Debug.enable(true)
			Clock.enable()
			Clock.tick(time)
		}


		pub fun debug(_ value: Bool) {
			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}
			Debug.enable(value)
		}

		pub fun setFeature(action: String, enabled: Bool) {
			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}
			Templates.setFeature(action: action, enabled: enabled)
		}

		pub fun resetCounter() {
			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}
			Templates.resetCounters()
		}

		pub fun registerDoodlesBaseCharacter(_ d: Doodles.BaseCharacter) {
			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}
			Doodles.setBaseCharacter(d)
		}

		pub fun retireDoodlesBaseCharacter(_ id: UInt64) {
			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}
			Doodles.retireBaseCharacter(id)
		}

		pub fun registerDoodlesSpecies(_ d: Doodles.Species) {
			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}
			Doodles.addSpecies(d)
		}

		pub fun retireDoodlesSpecies(_ id: UInt64) {
			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}
			Doodles.retireSpecies(id)
		}

		pub fun registerDoodlesSet(_ d: Doodles.Set) {
			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}
			Doodles.addSet(d)
		}

		pub fun retireDoodlesSet(_ id: UInt64) {
			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}
			Doodles.retireSet(id)
		}

		pub fun mintDoodles(
			recipient: &{NonFungibleToken.Receiver},
			baseCharacter: UInt64,
			context: {String : String}
		){

			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}

			Doodles.mintNFT(
				recipient: recipient,
				baseCharacter: baseCharacter,
				context: context
			)
		}

		pub fun createRedeemablesSet(name: String, canRedeem: Bool, redeemLimitTimestamp: UFix64, active: Bool) {
			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}
			Redeemables.createSet(name: name, canRedeem: canRedeem, redeemLimitTimestamp: redeemLimitTimestamp, active: active
			)
		}

		pub fun updateRedeemablesSetActive(setId: UInt64, active: Bool) {
			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}
			Redeemables.updateSetActive(setId: setId, active: active)
		}

		pub fun updateRedeemablesSetCanRedeem(setId: UInt64, canRedeem: Bool) {
			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}
			Redeemables.updateSetCanRedeem(setId: setId, canRedeem: canRedeem)
		}

		pub fun updateRedeemablesSetRedeemLimitTimestamp(setId: UInt64, redeemLimitTimestamp: UFix64) {
			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}
			Redeemables.updateSetRedeemLimitTimestamp(setId: setId, redeemLimitTimestamp: redeemLimitTimestamp)
		}

		pub fun createRedeemablesTemplate(
			setId: UInt64,
			name: String,
			description: String,
			brand: String,
			royalties: [MetadataViews.Royalty],
			type: String,
			thumbnail: MetadataViews.Media,
			image: MetadataViews.Media,
			active: Bool,
			extra: {String: AnyStruct}
		) {
			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}
			Redeemables.createTemplate(
				setId: setId,
				name: name,
				description: description,
				brand: brand,
				royalties: royalties,
				type: type,
				thumbnail: thumbnail,
				image: image,
				active: active,
				extra: extra
			)
		}

		pub fun updateRedeemablesTemplateActive(templateId: UInt64, active: Bool) {
			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}
			Redeemables.updateTemplateActive(templateId: templateId, active: active)
		}

		pub fun mintRedeemablesNFT(recipient: &{NonFungibleToken.Receiver}, templateId: UInt64){
			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}
			Redeemables.mintNFT(recipient: recipient, templateId: templateId)
		}

		pub fun burnRedeemablesUnredeemedSet(setId: UInt64) {
			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}
			Redeemables.burnUnredeemedSet(setId: setId)
		}

		pub fun registerDoodlesDropsWearablesMintTransaction(packTypeId: UInt64, packId: UInt64, transactionId: String) {
			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}
			TransactionsRegistry.registerDoodlesDropsWearablesMint(packTypeId: packTypeId, packId: packId, transactionId: transactionId)
		}

		pub fun registerDoodlesDropsRedeemablesMintTransaction(packTypeId: UInt64, packId: UInt64, transactionId: String) {
			pre {
				self.capability != nil: "Cannot create Admin, capability is not set"
			}
			TransactionsRegistry.registerDoodlesDropsRedeemablesMint(packTypeId: packTypeId, packId: packId, transactionId: transactionId)
		}

		init() {
			self.capability = nil
		}

	}

	init() {

		self.AdminProxyPublicPath= /public/characterAdminProxy
		self.AdminProxyStoragePath=/storage/characterAdminProxy

		//create a dummy server for now, if we have a resource later we want to use instead of server we can change to that
		self.AdminServerPrivatePath=/private/characterAdminServer
		self.AdminServerStoragePath=/storage/characterAdminServer
		self.account.save(<- create Server(), to: self.AdminServerStoragePath)
		self.account.link<&Server>( self.AdminServerPrivatePath, target: self.AdminServerStoragePath)
	}

}"
-------
"import CapabilityFactory from 0xd8a7e05a7ac670c0
import FungibleToken from 0xf233dcee88fe0abe

pub contract FTAllFactory {
    pub struct Factory: CapabilityFactory.Factory {
        pub fun getCapability(acct: &AuthAccount, path: CapabilityPath): Capability {
            return acct.getCapability<&{FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance}>(path)
        }
    }
}"
-------
"/**

# Lending related interface definitions all-in-one

# Author: Increment Labs

*/
import FungibleToken from 0xf233dcee88fe0abe

pub contract interface LendingInterfaces {

    pub resource interface PoolPublic {
        pub fun getPoolAddress(): Address
        pub fun getUnderlyingTypeString(): String
        pub fun getUnderlyingAssetType(): String
        pub fun getUnderlyingToLpTokenRateScaled(): UInt256
        pub fun getAccountLpTokenBalanceScaled(account: Address): UInt256
        /// Return snapshot of account borrowed balance in scaled UInt256 format
        pub fun getAccountBorrowBalanceScaled(account: Address): UInt256
        /// Return: [scaledExchangeRate, scaledLpTokenBalance, scaledBorrowBalance, scaledAccountBorrowPrincipal, scaledAccountBorrowIndex]
        pub fun getAccountSnapshotScaled(account: Address): [UInt256; 5]
        pub fun getAccountRealtimeScaled(account: Address): [UInt256; 5]
        pub fun getInterestRateModelAddress(): Address
        pub fun getPoolReserveFactorScaled(): UInt256
        pub fun getPoolAccrualBlockNumber(): UInt256
        pub fun getPoolTotalBorrowsScaled(): UInt256
        pub fun getPoolBorrowIndexScaled(): UInt256
        pub fun getPoolTotalSupplyScaled(): UInt256
        pub fun getPoolCash(): UInt256
        pub fun getPoolTotalLpTokenSupplyScaled(): UInt256
        pub fun getPoolTotalReservesScaled(): UInt256
        pub fun getPoolBorrowRateScaled(): UInt256
        pub fun getPoolSupplyAprScaled(): UInt256
        pub fun getPoolBorrowAprScaled(): UInt256
        pub fun getPoolSupplierCount(): UInt256
        pub fun getPoolBorrowerCount(): UInt256
        pub fun getPoolSupplierList(): [Address]
        pub fun getPoolBorrowerList(): [Address]
        pub fun getPoolSupplierSlicedList(from: UInt64, to: UInt64): [Address]
        pub fun getPoolBorrowerSlicedList(from: UInt64, to: UInt64): [Address]
        pub fun getFlashloanRateBps(): UInt64

        /// Accrue pool interest and checkpoint latest data to pool states
        pub fun accrueInterest()
        pub fun accrueInterestReadonly(): [UInt256; 4]
        pub fun getPoolCertificateType(): Type
        /// Note: Check to ensure @callerPoolCertificate's run-time type is another LendingPool's.IdentityCertificate,
        /// so that this public seize function can only be invoked by another LendingPool contract
        pub fun seize(
            seizerPoolCertificate: @{LendingInterfaces.IdentityCertificate},
            seizerPool: Address,
            liquidator: Address,
            borrower: Address,
            scaledBorrowerCollateralLpTokenToSeize: UInt256
        )

        pub fun supply(supplierAddr: Address, inUnderlyingVault: @FungibleToken.Vault)
        pub fun redeem(userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>, numLpTokenToRedeem: UFix64): @FungibleToken.Vault
        pub fun redeemUnderlying(userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>, numUnderlyingToRedeem: UFix64): @FungibleToken.Vault
        pub fun borrow(userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>, borrowAmount: UFix64): @FungibleToken.Vault
        pub fun repayBorrow(borrower: Address, repayUnderlyingVault: @FungibleToken.Vault): @FungibleToken.Vault?
        pub fun liquidate(liquidator: Address, borrower: Address, poolCollateralizedToSeize: Address, repayUnderlyingVault: @FungibleToken.Vault): @FungibleToken.Vault?
        pub fun flashloan(executorCap: Capability<&{LendingInterfaces.FlashLoanExecutor}>, requestedAmount: UFix64, params: {String: AnyStruct}) {return}
    }

    pub resource interface PoolAdminPublic {
        pub fun setInterestRateModel(newInterestRateModelAddress: Address)
        pub fun setReserveFactor(newReserveFactor: UFix64)
        pub fun setPoolSeizeShare(newPoolSeizeShare: UFix64)
        pub fun setComptroller(newComptrollerAddress: Address)
        /// A pool can only be initialized once
        pub fun initializePool(reserveFactor: UFix64, poolSeizeShare: UFix64, interestRateModelAddress: Address)
        pub fun withdrawReserves(reduceAmount: UFix64): @FungibleToken.Vault
        pub fun setFlashloanRateBps(rateBps: UInt64)
        pub fun setFlashloanOpen(isOpen: Bool)
    }

    pub resource interface FlashLoanExecutor {
        pub fun executeAndRepay(loanedToken: @FungibleToken.Vault, params: {String: AnyStruct}): @FungibleToken.Vault
    }

    pub resource interface InterestRateModelPublic {
        /// exposing model specific fields, e.g.: modelName, model params.
        pub fun getInterestRateModelParams(): {String: AnyStruct}
        /// pool's capital utilization rate (scaled up by scaleFactor, e.g. 1e18)
        pub fun getUtilizationRate(cash: UInt256, borrows: UInt256, reserves: UInt256): UInt256
        /// Get the borrow interest rate per block (scaled up by scaleFactor, e.g. 1e18)
        pub fun getBorrowRate(cash: UInt256, borrows: UInt256, reserves: UInt256): UInt256
        /// Get the supply interest rate per block (scaled up by scaleFactor, e.g. 1e18)
        pub fun getSupplyRate(cash: UInt256, borrows: UInt256, reserves: UInt256, reserveFactor: UInt256): UInt256
        /// Get the number of blocks per year.
        pub fun getBlocksPerYear(): UInt256
    }

    /// IdentityCertificate resource which is used to identify account address or perform caller authentication
    pub resource interface IdentityCertificate {}

    pub resource interface OraclePublic {
        /// Get the given pool's underlying asset price denominated in USD.
        /// Note: Return value of 0.0 means the given pool's price feed is not available.
        pub fun getUnderlyingPrice(pool: Address): UFix64

        /// Return latest reported data in [timestamp, priceData]
        pub fun latestResult(pool: Address): [UFix64; 2]

        /// Return supported markets' addresses
        pub fun getSupportedFeeds(): [Address]
    }

    pub resource interface ComptrollerPublic {
        /// Return error string on condition (or nil)
        pub fun supplyAllowed(
            poolCertificate: @{LendingInterfaces.IdentityCertificate},
            poolAddress: Address,
            supplierAddress: Address,
            supplyUnderlyingAmountScaled: UInt256
        ): String?

        pub fun redeemAllowed(
            poolCertificate: @{LendingInterfaces.IdentityCertificate},
            poolAddress: Address,
            redeemerAddress: Address,
            redeemLpTokenAmountScaled: UInt256
        ): String?

        pub fun borrowAllowed(
            poolCertificate: @{LendingInterfaces.IdentityCertificate},
            poolAddress: Address,
            borrowerAddress: Address,
            borrowUnderlyingAmountScaled: UInt256
        ): String?

        pub fun repayAllowed(
            poolCertificate: @{LendingInterfaces.IdentityCertificate},
            poolAddress: Address,
            borrowerAddress: Address,
            repayUnderlyingAmountScaled: UInt256
        ): String?

        pub fun liquidateAllowed(
            poolCertificate: @{LendingInterfaces.IdentityCertificate},
            poolBorrowed: Address,
            poolCollateralized: Address,
            borrower: Address,
            repayUnderlyingAmountScaled: UInt256
        ): String?

        pub fun seizeAllowed(
            poolCertificate: @{LendingInterfaces.IdentityCertificate},
            borrowPool: Address,
            collateralPool: Address,
            liquidator: Address,
            borrower: Address,
            seizeCollateralPoolLpTokenAmountScaled: UInt256
        ): String?

        pub fun callerAllowed(
            callerCertificate: @{LendingInterfaces.IdentityCertificate},
            callerAddress: Address
        ): String?

        pub fun calculateCollateralPoolLpTokenToSeize(
            borrower: Address,
            borrowPool: Address,
            collateralPool: Address,
            actualRepaidBorrowAmountScaled: UInt256
        ): UInt256

        pub fun getUserCertificateType(): Type
        pub fun getPoolPublicRef(poolAddr: Address): &{PoolPublic}
        pub fun getAllMarkets(): [Address]
        pub fun getMarketInfo(poolAddr: Address): {String: AnyStruct}
        pub fun getUserMarkets(userAddr: Address): [Address]
        pub fun getUserCrossMarketLiquidity(userAddr: Address): [String; 3]
        pub fun getUserMarketInfo(userAddr: Address, poolAddr: Address): {String: AnyStruct}
    }
}
"
-------
"
  import FungibleToken from 0xf233dcee88fe0abe

   access(all) contract ChainlinkFlowToken3: FungibleToken {
      pub var totalSupply: UFix64

      /// TokensInitialized
      ///
      /// The event that is emitted when the contract is created
      pub event TokensInitialized(initialSupply: UFix64)

      /// TokensWithdrawn
      ///
      /// The event that is emitted when tokens are withdrawn from a Vault
      pub event TokensWithdrawn(amount: UFix64, from: Address?)

      /// TokensDeposited
      ///
      /// The event that is emitted when tokens are deposited to a Vault
      pub event TokensDeposited(amount: UFix64, to: Address?)

      /// TokensMinted
      ///
      /// The event that is emitted when new tokens are minted
      pub event TokensMinted(amount: UFix64)

      pub let TokenVaultStoragePath: StoragePath
      pub let TokenVaultPublicPath: PublicPath
      pub let TokenMinterStoragePath: StoragePath

      pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {
          pub var balance: UFix64

          init(balance: UFix64) {
              self.balance = balance
          }

          pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
              self.balance = self.balance - amount
              emit TokensWithdrawn(amount: amount, from: self.owner?.address)
              return <- create Vault(balance: amount)
          }

          pub fun deposit(from: @FungibleToken.Vault) {
              let vault <- from as! @ChainlinkFlowToken3.Vault
              self.balance = self.balance + vault.balance
              emit TokensDeposited(amount: vault.balance, to: self.owner?.address)
              vault.balance = 0.0
              destroy vault // Make sure we get rid of the vault
          }

          destroy() {
              ChainlinkFlowToken3.totalSupply = ChainlinkFlowToken3.totalSupply - self.balance
          }
      }

      pub fun createEmptyVault(): @FungibleToken.Vault {
          return <- create Vault(balance: 0.0)
      }

      access(contract) fun initialMint(initialMintValue: UFix64): @FungibleToken.Vault {
          return <- create Vault(balance: initialMintValue)
      }

      pub resource Minter {
          pub fun mintTokens(amount: UFix64): @FungibleToken.Vault {
          pre {
                  amount > 0.0: "Amount minted must be greater than zero"
              }
              ChainlinkFlowToken3.totalSupply = ChainlinkFlowToken3.totalSupply + amount
              return <- create Vault(balance:amount)
          }

      }

      init() {
          self.totalSupply = 100.00
          self.TokenVaultStoragePath = /storage/ChainlinkFlowToken3Vault
          self.TokenVaultPublicPath = /public/ChainlinkFlowToken3Vault
          self.TokenMinterStoragePath = /storage/ChainlinkFlowToken3Minter

          self.account.save(<- create Minter(), to: ChainlinkFlowToken3.TokenMinterStoragePath)

         //
         // Create an Empty Vault for the Minter
         //
          self.account.save(<- ChainlinkFlowToken3.initialMint(initialMintValue: self.totalSupply), to: ChainlinkFlowToken3.TokenVaultStoragePath)
          self.account.link<&ChainlinkFlowToken3.Vault{FungibleToken.Balance, FungibleToken.Receiver}>(ChainlinkFlowToken3.TokenVaultPublicPath, target: ChainlinkFlowToken3.TokenVaultStoragePath)
      }
   }

      "
-------
"import CapabilityFactory from 0xd8a7e05a7ac670c0
import FungibleToken from 0xf233dcee88fe0abe

pub contract FTBalanceFactory {
    pub struct Factory: CapabilityFactory.Factory {
        pub fun getCapability(acct: &AuthAccount, path: CapabilityPath): Capability {
            return acct.getCapability<&{FungibleToken.Balance}>(path)
        }
    }
}"
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe

pub contract AlphaNFTV1 : NonFungibleToken {
    // Events
    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event NFTDestroyed(id: UInt64)
    pub event NFTMinted(nftId: UInt64, templateId: UInt64, mintNumber: UInt64)
    pub event TemplateCreated(templateId: UInt64, maxSupply: UInt64)

    // Paths
    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath

    pub var nextTemplateId: UInt64

    pub var totalSupply: UInt64

    access(account) var templates: {UInt64: Template}

    access(self) var nfts: {UInt64: NFTData}

    pub struct Template {
        pub let templateId: UInt64
        pub var maxSupply: UInt64
        pub var issuedSupply: UInt64
        access(contract) var immutableData: {String: AnyStruct}

        init(maxSupply: UInt64, immutableData: {String: AnyStruct}) {
            pre {
                maxSupply > 0 : "MaxSupply must be greater than zero"
            }

            self.templateId = AlphaNFTV1.nextTemplateId
            self.maxSupply = maxSupply
            self.immutableData = immutableData
            self.issuedSupply = 0
        }
        pub fun getImmutableData(): {String:AnyStruct} {
            return self.immutableData
        }
        access(account) fun incrementIssuedSupply(): UInt64 {
            pre {
                self.issuedSupply < self.maxSupply: "Template reached max supply"
            }
            self.issuedSupply = self.issuedSupply + 1
            return self.issuedSupply
        }

    }

    pub struct NFTData {
        pub let templateId: UInt64
        pub let mintNumber: UInt64

        init(templateId: UInt64, mintNumber: UInt64) {
            self.templateId = templateId
            self.mintNumber = mintNumber
        }
    }
    // The resource that represents the AlphaNFTV1 NFTs
    //
    pub resource NFT: NonFungibleToken.INFT {
        pub let id: UInt64

        init(templateId: UInt64, mintNumber: UInt64) {
            AlphaNFTV1.totalSupply = AlphaNFTV1.totalSupply + 1

            self.id = AlphaNFTV1.totalSupply
            AlphaNFTV1.nfts[self.id] = NFTData(templateId: templateId, mintNumber: mintNumber)

            emit NFTMinted(nftId: self.id, templateId: templateId, mintNumber: mintNumber)
        }
        destroy(){
            emit NFTDestroyed(id: self.id)
        }
    }
    pub resource interface AlphaNFTV1CollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowAlphaNFTV1(id: UInt64): &AlphaNFTV1.NFT? {
            // If the result isn't nil, the id of the returned reference
            // should be the same as the argument to the function
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow AlphaNFTV1 reference: The ID of the returned reference is incorrect"
            }
        }
    }

    // Collection is a resource that every user who owns NFTs
    // will store in their account to manage their NFTS
    //
    pub resource Collection: AlphaNFTV1CollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic {
        // dictionary of NFT conforming tokens
		// NFT is a resource type with an `UInt64` ID field
		pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

       	// withdraw removes an NFT from the collection and moves it to the caller
		pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
			let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")
			emit Withdraw(id: token.id, from: self.owner?.address)
			return <-token
		}

        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @AlphaNFTV1.NFT
            let id = token.id
            let oldToken <- self.ownedNFTs[id] <- token
            if self.owner?.address != nil {
                emit Deposit(id: id, to: self.owner?.address)
            }
            destroy oldToken
        }

        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowAlphaNFTV1(id: UInt64): &AlphaNFTV1.NFT? {
            if self.ownedNFTs[id] != nil {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &AlphaNFTV1.NFT
            }
            else{
                return nil
            }
        }

        init() {
            self.ownedNFTs <- {}
        }

        destroy () {
            destroy self.ownedNFTs
        }
    }
    //method to create new Template, only access by the verified user
    access(account) fun createTemplate(maxSupply: UInt64, immutableData: {String: AnyStruct}) {
        let newTemplate = Template(maxSupply: maxSupply, immutableData: immutableData)
        AlphaNFTV1.templates[AlphaNFTV1.nextTemplateId] = newTemplate
        emit TemplateCreated(templateId: AlphaNFTV1.nextTemplateId, maxSupply: maxSupply)
        AlphaNFTV1.nextTemplateId = AlphaNFTV1.nextTemplateId + 1
    }
    //method to mint NFT, only access by the verified user
    access(account) fun mintNFT(templateInfo: {String: UInt64}, account: Address) {
        pre {
            account != nil: "invalid receipt Address"
            AlphaNFTV1.templates[templateInfo["id"]!] != nil: "Template Id must be valid"
        }
        let receiptAccount = getAccount(account)
        let recipientCollection = receiptAccount
            .getCapability(AlphaNFTV1.CollectionPublicPath)
            .borrow<&{AlphaNFTV1.AlphaNFTV1CollectionPublic}>()
            ?? panic("Could not get receiver reference to the NFT Collection")
        let mintNumberFromSupply = AlphaNFTV1.templates[templateInfo["id"]!]!.incrementIssuedSupply()
        let mintNumber = templateInfo["serial"] ?? mintNumberFromSupply
        var newNFT: @NFT <- create NFT(templateId: templateInfo["id"]!, mintNumber: mintNumber)
        recipientCollection.deposit(token: <-newNFT)
    }

    // public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create AlphaNFTV1.Collection()
    }

    //public function to get all templates
    pub fun getTemplates(): {UInt64: Template} {
        return AlphaNFTV1.templates
    }

    //public function to get the latest template id
    pub fun getLatestTemplateId() : UInt64 {
        return AlphaNFTV1.nextTemplateId - 1
    }

    //public function to get template by id
    pub fun getTemplateById(templateId: UInt64): Template {
        pre {
            AlphaNFTV1.templates[templateId] != nil: "Template id does not exist"
        }
        return AlphaNFTV1.templates[templateId]!
    }
    //public function to get nft-data by id
    pub fun getNFTData(nftId: UInt64): NFTData {
        pre {
            AlphaNFTV1.nfts[nftId] != nil:"nft id does not exist"
        }
        return AlphaNFTV1.nfts[nftId]!
    }

    init(){
        self.nextTemplateId = 1
        self.totalSupply = 0
        self.templates = {}
        self.nfts = {}
        self.CollectionStoragePath = /storage/AlphaNFTV1Collection
        self.CollectionPublicPath = /public/AlphaNFTV1Collection
    }
}
 "
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract Boneyard: NonFungibleToken {

  pub struct BoneyardDisplay {
    pub let itemId: UInt64
    pub let name: String
    pub let description: String
    pub let editionSize: UInt64
    pub let editionNumber: UInt64
    pub let collectionName: String
    pub let collectionDescription: String
    pub let collectionSquareImageCID: String
    pub let collectionBannerImageCID: String
    pub let imageCID: AnyStruct{MetadataViews.File}
    pub let creatorName: String
    pub let mintDateTime: UInt64
    pub let mintLocation: String
    pub let copyrightHolder: String
    pub let minterName: String
    pub let fileFormat: String
    pub let fileSizeMb: UFix64
    pub let rightsAndObligationsSummary: String
    pub let rightsAndObligationsFullText: String
    pub let nftRarityScore: UFix64
    pub let nftRarityDescription: String

    init(
      itemId: UInt64,
      name: String,
      description: String,
      editionSize: UInt64,
      editionNumber: UInt64,
      collectionName: String,
      collectionDescription: String,
      collectionSquareImageCID: String,
      collectionBannerImageCID: String,
      creatorName: String,
      mintDateTime: UInt64,
      mintLocation: String,
      copyrightHolder: String,
      minterName: String,
      fileFormat: String,
      fileSizeMb: UFix64,
      rightsAndObligationsSummary: String,
      rightsAndObligationsFullText: String,
      nftRarityScore: UFix64,
      nftRarityDescription: String,
      imageCID: AnyStruct{MetadataViews.File}
    ) {
      self.itemId = itemId
      self.name = name
      self.description = description
      self.editionSize = editionSize
      self.editionNumber = editionNumber
      self.collectionName = collectionName
      self.collectionDescription = collectionDescription
      self.collectionSquareImageCID = collectionSquareImageCID
      self.collectionBannerImageCID = collectionBannerImageCID
      self.imageCID = imageCID
      self.creatorName = creatorName
      self.mintDateTime = mintDateTime
      self.mintLocation = mintLocation
      self.copyrightHolder = copyrightHolder
      self.minterName = minterName
      self.fileFormat = fileFormat
      self.fileSizeMb = fileSizeMb
      self.rightsAndObligationsSummary = rightsAndObligationsSummary
      self.rightsAndObligationsFullText = rightsAndObligationsFullText
      self.nftRarityScore = nftRarityScore
      self.nftRarityDescription = nftRarityDescription
    }
  }

  // Total NFTs minted
  pub var totalSupply: UInt64

  // Events
  pub event ContractInitialized()
  pub event Withdraw(id: UInt64, from: Address?)
  pub event Deposit(id: UInt64, to: Address?)
  pub event Minted(id: UInt64, name:String)

  // Path Names
  pub let CollectionStoragePath: StoragePath
  pub let CollectionPublicPath: PublicPath
  pub let MinterStoragePath: StoragePath

  pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
    // id
    pub let id: UInt64

    // display
    pub let name: String
    pub let description: String

    pub let editionSize: UInt64
    pub let editionNumber: UInt64

    // collectionDisplay
    pub let collectionName: String
    pub let collectionDescription: String
    pub let collectionSquareImageCID: String
    pub let collectionBannerImageCID: String

    // traits
    // traits data is a dictionary of key value pairs. {
    //  "value": "Pure Jet",
    //  "rarityScore": 0.1,
    //  "rarityDescription": "Common",
    // }

    pub let nftCategoryData: [{String: AnyStruct}]
    pub let airForceData: [{String: AnyStruct}]
    pub let wingData: [{String: AnyStruct}]
    pub let squadronData: [{String: AnyStruct}]
    pub let aircraftNumberData: [{String: AnyStruct}]
    pub let roundelData: [{String: AnyStruct}]
    pub let commandMarkingData: [{String: AnyStruct}]
    pub let aircraftMarkingData: [{String: AnyStruct}]

    // IPFSFile
    pub let imageCID: String

    // Royalties
    access(self) let royalties: [MetadataViews.Royalty]

    pub let creatorName: String
    pub let mintDateTime: UInt64
    pub let mintLocation: String
    pub let copyrightHolder: String
    pub let minterName: String

    pub let fileFormat: String
    pub let fileSizeMb: UFix64

    pub let rightsAndObligationsSummary: String
    pub let rightsAndObligationsFullText: String

    pub let nftRarityScore: UFix64
    pub let nftRarityDescription: String

    init(
      id: UInt64,
      name: String,
      description: String,
      editionSize: UInt64,
      editionNumber: UInt64,
      collectionName: String,
      collectionDescription: String,
      collectionSquareImageCID: String,
      collectionBannerImageCID: String,
      nftCategoryData: [{String: AnyStruct}],
      airForceData: [{String: AnyStruct}],
      wingData: [{String: AnyStruct}],
      squadronData: [{String: AnyStruct}],
      aircraftNumberData: [{String: AnyStruct}],
      roundelData: [{String: AnyStruct}],
      commandMarkingData: [{String: AnyStruct}],
      aircraftMarkingData: [{String: AnyStruct}],
      royalties: [MetadataViews.Royalty],
      imageCID: String,
      creatorName: String,
      copyrightHolder: String,
      mintDateTime: UInt64,
      minterName: String,
      mintLocation: String,
      fileFormat: String,
      fileSizeMb: UFix64,
      rightsAndObligationsSummary: String,
      rightsAndObligationsFullText: String,
      nftRarityScore: UFix64,
      nftRarityDescription: String
    ) {
      self.id = id
      self.name = name
      self.description = description
      self.editionSize = editionSize
      self.editionNumber = editionNumber
      self.collectionName = collectionName
      self.collectionDescription = collectionDescription
      self.collectionSquareImageCID = collectionSquareImageCID
      self.collectionBannerImageCID = collectionBannerImageCID
      self.nftCategoryData = nftCategoryData
      self.airForceData = airForceData
      self.wingData = wingData
      self.squadronData = squadronData
      self.aircraftNumberData = aircraftNumberData
      self.roundelData = roundelData
      self.commandMarkingData = commandMarkingData
      self.aircraftMarkingData = aircraftMarkingData
      self.royalties = royalties
      self.imageCID = imageCID
      self.creatorName = creatorName
      self.copyrightHolder = copyrightHolder
      self.mintDateTime = mintDateTime
      self.minterName = minterName
      self.mintLocation = mintLocation
      self.fileFormat = fileFormat
      self.fileSizeMb = fileSizeMb
      self.rightsAndObligationsSummary = rightsAndObligationsSummary
      self.rightsAndObligationsFullText = rightsAndObligationsFullText
      self.nftRarityScore = nftRarityScore
      self.nftRarityDescription = nftRarityDescription
    }

    pub fun getViews(): [Type] {
      return [
        Type<BoneyardDisplay>(),
        Type<MetadataViews.IPFSFile>(),
        Type<MetadataViews.Display>(),
        Type<MetadataViews.ExternalURL>(),
        Type<MetadataViews.NFTCollectionData>(),
        Type<MetadataViews.NFTCollectionDisplay>(),
        Type<MetadataViews.Medias>(),
        Type<MetadataViews.Royalties>(),
        Type<MetadataViews.Traits>(),
        Type<MetadataViews.Editions>()
      ]
    }

    pub fun resolveView(_ view: Type): AnyStruct? {
      switch view {
        case Type<BoneyardDisplay>():
          return BoneyardDisplay(
            itemId: self.id,
            name: self.name,
            description: self.description,
            editionSize: self.editionSize,
            editionNumber: self.editionNumber,
            collectionName: self.collectionName,
            collectionDescription: self.collectionDescription,
            collectionSquareImageCID: self.collectionSquareImageCID,
            collectionBannerImageCID: self.collectionBannerImageCID,
            creatorName: self.creatorName,
            mintDateTime: self.mintDateTime,
            mintLocation: self.mintLocation,
            copyrightHolder: self.copyrightHolder,
            minterName: self.minterName,
            fileFormat: self.fileFormat,
            fileSizeMb: self.fileSizeMb,
            rightsAndObligationsSummary: self.rightsAndObligationsSummary,
            rightsAndObligationsFullText: self.rightsAndObligationsFullText,
            nftRarityScore: self.nftRarityScore,
            nftRarityDescription: self.nftRarityDescription,
            imageCID: MetadataViews.IPFSFile(
              cid: self.imageCID,
              path: nil
            )
          )
        case Type<MetadataViews.IPFSFile>():
          return MetadataViews.IPFSFile(
            cid: self.imageCID,
            path: nil
          )
        case Type<MetadataViews.Display>():
          return MetadataViews.Display(
            name: self.name,
            description: self.description,
            image: MetadataViews.IPFSFile(
              cid: self.imageCID,
              path: nil
            )
          )
        case Type<MetadataViews.ExternalURL>():
          return MetadataViews.ExternalURL(url: "https://www.boneyard.cloud")
        case Type<MetadataViews.NFTCollectionData>():
          return MetadataViews.NFTCollectionData(
            storagePath: Boneyard.CollectionStoragePath,
            publicPath: Boneyard.CollectionPublicPath,
            providerPath: /private/BoneyardCollection,
            publicCollection: Type<&Boneyard.Collection{Boneyard.BoneyardCollectionPublic, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}>(),
            publicLinkedType: Type<&Boneyard.Collection{Boneyard.BoneyardCollectionPublic, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}>(),
            providerLinkedType: Type<&Boneyard.Collection{Boneyard.BoneyardCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}>(),
            createEmptyCollectionFunction: fun (): @NonFungibleToken.Collection {
              return <- Boneyard.createEmptyCollection()
            }
          )
        case Type<MetadataViews.NFTCollectionDisplay>():
          return MetadataViews.NFTCollectionDisplay(
            name: self.collectionName,
            description: self.collectionDescription,
            externalURL: MetadataViews.ExternalURL(url: "https://www.boneyard.cloud"),
            squareImage: MetadataViews.Media(
              file: MetadataViews.IPFSFile(
                cid: self.collectionSquareImageCID,
                path: nil,
              ),
              mediaType: "image/png"
            ),
            bannerImage: MetadataViews.Media(
              file: MetadataViews.IPFSFile(
                cid: self.collectionBannerImageCID,
                path: nil,
              ),
              mediaType: "image/png"
            ),
            socials: {
              "mastodon": MetadataViews.ExternalURL(url: "https://me.dm/@The_Boneyard"),
              "twitter": MetadataViews.ExternalURL(url: "https://twitter.com/TheBoneyardNFT")
            }
          )
        case Type<MetadataViews.Medias>():
          return MetadataViews.Medias([
            MetadataViews.Media(
              file: MetadataViews.IPFSFile(
                  cid: self.imageCID,
                  path: nil
              ),
              mediaType: "image/png"
            )
          ])
        case Type<MetadataViews.Royalties>():
          return MetadataViews.Royalties(
            royalties: self.royalties
          )
        case Type<MetadataViews.Traits>():
          // traits data is a dictionary of key value pairs. {
          //  "value": "Pure Jet",
          //  "rarityScore": 0.1,
          //  "rarityDescription": "Common",
          // }
          let nftCategoryTraits: [MetadataViews.Trait] = []
          for category in self.nftCategoryData {
            nftCategoryTraits.append(MetadataViews.Trait(
              name: "NFT Category",
              value: category["value"],
              displayType: nil,
              rarity: MetadataViews.Rarity(
                score: UFix64.fromString(category["rarityScore"]! as? String ?? "0.0"),
                max: 1.0,
                description: category["rarityDescription"] as? String ?? ""
              ),
            ))
          }
          let airForceTraits: [MetadataViews.Trait] = []
          for airForce in self.airForceData {
            airForceTraits.append(MetadataViews.Trait(
              name: "Air Force",
              value: airForce["value"],
              displayType: nil,
              rarity: MetadataViews.Rarity(
                score: UFix64.fromString(airForce["rarityScore"]! as? String ?? "0.0"),
                max: 1.0,
                description: airForce["rarityDescription"] as? String ?? ""
              ),
            ))
          }
          let wingTraits: [MetadataViews.Trait] = []
          for wing in self.wingData {
            wingTraits.append(MetadataViews.Trait(
              name: "Wing",
              value: wing["value"],
              displayType: nil,
              rarity: MetadataViews.Rarity(
                score: UFix64.fromString(wing["rarityScore"]! as? String ?? "0.0"),
                max: 1.0,
                description: wing["rarityDescription"] as? String ?? ""
              ),
            ))
          }
          let squadronTraits: [MetadataViews.Trait] = []
          for squadron in self.squadronData {
            squadronTraits.append(MetadataViews.Trait(
              name: "Squadron",
              value: squadron["value"],
              displayType: nil,
              rarity: MetadataViews.Rarity(
                score: UFix64.fromString(squadron["rarityScore"]! as? String ?? "0.0"),
                max: 1.0,
                description: squadron["rarityDescription"] as? String ?? ""
              ),
            ))
          }
          let aircraftNumberTraits: [MetadataViews.Trait] = []
          for aircraftNumber in self.aircraftNumberData {
            aircraftNumberTraits.append(MetadataViews.Trait(
              name: "Aircraft Number",
              value: aircraftNumber["value"],
              displayType: nil,
              rarity: MetadataViews.Rarity(
                score: UFix64.fromString(aircraftNumber["rarityScore"]! as? String ?? "0.0"),
                max: 1.0,
                description: aircraftNumber["rarityDescription"] as? String ?? ""
              ),
            ))
          }
          let roundelTraits: [MetadataViews.Trait] = []
          for roundel in self.roundelData {
            roundelTraits.append(MetadataViews.Trait(
              name: "Roundel",
              value: roundel["value"],
              displayType: nil,
              rarity: MetadataViews.Rarity(
                score: UFix64.fromString(roundel["rarityScore"]! as? String ?? "0.0"),
                max: 1.0,
                description: roundel["rarityDescription"] as? String ?? ""
              ),
            ))
          }
          let commandMarkingTraits: [MetadataViews.Trait] = []
          for commandMarking in self.commandMarkingData {
            commandMarkingTraits.append(MetadataViews.Trait(
              name: "Command Marking",
              value: commandMarking["value"],
              displayType: nil,
              rarity: MetadataViews.Rarity(
                score: UFix64.fromString(commandMarking["rarityScore"]! as? String ?? "0.0"),
                max: 1.0,
                description: commandMarking["rarityDescription"] as? String ?? ""
              ),
            ))
          }
          let aircraftMarkingTraits: [MetadataViews.Trait] = []
          for aircraftMarking in self.aircraftMarkingData {
            aircraftMarkingTraits.append(MetadataViews.Trait(
              name: "Aircraft Marking",
              value: aircraftMarking["value"],
              displayType: nil,
              rarity: MetadataViews.Rarity(
                score: UFix64.fromString(aircraftMarking["rarityScore"]! as? String ?? "0.0"),
                max: 1.0,
                description: aircraftMarking["rarityDescription"] as? String ?? ""
              ),
            ))
          }

          let otherTraits: [MetadataViews.Trait] = [
            MetadataViews.Trait(name: "NFT Creator", value: self.creatorName, displayType: nil, rarity: nil),
            MetadataViews.Trait(name: "NFT Copyright Holder", value: self.copyrightHolder, displayType: nil, rarity: nil),
            MetadataViews.Trait(name: "Minter Name", value: self.minterName, displayType: nil, rarity: nil),
            MetadataViews.Trait(name: "NFT Mint Date", value: self.mintDateTime, displayType: "Date", rarity: nil),
            MetadataViews.Trait(name: "NFT Mint Location", value: self.mintLocation, displayType: nil, rarity: nil),
            MetadataViews.Trait(name: "NFT License Agreement Summary", value: self.rightsAndObligationsSummary, displayType: nil, rarity: nil),
            MetadataViews.Trait(name: "NFT License Agreement Full", value: self.rightsAndObligationsFullText, displayType: nil, rarity: nil),
            MetadataViews.Trait(name: "NFT File Format", value: self.fileFormat, displayType: nil, rarity: nil),
            MetadataViews.Trait(name: "NFT File Size", value: self.fileSizeMb, displayType: nil, rarity: nil),
            MetadataViews.Trait(name: "NFT Rarity Score", value: self.nftRarityScore, displayType: nil, rarity: nil),
            MetadataViews.Trait(name: "NFT Rarity Description", value: self.nftRarityDescription, displayType: nil, rarity: nil)
          ]

          let allTraits: [MetadataViews.Trait] = nftCategoryTraits.concat(
            airForceTraits.concat(
              wingTraits.concat(
                squadronTraits.concat(
                  aircraftNumberTraits.concat(
                    roundelTraits.concat(
                      commandMarkingTraits.concat(
                        aircraftMarkingTraits.concat(
                          otherTraits
                        )
                      )
                    )
                  )
                )
              )
            )
          )

          return MetadataViews.Traits(allTraits)
        case Type<MetadataViews.Editions>():
          return MetadataViews.Editions(
            infoList: [
              MetadataViews.Edition(
                name: nil,
                number: self.editionNumber,
                max: self.editionSize,
              )
            ]
          )
      }

      return nil
    }
  }

  pub resource interface BoneyardCollectionPublic {
    pub fun deposit(token: @NonFungibleToken.NFT)
    pub fun getIDs(): [UInt64]
    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
    pub fun borrowBoneyard(id: UInt64): &Boneyard.NFT? {
      post {
        (result == nil) || (result?.id == id):
            "Cannot borrow Boneyard reference: the ID of the returned reference is incorrect"
      }
    }
    pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver}
  }

  pub resource Collection: BoneyardCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
      // dictionary of NFT conforming tokens
      // NFT is a resource type with an `UInt64` ID field
      pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

      init () {
        self.ownedNFTs <- {}
      }

      // withdraw removes an NFT from the collection and moves it to the caller
      pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
        let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

        emit Withdraw(id: token.id, from: self.owner?.address)

        return <-token
      }

      // deposit takes a NFT and adds it to the collections dictionary
      // and adds the ID to the id array
      pub fun deposit(token: @NonFungibleToken.NFT) {
        let token <- token as! @Boneyard.NFT

        let id: UInt64 = token.id

        // add the new token to the dictionary which removes the old one
        let oldToken <- self.ownedNFTs[id] <- token

        emit Deposit(id: id, to: self.owner?.address)

        destroy oldToken
      }

      pub fun getIDs(): [UInt64] {
        return self.ownedNFTs.keys
      }

      // borrowNFT gets a reference to an NFT in the collection
      // so that the caller can read its metadata and call its methods
      pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
        return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
      }

      pub fun borrowBoneyard(id: UInt64): &Boneyard.NFT? {
        if self.ownedNFTs[id] != nil {
          // Create an authorized reference to allow downcasting
          let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
          return ref as! &Boneyard.NFT
        }

        return nil
      }

      pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
        let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
        let Boneyard = nft as! &Boneyard.NFT
        return Boneyard as &AnyResource{MetadataViews.Resolver}
      }

      destroy() {
        destroy self.ownedNFTs
      }
  }

  pub fun createEmptyCollection(): @NonFungibleToken.Collection {
    return <- create Collection()
  }

  pub fun createMinter(): @NFTMinter {
    return <- create NFTMinter()
  }

  pub resource NFTMinter {
    // mintNFT mints a new NFT with a new ID
    // and deposit it in the recipients collection using their collection reference
    pub fun mintNFT(
      recipient: &{NonFungibleToken.CollectionPublic},
      name: String,
      description: String,
      editionSize: UInt64,
      editionNumber: UInt64,
      collectionName: String,
      collectionDescription: String,
      collectionSquareImageCID: String,
      collectionBannerImageCID: String,
      nftCategoryData: [{String: AnyStruct}],
      airForceData: [{String: AnyStruct}],
      wingData: [{String: AnyStruct}],
      squadronData: [{String: AnyStruct}],
      aircraftNumberData: [{String: AnyStruct}],
      roundelData: [{String: AnyStruct}],
      commandMarkingData: [{String: AnyStruct}],
      aircraftMarkingData: [{String: AnyStruct}],
      royalties: [MetadataViews.Royalty],
      imageCID: String,
      creatorName: String,
      copyrightHolder: String,
      mintDateTime: UInt64,
      minterName: String,
      mintLocation: String,
      fileFormat: String,
      fileSizeMb: UFix64,
      rightsAndObligationsSummary: String,
      rightsAndObligationsFullText: String,
      nftRarityScore: UFix64,
    ) {
      // setup rarity description from score
      var nftRarityDescription: String = ""
      if(nftRarityScore <= 5.0) {
        nftRarityDescription = "Common"
      } else if(nftRarityScore <= 10.0) {
        nftRarityDescription = "Uncommon"
      } else if(nftRarityScore <= 40.0) {
        nftRarityDescription = "Unusual"
      } else if(nftRarityScore <= 100.0) {
        nftRarityDescription = "Remarkable"
      } else {
        nftRarityDescription = "Rare"
      }

      var newNFT <- create NFT(
        id: Boneyard.totalSupply,
        name: name,
        description: description,
        editionSize: editionSize,
        editionNumber: editionNumber,
        collectionName: collectionName,
        collectionDescription: collectionDescription,
        collectionSquareImageCID: collectionSquareImageCID,
        collectionBannerImageCID: collectionBannerImageCID,
        nftCategoryData: nftCategoryData,
        airForceData: airForceData,
        wingData: wingData,
        squadronData: squadronData,
        aircraftNumberData: aircraftNumberData,
        roundelData: roundelData,
        commandMarkingData: commandMarkingData,
        aircraftMarkingData: aircraftMarkingData,
        royalties: royalties,
        imageCID: imageCID,
        creatorName: creatorName,
        copyrightHolder: copyrightHolder,
        mintDateTime: mintDateTime,
        minterName: minterName,
        mintLocation: mintLocation,
        fileFormat: fileFormat,
        fileSizeMb: fileSizeMb,
        rightsAndObligationsSummary: rightsAndObligationsSummary,
        rightsAndObligationsFullText: rightsAndObligationsFullText,
        nftRarityScore: nftRarityScore,
        nftRarityDescription: nftRarityDescription
      )

      // deposit newNFT in the recipient's account using their reference
      recipient.deposit(token: <-newNFT)

      Boneyard.totalSupply = Boneyard.totalSupply + 1
    }
  }

  init() {
    // Initialize the total supply
    self.totalSupply = 0

    // Set the named paths
    self.CollectionStoragePath = /storage/BoneyardCollection
    self.CollectionPublicPath = /public/BoneyardCollection
    self.MinterStoragePath = /storage/BoneyardMinterCollection

    self.account.save(<-self.createEmptyCollection(), to: self.CollectionStoragePath)

    // create a public capability for the collection
    self.account.link<&Boneyard.Collection{NonFungibleToken.CollectionPublic, Boneyard.BoneyardCollectionPublic}>(
        self.CollectionPublicPath,
        target: self.CollectionStoragePath
    )

    // Create a Minter resource and save it to storage
    self.account.save(<-self.createMinter(), to: self.MinterStoragePath)

    emit ContractInitialized()
  }
}

 "
-------
"// Flickplay

import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract BarelyABear: NonFungibleToken {
    /// Events
    ///
    pub event ContractInitialized() /// emitted when the contract is initialized
    pub event Withdraw(id: UInt64, from: Address?) /// emitted when an NFT is withdrawn from an account
    pub event Deposit(id: UInt64, to: Address?) /// emitted when an NFT is deposited into an account
    pub event Minted(id: UInt64) /// emitted when a new NFT is minted
    pub event NFTDestroyed(id: UInt64) /// emitted when an NFT is destroyed
    pub event SetCreated(setId: UInt32) /// emitted when a new NFT set is created
    pub event SetMetadataUpdated(setId: UInt32) /// emitted when the metadata of an NFT set is updated
    pub event NFTMinted(tokenId: UInt64,setId: UInt32, editionNum: UInt64) /// emitted when a new NFT is minted within a specific set
    pub event ActionsAllowed(setId: UInt32, ids: [UInt64]) /// emitted when actions are allowed for a specific set and IDs
    pub event ActionsRestricted(setId: UInt32, ids: [UInt64]) /// emitted when actions are restricted for a specific set and IDs
    pub event AddedToWhitelist(addedAddresses: [Address]) /// emitted when addresses are added to the whitelist
    pub event RemovedFromWhitelist(removedAddresses: [Address]) /// emitted when addresses are removed from the whitelist
    pub event RoyaltyCutUpdated(newRoyaltyCut: UFix64) /// emitted when the royalty cut is updated
    pub event RoyaltyAddressUpdated(newAddress: Address) /// emitted when the royalty address is updated
    pub event NewAdminCreated() /// emitted when a new admin is created
    pub event Unboxed(setId: UInt32) /// emitted when set id updated when unboxing

    /// Contract paths
    ///
    pub let CollectionStoragePath: StoragePath /// the storage path for NFT collections
    pub let CollectionPublicPath: PublicPath /// the public path for NFT collections
    pub let AdminStoragePath: StoragePath
    pub let AdminPrivatePath: PrivatePath

    pub var totalSupply: UInt64 /// the total number of NFTs minted by the contract
    access(self) var royaltyCut: UFix64 //// the percentage of royalties to be distributed
    pub var royaltyAddress: Address /// the address to receive royalties
    pub var whitelist:{Address:Bool} /// a dictionary that maps addresses to a boolean value, indicating if the address is whitelisted
    access(self) var setMetadata: {UInt32: NFTSetMetadata} /// a dictionary that maps set IDs to NFTSetMetadata resources
    pub var allowedActions: {UInt32:{UInt64: Bool}} /// a dictionary that maps set IDs to a dictionary of token IDs and their allowed actions
    access(self) var series: @Series /// a reference to the Series resource




    pub resource Series {

        /// Resource state variables
        ///
        access(self) var setIds: [UInt32]
        access(self) var tokenIDs: UInt64
        access(self) var numberEditionsMintedPerSet: {UInt32: UInt64}

        /// Initialize the Series resource
        ///
        init() {
            self.numberEditionsMintedPerSet = {}
            self.setIds = []
            self.tokenIDs = 0
        }



        pub fun addNftSet(
            setId: UInt32,
            name: String,
            edition:String,
            thumbnail: String,
            description: String,
            httpFile: String,
            maxEditions: UInt64,
            mediaFile: String,
            externalUrl:String,
            twitterLink:String,
            toyStats: ToyStats,
            toyProperties: {String: AnyStruct}
           ) {
            pre {
                self.setIds.contains(setId) == false: "The Set has already been added to the Series."
            }

            var newNFTSet = NFTSetMetadata(
                setId: setId,
                name: name,
                edition: edition,
                thumbnail: thumbnail,
                description: description,
                httpFile: httpFile,
                maxEditions: maxEditions,
                mediaFile: mediaFile,
                externalUrl: externalUrl,
                twitterLink: twitterLink,
                toyStats: toyStats,
                toyProperties: toyProperties
            )
            self.setIds.append(setId)
            self.numberEditionsMintedPerSet[setId] = 0
            BarelyABear.setMetadata[setId] = newNFTSet

            emit SetCreated(setId: setId)
        }


        pub fun updateSetMetadata(
            setId: UInt32,
            name: String,
            edition:String,
            thumbnail: String,
            description: String,
            httpFile: String,
            maxEditions: UInt64,
            mediaFile: String,
            externalUrl:String,
            twitterLink:String,
            toyStats: ToyStats,
            toyProperties: {String: AnyStruct}
            ) {
            pre {
                self.setIds.contains(setId) == true: "The Set is not part of this Series."
            }
            let newSetMetadata = NFTSetMetadata(
                setId: setId,
                name: name,
                edition: edition,
                thumbnail: thumbnail,
                description: description,
                httpFile: httpFile,
                maxEditions: maxEditions,
                mediaFile: mediaFile,
                externalUrl: externalUrl,
                twitterLink: twitterLink,
                toyStats: toyStats,
                toyProperties: toyProperties
            )
            BarelyABear.setMetadata[setId] = newSetMetadata

            emit SetMetadataUpdated(setId: setId)
        }


        pub fun updateSetStats(
            setId: UInt32,
            toyStats: ToyStats,
            ) {
            pre {
                self.setIds.contains(setId) == true: "The Set is not part of this Series."
            }

            let newSetMetadata = NFTSetMetadata(
                setId: setId,
                name: BarelyABear.getSetMetadata(setId: setId).name,
                edition: BarelyABear.getSetMetadata(setId: setId).edition,
                thumbnail: BarelyABear.getSetMetadata(setId: setId).thumbnail,
                description: BarelyABear.getSetMetadata(setId: setId).description,
                httpFile: BarelyABear.getSetMetadata(setId: setId).httpFile,
                maxEditions: BarelyABear.getSetMetadata(setId: setId).maxEditions,
                mediaFile: BarelyABear.getSetMetadata(setId: setId).mediaFile,
                externalUrl: BarelyABear.getSetMetadata(setId: setId).externalUrl,
                twitterLink: BarelyABear.getSetMetadata(setId: setId).twitterLink,
                toyStats: toyStats,
                toyProperties: BarelyABear.getSetMetadata(setId: setId).toyProperties
            )
            BarelyABear.setMetadata[setId] = newSetMetadata

            emit SetMetadataUpdated(setId: setId)
        }

        pub fun updateSetTraits(
            setId: UInt32,
            toyProperties: {String: AnyStruct},
            ) {
            pre {
                self.setIds.contains(setId) == true: "The Set is not part of this Series."
            }

            let newSetMetadata = NFTSetMetadata(
                setId: setId,
                name: BarelyABear.getSetMetadata(setId: setId).name,
                edition: BarelyABear.getSetMetadata(setId: setId).edition,
                thumbnail: BarelyABear.getSetMetadata(setId: setId).thumbnail,
                description: BarelyABear.getSetMetadata(setId: setId).description,
                httpFile: BarelyABear.getSetMetadata(setId: setId).httpFile,
                maxEditions: BarelyABear.getSetMetadata(setId: setId).maxEditions,
                mediaFile: BarelyABear.getSetMetadata(setId: setId).mediaFile,
                externalUrl: BarelyABear.getSetMetadata(setId: setId).externalUrl,
                twitterLink: BarelyABear.getSetMetadata(setId: setId).twitterLink,
                toyStats: BarelyABear.getSetMetadata(setId: setId).toyStats,
                toyProperties: toyProperties
            )
            BarelyABear.setMetadata[setId] = newSetMetadata

            emit SetMetadataUpdated(setId: setId)
        }

        pub fun updateGenericMetadata(
            setId: UInt32,
            name: String,
            edition: String,
            thumbnail: String,
            description: String,
            httpFile: String,
            maxEditions: UInt64,
            mediaFile: String,
            externalUrl:String,
            twitterLink:String,
        ) {
            pre {
                self.setIds.contains(setId) == true: "The Set is not part of this Series."
            }
            let newSetMetadata = NFTSetMetadata(
                setId: setId,
                name: name,
                edition: edition,
                thumbnail: thumbnail,
                description: description,
                httpFile: httpFile,
                maxEditions: maxEditions,
                mediaFile: mediaFile,
                externalUrl: externalUrl,
                twitterLink: twitterLink,
                toyStats: BarelyABear.getSetMetadata(setId: setId).toyStats,
                toyProperties: BarelyABear.getSetMetadata(setId: setId).toyProperties
            )
            BarelyABear.setMetadata[setId] = newSetMetadata

            emit SetMetadataUpdated(setId: setId)
        }

	    pub fun mintFlickplaySeriesNFT(
            recipient: &{NonFungibleToken.CollectionPublic},
            setId: UInt32) {

            pre {
                self.numberEditionsMintedPerSet[setId] != nil: "The Set does not exist."
                self.numberEditionsMintedPerSet[setId]! < BarelyABear.getSetMaxEditions(setId: setId)!:
                    "Set has reached maximum NFT edition capacity."
            }

            let tokenId: UInt64 = self.tokenIDs
            let editionNum: UInt64 = self.numberEditionsMintedPerSet[setId]! + 1

			recipient.deposit(token: <-create BarelyABear.NFT(
                tokenId: tokenId,
                setId: setId,
                editionNum: editionNum,
                name: BarelyABear.getSetMetadata(setId: setId).name,
                description: BarelyABear.getSetMetadata(setId: setId).description,
                thumbnail: BarelyABear.getSetMetadata(setId: setId).thumbnail
            ))

            self.tokenIDs = self.tokenIDs + 1

            BarelyABear.totalSupply = BarelyABear.totalSupply + 1
            self.numberEditionsMintedPerSet[setId] = editionNum

            emit NFTMinted(tokenId: tokenId,setId: setId, editionNum: editionNum)
        }


		pub fun batchMintFlickplaySeriesNFT(
            recipient: &{NonFungibleToken.CollectionPublic},
            setId: UInt32,
            amount: UInt32,
            ) {

            pre {
                amount > 0:
                    "Amount must be > 0"
            }

            var i: UInt32 = 0
            while i < amount {
                self.mintFlickplaySeriesNFT(
                    recipient: recipient,
                    setId: setId,
                )
                i = i + 1
            }
		}
	}

    pub struct ToyStats {
        pub var level: UInt32
        pub var xp: UInt32
        pub var likes: UInt32
        pub var views: UInt32
        pub var uses: UInt32
        // pub var animation: String

        init(
            level: UInt32,
            xp: UInt32,
            likes: UInt32,
            views: UInt32,
            uses: UInt32
            // animation: String,
        ) {
            self.level = level
            self.xp = xp
            self.likes = likes
            self.views = views
            self.uses = uses
            // self.animation = animation
        }
    }

    pub fun getStats(_ viewResolver: &{MetadataViews.Resolver}) : ToyStats? {
        if let view = viewResolver.resolveView(Type<BarelyABear.ToyStats>()) {
            if let v = view as? ToyStats {
                return v
            }
        }
        return nil
    }

       pub struct NFTSetMetadata {

        pub var setId: UInt32
        pub var name: String
        pub var edition: String
        pub var thumbnail: String
        pub var description: String
        pub var httpFile: String
        pub var maxEditions: UInt64
        pub var mediaFile: String
        pub var externalUrl: String
        pub var twitterLink: String
        pub var toyStats: ToyStats
        pub var toyProperties: {String: AnyStruct}

        init(
            setId: UInt32,
            name: String,
            edition: String,
            thumbnail: String,
            description: String,
            httpFile: String,
            maxEditions: UInt64,
            mediaFile: String,
            externalUrl: String,
            twitterLink: String,
            toyStats: ToyStats,
            toyProperties: {String: AnyStruct}
) {

            self.setId = setId
            self.name = name
            self.edition = edition
            self.thumbnail = thumbnail
            self.description = description
            self.httpFile = httpFile
            self.maxEditions = maxEditions
            self.mediaFile = mediaFile
            self.externalUrl = externalUrl
            self.twitterLink = twitterLink
            self.toyStats = toyStats
            self.toyProperties = toyProperties


            emit SetCreated(setId: self.setId)
        }
    }



    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        pub let id: UInt64
        pub var setId: UInt32
        pub let editionNum: UInt64
        pub let name: String
        pub let description: String
        pub let thumbnail: String
        init(
          tokenId: UInt64,
          setId: UInt32,
          editionNum: UInt64,
          name: String,
          description: String,
          thumbnail: String) {
            self.id = tokenId
            self.setId = setId
            self.editionNum = editionNum
            self.name = name
            self.description = description
            self.thumbnail = thumbnail
            emit Minted(id: self.id)
        }

        destroy() {
            BarelyABear.totalSupply = BarelyABear.totalSupply - 1
            emit NFTDestroyed(id: self.id)
        }

        access(contract) fun unbox(newSetId: UInt32){
            self.setId = newSetId
            emit Unboxed(setId: newSetId)
        }



        pub fun getViews(): [Type] {
            return [
               Type<MetadataViews.Display>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.Editions>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.Traits>(),
                Type<BarelyABear.ToyStats>()
            ]
        }


      pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: BarelyABear.getSetMetadata(setId: self.setId).name,
                        description: BarelyABear.getSetMetadata(setId: self.setId).description,
                        thumbnail: MetadataViews.HTTPFile(
                            url: BarelyABear.getSetMetadata(setId: self.setId).thumbnail,
                        )
                    )
                case Type<MetadataViews.Editions>():
                    let editionInfo = MetadataViews.Edition(
                     name: BarelyABear.getSetMetadata(setId: self.setId).edition,
                     number: self.editionNum,
                     max: BarelyABear.getSetMetadata(setId: self.setId).maxEditions)
                    let editionList: [MetadataViews.Edition] = [editionInfo]
                        return MetadataViews.Editions(
                        editionList
                     )
                case Type<MetadataViews.HTTPFile>():
                    return MetadataViews.HTTPFile(
                        BarelyABear.getSetMetadata(setId: self.setId).httpFile
                    )
                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(
                        self.id
                    )
                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL(BarelyABear.getSetMetadata(setId: self.setId).externalUrl)
                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: BarelyABear.CollectionStoragePath,
                        publicPath: BarelyABear.CollectionPublicPath,
                        providerPath: /private/BarelyABearCollection,
                        publicCollection: Type<&BarelyABear.Collection{BarelyABear.FlickplaySeriesCollectionPublic}>(),
                        publicLinkedType: Type<&BarelyABear.Collection{BarelyABear.FlickplaySeriesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&BarelyABear.Collection{BarelyABear.FlickplaySeriesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(),
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                            return <-BarelyABear.createEmptyCollection()
                        })
                    )
                case Type<MetadataViews.NFTCollectionDisplay>():
                    let media = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: BarelyABear.getSetMetadata(setId: self.setId).mediaFile
                        ),
                        mediaType: "image/svg+xml"
                    )
                    return MetadataViews.NFTCollectionDisplay(
                        name: BarelyABear.getSetMetadata(setId: self.setId).name,
                        description:  BarelyABear.getSetMetadata(setId: self.setId).description,
                        externalURL: MetadataViews.ExternalURL(BarelyABear.getSetMetadata(setId: self.setId).externalUrl),
                        squareImage: media,
                        bannerImage: media,
                        socials: {
                            "twitter": MetadataViews.ExternalURL(BarelyABear.getSetMetadata(setId: self.setId).twitterLink)
                        }
                    )
                case Type<MetadataViews.Royalties>():
                    let royaltyReceiver: Capability<&{FungibleToken.Receiver}> =
                        getAccount(BarelyABear.royaltyAddress).getCapability<&AnyResource{FungibleToken.Receiver}>(MetadataViews.getRoyaltyReceiverPublicPath())
                    return MetadataViews.Royalties(
                        royalties: [
                            MetadataViews.Royalty(
                                receiver: royaltyReceiver,
                                cut: BarelyABear.royaltyCut,
                                description: "Flickplay Royalty"
                            )
                        ]
                    )
                case Type<MetadataViews.Traits>():
                    let traitsView = MetadataViews.dictToTraits(dict:  BarelyABear.getSetMetadata(setId: self.setId).toyProperties, excludedNames: [])
                    return traitsView
                case Type<BarelyABear.ToyStats>():
                    return  BarelyABear.getSetMetadata(setId: self.setId).toyStats
            }
            return nil
        }
    }



    pub resource Admin: IAdminSafeShare {



        pub fun borrowSeries(): &Series  {
            return &BarelyABear.series as &Series
        }



        pub fun setAllowedActions(setId: UInt32, ids: [UInt64]) {
            let set = BarelyABear.allowedActions[setId] ?? {}
            for id in ids {
                set[id] = true
                }
            BarelyABear.allowedActions[setId] = set
            emit ActionsAllowed(setId: setId, ids: ids)
        }



        pub fun setRestrictedActions(setId: UInt32, ids: [UInt64]) {
            let set = BarelyABear.allowedActions[setId] ?? {}
            for id in ids {
                set[id] = false
            }
            BarelyABear.allowedActions[setId] = set
            emit ActionsRestricted(setId: setId, ids: ids)
        }




        pub fun addToWhitelist(_toAddAddresses: [Address]) {
            for address in _toAddAddresses {
                BarelyABear.whitelist[address] = true
            }
            emit AddedToWhitelist(addedAddresses: _toAddAddresses)
        }



        pub fun removeFromWhitelist(_toRemoveAddresses: [Address]) {
            for address in _toRemoveAddresses {
                BarelyABear.whitelist[address] = false
            }
            emit RemovedFromWhitelist(removedAddresses: _toRemoveAddresses)
        }




        pub fun unboxNft(address: Address, nftId: UInt64, newSetId: UInt32 ){
            let collectionRef = getAccount(address).getCapability<&{BarelyABear.FlickplaySeriesCollectionPublic}>(BarelyABear.CollectionPublicPath).borrow()
            let nftRef = collectionRef!.borrowFlickplaySeries(id: nftId)
            nftRef?.unbox(newSetId: newSetId)
        }



        pub fun setRoyaltyCut(newRoyalty: UFix64){
            BarelyABear.royaltyCut = newRoyalty
            emit RoyaltyCutUpdated(newRoyaltyCut: newRoyalty)
        }



        pub fun setRoyaltyAddress(newReceiver: Address){
            BarelyABear.royaltyAddress = newReceiver
            emit RoyaltyAddressUpdated(newAddress: newReceiver)
        }



        pub fun createNewAdmin(): @Admin {
            return <-create Admin()
        }

    }



    pub resource interface IAdminSafeShare{
        pub fun borrowSeries(): &Series
        pub fun setAllowedActions(setId: UInt32, ids: [UInt64])
        pub fun setRestrictedActions(setId: UInt32, ids: [UInt64])
        pub fun addToWhitelist(_toAddAddresses: [Address])
        pub fun removeFromWhitelist(_toRemoveAddresses: [Address])
        pub fun unboxNft(address: Address, nftId: UInt64, newSetId: UInt32 )
    }




    pub resource interface FlickplaySeriesCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowFlickplaySeries(id: UInt64): &BarelyABear.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow BarelyABear reference: The ID of the returned reference is incorrect"
            }
        }
    }



    pub resource Collection: FlickplaySeriesCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {

        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}



        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let ref = (&self.ownedNFTs[withdrawID] as auth &NonFungibleToken.NFT?)!
            let flickplayNFT = ref as! &BarelyABear.NFT
            BarelyABear.getAllowedActionsStatus(setId: flickplayNFT.setId,tokenId: flickplayNFT.id) ?? panic("Actions for this token NOT allowed")
            let token <- self.ownedNFTs.remove(key: withdrawID)  ?? panic("missing NFT")
            emit Withdraw(id: token.id, from: self.owner?.address)
            return <-token
        }



        pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {
            var batchCollection <- create Collection()
            for id in ids {
                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))
            }
            return <-batchCollection
        }



        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @BarelyABear.NFT
            // BarelyABear.getAllowedActionsStatus(setId: token.setId,tokenId: token.id) ?? panic("Actions for this token NOT allowed")
            let id: UInt64 = token.id
            let oldToken <- self.ownedNFTs[id] <- token
            emit Deposit(id: id, to: self.owner?.address)
            destroy oldToken
        }

        // access(contract) fun depositInternal(token: @BarelyABear.NFT) {
        //     let id: UInt64 = token.id
        //     let oldToken <- self.ownedNFTs[id] <- token
        //     emit Deposit(id: id, to: self.owner?.address)
        //     destroy oldToken
        // }



        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {
            let keys = tokens.getIDs()
            for key in keys {
                self.deposit(token: <-tokens.withdraw(withdrawID: key))
            }
            destroy tokens
        }



        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }



        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }



        pub fun borrowFlickplaySeries(id: UInt64): &BarelyABear.NFT? {
            if self.ownedNFTs[id] != nil {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &BarelyABear.NFT
            } else {
                return nil
            }
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let flickplayNFT = nft as! &BarelyABear.NFT
            return flickplayNFT as &AnyResource{MetadataViews.Resolver}
        }



        destroy() {
            destroy self.ownedNFTs
        }


        pub fun burn(id: UInt64) {
            let nft <- self.ownedNFTs.remove(key: id) as! @BarelyABear.NFT?
            destroy nft
        }

        init () {
            self.ownedNFTs <- {}
        }
    }



    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create BarelyABear.Collection()
    }



    pub fun fetch(_ from: Address, id: UInt64): &BarelyABear.NFT? {
        let collection = getAccount(from)
            .getCapability(BarelyABear.CollectionPublicPath)
            .borrow<&BarelyABear.Collection{BarelyABear.FlickplaySeriesCollectionPublic}>()
            ?? panic("Couldn't get collection")
        return collection.borrowFlickplaySeries(id: id)
    }




    pub fun getSetMetadata(setId: UInt32): BarelyABear.NFTSetMetadata {
        return BarelyABear.setMetadata[setId]!
    }



    pub fun getAllowedActionsStatus(setId: UInt32, tokenId: UInt64): Bool? {
        if let set = BarelyABear.allowedActions[setId] {
            return set[tokenId]
        } else {
            return nil
        }
    }


    pub fun getAllSets(): [BarelyABear.NFTSetMetadata] {
        return BarelyABear.setMetadata.values
    }



    pub fun getSetMaxEditions(setId: UInt32): UInt64? {
        return BarelyABear.setMetadata[setId]?.maxEditions
    }



	init() {
        self.CollectionStoragePath = /storage/BarelyABearCollection
        self.CollectionPublicPath = /public/BarelyABearCollection
        self.AdminStoragePath = /storage/BarelyABearAdmin
        self.AdminPrivatePath = /private/BarelyABearAdminPrivate
        self.totalSupply = 0
        self.royaltyCut = 0.02
        self.royaltyAddress = self.account.address
        self.setMetadata = {}
        self.whitelist = {}
        self.allowedActions = {}
        self.series <- create Series()
        self.account.save(<-create Admin(), to: self.AdminStoragePath)
        self.account.link<&BarelyABear.Admin>(
            self.AdminPrivatePath,
            target: self.AdminStoragePath
        ) ?? panic("Could not get a capability to the admin")

        emit ContractInitialized()
	}
}
 "
-------
"import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import FiatToken from 0xb19436aae4d94622
import AlphaNFTV1 from 0xe600ffd2adb0c6d3

pub contract AlphaPackV1 {
    // event when a pack is bought
    pub event PackBought(templateId: UInt64, receiptAddress: Address?)
    pub event PurchaseDetails(buyer: Address, momentsInPack: [{String: UInt64}], pricePaid: UFix64, packID: UInt64, settledOnChain: Bool)
    // event when a pack is opened
    pub event PackOpened(nftId: UInt64, receiptAddress: Address?)

    // path for pack storage
    pub let PackStoragePath : StoragePath
    // path for pack public
    pub let PackPublicPath : PublicPath

    access(self) var ownerAddress: Address

    access(contract) let adminRef : Capability<&FiatToken.Vault{FungibleToken.Receiver}>

    pub resource interface PackPublic {
        // making this function public to call by authorized users
        pub fun openPack(packNFT: @AlphaNFTV1.NFT, receiptAddress: Address)
    }
    pub resource Pack : PackPublic {

        pub fun updateOwnerAddress(owner:Address){
            pre{
                owner != nil: "owner must not be null"
            }
            AlphaPackV1.ownerAddress = owner
        }

        pub fun buyPackFromAdmin(templateIds: [{String: UInt64}], packTemplateId: UInt64, receiptAddress: Address, price: UFix64) {
            pre {
                templateIds.length > 0 : "template id  must not be zero"
                receiptAddress != nil : "receipt address must not be null"
            }
            var allNftTemplateExists = true;
            assert(templateIds.length <= 10, message: "templates limit exceeded")
            let nftTemplateIds : [{String: UInt64}] = []
            for tempID in templateIds {
                let nftTemplateData = AlphaNFTV1.getTemplateById(templateId: tempID["id"]!)
                if(nftTemplateData == nil) {
                    allNftTemplateExists = false
                    break
                }
                nftTemplateIds.append(tempID)
            }

            let originalPackTemplateData = AlphaNFTV1.getTemplateById(templateId: packTemplateId)
            let originalPackTemplateImmutableData = originalPackTemplateData.getImmutableData()
            originalPackTemplateImmutableData["nftTemplates"] = nftTemplateIds


            assert(allNftTemplateExists, message: "Invalid NFTs")
            AlphaNFTV1.createTemplate(maxSupply: 1, immutableData: originalPackTemplateImmutableData)

            let nextTemplateId = AlphaNFTV1.getLatestTemplateId()
            AlphaNFTV1.mintNFT(templateInfo: {"id":nextTemplateId}, account: receiptAddress)
            AlphaNFTV1.templates[packTemplateId]!.incrementIssuedSupply()
            emit PackBought(templateId: nextTemplateId, receiptAddress: receiptAddress)
            emit PurchaseDetails(buyer: receiptAddress, momentsInPack: templateIds, pricePaid: price, packID: packTemplateId, settledOnChain: false)
        }

        pub fun buyPack(templateIds: [{String: UInt64}], packTemplateId: UInt64, receiptAddress: Address, price: UFix64, flowPayment: @FungibleToken.Vault) {
            pre {
                templateIds.length > 0 : "template id  must not be zero"
                flowPayment.balance == price: "Your vault does not have balance to buy NFT"
                receiptAddress != nil : "receipt address must not be null"
            }
            var allNftTemplateExists = true;
            assert(templateIds.length <= 10, message: "templates limit exceeded")
            let nftTemplateIds : [{String: UInt64}] = []
            for tempID in templateIds {
                let nftTemplateData = AlphaNFTV1.getTemplateById(templateId: tempID["id"]!)
                if(nftTemplateData == nil) {
                    allNftTemplateExists = false
                    break
                }
                nftTemplateIds.append(tempID)
            }

            let originalPackTemplateData = AlphaNFTV1.getTemplateById(templateId: packTemplateId)
            let originalPackTemplateImmutableData = originalPackTemplateData.getImmutableData()
            originalPackTemplateImmutableData["nftTemplates"] = nftTemplateIds


            assert(allNftTemplateExists, message: "Invalid NFTs")
            AlphaNFTV1.createTemplate(maxSupply: 1, immutableData: originalPackTemplateImmutableData)

            let nextTemplateId = AlphaNFTV1.getLatestTemplateId()
            let receiptAccount = getAccount(AlphaPackV1.ownerAddress)
            let recipientCollection = receiptAccount
                .getCapability(FiatToken.VaultReceiverPubPath)
                .borrow<&FiatToken.Vault{FungibleToken.Receiver}>()
                ?? panic("Could not get receiver reference to the flow receiver")
            recipientCollection.deposit(from: <-flowPayment)

            AlphaNFTV1.mintNFT(templateInfo: {"id":nextTemplateId}, account: receiptAddress)
            AlphaNFTV1.templates[packTemplateId]!.incrementIssuedSupply()
            emit PackBought(templateId: nextTemplateId, receiptAddress: receiptAddress)
            emit PurchaseDetails(buyer: receiptAddress, momentsInPack: templateIds, pricePaid: price, packID: packTemplateId, settledOnChain: true)
        }

        pub fun openPack(packNFT: @AlphaNFTV1.NFT, receiptAddress: Address) {
            pre {
                packNFT != nil : "pack nft must not be null"
                receiptAddress != nil : "receipt address must not be null"
            }
            var packNFTData = AlphaNFTV1.getNFTData(nftId: packNFT.id)
            var packTemplateData = AlphaNFTV1.getTemplateById(templateId: packNFTData.templateId)
            let templateImmutableData = packTemplateData.getImmutableData()

            let allIds = templateImmutableData["nftTemplates"]! as! [AnyStruct]

            let packSlug = templateImmutableData["slug"]! as! String

            assert(allIds.length <= 10, message: "templates limit exceeded")
            for tempID in allIds {
                if(packSlug == "ripper-skippers") {
                    let templateInfo = {"id":tempID as! UInt64}
                    AlphaNFTV1.mintNFT(templateInfo: templateInfo!,  account: receiptAddress)
                } else {
                    let templateInfo = tempID as? {String: UInt64}
                    AlphaNFTV1.mintNFT(templateInfo: templateInfo!,  account: receiptAddress)
                }
            }
            emit PackOpened(nftId: packNFT.id, receiptAddress: self.owner?.address)
            destroy packNFT
        }
        init(){
        }
    }
    init() {
        self.ownerAddress = self.account!.address
        self.adminRef = self.account.getCapability<&FiatToken.Vault{FungibleToken.Receiver}>(FiatToken.VaultReceiverPubPath)
        self.PackStoragePath = /storage/AlphaPackV1
        self.PackPublicPath = /public/AlphaPackV1
        self.account.save(<- create Pack(), to: self.PackStoragePath)
        self.account.link<&{PackPublic}>(self.PackPublicPath, target: self.PackStoragePath)
    }
}
 "
-------
"// ExampleToken.cdc
//
// The ExampleToken contract is a sample implementation of a fungible token on Flow.
//
// Fungible tokens behave like everyday currencies -- they can be minted, transferred or
// traded for digital goods.
//
// Follow the fungible tokens tutorial to learn more: https://developers.flow.com/cadence/tutorial/06-fungible-tokens
//
// This is a basic implementation of a Fungible Token and is NOT meant to be used in production
// See the Flow Fungible Token standard for real examples: https://github.com/onflow/flow-ft

pub contract ExampleToken {

    // Total supply of all tokens in existence.
    pub var totalSupply: UFix64

    // Provider
    //
    // Interface that enforces the requirements for withdrawing
    // tokens from the implementing type.
    //
    // We don't enforce requirements on self.balance here because
    // it leaves open the possibility of creating custom providers
    // that don't necessarily need their own balance.
    //
    pub resource interface Provider {

        // withdraw
        //
        // Function that subtracts tokens from the owner's Vault
        // and returns a Vault resource (@Vault) with the removed tokens.
        //
        // The function's access level is public, but this isn't a problem
        // because even the public functions are not fully public at first.
        // anyone in the network can call them, but only if the owner grants
        // them access by publishing a resource that exposes the withdraw
        // function.
        //
        pub fun withdraw(amount: UFix64): @Vault {
            post {
                // `result` refers to the return value of the function
                result.balance == UFix64(amount):
                    "Withdrawal amount must be the same as the balance of the withdrawn Vault"
            }
        }
    }

    // Receiver
    //
    // Interface that enforces the requirements for depositing
    // tokens into the implementing type.
    //
    // We don't include a condition that checks the balance because
    // we want to give users the ability to make custom Receivers that
    // can do custom things with the tokens, like split them up and
    // send them to different places.
    //
	pub resource interface Receiver {
        // deposit
        //
        // Function that can be called to deposit tokens
        // into the implementing resource type
        //
        pub fun deposit(from: @Vault) {
            pre {
                from.balance > 0.0:
                    "Deposit balance must be positive"
            }
        }
    }

    // Balance
    //
    // Interface that specifies a public `balance` field for the vault
    //
    pub resource interface Balance {
        pub var balance: UFix64
    }

    // Vault
    //
    // Each user stores an instance of only the Vault in their storage
    // The functions in the Vault and governed by the pre and post conditions
    // in the interfaces when they are called.
    // The checks happen at runtime whenever a function is called.
    //
    // Resources can only be created in the context of the contract that they
    // are defined in, so there is no way for a malicious user to create Vaults
    // out of thin air. A special Minter resource needs to be defined to mint
    // new tokens.
    //
    pub resource Vault: Provider, Receiver, Balance {

		// keeps track of the total balance of the account's tokens
        pub var balance: UFix64

        // initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        // withdraw
        //
        // Function that takes an integer amount as an argument
        // and withdraws that amount from the Vault.
        //
        // It creates a new temporary Vault that is used to hold
        // the money that is being transferred. It returns the newly
        // created Vault to the context that called so it can be deposited
        // elsewhere.
        //
        pub fun withdraw(amount: UFix64): @Vault {
            self.balance = self.balance - amount
            return <-create Vault(balance: amount)
        }

        // deposit
        //
        // Function that takes a Vault object as an argument and adds
        // its balance to the balance of the owners Vault.
        //
        // It is allowed to destroy the sent Vault because the Vault
        // was a temporary holder of the tokens. The Vault's balance has
        // been consumed and therefore can be destroyed.
        pub fun deposit(from: @Vault) {
            self.balance = self.balance + from.balance
            destroy from
        }
    }

    // createEmptyVault
    //
    // Function that creates a new Vault with a balance of zero
    // and returns it to the calling context. A user must call this function
    // and store the returned Vault in their storage in order to allow their
    // account to be able to receive deposits of this token type.
    //
    pub fun createEmptyVault(): @Vault {
        return <-create Vault(balance: 30.000)
    }

	// VaultMinter
    //
    // Resource object that an admin can control to mint new tokens
    pub resource VaultMinter {

		// Function that mints new tokens and deposits into an account's vault
		// using their `Receiver` reference.
        // We say `&AnyResource{Receiver}` to say that the recipient can be any resource
        // as long as it implements the Receiver interface
        pub fun mintTokens(amount: UFix64, recipient: Capability<&AnyResource{Receiver}>) {
            let recipientRef = recipient.borrow()
                ?? panic("Could not borrow a receiver reference to the vault")

            ExampleToken.totalSupply = ExampleToken.totalSupply + UFix64(amount)
            recipientRef.deposit(from: <-create Vault(balance: amount))
        }
    }

    // The init function for the contract. All fields in the contract must
    // be initialized at deployment. This is just an example of what
    // an implementation could do in the init function. The numbers are arbitrary.
    init() {
        self.totalSupply = 30.0

        // create the Vault with the initial balance and put it in storage
        // account.save saves an object to the specified `to` path
        // The path is a literal path that consists of a domain and identifier
        // The domain must be `storage`, `private`, or `public`
        // the identifier can be any name
        let vault <- create Vault(balance: self.totalSupply)
        self.account.save(<-vault, to: /storage/CadenceFungibleTokenTutorialVault)

        // Create a new MintAndBurn resource and store it in account storage
        self.account.save(<-create VaultMinter(), to: /storage/CadenceFungibleTokenTutorialMinter)

        // Create a private capability link for the Minter
        // Capabilities can be used to create temporary references to an object
        // so that callers can use the reference to access fields and functions
        // of the objet.
        //
        // The capability is stored in the /private/ domain, which is only
        // accesible by the owner of the account
        self.account.link<&VaultMinter>(/private/Minter, target: /storage/CadenceFungibleTokenTutorialMinter)
    }
}

"
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract WATCHTOWER : NonFungibleToken {

    pub var totalSupply: UInt64

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath
    pub let MinterPublicPath: PublicPath
    //pub var CollectionPrivatePath: PrivatePath
    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event Mint(id: UInt64, creator: Address, metadata: {String:String})
    pub event Destroy(id: UInt64)

    // We use dict to store raw metadata
    pub resource interface RawMetadata {
        pub fun getRawMetadata(): {String: String}
    }

    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver, RawMetadata {
        pub let id: UInt64
        pub let creator: Address
        access(self) let metadata: {String:String}

        init(
            id: UInt64,
            creator: Address,
            metadata: {String: String}
        ) {
            self.id = id
            self.creator = creator
            self.metadata = metadata
        }

       pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.metadata["name"]!,
                        description: self.metadata["description"]!,
                        thumbnail: MetadataViews.HTTPFile(
                            url: self.metadata["thumbnail"]!
                        )
                    )
            }

            return nil
        }

        pub fun getRawMetadata(): {String: String} {
            return self.metadata
        }

        destroy() {
            emit Destroy(id: self.id)
        }
    }

    pub resource interface WATCHTOWERCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowWATCHTOWER(id: UInt64): &WATCHTOWER.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow NFT reference: the ID of the returned reference is incorrect"
            }
        }
    }

    pub resource Collection: WATCHTOWERCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {

        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        // withdraw removes an NFT from the collection and moves it to the caller
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        // deposit takes a NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @WATCHTOWER.NFT

            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        // getIDs returns an array of the IDs that are in the collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT gets a reference to an NFT in the collection
        // so that the caller can read its metadata and call its methods
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowWATCHTOWER(id: UInt64): &WATCHTOWER.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorized reference to allow downcasting
                let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT?
                return ref as! &WATCHTOWER.NFT?
            }

            return nil
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let mlNFT = nft as! &WATCHTOWER.NFT
            return mlNFT
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    // public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    // Resource that an admin or something similar would own to be
    // able to mint new NFTs
    //
    pub resource NFTMinter {

        // mintNFT mints a new NFT with a new ID
        // and deposit it in the recipients collection using their collection reference
        pub fun mintNFT(
            recipient: &{NonFungibleToken.CollectionPublic},
            metadata: {String: String}
        ): &NonFungibleToken.NFT {

            let creator = self.owner!.address
            // create a new NFT
            var newNFT <- create NFT(
                id: WATCHTOWER.totalSupply,
                creator: creator,
                metadata: metadata
            )

            let tokenRef = &newNFT as &NonFungibleToken.NFT
            // deposit it in the recipient's account using their reference
            recipient.deposit(token: <-newNFT)

            WATCHTOWER.totalSupply = WATCHTOWER.totalSupply + 1

            emit Mint(id: tokenRef.id, creator: creator, metadata: metadata)

            return tokenRef
        }
    }

    init() {
        // Initialize the total supply
        self.totalSupply = 0

        // Set the named paths
        self.CollectionStoragePath = /storage/MatrixMarketWATCHTOWERCollection
        self.CollectionPublicPath = /public/MatrixMarketWATCHTOWERCollection
        self.MinterStoragePath = /storage/MatrixMarketWATCHTOWERMinter
        self.MinterPublicPath = /public/MatrixMarketWATCHTOWERMinter

        // Create a Collection resource and save it to storage
        let collection <- create Collection()
        self.account.save(<-collection, to: self.CollectionStoragePath)

        // create a public capability for the collection
        self.account.link<&WATCHTOWER.Collection{NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, WATCHTOWER.WATCHTOWERCollectionPublic, MetadataViews.ResolverCollection}>(
            self.CollectionPublicPath,
            target: self.CollectionStoragePath
        )

        // Create a Minter resource and save it to storage
        let minter <- create NFTMinter()
        self.account.save(<-minter, to: self.MinterStoragePath)

        emit ContractInitialized()
    }
}
"
-------
"import Minter from 0xd9bc8eb0e90863f7
import FungibleToken from 0xf233dcee88fe0abe
import DapperUtilityCoin from 0xead892083b3e2c6c

pub contract DapperUtilityCoinMinter {
    pub resource FungibleTokenMinter: Minter.FungibleTokenMinter {
        pub let type: Type
        pub let addr: Address

        pub fun mintTokens(acct: AuthAccount, amount: UFix64): @FungibleToken.Vault {
            let mainVault = acct.borrow<&DapperUtilityCoin.Vault>(from: /storage/dapperUtilityCoinVault)
                ?? panic("vault not found")
            let tokens <- mainVault.withdraw(amount: amount)
            return <- tokens
        }

        init(_ t: Type, _ a: Address) {
            self.type = t
            self.addr = a
        }
    }

    pub fun createMinter(_ t: Type, _ a: Address): @FungibleTokenMinter {
        return <- create FungibleTokenMinter(t, a)
    }
}"
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import FlowToken from 0x1654653399040a61
import FungibleToken from 0xf233dcee88fe0abe

pub contract YDYHeartNFTs: NonFungibleToken {

    pub var totalSupply: UInt64
    pub var price: UFix64
    pub var isMintingEnabled: Bool

    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event Bought(id: UInt64, to: Address?)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let AdminStoragePath: StoragePath

    pub enum Rarity: UInt8 {
        pub case common
        pub case rare
        pub case legendary
        pub case epic
    }

    pub fun calculateAttribute(_ rarity: String): UInt64 {
        let commonRange = unsafeRandom() % 5 + 1; // 1-5
        let rareRange = unsafeRandom() % 6 + 4; // 4-9
        let legendaryRange = unsafeRandom() % 11 + 8; //8-18
        let epicRange = unsafeRandom() % 18 + 14; //14-31

        switch rarity {
            case "Common":
                return commonRange
            case "Rare":
                return rareRange
            case "Legendary":
                return legendaryRange
            case "Epic":
                return epicRange
        }

        return 0
    }

    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        pub let id: UInt64

        pub let name: String
        pub let description: String
        pub let thumbnailCID: String

        pub let background: String
        pub let body: String
        pub let mouth: String
        pub let eyes: String
        pub let pants: String

        pub let zone: String

        pub var level: UInt64
        pub var lastLeveledUp: UFix64

        pub var stamina: UFix64
        pub var lastStaminaUpdate: UFix64
        pub var endurance: UFix64
        pub var lastEnduranceBoost: UFix64
        pub var efficiency: UFix64
        pub var lastEfficiencyBoost: UFix64
        pub var luck: UFix64
        pub var lastLuckBoost: UFix64

        pub let rarity: String

        pub var version: String
        pub var versionLaunchDate: String

        init(
            thumbnailCID: String,
            background: String,
            body: String,
            mouth: String,
            eyes: String,
            pants: String,
            rarity: String,
            version: String,
            versionLaunchDate: String
        ) {
            YDYHeartNFTs.totalSupply = YDYHeartNFTs.totalSupply + 1
            self.id = YDYHeartNFTs.totalSupply

            self.name = "Heart #".concat(self.id.toString())
            self.description = "YDY Heart NFT #".concat(self.id.toString())
            self.thumbnailCID = thumbnailCID
            self.background = background
            self.body = body
            self.mouth = mouth
            self.eyes = eyes
            self.pants = pants

            self.zone = background

            self.level = 1
            self.lastLeveledUp = getCurrentBlock().timestamp

            self.stamina = 100.0
            self.lastStaminaUpdate = getCurrentBlock().timestamp

            self.endurance = UFix64(YDYHeartNFTs.calculateAttribute(rarity))
            self.lastEnduranceBoost = getCurrentBlock().timestamp
            self.efficiency = UFix64(YDYHeartNFTs.calculateAttribute(rarity))
            self.lastEfficiencyBoost = getCurrentBlock().timestamp
            self.luck = UFix64(YDYHeartNFTs.calculateAttribute(rarity))
            self.lastLuckBoost = getCurrentBlock().timestamp

            self.rarity = rarity

            self.version = version
            self.versionLaunchDate = versionLaunchDate
        }

        access(contract) fun levelUp() {
            self.level = self.level + 1
            self.lastLeveledUp = getCurrentBlock().timestamp
        }

        access(contract) fun repair(_ points: UFix64) {
            if (self.stamina + points > 100.0) {
                self.stamina = 100.0
            } else {
                self.stamina = self.stamina + points
            }
            self.lastStaminaUpdate = getCurrentBlock().timestamp
        }

        access(contract) fun reduceStamina(_ points: UFix64) {
            pre {
                self.stamina > points: "Not enough stamina to reduce by"
            }
            self.stamina = self.stamina - points
            self.lastStaminaUpdate = getCurrentBlock().timestamp
        }

        access(contract) fun boostEndurance(_ points: UFix64) {
            self.endurance = self.endurance + points
            self.lastEnduranceBoost = getCurrentBlock().timestamp
        }

        access(contract) fun boostEfficiency(_ points: UFix64) {
            self.efficiency = self.efficiency + points
            self.lastEfficiencyBoost = getCurrentBlock().timestamp
        }

        access(contract) fun boostLuck(_ points: UFix64) {
            self.luck = self.luck + points
            self.lastLuckBoost = getCurrentBlock().timestamp
        }

        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.Royalties>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.name,
                        description: self.description,
                        thumbnail: MetadataViews.IPFSFile(
                            cid: self.thumbnailCID,
                            path: "/".concat(self.id.toString()).concat(".png")
                        )
                    )
                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: YDYHeartNFTs.CollectionStoragePath,
                        publicPath: YDYHeartNFTs.CollectionPublicPath,
                        providerPath: /private/ydyNFTCollection,
                        publicCollection: Type<&YDYHeartNFTs.Collection{YDYHeartNFTs.YDYNFTCollectionPublic}>(),
                        publicLinkedType: Type<&YDYHeartNFTs.Collection{YDYHeartNFTs.YDYNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&YDYHeartNFTs.Collection{YDYHeartNFTs.YDYNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(),
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                            return <-YDYHeartNFTs.createEmptyCollection()
                        })
                    )
                case Type<MetadataViews.NFTCollectionDisplay>():
                    let media = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: "https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg"
                        ),
                        mediaType: "image/svg+xml"
                    )
                    return MetadataViews.NFTCollectionDisplay(
                        name: "YDY NFT",
                        description: "Collection of YDY NFTs.",
                        externalURL: MetadataViews.ExternalURL("https://www.ydylife.com/"),
                        squareImage: media,
                        bannerImage: media,
                        socials: {
                            "twitter": MetadataViews.ExternalURL("https://twitter.com/ydylife")
                        }
                    )
                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL(
                        "https://www.ydylife.com/"
                    )
                case Type<MetadataViews.Royalties>():
                    return MetadataViews.Royalties(
                        [MetadataViews.Royalty(recepient: getAccount(YDYHeartNFTs.account.address).getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver), cut: 0.075, description: "This is the royalty receiver for YDY NFTs")]
                    )
            }
            return nil
        }
    }

    pub resource interface YDYNFTCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowYDYNFT(id: UInt64): &YDYHeartNFTs.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow YDYNFT reference: the ID of the returned reference is incorrect"
            }
        }
        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver}
    }

    pub resource interface YDYNFTCollectionPrivate {
        access(account) fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT
    }

    pub resource Collection: YDYNFTCollectionPublic, YDYNFTCollectionPrivate, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @YDYHeartNFTs.NFT
            let id: UInt64 = token.id
            emit Deposit(id: id, to: self.owner?.address)

            self.ownedNFTs[id] <-! token
        }

        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowYDYNFT(id: UInt64): &YDYHeartNFTs.NFT? {
            if self.ownedNFTs[id] != nil {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)
                return ref as! &YDYHeartNFTs.NFT?
            }

            return nil
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let ydyNFT = nft as! &YDYHeartNFTs.NFT
            return ydyNFT as &AnyResource{MetadataViews.Resolver}
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    pub resource Admin {

        pub fun mintNFT(metadata: {String: String}, recipient: Capability<&Collection{YDYHeartNFTs.YDYNFTCollectionPublic}>) {
               pre {
                    metadata["thumbnailCID"] != nil: "thumbnailCID is required"
                    metadata["background"] != nil: "background is required"
                    metadata["body"] != nil: "body is required"
                    metadata["mouth"] != nil: "mouth is required"
                    metadata["eyes"] != nil: "eyes is required"
                    metadata["pants"] != nil: "pants is required"
                    metadata["rarity"] != nil: "rarity is required"
                    metadata["version"] != nil: "version is required"
                    metadata["versionLaunchDate"] != nil: "versionLaunchDate is required"
               }
               let nft <- create NFT(thumbnailCID: metadata["thumbnailCID"]!, background: metadata["background"]!, body: metadata["body"]!, mouth: metadata["mouth"]!, eyes: metadata["eyes"]!, pants: metadata["pants"]!, rarity: metadata["rarity"]!, version: metadata["version"]!, versionLaunchDate: metadata["versionLaunchDate"]!)
               let recipientCollection = recipient.borrow() ?? panic("Could not borrow recipient's collection")
               recipientCollection.deposit(token: <-nft)
            }

        pub fun levelUp(id: UInt64, recipientCollectionCapability: Capability<&Collection{YDYHeartNFTs.YDYNFTCollectionPublic}>): &YDYHeartNFTs.NFT? {
            post {
                nft.level == beforeLevel + 1: "The level must be increased by 1"
            }

            let receiver = recipientCollectionCapability.borrow() ?? panic("Cannot borrow")
            let nft = receiver.borrowYDYNFT(id: id) ?? panic("No NFT with this ID exists for user")

            let beforeLevel= nft.level
            nft.levelUp();
            return nft;
        }

        pub fun repair(points: UFix64, id: UInt64, recipientCollectionCapability: Capability<&Collection{YDYHeartNFTs.YDYNFTCollectionPublic}>): &YDYHeartNFTs.NFT? {
            let receiver = recipientCollectionCapability.borrow() ?? panic("Cannot borrow")
            let nft = receiver.borrowYDYNFT(id: id) ?? panic("No NFT with this ID exists for user")

            let beforeStamina = nft.stamina
            nft.repair(points);
            return nft
        }

        pub fun reduceStamina(points: UFix64, id: UInt64, recipientCollectionCapability: Capability<&Collection{YDYHeartNFTs.YDYNFTCollectionPublic}>): &YDYHeartNFTs.NFT? {
            post {
                nft.stamina == beforeStamina - points: "The stamina must be reduced by the points"
            }

            let receiver = recipientCollectionCapability.borrow() ?? panic("Cannot borrow")
            let nft = receiver.borrowYDYNFT(id: id) ?? panic("No NFT with this ID exists for user")

            let beforeStamina = nft.stamina
            nft.reduceStamina(points)
            return nft
        }

        pub fun boostEndurance(points: UFix64, id: UInt64, recipientCollectionCapability: Capability<&Collection{YDYHeartNFTs.YDYNFTCollectionPublic}>): &YDYHeartNFTs.NFT? {
            let receiver = recipientCollectionCapability.borrow() ?? panic("Cannot borrow")
            let nft = receiver.borrowYDYNFT(id: id) ?? panic("No NFT with this ID exists for user")

            nft.boostEndurance(points)
            return nft
        }

        pub fun boostEfficiency(points: UFix64, id: UInt64, recipientCollectionCapability: Capability<&Collection{YDYHeartNFTs.YDYNFTCollectionPublic}>): &YDYHeartNFTs.NFT? {
            let receiver = recipientCollectionCapability.borrow() ?? panic("Cannot borrow")
            let nft = receiver.borrowYDYNFT(id: id) ?? panic("No NFT with this ID exists for user")

            nft.boostEfficiency(points)
            return nft
        }

        pub fun boostLuck(points: UFix64, id: UInt64, recipientCollectionCapability: Capability<&Collection{YDYHeartNFTs.YDYNFTCollectionPublic}>): &YDYHeartNFTs.NFT? {
            let receiver = recipientCollectionCapability.borrow() ?? panic("Cannot borrow")
            let nft = receiver.borrowYDYNFT(id: id) ?? panic("No NFT with this ID exists for user")

            nft.boostLuck(points)
            return nft
        }

        pub fun changePrice(price: UFix64) {
            YDYHeartNFTs.price = price
        }

        pub fun changeIsMintingEnabled(isMinting: Bool) {
            YDYHeartNFTs.isMintingEnabled = isMinting
        }
    }

    init() {
        self.totalSupply = 0
        self.price = 100.0
        self.isMintingEnabled = false

        self.CollectionStoragePath = /storage/YDYHeartNFTsCollection
        self.CollectionPublicPath = /public/YDYHeartNFTsCollection
        self.AdminStoragePath = /storage/YDYHeartNFTsAdmin

        let admin <- create Admin()
        self.account.save(<-admin, to: self.AdminStoragePath)

        emit ContractInitialized()
    }
}"
-------
"import Minter from 0xd9bc8eb0e90863f7
import FungibleToken from 0xf233dcee88fe0abe
import FlowUtilityToken from 0xead892083b3e2c6c

pub contract FlowUtilityTokenMinter {
    pub resource FungibleTokenMinter: Minter.FungibleTokenMinter {
        pub let type: Type
        pub let addr: Address

        pub fun mintTokens(acct: AuthAccount, amount: UFix64): @FungibleToken.Vault {
            let mainVault = acct.borrow<&FlowUtilityToken.Vault>(from: /storage/flowUtilityTokenVault)
                ?? panic("vault not found")
            let tokens <- mainVault.withdraw(amount: amount)
            return <- tokens
        }

        init(_ t: Type, _ a: Address) {
            self.type = t
            self.addr = a
        }
    }

    pub fun createMinter(_ t: Type, _ a: Address): @FungibleTokenMinter {
        return <- create FungibleTokenMinter(t, a)
    }
}"
-------
"import Minter from 0xd9bc8eb0e90863f7
import FungibleToken from 0xf233dcee88fe0abe
import FlowToken from 0x1654653399040a61

pub contract FlowTokenMinter {
    pub resource FungibleTokenMinter: Minter.FungibleTokenMinter {
        pub let type: Type
        pub let addr: Address

        pub fun mintTokens(acct: AuthAccount, amount: UFix64): @FungibleToken.Vault {
            let admin = acct.borrow<&FlowToken.Administrator>(from: /storage/flowTokenAdmin)
                ?? panic("admin not found")
            let minter <- admin.createNewMinter(allowedAmount: amount)
            let tokens <- minter.mintTokens(amount: amount)

            destroy minter
            return <- tokens
        }

        init(_ t: Type, _ a: Address) {
            self.type = t
            self.addr = a
        }
    }

    pub fun createMinter(_ t: Type, _ a: Address): @FungibleTokenMinter {
        return <- create FungibleTokenMinter(t, a)
    }
}"
-------
"import Minter from 0xd9bc8eb0e90863f7
import FungibleToken from 0xf233dcee88fe0abe
import FiatToken from 0xb19436aae4d94622

pub contract FiatTokenMinter {
    pub resource FungibleTokenMinter: Minter.FungibleTokenMinter {
        pub let type: Type
        pub let addr: Address

        pub fun mintTokens(acct: AuthAccount, amount: UFix64): @FungibleToken.Vault {
            let minter <-  FiatToken.createNewMinter()
            let controller <- FiatToken.createNewMinterController(publicKeys: [], pubKeyAttrs: [])

            let executor = acct.borrow<&FiatToken.MasterMinterExecutor>(from: FiatToken.MasterMinterExecutorStoragePath)
                ?? panic("executor not found")
            executor.configureMinterController(minter: minter.uuid, minterController: controller.uuid)
            controller.increaseMinterAllowance(increment: amount)

            let tokens <- minter.mint(amount: amount)

            destroy minter
            destroy controller

            return <- tokens
        }

        init(_ t: Type, _ a: Address) {
            self.type = t
            self.addr = a
        }
    }

    pub fun createMinter(_ t: Type, _ a: Address): @FungibleTokenMinter {
        return <- create FungibleTokenMinter(t, a)
    }
}"
-------
"import NonFungibleToken from 0x1d7e57aa55817448

pub contract TopShotLocking {

    // -----------------------------------------------------------------------
    // TopShotLocking contract Events
    // -----------------------------------------------------------------------
    // Emitted when a Moment is locked
    pub event MomentLocked(id: UInt64, duration: UFix64, expiryTimestamp: UFix64)

    // Emitted when a Moment is unlocked
    pub event MomentUnlocked(id: UInt64)

    // Dictionary of locked NFTs
    // TopShot nft resource id is the key
    // locked until timestamp is the value
    access(self) var lockedNFTs: {UInt64: UFix64}

    // Dictionary of NFTs overridden to be unlocked
    access(self) var unlockableNFTs: {UInt64: Bool} // nft resource id is the key
    // isLocked Returns a boolean indicating if an nft exists in the lockedNFTs dictionary
    //
    // Parameters: nftRef: A reference to the NFT resource
    //
    // Returns: true if NFT is locked
    pub fun isLocked(nftRef: &NonFungibleToken.NFT): Bool {
        return self.lockedNFTs.containsKey(nftRef.id)
    }

    // getLockExpiry Returns the unix timestamp when an nft is unlockable
    //
    // Parameters: nftRef: A reference to the NFT resource
    //
    // Returns: unix timestamp
    pub fun getLockExpiry(nftRef: &NonFungibleToken.NFT): UFix64 {
        if !self.lockedNFTs.containsKey(nftRef.id) {
            panic("NFT is not locked")
        }
        return self.lockedNFTs[nftRef.id]!
    }

    // lockNFT Takes an NFT resource and adds its unique identifier to the lockedNFTs dictionary
    //
    // Parameters: nft: NFT resource
    //             duration: number of seconds the NFT will be locked for
    //
    // Returns: the NFT resource
    pub fun lockNFT(nft: @NonFungibleToken.NFT, duration: UFix64): @NonFungibleToken.NFT {
        let TopShotNFTType: Type = CompositeType("A.0b2a3299cc857e29.TopShot.NFT")!
        if !nft.isInstance(TopShotNFTType) {
            panic("NFT is not a TopShot NFT")
        }

        if self.lockedNFTs.containsKey(nft.id) {
            // already locked - short circuit and return the nft
            return <- nft
        }

        let expiryTimestamp = getCurrentBlock().timestamp + duration

        self.lockedNFTs[nft.id] = expiryTimestamp

        emit MomentLocked(id: nft.id, duration: duration, expiryTimestamp: expiryTimestamp)

        return <- nft
    }

    // unlockNFT Takes an NFT resource and removes it from the lockedNFTs dictionary
    //
    // Parameters: nft: NFT resource
    //
    // Returns: the NFT resource
    //
    // NFT must be eligible for unlocking by an admin
    pub fun unlockNFT(nft: @NonFungibleToken.NFT): @NonFungibleToken.NFT {
        if !self.lockedNFTs.containsKey(nft.id) {
            // nft is not locked, short circuit and return the nft
            return <- nft
        }

        let lockExpiryTimestamp: UFix64 = self.lockedNFTs[nft.id]!
        let isPastExpiry: Bool = getCurrentBlock().timestamp >= lockExpiryTimestamp

        let isUnlockableOverridden: Bool = self.unlockableNFTs.containsKey(nft.id)

        if !(isPastExpiry || isUnlockableOverridden) {
            panic("NFT is not eligible to be unlocked, expires at ".concat(lockExpiryTimestamp.toString()))
        }

        self.unlockableNFTs.remove(key: nft.id)
        self.lockedNFTs.remove(key: nft.id)

        emit MomentUnlocked(id: nft.id)

        return <- nft
    }

    // getIDs Returns the ids of all locked Top Shot NFT tokens
    //
    // Returns: array of ids
    //
    pub fun getIDs(): [UInt64] {
        return self.lockedNFTs.keys
    }

    // getExpiry Returns the timestamp when a locked token is eligible for unlock
    //
    // Parameters: tokenID: the nft id of the locked token
    //
    // Returns: a unix timestamp in seconds
    //
    pub fun getExpiry(tokenID: UInt64): UFix64? {
        return self.lockedNFTs[tokenID]
    }

    // getLockedNFTsLength Returns the count of locked tokens
    //
    // Returns: an integer containing the number of locked tokens
    //
    pub fun getLockedNFTsLength(): Int {
        return self.lockedNFTs.length
    }

    // The path to the TopShotLocking Admin resource belonging to the Account
    // which the contract is deployed on
    pub fun AdminStoragePath() : StoragePath { return /storage/TopShotLockingAdmin}

    // Admin is a special authorization resource that
    // allows the owner to override the lock on a moment
    //
    pub resource Admin {
        // createNewAdmin creates a new Admin resource
        //
        pub fun createNewAdmin(): @Admin {
            return <-create Admin()
        }

        // markNFTUnlockable marks a given nft as being
        // unlockable, overridding the expiry timestamp
        // the nft owner will still need to send an unlock transaction to unlock
        //
        pub fun markNFTUnlockable(nftRef: &NonFungibleToken.NFT) {
            TopShotLocking.unlockableNFTs[nftRef.id] = true
        }

        pub fun unlockByID(id: UInt64) {
            if !TopShotLocking.lockedNFTs.containsKey(id) {
                // nft is not locked, do nothing
                return
            }
            TopShotLocking.lockedNFTs.remove(key: id)
            emit MomentUnlocked(id: id)
        }

        // admin may alter the expiry of a lock on an NFT
        pub fun setLockExpiryByID(id: UInt64, expiryTimestamp: UFix64) {
            if expiryTimestamp < getCurrentBlock().timestamp {
                panic("cannot set expiry in the past")
            }

            let duration = expiryTimestamp - getCurrentBlock().timestamp

            TopShotLocking.lockedNFTs[id] = expiryTimestamp

            emit MomentLocked(id: id, duration: duration, expiryTimestamp: expiryTimestamp)
        }

        // unlocks all NFTs
        pub fun unlockAll() {
            TopShotLocking.lockedNFTs = {}
            TopShotLocking.unlockableNFTs = {}
        }
    }

    // -----------------------------------------------------------------------
    // TopShotLocking initialization function
    // -----------------------------------------------------------------------
    //
    init() {
        self.lockedNFTs = {}
        self.unlockableNFTs = {}

        // Create a single admin resource
        let admin <- create Admin()

        // Store it in private account storage in `init` so only the admin can use it
        self.account.save(<-admin, to: TopShotLocking.AdminStoragePath())
    }
}
"
-------
"/*
    Description: Central Smart Contract for NBA TopShot

    This smart contract contains the core functionality for
    NBA Top Shot, created by Dapper Labs

    The contract manages the data associated with all the plays and sets
    that are used as templates for the Moment NFTs

    When a new Play wants to be added to the records, an Admin creates
    a new Play struct that is stored in the smart contract.

    Then an Admin can create new Sets. Sets consist of a public struct that
    contains public information about a set, and a private resource used
    to mint new moments based off of plays that have been linked to the Set.

    The admin resource has the power to do all of the important actions
    in the smart contract. When admins want to call functions in a set,
    they call their borrowSet function to get a reference
    to a set in the contract. Then, they can call functions on the set using that reference.

    In this way, the smart contract and its defined resources interact
    with great teamwork, just like the Indiana Pacers, the greatest NBA team
    of all time.

    When moments are minted, they are initialized with a MomentData struct and
    are returned by the minter.

    The contract also defines a Collection resource. This is an object that
    every TopShot NFT owner will store in their account
    to manage their NFT collection.

    The main Top Shot account will also have its own Moment collections
    it can use to hold its own moments that have not yet been sent to a user.

    Note: All state changing functions will panic if an invalid argument is
    provided or one of its pre-conditions or post conditions aren't met.
    Functions that don't modify state will simply return 0 or nil
    and those cases need to be handled by the caller.

    It is also important to remember that
    The Golden State Warriors blew a 3-1 lead in the 2016 NBA finals.

*/

import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import TopShotLocking from 0x0b2a3299cc857e29

pub contract TopShot: NonFungibleToken {
    // -----------------------------------------------------------------------
    // TopShot deployment variables
    // -----------------------------------------------------------------------

    // The network the contract is deployed on
    pub fun Network() : String { return "mainnet" }

    // The address to which royalties should be deposited
    pub fun RoyaltyAddress() : Address { return 0xfaf0cc52c6e3acaf }


    // The path to the Subedition Admin resource belonging to the Account
    // which the contract is deployed on
    pub fun SubeditionAdminStoragePath() : StoragePath { return /storage/TopShotSubeditionAdmin}

    // -----------------------------------------------------------------------
    // TopShot contract Events
    // -----------------------------------------------------------------------

    // Emitted when the TopShot contract is created
    pub event ContractInitialized()

    // Emitted when a new Play struct is created
    pub event PlayCreated(id: UInt32, metadata: {String:String})
    // Emitted when a new series has been triggered by an admin
    pub event NewSeriesStarted(newCurrentSeries: UInt32)

    // Events for Set-Related actions
    //
    // Emitted when a new Set is created
    pub event SetCreated(setID: UInt32, series: UInt32)
    // Emitted when a new Play is added to a Set
    pub event PlayAddedToSet(setID: UInt32, playID: UInt32)
    // Emitted when a Play is retired from a Set and cannot be used to mint
    pub event PlayRetiredFromSet(setID: UInt32, playID: UInt32, numMoments: UInt32)
    // Emitted when a Set is locked, meaning Plays cannot be added
    pub event SetLocked(setID: UInt32)
    // Emitted when a Moment is minted from a Set
    pub event MomentMinted(momentID: UInt64, playID: UInt32, setID: UInt32, serialNumber: UInt32, subeditionID: UInt32)

    // Events for Collection-related actions
    //
    // Emitted when a moment is withdrawn from a Collection
    pub event Withdraw(id: UInt64, from: Address?)
    // Emitted when a moment is deposited into a Collection
    pub event Deposit(id: UInt64, to: Address?)

    // Emitted when a Moment is destroyed
    pub event MomentDestroyed(id: UInt64)

    // Emitted when a Subedition is created
    pub event SubeditionCreated(subeditionID: UInt32, name: String, metadata: {String:String})

    // Emitted when a Subedition is linked to the specific Moment
    pub event SubeditionAddedToMoment(momentID: UInt64, subeditionID: UInt32, setID: UInt32, playID: UInt32)

    // -----------------------------------------------------------------------
    // TopShot contract-level fields.
    // These contain actual values that are stored in the smart contract.
    // -----------------------------------------------------------------------

    // Series that this Set belongs to.
    // Series is a concept that indicates a group of Sets through time.
    // Many Sets can exist at a time, but only one series.
    pub var currentSeries: UInt32

    // Variable size dictionary of Play structs
    access(self) var playDatas: {UInt32: Play}

    // Variable size dictionary of SetData structs
    access(self) var setDatas: {UInt32: SetData}

    // Variable size dictionary of Set resources
    access(self) var sets: @{UInt32: Set}

    // The ID that is used to create Plays.
    // Every time a Play is created, playID is assigned
    // to the new Play's ID and then is incremented by 1.
    pub var nextPlayID: UInt32

    // The ID that is used to create Sets. Every time a Set is created
    // setID is assigned to the new set's ID and then is incremented by 1.
    pub var nextSetID: UInt32

    // The total number of Top shot Moment NFTs that have been created
    // Because NFTs can be destroyed, it doesn't necessarily mean that this
    // reflects the total number of NFTs in existence, just the number that
    // have been minted to date. Also used as global moment IDs for minting.
    pub var totalSupply: UInt64

    // -----------------------------------------------------------------------
    // TopShot contract-level Composite Type definitions
    // -----------------------------------------------------------------------
    // These are just *definitions* for Types that this contract
    // and other accounts can use. These definitions do not contain
    // actual stored values, but an instance (or object) of one of these Types
    // can be created by this contract that contains stored values.
    // -----------------------------------------------------------------------

    // Play is a Struct that holds metadata associated
    // with a specific NBA play, like the legendary moment when
    // Ray Allen hit the 3 to tie the Heat and Spurs in the 2013 finals game 6
    // or when Lance Stephenson blew in the ear of Lebron James.
    //
    // Moment NFTs will all reference a single play as the owner of
    // its metadata. The plays are publicly accessible, so anyone can
    // read the metadata associated with a specific play ID
    //
    pub struct Play {

        // The unique ID for the Play
        pub let playID: UInt32

        // Stores all the metadata about the play as a string mapping
        // This is not the long term way NFT metadata will be stored. It's a temporary
        // construct while we figure out a better way to do metadata.
        //
        pub let metadata: {String: String}

        init(metadata: {String: String}) {
            pre {
                metadata.length != 0: "New Play metadata cannot be empty"
            }
            self.playID = TopShot.nextPlayID
            self.metadata = metadata
        }

        /// This function is intended to backfill the Play on blockchain with a more detailed
        /// description of the Play. The benefit of having the description is that anyone would
        /// be able to know the story of the Play directly from Flow
        access(contract) fun updateTagline(tagline: String): UInt32 {
            self.metadata["Tagline"] = tagline

            TopShot.playDatas[self.playID] = self
            return self.playID
        }
    }

    // A Set is a grouping of Plays that have occured in the real world
    // that make up a related group of collectibles, like sets of baseball
    // or Magic cards. A Play can exist in multiple different sets.
    //
    // SetData is a struct that is stored in a field of the contract.
    // Anyone can query the constant information
    // about a set by calling various getters located
    // at the end of the contract. Only the admin has the ability
    // to modify any data in the private Set resource.
    //
    pub struct SetData {

        // Unique ID for the Set
        pub let setID: UInt32

        // Name of the Set
        // ex. "Times when the Toronto Raptors choked in the playoffs"
        pub let name: String

        // Series that this Set belongs to.
        // Series is a concept that indicates a group of Sets through time.
        // Many Sets can exist at a time, but only one series.
        pub let series: UInt32

        init(name: String) {
            pre {
                name.length > 0: "New Set name cannot be empty"
            }
            self.setID = TopShot.nextSetID
            self.name = name
            self.series = TopShot.currentSeries
        }
    }

    // Set is a resource type that contains the functions to add and remove
    // Plays from a set and mint Moments.
    //
    // It is stored in a private field in the contract so that
    // the admin resource can call its methods.
    //
    // The admin can add Plays to a Set so that the set can mint Moments
    // that reference that playdata.
    // The Moments that are minted by a Set will be listed as belonging to
    // the Set that minted it, as well as the Play it references.
    //
    // Admin can also retire Plays from the Set, meaning that the retired
    // Play can no longer have Moments minted from it.
    //
    // If the admin locks the Set, no more Plays can be added to it, but
    // Moments can still be minted.
    //
    // If retireAll() and lock() are called back-to-back,
    // the Set is closed off forever and nothing more can be done with it.
    pub resource Set {

        // Unique ID for the set
        pub let setID: UInt32

        // Array of plays that are a part of this set.
        // When a play is added to the set, its ID gets appended here.
        // The ID does not get removed from this array when a Play is retired.
        access(contract) var plays: [UInt32]

        // Map of Play IDs that Indicates if a Play in this Set can be minted.
        // When a Play is added to a Set, it is mapped to false (not retired).
        // When a Play is retired, this is set to true and cannot be changed.
        access(contract) var retired: {UInt32: Bool}

        // Indicates if the Set is currently locked.
        // When a Set is created, it is unlocked
        // and Plays are allowed to be added to it.
        // When a set is locked, Plays cannot be added.
        // A Set can never be changed from locked to unlocked,
        // the decision to lock a Set it is final.
        // If a Set is locked, Plays cannot be added, but
        // Moments can still be minted from Plays
        // that exist in the Set.
        pub var locked: Bool

        // Mapping of Play IDs that indicates the number of Moments
        // that have been minted for specific Plays in this Set.
        // When a Moment is minted, this value is stored in the Moment to
        // show its place in the Set, eg. 13 of 60.
        access(contract) var numberMintedPerPlay: {UInt32: UInt32}

        init(name: String) {
            self.setID = TopShot.nextSetID
            self.plays = []
            self.retired = {}
            self.locked = false
            self.numberMintedPerPlay = {}

            // Create a new SetData for this Set and store it in contract storage
            TopShot.setDatas[self.setID] = SetData(name: name)
        }

        // addPlay adds a play to the set
        //
        // Parameters: playID: The ID of the Play that is being added
        //
        // Pre-Conditions:
        // The Play needs to be an existing play
        // The Set needs to be not locked
        // The Play can't have already been added to the Set
        //
        pub fun addPlay(playID: UInt32) {
            pre {
                TopShot.playDatas[playID] != nil: "Cannot add the Play to Set: Play doesn't exist."
                !self.locked: "Cannot add the play to the Set after the set has been locked."
                self.numberMintedPerPlay[playID] == nil: "The play has already beed added to the set."
            }

            // Add the Play to the array of Plays
            self.plays.append(playID)

            // Open the Play up for minting
            self.retired[playID] = false

            // Initialize the Moment count to zero
            self.numberMintedPerPlay[playID] = 0

            emit PlayAddedToSet(setID: self.setID, playID: playID)
        }

        // addPlays adds multiple Plays to the Set
        //
        // Parameters: playIDs: The IDs of the Plays that are being added
        //                      as an array
        //
        pub fun addPlays(playIDs: [UInt32]) {
            for play in playIDs {
                self.addPlay(playID: play)
            }
        }

        // retirePlay retires a Play from the Set so that it can't mint new Moments
        //
        // Parameters: playID: The ID of the Play that is being retired
        //
        // Pre-Conditions:
        // The Play is part of the Set and not retired (available for minting).
        //
        pub fun retirePlay(playID: UInt32) {
            pre {
                self.retired[playID] != nil: "Cannot retire the Play: Play doesn't exist in this set!"
            }

            if !self.retired[playID]! {
                self.retired[playID] = true

                emit PlayRetiredFromSet(setID: self.setID, playID: playID, numMoments: self.numberMintedPerPlay[playID]!)
            }
        }

        // retireAll retires all the plays in the Set
        // Afterwards, none of the retired Plays will be able to mint new Moments
        //
        pub fun retireAll() {
            for play in self.plays {
                self.retirePlay(playID: play)
            }
        }

        // lock() locks the Set so that no more Plays can be added to it
        //
        // Pre-Conditions:
        // The Set should not be locked
        pub fun lock() {
            if !self.locked {
                self.locked = true
                emit SetLocked(setID: self.setID)
            }
        }

        // mintMoment mints a new Moment and returns the newly minted Moment
        //
        // Parameters: playID: The ID of the Play that the Moment references
        //
        // Pre-Conditions:
        // The Play must exist in the Set and be allowed to mint new Moments
        //
        // Returns: The NFT that was minted
        //
        pub fun mintMoment(playID: UInt32): @NFT {
            pre {
                self.retired[playID] != nil: "Cannot mint the moment: This play doesn't exist."
                !self.retired[playID]!: "Cannot mint the moment from this play: This play has been retired."
            }

            // Gets the number of Moments that have been minted for this Play
            // to use as this Moment's serial number
            let numInPlay = self.numberMintedPerPlay[playID]!

            // Mint the new moment
            let newMoment: @NFT <- create NFT(serialNumber: numInPlay + UInt32(1),
                                              playID: playID,
                                              setID: self.setID,
                                              subeditionID: 0)

            // Increment the count of Moments minted for this Play
            self.numberMintedPerPlay[playID] = numInPlay + UInt32(1)

            return <-newMoment
        }

        // batchMintMoment mints an arbitrary quantity of Moments
        // and returns them as a Collection
        //
        // Parameters: playID: the ID of the Play that the Moments are minted for
        //             quantity: The quantity of Moments to be minted
        //
        // Returns: Collection object that contains all the Moments that were minted
        //
        pub fun batchMintMoment(playID: UInt32, quantity: UInt64): @Collection {
            let newCollection <- create Collection()

            var i: UInt64 = 0
            while i < quantity {
                newCollection.deposit(token: <-self.mintMoment(playID: playID))
                i = i + UInt64(1)
            }

            return <-newCollection
        }

        // mintMomentWithSubedition mints a new Moment with subedition and returns the newly minted Moment
        //
        // Parameters: playID: The ID of the Play that the Moment references
        //             subeditionID: The ID of the subedition within Edition that the Moment references
        //
        // Pre-Conditions:
        // The Play must exist in the Set and be allowed to mint new Moments
        //
        // Returns: The NFT that was minted
        //
        pub fun mintMomentWithSubedition(playID: UInt32, subeditionID: UInt32): @NFT {
            pre {
                self.retired[playID] != nil: "Cannot mint the moment: This play doesn't exist."
                !self.retired[playID]!: "Cannot mint the moment from this play: This play has been retired."
            }

            // Gets the number of Moments that have been minted for this subedition
            // to use as this Moment's serial number
            let subeditionRef = TopShot.account.borrow<&SubeditionAdmin>(from: TopShot.SubeditionAdminStoragePath())
            ?? panic("No subedition admin resource in storage")

            let numInSubedition = subeditionRef.getNumberMintedPerSubedition(setID: self.setID,
                                                                             playID: playID,
                                                                             subeditionID: subeditionID)

            // Mint the new moment
            let newMoment: @NFT <- create NFT(serialNumber: numInSubedition + UInt32(1),
                                              playID: playID,
                                              setID: self.setID,
                                              subeditionID: subeditionID)

            // Increment the count of Moments minted for this subedition
            subeditionRef.addToNumberMintedPerSubedition(setID: self.setID,
                                                         playID: playID,
                                                         subeditionID: subeditionID)

            subeditionRef.setMomentsSubedition(nftID: newMoment.id, subeditionID: subeditionID, setID: self.setID, playID: playID)

            self.numberMintedPerPlay[playID] = self.numberMintedPerPlay[playID]! + UInt32(1)

            return <-newMoment
        }

        // batchMintMomentWithSubedition mints an arbitrary quantity of Moments with subedition
        // and returns them as a Collection
        //
        // Parameters: playID: the ID of the Play that the Moments are minted for
        //             quantity: The quantity of Moments to be minted
        //             subeditionID: The ID of the subedition within Edition that the Moments references
        //
        // Returns: Collection object that contains all the Moments that were minted
        //
         pub fun batchMintMomentWithSubedition(playID: UInt32, quantity: UInt64, subeditionID: UInt32): @Collection {
            let newCollection <- create Collection()

            var i: UInt64 = 0
            while i < quantity {
                newCollection.deposit(token: <-self.mintMomentWithSubedition(playID: playID,
                                                                             subeditionID: subeditionID))
                i = i + UInt64(1)
            }

            return <-newCollection
        }

        pub fun getPlays(): [UInt32] {
            return self.plays
        }

        pub fun getRetired(): {UInt32: Bool} {
            return self.retired
        }

        pub fun getNumMintedPerPlay(): {UInt32: UInt32} {
            return self.numberMintedPerPlay
        }
    }

    // Struct that contains all of the important data about a set
    // Can be easily queried by instantiating the `QuerySetData` object
    // with the desired set ID
    // let setData = TopShot.QuerySetData(setID: 12)
    //
    pub struct QuerySetData {
        pub let setID: UInt32
        pub let name: String
        pub let series: UInt32
        access(self) var plays: [UInt32]
        access(self) var retired: {UInt32: Bool}
        pub var locked: Bool
        access(self) var numberMintedPerPlay: {UInt32: UInt32}

        init(setID: UInt32) {
            pre {
                TopShot.sets[setID] != nil: "The set with the provided ID does not exist"
            }

            let set = (&TopShot.sets[setID] as &Set?)!
            let setData = TopShot.setDatas[setID]!

            self.setID = setID
            self.name = setData.name
            self.series = setData.series
            self.plays = set.plays
            self.retired = set.retired
            self.locked = set.locked
            self.numberMintedPerPlay = set.numberMintedPerPlay
        }

        pub fun getPlays(): [UInt32] {
            return self.plays
        }

        pub fun getRetired(): {UInt32: Bool} {
            return self.retired
        }

        pub fun getNumberMintedPerPlay(): {UInt32: UInt32} {
            return self.numberMintedPerPlay
        }
    }

    pub struct MomentData {

        // The ID of the Set that the Moment comes from
        pub let setID: UInt32

        // The ID of the Play that the Moment references
        pub let playID: UInt32

        // The place in the edition that this Moment was minted
        // Otherwise know as the serial number
        pub let serialNumber: UInt32

        init(setID: UInt32, playID: UInt32, serialNumber: UInt32) {
            self.setID = setID
            self.playID = playID
            self.serialNumber = serialNumber
        }

    }

    // This is an implementation of a custom metadata view for Top Shot.
    // This view contains the play metadata.
    //
    pub struct TopShotMomentMetadataView {

        pub let fullName: String?
        pub let firstName: String?
        pub let lastName: String?
        pub let birthdate: String?
        pub let birthplace: String?
        pub let jerseyNumber: String?
        pub let draftTeam: String?
        pub let draftYear: String?
        pub let draftSelection: String?
        pub let draftRound: String?
        pub let teamAtMomentNBAID: String?
        pub let teamAtMoment: String?
        pub let primaryPosition: String?
        pub let height: String?
        pub let weight: String?
        pub let totalYearsExperience: String?
        pub let nbaSeason: String?
        pub let dateOfMoment: String?
        pub let playCategory: String?
        pub let playType: String?
        pub let homeTeamName: String?
        pub let awayTeamName: String?
        pub let homeTeamScore: String?
        pub let awayTeamScore: String?
        pub let seriesNumber: UInt32?
        pub let setName: String?
        pub let serialNumber: UInt32
        pub let playID: UInt32
        pub let setID: UInt32
        pub let numMomentsInEdition: UInt32?

        init(
            fullName: String?,
            firstName: String?,
            lastName: String?,
            birthdate: String?,
            birthplace: String?,
            jerseyNumber: String?,
            draftTeam: String?,
            draftYear: String?,
            draftSelection: String?,
            draftRound: String?,
            teamAtMomentNBAID: String?,
            teamAtMoment: String?,
            primaryPosition: String?,
            height: String?,
            weight: String?,
            totalYearsExperience: String?,
            nbaSeason: String?,
            dateOfMoment: String?,
            playCategory: String?,
            playType: String?,
            homeTeamName: String?,
            awayTeamName: String?,
            homeTeamScore: String?,
            awayTeamScore: String?,
            seriesNumber: UInt32?,
            setName: String?,
            serialNumber: UInt32,
            playID: UInt32,
            setID: UInt32,
            numMomentsInEdition: UInt32?
        ) {
            self.fullName = fullName
            self.firstName = firstName
            self.lastName = lastName
            self.birthdate = birthdate
            self.birthplace = birthplace
            self.jerseyNumber = jerseyNumber
            self.draftTeam = draftTeam
            self.draftYear = draftYear
            self.draftSelection = draftSelection
            self.draftRound = draftRound
            self.teamAtMomentNBAID = teamAtMomentNBAID
            self.teamAtMoment = teamAtMoment
            self.primaryPosition = primaryPosition
            self.height = height
            self.weight = weight
            self.totalYearsExperience = totalYearsExperience
            self.nbaSeason = nbaSeason
            self.dateOfMoment= dateOfMoment
            self.playCategory = playCategory
            self.playType = playType
            self.homeTeamName = homeTeamName
            self.awayTeamName = awayTeamName
            self.homeTeamScore = homeTeamScore
            self.awayTeamScore = awayTeamScore
            self.seriesNumber = seriesNumber
            self.setName = setName
            self.serialNumber = serialNumber
            self.playID = playID
            self.setID = setID
            self.numMomentsInEdition = numMomentsInEdition
        }
    }

    // The resource that represents the Moment NFTs
    //
    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {

        // Global unique moment ID
        pub let id: UInt64

        // Struct of Moment metadata
        pub let data: MomentData

        init(serialNumber: UInt32, playID: UInt32, setID: UInt32, subeditionID: UInt32) {
            // Increment the global Moment IDs
            TopShot.totalSupply = TopShot.totalSupply + UInt64(1)

            self.id = TopShot.totalSupply

            // Set the metadata struct
            self.data = MomentData(setID: setID, playID: playID, serialNumber: serialNumber)

            emit MomentMinted(momentID: self.id,
                              playID: playID,
                              setID: self.data.setID,
                              serialNumber: self.data.serialNumber,
                              subeditionID: subeditionID)
        }

        // If the Moment is destroyed, emit an event to indicate
        // to outside observers that it has been destroyed
        destroy() {
            emit MomentDestroyed(id: self.id)
        }

        pub fun name(): String {
            let fullName: String = TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "FullName") ?? ""
            let playType: String = TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "PlayType") ?? ""
            return fullName
                .concat(" ")
                .concat(playType)
        }

        access(self) fun buildDescString(): String {
            let setName: String = TopShot.getSetName(setID: self.data.setID) ?? ""
            let serialNumber: String = self.data.serialNumber.toString()
            let seriesNumber: String = TopShot.getSetSeries(setID: self.data.setID)?.toString() ?? ""
            return "A series "
                .concat(seriesNumber)
                .concat(" ")
                .concat(setName)
                .concat(" moment with serial number ")
                .concat(serialNumber)
        }

        /// The description of the Moment. If Tagline property of the play is empty, compose it using the buildDescString function
        /// If the Tagline property is not empty, use that as the description
        pub fun description(): String {
            let playDesc: String = TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "Tagline") ?? ""

            return playDesc.length > 0 ? playDesc : self.buildDescString()
        }

        // All supported metadata views for the Moment including the Core NFT Views
        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<TopShotMomentMetadataView>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.Editions>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.Traits>(),
                Type<MetadataViews.Medias>()
            ]
        }



        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.name(),
                        description: self.description(),
                        thumbnail: MetadataViews.HTTPFile(url: self.thumbnail())
                    )
                // Custom metadata view unique to TopShot Moments
                case Type<TopShotMomentMetadataView>():
                    return TopShotMomentMetadataView(
                        fullName: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "FullName"),
                        firstName: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "FirstName"),
                        lastName: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "LastName"),
                        birthdate: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "Birthdate"),
                        birthplace: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "Birthplace"),
                        jerseyNumber: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "JerseyNumber"),
                        draftTeam: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "DraftTeam"),
                        draftYear: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "DraftYear"),
                        draftSelection: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "DraftSelection"),
                        draftRound: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "DraftRound"),
                        teamAtMomentNBAID: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "TeamAtMomentNBAID"),
                        teamAtMoment: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "TeamAtMoment"),
                        primaryPosition: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "PrimaryPosition"),
                        height: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "Height"),
                        weight: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "Weight"),
                        totalYearsExperience: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "TotalYearsExperience"),
                        nbaSeason: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "NbaSeason"),
                        dateOfMoment: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "DateOfMoment"),
                        playCategory: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "PlayCategory"),
                        playType: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "PlayType"),
                        homeTeamName: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "HomeTeamName"),
                        awayTeamName: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "AwayTeamName"),
                        homeTeamScore: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "HomeTeamScore"),
                        awayTeamScore: TopShot.getPlayMetaDataByField(playID: self.data.playID, field: "AwayTeamScore"),
                        seriesNumber: TopShot.getSetSeries(setID: self.data.setID),
                        setName: TopShot.getSetName(setID: self.data.setID),
                        serialNumber: self.data.serialNumber,
                        playID: self.data.playID,
                        setID: self.data.setID,
                        numMomentsInEdition: TopShot.getNumMomentsInEdition(setID: self.data.setID, playID: self.data.playID)
                    )
                case Type<MetadataViews.Editions>():
                    let name = self.getEditionName()
                    let max = TopShot.getNumMomentsInEdition(setID: self.data.setID, playID: self.data.playID) ?? 0
                    let editionInfo = MetadataViews.Edition(name: name, number: UInt64(self.data.serialNumber), max: max > 0 ? UInt64(max) : nil)
                    let editionList: [MetadataViews.Edition] = [editionInfo]
                    return MetadataViews.Editions(
                        editionList
                    )
                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(
                        UInt64(self.data.serialNumber)
                    )
                case Type<MetadataViews.Royalties>():
                    let royaltyReceiver: Capability<&{FungibleToken.Receiver}> =
                        getAccount(TopShot.RoyaltyAddress()).getCapability<&AnyResource{FungibleToken.Receiver}>(MetadataViews.getRoyaltyReceiverPublicPath())
                    return MetadataViews.Royalties(
                        royalties: [
                            MetadataViews.Royalty(
                                receiver: royaltyReceiver,
                                cut: 0.05,
                                description: "NBATopShot marketplace royalty"
                            )
                        ]
                    )
                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL(self.getMomentURL())
                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: /storage/MomentCollection,
                        publicPath: /public/MomentCollection,
                        providerPath: /private/MomentCollection,
                        publicCollection: Type<&TopShot.Collection{TopShot.MomentCollectionPublic}>(),
                        publicLinkedType: Type<&TopShot.Collection{TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&TopShot.Collection{NonFungibleToken.Provider,TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(),
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                            return <-TopShot.createEmptyCollection()
                        })
                    )
                case Type<MetadataViews.NFTCollectionDisplay>():
                    let bannerImage = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: "https://nbatopshot.com/static/img/top-shot-logo-horizontal-white.svg"
                        ),
                        mediaType: "image/svg+xml"
                    )
                    let squareImage = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: "https://nbatopshot.com/static/img/og/og.png"
                        ),
                        mediaType: "image/png"
                    )
                    return MetadataViews.NFTCollectionDisplay(
                        name: "NBA-Top-Shot",
                        description: "NBA Top Shot is your chance to own, sell, and trade official digital collectibles of the NBA and WNBA's greatest plays and players",
                        externalURL: MetadataViews.ExternalURL("https://nbatopshot.com"),
                        squareImage: squareImage,
                        bannerImage: bannerImage,
                        socials: {
                            "twitter": MetadataViews.ExternalURL("https://twitter.com/nbatopshot"),
                            "discord": MetadataViews.ExternalURL("https://discord.com/invite/nbatopshot"),
                            "instagram": MetadataViews.ExternalURL("https://www.instagram.com/nbatopshot")
                        }
                    )
                case Type<MetadataViews.Traits>():
                    // sports radar team id
                    let excludedNames: [String] = ["TeamAtMomentNBAID"]
                    // non play specific traits
                    let traitDictionary: {String: AnyStruct} = {
                        "SeriesNumber": TopShot.getSetSeries(setID: self.data.setID),
                        "SetName": TopShot.getSetName(setID: self.data.setID),
                        "SerialNumber": self.data.serialNumber,
                        "Locked": TopShotLocking.isLocked(nftRef: &self as! &NonFungibleToken.NFT)
                    }
                    // add play specific data
                    let fullDictionary = self.mapPlayData(dict: traitDictionary)
                    return MetadataViews.dictToTraits(dict: fullDictionary, excludedNames: excludedNames)
                case Type<MetadataViews.Medias>():
                    return MetadataViews.Medias(
                        items: [
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(
                                    url: self.mediumimage()
                                ),
                                mediaType: "image/jpeg"
                            ),
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(
                                    url: self.video()
                                ),
                                mediaType: "video/mp4"
                            )
                        ]
                    )
            }

            return nil
        }

        // Functions used for computing MetadataViews

        // mapPlayData helps build our trait map from play metadata
        // Returns: The trait map with all non-empty fields from play data added
        pub fun mapPlayData(dict: {String: AnyStruct}) : {String: AnyStruct} {
            let playMetadata = TopShot.getPlayMetaData(playID: self.data.playID) ?? {}
            for name in playMetadata.keys {
                let value = playMetadata[name] ?? ""
                if value != "" {
                    dict.insert(key: name, value)
                }
            }
            return dict
        }

        // getMomentURL
        // Returns: The computed external url of the moment
        pub fun getMomentURL(): String {
            return "https://nbatopshot.com/moment/".concat(self.id.toString())
        }
        // getEditionName Moment's edition name is a combination of the Moment's setName and playID
        // `setName: #playID`
        pub fun getEditionName() : String {
            let setName: String = TopShot.getSetName(setID: self.data.setID) ?? ""
            let editionName = setName.concat(": #").concat(self.data.playID.toString())
            return editionName
        }

        pub fun assetPath(): String {
            return "https://assets.nbatopshot.com/media/".concat(self.id.toString())
        }

        // returns a url to display an medium sized image
        pub fun mediumimage(): String {
            let url = self.assetPath().concat("?width=512")
            return self.appendOptionalParams(url: url, firstDelim: "&")
        }

        // a url to display a thumbnail associated with the moment
        pub fun thumbnail(): String {
            let url = self.assetPath().concat("?width=256")
            return self.appendOptionalParams(url: url, firstDelim: "&")
        }

        // a url to display a video associated with the moment
        pub fun video(): String {
            let url = self.assetPath().concat("/video")
            return self.appendOptionalParams(url: url, firstDelim: "?")
        }

        // appends and optional network param needed to resolve the media
        pub fun appendOptionalParams(url: String, firstDelim: String): String {
            if (TopShot.Network() == "testnet") {
                return url.concat(firstDelim).concat("testnet")
            }
            return url
        }
    }

    // Admin is a special authorization resource that
    // allows the owner to perform important functions to modify the
    // various aspects of the Plays, Sets, and Moments
    //
    pub resource Admin {

        // createPlay creates a new Play struct
        // and stores it in the Plays dictionary in the TopShot smart contract
        //
        // Parameters: metadata: A dictionary mapping metadata titles to their data
        //                       example: {"Player Name": "Kevin Durant", "Height": "7 feet"}
        //                               (because we all know Kevin Durant is not 6'9")
        //
        // Returns: the ID of the new Play object
        //
        pub fun createPlay(metadata: {String: String}): UInt32 {
            // Create the new Play
            var newPlay = Play(metadata: metadata)
            let newID = newPlay.playID

            // Increment the ID so that it isn't used again
            TopShot.nextPlayID = TopShot.nextPlayID + UInt32(1)

            emit PlayCreated(id: newPlay.playID, metadata: metadata)

            // Store it in the contract storage
            TopShot.playDatas[newID] = newPlay

            return newID
        }

        /// Temporarily enabled so the description of the play can be backfilled
        /// Parameters: playID: The ID of the play to update
        ///             tagline: A string to be used as the tagline for the play
        /// Returns: The ID of the play
        pub fun updatePlayTagline(playID: UInt32, tagline: String): UInt32 {
            let tmpPlay = TopShot.playDatas[playID] ?? panic("playID does not exist")
            tmpPlay.updateTagline(tagline: tagline)
            return playID
        }

        // createSet creates a new Set resource and stores it
        // in the sets mapping in the TopShot contract
        //
        // Parameters: name: The name of the Set
        //
        // Returns: The ID of the created set
        pub fun createSet(name: String): UInt32 {

            // Create the new Set
            var newSet <- create Set(name: name)

            // Increment the setID so that it isn't used again
            TopShot.nextSetID = TopShot.nextSetID + UInt32(1)

            let newID = newSet.setID

            emit SetCreated(setID: newSet.setID, series: TopShot.currentSeries)

            // Store it in the sets mapping field
            TopShot.sets[newID] <-! newSet

            return newID
        }

        // borrowSet returns a reference to a set in the TopShot
        // contract so that the admin can call methods on it
        //
        // Parameters: setID: The ID of the Set that you want to
        // get a reference to
        //
        // Returns: A reference to the Set with all of the fields
        // and methods exposed
        //
        pub fun borrowSet(setID: UInt32): &Set {
            pre {
                TopShot.sets[setID] != nil: "Cannot borrow Set: The Set doesn't exist"
            }

            // Get a reference to the Set and return it
            // use `&` to indicate the reference to the object and type
            return (&TopShot.sets[setID] as &Set?)!
        }

        // startNewSeries ends the current series by incrementing
        // the series number, meaning that Moments minted after this
        // will use the new series number
        //
        // Returns: The new series number
        //
        pub fun startNewSeries(): UInt32 {
            // End the current series and start a new one
            // by incrementing the TopShot series number
            TopShot.currentSeries = TopShot.currentSeries + UInt32(1)

            emit NewSeriesStarted(newCurrentSeries: TopShot.currentSeries)

            return TopShot.currentSeries
        }

        // createSubeditionResource creates new SubeditionMap resource that
        // will be used to mint Moments with Subeditions
        pub fun createSubeditionAdminResource() {
            TopShot.account.save<@SubeditionAdmin>(<- create SubeditionAdmin(), to: TopShot.SubeditionAdminStoragePath())
        }

        // setMomentsSubedition saves which Subedition the Moment belongs to
        //
        // Parameters: nftID: The ID of the NFT
        //             subeditionID: The ID of the Subedition the Moment belongs to
        //             setID: The ID of the Set that the Moment references
        //             playID: The ID of the Play that the Moment references
        //
        pub fun setMomentsSubedition(nftID: UInt64, subeditionID: UInt32, setID: UInt32, playID: UInt32) {
            let subeditionAdmin = TopShot.account.borrow<&SubeditionAdmin>(from: TopShot.SubeditionAdminStoragePath())
                ?? panic("No subedition admin resource in storage")

            subeditionAdmin.setMomentsSubedition(nftID: nftID, subeditionID: subeditionID, setID: setID, playID: playID)
        }

        // createSubedition creates a new Subedition struct
        // and stores it in the Subeditions dictionary in the SubeditionAdmin resource
        //
        // Parameters: name: The name of the Subedition
        //             metadata: A dictionary mapping metadata titles to their data
        //
        // Returns: the ID of the new Subedition object
        //
        pub fun createSubedition(name:String, metadata:{String:String}): UInt32 {
            let subeditionAdmin = TopShot.account.borrow<&SubeditionAdmin>(from: TopShot.SubeditionAdminStoragePath())
                ?? panic("No subedition admin resource in storage")

            return subeditionAdmin.createSubedition(name:name, metadata:metadata)
        }

        // createNewAdmin creates a new Admin resource
        //
        pub fun createNewAdmin(): @Admin {
            return <-create Admin()
        }
    }

    // This is the interface that users can cast their Moment Collection as
    // to allow others to deposit Moments into their Collection. It also allows for reading
    // the IDs of Moments in the Collection.
    pub resource interface MomentCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowMoment(id: UInt64): &TopShot.NFT? {
            // If the result isn't nil, the id of the returned reference
            // should be the same as the argument to the function
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow Moment reference: The ID of the returned reference is incorrect"
            }
        }
    }

    // Collection is a resource that every user who owns NFTs
    // will store in their account to manage their NFTS
    //
    pub resource Collection: MomentCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        // Dictionary of Moment conforming tokens
        // NFT is a resource type with a UInt64 ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init() {
            self.ownedNFTs <- {}
        }

        // withdraw removes an Moment from the Collection and moves it to the caller
        //
        // Parameters: withdrawID: The ID of the NFT
        // that is to be removed from the Collection
        //
        // returns: @NonFungibleToken.NFT the token that was withdrawn
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {

            // Borrow nft and check if locked
            let nft = self.borrowNFT(id: withdrawID)
            if TopShotLocking.isLocked(nftRef: nft) {
                panic("Cannot withdraw: Moment is locked")
            }

            // Remove the nft from the Collection
            let token <- self.ownedNFTs.remove(key: withdrawID)
                ?? panic("Cannot withdraw: Moment does not exist in the collection")

            emit Withdraw(id: token.id, from: self.owner?.address)

            // Return the withdrawn token
            return <-token
        }

        // batchWithdraw withdraws multiple tokens and returns them as a Collection
        //
        // Parameters: ids: An array of IDs to withdraw
        //
        // Returns: @NonFungibleToken.Collection: A collection that contains
        //                                        the withdrawn moments
        //
        pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {
            // Create a new empty Collection
            var batchCollection <- create Collection()

            // Iterate through the ids and withdraw them from the Collection
            for id in ids {
                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))
            }

            // Return the withdrawn tokens
            return <-batchCollection
        }

        // deposit takes a Moment and adds it to the Collections dictionary
        //
        // Paramters: token: the NFT to be deposited in the collection
        //
        pub fun deposit(token: @NonFungibleToken.NFT) {

            // Cast the deposited token as a TopShot NFT to make sure
            // it is the correct type
            let token <- token as! @TopShot.NFT

            // Get the token's ID
            let id = token.id

            // Add the new token to the dictionary
            let oldToken <- self.ownedNFTs[id] <- token

            // Only emit a deposit event if the Collection
            // is in an account's storage
            if self.owner?.address != nil {
                emit Deposit(id: id, to: self.owner?.address)
            }

            // Destroy the empty old token that was "removed"
            destroy oldToken
        }

        // batchDeposit takes a Collection object as an argument
        // and deposits each contained NFT into this Collection
        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {

            // Get an array of the IDs to be deposited
            let keys = tokens.getIDs()

            // Iterate through the keys in the collection and deposit each one
            for key in keys {
                self.deposit(token: <-tokens.withdraw(withdrawID: key))
            }

            // Destroy the empty Collection
            destroy tokens
        }

        // lock takes a token id and a duration in seconds and locks
        // the moment for that duration
        pub fun lock(id: UInt64, duration: UFix64) {
            // Remove the nft from the Collection
            let token <- self.ownedNFTs.remove(key: id)
                ?? panic("Cannot lock: Moment does not exist in the collection")

            // pass the token to the locking contract
            // store it again after it comes back
            let oldToken <- self.ownedNFTs[id] <- TopShotLocking.lockNFT(nft: <- token, duration: duration)

            destroy oldToken
        }

        // batchLock takes an array of token ids and a duration in seconds
        // it iterates through the ids and locks each for the specified duration
        pub fun batchLock(ids: [UInt64], duration: UFix64) {
            // Iterate through the ids and lock them
            for id in ids {
                self.lock(id: id, duration: duration)
            }
        }

        // unlock takes a token id and attempts to unlock it
        // TopShotLocking.unlockNFT contains business logic around unlock eligibility
        pub fun unlock(id: UInt64) {
            // Remove the nft from the Collection
            let token <- self.ownedNFTs.remove(key: id)
                ?? panic("Cannot lock: Moment does not exist in the collection")

            // Pass the token to the TopShotLocking contract then get it back
            // Store it back to the ownedNFTs dictionary
            let oldToken <- self.ownedNFTs[id] <- TopShotLocking.unlockNFT(nft: <- token)

            destroy oldToken
        }

        // batchUnlock takes an array of token ids
        // it iterates through the ids and unlocks each if they are eligible
        pub fun batchUnlock(ids: [UInt64]) {
            // Iterate through the ids and unlocks them
            for id in ids {
                self.unlock(id: id)
            }
        }

        // destroyMoments destroys moments in this collection
        // unlocks the moments if they are locked
        //
        // Parameters: ids: An array of NFT IDs
        // to be destroyed from the Collection
        pub fun destroyMoments(ids: [UInt64]) {
            let topShotLockingAdmin = TopShot.account.borrow<&TopShotLocking.Admin>(from: TopShotLocking.AdminStoragePath())
                ?? panic("No TopShotLocking admin resource in storage")

            for id in ids {
                // Remove the nft from the Collection
                let token <- self.ownedNFTs.remove(key: id)
                    ?? panic("Cannot destroy: Moment does not exist in collection: ".concat(id.toString()))

                // does nothing if the moment is not locked
                topShotLockingAdmin.unlockByID(id: id)

                destroy token
            }
        }

        // getIDs returns an array of the IDs that are in the Collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT Returns a borrowed reference to a Moment in the Collection
        // so that the caller can read its ID
        //
        // Parameters: id: The ID of the NFT to get the reference for
        //
        // Returns: A reference to the NFT
        //
        // Note: This only allows the caller to read the ID of the NFT,
        // not any topshot specific data. Please use borrowMoment to
        // read Moment data.
        //
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        // Safe way to borrow a reference to an NFT that does not panic
        // Also now part of the NonFungibleToken.PublicCollection interface
        //
        // Parameters: id: The ID of the NFT to get the reference for
        //
        // Returns: An optional reference to the desired NFT, will be nil if the passed ID does not exist
        pub fun borrowNFTSafe(id: UInt64): &NonFungibleToken.NFT? {
            if let nftRef = &self.ownedNFTs[id] as &NonFungibleToken.NFT? {
                return nftRef
            }
            return nil
        }

        // borrowMoment returns a borrowed reference to a Moment
        // so that the caller can read data and call methods from it.
        // They can use this to read its setID, playID, serialNumber,
        // or any of the setData or Play data associated with it by
        // getting the setID or playID and reading those fields from
        // the smart contract.
        //
        // Parameters: id: The ID of the NFT to get the reference for
        //
        // Returns: A reference to the NFT
        pub fun borrowMoment(id: UInt64): &TopShot.NFT? {
            if self.ownedNFTs[id] != nil {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &TopShot.NFT
            } else {
                return nil
            }
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let topShotNFT = nft as! &TopShot.NFT
            return topShotNFT as &AnyResource{MetadataViews.Resolver}
        }

        // If a transaction destroys the Collection object,
        // All the NFTs contained within are also destroyed!
        // Much like when Damian Lillard destroys the hopes and
        // dreams of the entire city of Houston.
        //
        destroy() {
            destroy self.ownedNFTs
        }
    }

    // -----------------------------------------------------------------------
    // TopShot contract-level function definitions
    // -----------------------------------------------------------------------

    // createEmptyCollection creates a new, empty Collection object so that
    // a user can store it in their account storage.
    // Once they have a Collection in their storage, they are able to receive
    // Moments in transactions.
    //
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <-create TopShot.Collection()
    }

    // getAllPlays returns all the plays in topshot
    //
    // Returns: An array of all the plays that have been created
    pub fun getAllPlays(): [TopShot.Play] {
        return TopShot.playDatas.values
    }

    // getPlayMetaData returns all the metadata associated with a specific Play
    //
    // Parameters: playID: The id of the Play that is being searched
    //
    // Returns: The metadata as a String to String mapping optional
    pub fun getPlayMetaData(playID: UInt32): {String: String}? {
        return self.playDatas[playID]?.metadata
    }

    // getPlayMetaDataByField returns the metadata associated with a
    //                        specific field of the metadata
    //                        Ex: field: "Team" will return something
    //                        like "Memphis Grizzlies"
    //
    // Parameters: playID: The id of the Play that is being searched
    //             field: The field to search for
    //
    // Returns: The metadata field as a String Optional
    pub fun getPlayMetaDataByField(playID: UInt32, field: String): String? {
        // Don't force a revert if the playID or field is invalid
        if let play = TopShot.playDatas[playID] {
            return play.metadata[field]
        } else {
            return nil
        }
    }

    // getSetData returns the data that the specified Set
    //            is associated with.
    //
    // Parameters: setID: The id of the Set that is being searched
    //
    // Returns: The QuerySetData struct that has all the important information about the set
    pub fun getSetData(setID: UInt32): QuerySetData? {
        if TopShot.sets[setID] == nil {
            return nil
        } else {
            return QuerySetData(setID: setID)
        }
    }

    // getSetName returns the name that the specified Set
    //            is associated with.
    //
    // Parameters: setID: The id of the Set that is being searched
    //
    // Returns: The name of the Set
    pub fun getSetName(setID: UInt32): String? {
        // Don't force a revert if the setID is invalid
        return TopShot.setDatas[setID]?.name
    }

    // getSetSeries returns the series that the specified Set
    //              is associated with.
    //
    // Parameters: setID: The id of the Set that is being searched
    //
    // Returns: The series that the Set belongs to
    pub fun getSetSeries(setID: UInt32): UInt32? {
        // Don't force a revert if the setID is invalid
        return TopShot.setDatas[setID]?.series
    }

    // getSetIDsByName returns the IDs that the specified Set name
    //                 is associated with.
    //
    // Parameters: setName: The name of the Set that is being searched
    //
    // Returns: An array of the IDs of the Set if it exists, or nil if doesn't
    pub fun getSetIDsByName(setName: String): [UInt32]? {
        var setIDs: [UInt32] = []

        // Iterate through all the setDatas and search for the name
        for setData in TopShot.setDatas.values {
            if setName == setData.name {
                // If the name is found, return the ID
                setIDs.append(setData.setID)
            }
        }

        // If the name isn't found, return nil
        // Don't force a revert if the setName is invalid
        if setIDs.length == 0 {
            return nil
        } else {
            return setIDs
        }
    }

    // getPlaysInSet returns the list of Play IDs that are in the Set
    //
    // Parameters: setID: The id of the Set that is being searched
    //
    // Returns: An array of Play IDs
    pub fun getPlaysInSet(setID: UInt32): [UInt32]? {
        // Don't force a revert if the setID is invalid
        return TopShot.sets[setID]?.plays
    }

    // isEditionRetired returns a boolean that indicates if a Set/Play combo
    //                  (otherwise known as an edition) is retired.
    //                  If an edition is retired, it still remains in the Set,
    //                  but Moments can no longer be minted from it.
    //
    // Parameters: setID: The id of the Set that is being searched
    //             playID: The id of the Play that is being searched
    //
    // Returns: Boolean indicating if the edition is retired or not
    pub fun isEditionRetired(setID: UInt32, playID: UInt32): Bool? {

        if let setdata = self.getSetData(setID: setID) {

            // See if the Play is retired from this Set
            let retired = setdata.getRetired()[playID]

            // Return the retired status
            return retired
        } else {

            // If the Set wasn't found, return nil
            return nil
        }
    }

    // isSetLocked returns a boolean that indicates if a Set
    //             is locked. If it's locked,
    //             new Plays can no longer be added to it,
    //             but Moments can still be minted from Plays the set contains.
    //
    // Parameters: setID: The id of the Set that is being searched
    //
    // Returns: Boolean indicating if the Set is locked or not
    pub fun isSetLocked(setID: UInt32): Bool? {
        // Don't force a revert if the setID is invalid
        return TopShot.sets[setID]?.locked
    }

    // getNumMomentsInEdition return the number of Moments that have been
    //                        minted from a certain edition.
    //
    // Parameters: setID: The id of the Set that is being searched
    //             playID: The id of the Play that is being searched
    //
    // Returns: The total number of Moments
    //          that have been minted from an edition
    pub fun getNumMomentsInEdition(setID: UInt32, playID: UInt32): UInt32? {
        if let setdata = self.getSetData(setID: setID) {

            // Read the numMintedPerPlay
            let amount = setdata.getNumberMintedPerPlay()[playID]

            return amount
        } else {
            // If the set wasn't found return nil
            return nil
        }
    }

    // getMomentsSubedition returns the Subedition the Moment belongs to
    //
    // Parameters: nftID: The ID of the NFT
    //
    // returns: UInt32? Subedition's ID if exists
    //
    pub fun getMomentsSubedition(nftID: UInt64):UInt32? {
        let subeditionAdmin = self.account.borrow<&SubeditionAdmin>(from: TopShot.SubeditionAdminStoragePath())
            ?? panic("No subedition admin resource in storage")

        return subeditionAdmin.getMomentsSubedition(nftID: nftID)
    }

    // getAllSubeditions returns all the subeditions in topshot subeditionAdmin resource
    //
    // Returns: An array of all the subeditions that have been created
    pub fun getAllSubeditions():[TopShot.Subedition] {
        let subeditionAdmin = self.account.borrow<&SubeditionAdmin>(from: TopShot.SubeditionAdminStoragePath())
            ?? panic("No subedition admin resource in storage")
        return subeditionAdmin.subeditionDatas.values
    }

    // getSubeditionByID returns the subedition struct entity
    //
    // Parameters: subeditionID: The id of the Subedition that is being searched
    //
    // Returns: The Subedition struct
    pub fun getSubeditionByID(subeditionID: UInt32):TopShot.Subedition {
        let subeditionAdmin = self.account.borrow<&SubeditionAdmin>(from: TopShot.SubeditionAdminStoragePath())
            ?? panic("No subedition admin resource in storage")
        return subeditionAdmin.subeditionDatas[subeditionID]!
    }

    // This script reads the public nextSubeditionID from the SubeditionAdmin resource and
    // returns that number to the caller
    //
    // Returns: UInt32
    // the next number in nextSubeditionID from the SubeditionAdmin resource
    pub fun getNextSubeditionID():UInt32 {
        let subeditionAdmin = self.account.borrow<&SubeditionAdmin>(from: TopShot.SubeditionAdminStoragePath())
            ?? panic("No subedition admin resource in storage")
        return subeditionAdmin.nextSubeditionID
    }
    // SubeditionAdmin is a resource that allows Set to mint Moments with Subeditions
    //
    pub struct Subedition {
        pub let subeditionID: UInt32

        pub let name: String

        pub let metadata: {String: String}

        init(subeditionID: UInt32, name: String, metadata: {String: String}) {
            pre {
                name.length != 0: "New Subedition name cannot be empty"
            }
            self.subeditionID = subeditionID
            self.name = name
            self.metadata = metadata
        }
    }

    pub resource SubeditionAdmin {

        // Map of number of already minted Moments using Subedition.
        // When a new Moment with Subedition is minted, 1 is added to the
        // number in this map by the key, formed by concatinating of
        // SetID, PlayID and SubeditionID
        access(contract) let numberMintedPerSubedition: {String:UInt32}

        // Map of Subedition which the Moment belongs to.
        // This map updates after each minting.
        access(contract) let momentsSubedition: {UInt64:UInt32}

        // The ID that is used to create Subeditions.
        // Every time a Subeditions is created, subeditionID is assigned
        // to the new Subedition's ID and then is incremented by 1.
        access(contract) var nextSubeditionID: UInt32

        // Variable size dictionary of Subedition structs
        access(contract) let subeditionDatas: {UInt32: Subedition}

        // createSubedition creates a new Subedition struct
        // and stores it in the Subeditions dictionary in the SubeditionAdmin resource
        //
        // Parameters: name: The name of the Subedition
        //             metadata: A dictionary mapping metadata titles to their data
        //
        // Returns: the ID of the new Subedition object
        //
        pub fun createSubedition(name:String, metadata:{String:String}): UInt32 {

            let newID = self.nextSubeditionID

            var newSubedition = Subedition(subeditionID: newID, name: name, metadata: metadata)

            self.nextSubeditionID = self.nextSubeditionID + UInt32(1)

            self.subeditionDatas[newID] = newSubedition

            emit SubeditionCreated(subeditionID: newID, name: name, metadata: metadata)

            return newID
        }

        // getMomentsSubedition function that return's wich Subedition the Moment belongs to
        //
        // Parameters: nftID: The ID of the NFT
        //
        // returns: UInt32? Subedition's ID if exists
        //
        pub fun getMomentsSubedition(nftID: UInt64):UInt32? {
           return self.momentsSubedition[nftID]
        }

        // getNumberMintedPerSubedition function that return's
        // the number of Moments that have been minted for this subedition
        // to use as this Moment's serial number
        //
        // Parameters: setID: The ID of the Set Moment will be minted from
        //             playID: The ID of the Play Moment will be minted from
        //             subeditionID: The ID of the Subedition using which moment will be minted
        //
        // returns: UInt32 Number of Moments, already minted for this Subedition
        //
        pub fun getNumberMintedPerSubedition(setID: UInt32, playID: UInt32, subeditionID: UInt32): UInt32 {
           let setPlaySubedition = setID.toString().concat(playID.toString()).concat(subeditionID.toString())
           if !self.numberMintedPerSubedition.containsKey(setPlaySubedition) {
                self.numberMintedPerSubedition.insert(key: setPlaySubedition,UInt32(0))
                return UInt32(0)
           }
           return self.numberMintedPerSubedition[setPlaySubedition]!
        }

        // addToNumberMintedPerSubedition function that increments 1 to the
        // number of Moments that have been minted for this subedition
        //
        // Parameters: setID: The ID of the Set Moment will be minted from
        //             playID: The ID of the Play Moment will be minted from
        //             subeditionID: The ID of the Subedition using which moment will be minted
        //
        //
        pub fun addToNumberMintedPerSubedition(setID: UInt32, playID: UInt32, subeditionID: UInt32) {
           let setPlaySubedition = setID.toString().concat(playID.toString()).concat(subeditionID.toString())

           if !self.numberMintedPerSubedition.containsKey(setPlaySubedition) {
             panic("Could not find specified Subedition!")
           }
           self.numberMintedPerSubedition[setPlaySubedition] = self.numberMintedPerSubedition[setPlaySubedition]! + UInt32(1)
        }


        // setMomentsSubedition saves which Subedition the Moment belongs to
        //
        // Parameters: nftID: The ID of the NFT
        //             subeditionID: The ID of the Subedition the Moment belongs to
        //             setID: The ID of the Set that the Moment references
        //             playID: The ID of the Play that the Moment references
        //
        pub fun setMomentsSubedition(nftID: UInt64, subeditionID: UInt32, setID: UInt32, playID: UInt32){
            pre {
                !self.momentsSubedition.containsKey(nftID) : "Subedition for this moment already exists!"
            }

            self.momentsSubedition.insert(key: nftID, subeditionID)

            emit SubeditionAddedToMoment(momentID: nftID, subeditionID: subeditionID, setID: setID, playID: playID)
        }

        init() {
            self.momentsSubedition = {}
            self.numberMintedPerSubedition = {}
            self.subeditionDatas = {}
            self.nextSubeditionID = 1
        }
    }


    // -----------------------------------------------------------------------
    // TopShot initialization function
    // -----------------------------------------------------------------------
    //
    init() {
        // Initialize contract fields
        self.currentSeries = 0
        self.playDatas = {}
        self.setDatas = {}
        self.sets <- {}
        self.nextPlayID = 1
        self.nextSetID = 1
        self.totalSupply = 0

        // Put a new Collection in storage
        self.account.save<@Collection>(<- create Collection(), to: /storage/MomentCollection)

        // Create a public capability for the Collection
        self.account.link<&{MomentCollectionPublic}>(/public/MomentCollection, target: /storage/MomentCollection)

        // Put the Minter in storage
        self.account.save<@Admin>(<- create Admin(), to: /storage/TopShotAdmin)

        emit ContractInitialized()
    }
}"
-------
"/*
 * Copyright (c) 2021 24Karat. All rights reserved.
 *
 * SPDX-License-Identifier: MIT
 *
 * This file is part of Project: 24karat flow contract (https://github.com/24karat-gld/flow-24karat-contract)
 *
 * This source code is licensed under the MIT License found in the
 * LICENSE file in the root directory of this source tree or at
 * https://opensource.org/licenses/MIT.
 */

import FungibleToken from 0xf233dcee88fe0abe

pub contract EBISU: FungibleToken {
    // TokensInitialized
    //
    // The event that is emitted when the contract is created
    pub event TokensInitialized(initialSupply: UFix64)

    // TokensWithdrawn
    //
    // The event that is emitted when tokens are withdrawn from a Vault
    pub event TokensWithdrawn(amount: UFix64, from: Address?)

    // TokensDeposited
    //
    // The event that is emitted when tokens are deposited to a Vault
    pub event TokensDeposited(amount: UFix64, to: Address?)

    // TokensMinted
    //
    // The event that is emitted when new tokens are minted
    pub event TokensMinted(amount: UFix64)

    // TokensBurned
    //
    // The event that is emitted when tokens are destroyed
    pub event TokensBurned(amount: UFix64)

    // MinterCreated
    //
    // The event that is emitted when a new minter resource is created
    pub event MinterCreated(allowedAmount: UFix64)

    // Named paths
    //
    pub let VaultStoragePath: StoragePath
    pub let ReceiverPublicPath: PublicPath
    pub let BalancePublicPath: PublicPath
    pub let AdminStoragePath: StoragePath

    // Total supply of token in existence
    pub var totalSupply: UFix64

    // Vault
    //
    // Each user stores an instance of only the Vault in their storage
    // The functions in the Vault and governed by the pre and post conditions
    // in FungibleToken when they are called.
    // The checks happen at runtime whenever a function is called.
    //
    // Resources can only be created in the context of the contract that they
    // are defined in, so there is no way for a malicious user to create Vaults
    // out of thin air. A special Minter resource needs to be defined to mint
    // new tokens.
    //
    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {

        // The total balance of this vault
        pub var balance: UFix64

        // initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        // withdraw
        //
        // Function that takes an amount as an argument
        // and withdraws that amount from the Vault.
        //
        // It creates a new temporary Vault that is used to hold
        // the money that is being transferred. It returns the newly
        // created Vault to the context that called so it can be deposited
        // elsewhere.
        //
        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)
            return <-create Vault(balance: amount)
        }

        // deposit
        //
        // Function that takes a Vault object as an argument and adds
        // its balance to the balance of the owners Vault.
        //
        // It is allowed to destroy the sent Vault because the Vault
        // was a temporary holder of the tokens. The Vault's balance has
        // been consumed and therefore can be destroyed.
        //
        pub fun deposit(from: @FungibleToken.Vault) {
            let vault <- from as! @EBISU.Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)
            vault.balance = 0.0
            destroy vault
        }

        destroy() {
            EBISU.totalSupply = EBISU.totalSupply - self.balance
            if(self.balance > 0.0) {
                emit TokensBurned(amount: self.balance)
            }
        }
    }

    // createEmptyVault
    //
    // Function that creates a new Vault with a balance of zero
    // and returns it to the calling context. A user must call this function
    // and store the returned Vault in their storage in order to allow their
    // account to be able to receive deposits of this token type.
    //
    pub fun createEmptyVault(): @Vault {
        return <-create Vault(balance: 0.0)
    }

    pub resource Administrator {

        // createNewMinter
        //
        // Function that creates and returns a new minter resource
        //
        pub fun createNewMinter(allowedAmount: UFix64): @Minter {
            emit MinterCreated(allowedAmount: allowedAmount)
            return <-create Minter(allowedAmount: allowedAmount)
        }
    }

    // Minter
    //
    // Resource object that token admin accounts can hold to mint new tokens.
    //
    pub resource Minter {

        // The amount of tokens that the minter is allowed to mint
        pub var allowedAmount: UFix64

        // mintTokens
        //
        // Function that mints new tokens, adds them to the total supply,
        // and returns them to the calling context.
        //
        pub fun mintTokens(amount: UFix64): @EBISU.Vault {
            pre {
                amount > 0.0: "Amount minted must be greater than zero"
                amount <= self.allowedAmount: "Amount minted must be less than the allowed amount"
            }
            EBISU.totalSupply = EBISU.totalSupply + amount
            self.allowedAmount = self.allowedAmount - amount
            emit TokensMinted(amount: amount)
            return <-create Vault(balance: amount)
        }

        init(allowedAmount: UFix64) {
            self.allowedAmount = allowedAmount
        }
    }

    init() {
        // Set our named paths.
        self.VaultStoragePath = /storage/EBISU24KaratVault
        self.ReceiverPublicPath = /public/EBISU24KaratReceiver
        self.BalancePublicPath = /public/EBISU24KaratBalance
        self.AdminStoragePath = /storage/EBISU24KaratAdmin

        // Initialize contract state.
        self.totalSupply = 0.0

        // Create the one true Admin object and deposit it into the conttract account.
        let admin <- create Administrator()
        self.account.save(<-admin, to: self.AdminStoragePath)

        // Emit an event that shows that the contract was initialized.
        emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
 "
-------
"import AlphaNFTV1 from 0xe600ffd2adb0c6d3
import AlphaPackV1 from 0xe600ffd2adb0c6d3
import FungibleToken from 0xf233dcee88fe0abe

pub contract AlphaAdminV1 {

    // Admin
    // the admin resource is defined so that only the admin account
    // can have this resource. It possesses the ability to open packs
    // given a user's Pack Collection and Card Collection reference.
    // It can also create a new pack type and mint Packs.
    //
    pub resource Admin {

        pub fun createTemplate(maxSupply:UInt64, immutableData:{String: AnyStruct}){
            AlphaNFTV1.createTemplate(maxSupply:maxSupply, immutableData:immutableData)
        }

        pub fun openPack(templateInfo: {String: UInt64}, account: Address){
            AlphaNFTV1.mintNFT(templateInfo:templateInfo, account:account)
        }
        // createAdmin
        // only an admin can ever create
        // a new Admin resource
        //
        pub fun createAdmin(): @Admin {
            return <- create Admin()
        }

        init() {

        }
    }

    init() {
        self.account.save(<- create Admin(), to: /storage/AlphaAdminV1)
    }
}"
-------
"// CREATED BY: Touchstone (https://touchstone.city/), a platform crafted by your best friends at Emerald City DAO (https://ecdao.org/).
// STATEMENT: This contract promises to keep the 5% royalty off of primary sales and 2.5% off of secondary sales to Emerald City DAO or risk permanent suspension from participation in the DAO and its tools.

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import FlowToken from 0x1654653399040a61
import MintVerifiers from 0x7a696d6136e1dce2
import FUSD from 0x3c5959b568896393
import EmeraldPass from 0x6a07dbeb03167a13

pub contract TouchstoneDigiQuackz: NonFungibleToken {

	// Collection Information
	access(self) let collectionInfo: {String: AnyStruct}

	// Contract Information
	pub var nextEditionId: UInt64
	pub var nextMetadataId: UInt64
	pub var totalSupply: UInt64

	// Events
	pub event ContractInitialized()
	pub event Withdraw(id: UInt64, from: Address?)
	pub event Deposit(id: UInt64, to: Address?)
	pub event TouchstonePurchase(id: UInt64, recipient: Address, metadataId: UInt64, name: String, description: String, image: MetadataViews.IPFSFile, price: UFix64)
	pub event Minted(id: UInt64, recipient: Address, metadataId: UInt64)
	pub event MintBatch(metadataIds: [UInt64], recipients: [Address])

	// Paths
	pub let CollectionStoragePath: StoragePath
	pub let CollectionPublicPath: PublicPath
	pub let CollectionPrivatePath: PrivatePath
	pub let AdministratorStoragePath: StoragePath

	// Maps metadataId of NFT to NFTMetadata
	access(account) let metadatas: {UInt64: NFTMetadata}

	// Maps the metadataId of an NFT to the primary buyer
	access(account) let primaryBuyers: {Address: {UInt64: [UInt64]}}

	access(account) let nftStorage: @{Address: {UInt64: NFT}}

	pub struct NFTMetadata {
		pub let metadataId: UInt64
		pub let name: String
		pub let description: String
		// The main image of the NFT
		pub let image: MetadataViews.IPFSFile
		// An optional thumbnail that can go along with it
		// for easier loading
		pub let thumbnail: MetadataViews.IPFSFile?
		// If price is nil, defaults to the collection price
		pub let price: UFix64?
		pub var extra: {String: AnyStruct}
		pub let supply: UInt64
		pub let purchasers: {UInt64: Address}

		access(account) fun purchased(serial: UInt64, buyer: Address) {
			self.purchasers[serial] = buyer
		}

		init(_name: String, _description: String, _image: MetadataViews.IPFSFile, _thumbnail: MetadataViews.IPFSFile?, _price: UFix64?, _extra: {String: AnyStruct}, _supply: UInt64) {
			self.metadataId = TouchstoneDigiQuackz.nextMetadataId
			self.name = _name
			self.description = _description
			self.image = _image
			self.thumbnail = _thumbnail
			self.price = _price
			self.extra = _extra
			self.supply = _supply
			self.purchasers = {}
		}
	}

	pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
		// The 'id' is the same as the 'uuid'
		pub let id: UInt64
		// The 'metadataId' is what maps this NFT to its 'NFTMetadata'
		pub let metadataId: UInt64
		pub let serial: UInt64

		pub fun getMetadata(): NFTMetadata {
			return TouchstoneDigiQuackz.getNFTMetadata(self.metadataId)!
		}

		pub fun getViews(): [Type] {
			return [
				Type<MetadataViews.Display>(),
				Type<MetadataViews.ExternalURL>(),
				Type<MetadataViews.NFTCollectionData>(),
				Type<MetadataViews.NFTCollectionDisplay>(),
				Type<MetadataViews.Royalties>(),
				Type<MetadataViews.Serial>(),
				Type<MetadataViews.Traits>(),
				Type<MetadataViews.NFTView>()
			]
		}

		pub fun resolveView(_ view: Type): AnyStruct? {
			switch view {
				case Type<MetadataViews.Display>():
					let metadata = self.getMetadata()
					return MetadataViews.Display(
						name: metadata.name,
						description: metadata.description,
						thumbnail: metadata.thumbnail ?? metadata.image
					)
				case Type<MetadataViews.NFTCollectionData>():
					return MetadataViews.NFTCollectionData(
						storagePath: TouchstoneDigiQuackz.CollectionStoragePath,
						publicPath: TouchstoneDigiQuackz.CollectionPublicPath,
						providerPath: TouchstoneDigiQuackz.CollectionPrivatePath,
						publicCollection: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
						publicLinkedType: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
						providerLinkedType: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, NonFungibleToken.Provider}>(),
						createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
								return <- TouchstoneDigiQuackz.createEmptyCollection()
						})
					)
				case Type<MetadataViews.ExternalURL>():
          return MetadataViews.ExternalURL("https://touchstone.city/discover/".concat(self.owner!.address.toString()).concat("/TouchstoneDigiQuackz"))
				case Type<MetadataViews.NFTCollectionDisplay>():
					let squareMedia = MetadataViews.Media(
						file: TouchstoneDigiQuackz.getCollectionAttribute(key: "image") as! MetadataViews.IPFSFile,
						mediaType: "image"
					)

					// If a banner image exists, use it
					// Otherwise, default to the main square image
					var bannerMedia: MetadataViews.Media? = nil
					if let bannerImage = TouchstoneDigiQuackz.getOptionalCollectionAttribute(key: "bannerImage") as! MetadataViews.IPFSFile? {
						bannerMedia = MetadataViews.Media(
							file: bannerImage,
							mediaType: "image"
						)
					}
					return MetadataViews.NFTCollectionDisplay(
						name: TouchstoneDigiQuackz.getCollectionAttribute(key: "name") as! String,
						description: TouchstoneDigiQuackz.getCollectionAttribute(key: "description") as! String,
						externalURL: MetadataViews.ExternalURL("https://touchstone.city/discover/".concat(self.owner!.address.toString()).concat("/TouchstoneDigiQuackz")),
						squareImage: squareMedia,
						bannerImage: bannerMedia ?? squareMedia,
						socials: TouchstoneDigiQuackz.getCollectionAttribute(key: "socials") as! {String: MetadataViews.ExternalURL}
					)
				case Type<MetadataViews.Royalties>():
					return MetadataViews.Royalties([
						// This is for Emerald City in favor of producing Touchstone, a free platform for our users. Failure to keep this in the contract may result in permanent suspension from Emerald City.
						MetadataViews.Royalty(
							recepient: getAccount(0x5643fd47a29770e7).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),
							cut: 0.025, // 2.5% royalty on secondary sales
							description: "Emerald City DAO receives a 2.5% royalty from secondary sales because this collection was created using Touchstone (https://touchstone.city/), a tool for creating your own NFT collections, crafted by Emerald City DAO."
						)
					])
				case Type<MetadataViews.Serial>():
					return MetadataViews.Serial(
						self.serial
					)
				case Type<MetadataViews.Traits>():
					return MetadataViews.dictToTraits(dict: self.getMetadata().extra, excludedNames: nil)
				case Type<MetadataViews.NFTView>():
					return MetadataViews.NFTView(
						id: self.id,
						uuid: self.uuid,
						display: self.resolveView(Type<MetadataViews.Display>()) as! MetadataViews.Display?,
						externalURL: self.resolveView(Type<MetadataViews.ExternalURL>()) as! MetadataViews.ExternalURL?,
						collectionData: self.resolveView(Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?,
						collectionDisplay: self.resolveView(Type<MetadataViews.NFTCollectionDisplay>()) as! MetadataViews.NFTCollectionDisplay?,
						royalties: self.resolveView(Type<MetadataViews.Royalties>()) as! MetadataViews.Royalties?,
						traits: self.resolveView(Type<MetadataViews.Traits>()) as! MetadataViews.Traits?
					)
			}
			return nil
		}

		init(_metadataId: UInt64, _serial: UInt64, _recipient: Address) {
			pre {
				TouchstoneDigiQuackz.metadatas[_metadataId] != nil:
					"This NFT does not exist yet."
				_serial < TouchstoneDigiQuackz.getNFTMetadata(_metadataId)!.supply:
					"This serial does not exist for this metadataId."
				!TouchstoneDigiQuackz.getNFTMetadata(_metadataId)!.purchasers.containsKey(_serial):
					"This serial has already been purchased."
			}
			self.id = self.uuid
			self.metadataId = _metadataId
			self.serial = _serial

			// Update the buyers list so we keep track of who is purchasing
			if let buyersRef = &TouchstoneDigiQuackz.primaryBuyers[_recipient] as &{UInt64: [UInt64]}? {
				if let metadataIdMap = &buyersRef[_metadataId] as &[UInt64]? {
					metadataIdMap.append(_serial)
				} else {
					buyersRef[_metadataId] = [_serial]
				}
			} else {
				TouchstoneDigiQuackz.primaryBuyers[_recipient] = {_metadataId: [_serial]}
			}

			// Update who bought this serial inside NFTMetadata so it cannot be purchased again.
			let metadataRef = (&TouchstoneDigiQuackz.metadatas[_metadataId] as &NFTMetadata?)!
			metadataRef.purchased(serial: _serial, buyer: _recipient)

			TouchstoneDigiQuackz.totalSupply = TouchstoneDigiQuackz.totalSupply + 1
			emit Minted(id: self.id, recipient: _recipient, metadataId: _metadataId)
		}
	}

	pub resource Collection: NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
		// dictionary of NFT conforming tokens
		// NFT is a resource type with an 'UInt64' ID field
		pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

		// withdraw removes an NFT from the collection and moves it to the caller
		pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
			let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

			emit Withdraw(id: token.id, from: self.owner?.address)

			return <-token
		}

		// deposit takes a NFT and adds it to the collections dictionary
		// and adds the ID to the id array
		pub fun deposit(token: @NonFungibleToken.NFT) {
			let token <- token as! @NFT

			let id: UInt64 = token.id

			// add the new token to the dictionary
			self.ownedNFTs[id] <-! token

			emit Deposit(id: id, to: self.owner?.address)
		}

		// getIDs returns an array of the IDs that are in the collection
		pub fun getIDs(): [UInt64] {
			return self.ownedNFTs.keys
		}

		// borrowNFT gets a reference to an NFT in the collection
		// so that the caller can read its metadata and call its methods
		pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
			return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
		}

		pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
			let token = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
			let nft = token as! &NFT
			return nft as &AnyResource{MetadataViews.Resolver}
		}

		pub fun claim() {
			if let storage = &TouchstoneDigiQuackz.nftStorage[self.owner!.address] as &{UInt64: NFT}? {
				for id in storage.keys {
					self.deposit(token: <- storage.remove(key: id)!)
				}
			}
		}

		init () {
			self.ownedNFTs <- {}
		}

		destroy() {
			destroy self.ownedNFTs
		}
	}

	// A function to mint NFTs.
	// You can only call this function if minting
	// is currently active.
	pub fun mintNFT(metadataId: UInt64, recipient: &{NonFungibleToken.Receiver}, payment: @FlowToken.Vault, serial: UInt64): UInt64 {
		pre {
			self.canMint(): "Minting is currently closed by the Administrator!"
			payment.balance == self.getPriceOfNFT(metadataId):
				"Payment does not match the price. You passed in ".concat(payment.balance.toString()).concat(" but this NFT costs ").concat(self.getPriceOfNFT(metadataId)!.toString())
		}
		let price: UFix64 = self.getPriceOfNFT(metadataId)!

		// Confirm recipient passes all verifiers
		for verifier in self.getMintVerifiers() {
			let params = {"minter": recipient.owner!.address}
			if let error = verifier.verify(params) {
				panic(error)
			}
		}

		// Handle Emerald City DAO royalty (5%)
		let EmeraldCityTreasury = getAccount(0x5643fd47a29770e7).getCapability(/public/flowTokenReceiver)
								.borrow<&FlowToken.Vault{FungibleToken.Receiver}>()!
		let emeraldCityCut: UFix64 = 0.05 * price

		// Handle royalty to user that was configured upon creation
		if let royalty = TouchstoneDigiQuackz.getOptionalCollectionAttribute(key: "royalty") as! MetadataViews.Royalty? {
			royalty.receiver.borrow()!.deposit(from: <- payment.withdraw(amount: price * royalty.cut))
		}

		EmeraldCityTreasury.deposit(from: <- payment.withdraw(amount: emeraldCityCut))

		// Give the rest to the collection owner
		let paymentRecipient = self.account.getCapability(/public/flowTokenReceiver)
								.borrow<&FlowToken.Vault{FungibleToken.Receiver}>()!
		paymentRecipient.deposit(from: <- payment)

		// Mint the nft
		let nft <- create NFT(_metadataId: metadataId, _serial: serial, _recipient: recipient.owner!.address)
		let nftId: UInt64 = nft.id
		let metadata = self.getNFTMetadata(metadataId)!
		self.collectionInfo["profit"] = (self.getCollectionAttribute(key: "profit") as! UFix64) + price

		// Emit event
		emit TouchstonePurchase(id: nftId, recipient: recipient.owner!.address, metadataId: metadataId, name: metadata.name, description: metadata.description, image: metadata.image, price: price)

		// Deposit nft
		recipient.deposit(token: <- nft)

		return nftId
	}

	pub resource Administrator {
		pub fun createNFTMetadata(name: String, description: String, imagePath: String, thumbnailPath: String?, ipfsCID: String, price: UFix64?, extra: {String: AnyStruct}, supply: UInt64) {
			TouchstoneDigiQuackz.metadatas[TouchstoneDigiQuackz.nextMetadataId] = NFTMetadata(
				_name: name,
				_description: description,
				_image: MetadataViews.IPFSFile(
					cid: ipfsCID,
					path: imagePath
				),
				_thumbnail: thumbnailPath == nil ? nil : MetadataViews.IPFSFile(cid: ipfsCID, path: thumbnailPath),
				_price: price,
				_extra: extra,
				_supply: supply
			)
			TouchstoneDigiQuackz.nextMetadataId = TouchstoneDigiQuackz.nextMetadataId + 1
		}

		// mintNFT mints a new NFT and deposits
		// it in the recipients collection
		pub fun mintNFT(metadataId: UInt64, serial: UInt64, recipient: Address) {
			pre {
				EmeraldPass.isActive(user: TouchstoneDigiQuackz.account.address): "You must have an active Emerald Pass subscription to airdrop NFTs. You can purchase Emerald Pass at https://pass.ecdao.org/"
			}
			let nft <- create NFT(_metadataId: metadataId, _serial: serial, _recipient: recipient)
			if let recipientCollection = getAccount(recipient).getCapability(TouchstoneDigiQuackz.CollectionPublicPath).borrow<&TouchstoneDigiQuackz.Collection{NonFungibleToken.CollectionPublic}>() {
				recipientCollection.deposit(token: <- nft)
			} else {
				if let storage = &TouchstoneDigiQuackz.nftStorage[recipient] as &{UInt64: NFT}? {
					storage[nft.id] <-! nft
				} else {
					TouchstoneDigiQuackz.nftStorage[recipient] <-! {nft.id: <- nft}
				}
			}
		}

		pub fun mintBatch(metadataIds: [UInt64], serials: [UInt64], recipients: [Address]) {
			pre {
				metadataIds.length == recipients.length: "You need to pass in an equal number of metadataIds and recipients."
			}
			var i = 0
			while i < metadataIds.length {
				self.mintNFT(metadataId: metadataIds[i], serial: serials[i], recipient: recipients[i])
				i = i + 1
			}

			emit MintBatch(metadataIds: metadataIds, recipients: recipients)
		}

		// create a new Administrator resource
		pub fun createAdmin(): @Administrator {
			return <- create Administrator()
		}

		// change piece of collection info
		pub fun changeField(key: String, value: AnyStruct) {
			TouchstoneDigiQuackz.collectionInfo[key] = value
		}
	}

	// public function that anyone can call to create a new empty collection
	pub fun createEmptyCollection(): @NonFungibleToken.Collection {
		return <- create Collection()
	}

	// Get information about a NFTMetadata
	pub fun getNFTMetadata(_ metadataId: UInt64): NFTMetadata? {
		return self.metadatas[metadataId]
	}

	pub fun getNFTMetadatas(): {UInt64: NFTMetadata} {
		return self.metadatas
	}

	pub fun getPrimaryBuyers(): {Address: {UInt64: [UInt64]}} {
		return self.primaryBuyers
	}

	pub fun getCollectionInfo(): {String: AnyStruct} {
		let collectionInfo = self.collectionInfo
		collectionInfo["metadatas"] = self.metadatas
		collectionInfo["primaryBuyers"] = self.primaryBuyers
		collectionInfo["totalSupply"] = self.totalSupply
		collectionInfo["nextMetadataId"] = self.nextMetadataId
		collectionInfo["version"] = 1
		return collectionInfo
	}

	pub fun getCollectionAttribute(key: String): AnyStruct {
		return self.collectionInfo[key] ?? panic(key.concat(" is not an attribute in this collection."))
	}

	pub fun getOptionalCollectionAttribute(key: String): AnyStruct? {
		return self.collectionInfo[key]
	}

	pub fun getMintVerifiers(): [{MintVerifiers.IVerifier}] {
		return self.getCollectionAttribute(key: "mintVerifiers") as! [{MintVerifiers.IVerifier}]
	}

	pub fun canMint(): Bool {
		return self.getCollectionAttribute(key: "minting") as! Bool
	}

	// Returns nil if an NFT with this metadataId doesn't exist
	pub fun getPriceOfNFT(_ metadataId: UInt64): UFix64? {
		if let metadata: TouchstoneDigiQuackz.NFTMetadata = self.getNFTMetadata(metadataId) {
			let defaultPrice: UFix64 = self.getCollectionAttribute(key: "price") as! UFix64
			if self.getCollectionAttribute(key: "lotteryBuying") as! Bool {
				return defaultPrice
			}
			return metadata.price ?? defaultPrice
		}
		// If the metadataId doesn't exist
		return nil
	}

	// Returns an mapping of `id` to NFTMetadata
	// for the NFTs a user can claim
	pub fun getClaimableNFTs(user: Address): {UInt64: NFTMetadata} {
		let answer: {UInt64: NFTMetadata} = {}
		if let storage = &TouchstoneDigiQuackz.nftStorage[user] as &{UInt64: NFT}? {
			for id in storage.keys {
				let nftRef = (&storage[id] as &NFT?)!
				answer[id] = self.getNFTMetadata(nftRef.metadataId)
			}
		}
		return answer
	}

	init(
		_name: String,
		_description: String,
		_imagePath: String,
		_bannerImagePath: String?,
		_minting: Bool,
		_royalty: MetadataViews.Royalty?,
		_defaultPrice: UFix64,
		_paymentType: String,
		_ipfsCID: String,
		_lotteryBuying: Bool,
		_socials: {String: MetadataViews.ExternalURL},
		_mintVerifiers: [{MintVerifiers.IVerifier}]
	) {
		// Collection Info
		self.collectionInfo = {}
		self.collectionInfo["name"] = _name
		self.collectionInfo["description"] = _description
		self.collectionInfo["image"] = MetadataViews.IPFSFile(
			cid: _ipfsCID,
			path: _imagePath
		)
		if let bannerImagePath = _bannerImagePath {
			self.collectionInfo["bannerImage"] = MetadataViews.IPFSFile(
				cid: _ipfsCID,
				path: _bannerImagePath
			)
		}
		self.collectionInfo["ipfsCID"] = _ipfsCID
		self.collectionInfo["socials"] = _socials
		self.collectionInfo["minting"] = _minting
		self.collectionInfo["lotteryBuying"] = _lotteryBuying
		if let royalty = _royalty {
			assert(royalty.receiver.check(), message: "The passed in royalty receiver is not valid. The royalty account must set up the intended payment token.")
			assert(royalty.cut <= 0.95, message: "The royalty cut cannot be bigger than 95% because 5% goes to Emerald City treasury for primary sales.")
			self.collectionInfo["royalty"] = royalty
		}
		self.collectionInfo["price"] = _defaultPrice
		self.collectionInfo["paymentType"] = _paymentType
		self.collectionInfo["dateCreated"] = getCurrentBlock().timestamp
		self.collectionInfo["mintVerifiers"] = _mintVerifiers
		self.collectionInfo["profit"] = 0.0

		self.nextEditionId = 0
		self.nextMetadataId = 0
		self.totalSupply = 0
		self.metadatas = {}
		self.primaryBuyers = {}
		self.nftStorage <- {}

		// Set the named paths
		// We include the user's address in the paths.
		// This is to prevent clashing with existing
		// Collection paths in the ecosystem.
		self.CollectionStoragePath = /storage/TouchstoneDigiQuackzCollection_0x213c401adf5c8854
		self.CollectionPublicPath = /public/TouchstoneDigiQuackzCollection_0x213c401adf5c8854
		self.CollectionPrivatePath = /private/TouchstoneDigiQuackzCollection_0x213c401adf5c8854
		self.AdministratorStoragePath = /storage/TouchstoneDigiQuackzAdministrator_0x213c401adf5c8854

		// Create a Collection resource and save it to storage
		let collection <- create Collection()
		self.account.save(<- collection, to: self.CollectionStoragePath)

		// create a public capability for the collection
		self.account.link<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(
			self.CollectionPublicPath,
			target: self.CollectionStoragePath
		)

		// Create a Administrator resource and save it to storage
		let administrator <- create Administrator()
		self.account.save(<- administrator, to: self.AdministratorStoragePath)

		emit ContractInitialized()
	}
}
 "
-------
"// CREATED BY: Touchstone (https://touchstone.city/), a platform crafted by your best friends at Emerald City DAO (https://ecdao.org/).
// STATEMENT: This contract promises to keep the 5% royalty off of primary sales and 2.5% off of secondary sales to Emerald City DAO or risk permanent suspension from participation in the DAO and its tools.

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import FlowToken from 0x1654653399040a61
import MintVerifiers from 0x7a696d6136e1dce2
import FUSD from 0x3c5959b568896393
import EmeraldPass from 0x6a07dbeb03167a13

pub contract TouchstoneSPACETOURAGENCY: NonFungibleToken {

	// Collection Information
	access(self) let collectionInfo: {String: AnyStruct}

	// Contract Information
	pub var nextEditionId: UInt64
	pub var nextMetadataId: UInt64
	pub var totalSupply: UInt64

	// Events
	pub event ContractInitialized()
	pub event Withdraw(id: UInt64, from: Address?)
	pub event Deposit(id: UInt64, to: Address?)
	pub event TouchstonePurchase(id: UInt64, recipient: Address, metadataId: UInt64, name: String, description: String, image: MetadataViews.IPFSFile, price: UFix64)
	pub event Minted(id: UInt64, recipient: Address, metadataId: UInt64)
	pub event MintBatch(metadataIds: [UInt64], recipients: [Address])

	// Paths
	pub let CollectionStoragePath: StoragePath
	pub let CollectionPublicPath: PublicPath
	pub let CollectionPrivatePath: PrivatePath
	pub let AdministratorStoragePath: StoragePath

	// Maps metadataId of NFT to NFTMetadata
	access(account) let metadatas: {UInt64: NFTMetadata}

	// Maps the metadataId of an NFT to the primary buyer
	access(account) let primaryBuyers: {Address: {UInt64: [UInt64]}}

	access(account) let nftStorage: @{Address: {UInt64: NFT}}

	pub struct NFTMetadata {
		pub let metadataId: UInt64
		pub let name: String
		pub let description: String
		// The main image of the NFT
		pub let image: MetadataViews.IPFSFile
		// An optional thumbnail that can go along with it
		// for easier loading
		pub let thumbnail: MetadataViews.IPFSFile?
		// If price is nil, defaults to the collection price
		pub let price: UFix64?
		pub var extra: {String: AnyStruct}
		pub let supply: UInt64
		pub let purchasers: {UInt64: Address}

		access(account) fun purchased(serial: UInt64, buyer: Address) {
			self.purchasers[serial] = buyer
		}

		init(_name: String, _description: String, _image: MetadataViews.IPFSFile, _thumbnail: MetadataViews.IPFSFile?, _price: UFix64?, _extra: {String: AnyStruct}, _supply: UInt64) {
			self.metadataId = TouchstoneSPACETOURAGENCY.nextMetadataId
			self.name = _name
			self.description = _description
			self.image = _image
			self.thumbnail = _thumbnail
			self.price = _price
			self.extra = _extra
			self.supply = _supply
			self.purchasers = {}
		}
	}

	pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
		// The 'id' is the same as the 'uuid'
		pub let id: UInt64
		// The 'metadataId' is what maps this NFT to its 'NFTMetadata'
		pub let metadataId: UInt64
		pub let serial: UInt64

		pub fun getMetadata(): NFTMetadata {
			return TouchstoneSPACETOURAGENCY.getNFTMetadata(self.metadataId)!
		}

		pub fun getViews(): [Type] {
			return [
				Type<MetadataViews.Display>(),
				Type<MetadataViews.ExternalURL>(),
				Type<MetadataViews.NFTCollectionData>(),
				Type<MetadataViews.NFTCollectionDisplay>(),
				Type<MetadataViews.Royalties>(),
				Type<MetadataViews.Serial>(),
				Type<MetadataViews.Traits>(),
				Type<MetadataViews.NFTView>()
			]
		}

		pub fun resolveView(_ view: Type): AnyStruct? {
			switch view {
				case Type<MetadataViews.Display>():
					let metadata = self.getMetadata()
					return MetadataViews.Display(
						name: metadata.name,
						description: metadata.description,
						thumbnail: metadata.thumbnail ?? metadata.image
					)
				case Type<MetadataViews.NFTCollectionData>():
					return MetadataViews.NFTCollectionData(
						storagePath: TouchstoneSPACETOURAGENCY.CollectionStoragePath,
						publicPath: TouchstoneSPACETOURAGENCY.CollectionPublicPath,
						providerPath: TouchstoneSPACETOURAGENCY.CollectionPrivatePath,
						publicCollection: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
						publicLinkedType: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
						providerLinkedType: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, NonFungibleToken.Provider}>(),
						createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
								return <- TouchstoneSPACETOURAGENCY.createEmptyCollection()
						})
					)
				case Type<MetadataViews.ExternalURL>():
          return MetadataViews.ExternalURL("https://touchstone.city/discover/".concat(self.owner!.address.toString()).concat("/TouchstoneSPACETOURAGENCY"))
				case Type<MetadataViews.NFTCollectionDisplay>():
					let squareMedia = MetadataViews.Media(
						file: TouchstoneSPACETOURAGENCY.getCollectionAttribute(key: "image") as! MetadataViews.IPFSFile,
						mediaType: "image"
					)

					// If a banner image exists, use it
					// Otherwise, default to the main square image
					var bannerMedia: MetadataViews.Media? = nil
					if let bannerImage = TouchstoneSPACETOURAGENCY.getOptionalCollectionAttribute(key: "bannerImage") as! MetadataViews.IPFSFile? {
						bannerMedia = MetadataViews.Media(
							file: bannerImage,
							mediaType: "image"
						)
					}
					return MetadataViews.NFTCollectionDisplay(
						name: TouchstoneSPACETOURAGENCY.getCollectionAttribute(key: "name") as! String,
						description: TouchstoneSPACETOURAGENCY.getCollectionAttribute(key: "description") as! String,
						externalURL: MetadataViews.ExternalURL("https://touchstone.city/discover/".concat(self.owner!.address.toString()).concat("/TouchstoneSPACETOURAGENCY")),
						squareImage: squareMedia,
						bannerImage: bannerMedia ?? squareMedia,
						socials: TouchstoneSPACETOURAGENCY.getCollectionAttribute(key: "socials") as! {String: MetadataViews.ExternalURL}
					)
				case Type<MetadataViews.Royalties>():
					return MetadataViews.Royalties([
						// This is for Emerald City in favor of producing Touchstone, a free platform for our users. Failure to keep this in the contract may result in permanent suspension from Emerald City.
						MetadataViews.Royalty(
							recepient: getAccount(0x5643fd47a29770e7).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),
							cut: 0.025, // 2.5% royalty on secondary sales
							description: "Emerald City DAO receives a 2.5% royalty from secondary sales because this collection was created using Touchstone (https://touchstone.city/), a tool for creating your own NFT collections, crafted by Emerald City DAO."
						)
					])
				case Type<MetadataViews.Serial>():
					return MetadataViews.Serial(
						self.serial
					)
				case Type<MetadataViews.Traits>():
					return MetadataViews.dictToTraits(dict: self.getMetadata().extra, excludedNames: nil)
				case Type<MetadataViews.NFTView>():
					return MetadataViews.NFTView(
						id: self.id,
						uuid: self.uuid,
						display: self.resolveView(Type<MetadataViews.Display>()) as! MetadataViews.Display?,
						externalURL: self.resolveView(Type<MetadataViews.ExternalURL>()) as! MetadataViews.ExternalURL?,
						collectionData: self.resolveView(Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?,
						collectionDisplay: self.resolveView(Type<MetadataViews.NFTCollectionDisplay>()) as! MetadataViews.NFTCollectionDisplay?,
						royalties: self.resolveView(Type<MetadataViews.Royalties>()) as! MetadataViews.Royalties?,
						traits: self.resolveView(Type<MetadataViews.Traits>()) as! MetadataViews.Traits?
					)
			}
			return nil
		}

		init(_metadataId: UInt64, _serial: UInt64, _recipient: Address) {
			pre {
				TouchstoneSPACETOURAGENCY.metadatas[_metadataId] != nil:
					"This NFT does not exist yet."
				_serial < TouchstoneSPACETOURAGENCY.getNFTMetadata(_metadataId)!.supply:
					"This serial does not exist for this metadataId."
				!TouchstoneSPACETOURAGENCY.getNFTMetadata(_metadataId)!.purchasers.containsKey(_serial):
					"This serial has already been purchased."
			}
			self.id = self.uuid
			self.metadataId = _metadataId
			self.serial = _serial

			// Update the buyers list so we keep track of who is purchasing
			if let buyersRef = &TouchstoneSPACETOURAGENCY.primaryBuyers[_recipient] as &{UInt64: [UInt64]}? {
				if let metadataIdMap = &buyersRef[_metadataId] as &[UInt64]? {
					metadataIdMap.append(_serial)
				} else {
					buyersRef[_metadataId] = [_serial]
				}
			} else {
				TouchstoneSPACETOURAGENCY.primaryBuyers[_recipient] = {_metadataId: [_serial]}
			}

			// Update who bought this serial inside NFTMetadata so it cannot be purchased again.
			let metadataRef = (&TouchstoneSPACETOURAGENCY.metadatas[_metadataId] as &NFTMetadata?)!
			metadataRef.purchased(serial: _serial, buyer: _recipient)

			TouchstoneSPACETOURAGENCY.totalSupply = TouchstoneSPACETOURAGENCY.totalSupply + 1
			emit Minted(id: self.id, recipient: _recipient, metadataId: _metadataId)
		}
	}

	pub resource Collection: NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
		// dictionary of NFT conforming tokens
		// NFT is a resource type with an 'UInt64' ID field
		pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

		// withdraw removes an NFT from the collection and moves it to the caller
		pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
			let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

			emit Withdraw(id: token.id, from: self.owner?.address)

			return <-token
		}

		// deposit takes a NFT and adds it to the collections dictionary
		// and adds the ID to the id array
		pub fun deposit(token: @NonFungibleToken.NFT) {
			let token <- token as! @NFT

			let id: UInt64 = token.id

			// add the new token to the dictionary
			self.ownedNFTs[id] <-! token

			emit Deposit(id: id, to: self.owner?.address)
		}

		// getIDs returns an array of the IDs that are in the collection
		pub fun getIDs(): [UInt64] {
			return self.ownedNFTs.keys
		}

		// borrowNFT gets a reference to an NFT in the collection
		// so that the caller can read its metadata and call its methods
		pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
			return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
		}

		pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
			let token = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
			let nft = token as! &NFT
			return nft as &AnyResource{MetadataViews.Resolver}
		}

		pub fun claim() {
			if let storage = &TouchstoneSPACETOURAGENCY.nftStorage[self.owner!.address] as &{UInt64: NFT}? {
				for id in storage.keys {
					self.deposit(token: <- storage.remove(key: id)!)
				}
			}
		}

		init () {
			self.ownedNFTs <- {}
		}

		destroy() {
			destroy self.ownedNFTs
		}
	}

	// A function to mint NFTs.
	// You can only call this function if minting
	// is currently active.
	pub fun mintNFT(metadataId: UInt64, recipient: &{NonFungibleToken.Receiver}, payment: @FlowToken.Vault, serial: UInt64): UInt64 {
		pre {
			self.canMint(): "Minting is currently closed by the Administrator!"
			payment.balance == self.getPriceOfNFT(metadataId):
				"Payment does not match the price. You passed in ".concat(payment.balance.toString()).concat(" but this NFT costs ").concat(self.getPriceOfNFT(metadataId)!.toString())
		}
		let price: UFix64 = self.getPriceOfNFT(metadataId)!

		// Confirm recipient passes all verifiers
		for verifier in self.getMintVerifiers() {
			let params = {"minter": recipient.owner!.address}
			if let error = verifier.verify(params) {
				panic(error)
			}
		}

		// Handle Emerald City DAO royalty (5%)
		let EmeraldCityTreasury = getAccount(0x5643fd47a29770e7).getCapability(/public/flowTokenReceiver)
								.borrow<&FlowToken.Vault{FungibleToken.Receiver}>()!
		let emeraldCityCut: UFix64 = 0.05 * price

		// Handle royalty to user that was configured upon creation
		if let royalty = TouchstoneSPACETOURAGENCY.getOptionalCollectionAttribute(key: "royalty") as! MetadataViews.Royalty? {
			royalty.receiver.borrow()!.deposit(from: <- payment.withdraw(amount: price * royalty.cut))
		}

		EmeraldCityTreasury.deposit(from: <- payment.withdraw(amount: emeraldCityCut))

		// Give the rest to the collection owner
		let paymentRecipient = self.account.getCapability(/public/flowTokenReceiver)
								.borrow<&FlowToken.Vault{FungibleToken.Receiver}>()!
		paymentRecipient.deposit(from: <- payment)

		// Mint the nft
		let nft <- create NFT(_metadataId: metadataId, _serial: serial, _recipient: recipient.owner!.address)
		let nftId: UInt64 = nft.id
		let metadata = self.getNFTMetadata(metadataId)!
		self.collectionInfo["profit"] = (self.getCollectionAttribute(key: "profit") as! UFix64) + price

		// Emit event
		emit TouchstonePurchase(id: nftId, recipient: recipient.owner!.address, metadataId: metadataId, name: metadata.name, description: metadata.description, image: metadata.image, price: price)

		// Deposit nft
		recipient.deposit(token: <- nft)

		return nftId
	}

	pub resource Administrator {
		pub fun createNFTMetadata(name: String, description: String, imagePath: String, thumbnailPath: String?, ipfsCID: String, price: UFix64?, extra: {String: AnyStruct}, supply: UInt64) {
			TouchstoneSPACETOURAGENCY.metadatas[TouchstoneSPACETOURAGENCY.nextMetadataId] = NFTMetadata(
				_name: name,
				_description: description,
				_image: MetadataViews.IPFSFile(
					cid: ipfsCID,
					path: imagePath
				),
				_thumbnail: thumbnailPath == nil ? nil : MetadataViews.IPFSFile(cid: ipfsCID, path: thumbnailPath),
				_price: price,
				_extra: extra,
				_supply: supply
			)
			TouchstoneSPACETOURAGENCY.nextMetadataId = TouchstoneSPACETOURAGENCY.nextMetadataId + 1
		}

		// mintNFT mints a new NFT and deposits
		// it in the recipients collection
		pub fun mintNFT(metadataId: UInt64, serial: UInt64, recipient: Address) {
			pre {
				EmeraldPass.isActive(user: TouchstoneSPACETOURAGENCY.account.address): "You must have an active Emerald Pass subscription to airdrop NFTs. You can purchase Emerald Pass at https://pass.ecdao.org/"
			}
			let nft <- create NFT(_metadataId: metadataId, _serial: serial, _recipient: recipient)
			if let recipientCollection = getAccount(recipient).getCapability(TouchstoneSPACETOURAGENCY.CollectionPublicPath).borrow<&TouchstoneSPACETOURAGENCY.Collection{NonFungibleToken.CollectionPublic}>() {
				recipientCollection.deposit(token: <- nft)
			} else {
				if let storage = &TouchstoneSPACETOURAGENCY.nftStorage[recipient] as &{UInt64: NFT}? {
					storage[nft.id] <-! nft
				} else {
					TouchstoneSPACETOURAGENCY.nftStorage[recipient] <-! {nft.id: <- nft}
				}
			}
		}

		pub fun mintBatch(metadataIds: [UInt64], serials: [UInt64], recipients: [Address]) {
			pre {
				metadataIds.length == recipients.length: "You need to pass in an equal number of metadataIds and recipients."
			}
			var i = 0
			while i < metadataIds.length {
				self.mintNFT(metadataId: metadataIds[i], serial: serials[i], recipient: recipients[i])
				i = i + 1
			}

			emit MintBatch(metadataIds: metadataIds, recipients: recipients)
		}

		// create a new Administrator resource
		pub fun createAdmin(): @Administrator {
			return <- create Administrator()
		}

		// change piece of collection info
		pub fun changeField(key: String, value: AnyStruct) {
			TouchstoneSPACETOURAGENCY.collectionInfo[key] = value
		}
	}

	// public function that anyone can call to create a new empty collection
	pub fun createEmptyCollection(): @NonFungibleToken.Collection {
		return <- create Collection()
	}

	// Get information about a NFTMetadata
	pub fun getNFTMetadata(_ metadataId: UInt64): NFTMetadata? {
		return self.metadatas[metadataId]
	}

	pub fun getNFTMetadatas(): {UInt64: NFTMetadata} {
		return self.metadatas
	}

	pub fun getPrimaryBuyers(): {Address: {UInt64: [UInt64]}} {
		return self.primaryBuyers
	}

	pub fun getCollectionInfo(): {String: AnyStruct} {
		let collectionInfo = self.collectionInfo
		collectionInfo["metadatas"] = self.metadatas
		collectionInfo["primaryBuyers"] = self.primaryBuyers
		collectionInfo["totalSupply"] = self.totalSupply
		collectionInfo["nextMetadataId"] = self.nextMetadataId
		collectionInfo["version"] = 1
		return collectionInfo
	}

	pub fun getCollectionAttribute(key: String): AnyStruct {
		return self.collectionInfo[key] ?? panic(key.concat(" is not an attribute in this collection."))
	}

	pub fun getOptionalCollectionAttribute(key: String): AnyStruct? {
		return self.collectionInfo[key]
	}

	pub fun getMintVerifiers(): [{MintVerifiers.IVerifier}] {
		return self.getCollectionAttribute(key: "mintVerifiers") as! [{MintVerifiers.IVerifier}]
	}

	pub fun canMint(): Bool {
		return self.getCollectionAttribute(key: "minting") as! Bool
	}

	// Returns nil if an NFT with this metadataId doesn't exist
	pub fun getPriceOfNFT(_ metadataId: UInt64): UFix64? {
		if let metadata: TouchstoneSPACETOURAGENCY.NFTMetadata = self.getNFTMetadata(metadataId) {
			let defaultPrice: UFix64 = self.getCollectionAttribute(key: "price") as! UFix64
			if self.getCollectionAttribute(key: "lotteryBuying") as! Bool {
				return defaultPrice
			}
			return metadata.price ?? defaultPrice
		}
		// If the metadataId doesn't exist
		return nil
	}

	// Returns an mapping of `id` to NFTMetadata
	// for the NFTs a user can claim
	pub fun getClaimableNFTs(user: Address): {UInt64: NFTMetadata} {
		let answer: {UInt64: NFTMetadata} = {}
		if let storage = &TouchstoneSPACETOURAGENCY.nftStorage[user] as &{UInt64: NFT}? {
			for id in storage.keys {
				let nftRef = (&storage[id] as &NFT?)!
				answer[id] = self.getNFTMetadata(nftRef.metadataId)
			}
		}
		return answer
	}

	init(
		_name: String,
		_description: String,
		_imagePath: String,
		_bannerImagePath: String?,
		_minting: Bool,
		_royalty: MetadataViews.Royalty?,
		_defaultPrice: UFix64,
		_paymentType: String,
		_ipfsCID: String,
		_lotteryBuying: Bool,
		_socials: {String: MetadataViews.ExternalURL},
		_mintVerifiers: [{MintVerifiers.IVerifier}]
	) {
		// Collection Info
		self.collectionInfo = {}
		self.collectionInfo["name"] = _name
		self.collectionInfo["description"] = _description
		self.collectionInfo["image"] = MetadataViews.IPFSFile(
			cid: _ipfsCID,
			path: _imagePath
		)
		if let bannerImagePath = _bannerImagePath {
			self.collectionInfo["bannerImage"] = MetadataViews.IPFSFile(
				cid: _ipfsCID,
				path: _bannerImagePath
			)
		}
		self.collectionInfo["ipfsCID"] = _ipfsCID
		self.collectionInfo["socials"] = _socials
		self.collectionInfo["minting"] = _minting
		self.collectionInfo["lotteryBuying"] = _lotteryBuying
		if let royalty = _royalty {
			assert(royalty.receiver.check(), message: "The passed in royalty receiver is not valid. The royalty account must set up the intended payment token.")
			assert(royalty.cut <= 0.95, message: "The royalty cut cannot be bigger than 95% because 5% goes to Emerald City treasury for primary sales.")
			self.collectionInfo["royalty"] = royalty
		}
		self.collectionInfo["price"] = _defaultPrice
		self.collectionInfo["paymentType"] = _paymentType
		self.collectionInfo["dateCreated"] = getCurrentBlock().timestamp
		self.collectionInfo["mintVerifiers"] = _mintVerifiers
		self.collectionInfo["profit"] = 0.0

		self.nextEditionId = 0
		self.nextMetadataId = 0
		self.totalSupply = 0
		self.metadatas = {}
		self.primaryBuyers = {}
		self.nftStorage <- {}

		// Set the named paths
		// We include the user's address in the paths.
		// This is to prevent clashing with existing
		// Collection paths in the ecosystem.
		self.CollectionStoragePath = /storage/TouchstoneSPACETOURAGENCYCollection_0xdbf940eb504a0c27
		self.CollectionPublicPath = /public/TouchstoneSPACETOURAGENCYCollection_0xdbf940eb504a0c27
		self.CollectionPrivatePath = /private/TouchstoneSPACETOURAGENCYCollection_0xdbf940eb504a0c27
		self.AdministratorStoragePath = /storage/TouchstoneSPACETOURAGENCYAdministrator_0xdbf940eb504a0c27

		// Create a Collection resource and save it to storage
		let collection <- create Collection()
		self.account.save(<- collection, to: self.CollectionStoragePath)

		// create a public capability for the collection
		self.account.link<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(
			self.CollectionPublicPath,
			target: self.CollectionStoragePath
		)

		// Create a Administrator resource and save it to storage
		let administrator <- create Administrator()
		self.account.save(<- administrator, to: self.AdministratorStoragePath)

		emit ContractInitialized()
	}
}
 "
-------
"
  import FungibleToken from 0xf233dcee88fe0abe

   access(all) contract ChainLinkFlowToken: FungibleToken {
      pub var totalSupply: UFix64

      /// TokensInitialized
      ///
      /// The event that is emitted when the contract is created
      pub event TokensInitialized(initialSupply: UFix64)

      /// TokensWithdrawn
      ///
      /// The event that is emitted when tokens are withdrawn from a Vault
      pub event TokensWithdrawn(amount: UFix64, from: Address?)

      /// TokensDeposited
      ///
      /// The event that is emitted when tokens are deposited to a Vault
      pub event TokensDeposited(amount: UFix64, to: Address?)

      /// TokensMinted
      ///
      /// The event that is emitted when new tokens are minted
      pub event TokensMinted(amount: UFix64)

      pub let TokenVaultStoragePath: StoragePath
      pub let TokenVaultPublicPath: PublicPath
      pub let TokenMinterStoragePath: StoragePath

      pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {
          pub var balance: UFix64

          init(balance: UFix64) {
              self.balance = balance
          }

          pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
              self.balance = self.balance - amount
              emit TokensWithdrawn(amount: amount, from: self.owner?.address)
              return <- create Vault(balance: amount)
          }

          pub fun deposit(from: @FungibleToken.Vault) {
              let vault <- from as! @ChainLinkFlowToken.Vault
              self.balance = self.balance + vault.balance
              emit TokensDeposited(amount: vault.balance, to: self.owner?.address)
              vault.balance = 0.0
              destroy vault // Make sure we get rid of the vault
          }

          destroy() {
              ChainLinkFlowToken.totalSupply = ChainLinkFlowToken.totalSupply - self.balance
          }
      }

      pub fun createEmptyVault(): @FungibleToken.Vault {
          return <- create Vault(balance: 0.0)
      }

      access(contract) fun initialMint(initialMintValue: UFix64): @FungibleToken.Vault {
          return <- create Vault(balance: initialMintValue)
      }

      pub resource Minter {
          pub fun mintTokens(amount: UFix64): @FungibleToken.Vault {
          pre {
                  amount > 0.0: "Amount minted must be greater than zero"
              }
              ChainLinkFlowToken.totalSupply = ChainLinkFlowToken.totalSupply + amount
              return <- create Vault(balance:amount)
          }

      }

      init() {
          self.totalSupply = 100.00
          self.TokenVaultStoragePath = /storage/ChainLinkFlowTokenVault
          self.TokenVaultPublicPath = /public/ChainLinkFlowTokenVault
          self.TokenMinterStoragePath = /storage/ChainLinkFlowTokenMinter

          self.account.save(<- create Minter(), to: ChainLinkFlowToken.TokenMinterStoragePath)

         //
         // Create an Empty Vault for the Minter
         //
          self.account.save(<- ChainLinkFlowToken.initialMint(initialMintValue: self.totalSupply), to: ChainLinkFlowToken.TokenVaultStoragePath)
          self.account.link<&ChainLinkFlowToken.Vault{FungibleToken.Balance, FungibleToken.Receiver}>(ChainLinkFlowToken.TokenVaultPublicPath, target: ChainLinkFlowToken.TokenVaultStoragePath)
      }
   }

      "
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract TestingNFT : NonFungibleToken {

    pub var totalSupply: UInt64

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath
    pub let MinterPublicPath: PublicPath
    //pub var CollectionPrivatePath: PrivatePath
    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event Mint(id: UInt64, creator: Address, metadata: {String:String})
    pub event Destroy(id: UInt64)

    // We use dict to store raw metadata
    pub resource interface RawMetadata {
        pub fun getRawMetadata(): {String: String}
    }

    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver, RawMetadata {
        pub let id: UInt64
        pub let creator: Address
        access(self) let metadata: {String:String}

        init(
            id: UInt64,
            creator: Address,
            metadata: {String: String}
        ) {
            self.id = id
            self.creator = creator
            self.metadata = metadata
        }

       pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.metadata["name"]!,
                        description: self.metadata["description"]!,
                        thumbnail: MetadataViews.HTTPFile(
                            url: self.metadata["thumbnail"]!
                        )
                    )
            }

            return nil
        }

        pub fun getRawMetadata(): {String: String} {
            return self.metadata
        }

        destroy() {
            emit Destroy(id: self.id)
        }
    }

    pub resource interface TestingNFTCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowTestingNFT(id: UInt64): &TestingNFT.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow NFT reference: the ID of the returned reference is incorrect"
            }
        }
    }

    pub resource Collection: TestingNFTCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {

        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        // withdraw removes an NFT from the collection and moves it to the caller
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        // deposit takes a NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @TestingNFT.NFT

            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        // getIDs returns an array of the IDs that are in the collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT gets a reference to an NFT in the collection
        // so that the caller can read its metadata and call its methods
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowTestingNFT(id: UInt64): &TestingNFT.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorized reference to allow downcasting
                let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT?
                return ref as! &TestingNFT.NFT?
            }

            return nil
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let mlNFT = nft as! &TestingNFT.NFT
            return mlNFT
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    // public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    // Resource that an admin or something similar would own to be
    // able to mint new NFTs
    //
    pub resource NFTMinter {

        // mintNFT mints a new NFT with a new ID
        // and deposit it in the recipients collection using their collection reference
        pub fun mintNFT(
            recipient: &{NonFungibleToken.CollectionPublic},
            metadata: {String: String}
        ): &NonFungibleToken.NFT {

            let creator = self.owner!.address
            // create a new NFT
            var newNFT <- create NFT(
                id: TestingNFT.totalSupply,
                creator: creator,
                metadata: metadata
            )

            let tokenRef = &newNFT as &NonFungibleToken.NFT
            // deposit it in the recipient's account using their reference
            recipient.deposit(token: <-newNFT)

            TestingNFT.totalSupply = TestingNFT.totalSupply + 1

            emit Mint(id: tokenRef.id, creator: creator, metadata: metadata)

            return tokenRef
        }
    }

    init() {
        // Initialize the total supply
        self.totalSupply = 0

        // Set the named paths
        self.CollectionStoragePath = /storage/MatrixMarketTestingNFTCollection
        self.CollectionPublicPath = /public/MatrixMarketTestingNFTCollection
        self.MinterStoragePath = /storage/MatrixMarketTestingNFTMinter
        self.MinterPublicPath = /public/MatrixMarketTestingNFTMinter

        // Create a Collection resource and save it to storage
        let collection <- create Collection()
        self.account.save(<-collection, to: self.CollectionStoragePath)

        // create a public capability for the collection
        self.account.link<&TestingNFT.Collection{NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, TestingNFT.TestingNFTCollectionPublic, MetadataViews.ResolverCollection}>(
            self.CollectionPublicPath,
            target: self.CollectionStoragePath
        )

        // Create a Minter resource and save it to storage
        let minter <- create NFTMinter()
        self.account.save(<-minter, to: self.MinterStoragePath)

        emit ContractInitialized()
    }
}
"
-------
"//  SPDX-License-Identifier: UNLICENSED
//
//
import NonFungibleToken from 0x1d7e57aa55817448
import Anique from 0xe2e1689b53e92a82

pub contract SGKCLDR_destro246: NonFungibleToken, Anique {
    // -----------------------------------------------------------------------
    // SGKCLDR_destro246 contract Events
    // -----------------------------------------------------------------------

    // Events for Contract-Related actions
    //
    // Emitted when the SGKCLDR_destro246 contract is created
    pub event ContractInitialized()

    // Events for Item-Related actions
    //
    // Emitted when a new Item struct is created
    pub event ItemCreated(id: UInt32, metadata: {String:String})

    // Events for Collectible-Related actions
    //
    // Emitted when an CollectibleData NFT is minted
    pub event CollectibleMinted(collectibleID: UInt64, itemID: UInt32, serialNumber: UInt32)
    // Emitted when an CollectibleData NFT is destroyed
    pub event CollectibleDestroyed(collectibleID: UInt64)

    // events for Collection-related actions
    //
    // Emitted when an CollectibleData is withdrawn from a Collection
    pub event Withdraw(id: UInt64, from: Address?)
    // Emitted when an CollectibleData is deposited into a Collection
    pub event Deposit(id: UInt64, to: Address?)

    // paths
    pub let collectionStoragePath: StoragePath
    pub let collectionPublicPath: PublicPath
    pub let collectionPrivatePath: PrivatePath
    pub let adminStoragePath: StoragePath
    pub let saleCollectionStoragePath: StoragePath
    pub let saleCollectionPublicPath: PublicPath

    // -----------------------------------------------------------------------
    // SGKCLDR_destro246 contract-level fields.
    // These contain actual values that are stored in the smart contract.
    // -----------------------------------------------------------------------

    // fields for Item-related
    //
    // variable size dictionary of Item resources
    access(self) var items: @{UInt32: Item}

    // The ID that is used to create Items.
    pub var nextItemID: UInt32

    // fields for Collectible-related
    //
    // Total number of CollectibleData NFTs that have been minted ever.
    pub var totalSupply: UInt64

    // -----------------------------------------------------------------------
    // SGKCLDR_destro246 contract-level Composite Type definitions
    // -----------------------------------------------------------------------

    // The structure that represents Item
    // each digital content which SGKCLDR_destro246 deal with on Flow
    //
    pub struct ItemData {

        pub let itemID: UInt32

        pub let metadata: {String: String}

        init(itemID: UInt32) {
            let item = (&SGKCLDR_destro246.items[itemID] as &Item?)!

            self.itemID = item.itemID
            self.metadata = item.metadata
        }
   }

    // Item is a resource type that contains the functions to mint Collectibles.
    //
    // It is stored in a private field in the contract so that
    // the admin resource can call its methods and that there can be
    // public getters for some of its fields
    //
    // The admin can mint Collectibles that refer from Item.
    pub resource Item {

        // unique ID for the Item
        pub let itemID: UInt32

        // Stores all the metadata about the item as a string mapping
        // This is not the long term way NFT metadata will be stored. It's a temporary
        // construct while we figure out a better way to do metadata.
        //
        pub let metadata: {String: String}

        // The number of Collectibles that have been minted per Item.
        access(contract) var numberMintedPerItem: UInt32

        init(metadata: {String: String}) {
            pre {
                metadata.length != 0: "New Item metadata cannot be empty"
            }
            self.itemID = SGKCLDR_destro246.nextItemID
            self.metadata = metadata
            self.numberMintedPerItem = 0

            // increment the nextItemID so that it isn't used again
            SGKCLDR_destro246.nextItemID = SGKCLDR_destro246.nextItemID + 1

            emit ItemCreated(id: self.itemID, metadata: metadata)
        }

        // mintCollectible mints a new Collectible and returns the newly minted Collectible
        //
        // Returns: The NFT that was minted
        //
        pub fun mintCollectible(): @NFT {
            // get the number of Collectibles that have been minted for this Item
            // to use as this Collectible's serial number
            let numInItem = self.numberMintedPerItem

            // mint the new Collectible
            let newCollectible: @NFT <- create NFT(serialNumber: numInItem + 1,
                                              itemID: self.itemID)

            // Increment the count of Collectibles minted for this Item
            self.numberMintedPerItem = numInItem + 1

            return <-newCollectible
        }

        // batchMintCollectible mints an arbitrary quantity of Collectibles
        // and returns them as a Collection
        //
        // Parameters: itemID: the ID of the Item that the Collectibles are minted for
        //             quantity: The quantity of Collectibles to be minted
        //
        // Returns: Collection object that contains all the Collectibles that were minted
        //
        pub fun batchMintCollectible(quantity: UInt64): @Collection {
            let newCollection <- create Collection()

            var i: UInt64 = 0
            while i < quantity {
                newCollection.deposit(token: <-self.mintCollectible())
                i = i + 1
            }

            return <-newCollection
        }

        // Returns: the number of Collectibles
        pub fun getNumberMinted(): UInt32 {
            return self.numberMintedPerItem
        }
    }

    // The structure holds metadata of an Collectible
    pub struct CollectibleData {
        // The ID of the Item that the Collectible references
        pub let itemID: UInt32

        // The place in the Item that this Collectible was minted
        pub let serialNumber: UInt32

        init(itemID: UInt32, serialNumber: UInt32) {
            self.itemID = itemID
            self.serialNumber = serialNumber
        }
    }

    // The resource that represents the CollectibleData NFTs
    //
    pub resource NFT: NonFungibleToken.INFT, Anique.INFT {

        // Global unique collectibleData ID
        pub let id: UInt64

        // Struct of Collectible metadata
        pub let data: CollectibleData

        init(serialNumber: UInt32, itemID: UInt32) {
            // Increment the global Collectible IDs
            SGKCLDR_destro246.totalSupply = SGKCLDR_destro246.totalSupply + 1

            // set id
            self.id = SGKCLDR_destro246.totalSupply

            // Set the metadata struct
            self.data = CollectibleData(itemID: itemID, serialNumber: serialNumber)

            emit CollectibleMinted(collectibleID: self.id, itemID: itemID, serialNumber: self.data.serialNumber)
        }

        destroy() {
            emit CollectibleDestroyed(collectibleID: self.id)
        }
    }

    // interface that represents SGKCLDR_destro246 collections to public
    // extends of NonFungibleToken.CollectionPublic
    pub resource interface CollectionPublic {

        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT

        // deposit multi tokens
        pub fun batchDeposit(tokens: @Anique.Collection)

        // contains NFT
        pub fun contains(id: UInt64): Bool

        // borrow NFT as SGKCLDR_destro246 token
        pub fun borrowSGKCLDR_destro246Collectible(id: UInt64): auth &NFT
    }

    // Collection is a resource that every user who owns NFTs
    // will store in their account to manage their NFTs
    //
    pub resource Collection: CollectionPublic, NonFungibleToken.Receiver, NonFungibleToken.Provider, NonFungibleToken.CollectionPublic {
        // Dictionary of CollectibleData conforming tokens
        // NFT is a resource type with a UInt64 ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init() {
            self.ownedNFTs <- {}
        }

        // withdraw removes a Collectible from the Collection and moves it to the caller
        //
        // Parameters: withdrawID: The ID of the NFT
        // that is to be removed from the Collection
        //
        // returns: @NonFungibleToken.NFT the token that was withdrawn
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {

            // Remove the nft from the Collection
            let token <- self.ownedNFTs.remove(key: withdrawID)
                ?? panic("Cannot withdraw: Collectible does not exist in the collection")

            emit Withdraw(id: token.id, from: self.owner?.address)

            // Return the withdrawn token
            return <- token
        }

        // batchWithdraw withdraws multiple tokens and returns them as a Collection
        //
        // Parameters: collectibleIds: An array of IDs to withdraw
        //
        // Returns: @NonFungibleToken.Collection: A collection that contains
        //                                        the withdrawn collectibles
        //
        pub fun batchWithdraw(collectibleIds: [UInt64]): @Anique.Collection {
            // Create a new empty Collection
            var batchCollection <- create Collection()

            // Iterate through the collectibleIds and withdraw them from the Collection
            for collectibleID in collectibleIds {
                batchCollection.deposit(token: <-self.withdraw(withdrawID: collectibleID))
            }

            // Return the withdrawn tokens
            return <-batchCollection
        }

        // deposit takes a Collectible and adds it to the Collections dictionary
        //
        // Parameters: token: the NFT to be deposited in the collection
        //
        pub fun deposit(token: @NonFungibleToken.NFT) {

            // Cast the deposited token as an SGKCLDR_destro246 NFT to make sure
            // it is the correct type
            let token <- token as! @SGKCLDR_destro246.NFT

            // Get the token's ID
            let id = token.id

            // Add the new token to the dictionary
            let oldToken <- self.ownedNFTs[id] <- token

            // Only emit a deposit event if the Collection
            // is in an account's storage
            if self.owner?.address != nil {
                emit Deposit(id: id, to: self.owner?.address)
            }

            // Destroy the empty old token that was "removed"
            destroy oldToken
        }

        // batchDeposit takes a Collection object as an argument
        // and deposits each contained NFT into this Collection
        pub fun batchDeposit(tokens: @Anique.Collection) {

            // Get an array of the IDs to be deposited
            let keys = tokens.getIDs()

            // Iterate through the keys in the collection and deposit each one
            for key in keys {
                self.deposit(token: <-tokens.withdraw(withdrawID: key))
            }

            // Destroy the empty Collection
            destroy tokens
        }

        // getIDs returns an array of the IDs that are in the Collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // contains returns whether ID is in the Collection
        pub fun contains(id: UInt64): Bool {
            return self.ownedNFTs[id] != nil
        }

        // borrowNFT Returns a borrowed reference to a Collectible in the Collection
        // so that the caller can read its ID
        //
        // Parameters: id: The ID of the NFT to get the reference for
        //
        // Returns: A reference to the NFT
        //
        // Note: This only allows the caller to read the ID of the NFT,
        // not any SGKCLDR_destro246 specific data. Please use borrowCollectible to
        // read Collectible data.
        //
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowAniqueNFT(id: UInt64): auth &Anique.NFT {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            return nft as! auth &Anique.NFT
        }

        // borrowSGKCLDR_destro246Collectible returns a borrowed reference
        // to an SGKCLDR_destro246 Collectible
        pub fun borrowSGKCLDR_destro246Collectible(id: UInt64): auth &NFT {
            pre {
                self.ownedNFTs[id] != nil: "NFT does not exist in the collection!"
            }
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            return nft as! auth &NFT
        }

        // If a transaction destroys the Collection object,
        // All the NFTs contained within are also destroyed!
        //
        destroy() {
            destroy self.ownedNFTs
        }
    }

    // Admin is a special authorization resource that
    // allows the owner to perform important functions to modify the
    // various aspects of the Items, CollectibleDatas, etc.
    //
    pub resource Admin {

        // createItem creates a new Item struct
        // and stores it in the Items dictionary field in the SGKCLDR_destro246 smart contract
        //
        // Parameters: metadata: A dictionary mapping metadata titles to their data
        //                       example: {"Title": "Excellent Anime", "Author": "John Smith"}
        //
        // Returns: the ID of the new Item object
        //
        pub fun createItem(metadata: {String: String}): UInt32 {
            // Create the new Item
            var newItem <- create Item(metadata: metadata)
            let itemId = newItem.itemID

            // Store it in the contract storage
            SGKCLDR_destro246.items[newItem.itemID] <-! newItem

            return itemId
        }

        // borrowItem returns a reference to a Item in the SGKCLDR_destro246
        // contract so that the admin can call methods on it
        //
        // Parameters: itemID: The ID of the Item that you want to
        // get a reference to
        //
        // Returns: A reference to the Item with all of the fields
        // and methods exposed
        //
        pub fun borrowItem(itemID: UInt32): &Item {
            pre {
                SGKCLDR_destro246.items[itemID] != nil: "Cannot borrow Item: The Item doesn't exist"
            }

            return (&SGKCLDR_destro246.items[itemID] as &Item?)!
        }

        // createNewAdmin creates a new Admin resource
        //
        pub fun createNewAdmin(): @Admin {
            return <-create Admin()
        }
    }

    // -----------------------------------------------------------------------
    // SGKCLDR_destro246 contract-level function definitions
    // -----------------------------------------------------------------------

    // createEmptyCollection creates a new, empty Collection object so that
    // a user can store it in their account storage.
    // Once they have a Collection in their storage, they are able to receive
    // Collectibles in transactions.
    //
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <-create SGKCLDR_destro246.Collection()
    }

    // getNumCollectiblesInItem return the number of Collectibles that have been
    //                        minted from a certain Item.
    //
    // Parameters: itemID: The id of the Item that is being searched
    //
    // Returns: The total number of Collectibles
    //          that have been minted from a Item
    pub fun getNumCollectiblesInItem(itemID: UInt32): UInt32 {
        let item = (&SGKCLDR_destro246.items[itemID] as &Item?)!
        return item.numberMintedPerItem
    }

    // -----------------------------------------------------------------------
    // SGKCLDR_destro246 initialization function
    // -----------------------------------------------------------------------
    //
    init() {
        // Initialize contract fields
        self.items <- {}
        self.nextItemID = 1
        self.totalSupply = 0

        self.collectionStoragePath     = /storage/SGKCLDR_destro246Collection
        self.collectionPublicPath      =  /public/SGKCLDR_destro246Collection
        self.collectionPrivatePath     = /private/SGKCLDR_destro246Collection
        self.adminStoragePath          = /storage/SGKCLDR_destro246Admin
        self.saleCollectionStoragePath = /storage/SGKCLDR_destro246SaleCollection
        self.saleCollectionPublicPath  =  /public/SGKCLDR_destro246SaleCollection

        // Put a new Collection in storage
        self.account.save<@Collection>(<- create Collection(), to: self.collectionStoragePath)

        // Create a public capability for the Collection
        self.account.link<&{CollectionPublic}>(self.collectionPublicPath, target: self.collectionStoragePath)

        // Put the Admin in storage
        self.account.save<@Admin>(<- create Admin(), to: self.adminStoragePath)

        emit ContractInitialized()
    }
}
"
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract SPIN : NonFungibleToken {

    pub var totalSupply: UInt64

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath
    pub let MinterPublicPath: PublicPath
    //pub var CollectionPrivatePath: PrivatePath
    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event Mint(id: UInt64, creator: Address, metadata: {String:String})
    pub event Destroy(id: UInt64)

    // We use dict to store raw metadata
    pub resource interface RawMetadata {
        pub fun getRawMetadata(): {String: String}
    }

    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver, RawMetadata {
        pub let id: UInt64
        pub let creator: Address
        access(self) let metadata: {String:String}

        init(
            id: UInt64,
            creator: Address,
            metadata: {String: String}
        ) {
            self.id = id
            self.creator = creator
            self.metadata = metadata
        }

       pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.metadata["name"]!,
                        description: self.metadata["description"]!,
                        thumbnail: MetadataViews.HTTPFile(
                            url: self.metadata["thumbnail"]!
                        )
                    )
            }

            return nil
        }

        pub fun getRawMetadata(): {String: String} {
            return self.metadata
        }

        destroy() {
            emit Destroy(id: self.id)
        }
    }

    pub resource interface SPINCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowSPIN(id: UInt64): &SPIN.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow NFT reference: the ID of the returned reference is incorrect"
            }
        }
    }

    pub resource Collection: SPINCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {

        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        // withdraw removes an NFT from the collection and moves it to the caller
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        // deposit takes a NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @SPIN.NFT

            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        // getIDs returns an array of the IDs that are in the collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT gets a reference to an NFT in the collection
        // so that the caller can read its metadata and call its methods
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowSPIN(id: UInt64): &SPIN.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorized reference to allow downcasting
                let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT?
                return ref as! &SPIN.NFT?
            }

            return nil
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let mlNFT = nft as! &SPIN.NFT
            return mlNFT
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    // public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    // Resource that an admin or something similar would own to be
    // able to mint new NFTs
    //
    pub resource NFTMinter {

        // mintNFT mints a new NFT with a new ID
        // and deposit it in the recipients collection using their collection reference
        pub fun mintNFT(
            recipient: &{NonFungibleToken.CollectionPublic},
            metadata: {String: String}
        ): &NonFungibleToken.NFT {

            let creator = self.owner!.address
            // create a new NFT
            var newNFT <- create NFT(
                id: SPIN.totalSupply,
                creator: creator,
                metadata: metadata
            )

            let tokenRef = &newNFT as &NonFungibleToken.NFT
            // deposit it in the recipient's account using their reference
            recipient.deposit(token: <-newNFT)

            SPIN.totalSupply = SPIN.totalSupply + 1

            emit Mint(id: tokenRef.id, creator: creator, metadata: metadata)

            return tokenRef
        }
    }

    init() {
        // Initialize the total supply
        self.totalSupply = 0

        // Set the named paths
        self.CollectionStoragePath = /storage/MatrixMarketSPINCollection
        self.CollectionPublicPath = /public/MatrixMarketSPINCollection
        self.MinterStoragePath = /storage/MatrixMarketSPINMinter
        self.MinterPublicPath = /public/MatrixMarketSPINMinter

        // Create a Collection resource and save it to storage
        let collection <- create Collection()
        self.account.save(<-collection, to: self.CollectionStoragePath)

        // create a public capability for the collection
        self.account.link<&SPIN.Collection{NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, SPIN.SPINCollectionPublic, MetadataViews.ResolverCollection}>(
            self.CollectionPublicPath,
            target: self.CollectionStoragePath
        )

        // Create a Minter resource and save it to storage
        let minter <- create NFTMinter()
        self.account.save(<-minter, to: self.MinterStoragePath)

        emit ContractInitialized()
    }
}
"
-------
"
  import FungibleToken from 0xf233dcee88fe0abe

   access(all) contract PeaceToken: FungibleToken {
      pub var totalSupply: UFix64

      /// TokensInitialized
      ///
      /// The event that is emitted when the contract is created
      pub event TokensInitialized(initialSupply: UFix64)

      /// TokensWithdrawn
      ///
      /// The event that is emitted when tokens are withdrawn from a Vault
      pub event TokensWithdrawn(amount: UFix64, from: Address?)

      /// TokensDeposited
      ///
      /// The event that is emitted when tokens are deposited to a Vault
      pub event TokensDeposited(amount: UFix64, to: Address?)

      /// TokensMinted
      ///
      /// The event that is emitted when new tokens are minted
      pub event TokensMinted(amount: UFix64)

      pub let TokenVaultStoragePath: StoragePath
      pub let TokenVaultPublicPath: PublicPath
      pub let TokenMinterStoragePath: StoragePath

      pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {
          pub var balance: UFix64

          init(balance: UFix64) {
              self.balance = balance
          }

          pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
              self.balance = self.balance - amount
              emit TokensWithdrawn(amount: amount, from: self.owner?.address)
              return <- create Vault(balance: amount)
          }

          pub fun deposit(from: @FungibleToken.Vault) {
              let vault <- from as! @PeaceToken.Vault
              self.balance = self.balance + vault.balance
              emit TokensDeposited(amount: vault.balance, to: self.owner?.address)
              vault.balance = 0.0
              destroy vault // Make sure we get rid of the vault
          }

          destroy() {
              PeaceToken.totalSupply = PeaceToken.totalSupply - self.balance
          }
      }

      pub fun createEmptyVault(): @FungibleToken.Vault {
          return <- create Vault(balance: 0.0)
      }

      access(contract) fun initialMint(initialMintValue: UFix64): @FungibleToken.Vault {
          return <- create Vault(balance: initialMintValue)
      }

      pub resource Minter {
          pub fun mintTokens(amount: UFix64): @FungibleToken.Vault {
          pre {
                  amount > 0.0: "Amount minted must be greater than zero"
              }
              PeaceToken.totalSupply = PeaceToken.totalSupply + amount
              return <- create Vault(balance:amount)
          }

      }

      init() {
          self.totalSupply = 100.00
          self.TokenVaultStoragePath = /storage/PeaceTokenVault
          self.TokenVaultPublicPath = /public/PeaceTokenVault
          self.TokenMinterStoragePath = /storage/PeaceTokenMinter

          self.account.save(<- create Minter(), to: PeaceToken.TokenMinterStoragePath)

         //
         // Create an Empty Vault for the Minter
         //
          self.account.save(<- PeaceToken.initialMint(initialMintValue: self.totalSupply), to: PeaceToken.TokenVaultStoragePath)
          self.account.link<&PeaceToken.Vault{FungibleToken.Balance, FungibleToken.Receiver}>(PeaceToken.TokenVaultPublicPath, target: PeaceToken.TokenVaultStoragePath)
      }
   }

      "
-------
"
// Mainnet
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

//Testnet
// import NonFungibleToken from 0x631e88ae7f1d7c20
// import MetadataViews from 0x631e88ae7f1d7c20

pub contract DriverzExclusive: NonFungibleToken {

	//Define Events
	pub event ContractInitialized()
	pub event Withdraw(id: UInt64, from: Address?)
	pub event Deposit(id: UInt64, to: Address?)
	pub event ExclusiveMinted(id: UInt64, name: String, description: String, image: String, traits: {String:String})

	//Define Paths
	pub let CollectionStoragePath: StoragePath
	pub let CollectionPublicPath: PublicPath
	pub let CollectionPrivatePath: PrivatePath
	pub let AdminStoragePath: StoragePath

	//Difine Total Supply
	pub var totalSupply: UInt64

	pub struct driverzExclusiveMetadata {
		pub let id: UInt64
		pub let name: String
		pub let description: String
		pub let image: String
		pub let traits: {String:String}

		init(_id: UInt64, _name: String, _description: String, _image: String, _traits:{String:String}) {
			self.id = _id
			self.name = _name
			self.description = _description
			self.image = _image
			self.traits = _traits
		}
	}

	pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {

		pub let id: UInt64
		pub let name: String
		pub let description: String
		pub var image: String
		pub let traits: {String: String}

		init( _id: UInt64, _name: String, _description: String, _image: String, _traits: {String:String}) {

			self.id = _id
			self.name = _name
			self.description = _description
			self.image = _image
			self.traits = _traits
		}

		pub fun revealThumbnail() {
            let urlBase = self.image.slice(from: 0, upTo: 47)
            let newImage = urlBase.concat(self.id.toString()).concat(".png")
            self.image = newImage
        }

		pub fun getViews(): [Type] {
			return [
				Type<MetadataViews.NFTView>(),
				Type<MetadataViews.Display>(),
				Type<MetadataViews.ExternalURL>(),
				Type<MetadataViews.NFTCollectionData>(),
				Type<MetadataViews.NFTCollectionDisplay>(),
				Type<DriverzExclusive.driverzExclusiveMetadata>(),
                Type<MetadataViews.Royalties>(),
				Type<MetadataViews.Traits>()
			]
		}

		pub fun resolveView(_ view: Type): AnyStruct? {
			switch view {

				case Type<MetadataViews.Display>():
					return MetadataViews.Display(
                        name: self.name,
                        description: self.description,
                        thumbnail: MetadataViews.IPFSFile(
                            cid: self.image,
                            path: nil
                        )
                    )

                case Type<MetadataViews.ExternalURL>():
         			return MetadataViews.ExternalURL("https://driverz.world")

				case Type<MetadataViews.NFTCollectionData>():
					return MetadataViews.NFTCollectionData(
						storagePath: DriverzExclusive.CollectionStoragePath,
						publicPath: DriverzExclusive.CollectionPublicPath,
						providerPath: DriverzExclusive.CollectionPrivatePath,
						publicCollection: Type<&Collection{NonFungibleToken.CollectionPublic}>(),
						publicLinkedType: Type<&Collection{DriverzExclusive.CollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
						providerLinkedType: Type<&Collection{DriverzExclusive.CollectionPublic, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection, NonFungibleToken.Provider}>(),
						createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
								return <- DriverzExclusive.createEmptyCollection()
						})
					)

                case Type<MetadataViews.NFTCollectionDisplay>():
					let squareMedia = MetadataViews.Media(
						file: MetadataViews.HTTPFile(
							url: "https://driverzinc.io/DriverzNFT-logo.png"
						),
						mediaType: "image"
					)
					let bannerMedia = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: "https://driverzinc.io/DriverzNFT-logo.png"
                        ),
                        mediaType: "image"
                    )
					return MetadataViews.NFTCollectionDisplay(
						name: "Driverz Exclusive",
						description: "Driverz Exclusive Collection",
						externalURL: MetadataViews.ExternalURL("https://driverz.world"),
						squareImage: squareMedia,
						bannerImage: bannerMedia,
						socials: {
							"twitter": MetadataViews.ExternalURL("https://twitter.com/DriverzSales")
						}
					)

				case Type<DriverzExclusive.driverzExclusiveMetadata>():
					return DriverzExclusive.driverzExclusiveMetadata(
						id: self.id,
						name: self.name,
						description: self.description,
						image: self.image,
						traits: self.traits
					)

                case Type<MetadataViews.NFTView>():
                    let viewResolver = &self as &{MetadataViews.Resolver}
                        return MetadataViews.NFTView(
                            id: self.id,
                            uuid: self.uuid,
                            display: MetadataViews.getDisplay(viewResolver),
                            externalURL: MetadataViews.getExternalURL(viewResolver),
                            collectionData: MetadataViews.getNFTCollectionData(viewResolver),
                            collectionDisplay: MetadataViews.getNFTCollectionDisplay(viewResolver),
                            royalties: MetadataViews.getRoyalties(viewResolver),
                            traits: MetadataViews.getTraits(viewResolver)
                        )

                case Type<MetadataViews.Royalties>():
                    return MetadataViews.Royalties([])

				case Type<MetadataViews.Traits>():
					let traits: [MetadataViews.Trait] = []
                    for trait in self.traits.keys {
                        traits.append(MetadataViews.Trait(
                            trait: trait,
                            value: self.traits[trait]!,
                            displayType: nil,
                            rarity: nil
                        ))
                    }
                    return MetadataViews.Traits(traits: traits)

			}
			return nil
		}


	}

	pub resource interface CollectionPublic {
		pub fun deposit(token: @NonFungibleToken.NFT)
		pub fun getIDs(): [UInt64]
		pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver}
		pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowDriverzExclusive(id: UInt64): &DriverzExclusive.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow DriverzExclusive reference: The ID of the returned reference is incorrect."
            }
        }
	}

	pub resource Collection: CollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
		// dictionary of NFT conforming tokens
		// NFT is a resource type with an 'UInt64' ID field
		pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

		// withdraw removes an NFT from the collection and moves it to the caller
		pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
			let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

			emit Withdraw(id: token.id, from: self.owner?.address)

			return <-token
		}

		// deposit takes a NFT and adds it to the collections dictionary
		// and adds the ID to the id array
		pub fun deposit(token: @NonFungibleToken.NFT) {
			let token <- token as! @DriverzExclusive.NFT

			let id: UInt64 = token.id

			let oldToken <- self.ownedNFTs[id] <- token

			emit Deposit(id: id, to: self.owner?.address)

        destroy oldToken

		}

		// getIDs returns an array of the IDs that are in the collection
		pub fun getIDs(): [UInt64] {
			return self.ownedNFTs.keys
		}

        pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let mainNFT = nft as! &DriverzExclusive.NFT
            return mainNFT
		}


		// borrowNFT gets a reference to an NFT in the collection
		// so that the caller can read its metadata and call its methods
		pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
			return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
		}

       pub fun borrowDriverzExclusive(id: UInt64): &DriverzExclusive.NFT? {
            if self.ownedNFTs[id] != nil {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &DriverzExclusive.NFT
            } else {
                return nil
            }
        }

		init () {
			self.ownedNFTs <- {}
		}

		destroy() {
			destroy self.ownedNFTs
		}
	}

	pub fun createEmptyCollection(): @NonFungibleToken.Collection {
		return <- create Collection()
	}

	pub resource Admin {
		pub fun mintNFT(
            recipient: &{NonFungibleToken.CollectionPublic},
            name: String,
            description: String,
            image: String,
            traits: {String:String}
            ) {
			    emit ExclusiveMinted(id: DriverzExclusive.totalSupply, name: name, description: description, image: image, traits: traits)
			    DriverzExclusive.totalSupply = DriverzExclusive.totalSupply + (1 as UInt64)

			recipient.deposit(token: <- create DriverzExclusive.NFT(
                initID: DriverzExclusive.totalSupply,
                name: name,
                description: description,
                image: image,
                traits: traits
                )
			)
		}
	}

	init() {

		self.CollectionStoragePath = /storage/DriverzExclusiveCollection
		self.CollectionPublicPath = /public/DriverzExclusiveCollection
		self.CollectionPrivatePath = /private/DriverzExclusiveCollection
		self.AdminStoragePath = /storage/DriverzExclusiveMinter

		self.totalSupply = 0

		let minter <- create Admin()
		self.account.save(<-minter, to: self.AdminStoragePath)

		let collection <- DriverzExclusive.createEmptyCollection()
		self.account.save(<- collection, to: self.CollectionStoragePath)

		// create a public capability for the collection
		self.account.link<&DriverzExclusive.Collection{NonFungibleToken.CollectionPublic, DriverzExclusive.CollectionPublic}>(
			self.CollectionPublicPath,
			target: self.CollectionStoragePath
		)

		emit ContractInitialized()
	}
}
"
-------
"/* */
import MetadataViews from 0x1d7e57aa55817448
import NonFungibleToken from 0x1d7e57aa55817448
import TiblesApp from 0x5cdeb067561defcb
import TiblesNFT from 0x5cdeb067561defcb
import TiblesProducer from 0x5cdeb067561defcb

pub contract Sk8tibles:
  NonFungibleToken,
  TiblesApp,
  TiblesNFT,
  TiblesProducer
{
  pub let appId: String
  pub let title: String
  pub let description: String
  pub let ProducerStoragePath: StoragePath
  pub let ProducerPath: PrivatePath
  pub let ContentPath: PublicPath
  pub let contentCapability: Capability
  pub let CollectionStoragePath: StoragePath
  pub let PublicCollectionPath: PublicPath

  pub event ContractInitialized()
  pub event Withdraw(id: UInt64, from: Address?)
  pub event Deposit(id: UInt64, to: Address?)
  pub event MinterCreated(minterId: String)
  pub event TibleMinted(minterId: String, mintNumber: UInt32, id: UInt64)
  pub event TibleDestroyed(id: UInt64)
  pub event PackMinterCreated(minterId: String)
  pub event PackMinted(id: UInt64, printedPackId: String)

  pub var totalSupply: UInt64

  pub resource NFT: NonFungibleToken.INFT, TiblesNFT.INFT, MetadataViews.Resolver {
    pub let id: UInt64
    pub let mintNumber: UInt32

    access(self) let contentCapability: Capability
    access(self) let contentId: String

    init(id: UInt64, mintNumber: UInt32, contentCapability: Capability, contentId: String) {
      self.id = id
      self.mintNumber = mintNumber
      self.contentId = contentId
      self.contentCapability = contentCapability
    }

    destroy() {
      emit TibleDestroyed(id: self.id)
    }

    pub fun metadata(): {String: AnyStruct}? {
      let content = self.contentCapability.borrow<&{TiblesProducer.IContent}>() ?? panic("Failed to borrow content provider")
      return content.getMetadata(contentId: self.contentId)
    }

    pub fun displayData(): {String: String} {
      let metadata = self.metadata() ?? panic("Missing NFT metadata")

      if (metadata.containsKey("pack")) {
        return {
          "name": "Sk8tibles pack",
          "description": "A Sk8tibles pack",
          "imageUrl": "https://i.tibles.com/m/sk8tibles-minted-pack.png"
        }
      }

      let set = metadata["set"]! as! &Sk8tibles.Set
      let item = metadata["item"]! as! &Sk8tibles.Item
      let variant = metadata["variant"]! as! &Sk8tibles.Variant

      var edition: String = ""
      var serialInfo: String = ""
      if let maxCount = variant.maxCount() {
        edition = "Limited Edition"
        serialInfo = "LE | "
          .concat(variant.title())
          .concat(" #")
          .concat(self.mintNumber.toString())
          .concat("/")
          .concat(maxCount.toString())
      } else if let batchSize = variant.batchSize() {
        edition = "Standard Edition"
        let mintSeries = (self.mintNumber - 1) / batchSize + 1
        serialInfo = "S".concat(mintSeries.toString())
          .concat(" | ")
          .concat(variant.title())
          .concat(" #")
          .concat(self.mintNumber.toString())
      } else {
        panic("Missing batch size and max count")
      }

      let description = serialInfo
        .concat("\n")
        .concat(edition)
        .concat("\n")
        .concat(set.title())

      let imageUrl = item.imageUrl(variantId: variant.id)

      return {
        "name": item.title(),
        "description": description,
        "imageUrl": imageUrl,
        "edition": edition,
        "serialInfo": serialInfo
      }
    }

    pub fun display(): MetadataViews.Display {
      let nftData = self.displayData()

      return MetadataViews.Display(
        name: nftData["name"] ?? "",
        description: nftData["description"] ?? "",
        thumbnail: MetadataViews.HTTPFile(url: nftData["imageUrl"] ?? "")
      )
    }

    pub fun editions(): MetadataViews.Editions {
      let nftData = self.displayData()
      let metadata = self.metadata() ?? panic("Missing NFT metadata")
      if (metadata.containsKey("pack")) {
         return MetadataViews.Editions([MetadataViews.Edition(name: "Sk8tibles pack", number: UInt64(self.mintNumber), max: nil)])
      }

      let variant = metadata["variant"]! as! &Sk8tibles.Variant

      var maxCount: UInt64? = nil
      if let count = variant.maxCount() {
        maxCount = UInt64(count)
      }

      let editionInfo = MetadataViews.Edition(
        name: nftData["edition"] ?? "",
        number: UInt64(self.mintNumber),
        max: maxCount
      )

      let editionList: [MetadataViews.Edition] = [editionInfo]
      return MetadataViews.Editions(editionList)
    }

    pub fun serial(): MetadataViews.Serial {
      return MetadataViews.Serial(UInt64(self.mintNumber))
    }

    pub fun royalties(): MetadataViews.Royalties {
      let royalties : [MetadataViews.Royalty] = []
      return MetadataViews.Royalties(royalties: royalties)
    }

    pub fun externalURL(): MetadataViews.ExternalURL {
      return MetadataViews.ExternalURL("https://sk8tibles.com/collection".concat(self.id.toString()))
    }

    pub fun nftCollectionData(): MetadataViews.NFTCollectionData {
      return MetadataViews.NFTCollectionData(
        storagePath: Sk8tibles.CollectionStoragePath,
        publicPath: Sk8tibles.PublicCollectionPath,
        providerPath: /private/Sk8tiblesCollection,
        publicCollection: Type<&Sk8tibles.Collection{TiblesNFT.CollectionPublic}>(),
        publicLinkedType:   Type<&Sk8tibles.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
        providerLinkedType: Type<&Sk8tibles.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(),
        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
            return <-Sk8tibles.createEmptyCollection()
        })
      )
    }

    pub fun nftCollectionDisplay(): MetadataViews.NFTCollectionDisplay {
      let squareMedia = MetadataViews.Media(
        file: MetadataViews.HTTPFile(url: "https://i.tibles.com/m/sk8tibles-flow-icon.png"),
        mediaType: "image/svg+xml"
      )
      let bannerMedia = MetadataViews.Media(
        file: MetadataViews.HTTPFile(url: "https://i.tibles.com/m/sk8tibles-flow-collection-banner.png"),
        mediaType: "image/png"
      )

      let socialsData: {String: String} = {"twitter": "https://twitter.com/sk8tibles"}
      let socials:{String: MetadataViews.ExternalURL } = {}
      for key in socialsData.keys {
        socials[key] = MetadataViews.ExternalURL(socialsData[key]!)
      }

      return MetadataViews.NFTCollectionDisplay(
        name: "Sk8tibles Collection",
        description: "A digital trading card collecting experience by Tibles, made in partnership with the Skateboarding Hall of Fame and Museum.",
        externalURL: MetadataViews.ExternalURL("https://sk8tibles.com"),
        squareImage: squareMedia,
        bannerImage: bannerMedia,
        socials: socials
      )
    }

    pub fun traits(): MetadataViews.Traits {
      let traits : [MetadataViews.Trait] = []
      return MetadataViews.Traits(traits: traits)
    }

    pub fun getViews(): [Type] {
      return [
        Type<MetadataViews.Display>(),
        Type<MetadataViews.Editions>(),
        Type<MetadataViews.Royalties>(),
        Type<MetadataViews.ExternalURL>(),
        Type<MetadataViews.NFTCollectionData>(),
        Type<MetadataViews.NFTCollectionDisplay>(),
        Type<MetadataViews.Serial>(),
        Type<MetadataViews.Traits>()
      ]
    }

    pub fun resolveView(_ view: Type): AnyStruct? {
      switch view {
        case Type<MetadataViews.Display>():
          return self.display()
        case Type<MetadataViews.Editions>():
          return self.editions()
        case Type<MetadataViews.Serial>():
          return self.serial()
        case Type<MetadataViews.Royalties>():
          return self.royalties()
        case Type<MetadataViews.ExternalURL>():
          return self.externalURL()
        case Type<MetadataViews.NFTCollectionData>():
          return self.nftCollectionData()
        case Type<MetadataViews.NFTCollectionDisplay>():
          return self.nftCollectionDisplay()
        case Type<MetadataViews.Traits>():
          return self.traits()
        default: return nil
      }
    }
  }

  pub resource Collection:
    NonFungibleToken.Provider,
    NonFungibleToken.Receiver,
    NonFungibleToken.CollectionPublic,
    TiblesNFT.CollectionPublic,
    MetadataViews.ResolverCollection
  {
    pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

    pub fun deposit(token: @NonFungibleToken.NFT) {
      let tible <- token as! @Sk8tibles.NFT
      self.depositTible(tible: <- tible)
    }

    pub fun depositTible(tible: @AnyResource{TiblesNFT.INFT}) {
      pre {
        self.ownedNFTs[tible.id] == nil: "tible with this id already exists"
      }
      let token <- tible as! @Sk8tibles.NFT
      let id = token.id
      self.ownedNFTs[id] <-! token

      if self.owner?.address != nil {
        emit Deposit(id: id, to: self.owner?.address)
      }
    }

    pub fun getIDs(): [UInt64] {
      return self.ownedNFTs.keys
    }

    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
      if let nft = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT? {
        return nft
      }
      panic("Failed to borrow NFT with ID: ".concat(id.toString()))
    }

    pub fun borrowTible(id: UInt64): &AnyResource{TiblesNFT.INFT} {
      if let nft = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT? {
        return nft as! &Sk8tibles.NFT
      }
      panic("Failed to borrow NFT with ID: ".concat(id.toString()))
    }

    pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
      let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("Cannot withdraw: tible does not exist in the collection")
      emit Withdraw(id: token.id, from: self.owner?.address)
      return <-token
    }

    pub fun withdrawTible(id: UInt64): @AnyResource{TiblesNFT.INFT} {
      let token <- self.ownedNFTs.remove(key: id) ?? panic("Cannot withdraw: tible does not exist in the collection")
      let tible <- token as! @Sk8tibles.NFT
      emit Withdraw(id: tible.id, from: self.owner?.address)
      return <-tible
    }

    pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {
      if let nft = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT? {
        return nft as! &Sk8tibles.NFT
      }
      panic("Failed to borrow NFT with ID: ".concat(id.toString()))
    }

    pub fun tibleDescriptions(): {UInt64: {String: AnyStruct}} {
      var descriptions: {UInt64: {String: AnyStruct}} = {}

      for id in self.ownedNFTs.keys {
        let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT?
        let nft = ref as! &NFT
        var description: {String: AnyStruct} = {}
        description["mintNumber"] = nft.mintNumber
        description["metadata"] = nft.metadata()
        descriptions[id] = description
      }

      return descriptions
    }

    pub fun destroyTible(id: UInt64) {
      let token <- self.ownedNFTs.remove(key: id) ?? panic("NFT not found")
      destroy token
    }

    init () {
      self.ownedNFTs <- {}
    }

    destroy() {
      destroy self.ownedNFTs
    }
  }

  pub fun createEmptyCollection(): @NonFungibleToken.Collection {
    return <- create Collection()
  }

  pub struct ContentLocation {
    pub let setId: String
    pub let itemId: String
    pub let variantId: String

    init(setId: String, itemId: String, variantId: String) {
      self.setId = setId
      self.itemId = itemId
      self.variantId = variantId
    }
  }

  pub struct interface IContentLocation {}

  pub resource Producer: TiblesProducer.IProducer, TiblesProducer.IContent {
    access(contract) let minters: @{String: TiblesProducer.Minter}
    access(contract) let contentIdsToPaths: {String: TiblesProducer.ContentLocation}
    access(contract) let sets: {String: Set}

    pub fun minter(id: String): &Minter? {
      let ref = &self.minters[id] as auth &{TiblesProducer.IMinter}?
      return ref as! &Minter?
    }

    pub fun set(id: String): &Set? {
      return &self.sets[id] as &Set?
    }

    pub fun addSet(_ set: Set, contentCapability: Capability) {
      pre {
        self.sets[set.id] == nil: "Set with id: ".concat(set.id).concat(" already exists")
      }

      self.sets[set.id] = set

      for item in set.items.values {
        for variant in set.variants.values {
          let limit: UInt32? = variant.maxCount()

          let minterId: String = set.id.concat(":").concat(item.id).concat(":").concat(variant.id)
          let minter <- create Minter(id: minterId, limit: limit, contentCapability: contentCapability)

          if self.minters.keys.contains(minterId) {
            panic("Minter ID ".concat(minterId).concat(" already exists."))
          }

          self.minters[minterId] <-! minter

          let path = ContentLocation(setId: set.id, itemId: item.id, variantId: variant.id)
          self.contentIdsToPaths[minterId] = path

          emit MinterCreated(minterId: minterId)
        }
      }
    }

    pub fun getMetadata(contentId: String): {String: AnyStruct}? {
      let path = self.contentIdsToPaths[contentId] ?? panic("Failed to get content path")
      let location = path as! ContentLocation
      let set = self.set(id: location.setId) ?? panic("The set does not exist!")
      let item = set.item(location.itemId) ?? panic("Item metadata is nil")
      let variant = set.variant(location.variantId) ?? panic("Variant metadata is nil")

      var metadata: {String: AnyStruct} = {}
      metadata["set"] = set
      metadata["item"] = item
      metadata["variant"] = variant
      return metadata
    }

    init() {
      self.sets = {}
      self.contentIdsToPaths = {}
      self.minters <- {}
    }

    destroy() {
      destroy self.minters
    }
  }

  pub struct Set {
    pub let id: String
    access(contract) let items: {String: Item}
    access(contract) let variants: {String: Variant}
    access(contract) var metadata: {String: AnyStruct}?

    pub fun title(): String {
      return self.metadata!["title"]! as! String
    }

    pub fun item(_ id: String): &Item? {
      return &self.items[id] as &Item?
    }

    pub fun variant(_ id: String): &Variant? {
      return &self.variants[id] as &Variant?
    }

    pub fun update(title: String) {
      self.metadata = {
        "title": title
      }
    }

    init(id: String, title: String, items: {String: Item}, variants: {String: Variant}) {
      self.id = id
      self.items = items
      self.variants = variants
      self.metadata = nil
      self.update(title: title)
    }
  }

  pub struct Item {
    pub let id: String
    access(contract) var metadata: {String: AnyStruct}?

    pub fun title(): String {
      return self.metadata!["title"]! as! String
    }

    pub fun imageUrl(variantId: String): String {
      let imageUrls = self.metadata!["imageUrls"]! as! {String: String}
      return imageUrls[variantId]!
    }

    pub fun update(title: String, imageUrls: {String: String}) {
      self.metadata = {
        "title": title,
        "imageUrls": imageUrls
      }
    }

    init(id: String, title: String, imageUrls: {String: String}) {
      self.id = id
      self.metadata = nil
      self.update(title: title, imageUrls: imageUrls)
    }
  }

  pub struct Variant {
    pub let id: String
    access(contract) var metadata: {String: AnyStruct}?

    pub fun title(): String {
      return self.metadata!["title"]! as! String
    }

    pub fun batchSize(): UInt32? {
      return self.metadata!["batchSize"] as! UInt32?
    }

    pub fun maxCount(): UInt32? {
      return self.metadata!["maxCount"] as! UInt32?
    }

    pub fun update(title: String, batchSize: UInt32?, maxCount: UInt32?) {
      assert((batchSize == nil) != (maxCount == nil), message: "batch size or max count can be used, not both")
      let metadata: {String: AnyStruct} = {
        "title": title
      }
      let previousBatchSize = (self.metadata ?? {})["batchSize"] as! UInt32?
      let previousMaxCount = (self.metadata ?? {})["maxCount"] as! UInt32?
      if let batchSize = batchSize {
        assert(previousMaxCount == nil, message: "Cannot change from max count to batch size")
        assert(previousBatchSize == nil || previousBatchSize == batchSize, message: "batch size cannot be changed once set")
        metadata["batchSize"] = batchSize
      }
      if let maxCount = maxCount {
        assert(previousBatchSize == nil, message: "Cannot change from batch size to max count")
        assert(previousMaxCount == nil || previousMaxCount == maxCount, message: "max count cannot be changed once set")
        metadata["maxCount"] = maxCount
      }
      self.metadata = metadata
    }

    init(id: String, title: String, batchSize: UInt32?, maxCount: UInt32?) {
      self.id = id
      self.metadata = nil
      self.update(title: title, batchSize: batchSize, maxCount: maxCount)
    }
  }

  pub resource Minter: TiblesProducer.IMinter {
    pub let id: String
    pub var lastMintNumber: UInt32
    access(contract) let tibles: @{UInt32: AnyResource{TiblesNFT.INFT}}
    pub let limit: UInt32?
    pub let contentCapability: Capability

    pub fun withdraw(mintNumber: UInt32): @AnyResource{TiblesNFT.INFT} {
      pre {
        self.tibles[mintNumber] != nil: "The tible does not exist in this minter."
      }
      return <- self.tibles.remove(key: mintNumber)!
    }

    pub fun mintNext() {
      if let limit = self.limit {
        if self.lastMintNumber >= limit {
          panic("You've hit the limit for number of tokens in this minter!")
        }
      }

      let id = Sk8tibles.totalSupply + 1
      let mintNumber = self.lastMintNumber + 1
      let tible <- create NFT(id: id, mintNumber: mintNumber, contentCapability: self.contentCapability, contentId: self.id)
      self.tibles[mintNumber] <-! tible
      self.lastMintNumber = mintNumber
      Sk8tibles.totalSupply = id

      emit TibleMinted(minterId: self.id, mintNumber: mintNumber, id: id)
    }

    init(id: String, limit: UInt32?, contentCapability: Capability) {
      self.id = id
      self.lastMintNumber = 0
      self.tibles <- {}
      self.limit = limit
      self.contentCapability = contentCapability
    }

    destroy() {
      destroy self.tibles
    }
  }

  pub resource PackMinter: TiblesProducer.IContent{
      pub let id: String
      pub var lastMintNumber: UInt32
      access(contract) let packs: @{UInt64: AnyResource{TiblesNFT.INFT}}
      access(contract) let contentIdsToPaths: {String: TiblesProducer.ContentLocation}
      pub let contentCapability: Capability

      pub fun getMetadata(contentId: String): {String: AnyStruct}? {
        return {
          "pack": "Sk8tibles"
        }
      }

      pub fun withdraw(id: UInt64): @AnyResource{TiblesNFT.INFT} {
        pre {
          self.packs[id] != nil: "The pack does not exist in this minter."
        }
        return <- self.packs.remove(key: id)!
      }

      pub fun mintNext(printedPackId: String) {
        let id = Sk8tibles.totalSupply + 1
        let mintNumber = self.lastMintNumber + 1
        let pack <- create NFT(id: id, mintNumber: mintNumber, contentCapability: self.contentCapability, contentId: self.id)
        self.packs[id] <-! pack
        self.lastMintNumber = mintNumber
        Sk8tibles.totalSupply = id
        emit PackMinted(id: id, printedPackId: printedPackId)
      }

      init(id: String, contentCapability: Capability) {
        self.id = id
        self.lastMintNumber = 0
        self.packs <- {}
        self.contentCapability = contentCapability
        self.contentIdsToPaths = {}
        emit PackMinterCreated(minterId: self.id)
      }

      destroy() {
        destroy self.packs
      }
    }

    pub fun createNewPackMinter(id: String, contentCapability: Capability): @PackMinter {
      assert(self.account.address == 0x0a2fbb92a8ae5c6d, message: "wrong address")
      return <- create PackMinter(id: id, contentCapability: contentCapability)
    }

  init() {
    self.totalSupply = 0

    self.appId = "com.tibles.skateboarding"
    self.title = "Sk8tibles"
    self.description = "A Skateboarding Hall of Fame Collecting Community"

    self.ProducerStoragePath = /storage/TiblesSk8tiblesProducer
    self.ProducerPath = /private/TiblesSk8tiblesProducer
    self.ContentPath = /public/TiblesSk8tiblesContent
    self.CollectionStoragePath = /storage/TiblesSk8tiblesCollection
    self.PublicCollectionPath = /public/TiblesSk8tiblesCollection

    let producer <- create Producer()
    self.account.save<@Producer>(<-producer, to: self.ProducerStoragePath)
    self.account.link<&Producer>(self.ProducerPath, target: self.ProducerStoragePath)

    self.account.link<&{TiblesProducer.IContent}>(self.ContentPath, target: self.ProducerStoragePath)
    self.contentCapability = self.account.getCapability(self.ContentPath)

    emit ContractInitialized()
  }
}
"
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

// NftReality Contract
pub contract NftReality: NonFungibleToken {

    // Events
    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event Minted(
        id: UInt64,
        itemUuid: String,
        unit: UInt64,
        totalUnits: UInt64,
        metadata: Metadata,
        additionalInfo: {String: String}
    )

    // Paths
    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath

    // Number of nfts minted
    pub var totalSupply: UInt64

    // NFT metadata
    pub struct Metadata {
        pub let artwork: String
        pub let logotype: String
        pub let description: String
        pub let creator: String
        pub let company: String
        pub let role: String
        pub let creationDate: String

        init(
            artwork: String,
            logotype: String,
            description: String,
            creator: String,
            company: String,
            role: String,
            creationDate: String
        ) {
            self.artwork = artwork
            self.logotype = logotype
            self.description = description
            self.creator = creator
            self.company = company
            self.role = role
            self.creationDate = creationDate
        }
    }

    pub struct NftRealityMetadataView {
        pub let itemUuid: String
        pub let unit: UInt64
        pub let totalUnits: UInt64
        pub let artwork: String
        pub let logotype: String
        pub let description: String
        pub let creator: String
        pub let company: String
        pub let role: String
        pub let creationDate: String

        init(
            itemUuid: String,
            unit: UInt64,
            totalUnits: UInt64,
            artwork: String,
            logotype: String,
            description: String,
            creator: String,
            company: String,
            role: String,
            creationDate: String
        ) {
            self.itemUuid = itemUuid
            self.unit = unit
            self.totalUnits = totalUnits
            self.artwork = artwork
            self.logotype = logotype
            self.description = description
            self.creator = creator
            self.company = company
            self.role = role
            self.creationDate = creationDate
        }
    }

    // NftReality nft resource
    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        pub let id: UInt64
        pub let itemUuid: String
        pub let unit: UInt64
        pub let totalUnits: UInt64
        pub let metadata: Metadata
        access(self) let additionalInfo: {String: String}

        init(
            ID: UInt64,
            itemUuid: String,
            unit: UInt64,
            totalUnits: UInt64,
            metadata: Metadata,
            additionalInfo: {String: String}
        ) {
            self.id = ID
            self.itemUuid = itemUuid
            self.unit = unit
            self.totalUnits = totalUnits
            self.metadata = metadata
            self.additionalInfo = additionalInfo
        }

        pub fun name(): String {
            return self.metadata.company.concat(" - ").concat(self.metadata.role)
        }

        pub fun description(): String {
            return self.metadata.description
        }

        pub fun imageCID(): String {
            return self.metadata.artwork
        }

        pub fun getAdditionalInfo(): {String: String} {
            return self.additionalInfo
        }

        pub fun getViews(): [Type] {
            return [
                Type<NftRealityMetadataView>(),
                Type<MetadataViews.Display>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<NftRealityMetadataView>():
                    return NftRealityMetadataView(
                        itemUuid: self.itemUuid,
                        unit: self.unit,
                        totalUnits: self.totalUnits,
                        artwork: self.metadata.artwork,
                        logotype: self.metadata.logotype,
                        description: self.metadata.description,
                        creator: self.metadata.creator,
                        company: self.metadata.company,
                        role: self.metadata.role,
                        creationDate: self.metadata.creationDate
                    )
                case Type<MetadataViews.Display>():
                    var thumbnail: AnyStruct{MetadataViews.File} = MetadataViews.HTTPFile("")
                    if (self.getAdditionalInfo().containsKey("artworkThumbnail")) {
                        thumbnail = MetadataViews.IPFSFile(
                            cid: self.getAdditionalInfo()["artworkThumbnail"]!,
                            path: "artworkThumbnail"
                        )
                    }
                    return MetadataViews.Display(
                        name: self.name(),
                        description: self.description(),
                        thumbnail: thumbnail
                    )
            }

            return nil
        }
    }

    // NftReality nfts collection public interface
    pub resource interface NftRealityCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowNftReality(id: UInt64): &NftReality.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow NftReality reference: The ID of the returned reference is incorrect"
            }
        }
    }

    // NftReality nfts collection resource
    pub resource Collection: NftRealityCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic {
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("Missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @NftReality.NFT

            let id: UInt64 = token.id

            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowNftReality(id: UInt64): &NftReality.NFT? {
            if self.ownedNFTs[id] != nil {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &NftReality.NFT
            } else {
                return nil
            }
        }

        destroy() {
            destroy self.ownedNFTs
        }

        init () {
            self.ownedNFTs <- {}
        }
    }

    // Public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(): @NftReality.Collection {
        return <- create Collection()
    }

    // Resource that an admin can use to mint new nfts
	pub resource NFTMinter {

        pub fun mintNFT(
            itemUuid: String,
            recipient: &{NonFungibleToken.CollectionPublic},
            unit: UInt64,
            totalUnits: UInt64,
            metadata: Metadata,
            additionalInfo: {String: String}
        ) {
            emit Minted(id: NftReality.totalSupply, itemUuid: itemUuid, unit: unit, totalUnits: totalUnits, metadata: metadata, additionalInfo: additionalInfo)

            recipient.deposit(token: <-create NftReality.NFT(
                ID: NftReality.totalSupply,
                itemUuid: itemUuid,
                unit: unit,
                totalUnits: totalUnits,
                metadata: metadata,
                additionalInfo: additionalInfo
            ))

            NftReality.totalSupply = NftReality.totalSupply + (1 as UInt64)
        }

        pub fun batchMintNFT(
            itemUuid: String,
            recipient: &{NonFungibleToken.CollectionPublic},
            totalUnits: UInt64,
            startingUnit: UInt64,
            quantity: UInt64,
            metadata: Metadata,
            additionalInfo: {String: String}
        ) {
            var i: UInt64 = 0
            var unit: UInt64 = startingUnit - 1
            while i < quantity {
                i = i + UInt64(1)
                unit = unit + UInt64(1)
                self.mintNFT(
                    itemUuid: itemUuid,
                    recipient: recipient,
                    unit: unit,
                    totalUnits: totalUnits,
                    metadata: metadata,
                    additionalInfo: additionalInfo
                )
            }
        }

        pub fun createNFTMinter(): @NFTMinter {
            return <- create NFTMinter()
        }
    }

    init () {
        self.CollectionStoragePath = /storage/nftRealityCollection
        self.CollectionPublicPath = /public/nftRealityCollection
        self.MinterStoragePath = /storage/nftRealityMinter

        self.totalSupply = 0

        let minter <- create NFTMinter()
        self.account.save(<-minter, to: self.MinterStoragePath)

        emit ContractInitialized()
    }
}
"
-------
"// ExampleNFT.cdc
//
// This is a complete version of the ExampleNFT contract
// that includes withdraw and deposit functionality, as well as a
// collection resource that can be used to bundle NFTs together.
//
// It also includes a definition for the Minter resource,
// which can be used by admins to mint new NFTs.
//
// Learn more about non-fungible tokens in this tutorial: https://developers.flow.com/cadence/tutorial/05-non-fungible-tokens-1

pub contract ExampleNFT {

    // Declare Path constants so paths do not have to be hardcoded
    // in transactions and scripts

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath

    // Declare the NFT resource type
    pub resource NFT {
        // The unique ID that differentiates each NFT
        pub let id: UInt64

        // Initialize both fields in the init function
        init(initID: UInt64) {
            self.id = initID
        }
    }

    // We define this interface purely as a way to allow users
    // to create public, restricted references to their NFT Collection.
    // They would use this to publicly expose only the deposit, getIDs,
    // and idExists fields in their Collection
    pub resource interface NFTReceiver {

        pub fun deposit(token: @NFT)

        pub fun getIDs(): [UInt64]

        pub fun idExists(id: UInt64): Bool
    }

    // The definition of the Collection resource that
    // holds the NFTs that a user owns
    pub resource Collection: NFTReceiver {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with an `UInt64` ID field
        pub var ownedNFTs: @{UInt64: NFT}

        // Initialize the NFTs field to an empty collection
        init () {
            self.ownedNFTs <- {}
        }

        // withdraw
        //
        // Function that removes an NFT from the collection
        // and moves it to the calling context
        pub fun withdraw(withdrawID: UInt64): @NFT {
            // If the NFT isn't found, the transaction panics and reverts
            let token <- self.ownedNFTs.remove(key: withdrawID)!

            return <-token
        }

        // deposit
        //
        // Function that takes a NFT as an argument and
        // adds it to the collections dictionary
        pub fun deposit(token: @NFT) {
            // add the new token to the dictionary with a force assignment
            // if there is already a value at that key, it will fail and revert
            self.ownedNFTs[token.id] <-! token
        }

        // idExists checks to see if a NFT
        // with the given ID exists in the collection
        pub fun idExists(id: UInt64): Bool {
            return self.ownedNFTs[id] != nil
        }

        // getIDs returns an array of the IDs that are in the collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    // creates a new empty Collection resource and returns it
    pub fun createEmptyCollection(): @Collection {
        return <- create Collection()
    }

    // NFTMinter
    //
    // Resource that would be owned by an admin or by a smart contract
    // that allows them to mint new NFTs when needed
    pub resource NFTMinter {

        // the ID that is used to mint NFTs
        // it is only incremented so that NFT ids remain
        // unique. It also keeps track of the total number of NFTs
        // in existence
        pub var idCount: UInt64

        init() {
            self.idCount = 1
        }

        // mintNFT
        //
        // Function that mints a new NFT with a new ID
        // and returns it to the caller
        pub fun mintNFT(): @NFT {

            // create a new NFT
            var newNFT <- create NFT(initID: self.idCount)

            // change the id so that each ID is unique
            self.idCount = self.idCount + 1

            return <-newNFT
        }
    }

	init() {
        self.CollectionStoragePath = /storage/nftTutorialCollection
        self.CollectionPublicPath = /public/nftTutorialCollection
        self.MinterStoragePath = /storage/nftTutorialMinter

		// store an empty NFT Collection in account storage
        self.account.save(<-self.createEmptyCollection(), to: self.CollectionStoragePath)

        // publish a reference to the Collection in storage
        self.account.link<&{NFTReceiver}>(self.CollectionPublicPath, target: self.CollectionStoragePath)

        // store a minter resource in account storage
        self.account.save(<-create NFTMinter(), to: self.MinterStoragePath)
	}
}

"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import FungibleTokenMetadataViews from 0xf233dcee88fe0abe
import MetadataViews from 0x1d7e57aa55817448
import Toucans from 0x577a3c409c5dcb5e
import ToucansTokens from 0x577a3c409c5dcb5e
import FlowToken from 0x1654653399040a61
import ViewResolver from 0x1d7e57aa55817448

pub contract XuniaDao: FungibleToken, ViewResolver {

    // The amount of tokens in existance
    pub var totalSupply: UFix64
    // nil if there is none
    pub let maxSupply: UFix64?

    // Paths
    pub let VaultStoragePath: StoragePath
    pub let ReceiverPublicPath: PublicPath
    pub let VaultPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath
    pub let AdministratorStoragePath: StoragePath

    // Events
    pub event TokensInitialized(initialSupply: UFix64)
    pub event TokensWithdrawn(amount: UFix64, from: Address?)
    pub event TokensDeposited(amount: UFix64, to: Address?)
    pub event TokensTransferred(amount: UFix64, from: Address, to: Address)
    pub event TokensMinted(amount: UFix64)
    pub event TokensBurned(amount: UFix64)

    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance, MetadataViews.Resolver {
        pub var balance: UFix64

        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)

            if let owner: Address = self.owner?.address {
                XuniaDao.setBalance(address: owner, balance: self.balance)
            }
            return <- create Vault(balance: amount)
        }

        pub fun deposit(from: @FungibleToken.Vault) {
            let vault: @Vault <- from as! @Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)

            // We set the balance to 0.0 here so that it doesn't
            // decrease the totalSupply in the `destroy` function.
            vault.balance = 0.0
            destroy vault

            if let owner: Address = self.owner?.address {
                XuniaDao.setBalance(address: owner, balance: self.balance)
            }
        }

        pub fun getViews(): [Type]{
            return [
                Type<FungibleTokenMetadataViews.FTView>(),
                Type<FungibleTokenMetadataViews.FTDisplay>(),
                Type<FungibleTokenMetadataViews.FTVaultData>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<FungibleTokenMetadataViews.FTView>():
                    return XuniaDao.resolveView(view)
                case Type<FungibleTokenMetadataViews.FTDisplay>():
                    return XuniaDao.resolveView(view)
                case Type<FungibleTokenMetadataViews.FTVaultData>():
                    return XuniaDao.resolveView(view)
            }
            return nil
        }

        init(balance: UFix64) {
            self.balance = balance
        }

        destroy() {
            if (self.balance > 0.0) {
                emit TokensBurned(amount: self.balance)
                XuniaDao.totalSupply = XuniaDao.totalSupply - self.balance
            }
        }
    }

    pub fun createEmptyVault(): @Vault {
        return <- create Vault(balance: 0.0)
    }

    pub resource Minter: Toucans.Minter {
        pub fun mint(amount: UFix64): @Vault {
            post {
                XuniaDao.maxSupply == nil || XuniaDao.totalSupply <= XuniaDao.maxSupply!:
                    "Exceeded the max supply of tokens allowd."
            }
            XuniaDao.totalSupply = XuniaDao.totalSupply + amount
            emit TokensMinted(amount: amount)
            return <- create Vault(balance: amount)
        }
    }

    // We follow this pattern of storage
    // so the (potentially) huge dictionary
    // isn't loaded when the contract is imported
    pub resource Administrator {
        // This is an experimental index and should
        // not be used for anything official
        // or monetary related
        access(self) let balances: {Address: UFix64}

        access(contract) fun setBalance(address: Address, balance: UFix64) {
            self.balances[address] = balance
        }

        pub fun getBalance(address: Address): UFix64 {
            return self.balances[address] ?? 0.0
        }

        pub fun getBalances(): {Address: UFix64} {
            return self.balances
        }

        init() {
            self.balances = {}
        }
    }

    access(contract) fun setBalance(address: Address, balance: UFix64) {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        admin.setBalance(address: address, balance: balance)
    }

    pub fun getBalance(address: Address): UFix64 {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalance(address: address)
    }

    pub fun getBalances(): {Address: UFix64} {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalances()
    }

    pub fun getViews(): [Type] {
        return [
            Type<FungibleTokenMetadataViews.FTView>(),
            Type<FungibleTokenMetadataViews.FTDisplay>(),
            Type<FungibleTokenMetadataViews.FTVaultData>()
        ]
    }

    pub fun resolveView(_ view: Type): AnyStruct? {
        switch view {
            case Type<FungibleTokenMetadataViews.FTView>():
                return FungibleTokenMetadataViews.FTView(
                    ftDisplay: self.resolveView(Type<FungibleTokenMetadataViews.FTDisplay>()) as! FungibleTokenMetadataViews.FTDisplay?,
                    ftVaultData: self.resolveView(Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
                )
            case Type<FungibleTokenMetadataViews.FTDisplay>():
                let media = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                        url: "undefined"
                    ),
                    mediaType: "image"
                )
                let bannerMedia = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                        url: "undefined"
                    ),
                    mediaType: "image"
                )
                let medias = MetadataViews.Medias([media, bannerMedia])
                return FungibleTokenMetadataViews.FTDisplay(
                    name: "Xunia Dao",
                    symbol: "XUNIA",
                    description: "The creator economy coin",
                    externalURL: MetadataViews.ExternalURL("xunia.unicornplatform.page"),
                    logos: medias,
                    socials: {
                        "twitter": MetadataViews.ExternalURL("_xunia"),
                        "discord": MetadataViews.ExternalURL("")
                    }
                )
            case Type<FungibleTokenMetadataViews.FTVaultData>():
                return FungibleTokenMetadataViews.FTVaultData(
                    storagePath: XuniaDao.VaultStoragePath,
                    receiverPath: XuniaDao.ReceiverPublicPath,
                    metadataPath: XuniaDao.VaultPublicPath,
                    providerPath: /private/XuniaDaoVault,
                    receiverLinkedType: Type<&Vault{FungibleToken.Receiver}>(),
                    metadataLinkedType: Type<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(),
                    providerLinkedType: Type<&Vault{FungibleToken.Provider}>(),
                    createEmptyVaultFunction: (fun (): @Vault {
                        return <- XuniaDao.createEmptyVault()
                    })
                )
        }
        return nil
    }

    init(
      _paymentTokenInfo: ToucansTokens.TokenInfo,
      _editDelay: UFix64,
      _minting: Bool,
      _initialTreasurySupply: UFix64,
      _maxSupply: UFix64?,
      _extra: {String: AnyStruct}
    ) {

      // Contract Variables
      self.totalSupply = 0.0
      self.maxSupply = _maxSupply

      // Paths
      self.VaultStoragePath = /storage/XuniaDaoVault
      self.ReceiverPublicPath = /public/XuniaDaoReceiver
      self.VaultPublicPath = /public/XuniaDaoMetadata
      self.MinterStoragePath = /storage/XuniaDaoMinter
      self.AdministratorStoragePath = /storage/XuniaDaoAdmin

      // Admin Setup
      let vault <- create Vault(balance: self.totalSupply)
      self.account.save(<- vault, to: self.VaultStoragePath)

      self.account.link<&Vault{FungibleToken.Receiver}>(
          self.ReceiverPublicPath,
          target: self.VaultStoragePath
      )

      self.account.link<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(
          self.VaultPublicPath,
          target: self.VaultStoragePath
      )

      if self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath) == nil {
        self.account.save(<- Toucans.createCollection(), to: Toucans.CollectionStoragePath)
        self.account.link<&Toucans.Collection{Toucans.CollectionPublic}>(Toucans.CollectionPublicPath, target: Toucans.CollectionStoragePath)
      }

      let toucansProjectCollection = self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath)!
      toucansProjectCollection.createProject(
        projectTokenInfo: ToucansTokens.TokenInfo("XuniaDao", self.account.address, "XUNIA", self.ReceiverPublicPath, self.VaultPublicPath, self.VaultStoragePath),
        paymentTokenInfo: _paymentTokenInfo,
        minter: <- create Minter(),
        editDelay: _editDelay,
        minting: _minting,
        initialTreasurySupply: _initialTreasurySupply,
        extra: _extra
      )

      self.account.save(<- create Administrator(), to: self.AdministratorStoragePath)

      // Events
      emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
 "
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract CollectionVault {
    pub event VaultAccessed(key: String)

    pub let DefaultStoragePath: StoragePath
    pub let DefaultPublicPath: PublicPath
    pub let DefaultPrivatePath: PrivatePath

    pub resource interface VaultPublic {
        pub fun storeVaultPublic(capability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>)
    }

    pub resource Vault: VaultPublic {
        access(contract) var storedCapabilities: {String: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>}
        access(contract) var allowedPublic: [String]?
        access(contract) var enabled: Bool

        pub fun getKeys(): [String] {
            return self.storedCapabilities.keys
        }

        pub fun hasKey(_ key: String): Bool {
            let capability = self.storedCapabilities[key]
            if capability == nil { return false }
            return capability!.check()
        }

        pub fun getVault(_ key: String): &{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}? {
            let capability = self.storedCapabilities[key]
            if capability == nil { return nil }
            emit VaultAccessed(key: key)
            return capability!.borrow()
        }

        pub fun storeVault(_ key: String, capability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>) {
            self.storedCapabilities.insert(key: key, capability)
        }

        pub fun storeVaultPublic(capability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>) {
            let collection = capability.borrow() ?? panic("Could not borrow capability")
            let type = collection.getType().identifier
            if self.allowedPublic != nil && !self.allowedPublic!.contains(type) {
                panic("Type ".concat(type).concat(" is not allowed for storeVaultPublic"))
            }
            let owner = collection.owner ?? panic("Collection must be owned in order to use storeVaultPublic")

            let key = type.concat("@").concat(owner.address.toString())

            self.storedCapabilities.insert(key: key, capability)
        }

        pub fun removeVault(_ key: String) {
            self.storedCapabilities.remove(key: key)
        }

        pub fun setAllowedPublic(_ allowedPublic: [String]?) {
            self.allowedPublic = allowedPublic
        }

        init(_ allowedPublic: [String]?) {
            self.storedCapabilities = {}
            self.allowedPublic = allowedPublic
            self.enabled = true
        }
    }

    pub fun createEmptyVault(_ allowedPublic: [String]?): @Vault {
        return <- create Vault(allowedPublic)
    }

    pub fun getAddress(): Address {
        return self.account.address
    }

    init (_ allowedPublic: [String]?) {
        self.DefaultStoragePath = /storage/nftRealityCollectionVault
        self.DefaultPublicPath = /public/nftRealityCollectionVault
        self.DefaultPrivatePath = /private/nftRealityCollectionVault

        let vault <- create Vault(allowedPublic)
        self.account.save(<-vault, to: self.DefaultStoragePath)

        self.account.link<&{VaultPublic}>(self.DefaultPublicPath, target: self.DefaultStoragePath)
    }
}
"
-------
"pub contract DapperWalletCollections {
    pub let StoragePath: StoragePath

    pub event TypeChanged(identifier: String, added: Bool)

    access(self) let types: {Type: Bool}

    pub resource Admin {
        pub fun addType(_ t: Type) {
            DapperWalletCollections.types.insert(key: t, true)
            emit TypeChanged(identifier: t.identifier, added: true)
        }

        pub fun removeType( _ t: Type) {
            DapperWalletCollections.types.remove(key: t)
            emit TypeChanged(identifier: t.identifier, added: false)
        }
    }

    init () {
        self.types = {}

        self.StoragePath = /storage/dapperWalletCollections
    }
}"
-------
"// Description: Smart Contract for St. Louis Blues Digital Collectibles
// SPDX-License-Identifier: UNLICENSED


import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract BLUES : NonFungibleToken{
    pub var totalSupply: UInt64

    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath

    pub resource NFT : NonFungibleToken.INFT, MetadataViews.Resolver {
        pub let id: UInt64
        pub var link: String
        pub var batch: UInt32
        pub var sequence: UInt16
        pub var limit: UInt16
        pub(set) var attended: Bool

        pub let name: String
        pub let description: String
        pub let thumbnail: String

        init(
            initID: UInt64,
            initlink: String,
            initbatch: UInt32,
            initsequence: UInt16,
            initlimit: UInt16
        ) {
            self.id = initID
            self.link = initlink
            self.batch = initbatch
            self.sequence = initsequence
            self.limit = initlimit
            self.attended = false

            self.name = "St Louis Blues"
            self.description = "St Louis Blues NFTs"
            self.thumbnail = initlink
        }

        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.NFTCollectionData>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: BLUES.CollectionStoragePath,
                        publicPath: BLUES.CollectionPublicPath,
                        providerPath: /private/BLUESCollection,
                        publicCollection: Type<&BLUES.Collection{BLUES.BLUESCollectionPublic}>(),
                        publicLinkedType: Type<&BLUES.Collection{BLUES.BLUESCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&BLUES.Collection{BLUES.BLUESCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Provider, MetadataViews.ResolverCollection}>(),
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                            return <-BLUES.createEmptyCollection()
                        })
                    )
            }

            return nil
        }
    }

    pub resource interface BLUESCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun markAttendance(id: UInt64, attendance:Bool) : Bool
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT

        pub fun borrowBLUES(id: UInt64): &BLUES.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow BLUES reference: The ID of the returned reference is incorrect"
            }
        }
    }

    pub resource Collection: BLUESCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID)!

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @BLUES.NFT
            let id: UInt64 = token.id

            let oldToken <- self.ownedNFTs[id] <- token
            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun markAttendance(id: UInt64, attendance:Bool) : Bool {
            let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let ref2 =  ref as! &BLUES.NFT
            ref2.attended = attendance

            return ref2.attended
        }

        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        destroy() {
            destroy self.ownedNFTs
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let bluesNFT = nft as! &BLUES.NFT
            return bluesNFT as &AnyResource{MetadataViews.Resolver}
        }

        pub fun borrowBLUES(id: UInt64): &BLUES.NFT? {
            if self.ownedNFTs[id] == nil {
                return nil
            }
            else {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &BLUES.NFT
            }
        }

    }

    pub fun createEmptyCollection(): @BLUES.Collection {
        return <- create Collection()
    }

    pub resource NFTMinter {
        pub var minterID: UInt64

        init() {
            self.minterID = 0
        }

        pub fun mintNFT(glink: String, gbatch: UInt32, glimit: UInt16, gsequence:UInt16): @NFT {
            let tokenID = (UInt64(gbatch) << 32) | (UInt64(glimit) << 16) | UInt64(gsequence)
            var newNFT <- create NFT(initID: tokenID, initlink: glink, initbatch: gbatch, initsequence: gsequence, initlimit: glimit)

            self.minterID= tokenID

            BLUES.totalSupply = BLUES.totalSupply + UInt64(1)

            return <-newNFT
        }
    }

	init() {
        self.CollectionStoragePath = /storage/BLUESCollection
        self.CollectionPublicPath = /public/BLUESCollection
        self.MinterStoragePath = /storage/BLUESMinter

        self.totalSupply = 0

        self.account.save(<-self.createEmptyCollection(), to: self.CollectionStoragePath)
        self.account.link<&{BLUES.BLUESCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(
            self.CollectionPublicPath,
            target: self.CollectionStoragePath
        )
        self.account.save(<-create NFTMinter(), to: self.MinterStoragePath)

        emit ContractInitialized()
	}
}

 "
-------
"import FungibleToken from 0xf233dcee88fe0abe
import FungibleTokenMetadataViews from 0xf233dcee88fe0abe
import MetadataViews from 0x1d7e57aa55817448
import Toucans from 0x577a3c409c5dcb5e
import ToucansTokens from 0x577a3c409c5dcb5e

pub contract brasil: FungibleToken {

    // The amount of tokens in existance
    pub var totalSupply: UFix64
    // nil if there is none
    pub let maxSupply: UFix64?

    // Paths
    pub let VaultStoragePath: StoragePath
    pub let ReceiverPublicPath: PublicPath
    pub let VaultPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath
    pub let AdministratorStoragePath: StoragePath

    // Events
    pub event TokensInitialized(initialSupply: UFix64)
    pub event TokensWithdrawn(amount: UFix64, from: Address?)
    pub event TokensDeposited(amount: UFix64, to: Address?)
    pub event TokensTransferred(amount: UFix64, from: Address, to: Address)
    pub event TokensMinted(amount: UFix64)
    pub event TokensBurned(amount: UFix64)

    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance, MetadataViews.Resolver {
        pub var balance: UFix64

        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)

            if let owner: Address = self.owner?.address {
                brasil.setBalance(address: owner, balance: self.balance)
            }
            return <- create Vault(balance: amount)
        }

        pub fun deposit(from: @FungibleToken.Vault) {
            let vault: @Vault <- from as! @Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)

            // We set the balance to 0.0 here so that it doesn't
            // decrease the totalSupply in the `destroy` function.
            vault.balance = 0.0
            destroy vault

            if let owner: Address = self.owner?.address {
                brasil.setBalance(address: owner, balance: self.balance)
            }
        }

        pub fun getViews(): [Type]{
            return [Type<FungibleTokenMetadataViews.FTView>(),
                    Type<FungibleTokenMetadataViews.FTDisplay>(),
                    Type<FungibleTokenMetadataViews.FTVaultData>()]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<FungibleTokenMetadataViews.FTView>():
                    return FungibleTokenMetadataViews.FTView(
                        ftDisplay: self.resolveView(Type<FungibleTokenMetadataViews.FTDisplay>()) as! FungibleTokenMetadataViews.FTDisplay?,
                        ftVaultData: self.resolveView(Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
                    )
                case Type<FungibleTokenMetadataViews.FTDisplay>():
                    let media = MetadataViews.Media(
                            file: MetadataViews.HTTPFile(
                            url: "https://nftstorage.link/ipfs/bafkreihc3newdiaydwjat3hrhhdvup3foa4rcfc6obvshlyno4iibo6are"
                        ),
                        mediaType: "image"
                    )
                    let bannerMedia = MetadataViews.Media(
                            file: MetadataViews.HTTPFile(
                            url: "https://nftstorage.link/ipfs/bafybeic5wfn62cghy65n4xzp5jws6b2l7kbntfqc33z3hmvj7uwhb7pala"
                        ),
                        mediaType: "image"
                    )
                    let medias = MetadataViews.Medias([media, bannerMedia])
                    return FungibleTokenMetadataViews.FTDisplay(
                        name: "brasil",
                        symbol: "BR",
                        description: "Moeda @FlowBrasilChain",
                        externalURL: MetadataViews.ExternalURL("instagram.com/flowbrasilchain"),
                        logos: medias,
                        socials: {
                            "twitter": MetadataViews.ExternalURL("flowbrasilchain"),
                            "discord": MetadataViews.ExternalURL("emeraldcity")
                        }
                    )
                case Type<FungibleTokenMetadataViews.FTVaultData>():
                    return FungibleTokenMetadataViews.FTVaultData(
                        storagePath: brasil.VaultStoragePath,
                        receiverPath: brasil.ReceiverPublicPath,
                        metadataPath: brasil.VaultPublicPath,
                        providerPath: /private/brasilVault,
                        receiverLinkedType: Type<&Vault{FungibleToken.Receiver}>(),
                        metadataLinkedType: Type<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(),
                        providerLinkedType: Type<&Vault{FungibleToken.Provider}>(),
                        createEmptyVaultFunction: (fun (): @Vault {
                            return <- brasil.createEmptyVault()
                        })
                    )
            }
            return nil
        }

        init(balance: UFix64) {
            self.balance = balance
        }

        destroy() {
            emit TokensBurned(amount: self.balance)
            brasil.totalSupply = brasil.totalSupply - self.balance
        }
    }

    pub fun createEmptyVault(): @Vault {
        return <- create Vault(balance: 0.0)
    }

    pub resource Minter: Toucans.Minter {
        pub fun mint(amount: UFix64): @Vault {
            post {
                brasil.maxSupply == nil || brasil.totalSupply <= brasil.maxSupply!:
                    "Exceeded the max supply of tokens allowd."
            }
            brasil.totalSupply = brasil.totalSupply + amount
            emit TokensMinted(amount: amount)
            return <- create Vault(balance: amount)
        }
    }

    // We follow this pattern of storage
    // so the (potentially) huge dictionary
    // isn't loaded when the contract is imported
    pub resource Administrator {
        // This is an experimental index and should
        // not be used for anything official
        // or monetary related
        access(self) let balances: {Address: UFix64}

        access(contract) fun setBalance(address: Address, balance: UFix64) {
            self.balances[address] = balance
        }

        pub fun getBalance(address: Address): UFix64 {
            return self.balances[address] ?? 0.0
        }

        pub fun getBalances(): {Address: UFix64} {
            return self.balances
        }

        init() {
            self.balances = {}
        }
    }

    access(contract) fun setBalance(address: Address, balance: UFix64) {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        admin.setBalance(address: address, balance: balance)
    }

    pub fun getBalance(address: Address): UFix64 {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalance(address: address)
    }

    pub fun getBalances(): {Address: UFix64} {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalances()
    }

    init(
      _paymentTokenInfo: ToucansTokens.TokenInfo,
      _editDelay: UFix64,
      _minting: Bool,
      _initialTreasurySupply: UFix64,
      _maxSupply: UFix64?,
      _extra: {String: AnyStruct}
    ) {

      // Contract Variables
      self.totalSupply = 0.0
      self.maxSupply = _maxSupply

      // Paths
      self.VaultStoragePath = /storage/brasilVault
      self.ReceiverPublicPath = /public/brasilReceiver
      self.VaultPublicPath = /public/brasilMetadata
      self.MinterStoragePath = /storage/brasilMinter
      self.AdministratorStoragePath = /storage/brasilAdmin

      // Admin Setup
      let vault <- create Vault(balance: self.totalSupply)
      self.account.save(<- vault, to: self.VaultStoragePath)

      self.account.link<&Vault{FungibleToken.Receiver}>(
          self.ReceiverPublicPath,
          target: self.VaultStoragePath
      )

      self.account.link<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(
          self.VaultPublicPath,
          target: self.VaultStoragePath
      )

      if self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath) == nil {
        self.account.save(<- Toucans.createCollection(), to: Toucans.CollectionStoragePath)
        self.account.link<&Toucans.Collection{Toucans.CollectionPublic}>(Toucans.CollectionPublicPath, target: Toucans.CollectionStoragePath)
      }

      let toucansProjectCollection = self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath)!
      toucansProjectCollection.createProject(
        projectTokenInfo: ToucansTokens.TokenInfo("brasil", self.account.address, "BR", self.ReceiverPublicPath, self.VaultPublicPath, self.VaultStoragePath),
        paymentTokenInfo: _paymentTokenInfo,
        minter: <- create Minter(),
        editDelay: _editDelay,
        minting: _minting,
        initialTreasurySupply: _initialTreasurySupply,
        extra: _extra
      )

      self.account.save(<- create Administrator(), to: self.AdministratorStoragePath)

      // Events
      emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
 "
-------
"import FungibleToken from 0xf233dcee88fe0abe
import FungibleTokenMetadataViews from 0xf233dcee88fe0abe
import MetadataViews from 0x1d7e57aa55817448
import Toucans from 0x577a3c409c5dcb5e
import ToucansTokens from 0x577a3c409c5dcb5e

pub contract PublishedNFTDAO: FungibleToken {

    // The amount of tokens in existance
    pub var totalSupply: UFix64
    // nil if there is none
    pub let maxSupply: UFix64?

    // Paths
    pub let VaultStoragePath: StoragePath
    pub let ReceiverPublicPath: PublicPath
    pub let VaultPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath
    pub let AdministratorStoragePath: StoragePath

    // Events
    pub event TokensInitialized(initialSupply: UFix64)
    pub event TokensWithdrawn(amount: UFix64, from: Address?)
    pub event TokensDeposited(amount: UFix64, to: Address?)
    pub event TokensTransferred(amount: UFix64, from: Address, to: Address)
    pub event TokensMinted(amount: UFix64)
    pub event TokensBurned(amount: UFix64)

    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance, MetadataViews.Resolver {
        pub var balance: UFix64

        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)

            if let owner: Address = self.owner?.address {
                PublishedNFTDAO.setBalance(address: owner, balance: self.balance)
            }
            return <- create Vault(balance: amount)
        }

        pub fun deposit(from: @FungibleToken.Vault) {
            let vault: @Vault <- from as! @Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)

            // We set the balance to 0.0 here so that it doesn't
            // decrease the totalSupply in the `destroy` function.
            vault.balance = 0.0
            destroy vault

            if let owner: Address = self.owner?.address {
                PublishedNFTDAO.setBalance(address: owner, balance: self.balance)
            }
        }

        pub fun getViews(): [Type]{
            return [Type<FungibleTokenMetadataViews.FTView>(),
                    Type<FungibleTokenMetadataViews.FTDisplay>(),
                    Type<FungibleTokenMetadataViews.FTVaultData>()]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<FungibleTokenMetadataViews.FTView>():
                    return FungibleTokenMetadataViews.FTView(
                        ftDisplay: self.resolveView(Type<FungibleTokenMetadataViews.FTDisplay>()) as! FungibleTokenMetadataViews.FTDisplay?,
                        ftVaultData: self.resolveView(Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
                    )
                case Type<FungibleTokenMetadataViews.FTDisplay>():
                    let media = MetadataViews.Media(
                            file: MetadataViews.HTTPFile(
                            url: "https://nftstorage.link/ipfs/bafybeifsbguk3gajq6hwmoc772wldkadgxicbq6kodxp4vfp772helmwyq"
                        ),
                        mediaType: "image"
                    )
                    let bannerMedia = MetadataViews.Media(
                            file: MetadataViews.HTTPFile(
                            url: "https://nftstorage.link/ipfs/bafybeib4tiwtu437dttkerj62g6sdlnq2jprhvzpskiidh6ywadg3nikgm"
                        ),
                        mediaType: "image"
                    )
                    let medias = MetadataViews.Medias([media, bannerMedia])
                    return FungibleTokenMetadataViews.FTDisplay(
                        name: "Published NFT DAO",
                        symbol: "PAGE",
                        description: "Published NFT is a decentralized autonomous organization (DAO) that revolutionizes the world of eBook publishing by leveraging the power of Non-Fungible Tokens (NFTs). As an innovative platform, it allows users to engage in various activities such as donating, staking, and burning eBook NFTs to earn rewards in the form of page tokens.By acquiring eBook NFTs, users gain ownership of unique digital books, granting them exclusive rights and benefits within the ecosystem. These NFTs can be utilized in different ways, including staking them to earn page tokens. The more eBook NFTs staked, the greater the potential rewards.Page tokens hold significant value within the Published NFT DAO, as they serve as a voting mechanism. Holders of page tokens have the opportunity to influence important decisions regarding the platform's operations, such as the selection of new eBook titles, marketing strategies, and community initiatives. This democratic approach ensures that the DAO represents the collective interests of its members.Additionally, users have the option to burn their eBook NFTs, essentially removing them from circulation. In return for this action, they receive page tokens as a reward. Burning NFTs not only reduces the supply but also increases the scarcity and value of the remaining eBook NFTs held by the community.Published NFT empowers both eBook authors and readers, creating an inclusive ecosystem where creators are fairly compensated for their work and readers have a say in shaping the platform's direction. Through the use of NFTs, staking, burning, and page tokens, Published NFT establishes an innovative model that combines ownership, rewards, and community governance, ensuring a vibrant and engaging experience for all participants.",
                        externalURL: MetadataViews.ExternalURL("publishednft.io/"),
                        logos: medias,
                        socials: {
                            "twitter": MetadataViews.ExternalURL("publishednft"),
                            "discord": MetadataViews.ExternalURL("RHH5aH44k9")
                        }
                    )
                case Type<FungibleTokenMetadataViews.FTVaultData>():
                    return FungibleTokenMetadataViews.FTVaultData(
                        storagePath: PublishedNFTDAO.VaultStoragePath,
                        receiverPath: PublishedNFTDAO.ReceiverPublicPath,
                        metadataPath: PublishedNFTDAO.VaultPublicPath,
                        providerPath: /private/PublishedNFTDAOVault,
                        receiverLinkedType: Type<&Vault{FungibleToken.Receiver}>(),
                        metadataLinkedType: Type<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(),
                        providerLinkedType: Type<&Vault{FungibleToken.Provider}>(),
                        createEmptyVaultFunction: (fun (): @Vault {
                            return <- PublishedNFTDAO.createEmptyVault()
                        })
                    )
            }
            return nil
        }

        init(balance: UFix64) {
            self.balance = balance
        }

        destroy() {
            emit TokensBurned(amount: self.balance)
            PublishedNFTDAO.totalSupply = PublishedNFTDAO.totalSupply - self.balance
        }
    }

    pub fun createEmptyVault(): @Vault {
        return <- create Vault(balance: 0.0)
    }

    pub resource Minter: Toucans.Minter {
        pub fun mint(amount: UFix64): @Vault {
            post {
                PublishedNFTDAO.maxSupply == nil || PublishedNFTDAO.totalSupply <= PublishedNFTDAO.maxSupply!:
                    "Exceeded the max supply of tokens allowd."
            }
            PublishedNFTDAO.totalSupply = PublishedNFTDAO.totalSupply + amount
            emit TokensMinted(amount: amount)
            return <- create Vault(balance: amount)
        }
    }

    // We follow this pattern of storage
    // so the (potentially) huge dictionary
    // isn't loaded when the contract is imported
    pub resource Administrator {
        // This is an experimental index and should
        // not be used for anything official
        // or monetary related
        access(self) let balances: {Address: UFix64}

        access(contract) fun setBalance(address: Address, balance: UFix64) {
            self.balances[address] = balance
        }

        pub fun getBalance(address: Address): UFix64 {
            return self.balances[address] ?? 0.0
        }

        pub fun getBalances(): {Address: UFix64} {
            return self.balances
        }

        init() {
            self.balances = {}
        }
    }

    access(contract) fun setBalance(address: Address, balance: UFix64) {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        admin.setBalance(address: address, balance: balance)
    }

    pub fun getBalance(address: Address): UFix64 {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalance(address: address)
    }

    pub fun getBalances(): {Address: UFix64} {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalances()
    }

    init(
      _paymentTokenInfo: ToucansTokens.TokenInfo,
      _editDelay: UFix64,
      _minting: Bool,
      _initialTreasurySupply: UFix64,
      _maxSupply: UFix64?,
      _extra: {String: AnyStruct}
    ) {

      // Contract Variables
      self.totalSupply = 0.0
      self.maxSupply = _maxSupply

      // Paths
      self.VaultStoragePath = /storage/PublishedNFTDAOVault
      self.ReceiverPublicPath = /public/PublishedNFTDAOReceiver
      self.VaultPublicPath = /public/PublishedNFTDAOMetadata
      self.MinterStoragePath = /storage/PublishedNFTDAOMinter
      self.AdministratorStoragePath = /storage/PublishedNFTDAOAdmin

      // Admin Setup
      let vault <- create Vault(balance: self.totalSupply)
      self.account.save(<- vault, to: self.VaultStoragePath)

      self.account.link<&Vault{FungibleToken.Receiver}>(
          self.ReceiverPublicPath,
          target: self.VaultStoragePath
      )

      self.account.link<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(
          self.VaultPublicPath,
          target: self.VaultStoragePath
      )

      if self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath) == nil {
        self.account.save(<- Toucans.createCollection(), to: Toucans.CollectionStoragePath)
        self.account.link<&Toucans.Collection{Toucans.CollectionPublic}>(Toucans.CollectionPublicPath, target: Toucans.CollectionStoragePath)
      }

      let toucansProjectCollection = self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath)!
      toucansProjectCollection.createProject(
        projectTokenInfo: ToucansTokens.TokenInfo("PublishedNFTDAO", self.account.address, "PAGE", self.ReceiverPublicPath, self.VaultPublicPath, self.VaultStoragePath),
        paymentTokenInfo: _paymentTokenInfo,
        minter: <- create Minter(),
        editDelay: _editDelay,
        minting: _minting,
        initialTreasurySupply: _initialTreasurySupply,
        extra: _extra
      )

      self.account.save(<- create Administrator(), to: self.AdministratorStoragePath)

      // Events
      emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
 "
-------
"pub contract Utils {
  pub struct AddressNamePair {
    pub let address: Address
    pub let name: String

    init(address: Address, name: String) {
      self.address = address
      self.name = name
    }
  }

  pub fun convertStringToAddress(_ input: String): Address? {
    var address = input
    if input.utf8[1] == 120 {
      address = input.slice(from: 2, upTo: input.length)
    }
    var r: UInt64 = 0
    var bytes = address.decodeHex()

    while bytes.length > 0 {
      r = r + (UInt64(bytes.removeFirst()) << UInt64(bytes.length * 8))
    }

    return Address(r)
  }

  pub fun royaltyCutStringToUFix64(_ royaltyCut: String): UFix64 {
    var decimalPos = 0
    if royaltyCut[0] == "." {
      decimalPos = 1
    } else if royaltyCut[1] == "." {
      if royaltyCut[0] == "1" {
        // "1" in the first postiion must be 1.0 i.e. 100% cut
        return 1.0
      } else if royaltyCut[0] == "0" {
        decimalPos = 2
      }
    } else {
      // Invalid royalty value
      return 0.0
    }

    var royaltyCutStrLen = royaltyCut.length
    if royaltyCut.length > (8 + decimalPos) {
      // UFix64 is capped at 8 digits after the decimal
      // so truncate excess decimal values from the string
      royaltyCutStrLen = (8 + decimalPos)
    }
    let royaltyCutPercentValue = royaltyCut.slice(from: decimalPos, upTo: royaltyCutStrLen)
    var bytes = royaltyCutPercentValue.utf8
    var i = 0
    var cutValueInteger: UInt64 = 0
    var cutValueDivisor: UFix64 = 1.0
    let zeroAsciiIntValue: UInt64 = 48
    // First convert the string to a non-decimal Integer
    while i < bytes.length {
      cutValueInteger = (cutValueInteger * 10) + UInt64(bytes[i]) - zeroAsciiIntValue
      cutValueDivisor = cutValueDivisor * 10.0
      i = i + 1
    }

    // Convert the resulting Integer to a decimal in the range 0.0 - 0.99999999
    return (UFix64(cutValueInteger) / cutValueDivisor)
  }

  pub fun getMimeType(_ metadataFileType: String): String {
    switch metadataFileType {
      case "mp4":
      return "video/mp4"
      case "mov":
      return "video/quicktime"
      case "webm":
      return "video/webm"
      case "ogv":
      return "video/ogg"
      case "png":
      return "image/png"
      case "jpeg":
      return "image/jpeg"
      case "jpg":
      return "image/jpeg"
      case "gif":
      return "image/gif"
      case "webp":
      return "image/webp"
      case "svg":
      return "image/svg+xml"
      case "glb":
      return "model/gltf-binary"
      case "gltf":
      return "model/gltf+json"
      case "obj":
      return "model/obj"
      case "mtl":
      return "model/mtl"
      case "mp3":
      return "audio/mpeg"
      case "ogg":
      return "audio/ogg"
      case "oga":
      return "audio/ogg"
      case "wav":
      return "audio/wav"
      case "html":
      return "text/html"
    }
    return ""
  }
}"
-------
"//     _____                        __          __
//    / ___/____  ____ _____  _____/ /_  ____  / /_
//    \__ \/ __ \/ __ `/ __ \/ ___/ __ \/ __ \/ __/
//   ___/ / / / / /_/ / /_/ (__  ) / / / /_/ / /_
//  /____/_/ /_/\__,_/ .___/____/_/ /_/\____/\__/
//                  /_/
//
// The `Snapshot` contract provides the following features:
//  - Records all NFT information owned by an address at the time of execution (this is called a snapshot).
//  - Proves that an address owned a particular NFT for a specified time range (if it did, it returns its snapshot information).
//  - Displays a specific snapshot in a format of your choice.
//
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract Snapshot {

    // Paths to `Album` resource that store snapshots and path to `Admin` resource.
    pub let AlbumPublicPath: PublicPath
    pub let AlbumStoragePath: StoragePath
    pub let AdminStoragePath: StoragePath

    // Only allowed logic may be used when taking snapshots. This can be updated by `Admin`.
    pub var allowedLogicTypes: [Type]

    // `NFTInfo` is the unit of measure recorded in the snapshot.
    // `MetadataViews.Display` metadata, if any, will be stored.
    //  Depending on the logic, some may record whatever values they like in `extraMetadata`.
    pub struct NFTInfo {
        pub let collectionPublicPath: String
        pub let nftType: Type
        pub let nftID: UInt64
        pub let metadata: MetadataViews.Display?
        pub let extraMetadata: {String: AnyStruct}?

        init(
            collectionPublicPath: String,
            nftType: Type,
            nftID: UInt64,
            metadata: MetadataViews.Display?,
            extraMetadata: {String: AnyStruct}?
        ) {
            self.collectionPublicPath = collectionPublicPath
            self.nftType = nftType
            self.nftID = nftID
            self.metadata = metadata
            self.extraMetadata = extraMetadata
        }
    }

    // `ILogic` is the interface for the logic used to take snapshots.
    //  It returns `NFTInfo` instances held by a given address, keyed by the PublicPath of the respective Collection and the ID of the NFT.
    //  The primary implementation is provided in the `SnapshotLogic` contract, but it can be extended in the future.
    //  While anyone can define this implementation, it must be approved by the `Admin` to be used.
    pub struct interface ILogic {
        pub fun getOwnedNFTs(address: Address): {String: {UInt64: NFTInfo}}
    }

    // `IViewer` is the interface for generating arbitrary images, etc., based on snapshots.
    //  For instance, the `SnapshotViewer` contract offers an implementation that produces HTML.
    //  Anybody can create this implementation, and it doesn't require permission to use.
    pub struct interface IViewer {
        pub fun getView(snap: &Snap): AnyStruct
    }

    // `Snap` is a resource that aggregates `NFTInfo` instances,
    //  along with details like the time and logic when they were captured.
    pub resource Snap {
        pub let time: UFix64
        pub let ownerAddress: Address
        pub let ownedNFTs: {String: {UInt64: NFTInfo}}
        pub let logicType: Type

        init(
            time: UFix64,
            ownerAddress: Address,
            ownedNFTs: {String: {UInt64: NFTInfo}},
            logicType: Type
        ) {
            self.time = time
            self.ownerAddress = ownerAddress
            self.ownedNFTs = ownedNFTs
            self.logicType = logicType
        }
    }

    // `AlbumPublic` is an interface for publishing `Album` resources.
    //  Anyone can access the snapshot information, but cannot add or remove snapshots without permission.
    pub resource interface AlbumPublic {
        pub var snaps: @{UFix64: Snap}

        pub fun proofOfOwnership(
            startTime: UFix64,
            endTime: UFix64,
            collectionPublicPath: String,
            nftType: Type, nftID: UInt64, ownerAddress: Address
        ): &Snap?

        pub fun view(time: UFix64, viewer: {IViewer}): AnyStruct
    }

    // `Album` is a Collection-like resource for storing multiple snapshots (`Snap`).
    //  The key features of this contract are defined in this resource.
    pub resource Album: AlbumPublic {

        // Variable to store snapshots. Each snapshot is indexed by the block time at which it was taken.
        pub var snaps: @{UFix64: Snap}

        // Function to capture a snapshot.
        // The arguments include the address and the desired logic struct. The logic must be authorized.
        pub fun snapshot(address: Address, logic: {ILogic}) {
            pre {
                Snapshot.allowedLogicTypes.contains(logic.getType()): "Not allowed logic"
            }
            let time = getCurrentBlock().timestamp
            self.snaps[time] <-! create Snap(
                time: time,
                ownerAddress: address,
                ownedNFTs: logic.getOwnedNFTs(address: address),
                logicType: logic.getType()
            )
        }

        // This function enables you to verify if a specific address owned a particular NFT
        // within a specified start and end time range.
        // If a provable snapshot exists, it will be returned. Otherwise, nil is returned.
        pub fun proofOfOwnership(
            startTime: UFix64,
            endTime: UFix64,
            collectionPublicPath: String,
            nftType: Type,
            nftID: UInt64,
            ownerAddress: Address
        ): &Snap? {
            for time in self.snaps.keys {
                if (startTime > time || time > endTime) {
                    continue
                }
                let snap = &self.snaps[time] as? &Snap?
                if (
                    snap != nil &&
                    snap!.ownerAddress == ownerAddress &&
                    snap!.ownedNFTs[collectionPublicPath] != nil &&
                    snap!.ownedNFTs[collectionPublicPath]![nftID] != nil &&
                    snap!.ownedNFTs[collectionPublicPath]![nftID]!.nftType == nftType
                ) {
                    return snap
                }
            }
            return nil
        }

        // Function to display the contents of a snapshot.
        // For instance, it can be used to generate something akin to a family photo.
        pub fun view(time: UFix64, viewer: {IViewer}): AnyStruct {
            let snap = &self.snaps[time] as? &Snap?
            return viewer.getView(snap: snap!)
        }

        // Function to import a snapshot.
        pub fun import(snap: @Snap) {
            let time = snap.time
            self.snaps[time] <-! snap
        }

        // Function to export a snapshot.
        pub fun export(time: UFix64): @Snap {
            return <- self.snaps.remove(key: time)!
        }

        init() {
            self.snaps <- {}
        }

        destroy() {
            destroy self.snaps
        }
    }

    // `Admin` is a resource held by the administrator of this contract. It is used for maintaining logic.
    pub resource Admin {
        pub fun addLogic(logic: {ILogic}) {
            pre {
                !Snapshot.allowedLogicTypes.contains(logic.getType()): "Already exists"
            }
            Snapshot.allowedLogicTypes.append(logic.getType())
        }

        pub fun removeLogic(index: Int) {
            Snapshot.allowedLogicTypes.remove(at: index)
        }

        pub fun createAdmin(): @Admin {
            return <- create Admin()
        }
    }

    pub fun createEmptyAlbum(): @Album {
        return <- create Album()
    }

    init() {
        self.AlbumPublicPath = /public/SnapshotAlbum
        self.AlbumStoragePath = /storage/SnapshotAlbum
        self.AdminStoragePath = /storage/SnapshotAdmin
        self.allowedLogicTypes = []

        // The deployer of the contract will possess the `Admin` resource.
        self.account.save(<- create Admin(), to: self.AdminStoragePath)

        self.account.save(<- create Album(), to: self.AlbumStoragePath)
        self.account.link<&Album{AlbumPublic}>(self.AlbumPublicPath, target: self.AlbumStoragePath)
    }
}
"
-------
"pub contract StrikeNowData {

  //Should look like:
  // {
  //   "seriesId": "1",
  //   "seriesName": "UFC 292 Oezdemir vs. Smith",
  //   "seriesDescription": "UFC 292 Inaugral Launch",
  //   "eventId": "890",
  //   "season": "1",
  //   "eventTime": "1691694054.0",
  // }
  pub struct SeriesData {
    pub let seriesId: UInt32
    pub let seriesName: String
    pub let seriesDescription: String
    pub let eventId: UInt32
    pub let eventTime: UFix64
    pub let season: String
    pub let fights: {UInt32: FightData}
    pub let metadataRaw: {String: String}
    pub let fightsRaw: [{String: String}]?

    init(seriesId: UInt32, metadata: {String: String}, fights: [{String: String}]?) {
      pre {
        metadata["seriesName"] != nil: "Key seriesName is required on SeriesData"
        metadata["seriesDescription"] != nil: "Key seriesDescription is required on SeriesData"
        metadata["eventId"] != nil: "Key eventId is required on SeriesData"
        metadata["season"] != nil: "Key season is required on SeriesData"
        metadata["eventTime"] != nil: "Key eventTime is required on SeriesData"
      }

      self.seriesId = seriesId
      self.seriesName = metadata["seriesName"]!
      self.seriesDescription = metadata["seriesDescription"]!
      self.eventId = UInt32.fromString(metadata["eventId"]!)!
      self.season = metadata["season"]!
      self.eventTime = UFix64.fromString(metadata["eventTime"]!)!
      self.metadataRaw = metadata
      self.fightsRaw = fights
      self.fights = {}

      if fights != nil && fights?.length! > 0 {
        for fight in fights! {
          let id = UInt32.fromString(fight["fightId"]!)!
          self.fights[id] = StrikeNowData.FightData(fightId: id, input: fight)
        }
      }
    }
  }

  // Should look like:
  // {
  //   "fightId": "7441",
  //   "fightName": "Oezdemir vs Smith",
  //   "cardSegment": "Main",
  //   "weightClass": "Featherweight",
  //   "weightClassDescription": "136-145",
  //   "city": "Moncton",
  //   "state": "New Brunswick",
  //   "country": "Canada",
  // }
  pub struct FightData {
    pub let fightId: UInt32
    pub let fightName: String
    pub let cardSegment: String
    pub let weightClass: String
    pub let weightClassDescription: String
    pub let city: String
    pub let state: String
    pub let country: String

    init(fightId: UInt32, input: {String: String})
    {
      pre {
        input["fightName"] != nil: "Key fightName required on FightData"
        input["cardSegment"] != nil: "Key cardSegment required on FightData"
        input["weightClass"] != nil: "Key weightClass required on FightData"
        input["weightClassDescription"] != nil: "Key weightClassDescription required on FightData"
        input["city"] != nil: "Key city required on FightData"
        input["state"] != nil: "Key state required on FightData"
        input["country"] != nil: "Key country required on FightData"
      }
      self.fightId = fightId
      self.fightName = input["fightName"]!
      self.cardSegment = input["cardSegment"]!
      self.weightClass = input["weightClass"]!
      self.weightClassDescription = input["weightClassDescription"]!
      self.city = input["city"]!
      self.state = input["state"]!
      self.country = input["country"]!
    }
  }

  //Should look like this
  // {
  //   "setId": "1",
  //   "fightId": "7441",
  //   "fighterId": "5",
  //   "fighterName": "Test Oezdemir",
  //   "fightDescription": "Oezdemir faces Smith for the title",
  //   "thumbnail": "0",
  //   "mainAsset": "1",
  //   "opponentName": "Test Smith",
  //   "editionName": "Snapshot",
  //   "price": "5.75",
  //   "externalURL": "http://ufc292.oezdemir.strikenow.com"
  // }
  pub struct SetData {
    pub let setId: UInt32
    pub let seriesId: UInt32
    pub let editionName: String
    pub let price: UFix64
    pub let fightId: UInt32
    pub let thumbnail: UInt32
    pub let fighterName: String
    pub let fightDescription: String
    pub let opponentName: String
    pub let externalURL: String?
    pub let fightResult: FightResult?
    pub let assets: {UInt32: AssetData}?
    pub let fightResultRaw: {String: String}?
    pub let assetsRaw: [{String: String}]?
    pub let metadataRaw: {String: String}

    init(
      setId: UInt32,
      seriesId: UInt32,
      metadata: {String: String},
      assets: [{String: String}]?,
      result: {String: String}?) {

      pre {
        metadata["fightId"] != nil: "Key fightId required on SetData"
        metadata["editionName"] != nil: "Key editionName required on SetData"
        metadata["price"] != nil: "Key price required on SetData"
        metadata["thumbnail"] != nil: "Key thumbnail required on SetData"
        metadata["fighterName"] != nil: "Key fighterName required on SetData"
        metadata["fightDescription"] != nil: "Key fightDescription required on SetData"
        metadata["opponentName"] != nil: "Key opponentName required on SetData"
      }

      self.setId = setId
      self.seriesId = seriesId
      self.fightResultRaw = result
      self.assetsRaw = assets
      self.metadataRaw = metadata
      self.fightId = UInt32.fromString(metadata["fightId"]!)!
      self.editionName = metadata["editionName"]!
      self.price = UFix64.fromString(metadata["price"]!)!
      self.thumbnail = UInt32.fromString(metadata["thumbnail"]!)!
      self.fighterName = metadata["fighterName"]!
      self.fightDescription = metadata["fightDescription"]!
      self.opponentName = metadata["opponentName"]!
      self.externalURL = metadata["externalURL"]

      if assets != nil && assets?.length! > 0 {
        let output: {UInt32: AssetData} = {}
        for asset in assets! {
          let id = UInt32.fromString(asset["assetId"]!)!
          output[id] = StrikeNowData.AssetData(id, asset)
        }
        self.assets = output
      } else {
        self.assets = nil
      }

      if result != nil && result?.length! > 0 {
        self.fightResult = StrikeNowData.FightResult(result!)
      } else {
        self.fightResult = nil
      }
    }
  }

  // Should look like
  // {
  //   "assetURI": "https://testasset.com/assetOne",
  //   "assetFileType": "mp4",
  //   "assetId": "0"
  // }
  pub struct AssetData {
    pub let assetId: UInt32
    pub let assetURI: String
    pub let assetFileType: String
    pub let rawData: {String: String}

    init(assetId: UInt32, rawData: {String: String}) {
      pre {
        rawData["assetURI"] != nil: "Key assetURI required on AssetData"
        rawData["assetFileType"] != nil: "Key assetFileType required on AssetData"
      }
      self.assetId = assetId
      self.rawData = rawData
      self.assetURI = rawData["assetURI"]!
      self.assetFileType = rawData["assetFileType"]!
    }
  }

  // Should look like this
  // {
  //   "outcome": "Win", //THIS MUST BE EITHER "Win" or "Lose"
  //   "grade": "Gold",
  //   "method": "Submission",
  //   "endingRound": "3",
  //   "endingTime": "1:24",
  //   "endingPosition":"From Back Control",
  //   "edingSubmission":"Rear Naked Choke",
  //   "wins": "32",
  //   "losses": "15",
  //   "draws": "0",
  //   "knockdowns": "0",
  //   "strikeAttempts": "45",
  //   "strikesLanded": "32",
  //   "significantStrikes": "3",
  //   "takedownAttempts": "5",
  //   "takedownsLanded": "2",
  //   "submissionAttempts": "3",
  // }
  pub struct FightResult {
    pub let outcome: String
    pub let won: Bool
    pub let grade: String
    pub let method: String
    pub let endingRound: UInt16
    pub let endingTime: String
    pub let endingStrike: String?
    pub let endingTarget: String?
    pub let endingPosition: String?
    pub let endingSubmission: String?
    pub let wins: UInt16
    pub let losses: UInt16
    pub let draws: UInt16
    pub let strikeAttempts: UInt16
    pub let strikesLanded: UInt16
    pub let significantStrikes: UInt16
    pub let takedownAttempts: UInt16
    pub let takedownsLanded: UInt16
    pub let submissionAttempts: UInt16
    pub let knockdowns: UInt16

    init(input: {String: String}) {
      pre {
        input["outcome"] != nil: "Got nil for outcome"
        input["grade"] != nil: "Key grade required on FightResult"
        input["method"] != nil: "Key method required on FightResult"
        input["endingRound"] != nil: "Key endingRound required on FightResult"
        input["endingTime"] != nil: "Key endingTime required on FightResult"
        input["wins"] != nil: "Key wins required on FightResult"
        input["losses"] != nil: "Key losses required on FightResult"
        input["draws"] != nil: "Key draws required on FightResult"
        input["strikeAttempts"] != nil: "Key strikeAttempts required on FightResult"
        input["strikesLanded"] != nil: "Key strikesLanded required on FightResult"
        input["significantStrikes"] != nil: "Key significantStrikes required on FightResult"
        input["takedownAttempts"] != nil: "Key takedownAttempts required on FightResult"
        input["takedownsLanded"] != nil: "Key takedownsLanded required on FightResult"
        input["submissionAttempts"] != nil: "Key submissionAttempts required on FightResult"
        input["knockdowns"] != nil: "Key knockdowns required on FightResult"
      }

      self.outcome = input["outcome"]!
      self.won = self.outcome.toLower() == "win" || self.outcome.toLower() == "won"
        || self.outcome.toLower() == "victory"
      self.grade = input["grade"]!
      self.method = input["method"]!
      self.endingRound = UInt16.fromString(input["endingRound"]!)!
      self.endingTime = input["endingTime"]!
      self.endingStrike = input["endingStrike"]
      self.endingTarget = input["endingTarget"]
      self.endingPosition = input["endingPosition"]
      self.endingSubmission = input["endingSubmission"]
      self.wins = UInt16.fromString(input["wins"]!)!
      self.losses = UInt16.fromString(input["losses"]!)!
      self.draws = UInt16.fromString(input["draws"]!)!
      self.strikeAttempts = UInt16.fromString(input["strikeAttempts"]!)!
      self.strikesLanded = UInt16.fromString(input["strikesLanded"]!)!
      self.significantStrikes = UInt16.fromString(input["significantStrikes"]!)!
      self.takedownAttempts = UInt16.fromString(input["takedownAttempts"]!)!
      self.takedownsLanded = UInt16.fromString(input["takedownsLanded"]!)!
      self.submissionAttempts = UInt16.fromString(input["submissionAttempts"]!)!
      self.knockdowns = UInt16.fromString(input["knockdowns"]!)!
    }
  }

  //Should look like this
  // let input = {
  //   "collectionName": "UFC Strike Now",
  //   "collectionDescription": "UFC Strike Now: Commemorate The Fight. Win The Night.",
  //   "externalURL": "https://ufcstrike.com/now",
  //   "squareImageURL": "https://media.gigantik.io/ufc/square.png",
  //   "squareImageMediaType": "image/png",
  //   "bannerImageURL": "https://media.gigantik.io/ufc/banner.png",
  //   "bannerImageMediaType": "image/png"
  // }
  // let socials = {
  //   "instagram": "https://instagram.com/ufcstrike",
  //   "twitter": "https://twitter.com/UFCStrikeNFT",
  //   "discord": "https://discord.gg/UFCStrike"
  // }
  pub struct ConfigData {
    pub let collectionName: String
    pub let collectionDescription: String
    pub let externalURL: String
    pub let squareImageURL: String
    pub let squareImageMediaType: String
    pub let bannerImageURL: String
    pub let bannerImageMediaType: String
    pub let socials: { String: String }

    init(input: { String: String }, socials: { String: String }) {
      pre {
        input["collectionName"] != nil: "Key collectionName required on ConfigData"
        input["collectionDescription"] != nil: "Key collectionDescription required on ConfigData"
        input["externalURL"] != nil: "Key externalURL required on ConfigData"
        input["squareImageURL"] != nil: "Key squareImageURL required on ConfigData"
        input["squareImageMediaType"] != nil: "Key squareImageMediaType required on ConfigData"
        input["bannerImageURL"] != nil: "Key bannerImageURL required on ConfigData"
        input["bannerImageMediaType"] != nil: "Key bannerImageMediaType required on ConfigData"
      }

      self.collectionName = input["collectionName"]!
      self.collectionDescription = input["collectionDescription"]!
      self.externalURL = input["externalURL"]!
      self.squareImageURL = input["squareImageURL"]!
      self.squareImageMediaType = input["squareImageMediaType"]!
      self.bannerImageURL = input["bannerImageURL"]!
      self.bannerImageMediaType = input["bannerImageMediaType"]!
      self.socials = socials
    }
  }

  //Struct designed to capture a pending mint request along with the requester
  //address. Mints stores in format:
  //{
  //  SET_ID: AMOUNT_FROM_SET_TO_MINT
  //}
  pub struct MintSet {
    pub var address: Address
    pub var setIdToAmountMap: { UInt32: UInt32 }

    init(address: Address, setIdToAmountMap: { UInt32: UInt32 }) {
      self.address = address
      self.setIdToAmountMap = setIdToAmountMap
    }

    //Returns the number of mints expressed in the set
    pub fun getAmountInSet(): UInt32 {
      var amount: UInt32 = 0
      for set in self.setIdToAmountMap.keys {
        amount = amount + self.setIdToAmountMap[set]!
      }
      return amount
    }

    //Take a sequence of entries from the current mint set, removing them from the set
    //afterward. The format returned matches the format by which mint claims are
    //submitted:
    //{
    //  SET_ID: AMOUNT_FROM_SET_TO_MINT
    //}
    pub fun takeMintListAndDeplete(amountToTake: UInt32): { UInt32: UInt32 } {
      pre {
        amountToTake <= self.getAmountInSet(): "Mint set does not have sufficient entries"
      }

      var amountRemaining = amountToTake
      let list: { UInt32: UInt32 } = {}
      for set in self.setIdToAmountMap.keys {
        let amountCurrent = self.setIdToAmountMap[set]!
        if amountRemaining >= amountCurrent {
          list[set] = amountCurrent
          self.setIdToAmountMap[set] = 0
          amountRemaining = amountRemaining - amountCurrent
        }
        else {
          list[set] = amountRemaining
          self.setIdToAmountMap[set] = self.setIdToAmountMap[set]! - amountRemaining
          amountRemaining = 0
        }

        if amountRemaining == 0 {
          break
        }
      }
      return list
    }
  }
}"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import LostAndFound from 0x473d6a2c37eab5be
import DapperUtilityCoin from 0xead892083b3e2c6c
import FlowUtilityToken from 0xead892083b3e2c6c
import ScopedFTProviders from 0x3c1c4b041ad18279

import NFTStorefrontV2 from 0x3cdbb3d569211ff3
import Filter from 0x3c1c4b041ad18279
import FlowtyUtils from 0x3cdbb3d569211ff3

pub contract Offers {
	pub let OffersStoragePath: StoragePath
	pub let OffersPublicPath: PublicPath

	pub let AdminStoragePath: StoragePath
	pub let AdminPublicPath: PublicPath

	// Events
	pub event StorefrontInitialized(storefrontResourceID: UInt64)
	pub event OfferCancelled(storefrontAddress: Address, offerResourceID: UInt64)
	pub event OfferCompleted(storefrontAddress: Address, offerResourceID: UInt64)
	pub event OfferCreated(
		storefrontAddress: Address,
		offerResourceID: UInt64,
		offeredAmount: UFix64,
		paymentTokenType: String,
		numAcceptable: Int,
		expiry: UInt64,
		taker: Address?,
		payer: Address
	)

	pub event OfferAccepted(
		storefrontAddress: Address,
		offerResourceID: UInt64,
		offeredAmount: UFix64,
		paymentTokenType: String,
		numAcceptable: Int,
		remaining: Int,
		taker: Address,
		nftID: UInt64,
		nftType: String
	)

	pub event MissingReceiver(receiver: Address, amount: UFix64)

	pub resource interface StorefrontPublic {
		pub fun borrowOffer(offerResourceID: UInt64): &Offer{OfferPublic}?
		pub fun acceptOffer(offerResourceID: UInt64, nft: @NonFungibleToken.NFT, receiver: Capability<&{FungibleToken.Receiver}>)
		pub fun getIDs(): [UInt64]
		pub fun cleanupOffer(_ id: UInt64)
		access(contract) fun adminRemoveListing(offerResourceID: UInt64)
	}

	pub resource Storefront: StorefrontPublic {
		access(self) let offers: @{UInt64: Offer}

		pub fun createOffer(
			offeredAmount: UFix64,
			paymentTokenType: Type,
			filterGroup: Filter.FilterGroup,
			expiry: UInt64,
			numAcceptable: Int,
			taker: Address?,
			paymentProvider: Capability<&{FungibleToken.Provider, FungibleToken.Balance, FungibleToken.Receiver}>,
			nftReceiver: Capability<&{NonFungibleToken.CollectionPublic}>
		) {
			pre {
				paymentProvider.check(): "payment provider is invalid"
				nftReceiver.check(): "nftReceiver is invalid"
				Offers.validateFilterGroup(filterGroup): "invalid filter provided"
				filterGroup.filters.length == 1: "filter group must be a length of one filter"
			}

			// wrap out FT provider to keep it safe!
			// the provider should expire after when the offer expires, and it should only be
			// permitted to withdraw (offeredAmount * numAcceptable) tokens
			let allowance = ScopedFTProviders.AllowanceFilter(offeredAmount * UFix64(numAcceptable))
			let scopedProvider <- ScopedFTProviders.createScopedFTProvider(provider: paymentProvider, filters: [allowance], expiration: UFix64(expiry))

			let paymentTokenType = scopedProvider.getProviderType()

			let commission = NFTStorefrontV2.getFee(p: offeredAmount, t: paymentTokenType)

			let offer <- create Offer(
				offeredAmount: offeredAmount,
				paymentTokenType: paymentTokenType,
				commission: commission,
				filterGroup: filterGroup,
				expiry: expiry,
				numAcceptable: numAcceptable,
				taker: taker,
				paymentProvider: <-scopedProvider,
				nftReceiver: nftReceiver
			)

			emit OfferCreated(
				storefrontAddress: self.owner!.address,
				offerResourceID: offer.uuid,
				offeredAmount: offeredAmount,
				paymentTokenType: paymentTokenType.identifier,
				numAcceptable: numAcceptable,
				expiry: expiry,
				taker: taker,
				payer: paymentProvider.address
			)

			self.offers[offer.uuid] <-! offer
		}

		pub fun acceptOffer(offerResourceID: UInt64, nft: @NonFungibleToken.NFT, receiver: Capability<&{FungibleToken.Receiver}>) {
			let offer = (&self.offers[offerResourceID] as &Offer?) ?? panic("offer not found")

			let nftType = nft.getType()
			let nftID = nft.id

			emit OfferAccepted(
				storefrontAddress: self.owner!.address,
				offerResourceID: offer.uuid,
				offeredAmount: offer.details.offeredAmount,
				paymentTokenType: offer.details.paymentTokenType.identifier,
				numAcceptable: offer.details.numAcceptable,
				remaining: offer.details.remaining - 1,
				taker: receiver.address,
				nftID: nft.id,
				nftType: nftType.identifier
			)

			offer.acceptOffer(nft: <-nft, receiver: receiver)
			if offer.details.remaining < 1 {
				emit OfferCompleted(storefrontAddress: self.owner!.address, offerResourceID: offer.uuid)
				let o <- self.offers.remove(key: offerResourceID)
				destroy o
			}

			// clean up any listings that belong to this NFT on the NFTStorefront as well
			let cap = getAccount(receiver.address).getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath)
			if cap.check() {
				let s = cap.borrow()!
				var existingListingIDs = s.getExistingListingIDs(
					nftType: nftType,
					nftID: nftID
				)
				for listingID in existingListingIDs {
					s.cleanupInvalidListing(listingResourceID: listingID)
				}
			}
		}

		pub fun cancelOffer(offerResourceID: UInt64) {
			let offer <- self.offers.remove(key: offerResourceID) ?? panic("no offer with that resource ID")
			emit OfferCancelled(storefrontAddress: self.owner!.address, offerResourceID: offer.uuid)
			destroy offer
		}

		pub fun cleanupOffer(_ id: UInt64) {
			pre {
				self.offers.containsKey(id): "offer does not exist"
			}

		 	let offer <- self.offers.remove(key: id) ?? panic("offer not found")
			assert(!offer.isValid(), message: "cannot cleanup offers that are still valid")
			destroy offer
		}

		pub fun borrowOffer(offerResourceID: UInt64): &Offer{OfferPublic}? {
			return &self.offers[offerResourceID] as &Offer{OfferPublic}?
		}

		pub fun getIDs(): [UInt64] {
			return self.offers.keys
		}



		access(contract) fun adminRemoveListing(offerResourceID: UInt64) {
			pre {
				self.offers[offerResourceID] != nil: "could not find listing with given id"
			}
			let listing <- self.offers.remove(key: offerResourceID)
					?? panic("missing offer")
			let offerDetails = listing.getDetails()
			destroy listing
		}

		init() {
			self.offers <- {}
			emit StorefrontInitialized(storefrontResourceID: self.uuid)
		}

		destroy() {
			destroy self.offers
		}
	}

	pub struct OfferCut {
		pub let offeredAmount: UFix64
		pub let receiver: Capability<&{FungibleToken.Receiver}>

		init(offeredAmount: UFix64, receiver: Capability<&{FungibleToken.Receiver}>) {
			self.offeredAmount = offeredAmount
			self.receiver = receiver
		}
	}

	pub struct Details {
		pub let offerResourceID: UInt64
		pub let offeredAmount: UFix64
		pub let paymentTokenType: Type
		pub let filterGroup: Filter.FilterGroup
		pub let expiry: UInt64

		// Only provide for private offers
		pub let taker: Address?

		// how many times can this offer be accepted
		pub let numAcceptable: Int
		pub var remaining: Int

		// generated by offer creation
		pub let commission: UFix64

		init(
			offerResourceID: UInt64,
			offeredAmount: UFix64,
			paymentTokenType: Type,
			commission: UFix64,
			filterGroup: Filter.FilterGroup,
			expiry: UInt64,
			numAcceptable: Int,
			taker: Address?
		) {
			pre {
				numAcceptable > 0: "must be acceptable at least once"
			}

			self.offerResourceID = offerResourceID
			self.offeredAmount = offeredAmount
			self.paymentTokenType = paymentTokenType
			self.filterGroup = filterGroup
			self.expiry = expiry
			self.commission = commission
			self.taker = taker
			self.numAcceptable = numAcceptable

			self.remaining = numAcceptable
		}

		access(contract) fun decrementRemaining() {
			pre {
				self.remaining > 0: "cannot decrement below 0"
			}

			self.remaining = self.remaining - 1
		}
	}

	pub resource interface OfferPublic {
		access(contract) fun acceptOffer(nft: @NonFungibleToken.NFT, receiver: Capability<&{FungibleToken.Receiver}>)
		pub fun getDetails(): Details
		pub fun isValid(): Bool
		pub fun isMatch(_ nft: &NonFungibleToken.NFT): Bool
	}

	pub resource Offer: OfferPublic {
		access(contract) let details: Details
		access(contract) let provider: @ScopedFTProviders.ScopedFTProvider
		access(contract) let receiver: Capability<&{NonFungibleToken.CollectionPublic}>

		access(contract) fun acceptOffer(nft: @NonFungibleToken.NFT, receiver: Capability<&{FungibleToken.Receiver}>) {
			pre {
				self.details.filterGroup.match(nft: &nft as &NonFungibleToken.NFT): "nft does not pass filter check"
				self.details.taker == nil || receiver.address == self.details.taker: "this offer is meant for a private taker"
				self.isValid(): "offer is not valid"
			}
			let fees = NFTStorefrontV2.getPaymentCuts(r: receiver, n: &nft as &NonFungibleToken.NFT, p: self.details.offeredAmount, tokenType: self.details.paymentTokenType)
			let mpFee = NFTStorefrontV2.getFee(p: self.details.offeredAmount, t: self.details.paymentTokenType)

			let payment <- self.provider.withdraw(amount: self.details.offeredAmount)
			assert(payment.getType() == self.details.paymentTokenType, message: "mismatched payment token type")
			assert(payment.balance == self.details.offeredAmount, message: "mismatched payment amount")

			let depositor = Offers.account.borrow<&LostAndFound.Depositor>(from: LostAndFound.DepositorStoragePath)!
			let mpPayment <- payment.withdraw(amount: mpFee)
			let mpReceiver = NFTStorefrontV2.getCommissionReceiver(t: self.details.paymentTokenType)
			mpReceiver.borrow()!.deposit(from: <-mpPayment)

			let isDapperToken = self.details.paymentTokenType == Type<@DapperUtilityCoin.Vault>() || self.details.paymentTokenType == Type<@FlowUtilityToken.Vault>()
			for f in fees {
				if isDapperToken && !f.receiver.check() {
					emit MissingReceiver(receiver: f.receiver.address, amount: f.amount)
					continue
				}
				let paymentCut <- payment.withdraw(amount: f.amount)
				FlowtyUtils.trySendFungibleTokenVault(vault: <-paymentCut, receiver: f.receiver, depositor: depositor)
			}

			if payment.balance > 0.0 {
				// send whatever is left to the maker who is the last receiver
				FlowtyUtils.trySendFungibleTokenVault(vault: <-payment, receiver: fees[fees.length-1].receiver, depositor: depositor)
			} else {
				destroy payment
			}

			self.details.decrementRemaining()
			self.receiver.borrow()!.deposit(token: <- nft)
		}

		pub fun isMatch(_ nft: &NonFungibleToken.NFT): Bool {
			return self.details.filterGroup.match(nft: nft)
		}

		pub fun getDetails(): Details {
			return self.details
		}

		pub fun isValid(): Bool {
			if !self.provider.check() {
				return false
			}

			if !self.provider.canWithdraw(self.details.offeredAmount) {
				return false
			}

			if self.details.remaining < 1 {
				return false
			}

			if UInt64(getCurrentBlock().timestamp) > self.details.expiry {
				return false
			}

			return true
		}

		init(
			offeredAmount: UFix64,
			paymentTokenType: Type,
			commission: UFix64,
			filterGroup: Filter.FilterGroup,
			expiry: UInt64,
			numAcceptable: Int,
			taker: Address?,
			paymentProvider: @ScopedFTProviders.ScopedFTProvider,
			nftReceiver: Capability<&{NonFungibleToken.CollectionPublic}>
		) {
			self.details = Details(
				offerResourceID: self.uuid,
				offeredAmount: offeredAmount,
				paymentTokenType: paymentTokenType,
				commission: commission,
				filterGroup: filterGroup,
				expiry: expiry,
				numAcceptable: numAcceptable,
				taker: taker
			)

			self.provider <- paymentProvider
			self.receiver = nftReceiver
		}

		destroy () {
			destroy self.provider
		}
	}

	pub resource interface AdminPublic {
		pub fun isValidFilter(_ t: Type): Bool
		pub fun getFilters(): {Type: Bool}
	}

	pub resource interface AdminCleaner {
		pub fun removeListing(storefrontAddress: Address, offerResourceID: UInt64)
	}

	pub resource Admin: AdminPublic, AdminCleaner {
		pub let permittedFilters: {Type: Bool}

		init() {
			self.permittedFilters = {}
		}

		pub fun addPermittedFilter(_ t: Type) {
			pre {
				t.isSubtype(of: Type<{Filter.NFTFilter}>())
			}

			self.permittedFilters[t] = true
		}

		pub fun removeFilter(_ t: Type) {
			self.permittedFilters.remove(key: t)
		}

		pub fun isValidFilter(_ t: Type): Bool {
			return self.permittedFilters[t] != nil && self.permittedFilters[t]!
		}

		pub fun getFilters(): {Type: Bool} {
			return self.permittedFilters
		}

		pub fun removeListing(storefrontAddress: Address, offerResourceID: UInt64) {
			let acct = getAccount(storefrontAddress)
			let storefront = acct.getCapability<&Storefront{StorefrontPublic}>(Offers.OffersPublicPath)
			storefront.borrow()!.adminRemoveListing(offerResourceID: offerResourceID)
		}
	}

	pub fun getValidFilters(): {Type: Bool} {
		return Offers.borrowPublicAdmin().getFilters()
	}

	pub fun createStorefront(): @Storefront {
		return <- create Storefront()
	}

	pub fun borrowPublicAdmin(): &Admin{AdminPublic} {
		return self.account.borrow<&Admin{AdminPublic}>(from: Offers.AdminStoragePath)!
	}

	pub fun validateFilterGroup(_ fg: Filter.FilterGroup): Bool {
		let a = Offers.borrowPublicAdmin()
		for f in fg.filters {
			if !a.isValidFilter(f.getType()) {
				return false
			}
		}
		return true
	}

	pub fun getCommissionRate(paymentTokenType: Type, amount: UFix64): UFix64 {
		return 0.025
	}

	init() {
		self.OffersStoragePath = StoragePath(identifier: "Offers".concat(self.account.address.toString()))!
		self.OffersPublicPath = PublicPath(identifier: "Offers".concat(self.account.address.toString()))!

		self.AdminPublicPath = /public/offersAdmin
		self.AdminStoragePath = /storage/offersAdmin

		self.account.save(<- create Admin(), to: self.AdminStoragePath)
	}
}
 "
-------
"import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import LostAndFound from 0x473d6a2c37eab5be

import DapperUtilityCoin from 0xead892083b3e2c6c
import FlowUtilityToken from 0xead892083b3e2c6c

import Permitted from 0x3cdbb3d569211ff3
import FlowtyUtils from 0x3cdbb3d569211ff3
import RoyaltiesOverride from 0x3cdbb3d569211ff3

/// NFTStorefrontV2
///
/// A general purpose sale support contract for NFTs that implement the Flow NonFungibleToken standard.
///
/// Each account that wants to list NFTs for sale installs a Storefront,
/// and lists individual sales within that Storefront as Listings.
/// There is one Storefront per account, it handles sales of all NFT types
/// for that account.
///
/// Each Listing can have one or more "cuts" of the sale price that
/// goes to one or more addresses. Cuts can be used to pay listing fees
/// or other considerations.
/// Each Listing can include a commission amount that is paid to whoever facilitates
/// the purchase. The seller can also choose to provide an optional list of marketplace
/// receiver capabilities. In this case, the commission amount must be transferred to
/// one of the capabilities in the list.
///
/// Each NFT may be listed in one or more Listings, the validity of each
/// Listing can easily be checked.
///
/// Purchasers can watch for Listing events and check the NFT type and
/// ID to see if they wish to buy the listed item.
/// Marketplaces and other aggregators can watch for Listing events
/// and list items of interest.
///
pub contract NFTStorefrontV2 {

		pub event StorefrontInitialized(storefrontResourceID: UInt64)

		pub event StorefrontDestroyed(storefrontResourceID: UInt64)

		/// ListingAvailable
		/// A listing has been created and added to a Storefront resource.
		/// The Address values here are valid when the event is emitted, but
		/// the state of the accounts they refer to may change outside of the
		/// NFTStorefrontV2 workflow, so be careful to check when using them.
		///
		pub event ListingAvailable(
				storefrontAddress: Address,
				listingResourceID: UInt64,
				nftType: String,
				nftUUID: UInt64,
				nftID: UInt64,
				salePaymentVaultType: String,
				salePrice: UFix64,
				customID: String?,
				commissionAmount: UFix64,
				commissionReceivers: [Address]?,
				expiry: UInt64,
				buyer: Address?,
				providerAddress: Address
		)

		/// ListingCompleted
		/// The listing has been resolved. It has either been purchased, removed or destroyed.
		///
		pub event ListingCompleted(
				listingResourceID: UInt64,
				storefrontResourceID: UInt64,
				storefrontAddress: Address?,
				purchased: Bool,
				nftType: String,
				nftUUID: UInt64,
				nftID: UInt64,
				salePaymentVaultType: String,
				salePrice: UFix64,
				customID: String?,
				commissionAmount: UFix64,
				commissionReceiver: Address?,
				expiry: UInt64,
				buyer: Address?
		)

		/// left here for legacy reasons, we do not use it.
		pub event UnpaidReceiver()

		/// MissingReceiver
		pub event MissingReceiver(receiver: Address, amount: UFix64)

		/// StorefrontStoragePath
		/// The location in storage that a Storefront resource should be located.
		pub let StorefrontStoragePath: StoragePath

		/// StorefrontPublicPath
		/// The public location for a Storefront link.
		pub let StorefrontPublicPath: PublicPath

		pub let AdminStoragePath: StoragePath

		access(contract) let CommissionRecipients: {Type: Address}

		/// SaleCut
		/// A struct representing a recipient that must be sent a certain amount
		/// of the payment when a token is sold.
		///
		pub struct SaleCut {
				/// The receiver for the payment.
				/// Note that we do not store an address to find the Vault that this represents,
				/// as the link or resource that we fetch in this way may be manipulated,
				/// so to find the address that a cut goes to you must get this struct and then
				/// call receiver.borrow()!.owner.address on it.
				/// This can be done efficiently in a script.
				pub let receiver: Capability<&{FungibleToken.Receiver}>

				/// The amount of the payment FungibleToken that will be paid to the receiver.
				pub let amount: UFix64

				/// initializer
				///
				init(receiver: Capability<&{FungibleToken.Receiver}>, amount: UFix64) {
						self.receiver = receiver
						self.amount = amount
				}
		}


		/// ListingDetails
		/// A struct containing a Listing's data.
		///
		pub struct ListingDetails {
				pub var storefrontID: UInt64
				/// Whether this listing has been purchased or not.
				pub var purchased: Bool
				/// The Type of the NonFungibleToken.NFT that is being listed.
				pub let nftType: Type
				/// The Resource ID of the NFT which can only be set in the contract
				pub let nftUUID: UInt64
				/// The unique identifier of the NFT that will get sell.
				pub let nftID: UInt64
				/// The Type of the FungibleToken that payments must be made in.
				pub let salePaymentVaultType: Type
				/// The amount that must be paid in the specified FungibleToken.
				pub let salePrice: UFix64
				/// This specifies the division of payment between recipients.
				pub let saleCuts: [SaleCut]
				/// Allow different dapp teams to provide custom strings as the distinguisher string
				/// that would help them to filter events related to their customID.
				pub var customID: String?
				/// Commission available to be claimed by whoever facilitates the sale.
				pub let commissionAmount: UFix64
				/// Expiry of listing
				pub let expiry: UInt64
				/// Optional specified purchasing address for private listings
				pub let buyer: Address?

				/// Irreversibly set this listing as purchased.
				///
				access(contract) fun setToPurchased() {
						self.purchased = true
				}

				access(contract) fun setCustomID(customID: String?){
						self.customID = customID
				}

				/// Initializer
				///
				init (
						nftType: Type,
						nftUUID: UInt64,
						nftID: UInt64,
						salePaymentVaultType: Type,
						saleCuts: [SaleCut],
						storefrontID: UInt64,
						customID: String?,
						commissionAmount: UFix64,
						expiry: UInt64,
						buyer: Address?
				) {
						pre {
							// Validate the expiry
							expiry > UInt64(getCurrentBlock().timestamp) : "Expiry should be in the future"
							// Validate the length of the sale cut
							saleCuts.length > 0: "Listing must have at least one payment cut recipient"
						}
						self.storefrontID = storefrontID
						self.purchased = false
						self.nftType = nftType
						self.nftUUID = nftUUID
						self.nftID = nftID
						self.salePaymentVaultType = salePaymentVaultType
						self.customID = customID
						self.commissionAmount = commissionAmount
						self.expiry = expiry
						self.saleCuts = saleCuts
						self.buyer = buyer

						// Calculate the total price from the cuts
						var salePrice = commissionAmount
						// Perform initial check on capabilities, and calculate sale price from cut amounts.

						for cut in self.saleCuts {
							// Add the cut amount to the total price
							salePrice = salePrice + cut.amount
						}
						assert(salePrice > 0.0, message: "Listing must have non-zero price")

						// Store the calculated sale price
						self.salePrice = salePrice
				}
		}

		pub resource interface ListingPublic {
				pub fun borrowNFT(): &NonFungibleToken.NFT?

				/// purchase
				/// Purchase the listing, buying the token.
				/// This pays the beneficiaries and returns the token to the buyer.
				///
				pub fun purchase(
						payment: @FungibleToken.Vault,
						commissionRecipient: Capability<&{FungibleToken.Receiver}>?,
						privateListingAcceptor: &Storefront{PrivateListingAcceptor}
				): @NonFungibleToken.NFT

				/// getDetails
				/// Fetches the details of the listing.
				pub fun getDetails(): ListingDetails

				/// getAllowedCommissionReceivers
				/// Fetches the allowed marketplaces capabilities or commission receivers.
				/// If it returns `nil` then commission is up to grab by anyone.
				pub fun getAllowedCommissionReceivers(): [Capability<&{FungibleToken.Receiver}>]?

				pub fun isValid(): Bool
		}

		pub resource Listing: ListingPublic {
				access(self) let details: ListingDetails

				access(contract) let nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>

				access(contract) let marketplacesCapability: [Capability<&{FungibleToken.Receiver}>]?

				pub fun borrowNFT(): &NonFungibleToken.NFT? {
						let ref = self.nftProviderCapability.borrow()!.borrowNFT(id: self.details.nftID)
						if ref.isInstance(self.details.nftType) && ref.id == self.details.nftID {
								return ref as! &NonFungibleToken.NFT
						}
						return nil
				}

				pub fun getDetails(): ListingDetails {
						return self.details
				}

				/// getAllowedCommissionReceivers
				/// Fetches the allowed marketplaces capabilities or commission receivers.
				/// If it returns `nil` then commission is up to grab by anyone.
				pub fun getAllowedCommissionReceivers(): [Capability<&{FungibleToken.Receiver}>]? {
						return self.marketplacesCapability
				}

				/// purchase
				/// Purchase the listing, buying the token.
				/// This pays the beneficiaries and commission to the facilitator and returns extra token to the buyer.
				/// This also cleans up duplicate listings for the item being purchased.
				pub fun purchase(
					payment: @FungibleToken.Vault,
					commissionRecipient: Capability<&{FungibleToken.Receiver}>?,
					privateListingAcceptor: &Storefront{PrivateListingAcceptor}
				): @NonFungibleToken.NFT {
						pre {
							self.details.purchased == false: "listing has already been purchased"
							payment.isInstance(self.details.salePaymentVaultType): "payment vault is not requested fungible token"
							payment.balance == self.details.salePrice: "payment vault does not contain requested price"
							self.details.expiry > UInt64(getCurrentBlock().timestamp): "Listing is expired"
							self.owner != nil : "Resource doesn't have the assigned owner"
							self.details.buyer == nil || self.details.buyer! == privateListingAcceptor.owner!.address: "incorrect buyer for private listing"
							commissionRecipient == nil || commissionRecipient!.address == NFTStorefrontV2.account.address: "invalid commission recipient"
						}

						post {
							Permitted.isPermitted(result): "type of nft is not permitted"
						}

						let tokenInfo = FlowtyUtils.getTokenInfo(self.details.salePaymentVaultType) ?? panic("unsupported payment token")

						// Make sure the listing cannot be purchased again.
						self.details.setToPurchased()

						if self.details.commissionAmount > 0.0 {
								// If commission recipient is nil, Throw panic.
								let commissionReceiver = commissionRecipient ?? panic("Commission recipient can't be nil")
								if self.marketplacesCapability != nil {
										var isCommissionRecipientHasValidType = false
										var isCommissionRecipientAuthorised = commissionReceiver.address == NFTStorefrontV2.account.address
										for cap in self.marketplacesCapability! {
												// Check 1: Should have the same type
												if cap.getType() == commissionReceiver.getType() {
														isCommissionRecipientHasValidType = true
														// Check 2: Should have the valid market address that holds approved capability.
														if cap.address == commissionReceiver.address && cap.check() {
																isCommissionRecipientAuthorised = true
																break
														}
												}
										}
										assert(isCommissionRecipientHasValidType, message: "Given recipient does not has valid type")
										assert(isCommissionRecipientAuthorised,	 message: "Given recipient has not authorised to receive the commission")
								}
								let commissionPayment <- payment.withdraw(amount: self.details.commissionAmount)
								let recipient = commissionReceiver.borrow() ?? panic("Unable to borrow the recipent capability")
								recipient.deposit(from: <- commissionPayment)
						}
						// Fetch the token to return to the purchaser.
						let nft <-self.nftProviderCapability.borrow()!.withdraw(withdrawID: self.details.nftID)
						// Neither receivers nor providers are trustworthy, they must implement the correct
						// interface but beyond complying with its pre/post conditions they are not gauranteed
						// to implement the functionality behind the interface in any given way.
						// Therefore we cannot trust the Collection resource behind the interface,
						// and we must check the NFT resource it gives us to make sure that it is the correct one.
						assert(nft.isInstance(self.details.nftType), message: "withdrawn NFT is not of specified type")
						assert(nft.id == self.details.nftID, message: "withdrawn NFT does not have specified ID")

						// Fetch the duplicate listing for the given NFT
						// Access the StoreFrontManager resource reference to remove the duplicate listings if purchase would happen successfully.
						let storeFrontPublicRef = self.owner!.getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath)
																				.borrow() ?? panic("Unable to borrow the storeFrontManager resource")
						let duplicateListings = storeFrontPublicRef.getDuplicateListingIDs(nftType: self.details.nftType, nftID: self.details.nftID, listingID: self.uuid)

						// Let's force removal of the listing in this storefront for the NFT that is being purchased.
						for listingID in duplicateListings {
							storeFrontPublicRef.cleanup(listingResourceID: listingID)
						}

						let depositor = NFTStorefrontV2.account.borrow<&LostAndFound.Depositor>(from: LostAndFound.DepositorStoragePath)!
						let isDapperToken = self.details.salePaymentVaultType == Type<@DapperUtilityCoin.Vault>() || self.details.salePaymentVaultType == Type<@FlowUtilityToken.Vault>()
						for cut in self.details.saleCuts {
							if isDapperToken && !cut.receiver.check() {
								emit MissingReceiver(receiver: cut.receiver.address, amount: cut.amount)
								continue
							}
							let paymentCut <- payment.withdraw(amount: cut.amount)
							// assert(false, message: "".concat(paymentCut.getType().identifier.concat(" ").concat(paymentCut.balance.toString().concat(" "))))
							FlowtyUtils.trySendFungibleTokenVault(vault: <-paymentCut, receiver: cut.receiver, depositor: depositor)
						}

						if payment.balance > 0.0 {
							// send whatever is left to the seller who is the last receiver
							FlowtyUtils.trySendFungibleTokenVault(vault: <-payment, receiver: self.details.saleCuts[self.details.saleCuts.length-1].receiver, depositor: depositor)
						} else {
							destroy payment
						}

						// If the listing is purchased, we regard it as completed here.
						// Otherwise we regard it as completed in the destructor.
						emit ListingCompleted(
							listingResourceID: self.uuid,
							storefrontResourceID: self.details.storefrontID,
							storefrontAddress: self.owner?.address,
							purchased: self.details.purchased,
							nftType: self.details.nftType.identifier,
							nftUUID: self.details.nftUUID,
							nftID: self.details.nftID,
							salePaymentVaultType: self.details.salePaymentVaultType.identifier,
							salePrice: self.details.salePrice,
							customID: self.details.customID,
							commissionAmount: self.details.commissionAmount,
							commissionReceiver: self.details.commissionAmount != 0.0 ? commissionRecipient!.address : nil,
							expiry: self.details.expiry,
							buyer: privateListingAcceptor.owner?.address
						)

						return <-nft
				}

				pub fun isValid(): Bool {
					if UInt64(getCurrentBlock().timestamp) > self.details.expiry {
						return false
					}

					if !self.nftProviderCapability.check() {
						return false
					}

					let collection = self.nftProviderCapability.borrow()!
					let ids = collection.getIDs()
					if !ids.contains(self.details.nftID) {
						return false
					}

					let nft = collection.borrowNFT(id: self.details.nftID)
					if nft.getType() != self.details.nftType || nft.uuid != self.details.nftUUID || nft.id != self.details.nftID {
						return false
					}

					return true
				}

				/// destructor
				///
				destroy () { }

				/// initializer
				///
				init (
					nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,
					nftType: Type,
					nftUUID: UInt64,
					nftID: UInt64,
					salePaymentVaultType: Type,
					saleCuts: [SaleCut],
					marketplacesCapability: [Capability<&{FungibleToken.Receiver}>]?,
					storefrontID: UInt64,
					customID: String?,
					commissionAmount: UFix64,
					expiry: UInt64,
					buyer: Address?
				) {
						// Store the sale information
						self.details = ListingDetails(
							nftType: nftType,
							nftUUID: nftUUID,
							nftID: nftID,
							salePaymentVaultType: salePaymentVaultType,
							saleCuts: saleCuts,
							storefrontID: storefrontID,
							customID: customID,
							commissionAmount: commissionAmount,
							expiry: expiry,
							buyer: buyer
						)

						// Store the NFT provider
						self.nftProviderCapability = nftProviderCapability
						self.marketplacesCapability = marketplacesCapability

						// Check that the provider contains the NFT.
						// We will check it again when the token is sold.
						// We cannot move this into a function because initializers cannot call member functions.
						let provider = self.nftProviderCapability.borrow()
						assert(provider != nil, message: "cannot borrow nftProviderCapability")

						// This will precondition assert if the token is not available.
						 let nft = provider!.borrowNFT(id: self.details.nftID)
						assert(nft.isInstance(self.details.nftType), message: "token is not of specified type")
						assert(nft.id == self.details.nftID, message: "token does not have specified ID")
				}
		}

		/// StorefrontManager
		/// An interface for adding and removing Listings within a Storefront,
		/// intended for use by the Storefront's owner
		///
		pub resource interface StorefrontManager {
				/// createListing
				/// Allows the Storefront owner to create and insert Listings.
				///
				pub fun createListing(
					nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,
					paymentReceiver: Capability<&{FungibleToken.Receiver}>,
					nftType: Type,
					nftID: UInt64,
					salePaymentVaultType: Type,
					price: UFix64,
					customID: String?,
					expiry: UInt64,
					buyer: Address?
				): UInt64

				/// removeListing
				/// Allows the Storefront owner to remove any sale listing, acepted or not.
				///
				pub fun removeListing(listingResourceID: UInt64)
		}

		/// StorefrontPublic
		/// An interface to allow listing and borrowing Listings, and purchasing items via Listings
		/// in a Storefront.
		///
		pub resource interface StorefrontPublic {
			pub fun getListingIDs(): [UInt64]
			pub fun getDuplicateListingIDs(nftType: Type, nftID: UInt64, listingID: UInt64): [UInt64]
			pub fun borrowListing(listingResourceID: UInt64): &Listing{ListingPublic}?
			pub fun cleanupExpiredListings(fromIndex: UInt64, toIndex: UInt64)
			access(contract) fun cleanup(listingResourceID: UInt64)
			pub fun getExistingListingIDs(nftType: Type, nftID: UInt64): [UInt64]
			pub fun cleanupPurchasedListings(listingResourceID: UInt64)
			pub fun cleanupInvalidListing(listingResourceID: UInt64)
			access(contract) fun adminRemoveListing(listingResourceID: UInt64)
		}

		/// PrivateListingAcceptor
		/// Interface for accepting a private listing
		///
		/// Importantly, we will need to ensure that our Storefront is checking
		/// the entire type (&Storefront{PrivateListingAcceptor}) otherwise malicious actors might
		/// be able to impersonate a buyer.
		pub resource interface PrivateListingAcceptor {
						// Simple function just to ensure that we don't have an empty interface.
						// we'll use this method when purchasing a private listing to verify that a reference
						// is owned by the right address.
						pub fun getOwner(): Address?
		}

		/// Storefront
		/// A resource that allows its owner to manage a list of Listings, and anyone to interact with them
		/// in order to query their details and purchase the NFTs that they represent.
		///
		pub resource Storefront : StorefrontManager, StorefrontPublic, PrivateListingAcceptor {
				/// The dictionary of Listing uuids to Listing resources.
				access(contract) var listings: @{UInt64: Listing}
				/// Dictionary to keep track of listing ids for same NFTs listing.
				/// nftType.identifier -> nftID -> [listing resource ID]
				access(contract) var listedNFTs: {String: {UInt64 : [UInt64]}}

				pub fun getOwner(): Address? {
						return self.owner!.address
				}

				/// insert
				/// Create and publish a Listing for an NFT.
				///
				pub fun createListing(
					nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,
					paymentReceiver: Capability<&{FungibleToken.Receiver}>,
					nftType: Type,
					nftID: UInt64,
					salePaymentVaultType: Type,
					price: UFix64,
					customID: String?,
					expiry: UInt64,
					buyer: Address?
				 ): UInt64 {
						pre {
							paymentReceiver.check(): "payment receiver is invalid"
						}

						// Dapper has temporarily waived their dapper balance fee so this minumum is not needed for now.
						// if salePaymentVaultType == Type<@DapperUtilityCoin.Vault>() {
						// 	assert(price >= 0.75, message: "price must be at least 0.75")
						// }
						assert(price <= 10_000_000.0, message: "price must be less than 10 million")

						let commission = NFTStorefrontV2.getFee(p: price, t: salePaymentVaultType)

						let marketplacesCapability = [NFTStorefrontV2.getCommissionReceiver(t: salePaymentVaultType)]
						// let's ensure that the seller does indeed hold the NFT being listed
						let collectionRef = nftProviderCapability.borrow()
								?? panic("Could not borrow reference to collection")
						let nftRef = collectionRef.borrowNFT(id: nftID)
						assert(Permitted.isPermitted(nftRef), message: "type of nft is not permitted")

						let cuts = NFTStorefrontV2.getPaymentCuts(r: paymentReceiver, n: nftRef, p: price, tokenType: salePaymentVaultType)

						// Instead of letting an arbitrary value be set for the UUID of a given NFT, the contract
						// should fetch it itelf
						let uuid = nftRef.uuid
						let listing <- create Listing(
							nftProviderCapability: nftProviderCapability,
							nftType: nftType,
							nftUUID: uuid,
							nftID: nftID,
							salePaymentVaultType: salePaymentVaultType,
							saleCuts: cuts,
							marketplacesCapability: marketplacesCapability,
							storefrontID: self.uuid,
							customID: customID,
							commissionAmount: commission,
							expiry: expiry,
							buyer: buyer
						)

						let listingResourceID = listing.uuid
						let listingPrice = listing.getDetails().salePrice
						// Add the new listing to the dictionary.
						let oldListing <- self.listings[listingResourceID] <- listing
						destroy oldListing

						// Add the `listingResourceID` in the tracked listings.
						self.addDuplicateListing(nftIdentifier: nftType.identifier, nftID: nftID, listingResourceID: listingResourceID)

						// Scraping addresses from the capabilities to emit in the event.
						var allowedCommissionReceivers : [Address] = []
						for c in marketplacesCapability {
							allowedCommissionReceivers!.append(c.address)
						}

						emit ListingAvailable(
							storefrontAddress: self.owner?.address!,
							listingResourceID: listingResourceID,
							nftType: nftType.identifier,
							nftUUID: uuid,
							nftID: nftID,
							salePaymentVaultType: salePaymentVaultType.identifier,
							salePrice: listingPrice,
							customID: customID,
							commissionAmount: commission,
							commissionReceivers: allowedCommissionReceivers,
							expiry: expiry,
							buyer: buyer,
							providerAddress: nftProviderCapability.address
						)

						return listingResourceID
				}

				/// addDuplicateListing
				/// Helper function that allows to add duplicate listing of given nft in a map.
				///
				access(contract) fun addDuplicateListing(nftIdentifier: String, nftID: UInt64, listingResourceID: UInt64) {
						 if !self.listedNFTs.containsKey(nftIdentifier) {
								self.listedNFTs.insert(key: nftIdentifier, {nftID: [listingResourceID]})
						} else {
								if !self.listedNFTs[nftIdentifier]!.containsKey(nftID) {
										self.listedNFTs[nftIdentifier]!.insert(key: nftID, [listingResourceID])
								} else {
										self.listedNFTs[nftIdentifier]![nftID]!.append(listingResourceID)
								}
						}
				}

				/// removeDuplicateListing
				/// Helper function that allows to remove duplicate listing of given nft from a map.
				///
				access(contract) fun removeDuplicateListing(nftIdentifier: String, nftID: UInt64, listingResourceID: UInt64) {
					// Remove the listing from the listedNFTs dictionary.
					let listingIndex = self.listedNFTs[nftIdentifier]![nftID]!.firstIndex(of: listingResourceID) ?? panic("Should contain the index")
					self.listedNFTs[nftIdentifier]![nftID]!.remove(at: listingIndex)
				}

				pub fun removeListing(listingResourceID: UInt64) {
						let listing <- self.listings.remove(key: listingResourceID)
								?? panic("missing Listing")
						let listingDetails = listing.getDetails()

						if !listingDetails.purchased {
							emit ListingCompleted(
								listingResourceID: listingResourceID,
								storefrontResourceID: listingDetails.storefrontID,
								storefrontAddress: self.owner?.address,
								purchased: listingDetails.purchased,
								nftType: listingDetails.nftType.identifier,
								nftUUID: listingDetails.nftUUID,
								nftID: listingDetails.nftID,
								salePaymentVaultType: listingDetails.salePaymentVaultType.identifier,
								salePrice: listingDetails.salePrice,
								customID: listingDetails.customID,
								commissionAmount: listingDetails.commissionAmount,
								commissionReceiver: nil,
								expiry: listingDetails.expiry,
								buyer: nil
							)
						}

						self.removeDuplicateListing(nftIdentifier: listingDetails.nftType.identifier, nftID: listingDetails.nftID, listingResourceID: listingResourceID)
						// This will emit a ListingCompleted event.
						destroy listing
				}

				pub fun getListingIDs(): [UInt64] {
						return self.listings.keys
				}

				pub fun getExistingListingIDs(nftType: Type, nftID: UInt64): [UInt64] {
						if self.listedNFTs[nftType.identifier] == nil || self.listedNFTs[nftType.identifier]![nftID] == nil {
								return []
						}
						var listingIDs = self.listedNFTs[nftType.identifier]![nftID]!
						return listingIDs
				}

				pub fun cleanupPurchasedListings(listingResourceID: UInt64) {
						pre {
								self.listings[listingResourceID] != nil: "could not find listing with given id"
								self.borrowListing(listingResourceID: listingResourceID)!.getDetails().purchased == true: "listing not purchased yet"
						}
						let listing <- self.listings.remove(key: listingResourceID)!
						let listingDetails = listing.getDetails()
						self.removeDuplicateListing(nftIdentifier: listingDetails.nftType.identifier, nftID: listingDetails.nftID, listingResourceID: listingResourceID)

						destroy listing
				}

				pub fun getDuplicateListingIDs(nftType: Type, nftID: UInt64, listingID: UInt64): [UInt64] {
						var listingIDs = self.getExistingListingIDs(nftType: nftType, nftID: nftID)

						// Verify that given listing Id also a part of the `listingIds`
						let doesListingExist = listingIDs.contains(listingID)
						// Find out the index of the existing listing.
						if doesListingExist {
								var index: Int = 0
								for id in listingIDs {
										if id == listingID {
												break
										}
										index = index + 1
								}
								listingIDs.remove(at:index)
								return listingIDs
						}
					 return []
				}

				pub fun cleanupExpiredListings(fromIndex: UInt64, toIndex: UInt64) {
						pre {
								fromIndex <= toIndex : "Incorrect start index"
								Int(toIndex - fromIndex) < self.getListingIDs().length : "Provided range is out of bound"
						}
						var index = fromIndex
						let listingsIDs = self.getListingIDs()
						while index <= toIndex {
								// There is a possibility that some index may not have the listing.
								// becuase of that instead of failing the transaction, Execution moved to next index or listing.

								if let listing = self.borrowListing(listingResourceID: listingsIDs[index]) {
										if listing.getDetails().expiry <= UInt64(getCurrentBlock().timestamp) {
												self.cleanup(listingResourceID: listingsIDs[index])
										}
								}
								index = index + UInt64(1)
						}
				}

				access(contract) fun adminRemoveListing(listingResourceID: UInt64) {
					pre {
						self.listings[listingResourceID] != nil: "could not find listing with given id"
					}
					let listing <- self.listings.remove(key: listingResourceID)
							?? panic("missing Listing")
					let listingDetails = listing.getDetails()
					self.removeDuplicateListing(nftIdentifier: listingDetails.nftType.identifier, nftID: listingDetails.nftID, listingResourceID: listingResourceID)
					// This will emit a ListingCompleted event.
					destroy listing
				}

				/// borrowSaleItem
				/// Returns a read-only view of the SaleItem for the given listingID if it is contained by this collection.
				///
				pub fun borrowListing(listingResourceID: UInt64): &Listing{ListingPublic}? {
						 if self.listings[listingResourceID] != nil {
								return &self.listings[listingResourceID] as &Listing{ListingPublic}?
						} else {
								return nil
						}
				}

				/// cleanup
				/// Remove an listing, When given listing is duplicate or expired
				/// Only contract is allowed to execute it.
				///
				access(contract) fun cleanup(listingResourceID: UInt64) {
						pre {
								self.listings[listingResourceID] != nil: "could not find listing with given id"
						}
						let listing <- self.listings.remove(key: listingResourceID)!
						let listingDetails = listing.getDetails()
						self.removeDuplicateListing(nftIdentifier: listingDetails.nftType.identifier, nftID: listingDetails.nftID, listingResourceID: listingResourceID)

						destroy listing
				}

				/*
				Removes a listing that is not valid anymore. This could be because the listed nft is no longer in
				an account's storage, or it could be because the listing has expired or is otherwise completed.
				*/
				pub fun cleanupInvalidListing(listingResourceID: UInt64) {
					pre {
						self.listings[listingResourceID] != nil: "could not find listing with given id"
					}
					let listing <- self.listings.remove(key: listingResourceID)!
					assert(!listing.isValid(), message: "listing is valid and cannot be removed")

					let listingDetails = listing.getDetails()
					self.removeDuplicateListing(nftIdentifier: listingDetails.nftType.identifier, nftID: listingDetails.nftID, listingResourceID: listingResourceID)

					if !listingDetails.purchased {
						emit ListingCompleted(
							listingResourceID: listingResourceID,
							storefrontResourceID: listingDetails.storefrontID,
							storefrontAddress: self.owner?.address,
							purchased: listingDetails.purchased,
							nftType: listingDetails.nftType.identifier,
							nftUUID: listingDetails.nftUUID,
							nftID: listingDetails.nftID,
							salePaymentVaultType: listingDetails.salePaymentVaultType.identifier,
							salePrice: listingDetails.salePrice,
							customID: listingDetails.customID,
							commissionAmount: listingDetails.commissionAmount,
							commissionReceiver: nil,
							expiry: listingDetails.expiry,
							buyer: nil
						)
					}

					destroy listing
				}

				destroy () {
						destroy self.listings

						// Let event consumers know that this storefront will no longer exist
						emit StorefrontDestroyed(storefrontResourceID: self.uuid)
				}

				init () {
						self.listings <- {}
						self.listedNFTs = {}

						// Let event consumers know that this storefront exists
						emit StorefrontInitialized(storefrontResourceID: self.uuid)
				}
		}

		pub resource Admin {
			pub fun removeListing(addr: Address, listingResourceID: UInt64) {
				let s = getAccount(addr).getCapability<&Storefront{StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath).borrow() ?? panic("storefront not found")
				s.adminRemoveListing(listingResourceID: listingResourceID)
			}
		}

		pub fun getCommissionReceiver(t: Type): Capability<&{FungibleToken.Receiver}> {
			let tokenInfo = FlowtyUtils.getTokenInfo(t) ?? panic("invalid token type")
			return self.account.getCapability<&{FungibleToken.Receiver}>(tokenInfo.receiverPath)
		}

		pub fun createStorefront(): @Storefront {
			return <-create Storefront()
		}

		pub fun getFee(p: UFix64, t: Type): UFix64 {
			var fee = p * 0.02 // flowty has a fee of 2%
			var dwFee = 0.0
			// Dapper has temporarily waived their Dapper Balance fee
			// if t == Type<@DapperUtilityCoin.Vault>() {
			// 	dwFee = p * 0.01 // Dapper Wallet charges 1% to use DUC
			// 	dwFee = dwFee > 0.44 ? dwFee : 0.44 // but the minimum it charges is 0.44 DUC
			// }
			return fee + dwFee // flowty fee of 2% (dapper fee temporarily removed)
		}

		pub fun getPaymentCuts(r: Capability<&{FungibleToken.Receiver}>, n: &NonFungibleToken.NFT, p: UFix64, tokenType: Type): [SaleCut] {
			let t = n.getType()
			let ti = FlowtyUtils.getTokenInfo(tokenType) ?? panic("unsupported token type")

			let fee = NFTStorefrontV2.getFee(p: p, t: tokenType)
			var royalties: MetadataViews.Royalties? = nil

			// collection royalties may be overridden for various reasons such as misconfiguration.
			//
			// if they are not in the override, pull them and then we will calculate our cuts.
			if !RoyaltiesOverride.get(t) {
				royalties = n.resolveView(Type<MetadataViews.Royalties>()) as! MetadataViews.Royalties?
			}

			let cuts: [SaleCut] = []
			var remainder = p - fee
			if royalties != nil {
				for c in royalties!.getRoyalties() {
					// make sure that receivers are pointing where we expect them to
					let rec = getAccount(c.receiver.address).getCapability<&{FungibleToken.Receiver}>(ti.receiverPath)
					cuts.append(SaleCut(receiver: rec, amount: p * c.cut))
					remainder = remainder - c.cut * p
				}
			}

			cuts.append(SaleCut(receiver: r, amount: remainder))

			return cuts
		}

		pub fun getAddress(): Address {
			return self.account.address
		}

		init () {
			let pathIdentifier = "NFTStorefrontV2".concat(self.account.address.toString())
			let adminIdentifier = "NFTStorefrontV2Admin".concat(self.account.address.toString())

			self.StorefrontStoragePath = StoragePath(identifier: pathIdentifier)!
			self.StorefrontPublicPath = PublicPath(identifier: pathIdentifier)!
			self.AdminStoragePath = StoragePath(identifier: adminIdentifier)!

			self.CommissionRecipients = {}

			NFTStorefrontV2.account.save(<- create Admin(), to: self.AdminStoragePath)
		}
}
 "
-------
"import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import StrikeNowData from 0x4ea310a4f7197903
import DapperUtilityCoin from 0xead892083b3e2c6c
import Utils from 0x4ea310a4f7197903
import TokenForwarding from 0xe544175ee0461c4b

pub contract StrikeNow: NonFungibleToken {
  pub event ContractInitialized()
  pub event Minted(id: UInt64, setId: UInt32, seriesId: UInt32)
  pub event SeriesCreated(seriesId: UInt32)
  pub event SeriesSealed(seriesId: UInt32)
  pub event SeriesEditionsSetToProceedSerially(seriesId: UInt32)
  pub event SeriesMetadataUpdated(seriesId: UInt32)
  pub event SetCreated(seriesId: UInt32, setId: UInt32)
  pub event SetMetadataUpdated(seriesId: UInt32, setId: UInt32)
  pub event Withdraw(id: UInt64, from: Address?)
  pub event Deposit(id: UInt64, to: Address?)
  pub event NFTDestroyed(id: UInt64)
  pub event SetSaleStateChanged(id: UInt32, onSale: Bool)
  pub event SetEditionShuffleActivated(id: UInt32)
  pub event MintClaimSubmitted(by: Address)
  pub event MintOnDemandPurchased()

  pub let CollectionStoragePath: StoragePath
  pub let CollectionPublicPath: PublicPath
  pub let AdminStoragePath: StoragePath
  pub let AdminPrivatePath: PrivatePath
  pub let MinterPublicPath: PublicPath
  pub let VaultPublicPath: PublicPath

  pub var totalSupply: UInt64
  pub var numberEditionsMintedPerSet: {UInt32: UInt64}

  access(self) var setData: {UInt32: StrikeNowData.SetData}
  access(self) var seriesData: {UInt32: StrikeNowData.SeriesData}
  access(self) var series: @{UInt32: Series}
  access(self) var config: StrikeNowData.ConfigData
  access(self) var pendingMints: [StrikeNowData.MintSet]
  access(self) var failedMints: [StrikeNowData.MintSet]

  pub resource Series {
    pub let seriesId: UInt32
    pub var setIds: [UInt32]
    pub var sealed: Bool;
    pub var editionsProceedingSerially: Bool;
    pub let setEditionMap: {UInt32: {UInt32: UInt32}}
    pub let onSaleStateMap: {UInt32: Bool}

    init(
      seriesId: UInt32,
      metadata: {String: String},
      fights: [{String: String}]?) {

      self.seriesId = seriesId
      self.sealed = false
      self.setIds = []
      self.editionsProceedingSerially = false
      self.setEditionMap = {}
      self.onSaleStateMap = {}

      StrikeNow.seriesData[seriesId] = StrikeNowData.SeriesData(seriesId: seriesId, metadata: metadata, fights: fights)
      emit SeriesCreated(seriesId: seriesId)
    }

    pub fun updateSeriesMetadata(metadata: {String: String}, fights: [{String: String}]?) {
      pre {
        self.sealed == false: "The Series is permanently sealed. No metadata updates can be made."
      }
      let data = StrikeNowData.SeriesData(seriesId: self.seriesId, metadata: metadata, fights: fights)
      StrikeNow.seriesData[self.seriesId] = data
      emit SeriesMetadataUpdated(seriesId: self.seriesId)
    }

    pub fun addNftSet(
      setId: UInt32,
      metadata: {String: String},
      assets: [{String: String}]?,
      result: {String: String}?) {
      pre {
        self.setIds.contains(setId) == false: "The Set has already been added to the Series."
        self.sealed == false: "The Series is already sealed."
      }

      var newNFTSet = StrikeNowData.SetData(
        setId: setId,
        seriesId: self.seriesId,
        metadata: metadata,
        assets: assets,
        result: result
      )

      self.setIds.append(setId)
      self.setEditionMap[setId] = {}
      self.onSaleStateMap[setId] = false
      StrikeNow.numberEditionsMintedPerSet[setId] = 0
      StrikeNow.setData[setId] = newNFTSet

      emit SetCreated(seriesId: self.seriesId, setId: setId)
    }

    pub fun updateSetMetadata(
      setId: UInt32,
      metadata: {String: String},
      assets: [{String: String}]?,
      result: {String: String}?) {
      pre {
        self.sealed == false: "The Series is permanently sealed. No metadata updates can be made."
        self.setIds.contains(setId) == true: "The Set is not part of this Series."
      }

      let newSetMetadata = StrikeNowData.SetData(
        setId: setId,
        seriesId: self.seriesId,
        metadata: metadata,
        assets: assets,
        result: result
      )
      StrikeNow.setData[setId] = newSetMetadata

      emit SetMetadataUpdated(seriesId: self.seriesId, setId: setId)
    }

    pub fun mintStrikeNow(recipient: &{NonFungibleToken.CollectionPublic}, setId: UInt32) {
      pre {
        StrikeNow.numberEditionsMintedPerSet[setId] != nil: "The Set does not exist."
      }

      let index = StrikeNow.numberEditionsMintedPerSet[setId]! + 1
      let index32 = UInt32(index)
      recipient.deposit(token: <-create StrikeNow.NFT(setId: setId, tokenIndex: index32))

      let setMap = self.setEditionMap[setId]!
      setMap[index32] = self.editionsProceedingSerially ? index32 : 0
      self.setEditionMap[setId] = setMap
      StrikeNow.totalSupply = StrikeNow.totalSupply + 1
      StrikeNow.numberEditionsMintedPerSet[setId] = index
    }

    pub fun sealSeries() {
      pre {
        self.sealed == false: "The Series is already sealed"
      }
      self.sealed = true
      emit SeriesSealed(seriesId: self.seriesId)
    }

    pub fun setEditionsProceedingSerially() {
      pre {
        self.sealed == false: "The Series is sealed"
        self.editionsProceedingSerially == false: "Sets in this Series are already numbering editions serially"
      }
      self.editionsProceedingSerially = true
      emit SeriesEditionsSetToProceedSerially(seriesId: self.seriesId)
    }

    pub fun applyEditionsToRange(setId: UInt32, editionMap: {UInt32: UInt32}) {
      pre {
        self.sealed == false: "The Series is sealed"
      }

      let setMap = self.setEditionMap[setId]!
      for index in editionMap.keys {
        assert(setMap.containsKey(index), message: "Invalid token index ".concat(index.toString()))
        setMap[index] = editionMap[index]
      }
      self.setEditionMap[setId] = setMap

      emit SetEditionShuffleActivated(id: setId)
    }

    pub fun getEdition(setId: UInt32, tokenIndex: UInt32): UInt32 {
      pre {
        self.setEditionMap.containsKey(setId): "Invalid set id ".concat(setId.toString())
        self.setEditionMap[setId]!.containsKey(tokenIndex): "Invalid token index ".concat(tokenIndex.toString())
      }
      return self.setEditionMap[setId]![tokenIndex]!
    }

    pub fun setSaleState(setId: UInt32, onSale: Bool) {
      pre {
        self.setEditionMap.containsKey(setId): "Series ".concat(self.seriesId.toString()).concat(" does not contain set id ").concat(setId.toString())
      }
      self.onSaleStateMap[setId] = onSale

      emit SetSaleStateChanged(id: setId, onSale: onSale)
    }
  }

  pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
    pub let id: UInt64
    pub let tokenIndex: UInt32
    pub let setId: UInt32

    init(setId: UInt32, tokenIndex: UInt32) {
      self.id = self.uuid
      self.tokenIndex = tokenIndex
      self.setId = setId

      let seriesId = StrikeNow.getSetSeriesId(setId) !

      emit Minted(id: self.id, setId: setId, seriesId: seriesId)
    }

    pub fun getViews(): [Type] {
      return [
        Type<MetadataViews.Display>(),
        Type<MetadataViews.Edition>(),
        Type<MetadataViews.Editions>(),
        Type<MetadataViews.ExternalURL>(),
        Type<MetadataViews.NFTCollectionData>(),
        Type<MetadataViews.NFTCollectionDisplay>(),
        Type<MetadataViews.Serial>(),
        Type<MetadataViews.Traits>(),
        Type<MetadataViews.Medias>()
      ]
    }

    pub fun resolveView(_ view: Type): AnyStruct? {
      switch view {
        case Type<MetadataViews.Display>():
          let setData = StrikeNow.setData[self.setId]!
          let asset = StrikeNow.getAssetForId(setId: self.setId, assetId: setData.thumbnail)
          return MetadataViews.Display(
            name: setData.fighterName,
            description: setData.fightDescription,
            thumbnail: MetadataViews.HTTPFile(url: asset.assetURI)
          )
        case Type<MetadataViews.Serial>():
          return MetadataViews.Serial(self.id)
        case Type<MetadataViews.Edition>():
          return self.getEditionView()
        case Type<MetadataViews.Editions>():
          return [self.getEditionView()]
        case Type<MetadataViews.NFTCollectionData>():
          return MetadataViews.NFTCollectionData(
            storagePath: StrikeNow.CollectionStoragePath,
            publicPath: StrikeNow.CollectionPublicPath,
            providerPath: /private/StrikeNow,
            publicCollection: Type<&StrikeNow.Collection{StrikeNow.StrikeNowCollectionPublic, NonFungibleToken.CollectionPublic}>(),
            publicLinkedType: Type<&StrikeNow.Collection{StrikeNow.StrikeNowCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
            providerLinkedType: Type<&StrikeNow.Collection{StrikeNow.StrikeNowCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
            createEmptyCollectionFunction: (fun(): @NonFungibleToken.Collection {
              return <-StrikeNow.createEmptyCollection()
            })
          )
        case Type<MetadataViews.NFTCollectionDisplay> ():
          let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: StrikeNow.config.squareImageURL),
            mediaType: StrikeNow.config.squareImageMediaType
          )
          let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: StrikeNow.config.bannerImageURL),
            mediaType: StrikeNow.config.bannerImageMediaType
          )
          var socials: { String: MetadataViews.ExternalURL } = {}
          for social in StrikeNow.config.socials.keys {
            socials[social] = MetadataViews.ExternalURL(StrikeNow.config.socials[social]!)
          }
          return MetadataViews.NFTCollectionDisplay(
            name: StrikeNow.config.collectionName,
            description : StrikeNow.config.collectionDescription,
            externalURL : MetadataViews.ExternalURL(StrikeNow.config.externalURL),
            squareImage : squareImage,
            bannerImage : bannerImage,
            socials: socials
          )
        case Type<MetadataViews.ExternalURL>():
          if let externalURL = StrikeNow.setData[self.setId]?.externalURL {
            return MetadataViews.ExternalURL(externalURL)
          }
          return MetadataViews.ExternalURL("")
        case Type<MetadataViews.Traits>():
          let set = StrikeNow.setData[self.setId]!
          let series = StrikeNow.seriesData[set.seriesId]!
          let fight = StrikeNow.getFightForSet(self.setId)
          let traitDictionary: {String: AnyStruct} = {
            "Season": series.season,
            "Weight Class": fight.weightClass,
            "Athlete Name": set.fighterName,
            "Opponent Name": set.opponentName,
            "Matchup": fight.fightName,
            "Date": series.eventTime,
            "Event Name": series.seriesName,
            "Location": fight.city.concat(", ").concat(fight.state)
          }

          if set.fightResult != nil {
            let result = set.fightResult!
            traitDictionary["Winner"] = result.won ? set.fighterName : set.opponentName
            traitDictionary["Grade"] = result.grade
            traitDictionary["Defeated"] = result.won ? set.opponentName : set.fighterName
            traitDictionary["Round"] = result.endingRound
            traitDictionary["Fight Result"] = result.method
            traitDictionary["Time"] = result.endingTime
            traitDictionary["Strike Attempts"] = result.strikeAttempts
            traitDictionary["Strikes Landed"] = result.strikesLanded
            traitDictionary["Significant Strikes"] = result.significantStrikes
            traitDictionary["Takedown Attempts"] = result.takedownAttempts
            traitDictionary["Takedowns Landed"] = result.takedownsLanded
            traitDictionary["Submission Attempts"] = result.submissionAttempts
            traitDictionary["Knockdowns"] = result.knockdowns
          }
          return MetadataViews.dictToTraits(dict: traitDictionary, excludedNames: [])
        case Type<MetadataViews.Medias>():
          let assets = StrikeNow.setData[self.setId]!.assets
          if assets == nil {
            return MetadataViews.Medias(items: [])
          }

          let medias: [MetadataViews.Media] = []
          for asset in assets!.keys {
            let file = MetadataViews.HTTPFile(url: assets![asset]!.assetURI)
            let fileType = Utils.getMimeType(assets![asset]!.assetFileType.toLower())
            medias.append(MetadataViews.Media(file: file, mediaType: fileType))
          }
          return MetadataViews.Medias(items: medias)
      }
      return nil
    }

    access(self) fun getEditionView(): MetadataViews.Edition {
      let maxEditions = StrikeNow.getMaxEditions(setId: self.setId)
      let seriesId = StrikeNow.getSetSeriesId(self.setId)!
      let edition: UInt32 = StrikeNow.getEditionNumber(seriesId: seriesId, setId: self.setId, tokenIndex: self.tokenIndex)!
      let editionName = StrikeNow.setData[self.setId]!.editionName
      return MetadataViews.Edition(name: editionName, number: UInt64(edition), max: maxEditions)
    }

    destroy() {
      StrikeNow.totalSupply = StrikeNow.totalSupply - 1
      emit NFTDestroyed(id: self.id)
    }
  }

  pub resource Admin: StrikeNowMinterPublic {
    access(self) var vaultPath: PublicPath

    init(vaultPath: PublicPath) {
      self.vaultPath = vaultPath
    }

    pub fun addSeries(seriesId: UInt32, metadata: {String: String}, fights: [{String: String}]?) {
      pre {
        StrikeNow.series[seriesId] == nil: "Cannot add Series: The Series already exists"
      }

      var newSeries <-create Series(
        seriesId: seriesId,
        metadata: metadata,
        fights: fights
      )

      StrikeNow.series[seriesId] <-! newSeries
    }

    pub fun borrowSeries(seriesId: UInt32): &Series {
      pre {
        StrikeNow.series[seriesId] != nil: "Cannot borrow Series: The Series does not exist"
      }
      return (&StrikeNow.series[seriesId] as &Series?)!
    }

    pub fun borrowSet(setId: UInt32): &StrikeNowData.SetData {
      pre {
        StrikeNow.setData[setId] != nil: "The Set does not exist"
      }
      return &StrikeNow.setData[setId]! as &StrikeNowData.SetData
    }

    pub fun borrowSets(seriesId: UInt32): [&StrikeNowData.SetData] {
      pre {
        StrikeNow.series[seriesId] != nil: "The Series does not exist"
      }
      let sets:[&StrikeNowData.SetData] = []
      for setId in StrikeNow.series[seriesId]?.setIds! {
        sets.append(&StrikeNow.setData[setId]! as &StrikeNowData.SetData)
      }
      return sets
    }

    pub fun updateConfigData(input: { String: String }, socials: { String: String }) {
      StrikeNow.config = StrikeNowData.ConfigData(input, socials)
    }

    //Allow the admin to update the DUC vault with which to receive currency
    pub fun updateVaultPath(vaultPath: PublicPath) {
      self.vaultPath = vaultPath
    }

    pub fun getPendingMints(): [StrikeNowData.MintSet] {
      return StrikeNow.pendingMints
    }

    pub fun getFailedMints(): [StrikeNowData.MintSet] {
      return StrikeNow.failedMints
    }

    //Only this function on Admin will be exposed via a public capability
    //Takes a preloaded payment vault from a user, a map of sets to mint from,
    //and a collection reference in which to deposit minted NFTs.
    //If payment is in correct amount and denomination and NFTs are all set to
    //on sale, mints them in the amounts specified and deposits them in the user collection.
    pub fun mintStrikeNow(paymentVault: @FungibleToken.Vault, setIdToAmountMap: {UInt32: UInt32},
      recipient: &{NonFungibleToken.CollectionPublic}) {

      pre {
        StrikeNow.getSetsPurchasable(setIds: setIdToAmountMap.keys):
          "Not all of the specified sets are purchasable"
        paymentVault.balance == StrikeNow.getPriceForSetBatch(setIdToAmountMap: setIdToAmountMap):
          "Incorrect amount of currency supplied"
      }

      //Borrow a reference to our receiver using the stored path
      let receiver = self.owner?.getCapability(self.vaultPath)?.borrow<&{FungibleToken.Receiver}>()!!

      //Walk through each of the set ids to purchase and mint the specified amount
      for setId in setIdToAmountMap.keys {
        var amount = setIdToAmountMap[setId]!
        assert(amount > 0, message: "Can't mint 0 or fewer NFTs of set ".concat(setId.toString()))
        let seriesId = StrikeNow.getSetSeriesId(setId)!
        let series = self.borrowSeries(seriesId: seriesId)
        while amount > 0 {
          series.mintStrikeNow(recipient: recipient, setId: setId)
          amount = amount - 1
        }
      }

      //After minting, deposit in our receiver from the paying vault
      receiver.deposit(from: <- paymentVault)

      emit MintOnDemandPurchased()
    }

    //Alternative mint path that builds up a pending mint list for later execution
    pub fun submitMintClaim(paymentVault: @FungibleToken.Vault, setIdToAmountMap: {UInt32: UInt32},
      recipient: Address) {

      pre {
        StrikeNow.getSetsPurchasable(setIds: setIdToAmountMap.keys):
          "Not all of the specified sets are purchasable"
        paymentVault.balance == StrikeNow.getPriceForSetBatch(setIdToAmountMap: setIdToAmountMap):
          "Incorrect amount of currency supplied"
      }

      //Borrow a reference to our receiver using the stored path
      let receiver = self.owner?.getCapability(self.vaultPath)?.borrow<&{FungibleToken.Receiver}>()!!

      //Walk through each of the set ids and confirm intention to mint more than zero
      for setId in setIdToAmountMap.keys {
        assert(setIdToAmountMap[setId]! > 0, message: "Can't mint 0 or fewer NFTs of set ".concat(setId.toString()))
      }

      //Everything checks out, so let's add our pending mints to the list
      StrikeNow.pendingMints.append(StrikeNowData.MintSet(address: recipient, setIdToAmountMap: setIdToAmountMap))

      //After submission, deposit in receiver from the paying vault
      receiver.deposit(from: <- paymentVault)

      emit MintClaimSubmitted(by: recipient)
    }

    //Walk through our pending mint list and mint and deposit them in blocks
    pub fun executePendingMints(amount:UInt32) {
      var remaining = amount
      let path = StrikeNow.CollectionPublicPath

      while remaining > 0 && StrikeNow.pendingMints.length > 0 {
        let recipientAccount = getAccount(StrikeNow.pendingMints[0]!.address)
        let recipientCollection =
          recipientAccount.getCapability<&AnyResource{NonFungibleToken.CollectionPublic}>(path).borrow()

        //If the recipient has a broken or missing collection, add them to the list of
        //failed mints and move to the next mint set
        if recipientCollection == nil {
          StrikeNow.failedMints.append(StrikeNow.pendingMints[0])
          StrikeNow.pendingMints.remove(at: 0)
          continue
        }

        //Take the lesser of the two values - remaining count or amount in current set
        let amountInSet = StrikeNow.pendingMints[0].getAmountInSet()
        let amountToTake = remaining < amountInSet ? remaining : amountInSet
        let mintSet = StrikeNow.pendingMints[0].takeMintListAndDeplete(amountToTake: amountToTake)

        //Walk through each of the set ids to purchase and mint the specified amount
        for setId in mintSet.keys {
          var amount = mintSet[setId]!
          let seriesId = StrikeNow.getSetSeriesId(setId)!
          let series = self.borrowSeries(seriesId: seriesId)
          while amount > 0 {
            series.mintStrikeNow(recipient: recipientCollection!, setId: setId)
            amount = amount - 1
          }
        }

        //If we've depleted the current mint set, remove it
        if StrikeNow.pendingMints[0].getAmountInSet() <= 0 {
          StrikeNow.pendingMints.remove(at: 0)
        }

        //Deplete our remaining count by the amount minted
        remaining = remaining - amountToTake
      }
    }
  }

  //A public interface to allow minting on demand in exchange for DUC
  pub resource interface StrikeNowMinterPublic {
    pub fun mintStrikeNow(paymentVault: @FungibleToken.Vault, setIdToAmountMap: {UInt32: UInt32},
      recipient: &{NonFungibleToken.CollectionPublic})
    pub fun submitMintClaim(paymentVault: @FungibleToken.Vault, setIdToAmountMap: {UInt32: UInt32},
      recipient: Address)
  }

  pub resource interface StrikeNowCollectionPublic {
    pub fun deposit(token: @NonFungibleToken.NFT)
    pub fun batchDeposit(tokens: @NonFungibleToken.Collection)
    pub fun getIDs(): [UInt64]
    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
    pub fun borrowStrikeNow(id: UInt64): &StrikeNow.NFT? {
      post {
        (result == nil) || (result?.id == id):
          "Cannot borrow StrikeNow reference: The ID of the returned reference is incorrect"
      }
    }
  }

  pub resource Collection: StrikeNowCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
    pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

    pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
      let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

      emit Withdraw(id: token.id, from: self.owner?.address)

      return <-token
    }

    pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {
      var batchCollection <-create Collection()

      for id in ids {
        batchCollection.deposit(token: <-self.withdraw(withdrawID: id))
      }

      return <-batchCollection
    }

    pub fun deposit(token: @NonFungibleToken.NFT) {
      let token <-token as!@StrikeNow.NFT

      let id: UInt64 = token.id
      let oldToken <-self.ownedNFTs[id] <-token

      emit Deposit(id: id, to: self.owner?.address)

      destroy oldToken
    }

    pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {
      let keys = tokens.getIDs()

      for key in keys {
        self.deposit(token: <-tokens.withdraw(withdrawID: key))
      }

      destroy tokens
    }

    pub fun getIDs(): [UInt64] {
      return self.ownedNFTs.keys
    }

    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
      return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
    }

    pub fun borrowStrikeNow(id: UInt64): &StrikeNow.NFT? {
      let ref = & self.ownedNFTs[id] as auth &NonFungibleToken.NFT?
        return ref as! &StrikeNow.NFT?
    }

    pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
      let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let StrikeNowNft = nft as! &StrikeNow.NFT
      return StrikeNowNft as &AnyResource{MetadataViews.Resolver}
    }

    destroy() {
      destroy self.ownedNFTs
    }

    init() {
      self.ownedNFTs <- {}
    }
  }

  pub fun createEmptyCollection(): @NonFungibleToken.Collection {
    return <-create Collection()
  }

  pub fun fetch(_ from: Address, id: UInt64): &StrikeNow.NFT? {
    let collection = getAccount(from)
      .getCapability(StrikeNow.CollectionPublicPath)
      .borrow<&StrikeNow.Collection{StrikeNow.StrikeNowCollectionPublic}>()
        ?? panic("Couldn't get collection")

    return collection.borrowStrikeNow(id: id)
  }

  pub fun getAllSeries(): [StrikeNowData.SeriesData] {
    return StrikeNow.seriesData.values
  }

  pub fun getAllSets(): [StrikeNowData.SetData] {
    return StrikeNow.setData.values
  }

  pub fun getSeriesMetadata(seriesId: UInt32): {String: String}? {
    pre {
      StrikeNow.seriesData.containsKey(seriesId): "Invalid series id ".concat(seriesId.toString())
    }
    return StrikeNow.seriesData[seriesId]?.metadataRaw
  }

  pub fun getSetMetadata(setId: UInt32): {String: String}? {
    pre {
      StrikeNow.setData.containsKey(setId): "Invalid set id ".concat(setId.toString())
    }
    return StrikeNow.setData[setId]?.metadataRaw
  }

  pub fun getSetSeriesId(_ setId: UInt32): UInt32? {
    pre {
      StrikeNow.setData.containsKey(setId): "Invalid set id ".concat(setId.toString())
    }
    return StrikeNow.setData[setId]?.seriesId
  }

  pub fun getConfigData(): StrikeNowData.ConfigData {
    return StrikeNow.config
  }

  //Returns the shuffled edition number that is mapped to the token index in that set
  pub fun getEditionNumber(seriesId: UInt32, setId: UInt32, tokenIndex: UInt32): UInt32? {
    pre {
      StrikeNow.seriesData.containsKey(seriesId): "Invalid series id ".concat(seriesId.toString())
      StrikeNow.setData.containsKey(setId): "Invalid set id ".concat(setId.toString())
    }
    return StrikeNow.series[seriesId]?.getEdition(setId: setId, tokenIndex: tokenIndex)
  }

  //Just returns the total minted for a given set, as we will be running
  //open editions
  pub fun getMaxEditions(setId: UInt32): UInt64? {
    pre {
      StrikeNow.setData.containsKey(setId): "Invalid set id ".concat(setId.toString())
    }
    return StrikeNow.numberEditionsMintedPerSet[setId]
  }

  //Return the FightData that is referenced by a particular set
  pub fun getFightForSet(_ setId: UInt32): StrikeNowData.FightData {
    pre {
      StrikeNow.setData.containsKey(setId): "Invalid set id ".concat(setId.toString())
      StrikeNow.seriesData.containsKey(StrikeNow.setData[setId]!.seriesId)
    }
    let set = StrikeNow.setData[setId]!
    let series = StrikeNow.seriesData[set.seriesId]!
    assert(series.fights.containsKey(set.fightId), message: "Could not find fight in set with id ".concat(set.fightId.toString()))
    return series.fights[set.fightId]!
  }

  pub fun getSetPurchasable(setId: UInt32): Bool {
    pre {
      StrikeNow.setData.containsKey(setId): "Invalid set id ".concat(setId.toString())
    }
    let seriesId = StrikeNow.getSetSeriesId(setId)!
    let map = StrikeNow.series[seriesId]?.onSaleStateMap!
    return map[setId]!
  }

  //Return the total purchasability of an array of sets, as represented by
  //ids
  pub fun getSetsPurchasable(setIds: [UInt32]): Bool {
    for setId in setIds {
      if !StrikeNow.getSetPurchasable(setId: setId) {
        return false
      }
    }
    return true
  }

  //Return the price for an individual set
  pub fun getPriceForSet(setId: UInt32): UFix64 {
    pre {
      StrikeNow.setData.containsKey(setId): "Invalid set id ".concat(setId.toString())
    }
    return StrikeNow.setData[setId]!.price
  }

  //Return the total price for a set of NFTs, represented as a map between
  //setId and count to purchase:
  //{
  //  setId: numberToPurchase,
  //  setId: numberToPurchase
  //}
  pub fun getPriceForSetBatch(setIdToAmountMap: {UInt32: UInt32}): UFix64 {
    var price: UFix64 = 0.0
    for setId in setIdToAmountMap.keys {
      price = price + StrikeNow.getPriceForSet(setId: setId) * UFix64(setIdToAmountMap[setId]!)
    }
    return price
  }

  pub fun getOwnerAddress(): Address {
    return self.account.address
  }

  pub fun getAssetForId(setId: UInt32, assetId: UInt32): StrikeNowData.AssetData {
    pre {
      StrikeNow.setData.containsKey(setId): "Missing set id ".concat(setId.toString())
      StrikeNow.setData[setId]!.assets != nil: "No asset data on set id ".concat(setId.toString())
      StrikeNow.setData[setId]!.assets![assetId] != nil: "No asset with id ".concat(assetId.toString())
    }
    return StrikeNow.setData[setId]!.assets![assetId]!
  }

  init() {
    self.CollectionStoragePath = /storage/StrikeNowCollection
    self.CollectionPublicPath = /public/StrikeNowCollection
    self.AdminStoragePath = /storage/StrikeNowAdmin
    self.AdminPrivatePath = /private/StrikeNowAdmin
    self.MinterPublicPath = /public/StrikeNowMinter
    self.VaultPublicPath = /public/StrikeNowDUCReceiver

    self.totalSupply = 0
    self.setData = {}
    self.seriesData = {}
    self.series <-{}
    self.numberEditionsMintedPerSet = {}
    self.pendingMints = []
    self.failedMints = []

    //Initialize our admin resource with a path to our funds receiver vault
    let admin <- create Admin(vaultPath: self.VaultPublicPath)
    self.account.save(<- admin, to: self.AdminStoragePath)

    //Create a private capability that the deployer account can use to
    //manage the contract
    self.account.link<&StrikeNow.Admin> (
      self.AdminPrivatePath,
      target: self.AdminStoragePath
    ) ?? panic("Could not get a capability to the admin")

    //Create a public capability to access just the minter function on
    //the admin resource to enable external transactions
    self.account.link<&{StrikeNow.StrikeNowMinterPublic}> (
      self.MinterPublicPath,
      target: self.AdminStoragePath
    ) ?? panic("Could not get a capability to the admin")

    //Get a DUC receiver reference using our current merchant account
    //This must be updated for different target chains
    let merchantAccount = getAccount(0xcfa0d15914188d1d)
    let ducReceiver = merchantAccount.getCapability(/public/dapperUtilityCoinReceiver)!

    //Create a forwarder resource for DUC and store it
    let ducForwarder <- TokenForwarding.createNewForwarder(recipient: ducReceiver)
		self.account.save(<-ducForwarder, to: /storage/dapperUtilityCoinReceiver)

    //Publish Receiver capability linked to the DUC Forwarder
		self.account.link<&{FungibleToken.Receiver}>(
      self.VaultPublicPath,
      target: /storage/dapperUtilityCoinReceiver)
      ?? panic("Could not set up capability link for token receiver")

    //Set up our initial configuration data
    let input = {
      "collectionName": "UFC Strike Now",
      "collectionDescription": "UFC Strike Now: Commemorate The Fight. Win The Night.",
      "externalURL": "https://ufcstrike.com/now",
      "squareImageURL": "https://media.gigantik.io/ufc/square.png",
      "squareImageMediaType": "image/png",
      "bannerImageURL": "https://media.gigantik.io/ufc/banner.png",
      "bannerImageMediaType": "image/png"
    }
    let socials = {
      "instagram": "https://instagram.com/ufcstrike",
      "twitter": "https://twitter.com/UFCStrikeNFT",
      "discord": "https://discord.gg/UFCStrike"
    }
    self.config = StrikeNowData.ConfigData(input: input, socials: socials)

    emit ContractInitialized()
  }
}"
-------
"// HelloWorld.cdc
//
// Welcome to Cadence! This is one of the simplest programs you can deploy on Flow.
//
// The HelloWorld contract contains a single string field and a public getter function.
//
// Follow the "Hello, World!" tutorial to learn more: https://docs.onflow.org/cadence/tutorial/02-hello-world/

access(all) contract HelloWorld {

    // Declare a public field of type String.
    //
    // All fields must be initialized in the init() function.
    access(all) let greeting: String

    // The init() function is required if the contract contains any fields.
    init() {
        self.greeting = "Hello, World!"
    }

    // Public function that returns our friendly greeting!
    access(all) fun hello(): String {
        return self.greeting
    }
}
"
-------
"// Description: Smart Contract for NFL Virtual Commemorative Tickets
// SPDX-License-Identifier: UNLICENSED


import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract NFL : NonFungibleToken{
    pub var totalSupply: UInt64

    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath

    pub resource NFT : NonFungibleToken.INFT, MetadataViews.Resolver {
        pub let id: UInt64
        pub var link: String
        pub var batch: UInt32
        pub var sequence: UInt16
        pub var limit: UInt16

        init(
            initID: UInt64,
            initlink: String,
            initbatch: UInt32,
            initsequence: UInt16,
            initlimit: UInt16
        ) {
            self.id = initID
            self.link = initlink
            self.batch = initbatch
            self.sequence=initsequence
            self.limit=initlimit
        }

        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.NFTCollectionData>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: NFL.CollectionStoragePath,
                        publicPath: NFL.CollectionPublicPath,
                        providerPath: /private/NFLCollection,
                        publicCollection: Type<&NFL.Collection{NFL.NFLCollectionPublic}>(),
                        publicLinkedType: Type<&NFL.Collection{NFL.NFLCollectionPublic,NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&NFL.Collection{NFL.NFLCollectionPublic,NonFungibleToken.CollectionPublic, NonFungibleToken.Provider, MetadataViews.ResolverCollection}>(),
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                            return <-NFL.createEmptyCollection()
                        })
                    )

            }
            return nil
        }
    }

    pub resource interface NFLCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowNFL(id: UInt64): &NFL.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow NFL reference: The ID of the returned reference is incorrect"
            }
        }
    }

    pub resource Collection: NFLCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID)!

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }


        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @NFL.NFT
            let id: UInt64 = token.id
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let nflNFT = nft as! &NFL.NFT
            return nflNFT as &AnyResource{MetadataViews.Resolver}
        }

        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        destroy() {
            destroy self.ownedNFTs
        }

        pub fun borrowNFL(id: UInt64): &NFL.NFT? {
            if self.ownedNFTs[id] == nil {
                return nil
            }
            else {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!

                return ref as! &NFL.NFT
            }
        }
    }

    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    pub resource NFTMinter {
        pub var minterID: UInt64

        init() {
            self.minterID = 0
        }

        pub fun mintNFT(
            glink: String,
            gbatch: UInt32,
            glimit: UInt16,
            gsequence: UInt16
        ): @NFT {
            let tokenID = (UInt64(gbatch) << 32) | (UInt64(glimit) << 16) | UInt64(gsequence)
            var newNFT <- create NFT(initID: tokenID, initlink: glink, initbatch: gbatch, initsequence: gsequence, initlimit: glimit)

            self.minterID= tokenID
            NFL.totalSupply = NFL.totalSupply + UInt64(1)
            return <-newNFT
        }
    }

	init() {
        self.CollectionStoragePath = /storage/NFLCollection
        self.CollectionPublicPath = /public/NFLCollection
        self.MinterStoragePath = /storage/NFLMinter

        self.totalSupply = 0
        self.account.save(<-self.createEmptyCollection(), to: self.CollectionStoragePath)

        self.account.link<&{NFL.NFLCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(
            self.CollectionPublicPath,
            target: self.CollectionStoragePath
        )
        self.account.save(<-create NFTMinter(), to: self.MinterStoragePath)
	}
}

 "
-------
"import FungibleToken from 0xf233dcee88fe0abe
import FungibleTokenMetadataViews from 0xf233dcee88fe0abe
import MetadataViews from 0x1d7e57aa55817448
import Toucans from 0x577a3c409c5dcb5e
import ToucansTokens from 0x577a3c409c5dcb5e

pub contract BallerzFC: FungibleToken {

    // The amount of tokens in existance
    pub var totalSupply: UFix64
    // nil if there is none
    pub let maxSupply: UFix64?

    // Paths
    pub let VaultStoragePath: StoragePath
    pub let ReceiverPublicPath: PublicPath
    pub let VaultPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath
    pub let AdministratorStoragePath: StoragePath

    // Events
    pub event TokensInitialized(initialSupply: UFix64)
    pub event TokensWithdrawn(amount: UFix64, from: Address?)
    pub event TokensDeposited(amount: UFix64, to: Address?)
    pub event TokensTransferred(amount: UFix64, from: Address, to: Address)
    pub event TokensMinted(amount: UFix64)
    pub event TokensBurned(amount: UFix64)

    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance, MetadataViews.Resolver {
        pub var balance: UFix64

        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)

            if let owner: Address = self.owner?.address {
                BallerzFC.setBalance(address: owner, balance: self.balance)
            }
            return <- create Vault(balance: amount)
        }

        pub fun deposit(from: @FungibleToken.Vault) {
            let vault: @Vault <- from as! @Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)

            // We set the balance to 0.0 here so that it doesn't
            // decrease the totalSupply in the `destroy` function.
            vault.balance = 0.0
            destroy vault

            if let owner: Address = self.owner?.address {
                BallerzFC.setBalance(address: owner, balance: self.balance)
            }
        }

        pub fun getViews(): [Type]{
            return [Type<FungibleTokenMetadataViews.FTView>(),
                    Type<FungibleTokenMetadataViews.FTDisplay>(),
                    Type<FungibleTokenMetadataViews.FTVaultData>()]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<FungibleTokenMetadataViews.FTView>():
                    return FungibleTokenMetadataViews.FTView(
                        ftDisplay: self.resolveView(Type<FungibleTokenMetadataViews.FTDisplay>()) as! FungibleTokenMetadataViews.FTDisplay?,
                        ftVaultData: self.resolveView(Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
                    )
                case Type<FungibleTokenMetadataViews.FTDisplay>():
                    let media = MetadataViews.Media(
                            file: MetadataViews.HTTPFile(
                            url: "https://nftstorage.link/ipfs/bafkreia7yuhyjuqadsauw5dnmyaas2sxweulbj7cfpdysfglbu3u6kgtre"
                        ),
                        mediaType: "image"
                    )
                    let medias = MetadataViews.Medias([media])
                    return FungibleTokenMetadataViews.FTDisplay(
                        name: "Ballerz FC",
                        symbol: "BFC",
                        description: "A DAO for the ownership and management of Ballerz FC and related assets in the MFL Universe",
                        externalURL: MetadataViews.ExternalURL(""),
                        logos: medias,
                        socials: {
                            "twitter": MetadataViews.ExternalURL("Ballerz__FC"),
                            "discord": MetadataViews.ExternalURL("sDBp8YdH")
                        }
                    )
                case Type<FungibleTokenMetadataViews.FTVaultData>():
                    return FungibleTokenMetadataViews.FTVaultData(
                        storagePath: BallerzFC.VaultStoragePath,
                        receiverPath: BallerzFC.ReceiverPublicPath,
                        metadataPath: BallerzFC.VaultPublicPath,
                        providerPath: /private/BallerzFCVault,
                        receiverLinkedType: Type<&Vault{FungibleToken.Receiver}>(),
                        metadataLinkedType: Type<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(),
                        providerLinkedType: Type<&Vault{FungibleToken.Provider}>(),
                        createEmptyVaultFunction: (fun (): @Vault {
                            return <- BallerzFC.createEmptyVault()
                        })
                    )
            }
            return nil
        }

        init(balance: UFix64) {
            self.balance = balance
        }

        destroy() {
            emit TokensBurned(amount: self.balance)
            BallerzFC.totalSupply = BallerzFC.totalSupply - self.balance
        }
    }

    pub fun createEmptyVault(): @Vault {
        return <- create Vault(balance: 0.0)
    }

    pub resource Minter: Toucans.Minter {
        pub fun mint(amount: UFix64): @Vault {
            post {
                BallerzFC.maxSupply == nil || BallerzFC.totalSupply <= BallerzFC.maxSupply!:
                    "Exceeded the max supply of tokens allowd."
            }
            BallerzFC.totalSupply = BallerzFC.totalSupply + amount
            emit TokensMinted(amount: amount)
            return <- create Vault(balance: amount)
        }
    }

    // We follow this pattern of storage
    // so the (potentially) huge dictionary
    // isn't loaded when the contract is imported
    pub resource Administrator {
        // This is an experimental index and should
        // not be used for anything official
        // or monetary related
        access(self) let balances: {Address: UFix64}

        access(contract) fun setBalance(address: Address, balance: UFix64) {
            self.balances[address] = balance
        }

        pub fun getBalance(address: Address): UFix64 {
            return self.balances[address] ?? 0.0
        }

        pub fun getBalances(): {Address: UFix64} {
            return self.balances
        }

        init() {
            self.balances = {}
        }
    }

    access(contract) fun setBalance(address: Address, balance: UFix64) {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        admin.setBalance(address: address, balance: balance)
    }

    pub fun getBalance(address: Address): UFix64 {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalance(address: address)
    }

    pub fun getBalances(): {Address: UFix64} {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalances()
    }

    init(
      _paymentTokenInfo: ToucansTokens.TokenInfo,
      _editDelay: UFix64,
      _minting: Bool,
      _initialTreasurySupply: UFix64,
      _maxSupply: UFix64?,
      _extra: {String: AnyStruct}
    ) {

      // Contract Variables
      self.totalSupply = 0.0
      self.maxSupply = _maxSupply

      // Paths
      self.VaultStoragePath = /storage/BallerzFCVault
      self.ReceiverPublicPath = /public/BallerzFCReceiver
      self.VaultPublicPath = /public/BallerzFCMetadata
      self.MinterStoragePath = /storage/BallerzFCMinter
      self.AdministratorStoragePath = /storage/BallerzFCAdmin

      // Admin Setup
      let vault <- create Vault(balance: self.totalSupply)
      self.account.save(<- vault, to: self.VaultStoragePath)

      self.account.link<&Vault{FungibleToken.Receiver}>(
          self.ReceiverPublicPath,
          target: self.VaultStoragePath
      )

      self.account.link<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(
          self.VaultPublicPath,
          target: self.VaultStoragePath
      )

      if self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath) == nil {
        self.account.save(<- Toucans.createCollection(), to: Toucans.CollectionStoragePath)
        self.account.link<&Toucans.Collection{Toucans.CollectionPublic}>(Toucans.CollectionPublicPath, target: Toucans.CollectionStoragePath)
      }

      let toucansProjectCollection = self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath)!
      toucansProjectCollection.createProject(
        projectTokenInfo: ToucansTokens.TokenInfo("BallerzFC", self.account.address, "BFC", self.ReceiverPublicPath, self.VaultPublicPath, self.VaultStoragePath),
        paymentTokenInfo: _paymentTokenInfo,
        minter: <- create Minter(),
        editDelay: _editDelay,
        minting: _minting,
        initialTreasurySupply: _initialTreasurySupply,
        extra: _extra
      )

      self.account.save(<- create Administrator(), to: self.AdministratorStoragePath)

      // Events
      emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
 "
-------
"// CREATED BY: Touchstone (https://touchstone.city/), a platform crafted by your best friends at Emerald City DAO (https://ecdao.org/).
// STATEMENT: This contract promises to keep the 5% royalty off of primary sales and 2.5% off of secondary sales to Emerald City DAO or risk permanent suspension from participation in the DAO and its tools.

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import FlowToken from 0x1654653399040a61
import MintVerifiers from 0x7a696d6136e1dce2
import FUSD from 0x3c5959b568896393
import EmeraldPass from 0x6a07dbeb03167a13

pub contract TouchstoneFirst: NonFungibleToken {

	// Collection Information
	access(self) let collectionInfo: {String: AnyStruct}

	// Contract Information
	pub var nextEditionId: UInt64
	pub var nextMetadataId: UInt64
	pub var totalSupply: UInt64

	// Events
	pub event ContractInitialized()
	pub event Withdraw(id: UInt64, from: Address?)
	pub event Deposit(id: UInt64, to: Address?)
	pub event TouchstonePurchase(id: UInt64, recipient: Address, metadataId: UInt64, name: String, description: String, image: MetadataViews.IPFSFile, price: UFix64)
	pub event Minted(id: UInt64, recipient: Address, metadataId: UInt64)
	pub event MintBatch(metadataIds: [UInt64], recipients: [Address])

	// Paths
	pub let CollectionStoragePath: StoragePath
	pub let CollectionPublicPath: PublicPath
	pub let CollectionPrivatePath: PrivatePath
	pub let AdministratorStoragePath: StoragePath

	// Maps metadataId of NFT to NFTMetadata
	access(account) let metadatas: {UInt64: NFTMetadata}

	// Maps the metadataId of an NFT to the primary buyer
	access(account) let primaryBuyers: {Address: {UInt64: [UInt64]}}

	access(account) let nftStorage: @{Address: {UInt64: NFT}}

	pub struct NFTMetadata {
		pub let metadataId: UInt64
		pub let name: String
		pub let description: String
		// The main image of the NFT
		pub let image: MetadataViews.IPFSFile
		// An optional thumbnail that can go along with it
		// for easier loading
		pub let thumbnail: MetadataViews.IPFSFile?
		// If price is nil, defaults to the collection price
		pub let price: UFix64?
		pub var extra: {String: AnyStruct}
		pub let supply: UInt64
		pub let purchasers: {UInt64: Address}

		access(account) fun purchased(serial: UInt64, buyer: Address) {
			self.purchasers[serial] = buyer
		}

		init(_name: String, _description: String, _image: MetadataViews.IPFSFile, _thumbnail: MetadataViews.IPFSFile?, _price: UFix64?, _extra: {String: AnyStruct}, _supply: UInt64) {
			self.metadataId = TouchstoneFirst.nextMetadataId
			self.name = _name
			self.description = _description
			self.image = _image
			self.thumbnail = _thumbnail
			self.price = _price
			self.extra = _extra
			self.supply = _supply
			self.purchasers = {}
		}
	}

	pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
		// The 'id' is the same as the 'uuid'
		pub let id: UInt64
		// The 'metadataId' is what maps this NFT to its 'NFTMetadata'
		pub let metadataId: UInt64
		pub let serial: UInt64

		pub fun getMetadata(): NFTMetadata {
			return TouchstoneFirst.getNFTMetadata(self.metadataId)!
		}

		pub fun getViews(): [Type] {
			return [
				Type<MetadataViews.Display>(),
				Type<MetadataViews.ExternalURL>(),
				Type<MetadataViews.NFTCollectionData>(),
				Type<MetadataViews.NFTCollectionDisplay>(),
				Type<MetadataViews.Royalties>(),
				Type<MetadataViews.Serial>(),
				Type<MetadataViews.Traits>(),
				Type<MetadataViews.NFTView>()
			]
		}

		pub fun resolveView(_ view: Type): AnyStruct? {
			switch view {
				case Type<MetadataViews.Display>():
					let metadata = self.getMetadata()
					return MetadataViews.Display(
						name: metadata.name,
						description: metadata.description,
						thumbnail: metadata.thumbnail ?? metadata.image
					)
				case Type<MetadataViews.NFTCollectionData>():
					return MetadataViews.NFTCollectionData(
						storagePath: TouchstoneFirst.CollectionStoragePath,
						publicPath: TouchstoneFirst.CollectionPublicPath,
						providerPath: TouchstoneFirst.CollectionPrivatePath,
						publicCollection: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
						publicLinkedType: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
						providerLinkedType: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, NonFungibleToken.Provider}>(),
						createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
								return <- TouchstoneFirst.createEmptyCollection()
						})
					)
				case Type<MetadataViews.ExternalURL>():
          return MetadataViews.ExternalURL("https://touchstone.city/discover/".concat(self.owner!.address.toString()).concat("/TouchstoneFirst"))
				case Type<MetadataViews.NFTCollectionDisplay>():
					let squareMedia = MetadataViews.Media(
						file: TouchstoneFirst.getCollectionAttribute(key: "image") as! MetadataViews.IPFSFile,
						mediaType: "image"
					)

					// If a banner image exists, use it
					// Otherwise, default to the main square image
					var bannerMedia: MetadataViews.Media? = nil
					if let bannerImage = TouchstoneFirst.getOptionalCollectionAttribute(key: "bannerImage") as! MetadataViews.IPFSFile? {
						bannerMedia = MetadataViews.Media(
							file: bannerImage,
							mediaType: "image"
						)
					}
					return MetadataViews.NFTCollectionDisplay(
						name: TouchstoneFirst.getCollectionAttribute(key: "name") as! String,
						description: TouchstoneFirst.getCollectionAttribute(key: "description") as! String,
						externalURL: MetadataViews.ExternalURL("https://touchstone.city/discover/".concat(self.owner!.address.toString()).concat("/TouchstoneFirst")),
						squareImage: squareMedia,
						bannerImage: bannerMedia ?? squareMedia,
						socials: TouchstoneFirst.getCollectionAttribute(key: "socials") as! {String: MetadataViews.ExternalURL}
					)
				case Type<MetadataViews.Royalties>():
					return MetadataViews.Royalties([
						// This is for Emerald City in favor of producing Touchstone, a free platform for our users. Failure to keep this in the contract may result in permanent suspension from Emerald City.
						MetadataViews.Royalty(
							recepient: getAccount(0x5643fd47a29770e7).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),
							cut: 0.025, // 2.5% royalty on secondary sales
							description: "Emerald City DAO receives a 2.5% royalty from secondary sales because this collection was created using Touchstone (https://touchstone.city/), a tool for creating your own NFT collections, crafted by Emerald City DAO."
						)
					])
				case Type<MetadataViews.Serial>():
					return MetadataViews.Serial(
						self.serial
					)
				case Type<MetadataViews.Traits>():
					return MetadataViews.dictToTraits(dict: self.getMetadata().extra, excludedNames: nil)
				case Type<MetadataViews.NFTView>():
					return MetadataViews.NFTView(
						id: self.id,
						uuid: self.uuid,
						display: self.resolveView(Type<MetadataViews.Display>()) as! MetadataViews.Display?,
						externalURL: self.resolveView(Type<MetadataViews.ExternalURL>()) as! MetadataViews.ExternalURL?,
						collectionData: self.resolveView(Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?,
						collectionDisplay: self.resolveView(Type<MetadataViews.NFTCollectionDisplay>()) as! MetadataViews.NFTCollectionDisplay?,
						royalties: self.resolveView(Type<MetadataViews.Royalties>()) as! MetadataViews.Royalties?,
						traits: self.resolveView(Type<MetadataViews.Traits>()) as! MetadataViews.Traits?
					)
			}
			return nil
		}

		init(_metadataId: UInt64, _serial: UInt64, _recipient: Address) {
			pre {
				TouchstoneFirst.metadatas[_metadataId] != nil:
					"This NFT does not exist yet."
				_serial < TouchstoneFirst.getNFTMetadata(_metadataId)!.supply:
					"This serial does not exist for this metadataId."
				!TouchstoneFirst.getNFTMetadata(_metadataId)!.purchasers.containsKey(_serial):
					"This serial has already been purchased."
			}
			self.id = self.uuid
			self.metadataId = _metadataId
			self.serial = _serial

			// Update the buyers list so we keep track of who is purchasing
			if let buyersRef = &TouchstoneFirst.primaryBuyers[_recipient] as &{UInt64: [UInt64]}? {
				if let metadataIdMap = &buyersRef[_metadataId] as &[UInt64]? {
					metadataIdMap.append(_serial)
				} else {
					buyersRef[_metadataId] = [_serial]
				}
			} else {
				TouchstoneFirst.primaryBuyers[_recipient] = {_metadataId: [_serial]}
			}

			// Update who bought this serial inside NFTMetadata so it cannot be purchased again.
			let metadataRef = (&TouchstoneFirst.metadatas[_metadataId] as &NFTMetadata?)!
			metadataRef.purchased(serial: _serial, buyer: _recipient)

			TouchstoneFirst.totalSupply = TouchstoneFirst.totalSupply + 1
			emit Minted(id: self.id, recipient: _recipient, metadataId: _metadataId)
		}
	}

	pub resource Collection: NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
		// dictionary of NFT conforming tokens
		// NFT is a resource type with an 'UInt64' ID field
		pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

		// withdraw removes an NFT from the collection and moves it to the caller
		pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
			let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

			emit Withdraw(id: token.id, from: self.owner?.address)

			return <-token
		}

		// deposit takes a NFT and adds it to the collections dictionary
		// and adds the ID to the id array
		pub fun deposit(token: @NonFungibleToken.NFT) {
			let token <- token as! @NFT

			let id: UInt64 = token.id

			// add the new token to the dictionary
			self.ownedNFTs[id] <-! token

			emit Deposit(id: id, to: self.owner?.address)
		}

		// getIDs returns an array of the IDs that are in the collection
		pub fun getIDs(): [UInt64] {
			return self.ownedNFTs.keys
		}

		// borrowNFT gets a reference to an NFT in the collection
		// so that the caller can read its metadata and call its methods
		pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
			return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
		}

		pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
			let token = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
			let nft = token as! &NFT
			return nft as &AnyResource{MetadataViews.Resolver}
		}

		pub fun claim() {
			if let storage = &TouchstoneFirst.nftStorage[self.owner!.address] as &{UInt64: NFT}? {
				for id in storage.keys {
					self.deposit(token: <- storage.remove(key: id)!)
				}
			}
		}

		init () {
			self.ownedNFTs <- {}
		}

		destroy() {
			destroy self.ownedNFTs
		}
	}

	// A function to mint NFTs.
	// You can only call this function if minting
	// is currently active.
	pub fun mintNFT(metadataId: UInt64, recipient: &{NonFungibleToken.Receiver}, payment: @FlowToken.Vault, serial: UInt64): UInt64 {
		pre {
			self.canMint(): "Minting is currently closed by the Administrator!"
			payment.balance == self.getPriceOfNFT(metadataId):
				"Payment does not match the price. You passed in ".concat(payment.balance.toString()).concat(" but this NFT costs ").concat(self.getPriceOfNFT(metadataId)!.toString())
		}
		let price: UFix64 = self.getPriceOfNFT(metadataId)!

		// Confirm recipient passes all verifiers
		for verifier in self.getMintVerifiers() {
			let params = {"minter": recipient.owner!.address}
			if let error = verifier.verify(params) {
				panic(error)
			}
		}

		// Handle Emerald City DAO royalty (5%)
		let EmeraldCityTreasury = getAccount(0x5643fd47a29770e7).getCapability(/public/flowTokenReceiver)
								.borrow<&FlowToken.Vault{FungibleToken.Receiver}>()!
		let emeraldCityCut: UFix64 = 0.05 * price

		// Handle royalty to user that was configured upon creation
		if let royalty = TouchstoneFirst.getOptionalCollectionAttribute(key: "royalty") as! MetadataViews.Royalty? {
			royalty.receiver.borrow()!.deposit(from: <- payment.withdraw(amount: price * royalty.cut))
		}

		EmeraldCityTreasury.deposit(from: <- payment.withdraw(amount: emeraldCityCut))

		// Give the rest to the collection owner
		let paymentRecipient = self.account.getCapability(/public/flowTokenReceiver)
								.borrow<&FlowToken.Vault{FungibleToken.Receiver}>()!
		paymentRecipient.deposit(from: <- payment)

		// Mint the nft
		let nft <- create NFT(_metadataId: metadataId, _serial: serial, _recipient: recipient.owner!.address)
		let nftId: UInt64 = nft.id
		let metadata = self.getNFTMetadata(metadataId)!
		self.collectionInfo["profit"] = (self.getCollectionAttribute(key: "profit") as! UFix64) + price

		// Emit event
		emit TouchstonePurchase(id: nftId, recipient: recipient.owner!.address, metadataId: metadataId, name: metadata.name, description: metadata.description, image: metadata.image, price: price)

		// Deposit nft
		recipient.deposit(token: <- nft)

		return nftId
	}

	pub resource Administrator {
		pub fun createNFTMetadata(name: String, description: String, imagePath: String, thumbnailPath: String?, ipfsCID: String, price: UFix64?, extra: {String: AnyStruct}, supply: UInt64) {
			TouchstoneFirst.metadatas[TouchstoneFirst.nextMetadataId] = NFTMetadata(
				_name: name,
				_description: description,
				_image: MetadataViews.IPFSFile(
					cid: ipfsCID,
					path: imagePath
				),
				_thumbnail: thumbnailPath == nil ? nil : MetadataViews.IPFSFile(cid: ipfsCID, path: thumbnailPath),
				_price: price,
				_extra: extra,
				_supply: supply
			)
			TouchstoneFirst.nextMetadataId = TouchstoneFirst.nextMetadataId + 1
		}

		// mintNFT mints a new NFT and deposits
		// it in the recipients collection
		pub fun mintNFT(metadataId: UInt64, serial: UInt64, recipient: Address) {
			pre {
				EmeraldPass.isActive(user: TouchstoneFirst.account.address): "You must have an active Emerald Pass subscription to airdrop NFTs. You can purchase Emerald Pass at https://pass.ecdao.org/"
			}
			let nft <- create NFT(_metadataId: metadataId, _serial: serial, _recipient: recipient)
			if let recipientCollection = getAccount(recipient).getCapability(TouchstoneFirst.CollectionPublicPath).borrow<&TouchstoneFirst.Collection{NonFungibleToken.CollectionPublic}>() {
				recipientCollection.deposit(token: <- nft)
			} else {
				if let storage = &TouchstoneFirst.nftStorage[recipient] as &{UInt64: NFT}? {
					storage[nft.id] <-! nft
				} else {
					TouchstoneFirst.nftStorage[recipient] <-! {nft.id: <- nft}
				}
			}
		}

		pub fun mintBatch(metadataIds: [UInt64], serials: [UInt64], recipients: [Address]) {
			pre {
				metadataIds.length == recipients.length: "You need to pass in an equal number of metadataIds and recipients."
			}
			var i = 0
			while i < metadataIds.length {
				self.mintNFT(metadataId: metadataIds[i], serial: serials[i], recipient: recipients[i])
				i = i + 1
			}

			emit MintBatch(metadataIds: metadataIds, recipients: recipients)
		}

		// create a new Administrator resource
		pub fun createAdmin(): @Administrator {
			return <- create Administrator()
		}

		// change piece of collection info
		pub fun changeField(key: String, value: AnyStruct) {
			TouchstoneFirst.collectionInfo[key] = value
		}
	}

	// public function that anyone can call to create a new empty collection
	pub fun createEmptyCollection(): @NonFungibleToken.Collection {
		return <- create Collection()
	}

	// Get information about a NFTMetadata
	pub fun getNFTMetadata(_ metadataId: UInt64): NFTMetadata? {
		return self.metadatas[metadataId]
	}

	pub fun getNFTMetadatas(): {UInt64: NFTMetadata} {
		return self.metadatas
	}

	pub fun getPrimaryBuyers(): {Address: {UInt64: [UInt64]}} {
		return self.primaryBuyers
	}

	pub fun getCollectionInfo(): {String: AnyStruct} {
		let collectionInfo = self.collectionInfo
		collectionInfo["metadatas"] = self.metadatas
		collectionInfo["primaryBuyers"] = self.primaryBuyers
		collectionInfo["totalSupply"] = self.totalSupply
		collectionInfo["nextMetadataId"] = self.nextMetadataId
		collectionInfo["version"] = 1
		return collectionInfo
	}

	pub fun getCollectionAttribute(key: String): AnyStruct {
		return self.collectionInfo[key] ?? panic(key.concat(" is not an attribute in this collection."))
	}

	pub fun getOptionalCollectionAttribute(key: String): AnyStruct? {
		return self.collectionInfo[key]
	}

	pub fun getMintVerifiers(): [{MintVerifiers.IVerifier}] {
		return self.getCollectionAttribute(key: "mintVerifiers") as! [{MintVerifiers.IVerifier}]
	}

	pub fun canMint(): Bool {
		return self.getCollectionAttribute(key: "minting") as! Bool
	}

	// Returns nil if an NFT with this metadataId doesn't exist
	pub fun getPriceOfNFT(_ metadataId: UInt64): UFix64? {
		if let metadata: TouchstoneFirst.NFTMetadata = self.getNFTMetadata(metadataId) {
			let defaultPrice: UFix64 = self.getCollectionAttribute(key: "price") as! UFix64
			if self.getCollectionAttribute(key: "lotteryBuying") as! Bool {
				return defaultPrice
			}
			return metadata.price ?? defaultPrice
		}
		// If the metadataId doesn't exist
		return nil
	}

	// Returns an mapping of `id` to NFTMetadata
	// for the NFTs a user can claim
	pub fun getClaimableNFTs(user: Address): {UInt64: NFTMetadata} {
		let answer: {UInt64: NFTMetadata} = {}
		if let storage = &TouchstoneFirst.nftStorage[user] as &{UInt64: NFT}? {
			for id in storage.keys {
				let nftRef = (&storage[id] as &NFT?)!
				answer[id] = self.getNFTMetadata(nftRef.metadataId)
			}
		}
		return answer
	}

	init(
		_name: String,
		_description: String,
		_imagePath: String,
		_bannerImagePath: String?,
		_minting: Bool,
		_royalty: MetadataViews.Royalty?,
		_defaultPrice: UFix64,
		_paymentType: String,
		_ipfsCID: String,
		_lotteryBuying: Bool,
		_socials: {String: MetadataViews.ExternalURL},
		_mintVerifiers: [{MintVerifiers.IVerifier}]
	) {
		// Collection Info
		self.collectionInfo = {}
		self.collectionInfo["name"] = _name
		self.collectionInfo["description"] = _description
		self.collectionInfo["image"] = MetadataViews.IPFSFile(
			cid: _ipfsCID,
			path: _imagePath
		)
		if let bannerImagePath = _bannerImagePath {
			self.collectionInfo["bannerImage"] = MetadataViews.IPFSFile(
				cid: _ipfsCID,
				path: _bannerImagePath
			)
		}
		self.collectionInfo["ipfsCID"] = _ipfsCID
		self.collectionInfo["socials"] = _socials
		self.collectionInfo["minting"] = _minting
		self.collectionInfo["lotteryBuying"] = _lotteryBuying
		if let royalty = _royalty {
			assert(royalty.receiver.check(), message: "The passed in royalty receiver is not valid. The royalty account must set up the intended payment token.")
			assert(royalty.cut <= 0.95, message: "The royalty cut cannot be bigger than 95% because 5% goes to Emerald City treasury for primary sales.")
			self.collectionInfo["royalty"] = royalty
		}
		self.collectionInfo["price"] = _defaultPrice
		self.collectionInfo["paymentType"] = _paymentType
		self.collectionInfo["dateCreated"] = getCurrentBlock().timestamp
		self.collectionInfo["mintVerifiers"] = _mintVerifiers
		self.collectionInfo["profit"] = 0.0

		self.nextEditionId = 0
		self.nextMetadataId = 0
		self.totalSupply = 0
		self.metadatas = {}
		self.primaryBuyers = {}
		self.nftStorage <- {}

		// Set the named paths
		// We include the user's address in the paths.
		// This is to prevent clashing with existing
		// Collection paths in the ecosystem.
		self.CollectionStoragePath = /storage/TouchstoneFirstCollection_0x82b425681fb6a094
		self.CollectionPublicPath = /public/TouchstoneFirstCollection_0x82b425681fb6a094
		self.CollectionPrivatePath = /private/TouchstoneFirstCollection_0x82b425681fb6a094
		self.AdministratorStoragePath = /storage/TouchstoneFirstAdministrator_0x82b425681fb6a094

		// Create a Collection resource and save it to storage
		let collection <- create Collection()
		self.account.save(<- collection, to: self.CollectionStoragePath)

		// create a public capability for the collection
		self.account.link<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(
			self.CollectionPublicPath,
			target: self.CollectionStoragePath
		)

		// Create a Administrator resource and save it to storage
		let administrator <- create Administrator()
		self.account.save(<- administrator, to: self.AdministratorStoragePath)

		emit ContractInitialized()
	}
}
 "
-------
"// CREATED BY: Touchstone (https://touchstone.city/), a platform crafted by your best friends at Emerald City DAO (https://ecdao.org/).
// STATEMENT: This contract promises to keep the 5% royalty off of primary sales and 2.5% off of secondary sales to Emerald City DAO or risk permanent suspension from participation in the DAO and its tools.

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import FlowToken from 0x1654653399040a61
import MintVerifiers from 0x7a696d6136e1dce2
import FUSD from 0x3c5959b568896393
import EmeraldPass from 0x6a07dbeb03167a13

pub contract TouchstoneOdysseyoftheCryptoPharaohs: NonFungibleToken {

	// Collection Information
	access(self) let collectionInfo: {String: AnyStruct}

	// Contract Information
	pub var nextEditionId: UInt64
	pub var nextMetadataId: UInt64
	pub var totalSupply: UInt64

	// Events
	pub event ContractInitialized()
	pub event Withdraw(id: UInt64, from: Address?)
	pub event Deposit(id: UInt64, to: Address?)
	pub event TouchstonePurchase(id: UInt64, recipient: Address, metadataId: UInt64, name: String, description: String, image: MetadataViews.IPFSFile, price: UFix64)
	pub event Minted(id: UInt64, recipient: Address, metadataId: UInt64)
	pub event MintBatch(metadataIds: [UInt64], recipients: [Address])

	// Paths
	pub let CollectionStoragePath: StoragePath
	pub let CollectionPublicPath: PublicPath
	pub let CollectionPrivatePath: PrivatePath
	pub let AdministratorStoragePath: StoragePath

	// Maps metadataId of NFT to NFTMetadata
	access(account) let metadatas: {UInt64: NFTMetadata}

	// Maps the metadataId of an NFT to the primary buyer
	access(account) let primaryBuyers: {Address: {UInt64: [UInt64]}}

	access(account) let nftStorage: @{Address: {UInt64: NFT}}

	pub struct NFTMetadata {
		pub let metadataId: UInt64
		pub let name: String
		pub let description: String
		// The main image of the NFT
		pub let image: MetadataViews.IPFSFile
		// An optional thumbnail that can go along with it
		// for easier loading
		pub let thumbnail: MetadataViews.IPFSFile?
		// If price is nil, defaults to the collection price
		pub let price: UFix64?
		pub var extra: {String: AnyStruct}
		pub let supply: UInt64
		pub let purchasers: {UInt64: Address}

		access(account) fun purchased(serial: UInt64, buyer: Address) {
			self.purchasers[serial] = buyer
		}

		init(_name: String, _description: String, _image: MetadataViews.IPFSFile, _thumbnail: MetadataViews.IPFSFile?, _price: UFix64?, _extra: {String: AnyStruct}, _supply: UInt64) {
			self.metadataId = TouchstoneOdysseyoftheCryptoPharaohs.nextMetadataId
			self.name = _name
			self.description = _description
			self.image = _image
			self.thumbnail = _thumbnail
			self.price = _price
			self.extra = _extra
			self.supply = _supply
			self.purchasers = {}
		}
	}

	pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
		// The 'id' is the same as the 'uuid'
		pub let id: UInt64
		// The 'metadataId' is what maps this NFT to its 'NFTMetadata'
		pub let metadataId: UInt64
		pub let serial: UInt64

		pub fun getMetadata(): NFTMetadata {
			return TouchstoneOdysseyoftheCryptoPharaohs.getNFTMetadata(self.metadataId)!
		}

		pub fun getViews(): [Type] {
			return [
				Type<MetadataViews.Display>(),
				Type<MetadataViews.ExternalURL>(),
				Type<MetadataViews.NFTCollectionData>(),
				Type<MetadataViews.NFTCollectionDisplay>(),
				Type<MetadataViews.Royalties>(),
				Type<MetadataViews.Serial>(),
				Type<MetadataViews.Traits>(),
				Type<MetadataViews.NFTView>()
			]
		}

		pub fun resolveView(_ view: Type): AnyStruct? {
			switch view {
				case Type<MetadataViews.Display>():
					let metadata = self.getMetadata()
					return MetadataViews.Display(
						name: metadata.name,
						description: metadata.description,
						thumbnail: metadata.thumbnail ?? metadata.image
					)
				case Type<MetadataViews.NFTCollectionData>():
					return MetadataViews.NFTCollectionData(
						storagePath: TouchstoneOdysseyoftheCryptoPharaohs.CollectionStoragePath,
						publicPath: TouchstoneOdysseyoftheCryptoPharaohs.CollectionPublicPath,
						providerPath: TouchstoneOdysseyoftheCryptoPharaohs.CollectionPrivatePath,
						publicCollection: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
						publicLinkedType: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
						providerLinkedType: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, NonFungibleToken.Provider}>(),
						createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
								return <- TouchstoneOdysseyoftheCryptoPharaohs.createEmptyCollection()
						})
					)
				case Type<MetadataViews.ExternalURL>():
          return MetadataViews.ExternalURL("https://touchstone.city/discover/".concat(self.owner!.address.toString()).concat("/TouchstoneOdysseyoftheCryptoPharaohs"))
				case Type<MetadataViews.NFTCollectionDisplay>():
					let squareMedia = MetadataViews.Media(
						file: TouchstoneOdysseyoftheCryptoPharaohs.getCollectionAttribute(key: "image") as! MetadataViews.IPFSFile,
						mediaType: "image"
					)

					// If a banner image exists, use it
					// Otherwise, default to the main square image
					var bannerMedia: MetadataViews.Media? = nil
					if let bannerImage = TouchstoneOdysseyoftheCryptoPharaohs.getOptionalCollectionAttribute(key: "bannerImage") as! MetadataViews.IPFSFile? {
						bannerMedia = MetadataViews.Media(
							file: bannerImage,
							mediaType: "image"
						)
					}
					return MetadataViews.NFTCollectionDisplay(
						name: TouchstoneOdysseyoftheCryptoPharaohs.getCollectionAttribute(key: "name") as! String,
						description: TouchstoneOdysseyoftheCryptoPharaohs.getCollectionAttribute(key: "description") as! String,
						externalURL: MetadataViews.ExternalURL("https://touchstone.city/discover/".concat(self.owner!.address.toString()).concat("/TouchstoneOdysseyoftheCryptoPharaohs")),
						squareImage: squareMedia,
						bannerImage: bannerMedia ?? squareMedia,
						socials: TouchstoneOdysseyoftheCryptoPharaohs.getCollectionAttribute(key: "socials") as! {String: MetadataViews.ExternalURL}
					)
				case Type<MetadataViews.Royalties>():
					return MetadataViews.Royalties([
						// This is for Emerald City in favor of producing Touchstone, a free platform for our users. Failure to keep this in the contract may result in permanent suspension from Emerald City.
						MetadataViews.Royalty(
							recepient: getAccount(0x5643fd47a29770e7).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),
							cut: 0.025, // 2.5% royalty on secondary sales
							description: "Emerald City DAO receives a 2.5% royalty from secondary sales because this collection was created using Touchstone (https://touchstone.city/), a tool for creating your own NFT collections, crafted by Emerald City DAO."
						)
					])
				case Type<MetadataViews.Serial>():
					return MetadataViews.Serial(
						self.serial
					)
				case Type<MetadataViews.Traits>():
					return MetadataViews.dictToTraits(dict: self.getMetadata().extra, excludedNames: nil)
				case Type<MetadataViews.NFTView>():
					return MetadataViews.NFTView(
						id: self.id,
						uuid: self.uuid,
						display: self.resolveView(Type<MetadataViews.Display>()) as! MetadataViews.Display?,
						externalURL: self.resolveView(Type<MetadataViews.ExternalURL>()) as! MetadataViews.ExternalURL?,
						collectionData: self.resolveView(Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?,
						collectionDisplay: self.resolveView(Type<MetadataViews.NFTCollectionDisplay>()) as! MetadataViews.NFTCollectionDisplay?,
						royalties: self.resolveView(Type<MetadataViews.Royalties>()) as! MetadataViews.Royalties?,
						traits: self.resolveView(Type<MetadataViews.Traits>()) as! MetadataViews.Traits?
					)
			}
			return nil
		}

		init(_metadataId: UInt64, _serial: UInt64, _recipient: Address) {
			pre {
				TouchstoneOdysseyoftheCryptoPharaohs.metadatas[_metadataId] != nil:
					"This NFT does not exist yet."
				_serial < TouchstoneOdysseyoftheCryptoPharaohs.getNFTMetadata(_metadataId)!.supply:
					"This serial does not exist for this metadataId."
				!TouchstoneOdysseyoftheCryptoPharaohs.getNFTMetadata(_metadataId)!.purchasers.containsKey(_serial):
					"This serial has already been purchased."
			}
			self.id = self.uuid
			self.metadataId = _metadataId
			self.serial = _serial

			// Update the buyers list so we keep track of who is purchasing
			if let buyersRef = &TouchstoneOdysseyoftheCryptoPharaohs.primaryBuyers[_recipient] as &{UInt64: [UInt64]}? {
				if let metadataIdMap = &buyersRef[_metadataId] as &[UInt64]? {
					metadataIdMap.append(_serial)
				} else {
					buyersRef[_metadataId] = [_serial]
				}
			} else {
				TouchstoneOdysseyoftheCryptoPharaohs.primaryBuyers[_recipient] = {_metadataId: [_serial]}
			}

			// Update who bought this serial inside NFTMetadata so it cannot be purchased again.
			let metadataRef = (&TouchstoneOdysseyoftheCryptoPharaohs.metadatas[_metadataId] as &NFTMetadata?)!
			metadataRef.purchased(serial: _serial, buyer: _recipient)

			TouchstoneOdysseyoftheCryptoPharaohs.totalSupply = TouchstoneOdysseyoftheCryptoPharaohs.totalSupply + 1
			emit Minted(id: self.id, recipient: _recipient, metadataId: _metadataId)
		}
	}

	pub resource Collection: NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
		// dictionary of NFT conforming tokens
		// NFT is a resource type with an 'UInt64' ID field
		pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

		// withdraw removes an NFT from the collection and moves it to the caller
		pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
			let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

			emit Withdraw(id: token.id, from: self.owner?.address)

			return <-token
		}

		// deposit takes a NFT and adds it to the collections dictionary
		// and adds the ID to the id array
		pub fun deposit(token: @NonFungibleToken.NFT) {
			let token <- token as! @NFT

			let id: UInt64 = token.id

			// add the new token to the dictionary
			self.ownedNFTs[id] <-! token

			emit Deposit(id: id, to: self.owner?.address)
		}

		// getIDs returns an array of the IDs that are in the collection
		pub fun getIDs(): [UInt64] {
			return self.ownedNFTs.keys
		}

		// borrowNFT gets a reference to an NFT in the collection
		// so that the caller can read its metadata and call its methods
		pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
			return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
		}

		pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
			let token = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
			let nft = token as! &NFT
			return nft as &AnyResource{MetadataViews.Resolver}
		}

		pub fun claim() {
			if let storage = &TouchstoneOdysseyoftheCryptoPharaohs.nftStorage[self.owner!.address] as &{UInt64: NFT}? {
				for id in storage.keys {
					self.deposit(token: <- storage.remove(key: id)!)
				}
			}
		}

		init () {
			self.ownedNFTs <- {}
		}

		destroy() {
			destroy self.ownedNFTs
		}
	}

	// A function to mint NFTs.
	// You can only call this function if minting
	// is currently active.
	pub fun mintNFT(metadataId: UInt64, recipient: &{NonFungibleToken.Receiver}, payment: @FlowToken.Vault, serial: UInt64): UInt64 {
		pre {
			self.canMint(): "Minting is currently closed by the Administrator!"
			payment.balance == self.getPriceOfNFT(metadataId):
				"Payment does not match the price. You passed in ".concat(payment.balance.toString()).concat(" but this NFT costs ").concat(self.getPriceOfNFT(metadataId)!.toString())
		}
		let price: UFix64 = self.getPriceOfNFT(metadataId)!

		// Confirm recipient passes all verifiers
		for verifier in self.getMintVerifiers() {
			let params = {"minter": recipient.owner!.address}
			if let error = verifier.verify(params) {
				panic(error)
			}
		}

		// Handle Emerald City DAO royalty (5%)
		let EmeraldCityTreasury = getAccount(0x5643fd47a29770e7).getCapability(/public/flowTokenReceiver)
								.borrow<&FlowToken.Vault{FungibleToken.Receiver}>()!
		let emeraldCityCut: UFix64 = 0.05 * price

		// Handle royalty to user that was configured upon creation
		if let royalty = TouchstoneOdysseyoftheCryptoPharaohs.getOptionalCollectionAttribute(key: "royalty") as! MetadataViews.Royalty? {
			royalty.receiver.borrow()!.deposit(from: <- payment.withdraw(amount: price * royalty.cut))
		}

		EmeraldCityTreasury.deposit(from: <- payment.withdraw(amount: emeraldCityCut))

		// Give the rest to the collection owner
		let paymentRecipient = self.account.getCapability(/public/flowTokenReceiver)
								.borrow<&FlowToken.Vault{FungibleToken.Receiver}>()!
		paymentRecipient.deposit(from: <- payment)

		// Mint the nft
		let nft <- create NFT(_metadataId: metadataId, _serial: serial, _recipient: recipient.owner!.address)
		let nftId: UInt64 = nft.id
		let metadata = self.getNFTMetadata(metadataId)!
		self.collectionInfo["profit"] = (self.getCollectionAttribute(key: "profit") as! UFix64) + price

		// Emit event
		emit TouchstonePurchase(id: nftId, recipient: recipient.owner!.address, metadataId: metadataId, name: metadata.name, description: metadata.description, image: metadata.image, price: price)

		// Deposit nft
		recipient.deposit(token: <- nft)

		return nftId
	}

	pub resource Administrator {
		pub fun createNFTMetadata(name: String, description: String, imagePath: String, thumbnailPath: String?, ipfsCID: String, price: UFix64?, extra: {String: AnyStruct}, supply: UInt64) {
			TouchstoneOdysseyoftheCryptoPharaohs.metadatas[TouchstoneOdysseyoftheCryptoPharaohs.nextMetadataId] = NFTMetadata(
				_name: name,
				_description: description,
				_image: MetadataViews.IPFSFile(
					cid: ipfsCID,
					path: imagePath
				),
				_thumbnail: thumbnailPath == nil ? nil : MetadataViews.IPFSFile(cid: ipfsCID, path: thumbnailPath),
				_price: price,
				_extra: extra,
				_supply: supply
			)
			TouchstoneOdysseyoftheCryptoPharaohs.nextMetadataId = TouchstoneOdysseyoftheCryptoPharaohs.nextMetadataId + 1
		}

		// mintNFT mints a new NFT and deposits
		// it in the recipients collection
		pub fun mintNFT(metadataId: UInt64, serial: UInt64, recipient: Address) {
			pre {
				EmeraldPass.isActive(user: TouchstoneOdysseyoftheCryptoPharaohs.account.address): "You must have an active Emerald Pass subscription to airdrop NFTs. You can purchase Emerald Pass at https://pass.ecdao.org/"
			}
			let nft <- create NFT(_metadataId: metadataId, _serial: serial, _recipient: recipient)
			if let recipientCollection = getAccount(recipient).getCapability(TouchstoneOdysseyoftheCryptoPharaohs.CollectionPublicPath).borrow<&TouchstoneOdysseyoftheCryptoPharaohs.Collection{NonFungibleToken.CollectionPublic}>() {
				recipientCollection.deposit(token: <- nft)
			} else {
				if let storage = &TouchstoneOdysseyoftheCryptoPharaohs.nftStorage[recipient] as &{UInt64: NFT}? {
					storage[nft.id] <-! nft
				} else {
					TouchstoneOdysseyoftheCryptoPharaohs.nftStorage[recipient] <-! {nft.id: <- nft}
				}
			}
		}

		pub fun mintBatch(metadataIds: [UInt64], serials: [UInt64], recipients: [Address]) {
			pre {
				metadataIds.length == recipients.length: "You need to pass in an equal number of metadataIds and recipients."
			}
			var i = 0
			while i < metadataIds.length {
				self.mintNFT(metadataId: metadataIds[i], serial: serials[i], recipient: recipients[i])
				i = i + 1
			}

			emit MintBatch(metadataIds: metadataIds, recipients: recipients)
		}

		// create a new Administrator resource
		pub fun createAdmin(): @Administrator {
			return <- create Administrator()
		}

		// change piece of collection info
		pub fun changeField(key: String, value: AnyStruct) {
			TouchstoneOdysseyoftheCryptoPharaohs.collectionInfo[key] = value
		}
	}

	// public function that anyone can call to create a new empty collection
	pub fun createEmptyCollection(): @NonFungibleToken.Collection {
		return <- create Collection()
	}

	// Get information about a NFTMetadata
	pub fun getNFTMetadata(_ metadataId: UInt64): NFTMetadata? {
		return self.metadatas[metadataId]
	}

	pub fun getNFTMetadatas(): {UInt64: NFTMetadata} {
		return self.metadatas
	}

	pub fun getPrimaryBuyers(): {Address: {UInt64: [UInt64]}} {
		return self.primaryBuyers
	}

	pub fun getCollectionInfo(): {String: AnyStruct} {
		let collectionInfo = self.collectionInfo
		collectionInfo["metadatas"] = self.metadatas
		collectionInfo["primaryBuyers"] = self.primaryBuyers
		collectionInfo["totalSupply"] = self.totalSupply
		collectionInfo["nextMetadataId"] = self.nextMetadataId
		collectionInfo["version"] = 1
		return collectionInfo
	}

	pub fun getCollectionAttribute(key: String): AnyStruct {
		return self.collectionInfo[key] ?? panic(key.concat(" is not an attribute in this collection."))
	}

	pub fun getOptionalCollectionAttribute(key: String): AnyStruct? {
		return self.collectionInfo[key]
	}

	pub fun getMintVerifiers(): [{MintVerifiers.IVerifier}] {
		return self.getCollectionAttribute(key: "mintVerifiers") as! [{MintVerifiers.IVerifier}]
	}

	pub fun canMint(): Bool {
		return self.getCollectionAttribute(key: "minting") as! Bool
	}

	// Returns nil if an NFT with this metadataId doesn't exist
	pub fun getPriceOfNFT(_ metadataId: UInt64): UFix64? {
		if let metadata: TouchstoneOdysseyoftheCryptoPharaohs.NFTMetadata = self.getNFTMetadata(metadataId) {
			let defaultPrice: UFix64 = self.getCollectionAttribute(key: "price") as! UFix64
			if self.getCollectionAttribute(key: "lotteryBuying") as! Bool {
				return defaultPrice
			}
			return metadata.price ?? defaultPrice
		}
		// If the metadataId doesn't exist
		return nil
	}

	// Returns an mapping of `id` to NFTMetadata
	// for the NFTs a user can claim
	pub fun getClaimableNFTs(user: Address): {UInt64: NFTMetadata} {
		let answer: {UInt64: NFTMetadata} = {}
		if let storage = &TouchstoneOdysseyoftheCryptoPharaohs.nftStorage[user] as &{UInt64: NFT}? {
			for id in storage.keys {
				let nftRef = (&storage[id] as &NFT?)!
				answer[id] = self.getNFTMetadata(nftRef.metadataId)
			}
		}
		return answer
	}

	init(
		_name: String,
		_description: String,
		_imagePath: String,
		_bannerImagePath: String?,
		_minting: Bool,
		_royalty: MetadataViews.Royalty?,
		_defaultPrice: UFix64,
		_paymentType: String,
		_ipfsCID: String,
		_lotteryBuying: Bool,
		_socials: {String: MetadataViews.ExternalURL},
		_mintVerifiers: [{MintVerifiers.IVerifier}]
	) {
		// Collection Info
		self.collectionInfo = {}
		self.collectionInfo["name"] = _name
		self.collectionInfo["description"] = _description
		self.collectionInfo["image"] = MetadataViews.IPFSFile(
			cid: _ipfsCID,
			path: _imagePath
		)
		if let bannerImagePath = _bannerImagePath {
			self.collectionInfo["bannerImage"] = MetadataViews.IPFSFile(
				cid: _ipfsCID,
				path: _bannerImagePath
			)
		}
		self.collectionInfo["ipfsCID"] = _ipfsCID
		self.collectionInfo["socials"] = _socials
		self.collectionInfo["minting"] = _minting
		self.collectionInfo["lotteryBuying"] = _lotteryBuying
		if let royalty = _royalty {
			assert(royalty.receiver.check(), message: "The passed in royalty receiver is not valid. The royalty account must set up the intended payment token.")
			assert(royalty.cut <= 0.95, message: "The royalty cut cannot be bigger than 95% because 5% goes to Emerald City treasury for primary sales.")
			self.collectionInfo["royalty"] = royalty
		}
		self.collectionInfo["price"] = _defaultPrice
		self.collectionInfo["paymentType"] = _paymentType
		self.collectionInfo["dateCreated"] = getCurrentBlock().timestamp
		self.collectionInfo["mintVerifiers"] = _mintVerifiers
		self.collectionInfo["profit"] = 0.0

		self.nextEditionId = 0
		self.nextMetadataId = 0
		self.totalSupply = 0
		self.metadatas = {}
		self.primaryBuyers = {}
		self.nftStorage <- {}

		// Set the named paths
		// We include the user's address in the paths.
		// This is to prevent clashing with existing
		// Collection paths in the ecosystem.
		self.CollectionStoragePath = /storage/TouchstoneOdysseyoftheCryptoPharaohsCollection_0x7dc1aa82a2f8d409
		self.CollectionPublicPath = /public/TouchstoneOdysseyoftheCryptoPharaohsCollection_0x7dc1aa82a2f8d409
		self.CollectionPrivatePath = /private/TouchstoneOdysseyoftheCryptoPharaohsCollection_0x7dc1aa82a2f8d409
		self.AdministratorStoragePath = /storage/TouchstoneOdysseyoftheCryptoPharaohsAdministrator_0x7dc1aa82a2f8d409

		// Create a Collection resource and save it to storage
		let collection <- create Collection()
		self.account.save(<- collection, to: self.CollectionStoragePath)

		// create a public capability for the collection
		self.account.link<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(
			self.CollectionPublicPath,
			target: self.CollectionStoragePath
		)

		// Create a Administrator resource and save it to storage
		let administrator <- create Administrator()
		self.account.save(<- administrator, to: self.AdministratorStoragePath)

		emit ContractInitialized()
	}
}
 "
-------
"/**

# This contract stores some commonly used paths & library functions for PriceOracle

# Author Increment Labs

*/

pub contract OracleConfig {
    // Admin resource stored in every PriceOracle contract
    pub let OracleAdminPath: StoragePath
    // Reader public interface exposed in every PriceOracle contract
    pub let OraclePublicInterface_ReaderPath: PublicPath
    // Feeder public interface exposed in every PriceOracle contract
    pub let OraclePublicInterface_FeederPath: PublicPath
    // Recommended storage path of reader's certificate
    pub let ReaderCertificateStoragePath: StoragePath

    pub fun sortUFix64List(list: [UFix64]): [UFix64] {
        let len = list.length
        var preIndex = 0
        var current = 0.0
        var i = 1
        while (i < len) {
            preIndex = i - 1
            current = list[i];
            while(preIndex >= 0 && list[preIndex] > current) {
                list[preIndex+1] = list[preIndex]
                preIndex = preIndex - 1
            }
            list[preIndex+1] = current
            i = i + 1
        }
        return list
    }

    pub fun sortUInt64List(list: [UInt64]): [UInt64] {
        let len = list.length
        var preIndex = 0
        var current: UInt64 = 0
        var i = 1
        while (i < len) {
            preIndex = i - 1
            current = list[i];
            while(preIndex >= 0 && list[preIndex] > current) {
                list[preIndex+1] = list[preIndex]
                preIndex = preIndex - 1
            }
            list[preIndex+1] = current
            i = i + 1
        }
        return list
    }

    init() {
        self.OracleAdminPath = /storage/increment_oracle_admin
        self.OraclePublicInterface_ReaderPath = /public/increment_oracle_reader_public
        self.OraclePublicInterface_FeederPath = /public/increment_oracle_feeder_public
        self.ReaderCertificateStoragePath = /storage/increment_oracle_reader_certificate
    }
}"
-------
"// CREATED BY: Touchstone (https://touchstone.city/), a platform crafted by your best friends at Emerald City DAO (https://ecdao.org/).
// STATEMENT: This contract promises to keep the 5% royalty off of primary sales and 2.5% off of secondary sales to Emerald City DAO or risk permanent suspension from participation in the DAO and its tools.

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import FlowToken from 0x1654653399040a61
import MintVerifiers from 0x7a696d6136e1dce2
import FUSD from 0x3c5959b568896393
import EmeraldPass from 0x6a07dbeb03167a13

pub contract TouchstoneWFFL: NonFungibleToken {

	// Collection Information
	access(self) let collectionInfo: {String: AnyStruct}

	// Contract Information
	pub var nextEditionId: UInt64
	pub var nextMetadataId: UInt64
	pub var totalSupply: UInt64

	// Events
	pub event ContractInitialized()
	pub event Withdraw(id: UInt64, from: Address?)
	pub event Deposit(id: UInt64, to: Address?)
	pub event TouchstonePurchase(id: UInt64, recipient: Address, metadataId: UInt64, name: String, description: String, image: MetadataViews.IPFSFile, price: UFix64)
	pub event Minted(id: UInt64, recipient: Address, metadataId: UInt64)
	pub event MintBatch(metadataIds: [UInt64], recipients: [Address])

	// Paths
	pub let CollectionStoragePath: StoragePath
	pub let CollectionPublicPath: PublicPath
	pub let CollectionPrivatePath: PrivatePath
	pub let AdministratorStoragePath: StoragePath

	// Maps metadataId of NFT to NFTMetadata
	access(account) let metadatas: {UInt64: NFTMetadata}

	// Maps the metadataId of an NFT to the primary buyer
	access(account) let primaryBuyers: {Address: {UInt64: [UInt64]}}

	access(account) let nftStorage: @{Address: {UInt64: NFT}}

	pub struct NFTMetadata {
		pub let metadataId: UInt64
		pub let name: String
		pub let description: String
		// The main image of the NFT
		pub let image: MetadataViews.IPFSFile
		// An optional thumbnail that can go along with it
		// for easier loading
		pub let thumbnail: MetadataViews.IPFSFile?
		// If price is nil, defaults to the collection price
		pub let price: UFix64?
		pub var extra: {String: AnyStruct}
		pub let supply: UInt64
		pub let purchasers: {UInt64: Address}

		access(account) fun purchased(serial: UInt64, buyer: Address) {
			self.purchasers[serial] = buyer
		}

		init(_name: String, _description: String, _image: MetadataViews.IPFSFile, _thumbnail: MetadataViews.IPFSFile?, _price: UFix64?, _extra: {String: AnyStruct}, _supply: UInt64) {
			self.metadataId = TouchstoneWFFL.nextMetadataId
			self.name = _name
			self.description = _description
			self.image = _image
			self.thumbnail = _thumbnail
			self.price = _price
			self.extra = _extra
			self.supply = _supply
			self.purchasers = {}
		}
	}

	pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
		// The 'id' is the same as the 'uuid'
		pub let id: UInt64
		// The 'metadataId' is what maps this NFT to its 'NFTMetadata'
		pub let metadataId: UInt64
		pub let serial: UInt64

		pub fun getMetadata(): NFTMetadata {
			return TouchstoneWFFL.getNFTMetadata(self.metadataId)!
		}

		pub fun getViews(): [Type] {
			return [
				Type<MetadataViews.Display>(),
				Type<MetadataViews.ExternalURL>(),
				Type<MetadataViews.NFTCollectionData>(),
				Type<MetadataViews.NFTCollectionDisplay>(),
				Type<MetadataViews.Royalties>(),
				Type<MetadataViews.Serial>(),
				Type<MetadataViews.Traits>(),
				Type<MetadataViews.NFTView>()
			]
		}

		pub fun resolveView(_ view: Type): AnyStruct? {
			switch view {
				case Type<MetadataViews.Display>():
					let metadata = self.getMetadata()
					return MetadataViews.Display(
						name: metadata.name,
						description: metadata.description,
						thumbnail: metadata.thumbnail ?? metadata.image
					)
				case Type<MetadataViews.NFTCollectionData>():
					return MetadataViews.NFTCollectionData(
						storagePath: TouchstoneWFFL.CollectionStoragePath,
						publicPath: TouchstoneWFFL.CollectionPublicPath,
						providerPath: TouchstoneWFFL.CollectionPrivatePath,
						publicCollection: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
						publicLinkedType: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
						providerLinkedType: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, NonFungibleToken.Provider}>(),
						createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
								return <- TouchstoneWFFL.createEmptyCollection()
						})
					)
				case Type<MetadataViews.ExternalURL>():
          return MetadataViews.ExternalURL("https://touchstone.city/discover/".concat(self.owner!.address.toString()).concat("/TouchstoneWFFL"))
				case Type<MetadataViews.NFTCollectionDisplay>():
					let squareMedia = MetadataViews.Media(
						file: TouchstoneWFFL.getCollectionAttribute(key: "image") as! MetadataViews.IPFSFile,
						mediaType: "image"
					)

					// If a banner image exists, use it
					// Otherwise, default to the main square image
					var bannerMedia: MetadataViews.Media? = nil
					if let bannerImage = TouchstoneWFFL.getOptionalCollectionAttribute(key: "bannerImage") as! MetadataViews.IPFSFile? {
						bannerMedia = MetadataViews.Media(
							file: bannerImage,
							mediaType: "image"
						)
					}
					return MetadataViews.NFTCollectionDisplay(
						name: TouchstoneWFFL.getCollectionAttribute(key: "name") as! String,
						description: TouchstoneWFFL.getCollectionAttribute(key: "description") as! String,
						externalURL: MetadataViews.ExternalURL("https://touchstone.city/discover/".concat(self.owner!.address.toString()).concat("/TouchstoneWFFL")),
						squareImage: squareMedia,
						bannerImage: bannerMedia ?? squareMedia,
						socials: TouchstoneWFFL.getCollectionAttribute(key: "socials") as! {String: MetadataViews.ExternalURL}
					)
				case Type<MetadataViews.Royalties>():
					return MetadataViews.Royalties([
						// This is for Emerald City in favor of producing Touchstone, a free platform for our users. Failure to keep this in the contract may result in permanent suspension from Emerald City.
						MetadataViews.Royalty(
							recepient: getAccount(0x5643fd47a29770e7).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),
							cut: 0.025, // 2.5% royalty on secondary sales
							description: "Emerald City DAO receives a 2.5% royalty from secondary sales because this collection was created using Touchstone (https://touchstone.city/), a tool for creating your own NFT collections, crafted by Emerald City DAO."
						)
					])
				case Type<MetadataViews.Serial>():
					return MetadataViews.Serial(
						self.serial
					)
				case Type<MetadataViews.Traits>():
					return MetadataViews.dictToTraits(dict: self.getMetadata().extra, excludedNames: nil)
				case Type<MetadataViews.NFTView>():
					return MetadataViews.NFTView(
						id: self.id,
						uuid: self.uuid,
						display: self.resolveView(Type<MetadataViews.Display>()) as! MetadataViews.Display?,
						externalURL: self.resolveView(Type<MetadataViews.ExternalURL>()) as! MetadataViews.ExternalURL?,
						collectionData: self.resolveView(Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?,
						collectionDisplay: self.resolveView(Type<MetadataViews.NFTCollectionDisplay>()) as! MetadataViews.NFTCollectionDisplay?,
						royalties: self.resolveView(Type<MetadataViews.Royalties>()) as! MetadataViews.Royalties?,
						traits: self.resolveView(Type<MetadataViews.Traits>()) as! MetadataViews.Traits?
					)
			}
			return nil
		}

		init(_metadataId: UInt64, _serial: UInt64, _recipient: Address) {
			pre {
				TouchstoneWFFL.metadatas[_metadataId] != nil:
					"This NFT does not exist yet."
				_serial < TouchstoneWFFL.getNFTMetadata(_metadataId)!.supply:
					"This serial does not exist for this metadataId."
				!TouchstoneWFFL.getNFTMetadata(_metadataId)!.purchasers.containsKey(_serial):
					"This serial has already been purchased."
			}
			self.id = self.uuid
			self.metadataId = _metadataId
			self.serial = _serial

			// Update the buyers list so we keep track of who is purchasing
			if let buyersRef = &TouchstoneWFFL.primaryBuyers[_recipient] as &{UInt64: [UInt64]}? {
				if let metadataIdMap = &buyersRef[_metadataId] as &[UInt64]? {
					metadataIdMap.append(_serial)
				} else {
					buyersRef[_metadataId] = [_serial]
				}
			} else {
				TouchstoneWFFL.primaryBuyers[_recipient] = {_metadataId: [_serial]}
			}

			// Update who bought this serial inside NFTMetadata so it cannot be purchased again.
			let metadataRef = (&TouchstoneWFFL.metadatas[_metadataId] as &NFTMetadata?)!
			metadataRef.purchased(serial: _serial, buyer: _recipient)

			TouchstoneWFFL.totalSupply = TouchstoneWFFL.totalSupply + 1
			emit Minted(id: self.id, recipient: _recipient, metadataId: _metadataId)
		}
	}

	pub resource Collection: NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
		// dictionary of NFT conforming tokens
		// NFT is a resource type with an 'UInt64' ID field
		pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

		// withdraw removes an NFT from the collection and moves it to the caller
		pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
			let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

			emit Withdraw(id: token.id, from: self.owner?.address)

			return <-token
		}

		// deposit takes a NFT and adds it to the collections dictionary
		// and adds the ID to the id array
		pub fun deposit(token: @NonFungibleToken.NFT) {
			let token <- token as! @NFT

			let id: UInt64 = token.id

			// add the new token to the dictionary
			self.ownedNFTs[id] <-! token

			emit Deposit(id: id, to: self.owner?.address)
		}

		// getIDs returns an array of the IDs that are in the collection
		pub fun getIDs(): [UInt64] {
			return self.ownedNFTs.keys
		}

		// borrowNFT gets a reference to an NFT in the collection
		// so that the caller can read its metadata and call its methods
		pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
			return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
		}

		pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
			let token = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
			let nft = token as! &NFT
			return nft as &AnyResource{MetadataViews.Resolver}
		}

		pub fun claim() {
			if let storage = &TouchstoneWFFL.nftStorage[self.owner!.address] as &{UInt64: NFT}? {
				for id in storage.keys {
					self.deposit(token: <- storage.remove(key: id)!)
				}
			}
		}

		init () {
			self.ownedNFTs <- {}
		}

		destroy() {
			destroy self.ownedNFTs
		}
	}

	// A function to mint NFTs.
	// You can only call this function if minting
	// is currently active.
	pub fun mintNFT(metadataId: UInt64, recipient: &{NonFungibleToken.Receiver}, payment: @FlowToken.Vault, serial: UInt64): UInt64 {
		pre {
			self.canMint(): "Minting is currently closed by the Administrator!"
			payment.balance == self.getPriceOfNFT(metadataId):
				"Payment does not match the price. You passed in ".concat(payment.balance.toString()).concat(" but this NFT costs ").concat(self.getPriceOfNFT(metadataId)!.toString())
		}
		let price: UFix64 = self.getPriceOfNFT(metadataId)!

		// Confirm recipient passes all verifiers
		for verifier in self.getMintVerifiers() {
			let params = {"minter": recipient.owner!.address}
			if let error = verifier.verify(params) {
				panic(error)
			}
		}

		// Handle Emerald City DAO royalty (5%)
		let EmeraldCityTreasury = getAccount(0x5643fd47a29770e7).getCapability(/public/flowTokenReceiver)
								.borrow<&FlowToken.Vault{FungibleToken.Receiver}>()!
		let emeraldCityCut: UFix64 = 0.05 * price

		// Handle royalty to user that was configured upon creation
		if let royalty = TouchstoneWFFL.getOptionalCollectionAttribute(key: "royalty") as! MetadataViews.Royalty? {
			royalty.receiver.borrow()!.deposit(from: <- payment.withdraw(amount: price * royalty.cut))
		}

		EmeraldCityTreasury.deposit(from: <- payment.withdraw(amount: emeraldCityCut))

		// Give the rest to the collection owner
		let paymentRecipient = self.account.getCapability(/public/flowTokenReceiver)
								.borrow<&FlowToken.Vault{FungibleToken.Receiver}>()!
		paymentRecipient.deposit(from: <- payment)

		// Mint the nft
		let nft <- create NFT(_metadataId: metadataId, _serial: serial, _recipient: recipient.owner!.address)
		let nftId: UInt64 = nft.id
		let metadata = self.getNFTMetadata(metadataId)!
		self.collectionInfo["profit"] = (self.getCollectionAttribute(key: "profit") as! UFix64) + price

		// Emit event
		emit TouchstonePurchase(id: nftId, recipient: recipient.owner!.address, metadataId: metadataId, name: metadata.name, description: metadata.description, image: metadata.image, price: price)

		// Deposit nft
		recipient.deposit(token: <- nft)

		return nftId
	}

	pub resource Administrator {
		pub fun createNFTMetadata(name: String, description: String, imagePath: String, thumbnailPath: String?, ipfsCID: String, price: UFix64?, extra: {String: AnyStruct}, supply: UInt64) {
			TouchstoneWFFL.metadatas[TouchstoneWFFL.nextMetadataId] = NFTMetadata(
				_name: name,
				_description: description,
				_image: MetadataViews.IPFSFile(
					cid: ipfsCID,
					path: imagePath
				),
				_thumbnail: thumbnailPath == nil ? nil : MetadataViews.IPFSFile(cid: ipfsCID, path: thumbnailPath),
				_price: price,
				_extra: extra,
				_supply: supply
			)
			TouchstoneWFFL.nextMetadataId = TouchstoneWFFL.nextMetadataId + 1
		}

		// mintNFT mints a new NFT and deposits
		// it in the recipients collection
		pub fun mintNFT(metadataId: UInt64, serial: UInt64, recipient: Address) {
			pre {
				EmeraldPass.isActive(user: TouchstoneWFFL.account.address): "You must have an active Emerald Pass subscription to airdrop NFTs. You can purchase Emerald Pass at https://pass.ecdao.org/"
			}
			let nft <- create NFT(_metadataId: metadataId, _serial: serial, _recipient: recipient)
			if let recipientCollection = getAccount(recipient).getCapability(TouchstoneWFFL.CollectionPublicPath).borrow<&TouchstoneWFFL.Collection{NonFungibleToken.CollectionPublic}>() {
				recipientCollection.deposit(token: <- nft)
			} else {
				if let storage = &TouchstoneWFFL.nftStorage[recipient] as &{UInt64: NFT}? {
					storage[nft.id] <-! nft
				} else {
					TouchstoneWFFL.nftStorage[recipient] <-! {nft.id: <- nft}
				}
			}
		}

		pub fun mintBatch(metadataIds: [UInt64], serials: [UInt64], recipients: [Address]) {
			pre {
				metadataIds.length == recipients.length: "You need to pass in an equal number of metadataIds and recipients."
			}
			var i = 0
			while i < metadataIds.length {
				self.mintNFT(metadataId: metadataIds[i], serial: serials[i], recipient: recipients[i])
				i = i + 1
			}

			emit MintBatch(metadataIds: metadataIds, recipients: recipients)
		}

		// create a new Administrator resource
		pub fun createAdmin(): @Administrator {
			return <- create Administrator()
		}

		// change piece of collection info
		pub fun changeField(key: String, value: AnyStruct) {
			TouchstoneWFFL.collectionInfo[key] = value
		}
	}

	// public function that anyone can call to create a new empty collection
	pub fun createEmptyCollection(): @NonFungibleToken.Collection {
		return <- create Collection()
	}

	// Get information about a NFTMetadata
	pub fun getNFTMetadata(_ metadataId: UInt64): NFTMetadata? {
		return self.metadatas[metadataId]
	}

	pub fun getNFTMetadatas(): {UInt64: NFTMetadata} {
		return self.metadatas
	}

	pub fun getPrimaryBuyers(): {Address: {UInt64: [UInt64]}} {
		return self.primaryBuyers
	}

	pub fun getCollectionInfo(): {String: AnyStruct} {
		let collectionInfo = self.collectionInfo
		collectionInfo["metadatas"] = self.metadatas
		collectionInfo["primaryBuyers"] = self.primaryBuyers
		collectionInfo["totalSupply"] = self.totalSupply
		collectionInfo["nextMetadataId"] = self.nextMetadataId
		collectionInfo["version"] = 1
		return collectionInfo
	}

	pub fun getCollectionAttribute(key: String): AnyStruct {
		return self.collectionInfo[key] ?? panic(key.concat(" is not an attribute in this collection."))
	}

	pub fun getOptionalCollectionAttribute(key: String): AnyStruct? {
		return self.collectionInfo[key]
	}

	pub fun getMintVerifiers(): [{MintVerifiers.IVerifier}] {
		return self.getCollectionAttribute(key: "mintVerifiers") as! [{MintVerifiers.IVerifier}]
	}

	pub fun canMint(): Bool {
		return self.getCollectionAttribute(key: "minting") as! Bool
	}

	// Returns nil if an NFT with this metadataId doesn't exist
	pub fun getPriceOfNFT(_ metadataId: UInt64): UFix64? {
		if let metadata: TouchstoneWFFL.NFTMetadata = self.getNFTMetadata(metadataId) {
			let defaultPrice: UFix64 = self.getCollectionAttribute(key: "price") as! UFix64
			if self.getCollectionAttribute(key: "lotteryBuying") as! Bool {
				return defaultPrice
			}
			return metadata.price ?? defaultPrice
		}
		// If the metadataId doesn't exist
		return nil
	}

	// Returns an mapping of `id` to NFTMetadata
	// for the NFTs a user can claim
	pub fun getClaimableNFTs(user: Address): {UInt64: NFTMetadata} {
		let answer: {UInt64: NFTMetadata} = {}
		if let storage = &TouchstoneWFFL.nftStorage[user] as &{UInt64: NFT}? {
			for id in storage.keys {
				let nftRef = (&storage[id] as &NFT?)!
				answer[id] = self.getNFTMetadata(nftRef.metadataId)
			}
		}
		return answer
	}

	init(
		_name: String,
		_description: String,
		_imagePath: String,
		_bannerImagePath: String?,
		_minting: Bool,
		_royalty: MetadataViews.Royalty?,
		_defaultPrice: UFix64,
		_paymentType: String,
		_ipfsCID: String,
		_lotteryBuying: Bool,
		_socials: {String: MetadataViews.ExternalURL},
		_mintVerifiers: [{MintVerifiers.IVerifier}]
	) {
		// Collection Info
		self.collectionInfo = {}
		self.collectionInfo["name"] = _name
		self.collectionInfo["description"] = _description
		self.collectionInfo["image"] = MetadataViews.IPFSFile(
			cid: _ipfsCID,
			path: _imagePath
		)
		if let bannerImagePath = _bannerImagePath {
			self.collectionInfo["bannerImage"] = MetadataViews.IPFSFile(
				cid: _ipfsCID,
				path: _bannerImagePath
			)
		}
		self.collectionInfo["ipfsCID"] = _ipfsCID
		self.collectionInfo["socials"] = _socials
		self.collectionInfo["minting"] = _minting
		self.collectionInfo["lotteryBuying"] = _lotteryBuying
		if let royalty = _royalty {
			assert(royalty.receiver.check(), message: "The passed in royalty receiver is not valid. The royalty account must set up the intended payment token.")
			assert(royalty.cut <= 0.95, message: "The royalty cut cannot be bigger than 95% because 5% goes to Emerald City treasury for primary sales.")
			self.collectionInfo["royalty"] = royalty
		}
		self.collectionInfo["price"] = _defaultPrice
		self.collectionInfo["paymentType"] = _paymentType
		self.collectionInfo["dateCreated"] = getCurrentBlock().timestamp
		self.collectionInfo["mintVerifiers"] = _mintVerifiers
		self.collectionInfo["profit"] = 0.0

		self.nextEditionId = 0
		self.nextMetadataId = 0
		self.totalSupply = 0
		self.metadatas = {}
		self.primaryBuyers = {}
		self.nftStorage <- {}

		// Set the named paths
		// We include the user's address in the paths.
		// This is to prevent clashing with existing
		// Collection paths in the ecosystem.
		self.CollectionStoragePath = /storage/TouchstoneWFFLCollection_0x33db9c4d319ab1e8
		self.CollectionPublicPath = /public/TouchstoneWFFLCollection_0x33db9c4d319ab1e8
		self.CollectionPrivatePath = /private/TouchstoneWFFLCollection_0x33db9c4d319ab1e8
		self.AdministratorStoragePath = /storage/TouchstoneWFFLAdministrator_0x33db9c4d319ab1e8

		// Create a Collection resource and save it to storage
		let collection <- create Collection()
		self.account.save(<- collection, to: self.CollectionStoragePath)

		// create a public capability for the collection
		self.account.link<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(
			self.CollectionPublicPath,
			target: self.CollectionStoragePath
		)

		// Create a Administrator resource and save it to storage
		let administrator <- create Administrator()
		self.account.save(<- administrator, to: self.AdministratorStoragePath)

		emit ContractInitialized()
	}
}
 "
-------
"/*
ifeelslick

This is the contract for ifeelslick NFTs!

This was implemented using Niftory interfaces. For full details on how this
contract functions, please see the Niftory and NFTRegistry contracts.

*/

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import ViewResolver from 0x1d7e57aa55817448

import MutableMetadata from 0x7ec1f607f0872a9e
import MutableMetadataTemplate from 0x7ec1f607f0872a9e
import MutableMetadataSet from 0x7ec1f607f0872a9e
import MutableMetadataSetManager from 0x7ec1f607f0872a9e
import MetadataViewsManager from 0x7ec1f607f0872a9e

import NiftoryNonFungibleToken from 0x7ec1f607f0872a9e
import NiftoryNFTRegistry from 0x7ec1f607f0872a9e

import NiftoryMetadataViewsResolvers from 0x7ec1f607f0872a9e
import NiftoryNonFungibleTokenProxy from 0x7ec1f607f0872a9e

pub contract ifeelslick: NonFungibleToken, ViewResolver {

  // ========================================================================
  // Constants
  // ========================================================================

  // Suggested paths where collection could be stored
  pub let COLLECTION_PRIVATE_PATH: PrivatePath
  pub let COLLECTION_PUBLIC_PATH: PublicPath
  pub let COLLECTION_STORAGE_PATH: StoragePath

  // Accessor token to be used with NiftoryNFTRegistry to retrieve
  // meta-information about this NFT project
  pub let REGISTRY_ADDRESS: Address
  pub let REGISTRY_BRAND: String

  // ========================================================================
  // Attributes
  // ========================================================================

  // Arbitrary metadata for this NFT contract
  pub var metadata: AnyStruct?

  // Number of NFTs created
  pub var totalSupply: UInt64

  // ========================================================================
  // Contract Events
  // ========================================================================

  // This contract was initialized
  pub event ContractInitialized()

  // A withdrawal of NFT `id` has occurred from the `from` Address
  pub event Withdraw(id: UInt64, from: Address?)

  // A deposit of an NFT `id` has occurred to the `to` Address
  pub event Deposit(id: UInt64, to: Address?)

  ///////////////////////////////////////////////////////////////////////////

  // Contract metadata was modified
  pub event ContractMetadataUpdated()

  // Metadata Views Manager was locked
  pub event MetadataViewsManagerLocked()

  // Metadata Views Resolver was added
  pub event MetadataViewsResolverAdded(type: Type)

  // Metadata Views Resolver was removed
  pub event MetadataViewsResolverRemoved(type: Type)

  // Set Manager Name or Description updated
  pub event SetManagerMetadataUpdated()

  // Set added to Set Manager
  pub event SetAddedToSetManager(setID: Int)

  ///////////////////////////////////////////////////////////////////////////

  // Set `setId` was locked (no new templates can be added)
  pub event SetLocked(setId: Int)

  // The metadata for Set `setId` was locked and cannot be modified
  pub event SetMetadataLocked(setId: Int)

  // Set `setId` was modified
  pub event SetMetadataModified(setId: Int)

  // A new Template `templateId` was added to Set `setId`
  pub event TemplateAddedToSet(setId: Int, templateId: Int)

  ///////////////////////////////////////////////////////////////////////////

  // Template `templateId` was locked in Set `setId`, which disables minting
  pub event TemplateLocked(setId: Int, templateId: Int)

  // Template `templateId` of Set `setId` had it's maxMint set to `maxMint`
  pub event TemplateMaxMintSet(setId: Int, templateId: Int, maxMint: UInt64)

  // Template `templateId` of Set `setId` has minted NFT with serial `serial`
  pub event NFTMinted(id: UInt64, setId: Int, templateId: Int, serial: UInt64)

  ///////////////////////////////////////////////////////////////////////////

  // The metadata for NFT/Template `templateId` of Set `setId` was locked
  pub event NFTMetadataLocked(setId: Int, templateId: Int)

  // The metadata for NFT/Template `templateId` of Set `setId` was modified
  pub event NFTMetadataModified(setId: Int, templateId: Int)

  ///////////////////////////////////////////////////////////////////////////

  // NFT `serial` from Template `templateId` of Set `setId` was burned
  pub event NFTBurned(setId: Int, templateId: Int, serial: UInt64)

  // ========================================================================
  // NFT
  // ========================================================================

  pub resource NFT:
    NonFungibleToken.INFT,
    MetadataViews.Resolver,
    NiftoryNonFungibleToken.NFTPublic
  {
    pub let id: UInt64
    pub let setId: Int
    pub let templateId: Int
    pub let serial: UInt64

    pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
      return ifeelslick.contract()
    }

    pub fun set(): &MutableMetadataSet.Set{MutableMetadataSet.Public} {
      return self
        .contract()
        .getSetManagerPublic()
        .getSet(self.setId)
    }

    pub fun metadata(): &MutableMetadata.Metadata{MutableMetadata.Public} {
      return self
        .set()
        .getTemplate(self.templateId)
        .metadata()
    }

    pub fun getViews(): [Type] {
      return self
        .contract()
        .getMetadataViewsManagerPublic()
        .getViews()
    }

    pub fun resolveView(_ view: Type): AnyStruct? {
      let nftRef = &self as &{NiftoryNonFungibleToken.NFTPublic}
      return self
        .contract()
        .getMetadataViewsManagerPublic()
        .resolveView(view: view, nftRef: nftRef)
    }

    init(setId: Int, templateId: Int, serial: UInt64) {
      self.id = ifeelslick.totalSupply
      ifeelslick.totalSupply =
        ifeelslick.totalSupply + 1
      self.setId = setId
      self.templateId = templateId
      self.serial = serial
    }

    destroy() {
      emit NFTBurned(
        setId: self.setId,
        templateId: self.templateId,
        serial: self.serial
      )
    }
  }

  // ========================================================================
  // Collection
  // ========================================================================

  pub resource Collection:
    NonFungibleToken.Provider,
    NonFungibleToken.Receiver,
    NonFungibleToken.CollectionPublic,
    MetadataViews.ResolverCollection,
    NiftoryNonFungibleToken.CollectionPublic,
    NiftoryNonFungibleToken.CollectionPrivate
  {
    pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

    pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
      return ifeelslick.contract()
    }

    pub fun getIDs(): [UInt64] {
      return self.ownedNFTs.keys
    }

    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
      pre {
        self.ownedNFTs[id] != nil : "NFT "
          .concat(id.toString())
          .concat(" does not exist in collection.")
      }
      return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
    }

    pub fun borrow(id: UInt64): &NFT{NiftoryNonFungibleToken.NFTPublic} {
      pre {
        self.ownedNFTs[id] != nil : "NFT does not exist in collection."
      }
      let nftRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let fullNft = nftRef as! &NFT
      return fullNft
    }

    pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {
      pre {
        self.ownedNFTs[id] != nil : "NFT does not exist in collection."
      }
      let nftRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let fullNft = nftRef as! &NFT
      return fullNft
    }

    pub fun deposit(token: @NonFungibleToken.NFT) {
      let token <- token as! @ifeelslick.NFT
      let id: UInt64 = token.id
      let oldToken <- self.ownedNFTs[id] <- token
      emit Deposit(id: id, to: self.owner?.address)
      destroy oldToken
    }

    pub fun depositBulk(tokens: @[NonFungibleToken.NFT]) {
      while tokens.length > 0 {
        let token <- tokens.removeLast() as! @ifeelslick.NFT
        self.deposit(token: <-token)
      }
      destroy tokens
    }

    pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
      pre {
        self.ownedNFTs[withdrawID] != nil
          : "NFT "
            .concat(withdrawID.toString())
            .concat(" does not exist in collection.")
      }
      let token <-self.ownedNFTs.remove(key: withdrawID)!
      emit Withdraw(id: token.id, from: self.owner?.address)
      return <-token
    }

    pub fun withdrawBulk(withdrawIDs: [UInt64]): @[NonFungibleToken.NFT] {
      let tokens: @[NonFungibleToken.NFT] <- []
      while withdrawIDs.length > 0 {
        tokens.append(<- self.withdraw(withdrawID: withdrawIDs.removeLast()))
      }
      return <-tokens
    }

    init() {
      self.ownedNFTs <- {}
    }

    destroy() {
      destroy self.ownedNFTs
    }
  }

  pub fun createEmptyCollection(): @Collection {
    return <-create Collection()
  }

  // ========================================================================
  // Manager
  // ========================================================================

  pub resource Manager:
    NiftoryNonFungibleToken.ManagerPublic,
    NiftoryNonFungibleToken.ManagerPrivate
  {
    // ========================================================================
    // Public
    // ========================================================================

    pub fun metadata(): AnyStruct? {
      return ifeelslick.metadata
    }

    pub fun getSetManagerPublic():
      &MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public}
    {
      return NiftoryNFTRegistry
        .getSetManagerPublic(
          ifeelslick.REGISTRY_ADDRESS,
          ifeelslick.REGISTRY_BRAND
        )
    }

    pub fun getMetadataViewsManagerPublic():
      &MetadataViewsManager.Manager{MetadataViewsManager.Public}
    {
      return NiftoryNFTRegistry
        .getMetadataViewsManagerPublic(
          ifeelslick.REGISTRY_ADDRESS,
          ifeelslick.REGISTRY_BRAND
        )
    }

    pub fun getNFTCollectionData(): MetadataViews.NFTCollectionData {
      return NiftoryNFTRegistry
        .buildNFTCollectionData(
          ifeelslick.REGISTRY_ADDRESS,
          ifeelslick.REGISTRY_BRAND,
          (fun (): @NonFungibleToken.Collection {
            return <-ifeelslick.createEmptyCollection()
          })
        )
    }

    // ========================================================================
    // Contract metadata
    // ========================================================================

    pub fun modifyContractMetadata(): auth &AnyStruct {
      emit ContractMetadataUpdated()
      let maybeMetadata = ifeelslick.metadata
      if maybeMetadata == nil {
        let blankMetadata: {String: String} = {}
        ifeelslick.metadata = blankMetadata
      }
      return (&ifeelslick.metadata as auth &AnyStruct?)!
    }

    pub fun replaceContractMetadata(_ metadata: AnyStruct?) {
      emit ContractMetadataUpdated()
      ifeelslick.metadata = metadata
    }

    // ========================================================================
    // Metadata Views Manager
    // ========================================================================

    access(self) fun _getMetadataViewsManagerPrivate():
      &MetadataViewsManager.Manager{MetadataViewsManager.Private}
    {
      let record =
        NiftoryNFTRegistry.getRegistryRecord(
          ifeelslick.REGISTRY_ADDRESS,
          ifeelslick.REGISTRY_BRAND
        )
      let manager =
        ifeelslick.account
          .getCapability<&MetadataViewsManager.Manager{MetadataViewsManager.Private}>(
            record.metadataViewsManager.paths.private
          ).borrow()!
      return manager
    }

    pub fun lockMetadataViewsManager() {
      self._getMetadataViewsManagerPrivate().lock()
      emit MetadataViewsManagerLocked()
    }

    pub fun setMetadataViewsResolver(
      _ resolver: AnyStruct{MetadataViewsManager.Resolver}
    ) {
      self._getMetadataViewsManagerPrivate().addResolver(resolver)
      emit MetadataViewsResolverAdded(type: resolver.type)
    }

    pub fun removeMetadataViewsResolver(_ type: Type) {
      self._getMetadataViewsManagerPrivate().removeResolver(type)
      emit MetadataViewsResolverRemoved(type: type)
    }

    // ========================================================================
    // Set Manager
    // ========================================================================

    access(self) fun _getSetManagerPrivate():
      &MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public, MutableMetadataSetManager.Private}
    {
      let record =
        NiftoryNFTRegistry.getRegistryRecord(
          ifeelslick.REGISTRY_ADDRESS,
          ifeelslick.REGISTRY_BRAND
        )
      let setManager =
        ifeelslick.account
          .getCapability<&MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public, MutableMetadataSetManager.Private}>(
            record.setManager.paths.private
          ).borrow()!
      return setManager
    }

    pub fun setMetadataManagerName(_ name: String) {
      self._getSetManagerPrivate().setName(name)
      emit SetManagerMetadataUpdated()
    }

    pub fun setMetadataManagerDescription(_ description: String) {
      self._getSetManagerPrivate().setDescription(description)
      emit SetManagerMetadataUpdated()
    }

    pub fun addSet(_ set: @MutableMetadataSet.Set) {
      let setManager = self._getSetManagerPrivate()
      let setId = setManager.numSets()
      setManager.addSet(<-set)
      emit SetAddedToSetManager(setID: setId)
    }

    // ========================================================================
    // Set
    // ========================================================================

    access(self) fun _getSetMutable(_ setId: Int):
      &MutableMetadataSet.Set{MutableMetadataSet.Private,
        MutableMetadataSet.Public} {
      return self._getSetManagerPrivate().getSetMutable(setId)
    }

    pub fun lockSet(setId: Int) {
      self._getSetMutable(setId).lock()
      emit SetLocked(setId: setId)
    }

    pub fun lockSetMetadata(setId: Int) {
      self._getSetMutable(setId).metadataMutable().lock()
      emit SetMetadataLocked(setId: setId)
    }

    pub fun modifySetMetadata(setId: Int): auth &AnyStruct {
      emit SetMetadataModified(setId: setId)
      return self._getSetMutable(setId).metadataMutable().getMutable()
    }

    pub fun replaceSetMetadata(setId: Int, new: AnyStruct) {
      self._getSetMutable(setId).metadataMutable().replace(new)
      emit SetMetadataModified(setId: setId)
    }

    pub fun addTemplate(
      setId: Int,
      template: @MutableMetadataTemplate.Template
    ) {
      let set = self._getSetMutable(setId)
      let templateId = set.numTemplates()
      set.addTemplate(<-template)
      emit TemplateAddedToSet(setId: setId, templateId: templateId)
    }

    // ========================================================================
    // Minting
    // ========================================================================

    access(self) fun _getTemplateMutable(_ setId: Int, _ templateId: Int):
      &MutableMetadataTemplate.Template{MutableMetadataTemplate.Public,
        MutableMetadataTemplate.Private} {
      return self._getSetMutable(setId).getTemplateMutable(templateId)
    }

    pub fun lockTemplate(setId: Int, templateId: Int) {
      self._getTemplateMutable(setId, templateId).lock()
      emit TemplateLocked(setId: setId, templateId: templateId)
    }

    pub fun setTemplateMaxMint(setId: Int, templateId: Int, max: UInt64) {
      self._getTemplateMutable(setId, templateId).setMaxMint(max)
      emit TemplateMaxMintSet(
        setId: setId,
        templateId: templateId,
        maxMint: max
      )
    }

    pub fun mint(setId: Int, templateId: Int): @NonFungibleToken.NFT {
      let template = self._getTemplateMutable(setId, templateId)
      template.registerMint()
      let serial = template.minted()
      let nft <-create NFT(
        setId: setId,
        templateId: templateId,
        serial: serial
      )
      emit NFTMinted(
        id: nft.id,
        setId: setId,
        templateId: templateId,
        serial: serial
      )
      return <-nft
    }

    pub fun mintBulk(
      setId: Int,
      templateId: Int,
      numToMint: UInt64,
    ): @[NonFungibleToken.NFT] {
      pre {
        numToMint > 0: "Must mint at least one NFT"
      }
      let template = self._getTemplateMutable(setId, templateId)
      let nfts: @[NonFungibleToken.NFT] <- []
      var leftToMint = numToMint
      while leftToMint > 0 {
        template.registerMint()
        let serial = template.minted()
        let nft <-create NFT(
          setId: setId,
          templateId: templateId,
          serial: serial
        )
        emit NFTMinted(
          id: nft.id,
          setId: setId,
          templateId: templateId,
          serial: serial
        )
        nfts.append(<-nft)
        leftToMint = leftToMint - 1
      }
      return <-nfts
    }

    // ========================================================================
    // NFT metadata
    // ========================================================================

    access(self) fun _getNFTMetadata(_ setId: Int, _ templateId: Int):
      &MutableMetadata.Metadata{MutableMetadata.Public,
        MutableMetadata.Private
      } {
        return self._getTemplateMutable(setId, templateId).metadataMutable()
    }

    pub fun lockNFTMetadata(setId: Int, templateId: Int) {
      self._getNFTMetadata(setId, templateId).lock()
      emit NFTMetadataLocked(setId: setId, templateId: templateId)
    }

    pub fun modifyNFTMetadata(setId: Int, templateId: Int): auth &AnyStruct {
      emit NFTMetadataModified(setId: setId, templateId: templateId)
      return self._getNFTMetadata(setId, templateId).getMutable()
    }

    pub fun replaceNFTMetadata(setId: Int, templateId: Int, new: AnyStruct) {
      self._getNFTMetadata(setId, templateId).replace(new)
      emit NFTMetadataModified(setId: setId, templateId: templateId)
    }
  }

  // ========================================================================
  // Contract functions
  // ========================================================================

  pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
    return NiftoryNFTRegistry
      .getNFTManagerPublic(
        ifeelslick.REGISTRY_ADDRESS,
        ifeelslick.REGISTRY_BRAND
      )
  }

  pub fun getViews(): [Type] {
    let possibleViews = [
      Type<MetadataViews.NFTCollectionDisplay>(),
      Type<MetadataViews.ExternalURL>()
    ]
    let views: [Type] = [Type<MetadataViews.NFTCollectionData>()]

    let viewManager = self.contract().getMetadataViewsManagerPublic()
    for view in possibleViews {
      if viewManager.inspectView(view: view) != nil {
        views.append(view)
      }
    }
    return views
  }

  pub fun resolveView(_ view: Type): AnyStruct? {
    let viewManager = self.contract().getMetadataViewsManagerPublic()
    switch view {

      case Type<MetadataViews.NFTCollectionData>():
        return self.contract().getNFTCollectionData()

      case Type<MetadataViews.NFTCollectionDisplay>():
        let maybeView = viewManager.inspectView(
          view: Type<MetadataViews.NFTCollectionDisplay>()
        )
        if maybeView == nil {
          return nil
        }
        let view = maybeView!

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver

          // External URL
          let externalURL = MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultExternalURLPrefix,
              uri: resolver.defaultExternalURL
            )
          )

          // Square image
          let squareImageURL = NiftoryMetadataViewsResolvers._prefixUri(
            allowedPrefixes:
              NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
            default: resolver.defaultSquareImagePrefix,
            uri: resolver.defaultSquareImage
          )
          let squareImageMediaType = resolver.defaultSquareImageMediaType
          let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: squareImageURL),
            mediaType: squareImageMediaType
          )

          // Banner image
          let bannerImageURL = NiftoryMetadataViewsResolvers._prefixUri(
            allowedPrefixes:
              NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
            default: resolver.defaultBannerImagePrefix,
            uri: resolver.defaultBannerImage
          )
          let bannerImageMediaType = resolver.defaultBannerImageMediaType
          let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
              url: bannerImageURL
            ),
            mediaType: bannerImageMediaType
          )

          return MetadataViews.NFTCollectionDisplay(
            name: resolver.defaultName,
            description: resolver.defaultDescription,
            externalURL: externalURL,
            squareImage: squareImage,
            bannerImage: bannerImage,
            socials: {}

          )
        }

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolverWithIpfsGateway>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolverWithIpfsGateway

          // External URL
          let externalURL = MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultExternalURLPrefix,
              uri: resolver.defaultExternalURL
            )
          )

          // Square image
          let squareImageURL = NiftoryMetadataViewsResolvers._useIpfsGateway(
            ipfsGateway: resolver.ipfsGateway,
            uri: NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultSquareImagePrefix,
              uri: resolver.defaultSquareImage
            )
        )
          let squareImageMediaType = resolver.defaultSquareImageMediaType
          let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: squareImageURL),
            mediaType: squareImageMediaType
          )

          // Banner image
          let bannerImageURL = NiftoryMetadataViewsResolvers._useIpfsGateway(
            ipfsGateway: resolver.ipfsGateway,
            uri: NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultBannerImagePrefix,
              uri: resolver.defaultBannerImage
            )
          )
          let bannerImageMediaType = resolver.defaultBannerImageMediaType
          let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
              url: bannerImageURL
            ),
            mediaType: bannerImageMediaType
          )

          return MetadataViews.NFTCollectionDisplay(
            name: resolver.defaultName,
            description: resolver.defaultDescription,
            externalURL: externalURL,
            squareImage: squareImage,
            bannerImage: bannerImage,
            socials: {}
          )
        }

        return nil

      case Type<MetadataViews.ExternalURL>():
        let maybeView = viewManager.inspectView(
          view: Type<MetadataViews.ExternalURL>()
        )
        if maybeView == nil {
          return nil
        }
        let view = maybeView!

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.ExternalURLResolver>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.ExternalURLResolver
          return MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultPrefix,
              uri: resolver.defaultURL
            )
          )
        }

        return nil
      }
      return nil

  }

  // ========================================================================
  // Init
  // ========================================================================

  init(
    nftManagerProxy: &{
      NiftoryNonFungibleTokenProxy.Public,
      NiftoryNonFungibleTokenProxy.Private
    }
  ) {

    let record = NiftoryNFTRegistry.generateRecord(
      account: self.account.address,
      project: "clbnz4dgn0000k40hrislizfn_ifeelslick"
    )

    self.REGISTRY_ADDRESS = 0x32d62d5c43ad1038
    self.REGISTRY_BRAND = "clbnz4dgn0000k40hrislizfn_ifeelslick"

    self.COLLECTION_PUBLIC_PATH = record.collectionPaths.public
    self.COLLECTION_PRIVATE_PATH = record.collectionPaths.private
    self.COLLECTION_STORAGE_PATH = record.collectionPaths.storage

    // No metadata to start with
    self.metadata = nil

    // Initialize the total supply to 0.
    self.totalSupply = 0

    // The Manager for this NFT
    //
    // NFT Manager storage
    let nftManager <- create Manager()

    // Save a MutableSetManager to this contract's storage, as the source of
    // this NFT contract's metadata.
    //
    // MutableMetadataSetManager storage
    self
      .account
      .save<@MutableMetadataSetManager.Manager>(
        <-MutableMetadataSetManager.create(
          name: "ifeelslick",
          description: "The set manager for ifeelslick."
        ),
        to: record.setManager.paths.storage
      )

    // MutableMetadataSetManager public
    self
      .account
      .link<&MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public}>(
        record.setManager.paths.public,
        target: record.setManager.paths.storage
      )

    // MutableMetadataSetManager private
    self
      .account
      .link<&
        MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public,
        MutableMetadataSetManager.Private
      }>(
        record.setManager.paths.private,
        target: record.setManager.paths.storage
      )

    // Save a MetadataViewsManager to this contract's storage, which will
    // allow observers to inspect standardized metadata through any of its
    // configured MetadataViews resolvers.
    //
    // MetadataViewsManager storage
    self
      .account
      .save<@MetadataViewsManager.Manager>(
        <-MetadataViewsManager.create(),
        to: record.metadataViewsManager.paths.storage
      )

    // MetadataViewsManager public
    self
      .account
      .link<&MetadataViewsManager.Manager{MetadataViewsManager.Public}>(
        record.metadataViewsManager.paths.public,
        target: record.metadataViewsManager.paths.storage
      )

    // MetadataViewsManager private
    self
      .account
      .link<&
        MetadataViewsManager.Manager{MetadataViewsManager.Private,
        MetadataViewsManager.Public
      }>(
        record.metadataViewsManager.paths.private,
        target: record.metadataViewsManager.paths.storage
      )

    let contractName = "ifeelslick"

    // Royalties
    let royaltiesResolver = NiftoryMetadataViewsResolvers.RoyaltiesResolver(
        royalties: MetadataViews.Royalties([])
    )
    nftManager.setMetadataViewsResolver(royaltiesResolver)

    // Collection Data
    let collectionDataResolver
        = NiftoryMetadataViewsResolvers.NFTCollectionDataResolver()
    nftManager.setMetadataViewsResolver(collectionDataResolver)

    // Display
    let displayResolver = NiftoryMetadataViewsResolvers.DisplayResolver(
        "title",
        contractName.concat("NFT"),
        "description",
        contractName.concat(" NFT"),
        "mediaUrl",
        "ipfs://",
        "ipfs://bafybeig6la3me5x3veull7jzxmwle4sfuaguou2is3o3z44ayhe7ihlqpa/NiftoryBanner.png"
    )
    nftManager.setMetadataViewsResolver(displayResolver)

    // Collection Display
    let collectionResolver = NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver(
        "title",
        contractName,
        "description",
        contractName.concat(" Collection"),
        "domainUrl",
        "https://",
        "https://niftory.com",
        "squareImage",
        "ipfs://",
        "ipfs://bafybeihc76uodw2at2xi2l5jydpvscj5ophfpqgblbrmsfpeffhcmgdtl4/squareImage.png",
        "squareImageMediaType",
        "image/png",
        "bannerImage",
        "ipfs://",
        "ipfs://bafybeig6la3me5x3veull7jzxmwle4sfuaguou2is3o3z44ayhe7ihlqpa/NiftoryBanner.png",
        "bannerImageMediaType",
        "image/png",
        []
    )
    nftManager.setMetadataViewsResolver(collectionResolver)

    // ExternalURL
    let externalURLResolver = NiftoryMetadataViewsResolvers.ExternalURLResolver(
        "domainUrl",
        "https://",
        "https://niftory.com"
    )
    nftManager.setMetadataViewsResolver(externalURLResolver)

    // Save NFT Manager
    self
      .account
      .save<@Manager>(
        <-nftManager,
        to: record.nftManager.paths.storage
      )

    // NFT Manager public
    self
      .account
      .link<&{NiftoryNonFungibleToken.ManagerPublic}>(
        record.nftManager.paths.public,
        target: record.nftManager.paths.storage
      )

    // NFT Manager private
    self
      .account
      .link<&
        Manager{NiftoryNonFungibleToken.ManagerPublic,
        NiftoryNonFungibleToken.ManagerPrivate
      }>(
        record.nftManager.paths.private,
        target: record.nftManager.paths.storage
      )

      nftManagerProxy.add(
        registryAddress: self.REGISTRY_ADDRESS,
        brand: self.REGISTRY_BRAND,
        cap: self.account
              .getCapability<&{
                NiftoryNonFungibleToken.ManagerPrivate,
                NiftoryNonFungibleToken.ManagerPublic
              }>(
                record.nftManager.paths.private
              )
      )
  }
}"
-------
"/*
FormulaOne

This is the contract for FormulaOne NFTs!

This was implemented using Niftory interfaces. For full details on how this
contract functions, please see the Niftory and NFTRegistry contracts.

*/

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import ViewResolver from 0x1d7e57aa55817448

import MutableMetadata from 0x7ec1f607f0872a9e
import MutableMetadataTemplate from 0x7ec1f607f0872a9e
import MutableMetadataSet from 0x7ec1f607f0872a9e
import MutableMetadataSetManager from 0x7ec1f607f0872a9e
import MetadataViewsManager from 0x7ec1f607f0872a9e

import NiftoryNonFungibleToken from 0x7ec1f607f0872a9e
import NiftoryNFTRegistry from 0x7ec1f607f0872a9e

import NiftoryMetadataViewsResolvers from 0x7ec1f607f0872a9e
import NiftoryNonFungibleTokenProxy from 0x7ec1f607f0872a9e

pub contract FormulaOne: NonFungibleToken, ViewResolver {

  // ========================================================================
  // Constants
  // ========================================================================

  // Suggested paths where collection could be stored
  pub let COLLECTION_PRIVATE_PATH: PrivatePath
  pub let COLLECTION_PUBLIC_PATH: PublicPath
  pub let COLLECTION_STORAGE_PATH: StoragePath

  // Accessor token to be used with NiftoryNFTRegistry to retrieve
  // meta-information about this NFT project
  pub let REGISTRY_ADDRESS: Address
  pub let REGISTRY_BRAND: String

  // ========================================================================
  // Attributes
  // ========================================================================

  // Arbitrary metadata for this NFT contract
  pub var metadata: AnyStruct?

  // Number of NFTs created
  pub var totalSupply: UInt64

  // ========================================================================
  // Contract Events
  // ========================================================================

  // This contract was initialized
  pub event ContractInitialized()

  // A withdrawal of NFT `id` has occurred from the `from` Address
  pub event Withdraw(id: UInt64, from: Address?)

  // A deposit of an NFT `id` has occurred to the `to` Address
  pub event Deposit(id: UInt64, to: Address?)

  ///////////////////////////////////////////////////////////////////////////

  // Contract metadata was modified
  pub event ContractMetadataUpdated()

  // Metadata Views Manager was locked
  pub event MetadataViewsManagerLocked()

  // Metadata Views Resolver was added
  pub event MetadataViewsResolverAdded(type: Type)

  // Metadata Views Resolver was removed
  pub event MetadataViewsResolverRemoved(type: Type)

  // Set Manager Name or Description updated
  pub event SetManagerMetadataUpdated()

  // Set added to Set Manager
  pub event SetAddedToSetManager(setID: Int)

  ///////////////////////////////////////////////////////////////////////////

  // Set `setId` was locked (no new templates can be added)
  pub event SetLocked(setId: Int)

  // The metadata for Set `setId` was locked and cannot be modified
  pub event SetMetadataLocked(setId: Int)

  // Set `setId` was modified
  pub event SetMetadataModified(setId: Int)

  // A new Template `templateId` was added to Set `setId`
  pub event TemplateAddedToSet(setId: Int, templateId: Int)

  ///////////////////////////////////////////////////////////////////////////

  // Template `templateId` was locked in Set `setId`, which disables minting
  pub event TemplateLocked(setId: Int, templateId: Int)

  // Template `templateId` of Set `setId` had it's maxMint set to `maxMint`
  pub event TemplateMaxMintSet(setId: Int, templateId: Int, maxMint: UInt64)

  // Template `templateId` of Set `setId` has minted NFT with serial `serial`
  pub event NFTMinted(id: UInt64, setId: Int, templateId: Int, serial: UInt64)

  ///////////////////////////////////////////////////////////////////////////

  // The metadata for NFT/Template `templateId` of Set `setId` was locked
  pub event NFTMetadataLocked(setId: Int, templateId: Int)

  // The metadata for NFT/Template `templateId` of Set `setId` was modified
  pub event NFTMetadataModified(setId: Int, templateId: Int)

  ///////////////////////////////////////////////////////////////////////////

  // NFT `serial` from Template `templateId` of Set `setId` was burned
  pub event NFTBurned(setId: Int, templateId: Int, serial: UInt64)

  // ========================================================================
  // NFT
  // ========================================================================

  pub resource NFT:
    NonFungibleToken.INFT,
    MetadataViews.Resolver,
    NiftoryNonFungibleToken.NFTPublic
  {
    pub let id: UInt64
    pub let setId: Int
    pub let templateId: Int
    pub let serial: UInt64

    pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
      return FormulaOne.contract()
    }

    pub fun set(): &MutableMetadataSet.Set{MutableMetadataSet.Public} {
      return self
        .contract()
        .getSetManagerPublic()
        .getSet(self.setId)
    }

    pub fun metadata(): &MutableMetadata.Metadata{MutableMetadata.Public} {
      return self
        .set()
        .getTemplate(self.templateId)
        .metadata()
    }

    pub fun getViews(): [Type] {
      return self
        .contract()
        .getMetadataViewsManagerPublic()
        .getViews()
    }

    pub fun resolveView(_ view: Type): AnyStruct? {
      let nftRef = &self as &{NiftoryNonFungibleToken.NFTPublic}
      return self
        .contract()
        .getMetadataViewsManagerPublic()
        .resolveView(view: view, nftRef: nftRef)
    }

    init(setId: Int, templateId: Int, serial: UInt64) {
      self.id = FormulaOne.totalSupply
      FormulaOne.totalSupply =
        FormulaOne.totalSupply + 1
      self.setId = setId
      self.templateId = templateId
      self.serial = serial
    }

    destroy() {
      emit NFTBurned(
        setId: self.setId,
        templateId: self.templateId,
        serial: self.serial
      )
    }
  }

  // ========================================================================
  // Collection
  // ========================================================================

  pub resource Collection:
    NonFungibleToken.Provider,
    NonFungibleToken.Receiver,
    NonFungibleToken.CollectionPublic,
    MetadataViews.ResolverCollection,
    NiftoryNonFungibleToken.CollectionPublic,
    NiftoryNonFungibleToken.CollectionPrivate
  {
    pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

    pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
      return FormulaOne.contract()
    }

    pub fun getIDs(): [UInt64] {
      return self.ownedNFTs.keys
    }

    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
      pre {
        self.ownedNFTs[id] != nil : "NFT "
          .concat(id.toString())
          .concat(" does not exist in collection.")
      }
      return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
    }

    pub fun borrow(id: UInt64): &NFT{NiftoryNonFungibleToken.NFTPublic} {
      pre {
        self.ownedNFTs[id] != nil : "NFT does not exist in collection."
      }
      let nftRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let fullNft = nftRef as! &NFT
      return fullNft
    }

    pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {
      pre {
        self.ownedNFTs[id] != nil : "NFT does not exist in collection."
      }
      let nftRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let fullNft = nftRef as! &NFT
      return fullNft
    }

    pub fun deposit(token: @NonFungibleToken.NFT) {
      let token <- token as! @FormulaOne.NFT
      let id: UInt64 = token.id
      let oldToken <- self.ownedNFTs[id] <- token
      emit Deposit(id: id, to: self.owner?.address)
      destroy oldToken
    }

    pub fun depositBulk(tokens: @[NonFungibleToken.NFT]) {
      while tokens.length > 0 {
        let token <- tokens.removeLast() as! @FormulaOne.NFT
        self.deposit(token: <-token)
      }
      destroy tokens
    }

    pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
      pre {
        self.ownedNFTs[withdrawID] != nil
          : "NFT "
            .concat(withdrawID.toString())
            .concat(" does not exist in collection.")
      }
      let token <-self.ownedNFTs.remove(key: withdrawID)!
      emit Withdraw(id: token.id, from: self.owner?.address)
      return <-token
    }

    pub fun withdrawBulk(withdrawIDs: [UInt64]): @[NonFungibleToken.NFT] {
      let tokens: @[NonFungibleToken.NFT] <- []
      while withdrawIDs.length > 0 {
        tokens.append(<- self.withdraw(withdrawID: withdrawIDs.removeLast()))
      }
      return <-tokens
    }

    init() {
      self.ownedNFTs <- {}
    }

    destroy() {
      destroy self.ownedNFTs
    }
  }

  pub fun createEmptyCollection(): @Collection {
    return <-create Collection()
  }

  // ========================================================================
  // Manager
  // ========================================================================

  pub resource Manager:
    NiftoryNonFungibleToken.ManagerPublic,
    NiftoryNonFungibleToken.ManagerPrivate
  {
    // ========================================================================
    // Public
    // ========================================================================

    pub fun metadata(): AnyStruct? {
      return FormulaOne.metadata
    }

    pub fun getSetManagerPublic():
      &MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public}
    {
      return NiftoryNFTRegistry
        .getSetManagerPublic(
          FormulaOne.REGISTRY_ADDRESS,
          FormulaOne.REGISTRY_BRAND
        )
    }

    pub fun getMetadataViewsManagerPublic():
      &MetadataViewsManager.Manager{MetadataViewsManager.Public}
    {
      return NiftoryNFTRegistry
        .getMetadataViewsManagerPublic(
          FormulaOne.REGISTRY_ADDRESS,
          FormulaOne.REGISTRY_BRAND
        )
    }

    pub fun getNFTCollectionData(): MetadataViews.NFTCollectionData {
      return NiftoryNFTRegistry
        .buildNFTCollectionData(
          FormulaOne.REGISTRY_ADDRESS,
          FormulaOne.REGISTRY_BRAND,
          (fun (): @NonFungibleToken.Collection {
            return <-FormulaOne.createEmptyCollection()
          })
        )
    }

    // ========================================================================
    // Contract metadata
    // ========================================================================

    pub fun modifyContractMetadata(): auth &AnyStruct {
      emit ContractMetadataUpdated()
      let maybeMetadata = FormulaOne.metadata
      if maybeMetadata == nil {
        let blankMetadata: {String: String} = {}
        FormulaOne.metadata = blankMetadata
      }
      return (&FormulaOne.metadata as auth &AnyStruct?)!
    }

    pub fun replaceContractMetadata(_ metadata: AnyStruct?) {
      emit ContractMetadataUpdated()
      FormulaOne.metadata = metadata
    }

    // ========================================================================
    // Metadata Views Manager
    // ========================================================================

    access(self) fun _getMetadataViewsManagerPrivate():
      &MetadataViewsManager.Manager{MetadataViewsManager.Private}
    {
      let record =
        NiftoryNFTRegistry.getRegistryRecord(
          FormulaOne.REGISTRY_ADDRESS,
          FormulaOne.REGISTRY_BRAND
        )
      let manager =
        FormulaOne.account
          .getCapability<&MetadataViewsManager.Manager{MetadataViewsManager.Private}>(
            record.metadataViewsManager.paths.private
          ).borrow()!
      return manager
    }

    pub fun lockMetadataViewsManager() {
      self._getMetadataViewsManagerPrivate().lock()
      emit MetadataViewsManagerLocked()
    }

    pub fun setMetadataViewsResolver(
      _ resolver: AnyStruct{MetadataViewsManager.Resolver}
    ) {
      self._getMetadataViewsManagerPrivate().addResolver(resolver)
      emit MetadataViewsResolverAdded(type: resolver.type)
    }

    pub fun removeMetadataViewsResolver(_ type: Type) {
      self._getMetadataViewsManagerPrivate().removeResolver(type)
      emit MetadataViewsResolverRemoved(type: type)
    }

    // ========================================================================
    // Set Manager
    // ========================================================================

    access(self) fun _getSetManagerPrivate():
      &MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public, MutableMetadataSetManager.Private}
    {
      let record =
        NiftoryNFTRegistry.getRegistryRecord(
          FormulaOne.REGISTRY_ADDRESS,
          FormulaOne.REGISTRY_BRAND
        )
      let setManager =
        FormulaOne.account
          .getCapability<&MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public, MutableMetadataSetManager.Private}>(
            record.setManager.paths.private
          ).borrow()!
      return setManager
    }

    pub fun setMetadataManagerName(_ name: String) {
      self._getSetManagerPrivate().setName(name)
      emit SetManagerMetadataUpdated()
    }

    pub fun setMetadataManagerDescription(_ description: String) {
      self._getSetManagerPrivate().setDescription(description)
      emit SetManagerMetadataUpdated()
    }

    pub fun addSet(_ set: @MutableMetadataSet.Set) {
      let setManager = self._getSetManagerPrivate()
      let setId = setManager.numSets()
      setManager.addSet(<-set)
      emit SetAddedToSetManager(setID: setId)
    }

    // ========================================================================
    // Set
    // ========================================================================

    access(self) fun _getSetMutable(_ setId: Int):
      &MutableMetadataSet.Set{MutableMetadataSet.Private,
        MutableMetadataSet.Public} {
      return self._getSetManagerPrivate().getSetMutable(setId)
    }

    pub fun lockSet(setId: Int) {
      self._getSetMutable(setId).lock()
      emit SetLocked(setId: setId)
    }

    pub fun lockSetMetadata(setId: Int) {
      self._getSetMutable(setId).metadataMutable().lock()
      emit SetMetadataLocked(setId: setId)
    }

    pub fun modifySetMetadata(setId: Int): auth &AnyStruct {
      emit SetMetadataModified(setId: setId)
      return self._getSetMutable(setId).metadataMutable().getMutable()
    }

    pub fun replaceSetMetadata(setId: Int, new: AnyStruct) {
      self._getSetMutable(setId).metadataMutable().replace(new)
      emit SetMetadataModified(setId: setId)
    }

    pub fun addTemplate(
      setId: Int,
      template: @MutableMetadataTemplate.Template
    ) {
      let set = self._getSetMutable(setId)
      let templateId = set.numTemplates()
      set.addTemplate(<-template)
      emit TemplateAddedToSet(setId: setId, templateId: templateId)
    }

    // ========================================================================
    // Minting
    // ========================================================================

    access(self) fun _getTemplateMutable(_ setId: Int, _ templateId: Int):
      &MutableMetadataTemplate.Template{MutableMetadataTemplate.Public,
        MutableMetadataTemplate.Private} {
      return self._getSetMutable(setId).getTemplateMutable(templateId)
    }

    pub fun lockTemplate(setId: Int, templateId: Int) {
      self._getTemplateMutable(setId, templateId).lock()
      emit TemplateLocked(setId: setId, templateId: templateId)
    }

    pub fun setTemplateMaxMint(setId: Int, templateId: Int, max: UInt64) {
      self._getTemplateMutable(setId, templateId).setMaxMint(max)
      emit TemplateMaxMintSet(
        setId: setId,
        templateId: templateId,
        maxMint: max
      )
    }

    pub fun mint(setId: Int, templateId: Int): @NonFungibleToken.NFT {
      let template = self._getTemplateMutable(setId, templateId)
      template.registerMint()
      let serial = template.minted()
      let nft <-create NFT(
        setId: setId,
        templateId: templateId,
        serial: serial
      )
      emit NFTMinted(
        id: nft.id,
        setId: setId,
        templateId: templateId,
        serial: serial
      )
      return <-nft
    }

    pub fun mintBulk(
      setId: Int,
      templateId: Int,
      numToMint: UInt64,
    ): @[NonFungibleToken.NFT] {
      pre {
        numToMint > 0: "Must mint at least one NFT"
      }
      let template = self._getTemplateMutable(setId, templateId)
      let nfts: @[NonFungibleToken.NFT] <- []
      var leftToMint = numToMint
      while leftToMint > 0 {
        template.registerMint()
        let serial = template.minted()
        let nft <-create NFT(
          setId: setId,
          templateId: templateId,
          serial: serial
        )
        emit NFTMinted(
          id: nft.id,
          setId: setId,
          templateId: templateId,
          serial: serial
        )
        nfts.append(<-nft)
        leftToMint = leftToMint - 1
      }
      return <-nfts
    }

    // ========================================================================
    // NFT metadata
    // ========================================================================

    access(self) fun _getNFTMetadata(_ setId: Int, _ templateId: Int):
      &MutableMetadata.Metadata{MutableMetadata.Public,
        MutableMetadata.Private
      } {
        return self._getTemplateMutable(setId, templateId).metadataMutable()
    }

    pub fun lockNFTMetadata(setId: Int, templateId: Int) {
      self._getNFTMetadata(setId, templateId).lock()
      emit NFTMetadataLocked(setId: setId, templateId: templateId)
    }

    pub fun modifyNFTMetadata(setId: Int, templateId: Int): auth &AnyStruct {
      emit NFTMetadataModified(setId: setId, templateId: templateId)
      return self._getNFTMetadata(setId, templateId).getMutable()
    }

    pub fun replaceNFTMetadata(setId: Int, templateId: Int, new: AnyStruct) {
      self._getNFTMetadata(setId, templateId).replace(new)
      emit NFTMetadataModified(setId: setId, templateId: templateId)
    }
  }

  // ========================================================================
  // Contract functions
  // ========================================================================

  pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
    return NiftoryNFTRegistry
      .getNFTManagerPublic(
        FormulaOne.REGISTRY_ADDRESS,
        FormulaOne.REGISTRY_BRAND
      )
  }

  pub fun getViews(): [Type] {
    let possibleViews = [
      Type<MetadataViews.NFTCollectionDisplay>(),
      Type<MetadataViews.ExternalURL>()
    ]
    let views: [Type] = [Type<MetadataViews.NFTCollectionData>()]

    let viewManager = self.contract().getMetadataViewsManagerPublic()
    for view in possibleViews {
      if viewManager.inspectView(view: view) != nil {
        views.append(view)
      }
    }
    return views
  }

  pub fun resolveView(_ view: Type): AnyStruct? {
    let viewManager = self.contract().getMetadataViewsManagerPublic()
    switch view {

      case Type<MetadataViews.NFTCollectionData>():
        return self.contract().getNFTCollectionData()

      case Type<MetadataViews.NFTCollectionDisplay>():
        let maybeView = viewManager.inspectView(
          view: Type<MetadataViews.NFTCollectionDisplay>()
        )
        if maybeView == nil {
          return nil
        }
        let view = maybeView!

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver

          // External URL
          let externalURL = MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultExternalURLPrefix,
              uri: resolver.defaultExternalURL
            )
          )

          // Square image
          let squareImageURL = NiftoryMetadataViewsResolvers._prefixUri(
            allowedPrefixes:
              NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
            default: resolver.defaultSquareImagePrefix,
            uri: resolver.defaultSquareImage
          )
          let squareImageMediaType = resolver.defaultSquareImageMediaType
          let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: squareImageURL),
            mediaType: squareImageMediaType
          )

          // Banner image
          let bannerImageURL = NiftoryMetadataViewsResolvers._prefixUri(
            allowedPrefixes:
              NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
            default: resolver.defaultBannerImagePrefix,
            uri: resolver.defaultBannerImage
          )
          let bannerImageMediaType = resolver.defaultBannerImageMediaType
          let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
              url: bannerImageURL
            ),
            mediaType: bannerImageMediaType
          )

          return MetadataViews.NFTCollectionDisplay(
            name: resolver.defaultName,
            description: resolver.defaultDescription,
            externalURL: externalURL,
            squareImage: squareImage,
            bannerImage: bannerImage,
            socials: {}

          )
        }

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolverWithIpfsGateway>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolverWithIpfsGateway

          // External URL
          let externalURL = MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultExternalURLPrefix,
              uri: resolver.defaultExternalURL
            )
          )

          // Square image
          let squareImageURL = NiftoryMetadataViewsResolvers._useIpfsGateway(
            ipfsGateway: resolver.ipfsGateway,
            uri: NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultSquareImagePrefix,
              uri: resolver.defaultSquareImage
            )
        )
          let squareImageMediaType = resolver.defaultSquareImageMediaType
          let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: squareImageURL),
            mediaType: squareImageMediaType
          )

          // Banner image
          let bannerImageURL = NiftoryMetadataViewsResolvers._useIpfsGateway(
            ipfsGateway: resolver.ipfsGateway,
            uri: NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultBannerImagePrefix,
              uri: resolver.defaultBannerImage
            )
          )
          let bannerImageMediaType = resolver.defaultBannerImageMediaType
          let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
              url: bannerImageURL
            ),
            mediaType: bannerImageMediaType
          )

          return MetadataViews.NFTCollectionDisplay(
            name: resolver.defaultName,
            description: resolver.defaultDescription,
            externalURL: externalURL,
            squareImage: squareImage,
            bannerImage: bannerImage,
            socials: {}
          )
        }

        return nil

      case Type<MetadataViews.ExternalURL>():
        let maybeView = viewManager.inspectView(
          view: Type<MetadataViews.ExternalURL>()
        )
        if maybeView == nil {
          return nil
        }
        let view = maybeView!

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.ExternalURLResolver>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.ExternalURLResolver
          return MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultPrefix,
              uri: resolver.defaultURL
            )
          )
        }

        return nil
      }
      return nil

  }

  // ========================================================================
  // Init
  // ========================================================================

  init(
    nftManagerProxy: &{
      NiftoryNonFungibleTokenProxy.Public,
      NiftoryNonFungibleTokenProxy.Private
    }
  ) {

    let record = NiftoryNFTRegistry.generateRecord(
      account: self.account.address,
      project: "cleg7ogbg0002mk0vtd593ino_FormulaOne"
    )

    self.REGISTRY_ADDRESS = 0x32d62d5c43ad1038
    self.REGISTRY_BRAND = "cleg7ogbg0002mk0vtd593ino_FormulaOne"

    self.COLLECTION_PUBLIC_PATH = record.collectionPaths.public
    self.COLLECTION_PRIVATE_PATH = record.collectionPaths.private
    self.COLLECTION_STORAGE_PATH = record.collectionPaths.storage

    // No metadata to start with
    self.metadata = nil

    // Initialize the total supply to 0.
    self.totalSupply = 0

    // The Manager for this NFT
    //
    // NFT Manager storage
    let nftManager <- create Manager()

    // Save a MutableSetManager to this contract's storage, as the source of
    // this NFT contract's metadata.
    //
    // MutableMetadataSetManager storage
    self
      .account
      .save<@MutableMetadataSetManager.Manager>(
        <-MutableMetadataSetManager.create(
          name: "FormulaOne",
          description: "The set manager for FormulaOne."
        ),
        to: record.setManager.paths.storage
      )

    // MutableMetadataSetManager public
    self
      .account
      .link<&MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public}>(
        record.setManager.paths.public,
        target: record.setManager.paths.storage
      )

    // MutableMetadataSetManager private
    self
      .account
      .link<&
        MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public,
        MutableMetadataSetManager.Private
      }>(
        record.setManager.paths.private,
        target: record.setManager.paths.storage
      )

    // Save a MetadataViewsManager to this contract's storage, which will
    // allow observers to inspect standardized metadata through any of its
    // configured MetadataViews resolvers.
    //
    // MetadataViewsManager storage
    self
      .account
      .save<@MetadataViewsManager.Manager>(
        <-MetadataViewsManager.create(),
        to: record.metadataViewsManager.paths.storage
      )

    // MetadataViewsManager public
    self
      .account
      .link<&MetadataViewsManager.Manager{MetadataViewsManager.Public}>(
        record.metadataViewsManager.paths.public,
        target: record.metadataViewsManager.paths.storage
      )

    // MetadataViewsManager private
    self
      .account
      .link<&
        MetadataViewsManager.Manager{MetadataViewsManager.Private,
        MetadataViewsManager.Public
      }>(
        record.metadataViewsManager.paths.private,
        target: record.metadataViewsManager.paths.storage
      )

    let contractName = "FormulaOne"

    // Royalties
    let royaltiesResolver = NiftoryMetadataViewsResolvers.RoyaltiesResolver(
        royalties: MetadataViews.Royalties([])
    )
    nftManager.setMetadataViewsResolver(royaltiesResolver)

    // Collection Data
    let collectionDataResolver
        = NiftoryMetadataViewsResolvers.NFTCollectionDataResolver()
    nftManager.setMetadataViewsResolver(collectionDataResolver)

    // Display
    let displayResolver = NiftoryMetadataViewsResolvers.DisplayResolver(
        "title",
        contractName.concat("NFT"),
        "description",
        contractName.concat(" NFT"),
        "mediaUrl",
        "ipfs://",
        "ipfs://bafybeig6la3me5x3veull7jzxmwle4sfuaguou2is3o3z44ayhe7ihlqpa/NiftoryBanner.png"
    )
    nftManager.setMetadataViewsResolver(displayResolver)

    // Collection Display
    let collectionResolver = NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver(
        "title",
        contractName,
        "description",
        contractName.concat(" Collection"),
        "domainUrl",
        "https://",
        "https://niftory.com",
        "squareImage",
        "ipfs://",
        "ipfs://bafybeihc76uodw2at2xi2l5jydpvscj5ophfpqgblbrmsfpeffhcmgdtl4/squareImage.png",
        "squareImageMediaType",
        "image/png",
        "bannerImage",
        "ipfs://",
        "ipfs://bafybeig6la3me5x3veull7jzxmwle4sfuaguou2is3o3z44ayhe7ihlqpa/NiftoryBanner.png",
        "bannerImageMediaType",
        "image/png",
        []
    )
    nftManager.setMetadataViewsResolver(collectionResolver)

    // ExternalURL
    let externalURLResolver = NiftoryMetadataViewsResolvers.ExternalURLResolver(
        "domainUrl",
        "https://",
        "https://niftory.com"
    )
    nftManager.setMetadataViewsResolver(externalURLResolver)

    // Save NFT Manager
    self
      .account
      .save<@Manager>(
        <-nftManager,
        to: record.nftManager.paths.storage
      )

    // NFT Manager public
    self
      .account
      .link<&{NiftoryNonFungibleToken.ManagerPublic}>(
        record.nftManager.paths.public,
        target: record.nftManager.paths.storage
      )

    // NFT Manager private
    self
      .account
      .link<&
        Manager{NiftoryNonFungibleToken.ManagerPublic,
        NiftoryNonFungibleToken.ManagerPrivate
      }>(
        record.nftManager.paths.private,
        target: record.nftManager.paths.storage
      )

      nftManagerProxy.add(
        registryAddress: self.REGISTRY_ADDRESS,
        brand: self.REGISTRY_BRAND,
        cap: self.account
              .getCapability<&{
                NiftoryNonFungibleToken.ManagerPrivate,
                NiftoryNonFungibleToken.ManagerPublic
              }>(
                record.nftManager.paths.private
              )
      )
  }
}"
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract StarNFT: NonFungibleToken {
    pub let baseUri: String

    // Signer
    pub var signer: Address

    // Collection
    pub let collectionName: String
    pub let collectionDescription: String
    // External link to a URL to view more information about this collection.
    pub let collectionExternalURL: MetadataViews.ExternalURL
    // Square-sized image to represent this collection.
    pub let collectionSquareImage: MetadataViews.Media
    // Banner-sized image for this collection, recommended to have a size near 1200x630.
    pub let collectionBannerImage: MetadataViews.Media
    // Social links to reach this collection's social homepages.
    // Possible keys may be "instagram", "twitter", "discord", etc.
    pub let collectionSocials: {String: MetadataViews.ExternalURL}

    pub var totalSupply: UInt64

    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event Minted(id: UInt64, address: Address)

    pub event Claim(campaign_id: UInt256, verify_id: UInt256, minter: Address, owner: Address, nft_id: UInt64)
    pub event Transfer(id: UInt64, from: Address, to: Address)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let OwnerStoragePath: StoragePath

    /// Maps each token ID to its owner address
    access(self) let owners: [Address]

    /// Maps each verify ID to its minted status
    access(self) let minted: {UInt256: Bool}

    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        /// The unique ID of each NFT
        pub let id: UInt64

        /// Metadata fields
        pub let name: String
        pub let description: String
        pub let thumbnail: String
        access(self) let metadata: {String: String}

        init(
            id: UInt64,
            name: String,
            description: String,
            thumbnail: String,
            metadata: {String: String}
        ) {
            self.id = id
            self.name = name
            self.description = description
            self.thumbnail = thumbnail
            self.metadata = metadata
        }

        /// Function that returns all the Metadata Views implemented by a Non Fungible Token
        ///
        /// @return An array of Types defining the implemented views. This value will be used by
        ///         developers to know which parameter to pass to the resolveView() method.
        ///
        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.Editions>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.Traits>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.name,
                        description: self.description,
                        thumbnail: MetadataViews.HTTPFile(
                            url: self.thumbnail
                        )
                    )

                case Type<MetadataViews.Editions>():
                    // There is no max number of NFTs that can be minted from this contract
                    // so the max edition field value is set to nil
                    let editionInfo = MetadataViews.Edition(
                        name: self.name.concat(" NFT Edition"),
                        number: self.id, max: nil
                    )
                    let editionList: [MetadataViews.Edition] = [editionInfo]
                    return MetadataViews.Editions(
                        editionList
                    )

                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(
                        self.id
                    )

                case Type<MetadataViews.Royalties>():
                    return MetadataViews.Royalties([])

                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL(
                        StarNFT.baseUri.concat(self.id.toString()).concat(".json")
                    )

                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: StarNFT.CollectionStoragePath,
                        publicPath: StarNFT.CollectionPublicPath,
                        providerPath: /private/StarNFTCollection,
                        publicCollection: Type<&StarNFT.Collection{StarNFT.StarNFTCollectionPublic,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(),
                        publicLinkedType: Type<&StarNFT.Collection{StarNFT.StarNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&StarNFT.Collection{StarNFT.StarNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(),
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                            return <-StarNFT.createEmptyCollection()
                        })
                    )

                case Type<MetadataViews.NFTCollectionDisplay>():
                    return MetadataViews.NFTCollectionDisplay(
                        name: StarNFT.collectionName,
                        description: StarNFT.collectionDescription,
                        externalURL: StarNFT.collectionExternalURL,
                        squareImage: StarNFT.collectionSquareImage,
                        bannerImage: StarNFT.collectionBannerImage,
                        socials: StarNFT.collectionSocials,
                    )

                case Type<MetadataViews.Traits>():
                    return MetadataViews.dictToTraits(dict: self.metadata, excludedNames: [])
                }
                return nil
            }
        }

        /// Defines the methods that are particular to this NFT contract collection
        ///
        pub resource interface StarNFTCollectionPublic {
            pub fun deposit(token: @NonFungibleToken.NFT)
            pub fun getIDs(): [UInt64]
            pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver}
            pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
            pub fun borrowStarNFT(id: UInt64): &StarNFT.NFT? {
                post {
                    (result == nil) || (result?.id == id):
                        "Cannot borrow StarNFT reference: The ID of the returned reference is incorrect"
                }
            }
        }

    /// The resource that will be holding the NFTs inside any account.
    /// In order to be able to manage NFTs any account will need to create
    /// an empty collection first
    ///
    pub resource Collection: StarNFTCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with an `UInt64` ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        /// Removes an NFT from the collection and moves it to the caller
        ///
        /// @param withdrawID: The ID of the NFT that wants to be withdrawn
        /// @return The NFT resource that has been taken out of the collection
        ///
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        /// Adds an NFT to the collections dictionary and adds the ID to the id array
        ///
        /// @param token: The NFT resource to be included in the collection
        ///
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @StarNFT.NFT

            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token

            StarNFT.owners[id] = self.owner!.address

            emit Deposit(id: id, to: self.owner!.address)

            destroy oldToken
        }

        // transfer takes an NFT ID and a reference to a recipient's collection
        // and transfers the NFT corresponding to that ID to the recipient
        pub fun transfer(id: UInt64, recipient: &{NonFungibleToken.CollectionPublic}) {
            post {
                self.ownedNFTs[id] == nil: "The specified NFT was not transferred"
                recipient.borrowNFT(id: id) != nil: "Recipient did not receive the intended NFT"
            }

            let nft: @NonFungibleToken.NFT <- self.withdraw(withdrawID: id)

            emit Transfer(id: id, from: recipient.owner!.address, to: self.owner!.address)

            recipient.deposit(token: <- nft)
        }

        // burn destroys an NFT
        pub fun burn(id: UInt64) {
            post {
                self.ownedNFTs[id] == nil: "The specified NFT was not burned"
            }

            destroy <- self.withdraw(withdrawID: id)
        }

        /// Helper method for getting the collection IDs
        ///
        /// @return An array containing the IDs of the NFTs in the collection
        ///
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        /// Gets a reference to an NFT in the collection so that
        /// the caller can read its metadata and call its methods
        ///
        /// @param id: The ID of the wanted NFT
        /// @return A reference to the wanted NFT resource
        ///
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        /// Gets a reference to an NFT in the collection so that
        /// the caller can read its metadata and call its methods
        ///
        /// @param id: The ID of the wanted NFT
        /// @return A reference to the wanted NFT resource
        ///
        pub fun borrowStarNFT(id: UInt64): &StarNFT.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorized reference to allow downcasting
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &StarNFT.NFT
            }

            return nil
        }

        /// Gets a reference to the NFT only conforming to the `{MetadataViews.Resolver}`
        /// interface so that the caller can retrieve the views that the NFT
        /// is implementing and resolve them
        ///
        /// @param id: The ID of the wanted NFT
        /// @return The resource reference conforming to the Resolver interface
        ///
        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let starNFT = nft as! &StarNFT.NFT
            return starNFT
        }


        destroy() {
            destroy self.ownedNFTs
        }
    }

    /// Allows anyone to create a new empty collection
    ///
    /// @return The new Collection resource
    ///
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    /// Allows anyone to claim an NFT with a valid claim signature from Galxe
    ///
    pub fun claim(
        chain_id: String,
        campaign_id: UInt256,
        verify_id: UInt256,
        cap: UInt256,
        recipient: Address,
        signature: String,
        name: String,
        description: String,
        thumbnail: String,
        metadata: {String: String}
    ) {
        // check if verify_id is already minted
        if StarNFT.minted[verify_id] != nil {
            panic("NFT already minted")
        }

        // turn metadata into a string to verify signature
        var metadataStr = "{"
        metadata.forEachKey(fun (key: String): Bool {
            metadataStr = metadataStr.concat(key).concat(":").concat(metadata[key]!).concat(",")
            return true
        })
        // Removing the trailing comma and space
        if (metadataStr.length > 1) {
            metadataStr = metadataStr.slice(from: 0, upTo: metadataStr.length-1)
        }
        metadataStr = metadataStr.concat("}")

        // get current contract address
        let acct = self.account.address.toString()
        let contractAddr = "A.".concat(acct.slice(from: 2, upTo: acct.length)).concat(".StarNFT")

        let message = "NFT(chain_id:String,contract:String,campaign_id:u64,verify_id:u64,cap:u64,owner:u64,name:String,description:String,thumbnail:String:metadata:{String: String})"
            .concat(chain_id)
            .concat(contractAddr)
            .concat(campaign_id.toString())
            .concat(verify_id.toString())
            .concat(cap.toString())
            .concat(recipient.toString())
            .concat(String.encodeHex(HashAlgorithm.SHA3_256.hash(name.utf8)))
            .concat(String.encodeHex(HashAlgorithm.SHA3_256.hash(description.utf8)))
            .concat(String.encodeHex(HashAlgorithm.SHA3_256.hash(thumbnail.utf8)))
            .concat(String.encodeHex(HashAlgorithm.SHA3_256.hash(metadataStr.utf8)))
        log(message)
        if !self.verifyClaimSignature(
            address: self.signer,
            signature: signature,
            signedData: message.utf8
        ) {
            panic("Invalid signature")
        }

        // Increment the totalSupply for a new ID
        let id = StarNFT.totalSupply

        // Create the new NFT
        var newNFT <- create NFT(
            id: id,
            name: name,
            description: description,
            thumbnail: thumbnail,
            metadata: metadata
        )

        StarNFT.minted[verify_id] = true
        emit Minted(id: id, address: recipient)

        // Get the collection of the current account using a borrowed reference
        let receiver = getAccount(recipient)
            .getCapability(StarNFT.CollectionPublicPath)
            .borrow<&{NonFungibleToken.CollectionPublic}>()
            ?? panic("Could not get receiver reference to the NFT Collection")

        // Update the owners mapping
        StarNFT.owners.append(recipient)

        // Deposit the new NFT into the current account's collection
        receiver.deposit(token: <-newNFT)

        // Increment the total supply
        StarNFT.totalSupply = StarNFT.totalSupply + 1

        let minter = self.account.address

        emit Claim(campaign_id: campaign_id, verify_id: verify_id, minter: minter, owner: recipient, nft_id: id)
    }

    access(self) fun verifyClaimSignature(address: Address, signature: String, signedData: [UInt8]): Bool {
        let signatureBytes = signature.decodeHex()
	    let account = getAccount(self.signer)
	    let keys = account.keys
        var i = 0
        while true {
            if let key = keys.get(keyIndex: i) {
                if key.isRevoked {
                    // do not check revoked keys
                    i = i + 1
                    continue
                }
                let pk = PublicKey(
                        publicKey: key.publicKey.publicKey,
                        signatureAlgorithm: key.publicKey.signatureAlgorithm
                )
                if pk.verify(
                    signature: signatureBytes,
                    signedData: signedData,
                    domainSeparationTag: "",
                    hashAlgorithm: HashAlgorithm.SHA3_256
                ) {
                    return true
                }
            } else {
                return false
            }
            i = i + 1
        }

        return false
    }

    /// Resource that an admin or something similar would own to have admin operations access
    ///
    pub resource Owner {
        pub fun updateSigner(newSigner: Address) {
            StarNFT.signer = newSigner
        }
    }

    // Gets the owner of the given token ID
    pub fun ownerOf(tokenId: UInt64): Address? {
        if tokenId >= 0 {
            return StarNFT.owners[tokenId]
        }
        return nil
    }

    init() {
        self.baseUri = "https://graphigo.stg.galaxy.eco/metadata/0x123/"

        // Initialize signer
        self.signer = self.account.address

        // Initialize collection metadatas
        self.collectionName = "collection name"
        self.collectionDescription = "collection description"
        self.collectionExternalURL = MetadataViews.ExternalURL("https://galxe.com")
        self.collectionSquareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
                url: "https://bafybeifvcfyaljvjl4ei67llykxa2b7kpgpuzh4xcwnkxa6relbyg7kore.ipfs.nftstorage.link"
            ),
            mediaType: "image/png"
        )
        self.collectionBannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
                url: "https://bafybeifvcfyaljvjl4ei67llykxa2b7kpgpuzh4xcwnkxa6relbyg7kore.ipfs.nftstorage.link"
            ),
            mediaType: "image/png"
        )
        self.collectionSocials = {
            "twitter": MetadataViews.ExternalURL("https://twitter.com/oyyblin")
        }

        // Initialize contract internal metadatas
        // Initialize the total supply
        self.totalSupply = 0

        // Initalize mapping from ID to address
        self.owners = []

        // Initialize mapping from verify_id to bool
        self.minted = {}

        // Set the named paths
        self.CollectionStoragePath = /storage/StarNFTCollection
        self.CollectionPublicPath = /public/StarNFTCollection
        self.OwnerStoragePath = /storage/StarNFTOwner

        // Create a Collection resource and save it to storage
        let collection <- create Collection()
        self.account.save(<-collection, to: self.CollectionStoragePath)

        // create a public capability for the collection
        self.account.link<&StarNFT.Collection{NonFungibleToken.CollectionPublic, StarNFT.StarNFTCollectionPublic, MetadataViews.ResolverCollection}>(
            self.CollectionPublicPath,
            target: self.CollectionStoragePath
        )

        emit ContractInitialized()
    }
}
 "
-------
"import FungibleToken from 0xf233dcee88fe0abe
import Crypto
import ToucansTokens from 0x577a3c409c5dcb5e
import ToucansUtils from 0x577a3c409c5dcb5e
import ToucansActions from 0x577a3c409c5dcb5e
import FlowToken from 0x1654653399040a61
import ToucansLockTokens from 0x577a3c409c5dcb5e

pub contract Toucans {

  pub let CollectionStoragePath: StoragePath
  pub let CollectionPublicPath: PublicPath

  pub resource interface Minter {
    pub fun mint(amount: UFix64): @FungibleToken.Vault {
      post {
        result.balance == amount: "Did not mint correct number of tokens."
      }
    }
  }

  pub resource DummyMinter: Minter {
    pub fun mint(amount: UFix64): @FungibleToken.Vault {
      return <- FlowToken.createEmptyVault()
    }
  }

  pub event ProjectCreated(
    projectId: String,
    tokenTypeIdentifier: String?,
    by: Address
  )

  pub event NewFundingCycle(
    projectId: String,
    projectOwner: Address,
    newCycleId: UInt64,
    fundingTarget: UFix64?,
    issuanceRate: UFix64,
    reserveRate: UFix64,
    timeframe: CycleTimeFrame?
  )

  pub event Purchase(
    projectId: String,
    projectOwner: Address,
    currentCycle: UInt64,
    tokenSymbol: String,
    amount: UFix64,
    by: Address,
    message: String
  )

  pub event Donate(
    projectId: String,
    projectOwner: Address,
    currentCycle: UInt64?,
    amount: UFix64,
    tokenSymbol: String,
    by: Address,
    message: String
  )

  // Multi Sign Actions
  pub event Withdraw(
    projectId: String,
    projectOwner: Address,
    currentCycle: UInt64?,
    tokenSymbol: String,
    amount: UFix64,
    to: Address
  )
  pub event BatchWithdraw(
    projectId: String,
    projectOwner: Address,
    currentCycle: UInt64?,
    tokenSymbol: String,
    amounts: {Address: UFix64},
    amount: UFix64,
    failed: [Address]
  )
  pub event Mint(
    projectId: String,
    by: Address,
    currentCycle: UInt64?,
    tokenSymbol: String,
    to: Address,
    amount: UFix64
  )
  pub event BatchMint(
    projectId: String,
    by: Address,
    currentCycle: UInt64?,
    tokenSymbol: String,
    amounts: {Address: UFix64},
    amount: UFix64,
    failed: [Address]
  )
  pub event Burn(
    projectId: String,
    by: Address,
    currentCycle: UInt64?,
    tokenSymbol: String,
    amount: UFix64
  )
  pub event LockTokens(
    projectId: String,
    by: Address,
    to: Address,
    currentCycle: UInt64?,
    tokenSymbol: String,
    amount: UFix64,
    unlockTime: UFix64
  )
  pub event AddSigner(projectId: String, signer: Address)
  pub event RemoveSigner(projectId: String, signer: Address)
  pub event UpdateThreshold(projectId: String, newThreshold: UInt64)

  pub struct CycleTimeFrame {
    pub let startTime: UFix64
    pub let endTime: UFix64?

    init(_ st: UFix64, _ et: UFix64?) {
      pre {
        et == nil || (et! > st): "The end time must be greater than the start time."
      }
      self.startTime = st
      self.endTime = et
    }
  }

  pub struct Payout {
    pub let address: Address
    pub let percent: UFix64

    init(_ a: Address, _ p: UFix64) {
      pre {
        p > 0.0 && p < 1.0: "percent must be a percantage."
      }
      self.address = a
      self.percent = p
    }
  }

  pub struct FundingCycleDetails {
    pub let cycleId: UInt64
    // nil if the funding target is infinity
    pub let fundingTarget: UFix64?
    pub let issuanceRate: UFix64
    // a tax on purchases
    pub let reserveRate: UFix64
    pub let timeframe: CycleTimeFrame
    pub let payouts: [Payout]
    pub let allowOverflow: Bool
    pub let allowedAddresses: [Address]?
    pub let catalogCollectionIdentifier: String?
    pub let extra: {String: AnyStruct}

    init(cycleId: UInt64, fundingTarget: UFix64?, issuanceRate: UFix64, reserveRate: UFix64, timeframe: CycleTimeFrame, payouts: [Payout], allowOverflow: Bool, allowedAddresses: [Address]?, catalogCollectionIdentifier: String?, _ extra: {String: AnyStruct}) {
      pre {
        reserveRate <= 1.0: "You must provide a reserve rate value between 0.0 and 1.0"
      }
      self.cycleId = cycleId
      self.issuanceRate = issuanceRate
      self.fundingTarget = fundingTarget
      self.reserveRate = reserveRate
      self.timeframe = timeframe
      self.allowOverflow = allowOverflow
      self.allowedAddresses = allowedAddresses
      self.catalogCollectionIdentifier = catalogCollectionIdentifier
      self.extra = extra
      self.payouts = payouts

      var percentCount: UFix64 = 0.0
      for payout in self.payouts {
        percentCount = percentCount + payout.percent
      }
      assert(percentCount <= 1.0, message: "Payouts cannot total to more than 100%.")
    }
  }

  pub struct FundingCycle {
    pub(set) var details: FundingCycleDetails
    // the amount of tokens that users acquired during
    // this round (does not count the amount that got
    // reserved to treasury)
    pub var projectTokensAcquired: UFix64
    // This is the amount of payment received during the round.
    // This does NOT include Overflow that was transferred into this
    // round.
    pub var raisedDuringRound: UFix64
    // Same as raisedDuringRound but
    // also includes overflow transferred in
    pub var raisedTowardsGoal: UFix64
    pub let funders: {Address: UFix64}

    // called when a purchase happens
    access(contract) fun handlePaymentReceipt(projectTokensAcquired: UFix64, cost: UFix64, payer: Address) {
      self.projectTokensAcquired = self.projectTokensAcquired + projectTokensAcquired
      self.funders[payer] = (self.funders[payer] ?? 0.0) + cost
      self.raisedDuringRound = self.raisedDuringRound + cost
      self.raisedTowardsGoal = self.raisedTowardsGoal + cost
    }

    // for overflow purposes
    access(contract) fun raise(amount: UFix64) {
      self.raisedTowardsGoal = self.raisedTowardsGoal + amount
    }

    init(details: FundingCycleDetails) {
      self.details = details
      self.projectTokensAcquired = 0.0
      self.raisedTowardsGoal = 0.0
      self.funders = {}
      self.raisedDuringRound = 0.0
    }
  }

  pub resource interface ProjectPublic {
    pub let projectId: String
    pub var projectTokenInfo: ToucansTokens.TokenInfo
    pub let paymentTokenInfo: ToucansTokens.TokenInfo
    pub var totalFunding: UFix64
    pub var editDelay: UFix64
    pub var purchasing: Bool
    pub let minting: Bool

    // Setters
    // Some proposals we think make sense to be public initially
    pub fun proposeWithdraw(recipientVault: Capability<&{FungibleToken.Receiver}>, amount: UFix64)
    pub fun proposeMint(recipientVault: Capability<&{FungibleToken.Receiver}>, amount: UFix64)
    pub fun proposeBurn(tokenType: Type, amount: UFix64)
    pub fun proposeAddSigner(signer: Address)
    pub fun proposeRemoveSigner(signer: Address)
    pub fun proposeUpdateThreshold(threshold: UInt64)
    // If the action is ready to execute, then allow anyone to do it.
    pub fun finalizeAction(actionUUID: UInt64)
    pub fun donateToTreasury(vault: @FungibleToken.Vault, payer: Address, message: String)
    pub fun transferProjectTokenToTreasury(vault: @FungibleToken.Vault, payer: Address, message: String)
    pub fun purchase(paymentTokens: @FungibleToken.Vault, projectTokenReceiver: &{FungibleToken.Receiver}, message: String)
    pub fun claimOverflow(tokenVault: @FungibleToken.Vault, receiver: &{FungibleToken.Receiver})
    pub fun claimLockedTokens(lockedVaultUuid: UInt64, recipientVault: &{FungibleToken.Receiver})

    // Getters
    pub fun getCurrentIssuanceRate(): UFix64?
    pub fun getCurrentFundingCycle(): FundingCycle?
    pub fun getCurrentFundingCycleId(): UInt64?
    pub fun getFundingCycle(cycleIndex: UInt64): FundingCycle
    pub fun getFundingCycles(): [FundingCycle]
    pub fun getVaultTypesInTreasury(): [Type]
    pub fun getVaultBalanceInTreasury(vaultType: Type): UFix64?
    pub fun getExtra(): {String: AnyStruct}
    pub fun getCompletedActionIds(): {UInt64: Bool}
    pub fun getFunders(): {Address: UFix64}
    pub fun getOverflowBalance(): UFix64
    pub fun borrowManagerPublic(): &Manager{ManagerPublic}
    pub fun borrowLockTokensManagerPublic(): &ToucansLockTokens.Manager{ToucansLockTokens.ManagerPublic}?
    pub fun hasTokenContract(): Bool
  }

  pub resource Project: ProjectPublic {
    pub let projectId: String
    pub var projectTokenInfo: ToucansTokens.TokenInfo
    pub let paymentTokenInfo: ToucansTokens.TokenInfo
    // Of payment tokens
    pub var totalFunding: UFix64
    // You cannot edit or start a new cycle within this time frame
    pub var editDelay: UFix64
    pub let minting: Bool
    pub var purchasing: Bool
    pub var nextCycleId: UInt64

    // Kept in order of start date
    // i.e. every element in the array
    // must have a start time greater
    // than the one before it
    access(self) let fundingCycles: [FundingCycle]
    access(self) let treasury: @{Type: FungibleToken.Vault}
    access(self) let multiSignManager: @Manager
    access(self) let overflow: @FungibleToken.Vault
    access(self) var minter: @{Minter}
    access(self) let funders: {Address: UFix64}
    access(self) var extra: {String: AnyStruct}
    access(self) var additions: @{String: AnyResource}

    // This function will be called when the owner is ready to add their own token to the DAO.
    //
    // This function is useless if the project owner already configured a token when they
    // created the project.
    //
    // COMING SOON
    //
    // pub fun evolve(projectTokenInfo: ToucansTokens.TokenInfo, minter: @{Minter}, initialTreasurySupply: UFix64, editDelay: UFix64) {
    //   pre {
    //     !self.hasTokenContract(): "This project already has an associated token."
    //   }
    //   self.editDelay = editDelay
    //   self.projectTokenInfo = projectTokenInfo
    //   let initialVault: @FungibleToken.Vault <- minter.mint(amount: initialTreasurySupply)
    //   assert(initialVault.getType() == projectTokenInfo.tokenType, message: "The passed in minter did not mint the correct token type.")
    //   self.depositToTreasury(vault: <- initialVault)
    //   let dummyMinter <- self.minter <- minter
    //   destroy dummyMinter
    // }


    //  __  __       _ _   _    _____ _
    // |  \/  |     | | | (_)  / ____(_)
    // | \  / |_   _| | |_ _  | (___  _  __ _ _ __
    // | |\/| | | | | | __| |  \___ \| |/ _` | '_ \
    // | |  | | |_| | | |_| |  ____) | | (_| | | | |
    // |_|  |_|\__,_|_|\__|_| |_____/|_|\__, |_| |_|
    //                                   __/ |
    //                                  |___/


    pub fun proposeWithdraw(recipientVault: Capability<&{FungibleToken.Receiver}>, amount: UFix64) {
      let vaultType: Type = recipientVault.borrow()!.getType()
      let tokenInfo = self.getTokenInfo(inputVaultType: vaultType)
                ?? panic("Unsupported token type for withdrawing.")
      let action = ToucansActions.WithdrawToken(vaultType, recipientVault, amount, tokenInfo.symbol)
      self.multiSignManager.createMultiSign(action: action)
    }

    pub fun proposeBatchWithdraw(vaultType: Type, recipientVaults: {Address: Capability<&{FungibleToken.Receiver}>}, amounts: {Address: UFix64}) {
      let tokenInfo = self.getTokenInfo(inputVaultType: vaultType)
                ?? panic("Unsupported token type for withdrawing.")
      let action = ToucansActions.BatchWithdrawToken(vaultType, recipientVaults, amounts, tokenInfo.symbol)
      self.multiSignManager.createMultiSign(action: action)
    }

    pub fun proposeMint(recipientVault: Capability<&{FungibleToken.Receiver}>, amount: UFix64) {
      pre {
        recipientVault.borrow()!.getType() == self.projectTokenInfo.tokenType:
          "This vault cannot receive the projects token."
        self.minting: "Minting is turned off."
        self.hasTokenContract(): "There is no token to mint."
      }
      let action = ToucansActions.MintTokens(recipientVault, amount, self.projectTokenInfo.symbol)
      self.multiSignManager.createMultiSign(action: action)
    }

    pub fun proposeBurn(tokenType: Type, amount: UFix64) {
      let tokenInfo = self.getTokenInfo(inputVaultType: tokenType)
                ?? panic("Unsupported token type for burning.")
      let action = ToucansActions.BurnTokens(amount, tokenInfo.symbol)
      self.multiSignManager.createMultiSign(action: action)
    }

    pub fun proposeBatchMint(recipientVaults: {Address: Capability<&{FungibleToken.Receiver}>}, amounts: {Address: UFix64}) {
      pre {
        self.minting: "Minting is turned off."
        self.hasTokenContract(): "There is no token to mint."
      }
      let action = ToucansActions.BatchMintTokens(recipientVaults, amounts, self.projectTokenInfo.symbol)
      self.multiSignManager.createMultiSign(action: action)
    }

    pub fun proposeMintToTreasury(amount: UFix64) {
      pre {
        self.minting: "Minting is turned off."
        self.hasTokenContract(): "There is no token to mint."
      }
      let action = ToucansActions.MintTokensToTreasury(amount, self.projectTokenInfo.symbol)
      self.multiSignManager.createMultiSign(action: action)
    }

    pub fun proposeAddSigner(signer: Address) {
      pre {
        !self.multiSignManager.getSigners().contains(signer): "This wallet is already a signer."
      }
      let action = ToucansActions.AddOneSigner(signer)
      self.multiSignManager.createMultiSign(action: action)
    }

    pub fun proposeRemoveSigner(signer: Address) {
      pre {
        self.multiSignManager.getSigners().length > 1: "Cannot remove a signer if it will bring the signers to 0."
        self.multiSignManager.getSigners().contains(signer): "This wallet is not already a signer."
      }
      let action = ToucansActions.RemoveOneSigner(signer)
      self.multiSignManager.createMultiSign(action: action)
    }

    pub fun proposeUpdateThreshold(threshold: UInt64) {
      pre {
        self.multiSignManager.getSigners().length >= Int(threshold): "Threshold cannot be above number of signers."
        threshold > 0: "Threshold must be greater than 0."
      }
      let action = ToucansActions.UpdateTreasuryThreshold(threshold)
      self.multiSignManager.createMultiSign(action: action)
    }

    pub fun proposeLockTokens(recipient: Address, tokenType: Type, amount: UFix64, unlockTime: UFix64) {
      let tokenInfo = self.getTokenInfo(inputVaultType: tokenType)
                ?? panic("Unsupported token type for locking tokens.")
      let action = ToucansActions.LockTokens(recipient, amount, tokenInfo.symbol, unlockTime)
      self.multiSignManager.createMultiSign(action: action)
    }

    pub fun finalizeAction(actionUUID: UInt64) {
      let actionState: ActionState = self.multiSignManager.getActionState(actionUUID: actionUUID)
      assert(actionState == ActionState.ACCEPTED || actionState == ActionState.DECLINED, message: "Cannot finalize this action yet.")

      if actionState == ActionState.ACCEPTED {
        self.markCompletedAction(actionUUID: actionUUID, mark: true)
        let actionWrapper: &MultiSignAction = self.multiSignManager.borrowAction(actionUUID: actionUUID)
        let action: {ToucansActions.Action} = actionWrapper.action
        switch action.getType() {
          case Type<ToucansActions.WithdrawToken>():
            let withdraw: ToucansActions.WithdrawToken = action as! ToucansActions.WithdrawToken
            let recipientVault: &{FungibleToken.Receiver} = withdraw.recipientVault.borrow()!
            self.withdrawFromTreasury(vaultType: withdraw.vaultType, vault: recipientVault, amount: withdraw.amount, tokenSymbol: withdraw.tokenSymbol)
          case Type<ToucansActions.BatchWithdrawToken>():
            let withdraw: ToucansActions.BatchWithdrawToken = action as! ToucansActions.BatchWithdrawToken
            self.batchWithdrawFromTreasury(vaultType: withdraw.vaultType, vaults: withdraw.recipientVaults, amounts: withdraw.amounts, tokenSymbol: withdraw.tokenSymbol)
          case Type<ToucansActions.MintTokens>():
            let mint: ToucansActions.MintTokens = action as! ToucansActions.MintTokens
            self.mint(recipientVault: mint.recipientVault.borrow()!, amount: mint.amount)
          case Type<ToucansActions.BatchMintTokens>():
            let mint: ToucansActions.BatchMintTokens = action as! ToucansActions.BatchMintTokens
            self.batchMint(vaults: mint.recipientVaults, amounts: mint.amounts)
          case Type<ToucansActions.BurnTokens>():
            let burn: ToucansActions.BurnTokens = action as! ToucansActions.BurnTokens
            if burn.tokenSymbol == self.projectTokenInfo.symbol {
              self.burn(tokenType: self.projectTokenInfo.tokenType, tokenSymbol: burn.tokenSymbol, amount: burn.amount)
            } else {
              self.burn(tokenType: ToucansTokens.getTokenInfoFromSymbol(symbol: burn.tokenSymbol)!.tokenType, tokenSymbol: burn.tokenSymbol, amount: burn.amount)
            }
          case Type<ToucansActions.MintTokensToTreasury>():
            let mint: ToucansActions.MintTokensToTreasury = action as! ToucansActions.MintTokensToTreasury
            let ref: &FungibleToken.Vault = (&self.treasury[self.projectTokenInfo.tokenType] as &FungibleToken.Vault?)!
            self.mint(recipientVault: ref, amount: mint.amount)
          case Type<ToucansActions.AddOneSigner>():
            let addSigner: ToucansActions.AddOneSigner = action as! ToucansActions.AddOneSigner
            self.multiSignManager.addSigner(signer: addSigner.signer)
            emit AddSigner(projectId: self.projectId, signer: addSigner.signer)
          case Type<ToucansActions.RemoveOneSigner>():
            let removeSigner: ToucansActions.RemoveOneSigner = action as! ToucansActions.RemoveOneSigner
            self.multiSignManager.removeSigner(signer: removeSigner.signer)
            emit RemoveSigner(projectId: self.projectId, signer: removeSigner.signer)
          case Type<ToucansActions.UpdateTreasuryThreshold>():
            let updateThreshold: ToucansActions.UpdateTreasuryThreshold = action as! ToucansActions.UpdateTreasuryThreshold
            self.multiSignManager.updateThreshold(newThreshold: updateThreshold.threshold)
            emit UpdateThreshold(projectId: self.projectId, newThreshold: updateThreshold.threshold)
          case Type<ToucansActions.LockTokens>():
            let tokenLock: ToucansActions.LockTokens = action as! ToucansActions.LockTokens
            if tokenLock.tokenSymbol == self.projectTokenInfo.symbol {
              self.sendToLock(recipient: tokenLock.recipient, tokenInfo: self.projectTokenInfo, amount: tokenLock.amount, unlockTime: tokenLock.unlockTime)
            } else {
              self.sendToLock(recipient: tokenLock.recipient, tokenInfo: ToucansTokens.getTokenInfoFromSymbol(symbol: tokenLock.tokenSymbol)!, amount: tokenLock.amount, unlockTime: tokenLock.unlockTime)
            }
        }
      }
      if actionState == ActionState.DECLINED {
        self.markCompletedAction(actionUUID: actionUUID, mark: false)
      }

      // Will delete the action and make sure everything is good to go
      self.multiSignManager.destroyAction(actionUUID: actionUUID)
    }


    //   ______               _           _
    //  |  ____|             | |         (_)
    //  | |__ _   _ _ __   __| |_ __ __ _ _ ___  ___
    //  |  __| | | | '_ \ / _` | '__/ _` | / __|/ _ \
    //  | |  | |_| | | | | (_| | | | (_| | \__ \  __/
    //  |_|   \__,_|_| |_|\__,_|_|  \__,_|_|___/\___|


    // Allows you to add a new funding round to the end of the array.
    // This does not allow you to insert a funding round into the middle
    // somewhere. Maybe we will allow this later.
    // NOTES:
    // If `fundingTarget` is nil, that means this is an on-going funding round,
    // and there is no limit.
    pub fun configureFundingCycle(fundingTarget: UFix64?, issuanceRate: UFix64, reserveRate: UFix64, timeframe: CycleTimeFrame, payouts: [Payout], allowOverflow: Bool, allowedAddresses: [Address]?, catalogCollectionIdentifier: String?, extra: {String: AnyStruct}) {
      pre {
        getCurrentBlock().timestamp + self.editDelay <= timeframe.startTime: "You cannot configure a new cycle to start within the edit delay."
        timeframe.startTime >= getCurrentBlock().timestamp: "Start time must be now or in the future."
        self.hasTokenContract(): "There is no token to mint."
      }

      let newFundingCycle: FundingCycle = FundingCycle(details: FundingCycleDetails(
        cycleId: self.nextCycleId,
        fundingTarget: fundingTarget,
        issuanceRate: issuanceRate,
        reserveRate: reserveRate,
        timeframe: timeframe,
        payouts: payouts,
        allowOverflow: allowOverflow,
        allowedAddresses: allowedAddresses,
        catalogCollectionIdentifier: catalogCollectionIdentifier,
        extra
      ))

      var i: Int = self.fundingCycles.length - 1
      var insertAt: Int = 0
      while i >= 0 {
        let cycle: FundingCycle = self.fundingCycles[i]
        if timeframe.startTime >= cycle.details.timeframe.startTime {
          insertAt = i + 1
          break
        }
        i = i - 1
      }

      self.fundingCycles.insert(at: insertAt, newFundingCycle)

      // Make sure it doesn't conflict with a cycle before it
      if insertAt > 0 {
        let previousCycle: FundingCycle = self.getFundingCycle(cycleIndex: UInt64(insertAt - 1))
        Toucans.assertNonConflictingCycles(earlierCycle: previousCycle.details, laterCycle: newFundingCycle.details)
      }

      // Make sure it doesn't conflict with a cycle after it
      if insertAt < self.fundingCycles.length - 1 {
        let subsequentCycle: FundingCycle = self.getFundingCycle(cycleIndex: UInt64(insertAt + 1))
        Toucans.assertNonConflictingCycles(earlierCycle: newFundingCycle.details, laterCycle: subsequentCycle.details)
      }

      emit NewFundingCycle(
        projectId: self.projectId,
        projectOwner: self.owner!.address,
        newCycleId: self.nextCycleId,
        fundingTarget: fundingTarget,
        issuanceRate: issuanceRate,
        reserveRate: reserveRate,
        timeframe: timeframe
      )
      self.nextCycleId = self.nextCycleId + 1
    }

    // Allows you to edit a cycle that has not happened yet
    pub fun editUpcomingCycle(cycleIndex: UInt64, details: FundingCycleDetails) {
      let fundingCycle: &FundingCycle = self.borrowFundingCycleRef(cycleIndex: cycleIndex)
      let currentTime: UFix64 = getCurrentBlock().timestamp
      assert(fundingCycle.details.cycleId == details.cycleId, message: "Cannot edit the cycleId.")
      assert(
        self.editDelay == 0.0 || (currentTime + self.editDelay <= details.timeframe.startTime),
        message: "You are no longer allowed to edit this upcoming cycle because of your edit delay."
      )
      assert(
        fundingCycle.details.timeframe.startTime == details.timeframe.startTime ||
        currentTime <= fundingCycle.details.timeframe.startTime,
        message: "You can only change the start time if the round hasn't started yet."
      )
      assert(
        fundingCycle.details.timeframe.startTime == details.timeframe.startTime ||
        currentTime <= details.timeframe.startTime,
        message: "New start time must be greater than now."
      )

      // Check the cycle above it, if it exists
      if Int(cycleIndex) < self.fundingCycles.length - 1 {
        let aboveCycle: FundingCycle = self.getFundingCycle(cycleIndex: cycleIndex + 1)
        Toucans.assertNonConflictingCycles(earlierCycle: details, laterCycle: aboveCycle.details)
      }

      // Check the cycle below it, if it exists
      if cycleIndex > 0 {
        let belowCycle: FundingCycle = self.getFundingCycle(cycleIndex: cycleIndex - 1)
        Toucans.assertNonConflictingCycles(earlierCycle: belowCycle.details, laterCycle: details)
      }

      fundingCycle.details = details
    }

    pub fun togglePurchasing() {
      self.purchasing = !self.purchasing
    }

    pub fun purchase(paymentTokens: @FungibleToken.Vault, projectTokenReceiver: &{FungibleToken.Receiver}, message: String) {
      pre {
        paymentTokens.getType() == self.paymentTokenInfo.tokenType: "This is not the correct payment."
        self.purchasing: "Purchasing is turned off at the moment."
        self.hasTokenContract(): "There is no token to purchase."
      }
      let fundingCycleRef: &FundingCycle = self.borrowCurrentFundingCycleRef() ?? panic("There is no active cycle.")

      // tax for emerald city (5%)
      let emeraldCityTreasury = getAccount(0x5643fd47a29770e7).getCapability(self.paymentTokenInfo.receiverPath)
                                          .borrow<&{FungibleToken.Receiver}>()
                                          ?? panic("Emerald City treasury cannot accept this payment. Please contact us in our Discord.")
      emeraldCityTreasury.deposit(from: <- paymentTokens.withdraw(amount: paymentTokens.balance * 0.05))

      let paymentAfterTax: UFix64 = paymentTokens.balance
      let payer: Address = projectTokenReceiver.owner!.address

      // If there is a limit on allowed addresses, check that here.
      if let allowedAddresses: [Address] = fundingCycleRef.details.allowedAddresses {
        assert(
          allowedAddresses.contains(payer),
          message: "This account is not allowed to participate in this round."
        )
      }

      // If the payer must have a certain NFT, check that here.
      if let catalogCollectionIdentifier: String = fundingCycleRef.details.catalogCollectionIdentifier {
        assert(
          ToucansUtils.ownsNFTFromCatalogCollectionIdentifier(collectionIdentifier: catalogCollectionIdentifier, user: payer),
          message: "User does not own a requried NFT for participating in the round."
        )
      }

      let issuanceRate: UFix64 = self.getCurrentIssuanceRate()!
      let amountToMint: UFix64 = issuanceRate * paymentAfterTax
      let mintedTokens: @FungibleToken.Vault <- self.minter.mint(amount: amountToMint)
      assert(mintedTokens.getType() == self.projectTokenInfo.tokenType, message: "Someone is messing with the minter. It's not minting the original type.")
      assert(amountToMint == mintedTokens.balance, message: "Not enough tokens were minted.")

      // RESERVE RATE: Withhold some of the purchased tokens
      let reserved: @FungibleToken.Vault <- mintedTokens.withdraw(amount: mintedTokens.balance * fundingCycleRef.details.reserveRate)
      // Deposit tax to project treasury
      self.depositToTreasury(vault: <- reserved)

      // 2 cases:
      // 1. Funding target is nil OR amount sent won't exceed the target (deposit everything to treasury)
      // 2. Amount sent will make us overflow the goal or it has already been reached (split between overflow and treasury)
      let fundingTarget: UFix64? = fundingCycleRef.details.fundingTarget
      if fundingTarget == nil || (fundingCycleRef.raisedTowardsGoal + paymentAfterTax <= fundingTarget!) {
        // Calculate payouts
        for payout in fundingCycleRef.details.payouts {
          ToucansUtils.depositTokensToAccount(funds: <- paymentTokens.withdraw(amount: paymentAfterTax * payout.percent), to: payout.address, publicPath: self.paymentTokenInfo.receiverPath)
        }
        self.depositToTreasury(vault: <- paymentTokens)
      } else {
        // "Fail fast"
        assert(fundingCycleRef.details.allowOverflow, message: "Overflow is not allowed. Cannot purchase.")
        if fundingCycleRef.raisedTowardsGoal < fundingTarget! {
          // this is the amount that will put the current round at its goal
          var amountToGoal: UFix64 = fundingTarget! - fundingCycleRef.raisedTowardsGoal
          // calculate payouts
          for payout in fundingCycleRef.details.payouts {
            let amountToPayout: UFix64 = amountToGoal * payout.percent
            ToucansUtils.depositTokensToAccount(funds: <- paymentTokens.withdraw(amount: amountToPayout), to: payout.address, publicPath: self.paymentTokenInfo.receiverPath)
            amountToGoal = amountToGoal - amountToPayout
          }
          // put the rest in treasury
          self.depositToTreasury(vault: <- paymentTokens.withdraw(amount: amountToGoal))
        }

        // Give the rest to overflow
        self.depositToOverflow(vault: <- paymentTokens)
      }

      // Tokens were purchased, so increment amount raised
      self.totalFunding = self.totalFunding + paymentAfterTax
      self.funders[payer] = (self.funders[payer] ?? 0.0) + paymentAfterTax
      // Amount acquired by user is the amount minted - the reserve tax
      fundingCycleRef.handlePaymentReceipt(projectTokensAcquired: mintedTokens.balance, cost: paymentAfterTax, payer: payer)
      // Deposit new tokens to payer
      projectTokenReceiver.deposit(from: <- mintedTokens)
      emit Purchase(
        projectId: self.projectId,
        projectOwner: self.owner!.address,
        currentCycle: fundingCycleRef.details.cycleId,
        tokenSymbol: self.paymentTokenInfo.symbol,
        amount: paymentAfterTax,
        by: payer,
        message: message
      )
    }


    //   _    _      _
    //  | |  | |    | |
    //  | |__| | ___| |_ __   ___ _ __
    //  |  __  |/ _ \ | '_ \ / _ \ '__|
    //  | |  | |  __/ | |_) |  __/ |
    //  |_|  |_|\___|_| .__/ \___|_|
    //                | |
    //                |_|


    access(self) fun depositToTreasury(vault: @FungibleToken.Vault) {
      if let existingVault = &self.treasury[vault.getType()] as &FungibleToken.Vault? {
        existingVault.deposit(from: <- vault)
      } else {
        self.treasury[vault.getType()] <-! vault
      }
    }

    access(self) fun depositToOverflow(vault: @FungibleToken.Vault) {
      pre {
        vault.getType() == self.paymentTokenInfo.tokenType: "Not payment token type."
      }
      self.overflow.deposit(from: <- vault)
    }

    access(account) fun borrowManager(): &Manager {
      return &self.multiSignManager as &Manager
    }

    pub fun getTokenInfo(inputVaultType: Type): ToucansTokens.TokenInfo? {
      if inputVaultType == self.projectTokenInfo.tokenType {
        return self.projectTokenInfo
      } else if let tokenInfo = ToucansTokens.getTokenInfo(tokenType: inputVaultType) {
        return tokenInfo
      }
      return nil
    }

    access(self) fun withdrawFromTreasury(vaultType: Type, vault: &{FungibleToken.Receiver}, amount: UFix64, tokenSymbol: String) {
      emit Withdraw(
        projectId: self.projectId,
        projectOwner: self.owner!.address,
        currentCycle: self.getCurrentFundingCycleId(),
        tokenSymbol: tokenSymbol,
        amount: amount,
        to: vault.owner!.address
      )
      vault.deposit(from: <- self.treasury[vaultType]?.withdraw!(amount: amount))
    }

    access(self) fun batchWithdrawFromTreasury(vaultType: Type, vaults: {Address: Capability<&{FungibleToken.Receiver}>}, amounts: {Address: UFix64}, tokenSymbol: String) {
      let failed: [Address] = []
      var totalAmount: UFix64 = 0.0
      for wallet in amounts.keys {
        let amount: UFix64 = amounts[wallet]!
        totalAmount = totalAmount + amount
        if let recipientVault: &{FungibleToken.Receiver} = vaults[wallet]!.borrow() {
          recipientVault.deposit(from: <- self.treasury[vaultType]?.withdraw!(amount: amount))
        } else {
          failed.append(wallet)
        }
      }
      emit BatchWithdraw(
        projectId: self.projectId,
        projectOwner: self.owner!.address,
        currentCycle: self.getCurrentFundingCycleId(),
        tokenSymbol: tokenSymbol,
        amounts: amounts,
        amount: totalAmount,
        failed: failed
      )
    }

    pub fun donateToTreasury(vault: @FungibleToken.Vault, payer: Address, message: String) {
      let tokenInfo = self.getTokenInfo(inputVaultType: vault.getType())
                ?? panic("Unsupported token type for donating.")

      // tax for emerald city (5%)
      let emeraldCityTreasury = getAccount(0x5643fd47a29770e7).getCapability(tokenInfo.receiverPath)
                                          .borrow<&{FungibleToken.Receiver}>()
                                          ?? panic("Emerald City treasury cannot accept this payment. Please contact us in our Discord.")
      emeraldCityTreasury.deposit(from: <- vault.withdraw(amount: vault.balance * 0.05))

      emit Donate(
        projectId: self.projectId,
        projectOwner: self.owner!.address,
        currentCycle: self.getCurrentFundingCycleId(),
        amount: vault.balance,
        tokenSymbol: tokenInfo.symbol,
        by: payer,
        message: message
      )
      if vault.getType() == self.paymentTokenInfo.tokenType {
        self.totalFunding = self.totalFunding + vault.balance
        self.funders[payer] = (self.funders[payer] ?? 0.0) + vault.balance
      }
      self.depositToTreasury(vault: <- vault)
    }

    pub fun transferProjectTokenToTreasury(vault: @FungibleToken.Vault, payer: Address, message: String) {
      pre {
        vault.getType() == self.projectTokenInfo.tokenType: "The received vault is not the project's token type."
        self.hasTokenContract(): "There is no project token."
      }
      emit Donate(
        projectId: self.projectId,
        projectOwner: self.owner!.address,
        currentCycle: self.getCurrentFundingCycleId(),
        amount: vault.balance,
        tokenSymbol: self.projectTokenInfo.symbol,
        by: payer,
        message: message
      )
      self.depositToTreasury(vault: <- vault)
    }

    access(self) fun markCompletedAction(actionUUID: UInt64, mark: Bool) {
      if self.extra["completedActionIds"] == nil {
        let completedActionIds: {UInt64: Bool} = {}
        self.extra["completedActionIds"] = completedActionIds
      }

      (self.extra["completedActionIds"]! as! {UInt64: Bool}).insert(key: actionUUID, mark)
    }


    //   __  __ _       _   _
    //  |  \/  (_)     | | (_)
    //  | \  / |_ _ __ | |_ _ _ __   __ _
    //  | |\/| | | '_ \| __| | '_ \ / _` |
    //  | |  | | | | | | |_| | | | | (_| |
    //  |_|  |_|_|_| |_|\__|_|_| |_|\__, |
    //                               __/ |
    //                              |___/


    access(account) fun mint(recipientVault: &{FungibleToken.Receiver}, amount: UFix64) {
      pre {
        self.minting: "Minting is off. You cannot do this."
        self.hasTokenContract(): "There is no token to mint."
      }

      let tokens <- self.minter.mint(amount: amount)
      recipientVault.deposit(from: <- tokens)

      emit Mint(
        projectId: self.projectId,
        by: self.owner!.address,
        currentCycle: self.getCurrentFundingCycleId(),
        tokenSymbol: self.projectTokenInfo.symbol,
        to: recipientVault.owner!.address,
        amount: amount
      )
    }

    access(account) fun batchMint(vaults: {Address: Capability<&{FungibleToken.Receiver}>}, amounts: {Address: UFix64}) {
      pre {
        self.minting: "Minting is off. You cannot do this."
        self.hasTokenContract(): "There is no token to mint."
      }

      let failed: [Address] = []
      var totalAmount: UFix64 = 0.0
      for wallet in amounts.keys {
        let amount = amounts[wallet]!
        totalAmount = totalAmount + amount
        if let recipientVault: &{FungibleToken.Receiver} = vaults[wallet]!.borrow() {
           let tokens <- self.minter.mint(amount: amount)
           recipientVault.deposit(from: <- tokens)
           continue
        }
        failed.append(wallet)
      }
      emit BatchMint(
        projectId: self.projectId,
        by: self.owner!.address,
        currentCycle: self.getCurrentFundingCycleId(),
        tokenSymbol: self.projectTokenInfo.symbol,
        amounts: amounts,
        amount: totalAmount,
        failed: failed
      )
    }


    //   _______    _                _                _
    //  |__   __|  | |              | |              | |
    //     | | ___ | | _____ _ __   | |     ___   ___| | __
    //     | |/ _ \| |/ / _ \ '_ \  | |    / _ \ / __| |/ /
    //     | | (_) |   <  __/ | | | | |___| (_) | (__|   <
    //     |_|\___/|_|\_\___|_| |_| |______\___/ \___|_|\_\


    access(account) fun sendToLock(recipient: Address, tokenInfo: ToucansTokens.TokenInfo, amount: UFix64, unlockTime: UFix64) {
      if self.additions["lockedTokensManager"] == nil {
        self.additions["lockedTokensManager"] <-! ToucansLockTokens.createManager()
      }

      let tokenLockManager: &ToucansLockTokens.Manager = self.borrowLockTokensManager()!
      let vaultToLock <- self.treasury[tokenInfo.tokenType]?.withdraw!(amount: amount)
      tokenLockManager.deposit(recipient: recipient, unlockTime: unlockTime, vault: <- vaultToLock, tokenInfo: tokenInfo)

      emit LockTokens(
        projectId: self.projectId,
        by: self.owner!.address,
        to: recipient,
        currentCycle: self.getCurrentFundingCycleId(),
        tokenSymbol: tokenInfo.symbol,
        amount: amount,
        unlockTime: unlockTime
      )
    }

    pub fun claimLockedTokens(lockedVaultUuid: UInt64, recipientVault: &{FungibleToken.Receiver}) {
      if self.additions["lockedTokensManager"] == nil {
        self.additions["lockedTokensManager"] <-! ToucansLockTokens.createManager()
      }

      let tokenLockManager: &ToucansLockTokens.Manager{ToucansLockTokens.ManagerPublic} = self.borrowLockTokensManagerPublic()!
      tokenLockManager.claim(lockedVaultUuid: lockedVaultUuid, receiver: recipientVault)
    }


    //   ____
    //  |  _ \
    //  | |_) |_   _ _ __ _ __
    //  |  _ <| | | | '__| '_ \
    //  | |_) | |_| | |  | | | |
    //  |____/ \__,_|_|  |_| |_|


    access(account) fun burn(tokenType: Type, tokenSymbol: String, amount: UFix64) {
      let tokens <- self.treasury[tokenType]?.withdraw!(amount: amount)
      destroy tokens

      emit Burn(
        projectId: self.projectId,
        by: self.owner!.address,
        currentCycle: self.getCurrentFundingCycleId(),
        tokenSymbol: tokenSymbol,
        amount: amount
      )
    }


    //    ____                  __ _
    //   / __ \                / _| |
    //  | |  | |_   _____ _ __| |_| | _____      __
    //  | |  | \ \ / / _ \ '__|  _| |/ _ \ \ /\ / /
    //  | |__| |\ V /  __/ |  | | | | (_) \ V  V /
    //   \____/  \_/ \___|_|  |_| |_|\___/ \_/\_/


    // can only be called if amount does not put us over the funding target
    pub fun transferOverflowToCurrentRound(amount: UFix64) {
      let cycle = self.borrowCurrentFundingCycleRef() ?? panic("There must be an active funding cycle in order to do this.")
      let overflow <- self.overflow.withdraw(amount: amount)
      // will fail if this puts the cycle over the funding target
      cycle.raise(amount: amount)
      self.depositToTreasury(vault: <- overflow)

      assert(
        cycle.details.fundingTarget == nil || (cycle.raisedTowardsGoal <= cycle.details.fundingTarget!),
        message: "Transferred Overflow cannot put the current funding round over its goal."
      )
    }

    pub fun claimOverflow(tokenVault: @FungibleToken.Vault, receiver: &{FungibleToken.Receiver}) {
      pre {
        tokenVault.getType() == self.projectTokenInfo.tokenType: "This is not the project's token."
      }
      let balance: UFix64 = tokenVault.balance
      let totalSupply: UFix64 = getAccount(self.projectTokenInfo.contractAddress).contracts.borrow<&FungibleToken>(name: self.projectTokenInfo.contractName)!.totalSupply
      let percent: UFix64 = balance / totalSupply
      assert(percent >= 0.0 && percent <= 1.0, message: "Percent must be a percent value.")

      let overflowBalance: UFix64 = self.getOverflowBalance()

      receiver.deposit(from: <- self.overflow.withdraw(amount: overflowBalance * percent))
      self.depositToTreasury(vault: <- tokenVault)
    }


    //    _____      _   _
    //   / ____|    | | | |
    //  | |  __  ___| |_| |_ ___ _ __ ___
    //  | | |_ |/ _ \ __| __/ _ \ '__/ __|
    //  | |__| |  __/ |_| ||  __/ |  \__ \
    //   \_____|\___|\__|\__\___|_|  |___/


    pub fun getVaultTypesInTreasury(): [Type] {
      return self.treasury.keys
    }

    // Returns nil if the requested type doesn't exist in the treasury
    pub fun getVaultBalanceInTreasury(vaultType: Type): UFix64? {
      return self.treasury[vaultType]?.balance
    }

    pub fun getCurrentFundingCycleIndex(): Int? {
      var i: Int = self.fundingCycles.length - 1
      let timestamp: UFix64 = getCurrentBlock().timestamp

      while i >= 0 {
        let cycle: FundingCycle = self.fundingCycles[i]
        // If at any time we're greater than the cycle we're inspecting's start
        // time, we will return something.
        if timestamp >= cycle.details.timeframe.startTime {
          if (cycle.details.timeframe.endTime == nil || timestamp <= cycle.details.timeframe.endTime!){
            // In this case, we're in the middle of the latest one
            return i
          } else {
            // In this case, we're past the latest one
            return nil
          }
        }
        i = i - 1
      }
      return nil
    }

    // Returns nil if there is no current round
    pub fun getCurrentFundingCycle(): FundingCycle? {
      let index: Int? = self.getCurrentFundingCycleIndex()
      if index == nil {
        return nil
      }
      return self.fundingCycles[index!]
    }

    pub fun getCurrentFundingCycleId(): UInt64? {
      let currentCycle = self.getCurrentFundingCycle()
      return currentCycle?.details?.cycleId
    }

    // Returns nil if there is no current round
    pub fun getCurrentIssuanceRate(): UFix64? {
      return self.getCurrentFundingCycle()?.details?.issuanceRate
    }

    pub fun getFundingCycle(cycleIndex: UInt64): FundingCycle {
      return self.fundingCycles[cycleIndex]
    }

    pub fun getFundingCycles(): [FundingCycle] {
      return self.fundingCycles
    }

    pub fun getExtra(): {String: AnyStruct} {
      return self.extra
    }

    pub fun getCompletedActionIds(): {UInt64: Bool} {
      if self.extra["completedActionIds"] == nil {
        return {}
      }

      return self.extra["completedActionIds"]! as! {UInt64: Bool}
    }

    pub fun getFunders(): {Address: UFix64} {
      return self.funders
    }

    pub fun getOverflowBalance(): UFix64 {
      return self.overflow.balance
    }

    pub fun hasTokenContract(): Bool {
      return self.minter.getType() != Type<@DummyMinter>()
    }


    //   ____
    //  |  _ \
    //  | |_) | ___  _ __ _ __ _____      __
    //  |  _ < / _ \| '__| '__/ _ \ \ /\ / /
    //  | |_) | (_) | |  | | | (_) \ V  V /
    //  |____/ \___/|_|  |_|  \___/ \_/\_/


    access(self) fun borrowFundingCycleRef(cycleIndex: UInt64): &FundingCycle {
      return &self.fundingCycles[cycleIndex] as &FundingCycle
    }

    access(self) fun borrowCurrentFundingCycleRef(): &FundingCycle? {
      let index: Int? = self.getCurrentFundingCycleIndex()
      if index == nil {
        return nil
      }
      return &self.fundingCycles[index!] as &FundingCycle
    }

    pub fun borrowManagerPublic(): &Manager{ManagerPublic} {
      return &self.multiSignManager as &Manager{ManagerPublic}
    }

    access(self) fun borrowLockTokensManager(): &ToucansLockTokens.Manager? {
      if let lockTokensManager = &self.additions["lockedTokensManager"] as auth &AnyResource? {
        return lockTokensManager as! &ToucansLockTokens.Manager
      }
      return nil
    }

    pub fun borrowLockTokensManagerPublic(): &ToucansLockTokens.Manager{ToucansLockTokens.ManagerPublic}? {
      if let lockTokensManager = &self.additions["lockedTokensManager"] as auth &AnyResource? {
        return lockTokensManager as! &ToucansLockTokens.Manager{ToucansLockTokens.ManagerPublic}
      }
      return nil
    }

    init(
      projectId: String,
      projectTokenInfo: ToucansTokens.TokenInfo,
      paymentTokenInfo: ToucansTokens.TokenInfo,
      minter: @{Minter},
      editDelay: UFix64,
      initialSigners: [Address],
      initialThreshold: UInt64,
      minting: Bool,
      initialTreasurySupply: UFix64,
      extra: {String: AnyStruct}
    ) {
      pre {
        ToucansTokens.getTokenInfo(tokenType: paymentTokenInfo.tokenType) != nil: "Unsupported token type for payment."
      }

      let paymentContract = getAccount(paymentTokenInfo.contractAddress).contracts.borrow<&FungibleToken>(name: paymentTokenInfo.contractName)!
      let emptyPaymentVault <- paymentContract.createEmptyVault()

      // no new token created
      if minter.getType() == Type<@DummyMinter>() {
        self.treasury <- {emptyPaymentVault.getType(): <- emptyPaymentVault}
      } else {
        let initialVault: @FungibleToken.Vault <- minter.mint(amount: initialTreasurySupply)
        assert(initialVault.getType() == projectTokenInfo.tokenType, message: "The passed in minter did not mint the correct token type.")
        self.treasury <- {projectTokenInfo.tokenType: <- initialVault, emptyPaymentVault.getType(): <- emptyPaymentVault}
      }
      self.projectId = projectId
      self.nextCycleId = 0
      self.totalFunding = 0.0
      self.extra = extra
      let completedActionIds: {UInt64: Bool} = {}
      self.extra["completedActionIds"] = completedActionIds
      self.fundingCycles = []
      self.minter <- minter
      self.funders = {}
      self.editDelay = editDelay
      self.projectTokenInfo = projectTokenInfo
      self.paymentTokenInfo = paymentTokenInfo
      self.minting = minting
      self.purchasing = true
      self.additions <- {
        "lockedTokensManager": <- ToucansLockTokens.createManager()
      }
      self.overflow <- paymentContract.createEmptyVault()
      self.multiSignManager <- create Manager(_initialSigners: initialSigners, _initialThreshold: initialThreshold)
    }

    destroy() {
      pre {
        false: "Disabled for now."
      }
      destroy self.treasury
      destroy self.minter
      destroy self.overflow
      destroy self.multiSignManager
      destroy self.additions
    }
  }

  pub resource interface CollectionPublic {
    pub fun getProjectIds(): [String]
    pub fun borrowProjectPublic(projectId: String): &Project{ProjectPublic}?
  }

  pub resource Collection: CollectionPublic {
    pub let projects: @{String: Project}

    pub fun createProjectNoToken(
      projectId: String,
      paymentTokenInfo: ToucansTokens.TokenInfo,
      extra: {String: AnyStruct},
      payment: @FlowToken.Vault
    ) {
      let project: @Project <- create Project(
        projectId: projectId,
        projectTokenInfo: paymentTokenInfo, // use the payment token, or "preferred currency", for this
        paymentTokenInfo: paymentTokenInfo,
        minter: <- create DummyMinter(),
        editDelay: 0.0,
        initialSigners: [self.owner!.address],
        initialThreshold: 1,
        minting: false,
        initialTreasurySupply: 0.0,
        extra: extra
      )
      self.projects[projectId] <-! project

      // payment
      let emeraldCityTreasury: &{FungibleToken.Receiver} = getAccount(0x5643fd47a29770e7).getCapability(/public/flowTokenReceiver)
                              .borrow<&{FungibleToken.Receiver}>()!
      emeraldCityTreasury.deposit(from: <- payment)

      emit ProjectCreated(
        projectId: projectId,
        tokenTypeIdentifier: nil,
        by: self.owner!.address
      )
    }

    pub fun createProject(
      projectTokenInfo: ToucansTokens.TokenInfo,
      paymentTokenInfo: ToucansTokens.TokenInfo,
      minter: @{Minter},
      editDelay: UFix64,
      minting: Bool,
      initialTreasurySupply: UFix64,
      extra: {String: AnyStruct}
    ) {
      let projectId: String = projectTokenInfo.contractName
      let project: @Project <- create Project(
        projectId: projectId,
        projectTokenInfo: projectTokenInfo,
        paymentTokenInfo: paymentTokenInfo,
        minter: <- minter,
        editDelay: editDelay,
        initialSigners: [self.owner!.address],
        initialThreshold: 1,
        minting: minting,
        initialTreasurySupply: initialTreasurySupply,
        extra: extra
      )
      self.projects[projectId] <-! project

      emit ProjectCreated(
        projectId: projectId,
        tokenTypeIdentifier: projectTokenInfo.tokenType.identifier,
        by: self.owner!.address
      )
    }

    pub fun borrowProject(projectId: String): &Project? {
      return &self.projects[projectId] as &Project?
    }

    pub fun getProjectIds(): [String] {
      return self.projects.keys
    }

    pub fun borrowProjectPublic(projectId: String): &Project{ProjectPublic}? {
      return &self.projects[projectId] as &Project{ProjectPublic}?
    }

    // use this function to vote on other projects proposals
    pub fun voteOnProjectAction(projectOwner: Address, projectId: String, actionUUID: UInt64, vote: Bool) {
      let collection: &Collection{CollectionPublic} = getAccount(projectOwner).getCapability(Toucans.CollectionPublicPath)
                    .borrow<&Toucans.Collection{Toucans.CollectionPublic}>()
                    ?? panic("A DAOTreasury doesn't exist here.")
      let project: &Project{ProjectPublic} = collection.borrowProjectPublic(projectId: projectId) ?? panic("Project does not exist.")
      let manager: &Manager{ManagerPublic} = project.borrowManagerPublic()
      let action: &MultiSignAction = manager.borrowAction(actionUUID: actionUUID)
      action.vote(acctAddress: self.owner!.address, vote: vote)

      if manager.readyToFinalize(actionUUID: actionUUID) {
        project.finalizeAction(actionUUID: actionUUID)
      }
    }

    init() {
      self.projects <- {}
    }

    destroy() {
      destroy self.projects
    }
  }


  //   __  __
  //  |  \/  |
  //  | \  / | __ _ _ __   __ _  __ _  ___ _ __
  //  | |\/| |/ _` | '_ \ / _` |/ _` |/ _ \ '__|
  //  | |  | | (_| | | | | (_| | (_| |  __/ |
  //  |_|  |_|\__,_|_| |_|\__,_|\__, |\___|_|
  //                             __/ |
  //                            |___/


  pub enum ActionState: UInt8 {
    pub case ACCEPTED
    pub case DECLINED
    pub case PENDING
  }

  pub resource MultiSignAction {
      pub let action: {ToucansActions.Action}
      access(self) let signers: [Address]
      access(self) let votes: {Address: Bool}
      pub let threshold: UInt64

      access(contract) fun vote(acctAddress: Address, vote: Bool) {
        pre {
          self.signers.contains(acctAddress): "This person cannot vote."
        }
        self.votes[acctAddress] = vote
      }

      pub fun getSigners(): [Address] {
          return self.signers
      }

      // Only returns people who have actually voted
      pub fun getVotes(): {Address: Bool} {
        return self.votes
      }

      pub fun getAccepted(): UInt64 {
        var count: UInt64 = 0
        for voter in self.votes.keys {
            if self.votes[voter]! {
                count = count + 1
            }
        }
        return count
      }

      pub fun getDeclined(): UInt64 {
        var count: UInt64 = 0
        for voter in self.votes.keys {
            if !self.votes[voter]! {
                count = count + 1
            }
        }
        return count
      }

      pub fun getActionState(): ActionState {
        // If this action is to add a signer,
        // and the person being added declined it,
        // it is automatically declined.
        if self.action.getType() == Type<ToucansActions.AddOneSigner>() {
          let addSignerAction: ToucansActions.AddOneSigner = self.action as! ToucansActions.AddOneSigner
          if self.votes[addSignerAction.signer] == false {
            return ActionState.DECLINED
          }
        }

        if self.getAccepted() >= self.threshold {
          return ActionState.ACCEPTED
        }
        if self.getDeclined() > UInt64(self.getSigners().length) - self.threshold {
          return ActionState.DECLINED
        }

        return ActionState.PENDING
      }

      init(_threshold: UInt64, _signers: [Address], _action: {ToucansActions.Action}) {
        self.threshold = _threshold
        self.signers = _signers
        self.votes = {}
        self.action = _action
      }
  }

  pub resource interface ManagerPublic {
      pub var threshold: UInt64
      pub fun borrowAction(actionUUID: UInt64): &MultiSignAction
      pub fun getActionState(actionUUID: UInt64): ActionState
      pub fun readyToFinalize(actionUUID: UInt64): Bool
      pub fun getIDs(): [UInt64]
      pub fun getSigners(): [Address]
  }

  pub resource Manager: ManagerPublic {
    pub var threshold: UInt64
    access(self) let signers: [Address]
    // Maps the `uuid` of the MultiSignAction
    // to the resource itself
    access(self) let actions: @{UInt64: MultiSignAction}

    access(account) fun createMultiSign(action: {ToucansActions.Action}) {
      var threshold: UInt64 = self.threshold
      var signers: [Address] = self.signers
      if action.getType() == Type<ToucansActions.AddOneSigner>() {
        let addSignerAction = action as! ToucansActions.AddOneSigner
        threshold = threshold + 1
        signers.append(addSignerAction.signer)
      }
      // ADD THIS BACK IF IT MAKES SENSE
      // if action.getType() == Type<ToucansActions.RemoveOneSigner>() {
      //   let removeSignerAction = action as! ToucansActions.RemoveOneSigner
      //   threshold = threshold - 1
      //   signers.remove(at: signers.firstIndex(of: removeSignerAction.signer)!)
      // }
      let newAction <- create MultiSignAction(_threshold: threshold, _signers: signers, _action: action)
      self.actions[newAction.uuid] <-! newAction
    }

    pub fun getActionState(actionUUID: UInt64): ActionState {
      let actionRef: &MultiSignAction = (&self.actions[actionUUID] as &MultiSignAction?)!
      return actionRef.getActionState()
    }

    pub fun readyToFinalize(actionUUID: UInt64): Bool {
      let actionState: ActionState = self.getActionState(actionUUID: actionUUID)
      return actionState != ActionState.PENDING
    }

    // We do not make this public because if anyone else wants to use
    // this contract, they may want specific access control over who can
    // actually execute an action, post conditions, and/or implement requirements
    // (like the treasury must have >= 10 $FLOW before an action can be executed).
    access(account) fun destroyAction(actionUUID: UInt64) {
      destroy self.actions.remove(key: actionUUID) ?? panic("This action does not exist.")
      self.assertValidTreasury()
    }

    // These will be multisign actions themselves
    access(account) fun addSigner(signer: Address) {
      pre {
        !self.signers.contains(signer): "This wallet is already a signer."
      }
      self.signers.append(signer)
      self.assertValidTreasury()
    }

    access(account) fun removeSigner(signer: Address) {
      pre {
        self.signers.contains(signer): "This wallet is not already a signer."
      }
      self.signers.remove(at: self.signers.firstIndex(of: signer)!)

      if Int(self.threshold) > self.signers.length {
        // Automatically reduce the threshold to prevent it from
        // being higher than the number of signers
        self.threshold = UInt64(self.signers.length)
      }

      self.assertValidTreasury()
    }

    access(account) fun updateThreshold(newThreshold: UInt64) {
      self.threshold = newThreshold
      self.assertValidTreasury()
    }

    pub fun borrowAction(actionUUID: UInt64): &MultiSignAction {
      return (&self.actions[actionUUID] as &MultiSignAction?)!
    }

    pub fun getIDs(): [UInt64] {
      return self.actions.keys
    }

    pub fun getSigners(): [Address] {
      return self.signers
    }

    pub fun assertValidTreasury() {
      assert(self.threshold > 0, message: "Threshold must be greater than 0.")
      assert(self.signers.length > 0, message: "Number of signers must be greater than 0.")
      assert(self.signers.length >= Int(self.threshold), message: "Number of signers must be greater than or equal to the threshold.")
    }

    init(_initialSigners: [Address], _initialThreshold: UInt64) {
      self.signers = _initialSigners
      self.actions <- {}
      self.threshold = _initialThreshold
      self.assertValidTreasury()
    }

    destroy() {
      destroy self.actions
    }
  }

  pub fun createMultiSigManager(signers: [Address], threshold: UInt64): @Manager {
      return <- create Manager(_initialSigners: signers, _initialThreshold: threshold)
  }

  pub fun createCollection(): @Collection {
    return <- create Collection()
  }

  pub fun assertNonConflictingCycles(earlierCycle: FundingCycleDetails, laterCycle: FundingCycleDetails) {
    let earlierCycleStartsEarlier = earlierCycle.timeframe.startTime < laterCycle.timeframe.startTime
    let earlierCycleEndsBeforeLaterStarts = earlierCycle.timeframe.endTime == nil || (earlierCycle.timeframe.endTime! < laterCycle.timeframe.startTime)
    assert(earlierCycleStartsEarlier && earlierCycleEndsBeforeLaterStarts, message: "Conflicting cycles!")
  }

  init() {
    self.CollectionStoragePath = /storage/ToucansCollection
    self.CollectionPublicPath = /public/ToucansCollection
  }

}
 "
-------
"// CREATED BY: Touchstone (https://touchstone.city/), a platform crafted by your best friends at Emerald City DAO (https://ecdao.org/).
// STATEMENT: This contract promises to keep the 5% royalty off of primary sales and 2.5% off of secondary sales to Emerald City DAO or risk permanent suspension from participation in the DAO and its tools.

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import FlowToken from 0x1654653399040a61
import MintVerifiers from 0x7a696d6136e1dce2
import FUSD from 0x3c5959b568896393
import EmeraldPass from 0x6a07dbeb03167a13

pub contract TouchstoneDigiQuacks: NonFungibleToken {

	// Collection Information
	access(self) let collectionInfo: {String: AnyStruct}

	// Contract Information
	pub var nextEditionId: UInt64
	pub var nextMetadataId: UInt64
	pub var totalSupply: UInt64

	// Events
	pub event ContractInitialized()
	pub event Withdraw(id: UInt64, from: Address?)
	pub event Deposit(id: UInt64, to: Address?)
	pub event TouchstonePurchase(id: UInt64, recipient: Address, metadataId: UInt64, name: String, description: String, image: MetadataViews.IPFSFile, price: UFix64)
	pub event Minted(id: UInt64, recipient: Address, metadataId: UInt64)
	pub event MintBatch(metadataIds: [UInt64], recipients: [Address])

	// Paths
	pub let CollectionStoragePath: StoragePath
	pub let CollectionPublicPath: PublicPath
	pub let CollectionPrivatePath: PrivatePath
	pub let AdministratorStoragePath: StoragePath

	// Maps metadataId of NFT to NFTMetadata
	access(account) let metadatas: {UInt64: NFTMetadata}

	// Maps the metadataId of an NFT to the primary buyer
	access(account) let primaryBuyers: {Address: {UInt64: [UInt64]}}

	access(account) let nftStorage: @{Address: {UInt64: NFT}}

	pub struct NFTMetadata {
		pub let metadataId: UInt64
		pub let name: String
		pub let description: String
		// The main image of the NFT
		pub let image: MetadataViews.IPFSFile
		// An optional thumbnail that can go along with it
		// for easier loading
		pub let thumbnail: MetadataViews.IPFSFile?
		// If price is nil, defaults to the collection price
		pub let price: UFix64?
		pub var extra: {String: AnyStruct}
		pub let supply: UInt64
		pub let purchasers: {UInt64: Address}

		access(account) fun purchased(serial: UInt64, buyer: Address) {
			self.purchasers[serial] = buyer
		}

		init(_name: String, _description: String, _image: MetadataViews.IPFSFile, _thumbnail: MetadataViews.IPFSFile?, _price: UFix64?, _extra: {String: AnyStruct}, _supply: UInt64) {
			self.metadataId = TouchstoneDigiQuacks.nextMetadataId
			self.name = _name
			self.description = _description
			self.image = _image
			self.thumbnail = _thumbnail
			self.price = _price
			self.extra = _extra
			self.supply = _supply
			self.purchasers = {}
		}
	}

	pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
		// The 'id' is the same as the 'uuid'
		pub let id: UInt64
		// The 'metadataId' is what maps this NFT to its 'NFTMetadata'
		pub let metadataId: UInt64
		pub let serial: UInt64

		pub fun getMetadata(): NFTMetadata {
			return TouchstoneDigiQuacks.getNFTMetadata(self.metadataId)!
		}

		pub fun getViews(): [Type] {
			return [
				Type<MetadataViews.Display>(),
				Type<MetadataViews.ExternalURL>(),
				Type<MetadataViews.NFTCollectionData>(),
				Type<MetadataViews.NFTCollectionDisplay>(),
				Type<MetadataViews.Royalties>(),
				Type<MetadataViews.Serial>(),
				Type<MetadataViews.Traits>(),
				Type<MetadataViews.NFTView>()
			]
		}

		pub fun resolveView(_ view: Type): AnyStruct? {
			switch view {
				case Type<MetadataViews.Display>():
					let metadata = self.getMetadata()
					return MetadataViews.Display(
						name: metadata.name,
						description: metadata.description,
						thumbnail: metadata.thumbnail ?? metadata.image
					)
				case Type<MetadataViews.NFTCollectionData>():
					return MetadataViews.NFTCollectionData(
						storagePath: TouchstoneDigiQuacks.CollectionStoragePath,
						publicPath: TouchstoneDigiQuacks.CollectionPublicPath,
						providerPath: TouchstoneDigiQuacks.CollectionPrivatePath,
						publicCollection: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
						publicLinkedType: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
						providerLinkedType: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, NonFungibleToken.Provider}>(),
						createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
								return <- TouchstoneDigiQuacks.createEmptyCollection()
						})
					)
				case Type<MetadataViews.ExternalURL>():
          return MetadataViews.ExternalURL("https://touchstone.city/discover/".concat(self.owner!.address.toString()).concat("/TouchstoneDigiQuacks"))
				case Type<MetadataViews.NFTCollectionDisplay>():
					let squareMedia = MetadataViews.Media(
						file: TouchstoneDigiQuacks.getCollectionAttribute(key: "image") as! MetadataViews.IPFSFile,
						mediaType: "image"
					)

					// If a banner image exists, use it
					// Otherwise, default to the main square image
					var bannerMedia: MetadataViews.Media? = nil
					if let bannerImage = TouchstoneDigiQuacks.getOptionalCollectionAttribute(key: "bannerImage") as! MetadataViews.IPFSFile? {
						bannerMedia = MetadataViews.Media(
							file: bannerImage,
							mediaType: "image"
						)
					}
					return MetadataViews.NFTCollectionDisplay(
						name: TouchstoneDigiQuacks.getCollectionAttribute(key: "name") as! String,
						description: TouchstoneDigiQuacks.getCollectionAttribute(key: "description") as! String,
						externalURL: MetadataViews.ExternalURL("https://touchstone.city/discover/".concat(self.owner!.address.toString()).concat("/TouchstoneDigiQuacks")),
						squareImage: squareMedia,
						bannerImage: bannerMedia ?? squareMedia,
						socials: TouchstoneDigiQuacks.getCollectionAttribute(key: "socials") as! {String: MetadataViews.ExternalURL}
					)
				case Type<MetadataViews.Royalties>():
					return MetadataViews.Royalties([
						// This is for Emerald City in favor of producing Touchstone, a free platform for our users. Failure to keep this in the contract may result in permanent suspension from Emerald City.
						MetadataViews.Royalty(
							recepient: getAccount(0x5643fd47a29770e7).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),
							cut: 0.025, // 2.5% royalty on secondary sales
							description: "Emerald City DAO receives a 2.5% royalty from secondary sales because this collection was created using Touchstone (https://touchstone.city/), a tool for creating your own NFT collections, crafted by Emerald City DAO."
						)
					])
				case Type<MetadataViews.Serial>():
					return MetadataViews.Serial(
						self.serial
					)
				case Type<MetadataViews.Traits>():
					return MetadataViews.dictToTraits(dict: self.getMetadata().extra, excludedNames: nil)
				case Type<MetadataViews.NFTView>():
					return MetadataViews.NFTView(
						id: self.id,
						uuid: self.uuid,
						display: self.resolveView(Type<MetadataViews.Display>()) as! MetadataViews.Display?,
						externalURL: self.resolveView(Type<MetadataViews.ExternalURL>()) as! MetadataViews.ExternalURL?,
						collectionData: self.resolveView(Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?,
						collectionDisplay: self.resolveView(Type<MetadataViews.NFTCollectionDisplay>()) as! MetadataViews.NFTCollectionDisplay?,
						royalties: self.resolveView(Type<MetadataViews.Royalties>()) as! MetadataViews.Royalties?,
						traits: self.resolveView(Type<MetadataViews.Traits>()) as! MetadataViews.Traits?
					)
			}
			return nil
		}

		init(_metadataId: UInt64, _serial: UInt64, _recipient: Address) {
			pre {
				TouchstoneDigiQuacks.metadatas[_metadataId] != nil:
					"This NFT does not exist yet."
				_serial < TouchstoneDigiQuacks.getNFTMetadata(_metadataId)!.supply:
					"This serial does not exist for this metadataId."
				!TouchstoneDigiQuacks.getNFTMetadata(_metadataId)!.purchasers.containsKey(_serial):
					"This serial has already been purchased."
			}
			self.id = self.uuid
			self.metadataId = _metadataId
			self.serial = _serial

			// Update the buyers list so we keep track of who is purchasing
			if let buyersRef = &TouchstoneDigiQuacks.primaryBuyers[_recipient] as &{UInt64: [UInt64]}? {
				if let metadataIdMap = &buyersRef[_metadataId] as &[UInt64]? {
					metadataIdMap.append(_serial)
				} else {
					buyersRef[_metadataId] = [_serial]
				}
			} else {
				TouchstoneDigiQuacks.primaryBuyers[_recipient] = {_metadataId: [_serial]}
			}

			// Update who bought this serial inside NFTMetadata so it cannot be purchased again.
			let metadataRef = (&TouchstoneDigiQuacks.metadatas[_metadataId] as &NFTMetadata?)!
			metadataRef.purchased(serial: _serial, buyer: _recipient)

			TouchstoneDigiQuacks.totalSupply = TouchstoneDigiQuacks.totalSupply + 1
			emit Minted(id: self.id, recipient: _recipient, metadataId: _metadataId)
		}
	}

	pub resource Collection: NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
		// dictionary of NFT conforming tokens
		// NFT is a resource type with an 'UInt64' ID field
		pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

		// withdraw removes an NFT from the collection and moves it to the caller
		pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
			let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

			emit Withdraw(id: token.id, from: self.owner?.address)

			return <-token
		}

		// deposit takes a NFT and adds it to the collections dictionary
		// and adds the ID to the id array
		pub fun deposit(token: @NonFungibleToken.NFT) {
			let token <- token as! @NFT

			let id: UInt64 = token.id

			// add the new token to the dictionary
			self.ownedNFTs[id] <-! token

			emit Deposit(id: id, to: self.owner?.address)
		}

		// getIDs returns an array of the IDs that are in the collection
		pub fun getIDs(): [UInt64] {
			return self.ownedNFTs.keys
		}

		// borrowNFT gets a reference to an NFT in the collection
		// so that the caller can read its metadata and call its methods
		pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
			return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
		}

		pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
			let token = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
			let nft = token as! &NFT
			return nft as &AnyResource{MetadataViews.Resolver}
		}

		pub fun claim() {
			if let storage = &TouchstoneDigiQuacks.nftStorage[self.owner!.address] as &{UInt64: NFT}? {
				for id in storage.keys {
					self.deposit(token: <- storage.remove(key: id)!)
				}
			}
		}

		init () {
			self.ownedNFTs <- {}
		}

		destroy() {
			destroy self.ownedNFTs
		}
	}

	// A function to mint NFTs.
	// You can only call this function if minting
	// is currently active.
	pub fun mintNFT(metadataId: UInt64, recipient: &{NonFungibleToken.Receiver}, payment: @FlowToken.Vault, serial: UInt64): UInt64 {
		pre {
			self.canMint(): "Minting is currently closed by the Administrator!"
			payment.balance == self.getPriceOfNFT(metadataId):
				"Payment does not match the price. You passed in ".concat(payment.balance.toString()).concat(" but this NFT costs ").concat(self.getPriceOfNFT(metadataId)!.toString())
		}
		let price: UFix64 = self.getPriceOfNFT(metadataId)!

		// Confirm recipient passes all verifiers
		for verifier in self.getMintVerifiers() {
			let params = {"minter": recipient.owner!.address}
			if let error = verifier.verify(params) {
				panic(error)
			}
		}

		// Handle Emerald City DAO royalty (5%)
		let EmeraldCityTreasury = getAccount(0x5643fd47a29770e7).getCapability(/public/flowTokenReceiver)
								.borrow<&FlowToken.Vault{FungibleToken.Receiver}>()!
		let emeraldCityCut: UFix64 = 0.05 * price

		// Handle royalty to user that was configured upon creation
		if let royalty = TouchstoneDigiQuacks.getOptionalCollectionAttribute(key: "royalty") as! MetadataViews.Royalty? {
			royalty.receiver.borrow()!.deposit(from: <- payment.withdraw(amount: price * royalty.cut))
		}

		EmeraldCityTreasury.deposit(from: <- payment.withdraw(amount: emeraldCityCut))

		// Give the rest to the collection owner
		let paymentRecipient = self.account.getCapability(/public/flowTokenReceiver)
								.borrow<&FlowToken.Vault{FungibleToken.Receiver}>()!
		paymentRecipient.deposit(from: <- payment)

		// Mint the nft
		let nft <- create NFT(_metadataId: metadataId, _serial: serial, _recipient: recipient.owner!.address)
		let nftId: UInt64 = nft.id
		let metadata = self.getNFTMetadata(metadataId)!
		self.collectionInfo["profit"] = (self.getCollectionAttribute(key: "profit") as! UFix64) + price

		// Emit event
		emit TouchstonePurchase(id: nftId, recipient: recipient.owner!.address, metadataId: metadataId, name: metadata.name, description: metadata.description, image: metadata.image, price: price)

		// Deposit nft
		recipient.deposit(token: <- nft)

		return nftId
	}

	pub resource Administrator {
		pub fun createNFTMetadata(name: String, description: String, imagePath: String, thumbnailPath: String?, ipfsCID: String, price: UFix64?, extra: {String: AnyStruct}, supply: UInt64) {
			TouchstoneDigiQuacks.metadatas[TouchstoneDigiQuacks.nextMetadataId] = NFTMetadata(
				_name: name,
				_description: description,
				_image: MetadataViews.IPFSFile(
					cid: ipfsCID,
					path: imagePath
				),
				_thumbnail: thumbnailPath == nil ? nil : MetadataViews.IPFSFile(cid: ipfsCID, path: thumbnailPath),
				_price: price,
				_extra: extra,
				_supply: supply
			)
			TouchstoneDigiQuacks.nextMetadataId = TouchstoneDigiQuacks.nextMetadataId + 1
		}

		// mintNFT mints a new NFT and deposits
		// it in the recipients collection
		pub fun mintNFT(metadataId: UInt64, serial: UInt64, recipient: Address) {
			pre {
				EmeraldPass.isActive(user: TouchstoneDigiQuacks.account.address): "You must have an active Emerald Pass subscription to airdrop NFTs. You can purchase Emerald Pass at https://pass.ecdao.org/"
			}
			let nft <- create NFT(_metadataId: metadataId, _serial: serial, _recipient: recipient)
			if let recipientCollection = getAccount(recipient).getCapability(TouchstoneDigiQuacks.CollectionPublicPath).borrow<&TouchstoneDigiQuacks.Collection{NonFungibleToken.CollectionPublic}>() {
				recipientCollection.deposit(token: <- nft)
			} else {
				if let storage = &TouchstoneDigiQuacks.nftStorage[recipient] as &{UInt64: NFT}? {
					storage[nft.id] <-! nft
				} else {
					TouchstoneDigiQuacks.nftStorage[recipient] <-! {nft.id: <- nft}
				}
			}
		}

		pub fun mintBatch(metadataIds: [UInt64], serials: [UInt64], recipients: [Address]) {
			pre {
				metadataIds.length == recipients.length: "You need to pass in an equal number of metadataIds and recipients."
			}
			var i = 0
			while i < metadataIds.length {
				self.mintNFT(metadataId: metadataIds[i], serial: serials[i], recipient: recipients[i])
				i = i + 1
			}

			emit MintBatch(metadataIds: metadataIds, recipients: recipients)
		}

		// create a new Administrator resource
		pub fun createAdmin(): @Administrator {
			return <- create Administrator()
		}

		// change piece of collection info
		pub fun changeField(key: String, value: AnyStruct) {
			TouchstoneDigiQuacks.collectionInfo[key] = value
		}
	}

	// public function that anyone can call to create a new empty collection
	pub fun createEmptyCollection(): @NonFungibleToken.Collection {
		return <- create Collection()
	}

	// Get information about a NFTMetadata
	pub fun getNFTMetadata(_ metadataId: UInt64): NFTMetadata? {
		return self.metadatas[metadataId]
	}

	pub fun getNFTMetadatas(): {UInt64: NFTMetadata} {
		return self.metadatas
	}

	pub fun getPrimaryBuyers(): {Address: {UInt64: [UInt64]}} {
		return self.primaryBuyers
	}

	pub fun getCollectionInfo(): {String: AnyStruct} {
		let collectionInfo = self.collectionInfo
		collectionInfo["metadatas"] = self.metadatas
		collectionInfo["primaryBuyers"] = self.primaryBuyers
		collectionInfo["totalSupply"] = self.totalSupply
		collectionInfo["nextMetadataId"] = self.nextMetadataId
		collectionInfo["version"] = 1
		return collectionInfo
	}

	pub fun getCollectionAttribute(key: String): AnyStruct {
		return self.collectionInfo[key] ?? panic(key.concat(" is not an attribute in this collection."))
	}

	pub fun getOptionalCollectionAttribute(key: String): AnyStruct? {
		return self.collectionInfo[key]
	}

	pub fun getMintVerifiers(): [{MintVerifiers.IVerifier}] {
		return self.getCollectionAttribute(key: "mintVerifiers") as! [{MintVerifiers.IVerifier}]
	}

	pub fun canMint(): Bool {
		return self.getCollectionAttribute(key: "minting") as! Bool
	}

	// Returns nil if an NFT with this metadataId doesn't exist
	pub fun getPriceOfNFT(_ metadataId: UInt64): UFix64? {
		if let metadata: TouchstoneDigiQuacks.NFTMetadata = self.getNFTMetadata(metadataId) {
			let defaultPrice: UFix64 = self.getCollectionAttribute(key: "price") as! UFix64
			if self.getCollectionAttribute(key: "lotteryBuying") as! Bool {
				return defaultPrice
			}
			return metadata.price ?? defaultPrice
		}
		// If the metadataId doesn't exist
		return nil
	}

	// Returns an mapping of `id` to NFTMetadata
	// for the NFTs a user can claim
	pub fun getClaimableNFTs(user: Address): {UInt64: NFTMetadata} {
		let answer: {UInt64: NFTMetadata} = {}
		if let storage = &TouchstoneDigiQuacks.nftStorage[user] as &{UInt64: NFT}? {
			for id in storage.keys {
				let nftRef = (&storage[id] as &NFT?)!
				answer[id] = self.getNFTMetadata(nftRef.metadataId)
			}
		}
		return answer
	}

	init(
		_name: String,
		_description: String,
		_imagePath: String,
		_bannerImagePath: String?,
		_minting: Bool,
		_royalty: MetadataViews.Royalty?,
		_defaultPrice: UFix64,
		_paymentType: String,
		_ipfsCID: String,
		_lotteryBuying: Bool,
		_socials: {String: MetadataViews.ExternalURL},
		_mintVerifiers: [{MintVerifiers.IVerifier}]
	) {
		// Collection Info
		self.collectionInfo = {}
		self.collectionInfo["name"] = _name
		self.collectionInfo["description"] = _description
		self.collectionInfo["image"] = MetadataViews.IPFSFile(
			cid: _ipfsCID,
			path: _imagePath
		)
		if let bannerImagePath = _bannerImagePath {
			self.collectionInfo["bannerImage"] = MetadataViews.IPFSFile(
				cid: _ipfsCID,
				path: _bannerImagePath
			)
		}
		self.collectionInfo["ipfsCID"] = _ipfsCID
		self.collectionInfo["socials"] = _socials
		self.collectionInfo["minting"] = _minting
		self.collectionInfo["lotteryBuying"] = _lotteryBuying
		if let royalty = _royalty {
			assert(royalty.receiver.check(), message: "The passed in royalty receiver is not valid. The royalty account must set up the intended payment token.")
			assert(royalty.cut <= 0.95, message: "The royalty cut cannot be bigger than 95% because 5% goes to Emerald City treasury for primary sales.")
			self.collectionInfo["royalty"] = royalty
		}
		self.collectionInfo["price"] = _defaultPrice
		self.collectionInfo["paymentType"] = _paymentType
		self.collectionInfo["dateCreated"] = getCurrentBlock().timestamp
		self.collectionInfo["mintVerifiers"] = _mintVerifiers
		self.collectionInfo["profit"] = 0.0

		self.nextEditionId = 0
		self.nextMetadataId = 0
		self.totalSupply = 0
		self.metadatas = {}
		self.primaryBuyers = {}
		self.nftStorage <- {}

		// Set the named paths
		// We include the user's address in the paths.
		// This is to prevent clashing with existing
		// Collection paths in the ecosystem.
		self.CollectionStoragePath = /storage/TouchstoneDigiQuacksCollection_0x213c401adf5c8854
		self.CollectionPublicPath = /public/TouchstoneDigiQuacksCollection_0x213c401adf5c8854
		self.CollectionPrivatePath = /private/TouchstoneDigiQuacksCollection_0x213c401adf5c8854
		self.AdministratorStoragePath = /storage/TouchstoneDigiQuacksAdministrator_0x213c401adf5c8854

		// Create a Collection resource and save it to storage
		let collection <- create Collection()
		self.account.save(<- collection, to: self.CollectionStoragePath)

		// create a public capability for the collection
		self.account.link<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(
			self.CollectionPublicPath,
			target: self.CollectionStoragePath
		)

		// Create a Administrator resource and save it to storage
		let administrator <- create Administrator()
		self.account.save(<- administrator, to: self.AdministratorStoragePath)

		emit ContractInitialized()
	}
}
 "
-------
"import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448

pub contract Swap {

    // Swap fee: 2.5%
    pub fun Fee(): UFix64 {
        return 0.025
    }

    // Swap fee receiver address
    pub fun FeeAddress(): Address {
        return 0x3896d4b8f0636f6d
    }

    // An order has been created
    pub event OrderCreated(
        orderID: UInt64,
        address: Address,
        nftType: Type,
        nftUUID: UInt64,
        nftID: UInt64,
        currency: Type,
        price: UFix64,
        expiry: UInt64
    )

    // An order has been canceled
    pub event OrderCanceled(
        orderID: UInt64,
        nftType: Type,
        nftUUID: UInt64,
        nftID: UInt64,
        currency: Type,
        price: UFix64,
        expiry: UInt64
    )

    // An order has been filled
    pub event OrderFilled(
        orderID: UInt64,
        nftType: Type,
        nftUUID: UInt64,
        nftID: UInt64,
        currency: Type,
        price: UFix64,
        expiry: UInt64
    )

    // The storage location of the Swap resource
    pub let SwapStoragePath: StoragePath

    // The public location of the Swap link
    pub let SwapPublicPath: PublicPath

    // A struct representing a payment that must be sent when an order is executed
    pub struct Payment {
        // The receiver for the payment of a sell order
        pub let receiver: Capability<&{FungibleToken.Receiver}>

        // The amount of the FungibleToken that will be paid
        pub let amount: UFix64

        init(receiver: Capability<&{FungibleToken.Receiver}>, amount: UFix64) {
            self.receiver = receiver
            self.amount = amount
        }
    }

    // A struct containing an order's data
    pub struct OrderDetails {
        // Whether this order has been filled or not
        pub var filled: Bool
        // The Type of the NonFungibleToken.NFT
        pub let nftType: Type
        // The Resource ID of the NFT
        pub let nftUUID: UInt64
        // The unique identifier of the NFT in the contract
        pub let nftID: UInt64
        // The Type of the FungibleToken that payments must be made in
        pub let currency: Type
        // The amount that must be paid in the specified FungibleToken
        pub let price: UFix64
        // This specifies the division of payment between recipients
        pub let payments: [Payment]
        // This specifies the division of royalties between recipients
        pub let royalties: [Payment]
        // This specifies the division of fees between recipients
        pub let fees: [Payment]
        // Time when order expires
        pub let expiry: UInt64

        // Set an order to filled so it can't be executed again
        access(contract) fun setToFilled() {
            self.filled = true
        }

        init (
            nftType: Type,
            nftUUID: UInt64,
            nftID: UInt64,
            currency: Type,
            payments: [Payment],
            royalties: [Payment],
            fees: [Payment],
            expiry: UInt64
        ) {

            pre {
                // Validate the UUID and ID when sell order
                nftUUID != nil && nftID != nil: "sell orders require the UUID and ID of the NFT"

                // Validate the expiry timestamp
                expiry > UInt64(getCurrentBlock().timestamp) : "expiry should be in the future"

                // Validate the existance of at least one payment recipient when sell order
                payments.length > 0: "sell orders must have at least one payment recipient"
            }

            self.filled = false
            self.nftType = nftType
            self.nftUUID = nftUUID
            self.nftID = nftID
            self.currency = currency
            self.payments = payments
            self.royalties = royalties
            self.fees = fees
            self.expiry = expiry

            var price = 0.0
            for payment in self.payments {
                payment.receiver.borrow() ?? panic("cannot borrow payment receiver")
                price = price + payment.amount
            }
            assert(price > 0.0, message: "item price must not be 0")
            let priceBeforeFees = price

            var totalFeeAmount = 0.0
            for fee in self.fees {
                totalFeeAmount = totalFeeAmount + fee.amount
                price = price + fee.amount
            }

            // Add the royalties
            var totalRoyalties = 0.0
            for royalty in self.royalties {
                royalty.receiver.borrow() ?? panic("cannot borrow royalty receiver")
                price = price + royalty.amount
                totalRoyalties = totalRoyalties + royalty.amount
            }

            assert(totalFeeAmount/(priceBeforeFees+totalFeeAmount+totalRoyalties) >= Swap.Fee(), message: "fee is lower than required fee")
            assert(totalRoyalties/(priceBeforeFees+totalFeeAmount+totalRoyalties) <= 0.1, message: "royalties are over 10%")

            self.price = price
        }
    }

    // An interface providing a public interface to an Order.
    pub resource interface OrderPublic {

        pub fun borrowNFT(): &NonFungibleToken.NFT?

        // Get the token in exchange of the currency vault
        pub fun fill(
            payment: @FungibleToken.Vault,
        ): @NonFungibleToken.NFT

        // Get the details of an Order
        pub fun getDetails(): OrderDetails

        // For a sell Order, checks whether the NFT is present in provided capability
        // `false` means the NFT was transfered out of the account
        pub fun isValid(): Bool
    }

    // A resource that allows an NFT to be sold for an amount of a given FungibleToken,
    // and for the proceeds of that sale to be split between several recipients.
    pub resource Order: OrderPublic {
        // The details of the Order
        access(self) let details: OrderDetails

        // A capability allowing this resource to withdraw any NFT with the given ID from its collection.
        access(contract) let nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>

        // Return the reference of the NFT that is for sale.
        // If the NFT is absent, it will return nil.
        pub fun borrowNFT(): &NonFungibleToken.NFT? {
            // Sell orders require the NFT type and ID
            let ref = self.nftProviderCapability.borrow()!.borrowNFT(id: self.details.nftID)
            if ref.isInstance(self.details.nftType) && ref.id == self.details.nftID {
                return ref as! &NonFungibleToken.NFT
            }
            return nil
        }

        // Get the details of an order.
        pub fun getDetails(): OrderDetails {
            return self.details
        }

        // For a sell Order, checks whether the NFT is present in provided capability
        // `false` means the NFT was transfered out of the account
        pub fun isValid(): Bool {
            if let providerRef = self.nftProviderCapability.borrow() {
                let availableIDs = providerRef.getIDs()
                return availableIDs.contains(self.details.nftID)
            }
            return false
        }

        // Fill the order
        // Send payments and returns the token to the buyer
        pub fun fill(
            payment: @FungibleToken.Vault,
        ): @NonFungibleToken.NFT {

            pre {
                self.details.filled == false: "order has already been filled"
                payment.isInstance(self.details.currency): "payment is not in required currency"
                payment.balance == self.details.price: "payment price is different"
                self.details.expiry > UInt64(getCurrentBlock().timestamp): "order is expired"
                self.owner != nil : "resource doesn't have the assigned owner"
            }

            // Make sure the order cannot be filled again
            self.details.setToFilled()

            // Fetch the token to return to the buyer
            let nft <-self.nftProviderCapability.borrow()!.withdraw(withdrawID: self.details.nftID)

            // Check if the withdrawn NFT has the specified Type and ID
            assert(nft.isInstance(self.details.nftType), message: "withdrawn NFT is not of specified type")
            assert(nft.id == self.details.nftID, message: "withdrawn NFT does not have specified ID")

            // Rather than aborting the transaction if any receiver is absent when we try to pay it,
            // we send the payment to the first valid receiver, which should be the seller.
            var residualReceiver: &{FungibleToken.Receiver}? = nil

            // Pay each beneficiary their amount of the payment
            // Set the first valid receiver as the residual receiver
            for p in self.details.payments {
                if let receiver = p.receiver.borrow() {
                   let vault <- payment.withdraw(amount: p.amount)
                    receiver.deposit(from: <-vault)
                    if (residualReceiver == nil) {
                        residualReceiver = receiver
                    }
                }
            }

            // Pay royalties
            for r in self.details.royalties {
                if let receiver = r.receiver.borrow() {
                   let vault <- payment.withdraw(amount: r.amount)
                    receiver.deposit(from: <-vault)
                }
            }

            // Pay fees to the fee receiver defined in the contract
            let feeAddress = Swap.FeeAddress()
            let feeReceiver = getAccount(feeAddress).getCapability<&AnyResource{FungibleToken.Receiver}>(/public/flowTokenReceiver)
            for f in self.details.fees {
                if let receiver = feeReceiver.borrow() {
                   let vault <- payment.withdraw(amount: f.amount)
                    receiver.deposit(from: <-vault)
                }
            }

            // At least one receiver was valid and paid
            assert(residualReceiver != nil, message: "no valid payment receivers")

            // At this point, if all receivers were valid, then the payment Vault will have
            // zero tokens left, and this will be a no-op that consumes the empty vault
            // otherwise the remaining payment will be deposited to the residual receiver
            residualReceiver!.deposit(from: <-payment)

            emit OrderFilled(
                orderID: self.uuid,
                nftType: self.details.nftType,
                nftUUID: self.details.nftUUID,
                nftID: self.details.nftID,
                currency: self.details.currency,
                price: self.details.price,
                expiry: self.details.expiry
            )

            return <-nft
        }

        destroy () {
            if !self.details.filled {
                emit OrderCanceled(
                    orderID: self.uuid,
                    nftType: self.details.nftType,
                    nftUUID: self.details.nftUUID,
                    nftID: self.details.nftID,
                    currency: self.details.currency,
                    price: self.details.price,
                    expiry: self.details.expiry
                )
            }
        }

        init (
            nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,
            nftType: Type,
            nftUUID: UInt64,
            nftID: UInt64,
            currency: Type,
            payments: [Payment],
            royalties: [Payment],
            fees: [Payment],
            expiry: UInt64
        ) {
            // Store the order instructions
            self.details = OrderDetails(
                nftType: nftType,
                nftUUID: nftUUID,
                nftID: nftID,
                currency: currency,
                payments: payments,
                royalties: royalties,
                fees: fees,
                expiry: expiry
            )

            // Store the NFT provider
            self.nftProviderCapability = nftProviderCapability


            // Check that the provider has the NFT
            let provider = self.nftProviderCapability.borrow()
            assert(provider != nil, message: "cannot borrow nftProviderCapability")

            let nft = provider!.borrowNFT(id: self.details.nftID)
            assert(nft.isInstance(self.details.nftType), message: "token is not of specified type")
            assert(nft.id == self.details.nftID, message: "token does not have specified ID")
        }
    }

    // An interface for adding and removing orders
    pub resource interface PortfolioManager {

        // Allows the portfolio owner to create a sell order
        pub fun createSellOrder(
            nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,
            nftType: Type,
            nftID: UInt64,
            currency: Type,
            payments: [Payment],
            royalties: [Payment],
            fees: [Payment],
            expiry: UInt64
        ): UInt64

        // Allows the portfolio owner to cancel any orders, filled or not
        pub fun cancelOrder(orderID: UInt64)
    }


    // An interface to allow order filling
    pub resource interface PortfolioPublic {
        pub fun getOrderIDs(): [UInt64]
        pub fun getSellOrderIDs(nftType: Type, nftID: UInt64): [UInt64]
        pub fun borrowOrder(orderID: UInt64): &Order{OrderPublic}?
        pub fun clean(orderID: UInt64)
   }

    // A resource that allows its owner to manage a portfolio, and anyone to interact with them
    // in order to query their details and fill the NFTs that they represent.
    pub resource Portfolio : PortfolioManager, PortfolioPublic {
        // The dictionary of orders uuids to order resources.
        access(contract) var orders: @{UInt64: Order}
        // Dictionary to keep track of sell order ids for an NFT
        // nftType.identifier -> nftID -> orderID
        access(contract) var sellOrders: {String: {UInt64 : UInt64}}
        // Create and publish a sell order for an NFT
         pub fun createSellOrder(
            nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,
            nftType: Type,
            nftID: UInt64,
            currency: Type,
            payments: [Payment],
            royalties: [Payment],
            fees: [Payment],
            expiry: UInt64
         ): UInt64 {

            // Check that the seller does indeed hold the NFT
            let collectionRef = nftProviderCapability.borrow()
                ?? panic("Could not borrow reference to collection")
            let nftRef = collectionRef.borrowNFT(id: nftID)

            let uuid = nftRef.uuid
            let order <- create Order(
                nftProviderCapability: nftProviderCapability,
                nftType: nftType,
                nftUUID: uuid,
                nftID: nftID,
                currency: currency,
                payments: payments,
                royalties: royalties,
                fees: fees,
                expiry: expiry
            )

            let orderID = order.uuid
            let price = order.getDetails().price

            // Add the new order to the dictionary.
            let oldOrder <- self.orders[orderID] <- order

            // Note that oldOrder will always be nil, but we have to handle it.
            destroy oldOrder

            // Add the `orderID` in the tracked sell orders and remove any previous sell order for the same nft
            if self.sellOrders.containsKey(nftType.identifier) {
                if self.sellOrders[nftType.identifier]!.containsKey(nftID) {
                    let previousOrderID = self.sellOrders[nftType.identifier]![nftID]!
                    self.cancelOrder(orderID: previousOrderID)
                }
            }
            self.addSellOrder(nftIdentifier: nftType.identifier, nftID: nftID, orderID: orderID)

            emit OrderCreated(
                orderID: orderID,
                address: self.owner?.address!,
                nftType: nftType,
                nftUUID: uuid,
                nftID: nftID,
                currency: currency,
                price: price,
                expiry: expiry
            )

            return orderID
        }

        // Helper function that allows to add a sell order for a given nft in a map
        access(contract) fun addSellOrder(nftIdentifier: String, nftID: UInt64, orderID: UInt64) {
             if !self.sellOrders.containsKey(nftIdentifier) {
                self.sellOrders.insert(key: nftIdentifier, {nftID: orderID})
            } else {
                if !self.sellOrders[nftIdentifier]!.containsKey(nftID) {
                    self.sellOrders[nftIdentifier]!.insert(key: nftID, orderID)
                } else {
                    self.sellOrders[nftIdentifier]!.remove(key: nftID)
                    self.sellOrders[nftIdentifier]!.insert(key: nftID, orderID)
                }
            }
        }

        // Helper function that allows to remove existing sell orders of given nft from a map
        access(contract) fun removeSellOrder(nftIdentifier: String, nftID: UInt64, orderID: UInt64) {
            if self.sellOrders.containsKey(nftIdentifier) {
                if self.sellOrders[nftIdentifier]!.containsKey(nftID) {
                    if self.sellOrders[nftIdentifier]![nftID]! == orderID {
                        self.sellOrders[nftIdentifier]!.remove(key: nftID)
                    }
                }
            }
        }

        // Remove an order that has not yet been filled and destroy it.
        // It can only be executed by the PortfolioManager resource owner.
        pub fun cancelOrder(orderID: UInt64) {
            let order <- self.orders.remove(key: orderID)
                ?? panic("missing Order")

            let details = order.getDetails()
            self.removeSellOrder(nftIdentifier: details.nftType.identifier, nftID: details.nftID, orderID: orderID)

            // This will emit an OrderCanceled event.
            destroy order
        }

        // Returns an array of all the orderIDs that are in the collection
        pub fun getOrderIDs(): [UInt64] {
            return self.orders.keys
        }

        // Returns the sell orderID of the given `nftType` and `nftID`
        pub fun getSellOrderIDs(nftType: Type, nftID: UInt64): [UInt64] {
            if self.sellOrders.containsKey(nftType.identifier) {
                if self.sellOrders[nftType.identifier]!.containsKey(nftID) {
                    return [self.sellOrders[nftType.identifier]![nftID]!]
                }
            }
            return []
        }

        // Allows anyone to clean filled or invalid orders
        pub fun clean(orderID: UInt64) {
            pre {
                self.orders[orderID] != nil: "could not find order with given id"
                (self.borrowOrder(orderID: orderID)!.getDetails().filled == true || self.borrowOrder(orderID: orderID)!.getDetails().expiry <= UInt64(getCurrentBlock().timestamp)): "order not filled or expired"
            }

            let orderRef = self.borrowOrder(orderID: orderID)!
            let details = orderRef.getDetails()

            var shouldClean = false
            if details.expiry <= UInt64(getCurrentBlock().timestamp) {
                // Order is expired and should be cleaned
                shouldClean = true
            } else {
                if details.filled == true {
                    // Order was filled and should be cleaned
                     shouldClean = true
                } else {
                    if !orderRef.isValid() {
                        // Order does not have NFT and should be cleaned
                        shouldClean = true
                    }
                }
            }

            assert(shouldClean, message: "given order is valid")

            let order <- self.orders.remove(key: orderID)!
            self.removeSellOrder(nftIdentifier: details.nftType.identifier, nftID: details.nftID, orderID: orderID)

            destroy order
        }

        // Returns a read-only view of the order
        pub fun borrowOrder(orderID: UInt64): &Order{OrderPublic}? {
             if self.orders[orderID] != nil {
                return &self.orders[orderID] as &Order{OrderPublic}?
            } else {
                return nil
            }
        }

        destroy () {
            destroy self.orders
        }

        init () {
            self.orders <- {}
            self.sellOrders = {}
        }
    }

    // Make creating a Portfolio publicly accessible
    pub fun createPortfolio(): @Portfolio {
        return <-create Portfolio()
    }

    init () {
        self.SwapStoragePath = /storage/Swap
        self.SwapPublicPath = /public/Swap
    }
}
 "
-------
"// CREATED BY: Touchstone (https://touchstone.city/), a platform crafted by your best friends at Emerald City DAO (https://ecdao.org/).
// STATEMENT: This contract promises to keep the 5% royalty off of primary sales and 2.5% off of secondary sales to Emerald City DAO or risk permanent suspension from participation in the DAO and its tools.

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import FlowToken from 0x1654653399040a61
import MintVerifiers from 0x7a696d6136e1dce2
import FUSD from 0x3c5959b568896393
import EmeraldPass from 0x6a07dbeb03167a13

pub contract TouchstoneSatelitte: NonFungibleToken {

	// Collection Information
	access(self) let collectionInfo: {String: AnyStruct}

	// Contract Information
	pub var nextEditionId: UInt64
	pub var nextMetadataId: UInt64
	pub var totalSupply: UInt64

	// Events
	pub event ContractInitialized()
	pub event Withdraw(id: UInt64, from: Address?)
	pub event Deposit(id: UInt64, to: Address?)
	pub event TouchstonePurchase(id: UInt64, recipient: Address, metadataId: UInt64, name: String, description: String, image: MetadataViews.IPFSFile, price: UFix64)
	pub event Minted(id: UInt64, recipient: Address, metadataId: UInt64)
	pub event MintBatch(metadataIds: [UInt64], recipients: [Address])

	// Paths
	pub let CollectionStoragePath: StoragePath
	pub let CollectionPublicPath: PublicPath
	pub let CollectionPrivatePath: PrivatePath
	pub let AdministratorStoragePath: StoragePath

	// Maps metadataId of NFT to NFTMetadata
	access(account) let metadatas: {UInt64: NFTMetadata}

	// Maps the metadataId of an NFT to the primary buyer
	access(account) let primaryBuyers: {Address: {UInt64: [UInt64]}}

	access(account) let nftStorage: @{Address: {UInt64: NFT}}

	pub struct NFTMetadata {
		pub let metadataId: UInt64
		pub let name: String
		pub let description: String
		// The main image of the NFT
		pub let image: MetadataViews.IPFSFile
		// An optional thumbnail that can go along with it
		// for easier loading
		pub let thumbnail: MetadataViews.IPFSFile?
		// If price is nil, defaults to the collection price
		pub let price: UFix64?
		pub var extra: {String: AnyStruct}
		pub let supply: UInt64
		pub let purchasers: {UInt64: Address}

		access(account) fun purchased(serial: UInt64, buyer: Address) {
			self.purchasers[serial] = buyer
		}

		init(_name: String, _description: String, _image: MetadataViews.IPFSFile, _thumbnail: MetadataViews.IPFSFile?, _price: UFix64?, _extra: {String: AnyStruct}, _supply: UInt64) {
			self.metadataId = TouchstoneSatelitte.nextMetadataId
			self.name = _name
			self.description = _description
			self.image = _image
			self.thumbnail = _thumbnail
			self.price = _price
			self.extra = _extra
			self.supply = _supply
			self.purchasers = {}
		}
	}

	pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
		// The 'id' is the same as the 'uuid'
		pub let id: UInt64
		// The 'metadataId' is what maps this NFT to its 'NFTMetadata'
		pub let metadataId: UInt64
		pub let serial: UInt64

		pub fun getMetadata(): NFTMetadata {
			return TouchstoneSatelitte.getNFTMetadata(self.metadataId)!
		}

		pub fun getViews(): [Type] {
			return [
				Type<MetadataViews.Display>(),
				Type<MetadataViews.ExternalURL>(),
				Type<MetadataViews.NFTCollectionData>(),
				Type<MetadataViews.NFTCollectionDisplay>(),
				Type<MetadataViews.Royalties>(),
				Type<MetadataViews.Serial>(),
				Type<MetadataViews.Traits>(),
				Type<MetadataViews.NFTView>()
			]
		}

		pub fun resolveView(_ view: Type): AnyStruct? {
			switch view {
				case Type<MetadataViews.Display>():
					let metadata = self.getMetadata()
					return MetadataViews.Display(
						name: metadata.name,
						description: metadata.description,
						thumbnail: metadata.thumbnail ?? metadata.image
					)
				case Type<MetadataViews.NFTCollectionData>():
					return MetadataViews.NFTCollectionData(
						storagePath: TouchstoneSatelitte.CollectionStoragePath,
						publicPath: TouchstoneSatelitte.CollectionPublicPath,
						providerPath: TouchstoneSatelitte.CollectionPrivatePath,
						publicCollection: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
						publicLinkedType: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
						providerLinkedType: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, NonFungibleToken.Provider}>(),
						createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
								return <- TouchstoneSatelitte.createEmptyCollection()
						})
					)
				case Type<MetadataViews.ExternalURL>():
          return MetadataViews.ExternalURL("https://touchstone.city/discover/".concat(self.owner!.address.toString()).concat("/TouchstoneSatelitte"))
				case Type<MetadataViews.NFTCollectionDisplay>():
					let squareMedia = MetadataViews.Media(
						file: TouchstoneSatelitte.getCollectionAttribute(key: "image") as! MetadataViews.IPFSFile,
						mediaType: "image"
					)

					// If a banner image exists, use it
					// Otherwise, default to the main square image
					var bannerMedia: MetadataViews.Media? = nil
					if let bannerImage = TouchstoneSatelitte.getOptionalCollectionAttribute(key: "bannerImage") as! MetadataViews.IPFSFile? {
						bannerMedia = MetadataViews.Media(
							file: bannerImage,
							mediaType: "image"
						)
					}
					return MetadataViews.NFTCollectionDisplay(
						name: TouchstoneSatelitte.getCollectionAttribute(key: "name") as! String,
						description: TouchstoneSatelitte.getCollectionAttribute(key: "description") as! String,
						externalURL: MetadataViews.ExternalURL("https://touchstone.city/discover/".concat(self.owner!.address.toString()).concat("/TouchstoneSatelitte")),
						squareImage: squareMedia,
						bannerImage: bannerMedia ?? squareMedia,
						socials: TouchstoneSatelitte.getCollectionAttribute(key: "socials") as! {String: MetadataViews.ExternalURL}
					)
				case Type<MetadataViews.Royalties>():
					return MetadataViews.Royalties([
						// This is for Emerald City in favor of producing Touchstone, a free platform for our users. Failure to keep this in the contract may result in permanent suspension from Emerald City.
						MetadataViews.Royalty(
							recepient: getAccount(0x5643fd47a29770e7).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),
							cut: 0.025, // 2.5% royalty on secondary sales
							description: "Emerald City DAO receives a 2.5% royalty from secondary sales because this collection was created using Touchstone (https://touchstone.city/), a tool for creating your own NFT collections, crafted by Emerald City DAO."
						)
					])
				case Type<MetadataViews.Serial>():
					return MetadataViews.Serial(
						self.serial
					)
				case Type<MetadataViews.Traits>():
					return MetadataViews.dictToTraits(dict: self.getMetadata().extra, excludedNames: nil)
				case Type<MetadataViews.NFTView>():
					return MetadataViews.NFTView(
						id: self.id,
						uuid: self.uuid,
						display: self.resolveView(Type<MetadataViews.Display>()) as! MetadataViews.Display?,
						externalURL: self.resolveView(Type<MetadataViews.ExternalURL>()) as! MetadataViews.ExternalURL?,
						collectionData: self.resolveView(Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?,
						collectionDisplay: self.resolveView(Type<MetadataViews.NFTCollectionDisplay>()) as! MetadataViews.NFTCollectionDisplay?,
						royalties: self.resolveView(Type<MetadataViews.Royalties>()) as! MetadataViews.Royalties?,
						traits: self.resolveView(Type<MetadataViews.Traits>()) as! MetadataViews.Traits?
					)
			}
			return nil
		}

		init(_metadataId: UInt64, _serial: UInt64, _recipient: Address) {
			pre {
				TouchstoneSatelitte.metadatas[_metadataId] != nil:
					"This NFT does not exist yet."
				_serial < TouchstoneSatelitte.getNFTMetadata(_metadataId)!.supply:
					"This serial does not exist for this metadataId."
				!TouchstoneSatelitte.getNFTMetadata(_metadataId)!.purchasers.containsKey(_serial):
					"This serial has already been purchased."
			}
			self.id = self.uuid
			self.metadataId = _metadataId
			self.serial = _serial

			// Update the buyers list so we keep track of who is purchasing
			if let buyersRef = &TouchstoneSatelitte.primaryBuyers[_recipient] as &{UInt64: [UInt64]}? {
				if let metadataIdMap = &buyersRef[_metadataId] as &[UInt64]? {
					metadataIdMap.append(_serial)
				} else {
					buyersRef[_metadataId] = [_serial]
				}
			} else {
				TouchstoneSatelitte.primaryBuyers[_recipient] = {_metadataId: [_serial]}
			}

			// Update who bought this serial inside NFTMetadata so it cannot be purchased again.
			let metadataRef = (&TouchstoneSatelitte.metadatas[_metadataId] as &NFTMetadata?)!
			metadataRef.purchased(serial: _serial, buyer: _recipient)

			TouchstoneSatelitte.totalSupply = TouchstoneSatelitte.totalSupply + 1
			emit Minted(id: self.id, recipient: _recipient, metadataId: _metadataId)
		}
	}

	pub resource Collection: NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
		// dictionary of NFT conforming tokens
		// NFT is a resource type with an 'UInt64' ID field
		pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

		// withdraw removes an NFT from the collection and moves it to the caller
		pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
			let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

			emit Withdraw(id: token.id, from: self.owner?.address)

			return <-token
		}

		// deposit takes a NFT and adds it to the collections dictionary
		// and adds the ID to the id array
		pub fun deposit(token: @NonFungibleToken.NFT) {
			let token <- token as! @NFT

			let id: UInt64 = token.id

			// add the new token to the dictionary
			self.ownedNFTs[id] <-! token

			emit Deposit(id: id, to: self.owner?.address)
		}

		// getIDs returns an array of the IDs that are in the collection
		pub fun getIDs(): [UInt64] {
			return self.ownedNFTs.keys
		}

		// borrowNFT gets a reference to an NFT in the collection
		// so that the caller can read its metadata and call its methods
		pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
			return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
		}

		pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
			let token = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
			let nft = token as! &NFT
			return nft as &AnyResource{MetadataViews.Resolver}
		}

		pub fun claim() {
			if let storage = &TouchstoneSatelitte.nftStorage[self.owner!.address] as &{UInt64: NFT}? {
				for id in storage.keys {
					self.deposit(token: <- storage.remove(key: id)!)
				}
			}
		}

		init () {
			self.ownedNFTs <- {}
		}

		destroy() {
			destroy self.ownedNFTs
		}
	}

	// A function to mint NFTs.
	// You can only call this function if minting
	// is currently active.
	pub fun mintNFT(metadataId: UInt64, recipient: &{NonFungibleToken.Receiver}, payment: @FlowToken.Vault, serial: UInt64): UInt64 {
		pre {
			self.canMint(): "Minting is currently closed by the Administrator!"
			payment.balance == self.getPriceOfNFT(metadataId):
				"Payment does not match the price. You passed in ".concat(payment.balance.toString()).concat(" but this NFT costs ").concat(self.getPriceOfNFT(metadataId)!.toString())
		}
		let price: UFix64 = self.getPriceOfNFT(metadataId)!

		// Confirm recipient passes all verifiers
		for verifier in self.getMintVerifiers() {
			let params = {"minter": recipient.owner!.address}
			if let error = verifier.verify(params) {
				panic(error)
			}
		}

		// Handle Emerald City DAO royalty (5%)
		let EmeraldCityTreasury = getAccount(0x5643fd47a29770e7).getCapability(/public/flowTokenReceiver)
								.borrow<&FlowToken.Vault{FungibleToken.Receiver}>()!
		let emeraldCityCut: UFix64 = 0.05 * price

		// Handle royalty to user that was configured upon creation
		if let royalty = TouchstoneSatelitte.getOptionalCollectionAttribute(key: "royalty") as! MetadataViews.Royalty? {
			royalty.receiver.borrow()!.deposit(from: <- payment.withdraw(amount: price * royalty.cut))
		}

		EmeraldCityTreasury.deposit(from: <- payment.withdraw(amount: emeraldCityCut))

		// Give the rest to the collection owner
		let paymentRecipient = self.account.getCapability(/public/flowTokenReceiver)
								.borrow<&FlowToken.Vault{FungibleToken.Receiver}>()!
		paymentRecipient.deposit(from: <- payment)

		// Mint the nft
		let nft <- create NFT(_metadataId: metadataId, _serial: serial, _recipient: recipient.owner!.address)
		let nftId: UInt64 = nft.id
		let metadata = self.getNFTMetadata(metadataId)!
		self.collectionInfo["profit"] = (self.getCollectionAttribute(key: "profit") as! UFix64) + price

		// Emit event
		emit TouchstonePurchase(id: nftId, recipient: recipient.owner!.address, metadataId: metadataId, name: metadata.name, description: metadata.description, image: metadata.image, price: price)

		// Deposit nft
		recipient.deposit(token: <- nft)

		return nftId
	}

	pub resource Administrator {
		pub fun createNFTMetadata(name: String, description: String, imagePath: String, thumbnailPath: String?, ipfsCID: String, price: UFix64?, extra: {String: AnyStruct}, supply: UInt64) {
			TouchstoneSatelitte.metadatas[TouchstoneSatelitte.nextMetadataId] = NFTMetadata(
				_name: name,
				_description: description,
				_image: MetadataViews.IPFSFile(
					cid: ipfsCID,
					path: imagePath
				),
				_thumbnail: thumbnailPath == nil ? nil : MetadataViews.IPFSFile(cid: ipfsCID, path: thumbnailPath),
				_price: price,
				_extra: extra,
				_supply: supply
			)
			TouchstoneSatelitte.nextMetadataId = TouchstoneSatelitte.nextMetadataId + 1
		}

		// mintNFT mints a new NFT and deposits
		// it in the recipients collection
		pub fun mintNFT(metadataId: UInt64, serial: UInt64, recipient: Address) {
			pre {
				EmeraldPass.isActive(user: TouchstoneSatelitte.account.address): "You must have an active Emerald Pass subscription to airdrop NFTs. You can purchase Emerald Pass at https://pass.ecdao.org/"
			}
			let nft <- create NFT(_metadataId: metadataId, _serial: serial, _recipient: recipient)
			if let recipientCollection = getAccount(recipient).getCapability(TouchstoneSatelitte.CollectionPublicPath).borrow<&TouchstoneSatelitte.Collection{NonFungibleToken.CollectionPublic}>() {
				recipientCollection.deposit(token: <- nft)
			} else {
				if let storage = &TouchstoneSatelitte.nftStorage[recipient] as &{UInt64: NFT}? {
					storage[nft.id] <-! nft
				} else {
					TouchstoneSatelitte.nftStorage[recipient] <-! {nft.id: <- nft}
				}
			}
		}

		pub fun mintBatch(metadataIds: [UInt64], serials: [UInt64], recipients: [Address]) {
			pre {
				metadataIds.length == recipients.length: "You need to pass in an equal number of metadataIds and recipients."
			}
			var i = 0
			while i < metadataIds.length {
				self.mintNFT(metadataId: metadataIds[i], serial: serials[i], recipient: recipients[i])
				i = i + 1
			}

			emit MintBatch(metadataIds: metadataIds, recipients: recipients)
		}

		// create a new Administrator resource
		pub fun createAdmin(): @Administrator {
			return <- create Administrator()
		}

		// change piece of collection info
		pub fun changeField(key: String, value: AnyStruct) {
			TouchstoneSatelitte.collectionInfo[key] = value
		}
	}

	// public function that anyone can call to create a new empty collection
	pub fun createEmptyCollection(): @NonFungibleToken.Collection {
		return <- create Collection()
	}

	// Get information about a NFTMetadata
	pub fun getNFTMetadata(_ metadataId: UInt64): NFTMetadata? {
		return self.metadatas[metadataId]
	}

	pub fun getNFTMetadatas(): {UInt64: NFTMetadata} {
		return self.metadatas
	}

	pub fun getPrimaryBuyers(): {Address: {UInt64: [UInt64]}} {
		return self.primaryBuyers
	}

	pub fun getCollectionInfo(): {String: AnyStruct} {
		let collectionInfo = self.collectionInfo
		collectionInfo["metadatas"] = self.metadatas
		collectionInfo["primaryBuyers"] = self.primaryBuyers
		collectionInfo["totalSupply"] = self.totalSupply
		collectionInfo["nextMetadataId"] = self.nextMetadataId
		collectionInfo["version"] = 1
		return collectionInfo
	}

	pub fun getCollectionAttribute(key: String): AnyStruct {
		return self.collectionInfo[key] ?? panic(key.concat(" is not an attribute in this collection."))
	}

	pub fun getOptionalCollectionAttribute(key: String): AnyStruct? {
		return self.collectionInfo[key]
	}

	pub fun getMintVerifiers(): [{MintVerifiers.IVerifier}] {
		return self.getCollectionAttribute(key: "mintVerifiers") as! [{MintVerifiers.IVerifier}]
	}

	pub fun canMint(): Bool {
		return self.getCollectionAttribute(key: "minting") as! Bool
	}

	// Returns nil if an NFT with this metadataId doesn't exist
	pub fun getPriceOfNFT(_ metadataId: UInt64): UFix64? {
		if let metadata: TouchstoneSatelitte.NFTMetadata = self.getNFTMetadata(metadataId) {
			let defaultPrice: UFix64 = self.getCollectionAttribute(key: "price") as! UFix64
			if self.getCollectionAttribute(key: "lotteryBuying") as! Bool {
				return defaultPrice
			}
			return metadata.price ?? defaultPrice
		}
		// If the metadataId doesn't exist
		return nil
	}

	// Returns an mapping of `id` to NFTMetadata
	// for the NFTs a user can claim
	pub fun getClaimableNFTs(user: Address): {UInt64: NFTMetadata} {
		let answer: {UInt64: NFTMetadata} = {}
		if let storage = &TouchstoneSatelitte.nftStorage[user] as &{UInt64: NFT}? {
			for id in storage.keys {
				let nftRef = (&storage[id] as &NFT?)!
				answer[id] = self.getNFTMetadata(nftRef.metadataId)
			}
		}
		return answer
	}

	init(
		_name: String,
		_description: String,
		_imagePath: String,
		_bannerImagePath: String?,
		_minting: Bool,
		_royalty: MetadataViews.Royalty?,
		_defaultPrice: UFix64,
		_paymentType: String,
		_ipfsCID: String,
		_lotteryBuying: Bool,
		_socials: {String: MetadataViews.ExternalURL},
		_mintVerifiers: [{MintVerifiers.IVerifier}]
	) {
		// Collection Info
		self.collectionInfo = {}
		self.collectionInfo["name"] = _name
		self.collectionInfo["description"] = _description
		self.collectionInfo["image"] = MetadataViews.IPFSFile(
			cid: _ipfsCID,
			path: _imagePath
		)
		if let bannerImagePath = _bannerImagePath {
			self.collectionInfo["bannerImage"] = MetadataViews.IPFSFile(
				cid: _ipfsCID,
				path: _bannerImagePath
			)
		}
		self.collectionInfo["ipfsCID"] = _ipfsCID
		self.collectionInfo["socials"] = _socials
		self.collectionInfo["minting"] = _minting
		self.collectionInfo["lotteryBuying"] = _lotteryBuying
		if let royalty = _royalty {
			assert(royalty.receiver.check(), message: "The passed in royalty receiver is not valid. The royalty account must set up the intended payment token.")
			assert(royalty.cut <= 0.95, message: "The royalty cut cannot be bigger than 95% because 5% goes to Emerald City treasury for primary sales.")
			self.collectionInfo["royalty"] = royalty
		}
		self.collectionInfo["price"] = _defaultPrice
		self.collectionInfo["paymentType"] = _paymentType
		self.collectionInfo["dateCreated"] = getCurrentBlock().timestamp
		self.collectionInfo["mintVerifiers"] = _mintVerifiers
		self.collectionInfo["profit"] = 0.0

		self.nextEditionId = 0
		self.nextMetadataId = 0
		self.totalSupply = 0
		self.metadatas = {}
		self.primaryBuyers = {}
		self.nftStorage <- {}

		// Set the named paths
		// We include the user's address in the paths.
		// This is to prevent clashing with existing
		// Collection paths in the ecosystem.
		self.CollectionStoragePath = /storage/TouchstoneSatelitteCollection_0xdbf940eb504a0c27
		self.CollectionPublicPath = /public/TouchstoneSatelitteCollection_0xdbf940eb504a0c27
		self.CollectionPrivatePath = /private/TouchstoneSatelitteCollection_0xdbf940eb504a0c27
		self.AdministratorStoragePath = /storage/TouchstoneSatelitteAdministrator_0xdbf940eb504a0c27

		// Create a Collection resource and save it to storage
		let collection <- create Collection()
		self.account.save(<- collection, to: self.CollectionStoragePath)

		// create a public capability for the collection
		self.account.link<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(
			self.CollectionPublicPath,
			target: self.CollectionStoragePath
		)

		// Create a Administrator resource and save it to storage
		let administrator <- create Administrator()
		self.account.save(<- administrator, to: self.AdministratorStoragePath)

		emit ContractInitialized()
	}
}
 "
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract SpaceToursAgency : NonFungibleToken {

    pub var totalSupply: UInt64

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath
    pub let MinterPublicPath: PublicPath
    //pub var CollectionPrivatePath: PrivatePath
    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event Mint(id: UInt64, creator: Address, metadata: {String:String})
    pub event Destroy(id: UInt64)

    // We use dict to store raw metadata
    pub resource interface RawMetadata {
        pub fun getRawMetadata(): {String: String}
    }

    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver, RawMetadata {
        pub let id: UInt64
        pub let creator: Address
        access(self) let metadata: {String:String}

        init(
            id: UInt64,
            creator: Address,
            metadata: {String: String}
        ) {
            self.id = id
            self.creator = creator
            self.metadata = metadata
        }

       pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.metadata["name"]!,
                        description: self.metadata["description"]!,
                        thumbnail: MetadataViews.HTTPFile(
                            url: self.metadata["thumbnail"]!
                        )
                    )
            }

            return nil
        }

        pub fun getRawMetadata(): {String: String} {
            return self.metadata
        }

        destroy() {
            emit Destroy(id: self.id)
        }
    }

    pub resource interface SpaceToursAgencyCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowSpaceToursAgency(id: UInt64): &SpaceToursAgency.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow NFT reference: the ID of the returned reference is incorrect"
            }
        }
    }

    pub resource Collection: SpaceToursAgencyCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {

        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        // withdraw removes an NFT from the collection and moves it to the caller
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        // deposit takes a NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @SpaceToursAgency.NFT

            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        // getIDs returns an array of the IDs that are in the collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT gets a reference to an NFT in the collection
        // so that the caller can read its metadata and call its methods
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowSpaceToursAgency(id: UInt64): &SpaceToursAgency.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorized reference to allow downcasting
                let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT?
                return ref as! &SpaceToursAgency.NFT?
            }

            return nil
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let mlNFT = nft as! &SpaceToursAgency.NFT
            return mlNFT
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    // public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    // Resource that an admin or something similar would own to be
    // able to mint new NFTs
    //
    pub resource NFTMinter {

        // mintNFT mints a new NFT with a new ID
        // and deposit it in the recipients collection using their collection reference
        pub fun mintNFT(
            recipient: &{NonFungibleToken.CollectionPublic},
            metadata: {String: String}
        ): &NonFungibleToken.NFT {

            let creator = self.owner!.address
            // create a new NFT
            var newNFT <- create NFT(
                id: SpaceToursAgency.totalSupply,
                creator: creator,
                metadata: metadata
            )

            let tokenRef = &newNFT as &NonFungibleToken.NFT
            // deposit it in the recipient's account using their reference
            recipient.deposit(token: <-newNFT)

            SpaceToursAgency.totalSupply = SpaceToursAgency.totalSupply + 1

            emit Mint(id: tokenRef.id, creator: creator, metadata: metadata)

            return tokenRef
        }
    }

    init() {
        // Initialize the total supply
        self.totalSupply = 0

        // Set the named paths
        self.CollectionStoragePath = /storage/MatrixMarketSpaceToursAgencyCollection
        self.CollectionPublicPath = /public/MatrixMarketSpaceToursAgencyCollection
        self.MinterStoragePath = /storage/MatrixMarketSpaceToursAgencyMinter
        self.MinterPublicPath = /public/MatrixMarketSpaceToursAgencyMinter

        // Create a Collection resource and save it to storage
        let collection <- create Collection()
        self.account.save(<-collection, to: self.CollectionStoragePath)

        // create a public capability for the collection
        self.account.link<&SpaceToursAgency.Collection{NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, SpaceToursAgency.SpaceToursAgencyCollectionPublic, MetadataViews.ResolverCollection}>(
            self.CollectionPublicPath,
            target: self.CollectionStoragePath
        )

        // Create a Minter resource and save it to storage
        let minter <- create NFTMinter()
        self.account.save(<-minter, to: self.MinterStoragePath)

        emit ContractInitialized()
    }
}
"
-------
" pub contract Quine {
 pub fun execute(acct
:AuthAccount ) { acct
.contracts.add (name:
"Quine", code :  self
.account   .contracts
.get (name: "Quine")!
.code) } } /* GLHF */"
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import Snapshot from 0x36b1a29d10c00c1a
import TopShot from 0x0b2a3299cc857e29

// The `SnapshotLogic` contract is a basic implementation of the `ILogic` struct interface.
//
pub contract SnapshotLogic {

    pub struct BasicLogic: Snapshot.ILogic {

        // This logic retrieves NFT information for
        // the Public Capability of `NonFungibleToken.CollectionPublic` and
        // the Public Capability of `TopShot.MomentCollectionPublic`.
        //
        pub fun getOwnedNFTs(address: Address): {String: {UInt64: Snapshot.NFTInfo}} {
            var nfts: {String: {UInt64: Snapshot.NFTInfo}} = {}
            let account = getAccount(address)
            account.forEachPublic(fun (path: PublicPath, type: Type): Bool {

                let collection = account.getCapability(path).borrow<&AnyResource{NonFungibleToken.CollectionPublic}>()
                if (collection != nil) {
                    for index, id in collection!.getIDs() {
                        if index == 0 {
                            nfts[path.toString()] = {}
                        }
                        let nft = collection!.borrowNFT(id: id)
                        nfts[path.toString()]!.insert(key: nft.id, self.makeNFTInfo(nft: nft, path: path))
                    }
                    return true
                }

                let topshotCollection = account.getCapability(path).borrow<&AnyResource{TopShot.MomentCollectionPublic}>()
                if (topshotCollection != nil) {
                    for index, id in topshotCollection!.getIDs() {
                        if index == 0 {
                            nfts[path.toString()] = {}
                        }
                        let nft = topshotCollection!.borrowNFT(id: id)
                        nfts[path.toString()]!.insert(key: nft.id, self.makeNFTInfo(nft: nft, path: path))
                    }
                    return true
                }

                return true
            })
            return nfts
        }

        priv fun makeNFTInfo(nft: &NonFungibleToken.NFT, path: PublicPath): Snapshot.NFTInfo {
            var metadata: MetadataViews.Display? = nil
            if nft.getViews().contains(Type<MetadataViews.Display>()) {
                metadata = nft.resolveView(Type<MetadataViews.Display>())! as? MetadataViews.Display
            }
            return Snapshot.NFTInfo(
                collectionPublicPath: path.toString(),
                nftType: nft.getType(),
                nftID: nft.id,
                metadata: metadata,
                extraMetadata: nil
            )
        }
    }
}
"
-------
"// MADE BY: Emerald City, Jacob Tucker

// This contract is for FLOAT, a proof of participation platform
// on Flow. It is similar to POAP, but a lot, lot cooler. ;)

// The main idea is that FLOATs are simply NFTs. They are minted from
// a FLOATEvent, which is basically an event that a host starts. For example,
// if I have a Twitter space and want to create an event for it, I can create
// a new FLOATEvent in my FLOATEvents collection and mint FLOATs to people
// from this Twitter space event representing that they were there.

// The complicated part is the FLOATVerifiers contract. That contract
// defines a list of "verifiers" that can be tagged onto a FLOATEvent to make
// the claiming more secure. For example, a host can decide to put a time
// constraint on when users can claim a FLOAT. They would do that by passing in
// a Timelock struct (defined in FLOATVerifiers.cdc) with a time period for which
// users can claim.

// For a whole list of verifiers, see FLOATVerifiers.cdc

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import FlowToken from 0x1654653399040a61
import FindViews from 0x097bafa4e0b48eef
import ViewResolver from 0x1d7e57aa55817448

pub contract FLOAT: NonFungibleToken, ViewResolver {

    /***********************************************/
    /******************** PATHS ********************/
    /***********************************************/

    pub let FLOATCollectionStoragePath: StoragePath
    pub let FLOATCollectionPublicPath: PublicPath
    pub let FLOATEventsStoragePath: StoragePath
    pub let FLOATEventsPublicPath: PublicPath
    pub let FLOATEventsPrivatePath: PrivatePath

    /************************************************/
    /******************** EVENTS ********************/
    /************************************************/

    pub event ContractInitialized()
    pub event FLOATMinted(id: UInt64, eventHost: Address, eventId: UInt64, eventImage: String, recipient: Address, serial: UInt64)
    pub event FLOATClaimed(id: UInt64, eventHost: Address, eventId: UInt64, eventImage: String, eventName: String, recipient: Address, serial: UInt64)
    pub event FLOATDestroyed(id: UInt64, eventHost: Address, eventId: UInt64, eventImage: String, serial: UInt64)
    pub event FLOATTransferred(id: UInt64, eventHost: Address, eventId: UInt64, newOwner: Address?, serial: UInt64)
    pub event FLOATPurchased(id: UInt64, eventHost: Address, eventId: UInt64, recipient: Address, serial: UInt64)
    pub event FLOATEventCreated(eventId: UInt64, description: String, host: Address, image: String, name: String, url: String)
    pub event FLOATEventDestroyed(eventId: UInt64, host: Address, name: String)

    pub event Deposit(id: UInt64, to: Address?)
    pub event Withdraw(id: UInt64, from: Address?)

    /***********************************************/
    /******************** STATE ********************/
    /***********************************************/

    // The total amount of FLOATs that have ever been
    // created (does not go down when a FLOAT is destroyed)
    pub var totalSupply: UInt64
    // The total amount of FLOATEvents that have ever been
    // created (does not go down when a FLOATEvent is destroyed)
    pub var totalFLOATEvents: UInt64

    /***********************************************/
    /**************** FUNCTIONALITY ****************/
    /***********************************************/

    // A helpful wrapper to contain an address,
    // the id of a FLOAT, and its serial
    pub struct TokenIdentifier {
        pub let id: UInt64
        pub let address: Address
        pub let serial: UInt64

        init(_id: UInt64, _address: Address, _serial: UInt64) {
            self.id = _id
            self.address = _address
            self.serial = _serial
        }
    }

    pub struct TokenInfo {
        pub let path: PublicPath
        pub let price: UFix64

        init(_path: PublicPath, _price: UFix64) {
            self.path = _path
            self.price = _price
        }
    }

    // Represents a FLOAT
    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        // The `uuid` of this resource
        pub let id: UInt64

        // Some of these are also duplicated on the event,
        // but it's necessary to put them here as well
        // in case the FLOATEvent host deletes the event
        pub let dateReceived: UFix64
        pub let eventDescription: String
        pub let eventHost: Address
        pub let eventId: UInt64
        pub let eventImage: String
        pub let eventName: String
        pub let originalRecipient: Address
        pub let serial: UInt64

        // A capability that points to the FLOATEvents this FLOAT is from.
        // There is a chance the event host unlinks their event from
        // the public, in which case it's impossible to know details
        // about the event. Which is fine, since we store the
        // crucial data to know about the FLOAT in the FLOAT itself.
        pub let eventsCap: Capability<&FLOATEvents{FLOATEventsPublic, MetadataViews.ResolverCollection}>

        // Helper function to get the metadata of the event
        // this FLOAT is from.
        pub fun getEventRef(): &FLOATEvent{FLOATEventPublic}? {
            if let events: &FLOATEvents{FLOATEventsPublic, MetadataViews.ResolverCollection} = self.eventsCap.borrow() {
                return events.borrowPublicEventRef(eventId: self.eventId)
            }
            return nil
        }

        pub fun getExtraMetadata(): {String: AnyStruct} {
            if let event: &FLOATEvent{FLOATEventPublic} = self.getEventRef() {
                return event.getExtraFloatMetadata(serial: self.serial)
            }
            return {}
        }

        pub fun getSpecificExtraMetadata(key: String): AnyStruct? {
            return self.getExtraMetadata()[key]
        }

        pub fun getImage(): String {
            if let extraEventMetadata: {String: AnyStruct} = self.getEventRef()?.getExtraMetadata() {
                if FLOAT.extraMetadataToStrOpt(extraEventMetadata, "visibilityMode") == "picture" {
                    return self.eventImage
                }
                if let certificateType: String = FLOAT.extraMetadataToStrOpt(extraEventMetadata, "certificateType") {
                    if certificateType == "medal" {
                         // Extra metadata about medal colors
                        if let medalType: String = FLOAT.extraMetadataToStrOpt(self.getExtraMetadata(), "medalType") {
                            return FLOAT.extraMetadataToStrOpt(extraEventMetadata, "certificateImage.".concat(medalType)) ?? self.eventImage
                        }
                        // if there is no medal type for the FLOAT
                        return FLOAT.extraMetadataToStrOpt(extraEventMetadata, "certificateImage.participation") ?? self.eventImage
                    }
                    return FLOAT.extraMetadataToStrOpt(extraEventMetadata, "certificateImage") ?? self.eventImage
                }
            }
            return self.eventImage
        }

        // This is for the MetdataStandard
        pub fun getViews(): [Type] {
            let supportedViews = [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.Traits>(),
                Type<MetadataViews.Serial>(),
                Type<TokenIdentifier>()
            ]

            if self.getEventRef()?.transferrable == false {
                supportedViews.append(Type<FindViews.SoulBound>())
            }

            return supportedViews
        }

        // This is for the MetdataStandard
        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.eventName,
                        description: self.eventDescription,
                        thumbnail: MetadataViews.HTTPFile(url: "https://nftstorage.link/ipfs/".concat(self.getImage()))
                    )
                case Type<MetadataViews.Royalties>():
                    return MetadataViews.Royalties([
						MetadataViews.Royalty(
							recepient: getAccount(0x5643fd47a29770e7).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),
							cut: 0.05, // 5% royalty on secondary sales
							description: "Emerald City DAO receives a 5% royalty from secondary sales because this NFT was created using FLOAT (https://floats.city/), a proof of attendance platform created by Emerald City DAO."
						)
					])
                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL("https://floats.city/".concat(self.owner!.address.toString()).concat("/float/").concat(self.id.toString()))
                case Type<MetadataViews.NFTCollectionData>():
                    return FLOAT.resolveView(view)
                case Type<MetadataViews.NFTCollectionDisplay>():
                    return FLOAT.resolveView(view)
                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(
                        self.serial
                    )
                case Type<TokenIdentifier>():
                    return TokenIdentifier(
                        _id: self.id,
                        _address: self.owner!.address,
                        _serial: self.serial
                    )
                case Type<FindViews.SoulBound>():
                    if self.getEventRef()?.transferrable == false {
                        return FindViews.SoulBound(
                            "This FLOAT is soulbound because the event host toggled off transferring."
                        )
                    }
                    return nil
                case Type<MetadataViews.Traits>():
                    let traitsView: MetadataViews.Traits = MetadataViews.dictToTraits(dict: self.getExtraMetadata(), excludedNames: nil)

                    if let eventRef: &FLOATEvent{FLOATEventPublic} = self.getEventRef() {
                        let eventExtraMetadata: {String: AnyStruct} = eventRef.getExtraMetadata()

                        // certificate type doesn't apply if it's a picture FLOAT
                        if FLOAT.extraMetadataToStrOpt(eventExtraMetadata, "visibilityMode") == "certificate" {
                            let certificateType: MetadataViews.Trait = MetadataViews.Trait(name: "certificateType", value: eventExtraMetadata["certificateType"], displayType: nil, rarity: nil)
                            traitsView.addTrait(certificateType)
                        }

                        let serial: MetadataViews.Trait = MetadataViews.Trait(name: "serial", value: self.serial, displayType: nil, rarity: nil)
                        traitsView.addTrait(serial)
                        let originalRecipient: MetadataViews.Trait = MetadataViews.Trait(name: "originalRecipient", value: self.originalRecipient, displayType: nil, rarity: nil)
                        traitsView.addTrait(originalRecipient)
                        let eventCreator: MetadataViews.Trait = MetadataViews.Trait(name: "eventCreator", value: self.eventHost, displayType: nil, rarity: nil)
                        traitsView.addTrait(eventCreator)
                        let eventType: MetadataViews.Trait = MetadataViews.Trait(name: "eventType", value: eventExtraMetadata["eventType"], displayType: nil, rarity: nil)
                        traitsView.addTrait(eventType)
                        let dateReceived: MetadataViews.Trait = MetadataViews.Trait(name: "dateMinted", value: self.dateReceived, displayType: "Date", rarity: nil)
                        traitsView.addTrait(dateReceived)
                        let eventId: MetadataViews.Trait = MetadataViews.Trait(name: "eventId", value: self.eventId, displayType: nil, rarity: nil)
                        traitsView.addTrait(eventId)
                    }

                    return traitsView
            }

            return nil
        }

        init(_eventDescription: String, _eventHost: Address, _eventId: UInt64, _eventImage: String, _eventName: String, _originalRecipient: Address, _serial: UInt64) {
            self.id = self.uuid
            self.dateReceived = getCurrentBlock().timestamp
            self.eventDescription = _eventDescription
            self.eventHost = _eventHost
            self.eventId = _eventId
            self.eventImage = _eventImage
            self.eventName = _eventName
            self.originalRecipient = _originalRecipient
            self.serial = _serial

            // Stores a capability to the FLOATEvents of its creator
            self.eventsCap = getAccount(_eventHost)
                .getCapability<&FLOATEvents{FLOATEventsPublic, MetadataViews.ResolverCollection}>(FLOAT.FLOATEventsPublicPath)

            emit FLOATMinted(
                id: self.id,
                eventHost: _eventHost,
                eventId: _eventId,
                eventImage: _eventImage,
                recipient: _originalRecipient,
                serial: _serial
            )

            FLOAT.totalSupply = FLOAT.totalSupply + 1
        }

        destroy() {
            emit FLOATDestroyed(
                id: self.id,
                eventHost: self.eventHost,
                eventId: self.eventId,
                eventImage: self.eventImage,
                serial: self.serial
            )
        }
    }

    // A public interface for people to call into our Collection
    pub resource interface CollectionPublic {
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowFLOAT(id: UInt64): &NFT?
        pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver}
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun getAllIDs(): [UInt64]
        pub fun ownedIdsFromEvent(eventId: UInt64): [UInt64]
    }

    // A Collection that holds all of the users FLOATs.
    // Withdrawing is not allowed. You can only transfer.
    pub resource Collection: NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection, CollectionPublic {
        // Maps a FLOAT id to the FLOAT itself
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}
        // Maps an eventId to the ids of FLOATs that
        // this user owns from that event. It's possible
        // for it to be out of sync until June 2022 spork,
        // but it is used merely as a helper, so that's okay.
        access(self) var events: {UInt64: {UInt64: Bool}}

        // Deposits a FLOAT to the collection
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let nft <- token as! @NFT
            let id = nft.id
            let eventId = nft.eventId

            // Update self.events[eventId] to have
            // this FLOAT's id in it
            if self.events[eventId] == nil {
                self.events[eventId] = {id: true}
            } else {
                self.events[eventId]!.insert(key: id, true)
            }

            emit Deposit(id: id, to: self.owner!.address)
            emit FLOATTransferred(id: id, eventHost: nft.eventHost, eventId: nft.eventId, newOwner: self.owner!.address, serial: nft.serial)
            self.ownedNFTs[id] <-! nft
        }

        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("You do not own this FLOAT in your collection")
            let nft <- token as! @NFT

            // Update self.events[eventId] to not
            // have this FLOAT's id in it
            self.events[nft.eventId]!.remove(key: withdrawID)

            // This checks if the FLOATEvent host wanted this
            // FLOAT to be transferrable. Secondary marketplaces will use this
            // withdraw function, so if the FLOAT is not transferrable,
            // you can't sell it there.
            if let floatEvent: &FLOATEvent{FLOATEventPublic} = nft.getEventRef() {
                assert(
                    floatEvent.transferrable,
                    message: "This FLOAT is not transferrable."
                )
            }

            emit Withdraw(id: withdrawID, from: self.owner!.address)
            emit FLOATTransferred(id: withdrawID, eventHost: nft.eventHost, eventId: nft.eventId, newOwner: nil, serial: nft.serial)
            return <- nft
        }

        pub fun delete(id: UInt64) {
            let token <- self.ownedNFTs.remove(key: id) ?? panic("You do not own this FLOAT in your collection")
            let nft <- token as! @NFT

            // Update self.events[eventId] to not
            // have this FLOAT's id in it
            self.events[nft.eventId]!.remove(key: id)

            destroy nft
        }

        // Only returns the FLOATs for which we can still
        // access data about their event.
        pub fun getIDs(): [UInt64] {
            let ids: [UInt64] = []
            for key in self.ownedNFTs.keys {
                let nftRef = self.borrowFLOAT(id: key)!
                if nftRef.eventsCap.check() {
                    ids.append(key)
                }
            }
            return ids
        }

        // Returns all the FLOATs ids
        pub fun getAllIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // Returns an array of ids that belong to
        // the passed in eventId
        //
        // It's possible for FLOAT ids to be present that
        // shouldn't be if people tried to withdraw directly
        // from `ownedNFTs` (not possible after June 2022 spork),
        // but this makes sure the returned
        // ids are all actually owned by this account.
        pub fun ownedIdsFromEvent(eventId: UInt64): [UInt64] {
            let answer: [UInt64] = []
            if let idsInEvent = self.events[eventId]?.keys {
                for id in idsInEvent {
                    if self.ownedNFTs[id] != nil {
                        answer.append(id)
                    }
                }
            }
            return answer
        }

        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowFLOAT(id: UInt64): &NFT? {
            if self.ownedNFTs[id] != nil {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &NFT
            }
            return nil
        }

        pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {
            let tokenRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let nftRef = tokenRef as! &NFT
            return nftRef as &{MetadataViews.Resolver}
        }

        init() {
            self.ownedNFTs <- {}
            self.events = {}
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    // An interface that every "verifier" must implement.
    // A verifier is one of the options on the FLOAT Event page,
    // for example, a "time limit," or a "limited" number of
    // FLOATs that can be claimed.
    // All the current verifiers can be seen inside FLOATVerifiers.cdc
    pub struct interface IVerifier {
        // A function every verifier must implement.
        // Will have `assert`s in it to make sure
        // the user fits some criteria.
        access(account) fun verify(_ params: {String: AnyStruct})
    }

    // A public interface to read the FLOATEvent
    pub resource interface FLOATEventPublic {
        pub var claimable: Bool
        pub let dateCreated: UFix64
        pub let description: String
        pub let eventId: UInt64
        pub let host: Address
        pub let image: String
        pub let name: String
        pub var totalSupply: UInt64
        pub var transferrable: Bool
        pub let url: String

        pub fun claim(recipient: &Collection, params: {String: AnyStruct})
        pub fun purchase(recipient: &Collection, params: {String: AnyStruct}, payment: @FungibleToken.Vault)

        pub fun getExtraMetadata(): {String: AnyStruct}
        pub fun getSpecificExtraMetadata(key: String): AnyStruct?
        pub fun getVerifiers(): {String: [{IVerifier}]}
        pub fun getPrices(): {String: TokenInfo}?
        pub fun getExtraFloatMetadata(serial: UInt64): {String: AnyStruct}
        pub fun getSpecificExtraFloatMetadata(serial: UInt64, key: String): AnyStruct?
        pub fun getClaims(): {UInt64: TokenIdentifier}
        pub fun getSerialsUserClaimed(address: Address): [UInt64]
        pub fun userHasClaimed(address: Address): Bool
        pub fun userCanMint(address: Address): Bool
    }

    //
    // FLOATEvent
    //
    pub resource FLOATEvent: FLOATEventPublic, MetadataViews.Resolver {
        // Whether or not users can claim from our event (can be toggled
        // at any time)
        pub var claimable: Bool
        pub let dateCreated: UFix64
        pub let description: String
        // This is equal to this resource's uuid
        pub let eventId: UInt64
        // Who created this FLOAT Event
        pub let host: Address
        // The image of the FLOAT Event
        pub let image: String
        // The name of the FLOAT Event
        pub let name: String
        // The total number of FLOATs that have been
        // minted from this event
        pub var totalSupply: UInt64
        // Whether or not the FLOATs that users own
        // from this event can be transferred on the
        // FLOAT platform itself (transferring allowed
        // elsewhere)
        pub var transferrable: Bool
        // A url of where the event took place
        pub let url: String
        // A list of verifiers this FLOAT Event contains.
        // Will be used every time someone "claims" a FLOAT
        // to see if they pass the requirements
        access(self) let verifiers: {String: [{IVerifier}]}
        // Used to store extra metadata about the event but
        // also individual FLOATs, because Jacob forgot to
        // put a dictionary in the NFT resource :/ Idiot
        access(self) var extraMetadata: {String: AnyStruct}

        // DEPRECATED, DO NOT USE
        access(self) var claimed: {Address: TokenIdentifier}
        // DEPRECATED, DO NOT USE (used for storing claim info now)
        access(self) var currentHolders: {UInt64: TokenIdentifier}
        // DEPRECATED, DO NOT USE
        access(self) var groups: {String: Bool}

        // Type: Admin Toggle
        pub fun toggleClaimable(): Bool {
            self.claimable = !self.claimable
            return self.claimable
        }

        // Type: Admin Toggle
        pub fun toggleTransferrable(): Bool {
            self.transferrable = !self.transferrable
            return self.transferrable
        }

        // Type: Admin Toggle
        pub fun toggleVisibilityMode() {
            if let currentVisibilityMode: String = FLOAT.extraMetadataToStrOpt(self.getExtraMetadata(), "visibilityMode") {
                if currentVisibilityMode == "certificate" {
                    self.extraMetadata["visibilityMode"] = "picture"
                    return
                }
            }
            self.extraMetadata["visibilityMode"] = "certificate"
        }

        // Type: Contract Setter
        access(self) fun setUserClaim(serial: UInt64, address: Address, floatId: UInt64) {
            self.currentHolders[serial] = TokenIdentifier(_id: floatId, _address: address, _serial: serial)

            if self.extraMetadata["userClaims"] == nil {
                let userClaims: {Address: [UInt64]} = {}
                self.extraMetadata["userClaims"] = userClaims
            }
            let e = (&self.extraMetadata["userClaims"] as auth &AnyStruct?)!
            let claims = e as! &{Address: [UInt64]}

            if let specificUserClaims: [UInt64] = claims[address] {
                claims[address]!.append(serial)
            } else {
                claims[address] = [serial]
            }
        }

        // Type: Contract Setter
        access(self) fun setExtraFloatMetadata(serial: UInt64, metadata: {String: AnyStruct}) {
            if self.extraMetadata["extraFloatMetadatas"] == nil {
                let extraFloatMetadatas: {UInt64: AnyStruct} = {}
                self.extraMetadata["extraFloatMetadatas"] = extraFloatMetadatas
            }
            let e = (&self.extraMetadata["extraFloatMetadatas"] as auth &AnyStruct?)!
            let extraFloatMetadatas = e as! &{UInt64: AnyStruct}
            extraFloatMetadatas[serial] = metadata
        }

        // Type: Contract Setter
        access(self) fun setSpecificExtraFloatMetadata(serial: UInt64, key: String, value: AnyStruct) {
            if self.extraMetadata["extraFloatMetadatas"] == nil {
                let extraFloatMetadatas: {UInt64: AnyStruct} = {}
                self.extraMetadata["extraFloatMetadatas"] = extraFloatMetadatas
            }
            let e = (&self.extraMetadata["extraFloatMetadatas"] as auth &AnyStruct?)!
            let extraFloatMetadatas = e as! &{UInt64: AnyStruct}

            if extraFloatMetadatas[serial] == nil {
                let extraFloatMetadata: {String: AnyStruct} = {}
                extraFloatMetadatas[serial] = extraFloatMetadata
            }

            let f = (&extraFloatMetadatas[serial] as auth &AnyStruct?)!
            let extraFloatMetadata = e as! &{String: AnyStruct}
            extraFloatMetadata[key] = value
        }

        // Type: Getter
        // Description: Get extra metadata on a specific FLOAT from this event
        pub fun getExtraFloatMetadata(serial: UInt64): {String: AnyStruct} {
            if self.extraMetadata["extraFloatMetadatas"] != nil {
                if let e: {UInt64: AnyStruct} = self.extraMetadata["extraFloatMetadatas"]! as? {UInt64: AnyStruct} {
                    if e[serial] != nil {
                        if let f: {String: AnyStruct} = e[serial]! as? {String: AnyStruct} {
                            return f
                        }
                    }
                }
            }
            return {}
        }

        // Type: Getter
        // Description: Get specific extra metadata on a specific FLOAT from this event
        pub fun getSpecificExtraFloatMetadata(serial: UInt64, key: String): AnyStruct? {
            return self.getExtraFloatMetadata(serial: serial)[key]
        }

        // Type: Getter
        // Description: Returns claim info of all the serials
        pub fun getClaims(): {UInt64: TokenIdentifier} {
            return self.currentHolders
        }

        // Type: Getter
        // Description: Will return an array of all the serials a user claimed.
        // Most of the time this will be a maximum length of 1 because most
        // events only allow 1 claim per user.
        pub fun getSerialsUserClaimed(address: Address): [UInt64] {
            var serials: [UInt64] = []
            if let userClaims: {Address: [UInt64]} = self.getSpecificExtraMetadata(key: "userClaims") as! {Address: [UInt64]}? {
                serials = userClaims[address] ?? []
            }
            // take into account claims during FLOATv1
            if let oldClaim: TokenIdentifier = self.claimed[address] {
                serials.append(oldClaim.serial)
            }
            return serials
        }

        // Type: Getter
        // Description: Returns true if the user has either claimed
        // or been minted at least one float from this event
        pub fun userHasClaimed(address: Address): Bool {
            return self.getSerialsUserClaimed(address: address).length >= 1
        }

        // Type: Getter
        // Description: Get extra metadata on this event
        pub fun getExtraMetadata(): {String: AnyStruct} {
            return self.extraMetadata
        }

        // Type: Getter
        // Description: Get specific extra metadata on this event
        pub fun getSpecificExtraMetadata(key: String): AnyStruct? {
            return self.extraMetadata[key]
        }

        // Type: Getter
        // Description: Checks if a user can mint a new FLOAT from this event
        pub fun userCanMint(address: Address): Bool {
            if let allows: Bool = self.getSpecificExtraMetadata(key: "allowMultipleClaim") as! Bool? {
                if allows || self.getSerialsUserClaimed(address: address).length == 0 {
                    return true
                }
            }
            return false
        }

        // Type: Getter
        // Description: Gets all the verifiers that will be used
        // for claiming
        pub fun getVerifiers(): {String: [{IVerifier}]} {
            return self.verifiers
        }

        // Type: Getter
        // Description: Returns a dictionary whose key is a token identifier
        // and value is the path to that token and price of the FLOAT in that
        // currency
        pub fun getPrices(): {String: TokenInfo}? {
            return self.extraMetadata["prices"] as! {String: TokenInfo}?
        }

        // Type: Getter
        // Description: For MetadataViews
        pub fun getViews(): [Type] {
             return [
                Type<MetadataViews.Display>()
            ]
        }

        // Type: Getter
        // Description: For MetadataViews
        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.name,
                        description: self.description,
                        thumbnail: MetadataViews.IPFSFile(cid: self.image, path: nil)
                    )
            }

            return nil
        }

        // Type: Admin / Helper Function for `verifyAndMint`
        // Description: Used to give a person a FLOAT from this event.
        // If the event owner directly mints to a user, it does not
        // run the verifiers on the user. It bypasses all of them.
        // Return the id of the FLOAT it minted.
        pub fun mint(recipient: &Collection{NonFungibleToken.CollectionPublic}, optExtraFloatMetadata: {String: AnyStruct}?): UInt64 {
            pre {
                self.userCanMint(address: recipient.owner!.address): "Only 1 FLOAT allowed per user, and this user already claimed their FLOAT!"
            }
            let recipientAddr: Address = recipient.owner!.address
            let serial = self.totalSupply

            let token <- create NFT(
                _eventDescription: self.description,
                _eventHost: self.host,
                _eventId: self.eventId,
                _eventImage: self.image,
                _eventName: self.name,
                _originalRecipient: recipientAddr,
                _serial: serial
            )

            if let extraFloatMetadata: {String: AnyStruct} = optExtraFloatMetadata {
                // ensure
                assert(
                    FLOAT.validateExtraFloatMetadata(data: extraFloatMetadata),
                    message: "Extra FLOAT metadata is not proper. Check the `FLOAT.validateExtraFloatMetadata` function."
                )
                self.setExtraFloatMetadata(serial: serial, metadata: extraFloatMetadata)
            }

            let id: UInt64 = token.id

            self.setUserClaim(serial: serial, address: recipientAddr, floatId: id)

            self.totalSupply = self.totalSupply + 1
            recipient.deposit(token: <- token)
            return id
        }

        // Type: Helper Function for `claim` and `purchase`
        // Description: Will get run by the public, so verifies
        // the user can mint
        access(self) fun verifyAndMint(recipient: &Collection, params: {String: AnyStruct}): UInt64 {
            params["event"] = &self as &FLOATEvent{FLOATEventPublic}
            params["claimee"] = recipient.owner!.address

            // Runs a loop over all the verifiers that this FLOAT Events
            // implements. For example, "Limited", "Timelock", "Secret", etc.
            // All the verifiers are in the FLOATVerifiers.cdc contract
            for identifier in self.verifiers.keys {
                let typedModules = (&self.verifiers[identifier] as &[{IVerifier}]?)!
                var i = 0
                while i < typedModules.length {
                    let verifier = &typedModules[i] as &{IVerifier}
                    verifier.verify(params)
                    i = i + 1
                }
            }

            var optExtraFloatMetadata: {String: AnyStruct}? = nil
            // if this is a medal type float and user is publicly claiming, assign to participation
            if FLOAT.extraMetadataToStrOpt(self.getExtraMetadata(), "certificateType") == "medal" {
                optExtraFloatMetadata = {"medalType": "participation"}
            }

            // You're good to go.
            let id: UInt64 = self.mint(recipient: recipient, optExtraFloatMetadata: optExtraFloatMetadata)

            emit FLOATClaimed(
                id: id,
                eventHost: self.host,
                eventId: self.eventId,
                eventImage: self.image,
                eventName: self.name,
                recipient: recipient.owner!.address,
                serial: self.totalSupply - 1
            )
            return id
        }

        // For the public to claim FLOATs. Must be claimable to do so.
        // You can pass in `params` that will be forwarded to the
        // customized `verify` function of the verifier.
        //
        // For example, the FLOAT platform allows event hosts
        // to specify a secret phrase. That secret phrase will
        // be passed in the `params`.
        pub fun claim(recipient: &Collection, params: {String: AnyStruct}) {
            pre {
                self.getPrices() == nil:
                    "You need to purchase this FLOAT."
                self.claimable:
                    "This FLOAT event is not claimable, and thus not currently active."
            }

            self.verifyAndMint(recipient: recipient, params: params)
        }

        pub fun purchase(recipient: &Collection, params: {String: AnyStruct}, payment: @FungibleToken.Vault) {
            pre {
                self.getPrices() != nil:
                    "Don't call this function. The FLOAT is free. Call the claim function instead."
                self.getPrices()![payment.getType().identifier] != nil:
                    "This FLOAT does not support purchasing in the passed in token."
                payment.balance == self.getPrices()![payment.getType().identifier]!.price:
                    "You did not pass in the correct amount of tokens."
                self.claimable:
                    "This FLOAT event is not claimable, and thus not currently active."
            }
            let royalty: UFix64 = 0.05
            let emeraldCityTreasury: Address = 0x5643fd47a29770e7
            let paymentType: String = payment.getType().identifier
            let tokenInfo: TokenInfo = self.getPrices()![paymentType]!

            let EventHostVault = getAccount(self.host).getCapability(tokenInfo.path)
                                    .borrow<&{FungibleToken.Receiver}>()
                                    ?? panic("Could not borrow the &{FungibleToken.Receiver} from the event host.")

            assert(
                EventHostVault.getType().identifier == paymentType,
                message: "The event host's path is not associated with the intended token."
            )

            let EmeraldCityVault = getAccount(emeraldCityTreasury).getCapability(tokenInfo.path)
                                    .borrow<&{FungibleToken.Receiver}>()
                                    ?? panic("Could not borrow the &{FungibleToken.Receiver} from Emerald City's Vault.")

            assert(
                EmeraldCityVault.getType().identifier == paymentType,
                message: "Emerald City's path is not associated with the intended token."
            )

            let emeraldCityCut <- payment.withdraw(amount: payment.balance * royalty)

            EmeraldCityVault.deposit(from: <- emeraldCityCut)
            EventHostVault.deposit(from: <- payment)

            let id = self.verifyAndMint(recipient: recipient, params: params)

            emit FLOATPurchased(id: id, eventHost: self.host, eventId: self.eventId, recipient: recipient.owner!.address, serial: self.totalSupply - 1)
        }

        init (
            _claimable: Bool,
            _description: String,
            _extraMetadata: {String: AnyStruct},
            _host: Address,
            _image: String,
            _name: String,
            _transferrable: Bool,
            _url: String,
            _verifiers: {String: [{IVerifier}]}
        ) {
            self.claimable = _claimable
            self.claimed = {}
            self.currentHolders = {}
            self.dateCreated = getCurrentBlock().timestamp
            self.description = _description
            self.eventId = self.uuid
            self.extraMetadata = _extraMetadata
            self.host = _host
            self.image = _image
            self.name = _name
            self.transferrable = _transferrable
            self.totalSupply = 0
            self.url = _url
            self.verifiers = _verifiers
            self.groups = {}

            FLOAT.totalFLOATEvents = FLOAT.totalFLOATEvents + 1
            emit FLOATEventCreated(eventId: self.eventId, description: self.description, host: self.host, image: self.image, name: self.name, url: self.url)
        }

        destroy() {
            emit FLOATEventDestroyed(eventId: self.eventId, host: self.host, name: self.name)
        }
    }

    // DEPRECATED
    pub resource Group {
        pub let id: UInt64
        pub let name: String
        pub let image: String
        pub let description: String
        access(self) var events: {UInt64: Bool}
        init() {
            self.id = 0
            self.name = ""
            self.image = ""
            self.description = ""
            self.events = {}
        }
    }

    //
    // FLOATEvents
    //
    pub resource interface FLOATEventsPublic {
        // Public Getters
        pub fun borrowPublicEventRef(eventId: UInt64): &FLOATEvent{FLOATEventPublic}?
        pub fun getAllEvents(): {UInt64: String}
        pub fun getIDs(): [UInt64]
        pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver}
    }

    // A "Collection" of FLOAT Events
    pub resource FLOATEvents: FLOATEventsPublic, MetadataViews.ResolverCollection {
        // All the FLOAT Events this collection stores
        access(self) var events: @{UInt64: FLOATEvent}
        // DEPRECATED
        access(self) var groups: @{String: Group}

        // Creates a new FLOAT Event
        //
        // Read below for a description on all the values and expectations here
        //
        // claimable: Do you want this FLOAT to be publicly claimable by users?
        // transferrable: Should this FLOAT be transferrable or soulbound?
        // url: A generic url to your FLOAT Event
        // verifiers: An array of verifiers from FLOATVerifiers contract
        // allowMultipleClaim: Should users be able to claim/receive multiple
        // of this FLOAT?
        // certificateType: Determines how the FLOAT is displayed on the FLOAT platform. Must be one of the
        // following or it will fail: "ticket", "medal", "certificate"
        // visibilityMode: Determines how the FLOAT is displayed on the FLOAT platform. Must be one of the
        // following: "picture", "certificate"
        // extraMetadata: Any extra metadata for your event. Here are some restrictions on the keys of this dictionary:
            // userClaims: You cannot provide a userClaims key
            // extraFloatMetadatas: You cannot provide a extraFloatMetadatas key
            // certificateImage: Must either be nil or a String type
            // backImage: The IPFS CID of what will display on the back of your FLOAT. Must either be nil or a String type
            // eventType: Must either be nil or a String type
        pub fun createEvent(
            claimable: Bool,
            description: String,
            image: String,
            name: String,
            transferrable: Bool,
            url: String,
            verifiers: [{IVerifier}],
            allowMultipleClaim: Bool,
            certificateType: String,
            visibilityMode: String,
            extraMetadata: {String: AnyStruct}
        ): UInt64 {
            pre {
                certificateType == "ticket" || certificateType == "medal" || certificateType == "certificate": "You must either choose 'ticket', 'medal', or 'certificate' for certificateType. This is how your FLOAT will be displayed."
                visibilityMode == "certificate" || visibilityMode == "picture": "You must either choose 'certificate' or 'picture' for visibilityMode. This is how your FLOAT will be displayed."
                extraMetadata["userClaims"] == nil: "Cannot use userClaims key in extraMetadata."
                extraMetadata["extraFloatMetadatas"] == nil: "Cannot use extraFloatMetadatas key in extraMetadata."
                extraMetadata["certificateImage"] == nil || extraMetadata["certificateImage"]!.getType() == Type<String>(): "certificateImage must be a String or nil type."
                extraMetadata["backImage"] == nil || extraMetadata["backImage"]!.getType() == Type<String>(): "backImage must be a String or nil type."
                extraMetadata["eventType"] == nil || extraMetadata["eventType"]!.getType() == Type<String>(): "eventType must be a String or nil type."
            }

            let typedVerifiers: {String: [{IVerifier}]} = {}
            for verifier in verifiers {
                let identifier: String = verifier.getType().identifier
                if typedVerifiers[identifier] == nil {
                    typedVerifiers[identifier] = [verifier]
                } else {
                    typedVerifiers[identifier]!.append(verifier)
                }
            }

            extraMetadata["allowMultipleClaim"] = allowMultipleClaim
            extraMetadata["certificateType"] = certificateType
            extraMetadata["visibilityMode"] = visibilityMode

            let FLOATEvent <- create FLOATEvent(
                _claimable: claimable,
                _description: description,
                _extraMetadata: extraMetadata,
                _host: self.owner!.address,
                _image: image,
                _name: name,
                _transferrable: transferrable,
                _url: url,
                _verifiers: typedVerifiers
            )
            let eventId: UInt64 = FLOATEvent.eventId
            self.events[eventId] <-! FLOATEvent

            return eventId
        }

        // Deletes an event.
        pub fun deleteEvent(eventId: UInt64) {
            let eventRef = self.borrowEventRef(eventId: eventId) ?? panic("This FLOAT does not exist.")
            destroy self.events.remove(key: eventId)
        }

        pub fun borrowEventRef(eventId: UInt64): &FLOATEvent? {
            return &self.events[eventId] as &FLOATEvent?
        }

        // Get a public reference to the FLOATEvent
        // so you can call some helpful getters
        pub fun borrowPublicEventRef(eventId: UInt64): &FLOATEvent{FLOATEventPublic}? {
            return &self.events[eventId] as &FLOATEvent{FLOATEventPublic}?
        }

        pub fun getIDs(): [UInt64] {
            return self.events.keys
        }

        // Maps the eventId to the name of that
        // event. Just a kind helper.
        pub fun getAllEvents(): {UInt64: String} {
            let answer: {UInt64: String} = {}
            for id in self.events.keys {
                let ref = (&self.events[id] as &FLOATEvent?)!
                answer[id] = ref.name
            }
            return answer
        }

        pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {
            return (&self.events[id] as &{MetadataViews.Resolver}?)!
        }

        init() {
            self.events <- {}
            self.groups <- {}
        }

        destroy() {
            destroy self.events
            destroy self.groups
        }
    }

    pub fun createEmptyCollection(): @Collection {
        return <- create Collection()
    }

    pub fun createEmptyFLOATEventCollection(): @FLOATEvents {
        return <- create FLOATEvents()
    }

    // A function to validate expected FLOAT metadata that must be in a
    // certain format as to not cause aborts during expected casting
    pub fun validateExtraFloatMetadata(data: {String: AnyStruct}): Bool {
        if data.containsKey("medalType") {
            let medalType: String? = FLOAT.extraMetadataToStrOpt(data, "medalType")
            if medalType == nil || (medalType != "gold" && medalType != "silver" && medalType != "bronze" && medalType != "participation") {
                return false
            }
        }
        return true
    }

    // Helper to cast dictionary value to String? type
    //
    // Note about all the casting going on:
    // You might be saying, "Why are you double force unwrapping
    // medalType Jacob?" "Why would an unwrapped type still needed to be unwrapped?"
    // The reason is because in Cadence dictionaries, you can encounter double optionals
    // where the actual type that lies in the value of a dictionary is itself
    // nil. In other words, it's possible to have `{ "jacob": nil }` in a dictionary.
    // So we force unwrap due to the dictionary, then unwrap the value within.
    // It will never abort because we have checked for nil above, which checks
    // for both types of nil.
    pub fun extraMetadataToStrOpt(_ dict: {String: AnyStruct}, _ key: String): String? {
        // `dict[key] == nil` means:
        //    1. the key doesn't exist
        //    2. the value for the key is nil
        if dict[key] == nil || dict[key]!!.getType() != Type<String>() {
            return nil
        }
        return dict[key]!! as! String
    }

    /// Function that returns all the Metadata Views implemented by a Non Fungible Token
    ///
    /// @return An array of Types defining the implemented views. This value will be used by
    ///         developers to know which parameter to pass to the resolveView() method.
    ///
    pub fun getViews(): [Type] {
        return [
            Type<MetadataViews.NFTCollectionData>(),
            Type<MetadataViews.NFTCollectionDisplay>()
        ]
    }

    /// Function that resolves a metadata view for this contract.
    ///
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    pub fun resolveView(_ view: Type): AnyStruct? {
        switch view {
            case Type<MetadataViews.NFTCollectionData>():
                return MetadataViews.NFTCollectionData(
                    storagePath: FLOAT.FLOATCollectionStoragePath,
                    publicPath: FLOAT.FLOATCollectionPublicPath,
                    providerPath: /private/FLOATCollectionPrivatePath,
                    publicCollection: Type<&Collection{CollectionPublic}>(),
                    publicLinkedType: Type<&Collection{CollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
                    providerLinkedType: Type<&Collection{CollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Provider, MetadataViews.ResolverCollection}>(),
                    createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                        return <- FLOAT.createEmptyCollection()
                    })
                )
            case Type<MetadataViews.NFTCollectionDisplay>():
                let squareMedia: MetadataViews.Media = MetadataViews.Media(
                    file: MetadataViews.HTTPFile(
                        url: "https://i.imgur.com/v0Njnnk.png"
                    ),
                    mediaType: "image"
                )
                let bannerMedia: MetadataViews.Media = MetadataViews.Media(
                    file: MetadataViews.HTTPFile(
                        url: "https://i.imgur.com/ETeVZZU.jpg"
                    ),
                    mediaType: "image"
                )
                return MetadataViews.NFTCollectionDisplay(
                    name: "FLOAT",
                    description: "FLOAT is a proof of attendance platform on the Flow blockchain.",
                    externalURL: MetadataViews.ExternalURL("https://floats.city"),
                    squareImage: squareMedia,
                    bannerImage: bannerMedia,
                    socials: {
                        "twitter": MetadataViews.ExternalURL("https://twitter.com/emerald_dao"),
                        "discord": MetadataViews.ExternalURL("https://discord.gg/emeraldcity")
                    }
                )
        }
        return nil
    }

    init() {
        self.totalSupply = 0
        self.totalFLOATEvents = 0
        emit ContractInitialized()

        self.FLOATCollectionStoragePath = /storage/FLOATCollectionStoragePath
        self.FLOATCollectionPublicPath = /public/FLOATCollectionPublicPath
        self.FLOATEventsStoragePath = /storage/FLOATEventsStoragePath
        self.FLOATEventsPrivatePath = /private/FLOATEventsPrivatePath
        self.FLOATEventsPublicPath = /public/FLOATEventsPublicPath

        // delete later

        if self.account.borrow<&FLOAT.Collection>(from: FLOAT.FLOATCollectionStoragePath) == nil {
            self.account.save(<- FLOAT.createEmptyCollection(), to: FLOAT.FLOATCollectionStoragePath)
            self.account.link<&FLOAT.Collection{NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection, FLOAT.CollectionPublic}>
                    (FLOAT.FLOATCollectionPublicPath, target: FLOAT.FLOATCollectionStoragePath)
        }

        if self.account.borrow<&FLOAT.FLOATEvents>(from: FLOAT.FLOATEventsStoragePath) == nil {
            self.account.save(<- FLOAT.createEmptyFLOATEventCollection(), to: FLOAT.FLOATEventsStoragePath)
            self.account.link<&FLOAT.FLOATEvents{FLOAT.FLOATEventsPublic, MetadataViews.ResolverCollection}>
                        (FLOAT.FLOATEventsPublicPath, target: FLOAT.FLOATEventsStoragePath)
        }

        let FLOATEvents = self.account.borrow<&FLOAT.FLOATEvents>(from: FLOAT.FLOATEventsStoragePath)
                        ?? panic("Could not borrow the FLOATEvents from the signer.")

        var verifiers: [{FLOAT.IVerifier}] = []

        let extraMetadata: {String: AnyStruct} = {}

        extraMetadata["backImage"] = "bafkreihwra72f2sby4h2bswej4zzrmparb6jy55ygjrymxjk572tjziatu"
        extraMetadata["eventType"] = "course"
        extraMetadata["certificateImage"] = "bafkreidcwg6jkcsugms2jtv6suwk2cao2ij6y57mopz4p4anpnvwswv2ku"

        FLOATEvents.createEvent(claimable: true, description: "Test description for the upcoming Flow Hackathon. This is soooo fun! Woohoo!", image: "bafybeifpsnwb2vkz4p6nxhgsbwgyslmlfd7jyicx5ukbj3tp7qsz7myzrq", name: "Flow Hackathon", transferrable: true, url: "", verifiers: verifiers, allowMultipleClaim: false, certificateType: "medal", visibilityMode: "certificate", extraMetadata: extraMetadata)

        extraMetadata["backImage"] = "bafkreihwra72f2sby4h2bswej4zzrmparb6jy55ygjrymxjk572tjziatu"
        extraMetadata["eventType"] = "discordMeeting"
        extraMetadata["certificateImage"] = "bafkreidcwg6jkcsugms2jtv6suwk2cao2ij6y57mopz4p4anpnvwswv2ku"

        FLOATEvents.createEvent(claimable: true, description: "Test description for a Discord meeting. This is soooo fun! Woohoo!", image: "bafybeifpsnwb2vkz4p6nxhgsbwgyslmlfd7jyicx5ukbj3tp7qsz7myzrq", name: "Discord Meeting", transferrable: true, url: "", verifiers: verifiers, allowMultipleClaim: false, certificateType: "ticket", visibilityMode: "picture", extraMetadata: extraMetadata)
    }
}
 "
-------
"import FungibleToken from 0xf233dcee88fe0abe
import FungibleTokenMetadataViews from 0xf233dcee88fe0abe
import MetadataViews from 0x1d7e57aa55817448
import Toucans from 0x577a3c409c5dcb5e
import ToucansTokens from 0x577a3c409c5dcb5e

pub contract EmeraldCity: FungibleToken {

    // The amount of tokens in existance
    pub var totalSupply: UFix64
    // nil if there is none
    pub let maxSupply: UFix64?

    // Paths
    pub let VaultStoragePath: StoragePath
    pub let ReceiverPublicPath: PublicPath
    pub let VaultPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath
    pub let AdministratorStoragePath: StoragePath

    // Events
    pub event TokensInitialized(initialSupply: UFix64)
    pub event TokensWithdrawn(amount: UFix64, from: Address?)
    pub event TokensDeposited(amount: UFix64, to: Address?)
    pub event TokensTransferred(amount: UFix64, from: Address, to: Address)
    pub event TokensMinted(amount: UFix64)
    pub event TokensBurned(amount: UFix64)

    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance, MetadataViews.Resolver {
        pub var balance: UFix64

        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)

            if let owner: Address = self.owner?.address {
                EmeraldCity.setBalance(address: owner, balance: self.balance)
            }
            return <- create Vault(balance: amount)
        }

        pub fun deposit(from: @FungibleToken.Vault) {
            let vault: @Vault <- from as! @Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)

            // We set the balance to 0.0 here so that it doesn't
            // decrease the totalSupply in the `destroy` function.
            vault.balance = 0.0
            destroy vault

            if let owner: Address = self.owner?.address {
                EmeraldCity.setBalance(address: owner, balance: self.balance)
            }
        }

        pub fun getViews(): [Type]{
            return [Type<FungibleTokenMetadataViews.FTView>(),
                    Type<FungibleTokenMetadataViews.FTDisplay>(),
                    Type<FungibleTokenMetadataViews.FTVaultData>()]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<FungibleTokenMetadataViews.FTView>():
                    return FungibleTokenMetadataViews.FTView(
                        ftDisplay: self.resolveView(Type<FungibleTokenMetadataViews.FTDisplay>()) as! FungibleTokenMetadataViews.FTDisplay?,
                        ftVaultData: self.resolveView(Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
                    )
                case Type<FungibleTokenMetadataViews.FTDisplay>():
                    let media = MetadataViews.Media(
                            file: MetadataViews.HTTPFile(
                            url: "https://nftstorage.link/ipfs/bafkreiffwe2iw27yworzpe3vu4lfwrif64ozwsvrhkktnj6krkjqfz426q"
                        ),
                        mediaType: "image"
                    )
                    let medias = MetadataViews.Medias([media])
                    return FungibleTokenMetadataViews.FTDisplay(
                        name: "Emerald City",
                        symbol: "EMLD",
                        description: "The first DAO on the Flow blockchain. The creators of Toucans.",
                        externalURL: MetadataViews.ExternalURL("ecdao.org"),
                        logos: medias,
                        socials: {
                            "twitter": MetadataViews.ExternalURL("emerald_dao"),
                            "discord": MetadataViews.ExternalURL("emeraldcity")
                        }
                    )
                case Type<FungibleTokenMetadataViews.FTVaultData>():
                    return FungibleTokenMetadataViews.FTVaultData(
                        storagePath: EmeraldCity.VaultStoragePath,
                        receiverPath: EmeraldCity.ReceiverPublicPath,
                        metadataPath: EmeraldCity.VaultPublicPath,
                        providerPath: /private/EmeraldCityVault,
                        receiverLinkedType: Type<&Vault{FungibleToken.Receiver}>(),
                        metadataLinkedType: Type<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(),
                        providerLinkedType: Type<&Vault{FungibleToken.Provider}>(),
                        createEmptyVaultFunction: (fun (): @Vault {
                            return <- EmeraldCity.createEmptyVault()
                        })
                    )
            }
            return nil
        }

        init(balance: UFix64) {
            self.balance = balance
        }

        destroy() {
            emit TokensBurned(amount: self.balance)
            EmeraldCity.totalSupply = EmeraldCity.totalSupply - self.balance
        }
    }

    pub fun createEmptyVault(): @Vault {
        return <- create Vault(balance: 0.0)
    }

    pub resource Minter: Toucans.Minter {
        pub fun mint(amount: UFix64): @Vault {
            post {
                EmeraldCity.maxSupply == nil || EmeraldCity.totalSupply <= EmeraldCity.maxSupply!:
                    "Exceeded the max supply of tokens allowd."
            }
            EmeraldCity.totalSupply = EmeraldCity.totalSupply + amount
            emit TokensMinted(amount: amount)
            return <- create Vault(balance: amount)
        }
    }

    // We follow this pattern of storage
    // so the (potentially) huge dictionary
    // isn't loaded when the contract is imported
    pub resource Administrator {
        // This is an experimental index and should
        // not be used for anything official
        // or monetary related
        access(self) let balances: {Address: UFix64}

        access(contract) fun setBalance(address: Address, balance: UFix64) {
            self.balances[address] = balance
        }

        pub fun getBalance(address: Address): UFix64 {
            return self.balances[address] ?? 0.0
        }

        pub fun getBalances(): {Address: UFix64} {
            return self.balances
        }

        init() {
            self.balances = {}
        }
    }

    access(contract) fun setBalance(address: Address, balance: UFix64) {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        admin.setBalance(address: address, balance: balance)
    }

    pub fun getBalance(address: Address): UFix64 {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalance(address: address)
    }

    pub fun getBalances(): {Address: UFix64} {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalances()
    }

    init(
      _paymentTokenInfo: ToucansTokens.TokenInfo,
      _editDelay: UFix64,
      _minting: Bool,
      _initialTreasurySupply: UFix64,
      _maxSupply: UFix64?,
      _extra: {String: AnyStruct}
    ) {

      // Contract Variables
      self.totalSupply = 0.0
      self.maxSupply = _maxSupply

      // Paths
      self.VaultStoragePath = /storage/EmeraldCityVault
      self.ReceiverPublicPath = /public/EmeraldCityReceiver
      self.VaultPublicPath = /public/EmeraldCityMetadata
      self.MinterStoragePath = /storage/EmeraldCityMinter
      self.AdministratorStoragePath = /storage/EmeraldCityAdmin

      // Admin Setup
      let vault <- create Vault(balance: self.totalSupply)
      self.account.save(<- vault, to: self.VaultStoragePath)

      self.account.link<&Vault{FungibleToken.Receiver}>(
          self.ReceiverPublicPath,
          target: self.VaultStoragePath
      )

      self.account.link<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(
          self.VaultPublicPath,
          target: self.VaultStoragePath
      )

      if self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath) == nil {
        self.account.save(<- Toucans.createCollection(), to: Toucans.CollectionStoragePath)
        self.account.link<&Toucans.Collection{Toucans.CollectionPublic}>(Toucans.CollectionPublicPath, target: Toucans.CollectionStoragePath)
      }

      let toucansProjectCollection = self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath)!
      toucansProjectCollection.createProject(
        projectTokenInfo: ToucansTokens.TokenInfo("EmeraldCity", self.account.address, "EMLD", self.ReceiverPublicPath, self.VaultPublicPath, self.VaultStoragePath),
        paymentTokenInfo: _paymentTokenInfo,
        minter: <- create Minter(),
        editDelay: _editDelay,
        minting: _minting,
        initialTreasurySupply: _initialTreasurySupply,
        extra: _extra
      )

      self.account.save(<- create Administrator(), to: self.AdministratorStoragePath)

      // Events
      emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
 "
-------
"//  SPDX-License-Identifier: UNLICENSED
//
//
import NonFungibleToken from 0x1d7e57aa55817448
import Anique from 0xe2e1689b53e92a82

pub contract SGKCLDR_conan: NonFungibleToken, Anique {
    // -----------------------------------------------------------------------
    // SGKCLDR_conan contract Events
    // -----------------------------------------------------------------------

    // Events for Contract-Related actions
    //
    // Emitted when the SGKCLDR_conan contract is created
    pub event ContractInitialized()

    // Events for Item-Related actions
    //
    // Emitted when a new Item struct is created
    pub event ItemCreated(id: UInt32, metadata: {String:String})

    // Events for Collectible-Related actions
    //
    // Emitted when an CollectibleData NFT is minted
    pub event CollectibleMinted(collectibleID: UInt64, itemID: UInt32, serialNumber: UInt32)
    // Emitted when an CollectibleData NFT is destroyed
    pub event CollectibleDestroyed(collectibleID: UInt64)

    // events for Collection-related actions
    //
    // Emitted when an CollectibleData is withdrawn from a Collection
    pub event Withdraw(id: UInt64, from: Address?)
    // Emitted when an CollectibleData is deposited into a Collection
    pub event Deposit(id: UInt64, to: Address?)

    // paths
    pub let collectionStoragePath: StoragePath
    pub let collectionPublicPath: PublicPath
    pub let collectionPrivatePath: PrivatePath
    pub let adminStoragePath: StoragePath
    pub let saleCollectionStoragePath: StoragePath
    pub let saleCollectionPublicPath: PublicPath

    // -----------------------------------------------------------------------
    // SGKCLDR_conan contract-level fields.
    // These contain actual values that are stored in the smart contract.
    // -----------------------------------------------------------------------

    // fields for Item-related
    //
    // variable size dictionary of Item resources
    access(self) var items: @{UInt32: Item}

    // The ID that is used to create Items.
    pub var nextItemID: UInt32

    // fields for Collectible-related
    //
    // Total number of CollectibleData NFTs that have been minted ever.
    pub var totalSupply: UInt64

    // -----------------------------------------------------------------------
    // SGKCLDR_conan contract-level Composite Type definitions
    // -----------------------------------------------------------------------

    // The structure that represents Item
    // each digital content which SGKCLDR_conan deal with on Flow
    //
    pub struct ItemData {

        pub let itemID: UInt32

        pub let metadata: {String: String}

        init(itemID: UInt32) {
            let item = (&SGKCLDR_conan.items[itemID] as &Item?)!

            self.itemID = item.itemID
            self.metadata = item.metadata
        }
   }

    // Item is a resource type that contains the functions to mint Collectibles.
    //
    // It is stored in a private field in the contract so that
    // the admin resource can call its methods and that there can be
    // public getters for some of its fields
    //
    // The admin can mint Collectibles that refer from Item.
    pub resource Item {

        // unique ID for the Item
        pub let itemID: UInt32

        // Stores all the metadata about the item as a string mapping
        // This is not the long term way NFT metadata will be stored. It's a temporary
        // construct while we figure out a better way to do metadata.
        //
        pub let metadata: {String: String}

        // The number of Collectibles that have been minted per Item.
        access(contract) var numberMintedPerItem: UInt32

        init(metadata: {String: String}) {
            pre {
                metadata.length != 0: "New Item metadata cannot be empty"
            }
            self.itemID = SGKCLDR_conan.nextItemID
            self.metadata = metadata
            self.numberMintedPerItem = 0

            // increment the nextItemID so that it isn't used again
            SGKCLDR_conan.nextItemID = SGKCLDR_conan.nextItemID + 1

            emit ItemCreated(id: self.itemID, metadata: metadata)
        }

        // mintCollectible mints a new Collectible and returns the newly minted Collectible
        //
        // Returns: The NFT that was minted
        //
        pub fun mintCollectible(): @NFT {
            // get the number of Collectibles that have been minted for this Item
            // to use as this Collectible's serial number
            let numInItem = self.numberMintedPerItem

            // mint the new Collectible
            let newCollectible: @NFT <- create NFT(serialNumber: numInItem + 1,
                                              itemID: self.itemID)

            // Increment the count of Collectibles minted for this Item
            self.numberMintedPerItem = numInItem + 1

            return <-newCollectible
        }

        // batchMintCollectible mints an arbitrary quantity of Collectibles
        // and returns them as a Collection
        //
        // Parameters: itemID: the ID of the Item that the Collectibles are minted for
        //             quantity: The quantity of Collectibles to be minted
        //
        // Returns: Collection object that contains all the Collectibles that were minted
        //
        pub fun batchMintCollectible(quantity: UInt64): @Collection {
            let newCollection <- create Collection()

            var i: UInt64 = 0
            while i < quantity {
                newCollection.deposit(token: <-self.mintCollectible())
                i = i + 1
            }

            return <-newCollection
        }

        // Returns: the number of Collectibles
        pub fun getNumberMinted(): UInt32 {
            return self.numberMintedPerItem
        }
    }

    // The structure holds metadata of an Collectible
    pub struct CollectibleData {
        // The ID of the Item that the Collectible references
        pub let itemID: UInt32

        // The place in the Item that this Collectible was minted
        pub let serialNumber: UInt32

        init(itemID: UInt32, serialNumber: UInt32) {
            self.itemID = itemID
            self.serialNumber = serialNumber
        }
    }

    // The resource that represents the CollectibleData NFTs
    //
    pub resource NFT: NonFungibleToken.INFT, Anique.INFT {

        // Global unique collectibleData ID
        pub let id: UInt64

        // Struct of Collectible metadata
        pub let data: CollectibleData

        init(serialNumber: UInt32, itemID: UInt32) {
            // Increment the global Collectible IDs
            SGKCLDR_conan.totalSupply = SGKCLDR_conan.totalSupply + 1

            // set id
            self.id = SGKCLDR_conan.totalSupply

            // Set the metadata struct
            self.data = CollectibleData(itemID: itemID, serialNumber: serialNumber)

            emit CollectibleMinted(collectibleID: self.id, itemID: itemID, serialNumber: self.data.serialNumber)
        }

        destroy() {
            emit CollectibleDestroyed(collectibleID: self.id)
        }
    }

    // interface that represents SGKCLDR_conan collections to public
    // extends of NonFungibleToken.CollectionPublic
    pub resource interface CollectionPublic {

        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT

        // deposit multi tokens
        pub fun batchDeposit(tokens: @Anique.Collection)

        // contains NFT
        pub fun contains(id: UInt64): Bool

        // borrow NFT as SGKCLDR_conan token
        pub fun borrowSGKCLDR_conanCollectible(id: UInt64): auth &NFT
    }

    // Collection is a resource that every user who owns NFTs
    // will store in their account to manage their NFTs
    //
    pub resource Collection: CollectionPublic, NonFungibleToken.Receiver, NonFungibleToken.Provider, NonFungibleToken.CollectionPublic {
        // Dictionary of CollectibleData conforming tokens
        // NFT is a resource type with a UInt64 ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init() {
            self.ownedNFTs <- {}
        }

        // withdraw removes a Collectible from the Collection and moves it to the caller
        //
        // Parameters: withdrawID: The ID of the NFT
        // that is to be removed from the Collection
        //
        // returns: @NonFungibleToken.NFT the token that was withdrawn
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {

            // Remove the nft from the Collection
            let token <- self.ownedNFTs.remove(key: withdrawID)
                ?? panic("Cannot withdraw: Collectible does not exist in the collection")

            emit Withdraw(id: token.id, from: self.owner?.address)

            // Return the withdrawn token
            return <- token
        }

        // batchWithdraw withdraws multiple tokens and returns them as a Collection
        //
        // Parameters: collectibleIds: An array of IDs to withdraw
        //
        // Returns: @NonFungibleToken.Collection: A collection that contains
        //                                        the withdrawn collectibles
        //
        pub fun batchWithdraw(collectibleIds: [UInt64]): @Anique.Collection {
            // Create a new empty Collection
            var batchCollection <- create Collection()

            // Iterate through the collectibleIds and withdraw them from the Collection
            for collectibleID in collectibleIds {
                batchCollection.deposit(token: <-self.withdraw(withdrawID: collectibleID))
            }

            // Return the withdrawn tokens
            return <-batchCollection
        }

        // deposit takes a Collectible and adds it to the Collections dictionary
        //
        // Parameters: token: the NFT to be deposited in the collection
        //
        pub fun deposit(token: @NonFungibleToken.NFT) {

            // Cast the deposited token as an SGKCLDR_conan NFT to make sure
            // it is the correct type
            let token <- token as! @SGKCLDR_conan.NFT

            // Get the token's ID
            let id = token.id

            // Add the new token to the dictionary
            let oldToken <- self.ownedNFTs[id] <- token

            // Only emit a deposit event if the Collection
            // is in an account's storage
            if self.owner?.address != nil {
                emit Deposit(id: id, to: self.owner?.address)
            }

            // Destroy the empty old token that was "removed"
            destroy oldToken
        }

        // batchDeposit takes a Collection object as an argument
        // and deposits each contained NFT into this Collection
        pub fun batchDeposit(tokens: @Anique.Collection) {

            // Get an array of the IDs to be deposited
            let keys = tokens.getIDs()

            // Iterate through the keys in the collection and deposit each one
            for key in keys {
                self.deposit(token: <-tokens.withdraw(withdrawID: key))
            }

            // Destroy the empty Collection
            destroy tokens
        }

        // getIDs returns an array of the IDs that are in the Collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // contains returns whether ID is in the Collection
        pub fun contains(id: UInt64): Bool {
            return self.ownedNFTs[id] != nil
        }

        // borrowNFT Returns a borrowed reference to a Collectible in the Collection
        // so that the caller can read its ID
        //
        // Parameters: id: The ID of the NFT to get the reference for
        //
        // Returns: A reference to the NFT
        //
        // Note: This only allows the caller to read the ID of the NFT,
        // not any SGKCLDR_conan specific data. Please use borrowCollectible to
        // read Collectible data.
        //
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowAniqueNFT(id: UInt64): auth &Anique.NFT {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            return nft as! auth &Anique.NFT
        }

        // borrowSGKCLDR_conanCollectible returns a borrowed reference
        // to an SGKCLDR_conan Collectible
        pub fun borrowSGKCLDR_conanCollectible(id: UInt64): auth &NFT {
            pre {
                self.ownedNFTs[id] != nil: "NFT does not exist in the collection!"
            }
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            return nft as! auth &NFT
        }

        // If a transaction destroys the Collection object,
        // All the NFTs contained within are also destroyed!
        //
        destroy() {
            destroy self.ownedNFTs
        }
    }

    // Admin is a special authorization resource that
    // allows the owner to perform important functions to modify the
    // various aspects of the Items, CollectibleDatas, etc.
    //
    pub resource Admin {

        // createItem creates a new Item struct
        // and stores it in the Items dictionary field in the SGKCLDR_conan smart contract
        //
        // Parameters: metadata: A dictionary mapping metadata titles to their data
        //                       example: {"Title": "Excellent Anime", "Author": "John Smith"}
        //
        // Returns: the ID of the new Item object
        //
        pub fun createItem(metadata: {String: String}): UInt32 {
            // Create the new Item
            var newItem <- create Item(metadata: metadata)
            let itemId = newItem.itemID

            // Store it in the contract storage
            SGKCLDR_conan.items[newItem.itemID] <-! newItem

            return itemId
        }

        // borrowItem returns a reference to a Item in the SGKCLDR_conan
        // contract so that the admin can call methods on it
        //
        // Parameters: itemID: The ID of the Item that you want to
        // get a reference to
        //
        // Returns: A reference to the Item with all of the fields
        // and methods exposed
        //
        pub fun borrowItem(itemID: UInt32): &Item {
            pre {
                SGKCLDR_conan.items[itemID] != nil: "Cannot borrow Item: The Item doesn't exist"
            }

            return (&SGKCLDR_conan.items[itemID] as &Item?)!
        }

        // createNewAdmin creates a new Admin resource
        //
        pub fun createNewAdmin(): @Admin {
            return <-create Admin()
        }
    }

    // -----------------------------------------------------------------------
    // SGKCLDR_conan contract-level function definitions
    // -----------------------------------------------------------------------

    // createEmptyCollection creates a new, empty Collection object so that
    // a user can store it in their account storage.
    // Once they have a Collection in their storage, they are able to receive
    // Collectibles in transactions.
    //
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <-create SGKCLDR_conan.Collection()
    }

    // getNumCollectiblesInItem return the number of Collectibles that have been
    //                        minted from a certain Item.
    //
    // Parameters: itemID: The id of the Item that is being searched
    //
    // Returns: The total number of Collectibles
    //          that have been minted from a Item
    pub fun getNumCollectiblesInItem(itemID: UInt32): UInt32 {
        let item = (&SGKCLDR_conan.items[itemID] as &Item?)!
        return item.numberMintedPerItem
    }

    // -----------------------------------------------------------------------
    // SGKCLDR_conan initialization function
    // -----------------------------------------------------------------------
    //
    init() {
        // Initialize contract fields
        self.items <- {}
        self.nextItemID = 1
        self.totalSupply = 0

        self.collectionStoragePath     = /storage/SGKCLDR_conanCollection
        self.collectionPublicPath      =  /public/SGKCLDR_conanCollection
        self.collectionPrivatePath     = /private/SGKCLDR_conanCollection
        self.adminStoragePath          = /storage/SGKCLDR_conanAdmin
        self.saleCollectionStoragePath = /storage/SGKCLDR_conanSaleCollection
        self.saleCollectionPublicPath  =  /public/SGKCLDR_conanSaleCollection

        // Put a new Collection in storage
        self.account.save<@Collection>(<- create Collection(), to: self.collectionStoragePath)

        // Create a public capability for the Collection
        self.account.link<&{CollectionPublic}>(self.collectionPublicPath, target: self.collectionStoragePath)

        // Put the Admin in storage
        self.account.save<@Admin>(<- create Admin(), to: self.adminStoragePath)

        emit ContractInitialized()
    }
}
"
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract RedSquirrelNFT: NonFungibleToken {

    pub var totalSupply: UInt64

    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath

    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        pub let id: UInt64

        pub let name: String
        pub let description: String
        pub let thumbnail: String

        init(
            id: UInt64,
            name: String,
            description: String,
            thumbnail: String,
        ) {
            self.id = id
            self.name = name
            self.description = description
            self.thumbnail = thumbnail
        }

        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                      name: self.name,
                      description: self.description,
                      thumbnail: MetadataViews.IPFSFile(
                          cid: self.thumbnail,
                          path: nil
                      )
                  )
            }

            return nil
        }
    }

    pub resource interface RedSquirrelNFTCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowRedSquirrelNFT(id: UInt64): &RedSquirrelNFT.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow RedSquirrelNFT reference: the ID of the returned reference is incorrect"
            }
        }
    }

    pub resource Collection: RedSquirrelNFTCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with an `UInt64` ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        // withdraw removes an NFT from the collection and moves it to the caller
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        // deposit takes a NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @RedSquirrelNFT.NFT

            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        // getIDs returns an array of the IDs that are in the collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT gets a reference to an NFT in the collection
        // so that the caller can read its metadata and call its methods
        // pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
        //     return &self.ownedNFTs[id] as &NonFungibleToken.NFT
        // }

        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?) ?? panic("nothing in this index")
        }

        pub fun borrowRedSquirrelNFT(id: UInt64): &RedSquirrelNFT.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorized reference to allow downcasting
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?) ?? panic("something1")
                return ref as! &RedSquirrelNFT.NFT
            }

            return nil
        }

        // pub fun borrowRedSquirrelNFT(id: UInt64): &NFT {
        //     let refNFT = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?) ?? panic("something1")
        //     return refNFT as! &NFT
        // }


        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?) ?? panic("something2")
            let redSquirrelNFT = nft as! &RedSquirrelNFT.NFT
            return redSquirrelNFT as &AnyResource{MetadataViews.Resolver}
        }


        destroy() {
            destroy self.ownedNFTs
        }
    }

    // public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    // Resource that an admin or something similar would own to be
    // able to mint new NFTs
    //
    pub resource NFTMinter {

        // mintNFT mints a new NFT with a new ID
        // and deposit it in the recipients collection using their collection reference
        pub fun mintNFT(
            recipient: &{NonFungibleToken.CollectionPublic},
            name: String,
            description: String,
            thumbnail: String,
        ) {

            // create a new NFT
            var newNFT <- create NFT(
                id: RedSquirrelNFT.totalSupply,
                name: name,
                description: description,
                thumbnail: thumbnail,
            )

            // deposit it in the recipient's account using their reference
            recipient.deposit(token: <-newNFT)

            RedSquirrelNFT.totalSupply = RedSquirrelNFT.totalSupply + UInt64(1)
        }
    }

    init() {
        // Initialize the total supply
        self.totalSupply = 0

        // Set the named paths
        self.CollectionStoragePath = /storage/redSquirrelNFTCollection
        self.CollectionPublicPath = /public/redSquirrelNFTCollection
        self.MinterStoragePath = /storage/redSquirrelNFTMinter

        // Create a Collection resource and save it to storage
        let collection <- create Collection()
        self.account.save(<-collection, to: self.CollectionStoragePath)

        // create a public capability for the collection
        self.account.link<&RedSquirrelNFT.Collection{NonFungibleToken.CollectionPublic, RedSquirrelNFT.RedSquirrelNFTCollectionPublic}>(
            self.CollectionPublicPath,
            target: self.CollectionStoragePath
        )

        // Create a Minter resource and save it to storage
        let minter <- create NFTMinter()
        self.account.save(<-minter, to: self.MinterStoragePath)

        emit ContractInitialized()
    }
}"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import FungibleTokenMetadataViews from 0xf233dcee88fe0abe
import MetadataViews from 0x1d7e57aa55817448
import Toucans from 0x577a3c409c5dcb5e
import ToucansTokens from 0x577a3c409c5dcb5e

pub contract SloppyStakes: FungibleToken {

    // The amount of tokens in existance
    pub var totalSupply: UFix64
    // nil if there is none
    pub let maxSupply: UFix64?

    // Paths
    pub let VaultStoragePath: StoragePath
    pub let ReceiverPublicPath: PublicPath
    pub let VaultPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath
    pub let AdministratorStoragePath: StoragePath

    // Events
    pub event TokensInitialized(initialSupply: UFix64)
    pub event TokensWithdrawn(amount: UFix64, from: Address?)
    pub event TokensDeposited(amount: UFix64, to: Address?)
    pub event TokensTransferred(amount: UFix64, from: Address, to: Address)
    pub event TokensMinted(amount: UFix64)
    pub event TokensBurned(amount: UFix64)

    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance, MetadataViews.Resolver {
        pub var balance: UFix64

        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)

            if let owner: Address = self.owner?.address {
                SloppyStakes.setBalance(address: owner, balance: self.balance)
            }
            return <- create Vault(balance: amount)
        }

        pub fun deposit(from: @FungibleToken.Vault) {
            let vault: @Vault <- from as! @Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)

            // We set the balance to 0.0 here so that it doesn't
            // decrease the totalSupply in the `destroy` function.
            vault.balance = 0.0
            destroy vault

            if let owner: Address = self.owner?.address {
                SloppyStakes.setBalance(address: owner, balance: self.balance)
            }
        }

        pub fun getViews(): [Type]{
            return [Type<FungibleTokenMetadataViews.FTView>(),
                    Type<FungibleTokenMetadataViews.FTDisplay>(),
                    Type<FungibleTokenMetadataViews.FTVaultData>()]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<FungibleTokenMetadataViews.FTView>():
                    return FungibleTokenMetadataViews.FTView(
                        ftDisplay: self.resolveView(Type<FungibleTokenMetadataViews.FTDisplay>()) as! FungibleTokenMetadataViews.FTDisplay?,
                        ftVaultData: self.resolveView(Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
                    )
                case Type<FungibleTokenMetadataViews.FTDisplay>():
                    let media = MetadataViews.Media(
                            file: MetadataViews.HTTPFile(
                            url: "https://nftstorage.link/ipfs/bafkreiem3taknzwhh33ux5hhsimqytzxjet2lnpfbcbmbs2j7pq35f2uoq"
                        ),
                        mediaType: "image"
                    )
                    let bannerMedia = MetadataViews.Media(
                            file: MetadataViews.HTTPFile(
                            url: "https://nftstorage.link/ipfs/bafkreidck2jl36rjwpgu6xwfdcn43xyedrviujd43ux7dnswjmy7yyp5ve"
                        ),
                        mediaType: "image"
                    )
                    let medias = MetadataViews.Medias([media, bannerMedia])
                    return FungibleTokenMetadataViews.FTDisplay(
                        name: "Sloppy Stakes",
                        symbol: "LOPPY",
                        description: "A DAO for everyone who used to be a piece of shit",
                        externalURL: MetadataViews.ExternalURL("find.xyz/alxo"),
                        logos: medias,
                        socials: {
                            "twitter": MetadataViews.ExternalURL("alxocity"),
                            "discord": MetadataViews.ExternalURL("GYV8JRR")
                        }
                    )
                case Type<FungibleTokenMetadataViews.FTVaultData>():
                    return FungibleTokenMetadataViews.FTVaultData(
                        storagePath: SloppyStakes.VaultStoragePath,
                        receiverPath: SloppyStakes.ReceiverPublicPath,
                        metadataPath: SloppyStakes.VaultPublicPath,
                        providerPath: /private/SloppyStakesVault,
                        receiverLinkedType: Type<&Vault{FungibleToken.Receiver}>(),
                        metadataLinkedType: Type<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(),
                        providerLinkedType: Type<&Vault{FungibleToken.Provider}>(),
                        createEmptyVaultFunction: (fun (): @Vault {
                            return <- SloppyStakes.createEmptyVault()
                        })
                    )
            }
            return nil
        }

        init(balance: UFix64) {
            self.balance = balance
        }

        destroy() {
            emit TokensBurned(amount: self.balance)
            SloppyStakes.totalSupply = SloppyStakes.totalSupply - self.balance
        }
    }

    pub fun createEmptyVault(): @Vault {
        return <- create Vault(balance: 0.0)
    }

    pub resource Minter: Toucans.Minter {
        pub fun mint(amount: UFix64): @Vault {
            post {
                SloppyStakes.maxSupply == nil || SloppyStakes.totalSupply <= SloppyStakes.maxSupply!:
                    "Exceeded the max supply of tokens allowd."
            }
            SloppyStakes.totalSupply = SloppyStakes.totalSupply + amount
            emit TokensMinted(amount: amount)
            return <- create Vault(balance: amount)
        }
    }

    // We follow this pattern of storage
    // so the (potentially) huge dictionary
    // isn't loaded when the contract is imported
    pub resource Administrator {
        // This is an experimental index and should
        // not be used for anything official
        // or monetary related
        access(self) let balances: {Address: UFix64}

        access(contract) fun setBalance(address: Address, balance: UFix64) {
            self.balances[address] = balance
        }

        pub fun getBalance(address: Address): UFix64 {
            return self.balances[address] ?? 0.0
        }

        pub fun getBalances(): {Address: UFix64} {
            return self.balances
        }

        init() {
            self.balances = {}
        }
    }

    access(contract) fun setBalance(address: Address, balance: UFix64) {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        admin.setBalance(address: address, balance: balance)
    }

    pub fun getBalance(address: Address): UFix64 {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalance(address: address)
    }

    pub fun getBalances(): {Address: UFix64} {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalances()
    }

    init(
      _paymentTokenInfo: ToucansTokens.TokenInfo,
      _editDelay: UFix64,
      _minting: Bool,
      _initialTreasurySupply: UFix64,
      _maxSupply: UFix64?,
      _extra: {String: AnyStruct}
    ) {

      // Contract Variables
      self.totalSupply = 0.0
      self.maxSupply = _maxSupply

      // Paths
      self.VaultStoragePath = /storage/SloppyStakesVault
      self.ReceiverPublicPath = /public/SloppyStakesReceiver
      self.VaultPublicPath = /public/SloppyStakesMetadata
      self.MinterStoragePath = /storage/SloppyStakesMinter
      self.AdministratorStoragePath = /storage/SloppyStakesAdmin

      // Admin Setup
      let vault <- create Vault(balance: self.totalSupply)
      self.account.save(<- vault, to: self.VaultStoragePath)

      self.account.link<&Vault{FungibleToken.Receiver}>(
          self.ReceiverPublicPath,
          target: self.VaultStoragePath
      )

      self.account.link<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(
          self.VaultPublicPath,
          target: self.VaultStoragePath
      )

      if self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath) == nil {
        self.account.save(<- Toucans.createCollection(), to: Toucans.CollectionStoragePath)
        self.account.link<&Toucans.Collection{Toucans.CollectionPublic}>(Toucans.CollectionPublicPath, target: Toucans.CollectionStoragePath)
      }

      let toucansProjectCollection = self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath)!
      toucansProjectCollection.createProject(
        projectTokenInfo: ToucansTokens.TokenInfo("SloppyStakes", self.account.address, "LOPPY", self.ReceiverPublicPath, self.VaultPublicPath, self.VaultStoragePath),
        paymentTokenInfo: _paymentTokenInfo,
        minter: <- create Minter(),
        editDelay: _editDelay,
        minting: _minting,
        initialTreasurySupply: _initialTreasurySupply,
        extra: _extra
      )

      self.account.save(<- create Administrator(), to: self.AdministratorStoragePath)

      // Events
      emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
 "
-------
"import NonFungibleToken from 0x1d7e57aa55817448

pub contract CryptoPoops: NonFungibleToken {
    pub var totalSupply: UInt64

    pub event ContractInitialized()

    pub event Withdraw(id: UInt64, from: Address?)

    pub event Deposit(id: UInt64, to: Address?)

    pub resource NFT: NonFungibleToken.INFT {
        pub let id: UInt64
        pub(set) var metadata: {String: String}

        init(metadata: {String: String}) {
            self.id = CryptoPoops.totalSupply
            CryptoPoops.totalSupply = CryptoPoops.totalSupply + (1 as UInt64)

            self.metadata = metadata
        }
    }

    pub resource interface MyCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowEntireNFT(id: UInt64): &NFT
    }

    pub resource Collection: NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MyCollectionPublic {
        // id of the NFT -> NFT with that id
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        pub fun deposit(token: @NonFungibleToken.NFT) {
            let cryptoPoop <- token as! @NFT
            emit Deposit(id: cryptoPoop.id, to:self.owner!.address)
            self.ownedNFTs[cryptoPoop.id] <-! cryptoPoop
        }

        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("This collection doesn't cotain nft with that id")
            emit Withdraw(id: withdrawID, from: self.owner?.address)
            return <- token
        }

        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?) ?? panic("nothing in this index")
        }

        pub fun borrowEntireNFT(id: UInt64): &NFT {
            let refNFT = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?) ?? panic("something")
            return refNFT as! &NFT
        }

        init() {
            self.ownedNFTs <- {}
        }

        destroy () {
            destroy self.ownedNFTs
        }
    }

    pub fun createEmptyCollection(): @Collection {
        return <- create Collection()
    }

    pub resource NFTMinter {
        pub fun createNFT(metadata: {String: String}): @NFT {
            let newNFT <- create NFT(metadata: metadata)
            return <- newNFT
        }

        init() {

        }
    }

    init() {
        self.totalSupply = 0
        emit ContractInitialized()

        self.account.save(<- create NFTMinter(), to: /storage/Minter)
    }
}"
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract RedSquirrelNFT: NonFungibleToken {

    pub var totalSupply: UInt64

    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath

    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        pub let id: UInt64

        pub let name: String
        pub let description: String
        pub let thumbnail: String

        init(
            id: UInt64,
            name: String,
            description: String,
            thumbnail: String,
        ) {
            self.id = id
            self.name = name
            self.description = description
            self.thumbnail = thumbnail
        }

        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                      name: self.name,
                      description: self.description,
                      thumbnail: MetadataViews.IPFSFile(
                          cid: self.thumbnail,
                          path: nil
                      )
                  )
            }

            return nil
        }
    }

    pub resource interface RedSquirrelNFTCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowRedSquirrelNFT(id: UInt64): &RedSquirrelNFT.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow RedSquirrelNFT reference: the ID of the returned reference is incorrect"
            }
        }
    }

    pub resource Collection: RedSquirrelNFTCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with an `UInt64` ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        // withdraw removes an NFT from the collection and moves it to the caller
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        // deposit takes a NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @RedSquirrelNFT.NFT

            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        // getIDs returns an array of the IDs that are in the collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT gets a reference to an NFT in the collection
        // so that the caller can read its metadata and call its methods
        // pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
        //     return &self.ownedNFTs[id] as &NonFungibleToken.NFT
        // }

        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?) ?? panic("nothing in this index")
        }

        pub fun borrowRedSquirrelNFT(id: UInt64): &RedSquirrelNFT.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorized reference to allow downcasting
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?) ?? panic("something1")
                return ref as! &RedSquirrelNFT.NFT
            }

            return nil
        }

        // pub fun borrowRedSquirrelNFT(id: UInt64): &NFT {
        //     let refNFT = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?) ?? panic("something1")
        //     return refNFT as! &NFT
        // }


        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?) ?? panic("something2")
            let redSquirrelNFT = nft as! &RedSquirrelNFT.NFT
            return redSquirrelNFT as &AnyResource{MetadataViews.Resolver}
        }


        destroy() {
            destroy self.ownedNFTs
        }
    }

    // public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    // Resource that an admin or something similar would own to be
    // able to mint new NFTs
    //
    pub resource NFTMinter {

        // mintNFT mints a new NFT with a new ID
        // and deposit it in the recipients collection using their collection reference
        pub fun mintNFT(
            recipient: &{NonFungibleToken.CollectionPublic},
            name: String,
            description: String,
            thumbnail: String,
        ) {

            // create a new NFT
            var newNFT <- create NFT(
                id: RedSquirrelNFT.totalSupply,
                name: name,
                description: description,
                thumbnail: thumbnail,
            )

            // deposit it in the recipient's account using their reference
            recipient.deposit(token: <-newNFT)

            RedSquirrelNFT.totalSupply = RedSquirrelNFT.totalSupply + UInt64(1)
        }
    }

    init() {
        // Initialize the total supply
        self.totalSupply = 0

        // Set the named paths
        self.CollectionStoragePath = /storage/redSquirrelNFTCollection
        self.CollectionPublicPath = /public/redSquirrelNFTCollection
        self.MinterStoragePath = /storage/redSquirrelNFTMinter

        // Create a Collection resource and save it to storage
        let collection <- create Collection()
        self.account.save(<-collection, to: self.CollectionStoragePath)

        // create a public capability for the collection
        self.account.link<&RedSquirrelNFT.Collection{NonFungibleToken.CollectionPublic, RedSquirrelNFT.RedSquirrelNFTCollectionPublic}>(
            self.CollectionPublicPath,
            target: self.CollectionStoragePath
        )

        // Create a Minter resource and save it to storage
        let minter <- create NFTMinter()
        self.account.save(<-minter, to: self.MinterStoragePath)

        emit ContractInitialized()
    }
}"
-------
"/*
PAIPEPE

This is the contract for PAIPEPE NFTs!

This was implemented using Niftory interfaces. For full details on how this
contract functions, please see the Niftory and NFTRegistry contracts.

*/

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import ViewResolver from 0x1d7e57aa55817448

import MutableMetadata from 0x7ec1f607f0872a9e
import MutableMetadataTemplate from 0x7ec1f607f0872a9e
import MutableMetadataSet from 0x7ec1f607f0872a9e
import MutableMetadataSetManager from 0x7ec1f607f0872a9e
import MetadataViewsManager from 0x7ec1f607f0872a9e

import NiftoryNonFungibleToken from 0x7ec1f607f0872a9e
import NiftoryNFTRegistry from 0x7ec1f607f0872a9e

import NiftoryMetadataViewsResolvers from 0x7ec1f607f0872a9e
import NiftoryNonFungibleTokenProxy from 0x7ec1f607f0872a9e

pub contract PAIPEPE: NonFungibleToken, ViewResolver {

  // ========================================================================
  // Constants
  // ========================================================================

  // Suggested paths where collection could be stored
  pub let COLLECTION_PRIVATE_PATH: PrivatePath
  pub let COLLECTION_PUBLIC_PATH: PublicPath
  pub let COLLECTION_STORAGE_PATH: StoragePath

  // Accessor token to be used with NiftoryNFTRegistry to retrieve
  // meta-information about this NFT project
  pub let REGISTRY_ADDRESS: Address
  pub let REGISTRY_BRAND: String

  // ========================================================================
  // Attributes
  // ========================================================================

  // Arbitrary metadata for this NFT contract
  pub var metadata: AnyStruct?

  // Number of NFTs created
  pub var totalSupply: UInt64

  // ========================================================================
  // Contract Events
  // ========================================================================

  // This contract was initialized
  pub event ContractInitialized()

  // A withdrawal of NFT `id` has occurred from the `from` Address
  pub event Withdraw(id: UInt64, from: Address?)

  // A deposit of an NFT `id` has occurred to the `to` Address
  pub event Deposit(id: UInt64, to: Address?)

  ///////////////////////////////////////////////////////////////////////////

  // Contract metadata was modified
  pub event ContractMetadataUpdated()

  // Metadata Views Manager was locked
  pub event MetadataViewsManagerLocked()

  // Metadata Views Resolver was added
  pub event MetadataViewsResolverAdded(type: Type)

  // Metadata Views Resolver was removed
  pub event MetadataViewsResolverRemoved(type: Type)

  // Set Manager Name or Description updated
  pub event SetManagerMetadataUpdated()

  // Set added to Set Manager
  pub event SetAddedToSetManager(setID: Int)

  ///////////////////////////////////////////////////////////////////////////

  // Set `setId` was locked (no new templates can be added)
  pub event SetLocked(setId: Int)

  // The metadata for Set `setId` was locked and cannot be modified
  pub event SetMetadataLocked(setId: Int)

  // Set `setId` was modified
  pub event SetMetadataModified(setId: Int)

  // A new Template `templateId` was added to Set `setId`
  pub event TemplateAddedToSet(setId: Int, templateId: Int)

  ///////////////////////////////////////////////////////////////////////////

  // Template `templateId` was locked in Set `setId`, which disables minting
  pub event TemplateLocked(setId: Int, templateId: Int)

  // Template `templateId` of Set `setId` had it's maxMint set to `maxMint`
  pub event TemplateMaxMintSet(setId: Int, templateId: Int, maxMint: UInt64)

  // Template `templateId` of Set `setId` has minted NFT with serial `serial`
  pub event NFTMinted(id: UInt64, setId: Int, templateId: Int, serial: UInt64)

  ///////////////////////////////////////////////////////////////////////////

  // The metadata for NFT/Template `templateId` of Set `setId` was locked
  pub event NFTMetadataLocked(setId: Int, templateId: Int)

  // The metadata for NFT/Template `templateId` of Set `setId` was modified
  pub event NFTMetadataModified(setId: Int, templateId: Int)

  ///////////////////////////////////////////////////////////////////////////

  // NFT `serial` from Template `templateId` of Set `setId` was burned
  pub event NFTBurned(setId: Int, templateId: Int, serial: UInt64)

  // ========================================================================
  // NFT
  // ========================================================================

  pub resource NFT:
    NonFungibleToken.INFT,
    MetadataViews.Resolver,
    NiftoryNonFungibleToken.NFTPublic
  {
    pub let id: UInt64
    pub let setId: Int
    pub let templateId: Int
    pub let serial: UInt64

    pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
      return PAIPEPE.contract()
    }

    pub fun set(): &MutableMetadataSet.Set{MutableMetadataSet.Public} {
      return self
        .contract()
        .getSetManagerPublic()
        .getSet(self.setId)
    }

    pub fun metadata(): &MutableMetadata.Metadata{MutableMetadata.Public} {
      return self
        .set()
        .getTemplate(self.templateId)
        .metadata()
    }

    pub fun getViews(): [Type] {
      return self
        .contract()
        .getMetadataViewsManagerPublic()
        .getViews()
    }

    pub fun resolveView(_ view: Type): AnyStruct? {
      let nftRef = &self as &{NiftoryNonFungibleToken.NFTPublic}
      return self
        .contract()
        .getMetadataViewsManagerPublic()
        .resolveView(view: view, nftRef: nftRef)
    }

    init(setId: Int, templateId: Int, serial: UInt64) {
      self.id = PAIPEPE.totalSupply
      PAIPEPE.totalSupply =
        PAIPEPE.totalSupply + 1
      self.setId = setId
      self.templateId = templateId
      self.serial = serial
    }

    destroy() {
      emit NFTBurned(
        setId: self.setId,
        templateId: self.templateId,
        serial: self.serial
      )
    }
  }

  // ========================================================================
  // Collection
  // ========================================================================

  pub resource Collection:
    NonFungibleToken.Provider,
    NonFungibleToken.Receiver,
    NonFungibleToken.CollectionPublic,
    MetadataViews.ResolverCollection,
    NiftoryNonFungibleToken.CollectionPublic,
    NiftoryNonFungibleToken.CollectionPrivate
  {
    pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

    pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
      return PAIPEPE.contract()
    }

    pub fun getIDs(): [UInt64] {
      return self.ownedNFTs.keys
    }

    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
      pre {
        self.ownedNFTs[id] != nil : "NFT "
          .concat(id.toString())
          .concat(" does not exist in collection.")
      }
      return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
    }

    pub fun borrow(id: UInt64): &NFT{NiftoryNonFungibleToken.NFTPublic} {
      pre {
        self.ownedNFTs[id] != nil : "NFT does not exist in collection."
      }
      let nftRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let fullNft = nftRef as! &NFT
      return fullNft
    }

    pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {
      pre {
        self.ownedNFTs[id] != nil : "NFT does not exist in collection."
      }
      let nftRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let fullNft = nftRef as! &NFT
      return fullNft
    }

    pub fun deposit(token: @NonFungibleToken.NFT) {
      let token <- token as! @PAIPEPE.NFT
      let id: UInt64 = token.id
      let oldToken <- self.ownedNFTs[id] <- token
      emit Deposit(id: id, to: self.owner?.address)
      destroy oldToken
    }

    pub fun depositBulk(tokens: @[NonFungibleToken.NFT]) {
      while tokens.length > 0 {
        let token <- tokens.removeLast() as! @PAIPEPE.NFT
        self.deposit(token: <-token)
      }
      destroy tokens
    }

    pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
      pre {
        self.ownedNFTs[withdrawID] != nil
          : "NFT "
            .concat(withdrawID.toString())
            .concat(" does not exist in collection.")
      }
      let token <-self.ownedNFTs.remove(key: withdrawID)!
      emit Withdraw(id: token.id, from: self.owner?.address)
      return <-token
    }

    pub fun withdrawBulk(withdrawIDs: [UInt64]): @[NonFungibleToken.NFT] {
      let tokens: @[NonFungibleToken.NFT] <- []
      while withdrawIDs.length > 0 {
        tokens.append(<- self.withdraw(withdrawID: withdrawIDs.removeLast()))
      }
      return <-tokens
    }

    init() {
      self.ownedNFTs <- {}
    }

    destroy() {
      destroy self.ownedNFTs
    }
  }

  pub fun createEmptyCollection(): @Collection {
    return <-create Collection()
  }

  // ========================================================================
  // Manager
  // ========================================================================

  pub resource Manager:
    NiftoryNonFungibleToken.ManagerPublic,
    NiftoryNonFungibleToken.ManagerPrivate
  {
    // ========================================================================
    // Public
    // ========================================================================

    pub fun metadata(): AnyStruct? {
      return PAIPEPE.metadata
    }

    pub fun getSetManagerPublic():
      &MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public}
    {
      return NiftoryNFTRegistry
        .getSetManagerPublic(
          PAIPEPE.REGISTRY_ADDRESS,
          PAIPEPE.REGISTRY_BRAND
        )
    }

    pub fun getMetadataViewsManagerPublic():
      &MetadataViewsManager.Manager{MetadataViewsManager.Public}
    {
      return NiftoryNFTRegistry
        .getMetadataViewsManagerPublic(
          PAIPEPE.REGISTRY_ADDRESS,
          PAIPEPE.REGISTRY_BRAND
        )
    }

    pub fun getNFTCollectionData(): MetadataViews.NFTCollectionData {
      return NiftoryNFTRegistry
        .buildNFTCollectionData(
          PAIPEPE.REGISTRY_ADDRESS,
          PAIPEPE.REGISTRY_BRAND,
          (fun (): @NonFungibleToken.Collection {
            return <-PAIPEPE.createEmptyCollection()
          })
        )
    }

    // ========================================================================
    // Contract metadata
    // ========================================================================

    pub fun modifyContractMetadata(): auth &AnyStruct {
      emit ContractMetadataUpdated()
      let maybeMetadata = PAIPEPE.metadata
      if maybeMetadata == nil {
        let blankMetadata: {String: String} = {}
        PAIPEPE.metadata = blankMetadata
      }
      return (&PAIPEPE.metadata as auth &AnyStruct?)!
    }

    pub fun replaceContractMetadata(_ metadata: AnyStruct?) {
      emit ContractMetadataUpdated()
      PAIPEPE.metadata = metadata
    }

    // ========================================================================
    // Metadata Views Manager
    // ========================================================================

    access(self) fun _getMetadataViewsManagerPrivate():
      &MetadataViewsManager.Manager{MetadataViewsManager.Private}
    {
      let record =
        NiftoryNFTRegistry.getRegistryRecord(
          PAIPEPE.REGISTRY_ADDRESS,
          PAIPEPE.REGISTRY_BRAND
        )
      let manager =
        PAIPEPE.account
          .getCapability<&MetadataViewsManager.Manager{MetadataViewsManager.Private}>(
            record.metadataViewsManager.paths.private
          ).borrow()!
      return manager
    }

    pub fun lockMetadataViewsManager() {
      self._getMetadataViewsManagerPrivate().lock()
      emit MetadataViewsManagerLocked()
    }

    pub fun setMetadataViewsResolver(
      _ resolver: AnyStruct{MetadataViewsManager.Resolver}
    ) {
      self._getMetadataViewsManagerPrivate().addResolver(resolver)
      emit MetadataViewsResolverAdded(type: resolver.type)
    }

    pub fun removeMetadataViewsResolver(_ type: Type) {
      self._getMetadataViewsManagerPrivate().removeResolver(type)
      emit MetadataViewsResolverRemoved(type: type)
    }

    // ========================================================================
    // Set Manager
    // ========================================================================

    access(self) fun _getSetManagerPrivate():
      &MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public, MutableMetadataSetManager.Private}
    {
      let record =
        NiftoryNFTRegistry.getRegistryRecord(
          PAIPEPE.REGISTRY_ADDRESS,
          PAIPEPE.REGISTRY_BRAND
        )
      let setManager =
        PAIPEPE.account
          .getCapability<&MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public, MutableMetadataSetManager.Private}>(
            record.setManager.paths.private
          ).borrow()!
      return setManager
    }

    pub fun setMetadataManagerName(_ name: String) {
      self._getSetManagerPrivate().setName(name)
      emit SetManagerMetadataUpdated()
    }

    pub fun setMetadataManagerDescription(_ description: String) {
      self._getSetManagerPrivate().setDescription(description)
      emit SetManagerMetadataUpdated()
    }

    pub fun addSet(_ set: @MutableMetadataSet.Set) {
      let setManager = self._getSetManagerPrivate()
      let setId = setManager.numSets()
      setManager.addSet(<-set)
      emit SetAddedToSetManager(setID: setId)
    }

    // ========================================================================
    // Set
    // ========================================================================

    access(self) fun _getSetMutable(_ setId: Int):
      &MutableMetadataSet.Set{MutableMetadataSet.Private,
        MutableMetadataSet.Public} {
      return self._getSetManagerPrivate().getSetMutable(setId)
    }

    pub fun lockSet(setId: Int) {
      self._getSetMutable(setId).lock()
      emit SetLocked(setId: setId)
    }

    pub fun lockSetMetadata(setId: Int) {
      self._getSetMutable(setId).metadataMutable().lock()
      emit SetMetadataLocked(setId: setId)
    }

    pub fun modifySetMetadata(setId: Int): auth &AnyStruct {
      emit SetMetadataModified(setId: setId)
      return self._getSetMutable(setId).metadataMutable().getMutable()
    }

    pub fun replaceSetMetadata(setId: Int, new: AnyStruct) {
      self._getSetMutable(setId).metadataMutable().replace(new)
      emit SetMetadataModified(setId: setId)
    }

    pub fun addTemplate(
      setId: Int,
      template: @MutableMetadataTemplate.Template
    ) {
      let set = self._getSetMutable(setId)
      let templateId = set.numTemplates()
      set.addTemplate(<-template)
      emit TemplateAddedToSet(setId: setId, templateId: templateId)
    }

    // ========================================================================
    // Minting
    // ========================================================================

    access(self) fun _getTemplateMutable(_ setId: Int, _ templateId: Int):
      &MutableMetadataTemplate.Template{MutableMetadataTemplate.Public,
        MutableMetadataTemplate.Private} {
      return self._getSetMutable(setId).getTemplateMutable(templateId)
    }

    pub fun lockTemplate(setId: Int, templateId: Int) {
      self._getTemplateMutable(setId, templateId).lock()
      emit TemplateLocked(setId: setId, templateId: templateId)
    }

    pub fun setTemplateMaxMint(setId: Int, templateId: Int, max: UInt64) {
      self._getTemplateMutable(setId, templateId).setMaxMint(max)
      emit TemplateMaxMintSet(
        setId: setId,
        templateId: templateId,
        maxMint: max
      )
    }

    pub fun mint(setId: Int, templateId: Int): @NonFungibleToken.NFT {
      let template = self._getTemplateMutable(setId, templateId)
      template.registerMint()
      let serial = template.minted()
      let nft <-create NFT(
        setId: setId,
        templateId: templateId,
        serial: serial
      )
      emit NFTMinted(
        id: nft.id,
        setId: setId,
        templateId: templateId,
        serial: serial
      )
      return <-nft
    }

    pub fun mintBulk(
      setId: Int,
      templateId: Int,
      numToMint: UInt64,
    ): @[NonFungibleToken.NFT] {
      pre {
        numToMint > 0: "Must mint at least one NFT"
      }
      let template = self._getTemplateMutable(setId, templateId)
      let nfts: @[NonFungibleToken.NFT] <- []
      var leftToMint = numToMint
      while leftToMint > 0 {
        template.registerMint()
        let serial = template.minted()
        let nft <-create NFT(
          setId: setId,
          templateId: templateId,
          serial: serial
        )
        emit NFTMinted(
          id: nft.id,
          setId: setId,
          templateId: templateId,
          serial: serial
        )
        nfts.append(<-nft)
        leftToMint = leftToMint - 1
      }
      return <-nfts
    }

    // ========================================================================
    // NFT metadata
    // ========================================================================

    access(self) fun _getNFTMetadata(_ setId: Int, _ templateId: Int):
      &MutableMetadata.Metadata{MutableMetadata.Public,
        MutableMetadata.Private
      } {
        return self._getTemplateMutable(setId, templateId).metadataMutable()
    }

    pub fun lockNFTMetadata(setId: Int, templateId: Int) {
      self._getNFTMetadata(setId, templateId).lock()
      emit NFTMetadataLocked(setId: setId, templateId: templateId)
    }

    pub fun modifyNFTMetadata(setId: Int, templateId: Int): auth &AnyStruct {
      emit NFTMetadataModified(setId: setId, templateId: templateId)
      return self._getNFTMetadata(setId, templateId).getMutable()
    }

    pub fun replaceNFTMetadata(setId: Int, templateId: Int, new: AnyStruct) {
      self._getNFTMetadata(setId, templateId).replace(new)
      emit NFTMetadataModified(setId: setId, templateId: templateId)
    }
  }

  // ========================================================================
  // Contract functions
  // ========================================================================

  pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
    return NiftoryNFTRegistry
      .getNFTManagerPublic(
        PAIPEPE.REGISTRY_ADDRESS,
        PAIPEPE.REGISTRY_BRAND
      )
  }

  pub fun getViews(): [Type] {
    let possibleViews = [
      Type<MetadataViews.NFTCollectionDisplay>(),
      Type<MetadataViews.ExternalURL>()
    ]
    let views: [Type] = [Type<MetadataViews.NFTCollectionData>()]

    let viewManager = self.contract().getMetadataViewsManagerPublic()
    for view in possibleViews {
      if viewManager.inspectView(view: view) != nil {
        views.append(view)
      }
    }
    return views
  }

  pub fun resolveView(_ view: Type): AnyStruct? {
    let viewManager = self.contract().getMetadataViewsManagerPublic()
    switch view {

      case Type<MetadataViews.NFTCollectionData>():
        return self.contract().getNFTCollectionData()

      case Type<MetadataViews.NFTCollectionDisplay>():
        let maybeView = viewManager.inspectView(
          view: Type<MetadataViews.NFTCollectionDisplay>()
        )
        if maybeView == nil {
          return nil
        }
        let view = maybeView!

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver

          // External URL
          let externalURL = MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultExternalURLPrefix,
              uri: resolver.defaultExternalURL
            )
          )

          // Square image
          let squareImageURL = NiftoryMetadataViewsResolvers._prefixUri(
            allowedPrefixes:
              NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
            default: resolver.defaultSquareImagePrefix,
            uri: resolver.defaultSquareImage
          )
          let squareImageMediaType = resolver.defaultSquareImageMediaType
          let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: squareImageURL),
            mediaType: squareImageMediaType
          )

          // Banner image
          let bannerImageURL = NiftoryMetadataViewsResolvers._prefixUri(
            allowedPrefixes:
              NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
            default: resolver.defaultBannerImagePrefix,
            uri: resolver.defaultBannerImage
          )
          let bannerImageMediaType = resolver.defaultBannerImageMediaType
          let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
              url: bannerImageURL
            ),
            mediaType: bannerImageMediaType
          )

          return MetadataViews.NFTCollectionDisplay(
            name: resolver.defaultName,
            description: resolver.defaultDescription,
            externalURL: externalURL,
            squareImage: squareImage,
            bannerImage: bannerImage,
            socials: {}

          )
        }

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolverWithIpfsGateway>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolverWithIpfsGateway

          // External URL
          let externalURL = MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultExternalURLPrefix,
              uri: resolver.defaultExternalURL
            )
          )

          // Square image
          let squareImageURL = NiftoryMetadataViewsResolvers._useIpfsGateway(
            ipfsGateway: resolver.ipfsGateway,
            uri: NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultSquareImagePrefix,
              uri: resolver.defaultSquareImage
            )
        )
          let squareImageMediaType = resolver.defaultSquareImageMediaType
          let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: squareImageURL),
            mediaType: squareImageMediaType
          )

          // Banner image
          let bannerImageURL = NiftoryMetadataViewsResolvers._useIpfsGateway(
            ipfsGateway: resolver.ipfsGateway,
            uri: NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultBannerImagePrefix,
              uri: resolver.defaultBannerImage
            )
          )
          let bannerImageMediaType = resolver.defaultBannerImageMediaType
          let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
              url: bannerImageURL
            ),
            mediaType: bannerImageMediaType
          )

          return MetadataViews.NFTCollectionDisplay(
            name: resolver.defaultName,
            description: resolver.defaultDescription,
            externalURL: externalURL,
            squareImage: squareImage,
            bannerImage: bannerImage,
            socials: {}
          )
        }

        return nil

      case Type<MetadataViews.ExternalURL>():
        let maybeView = viewManager.inspectView(
          view: Type<MetadataViews.ExternalURL>()
        )
        if maybeView == nil {
          return nil
        }
        let view = maybeView!

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.ExternalURLResolver>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.ExternalURLResolver
          return MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultPrefix,
              uri: resolver.defaultURL
            )
          )
        }

        return nil
      }
      return nil

  }

  // ========================================================================
  // Init
  // ========================================================================

  init(
    nftManagerProxy: &{
      NiftoryNonFungibleTokenProxy.Public,
      NiftoryNonFungibleTokenProxy.Private
    }
  ) {

    let record = NiftoryNFTRegistry.generateRecord(
      account: self.account.address,
      project: "cli4qpeyl0001l20volmeonl0_PAIPEPE"
    )

    self.REGISTRY_ADDRESS = 0x32d62d5c43ad1038
    self.REGISTRY_BRAND = "cli4qpeyl0001l20volmeonl0_PAIPEPE"

    self.COLLECTION_PUBLIC_PATH = record.collectionPaths.public
    self.COLLECTION_PRIVATE_PATH = record.collectionPaths.private
    self.COLLECTION_STORAGE_PATH = record.collectionPaths.storage

    // No metadata to start with
    self.metadata = nil

    // Initialize the total supply to 0.
    self.totalSupply = 0

    // The Manager for this NFT
    //
    // NFT Manager storage
    let nftManager <- create Manager()

    // Save a MutableSetManager to this contract's storage, as the source of
    // this NFT contract's metadata.
    //
    // MutableMetadataSetManager storage
    self
      .account
      .save<@MutableMetadataSetManager.Manager>(
        <-MutableMetadataSetManager.create(
          name: "PAIPEPE",
          description: "The set manager for PAIPEPE."
        ),
        to: record.setManager.paths.storage
      )

    // MutableMetadataSetManager public
    self
      .account
      .link<&MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public}>(
        record.setManager.paths.public,
        target: record.setManager.paths.storage
      )

    // MutableMetadataSetManager private
    self
      .account
      .link<&
        MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public,
        MutableMetadataSetManager.Private
      }>(
        record.setManager.paths.private,
        target: record.setManager.paths.storage
      )

    // Save a MetadataViewsManager to this contract's storage, which will
    // allow observers to inspect standardized metadata through any of its
    // configured MetadataViews resolvers.
    //
    // MetadataViewsManager storage
    self
      .account
      .save<@MetadataViewsManager.Manager>(
        <-MetadataViewsManager.create(),
        to: record.metadataViewsManager.paths.storage
      )

    // MetadataViewsManager public
    self
      .account
      .link<&MetadataViewsManager.Manager{MetadataViewsManager.Public}>(
        record.metadataViewsManager.paths.public,
        target: record.metadataViewsManager.paths.storage
      )

    // MetadataViewsManager private
    self
      .account
      .link<&
        MetadataViewsManager.Manager{MetadataViewsManager.Private,
        MetadataViewsManager.Public
      }>(
        record.metadataViewsManager.paths.private,
        target: record.metadataViewsManager.paths.storage
      )

    let contractName = "PAIPEPE"

    // Royalties
    let royaltiesResolver = NiftoryMetadataViewsResolvers.RoyaltiesResolver(
        royalties: MetadataViews.Royalties([])
    )
    nftManager.setMetadataViewsResolver(royaltiesResolver)

    // Collection Data
    let collectionDataResolver
        = NiftoryMetadataViewsResolvers.NFTCollectionDataResolver()
    nftManager.setMetadataViewsResolver(collectionDataResolver)

    // Display
    let displayResolver = NiftoryMetadataViewsResolvers.DisplayResolver(
        "title",
        contractName.concat("NFT"),
        "description",
        contractName.concat(" NFT"),
        "mediaUrl",
        "ipfs://",
        "ipfs://bafybeig6la3me5x3veull7jzxmwle4sfuaguou2is3o3z44ayhe7ihlqpa/NiftoryBanner.png"
    )
    nftManager.setMetadataViewsResolver(displayResolver)

    // Collection Display
    let collectionResolver = NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver(
        "title",
        contractName,
        "description",
        contractName.concat(" Collection"),
        "domainUrl",
        "https://",
        "https://niftory.com",
        "squareImage",
        "ipfs://",
        "ipfs://bafybeihc76uodw2at2xi2l5jydpvscj5ophfpqgblbrmsfpeffhcmgdtl4/squareImage.png",
        "squareImageMediaType",
        "image/png",
        "bannerImage",
        "ipfs://",
        "ipfs://bafybeig6la3me5x3veull7jzxmwle4sfuaguou2is3o3z44ayhe7ihlqpa/NiftoryBanner.png",
        "bannerImageMediaType",
        "image/png",
        []
    )
    nftManager.setMetadataViewsResolver(collectionResolver)

    // ExternalURL
    let externalURLResolver = NiftoryMetadataViewsResolvers.ExternalURLResolver(
        "domainUrl",
        "https://",
        "https://niftory.com"
    )
    nftManager.setMetadataViewsResolver(externalURLResolver)

    // Save NFT Manager
    self
      .account
      .save<@Manager>(
        <-nftManager,
        to: record.nftManager.paths.storage
      )

    // NFT Manager public
    self
      .account
      .link<&{NiftoryNonFungibleToken.ManagerPublic}>(
        record.nftManager.paths.public,
        target: record.nftManager.paths.storage
      )

    // NFT Manager private
    self
      .account
      .link<&
        Manager{NiftoryNonFungibleToken.ManagerPublic,
        NiftoryNonFungibleToken.ManagerPrivate
      }>(
        record.nftManager.paths.private,
        target: record.nftManager.paths.storage
      )

      nftManagerProxy.add(
        registryAddress: self.REGISTRY_ADDRESS,
        brand: self.REGISTRY_BRAND,
        cap: self.account
              .getCapability<&{
                NiftoryNonFungibleToken.ManagerPrivate,
                NiftoryNonFungibleToken.ManagerPublic
              }>(
                record.nftManager.paths.private
              )
      )
  }
}"
-------
"import DigitalNativeArt from 0xa19cf4dba5941530

pub contract Atelier {

    pub enum Event: UInt8 {
        pub case creation
        pub case destruction
    }

    pub struct Record {
        pub let blockHeight: UInt64
        pub let timestamp: UFix64
        pub let event: Event
        pub let creations: UInt64
        pub let destructions: UInt64

        init(blockHeight: UInt64, timestamp: UFix64, event: Event, creations: UInt64, destructions: UInt64) {
            self.blockHeight = blockHeight
            self.timestamp = timestamp
            self.event = event
            self.creations = creations
            self.destructions = destructions
        }
    }

    pub var arts: @{UInt64: DigitalNativeArt.Art}
    pub var creations: UInt64
    pub var destructions: UInt64
    access(account) var records: [Record]

    pub fun createArt(): UInt64 {
        let art <- DigitalNativeArt.create()
        let uuid = art.uuid
        Atelier.arts[uuid] <-! art
        Atelier.creations = Atelier.creations + 1
        let block = getCurrentBlock()
        let record = Record(
            blockHeight: block.height,
            timestamp: block.timestamp,
            event: Event.creation,
            creations: self.creations,
            destructions: self.destructions
        )
        Atelier.records.insert(at: 0, record)
        return uuid
    }

    pub fun destroyArt(uuid: UInt64) {
        let art <- Atelier.arts.remove(key: uuid)!
        destroy art
        Atelier.destructions = Atelier.destructions + 1
        let block = getCurrentBlock()
        let record = Record(
            blockHeight: block.height,
            timestamp: block.timestamp,
            event: Event.destruction,
            creations: self.creations,
            destructions: self.destructions
        )
        Atelier.records.insert(at: 0, record)
    }

    pub fun withdrawArt(uuid: UInt64): @DigitalNativeArt.Art {
        return <- Atelier.arts.remove(key: uuid)!
    }

    pub fun getUUIDs(): [UInt64] {
        return Atelier.arts.keys
    }

    pub fun getRecords(from: Int, upTo: Int): [Record] {
        if from >= Atelier.records.length {
            return []
        }
        if upTo > Atelier.records.length {
            return Atelier.records.slice(from: from, upTo: Atelier.records.length)
        }
        return Atelier.records.slice(from: from, upTo: upTo)
    }

    init() {
        self.arts <- {}
        self.creations = 1
        self.destructions = 1
        self.records = []
    }
}
"
-------
"/**
  This contract contains the MFL Admin logic.The idea is that any account can create an adminProxy,
  but only an AdminRoot in possession of Claims can share them with that admin proxy (using private capabilities).
**/

pub contract MFLAdmin {

    // Events
    pub event ContractInitialized()
    pub event AdminRootCreated(by: Address?)

    // Named Paths
    pub let AdminRootStoragePath: StoragePath
    pub let AdminProxyStoragePath: StoragePath
    pub let AdminProxyPublicPath: PublicPath

    // MFL Royalty Address
    pub fun royaltyAddress(): Address {
        return 0xa654669bd96b2014
    }

    // Interface that an AdminProxy will expose to be able to receive Claims capabilites from an AdminRoot
    pub resource interface AdminProxyPublic {
        access(contract) fun setClaimCapability(name: String, capability: Capability)
    }

    pub resource AdminProxy: AdminProxyPublic {

        // Dictionary of all Claims Capabilities stored in an AdminProxy
        access(contract) let claimsCapabilities: {String: Capability}

        access(contract) fun setClaimCapability(name: String, capability: Capability) {
            self.claimsCapabilities[name] = capability
        }

        pub fun getClaimCapability(name: String): Capability? {
            return self.claimsCapabilities[name]
        }

        init() {
            self.claimsCapabilities = {}
        }
    }

    // Anyone can create an AdminProxy, but can't do anything without Claims capabilities,
    // and only an AdminRoot can provide that.
    pub fun createAdminProxy(): @AdminProxy {
        return <- create AdminProxy()
    }

    // Resource that an admin owns to be able to create new AdminRoot or to set Claims
	pub resource AdminRoot {

        // Create a new AdminRoot resource and returns it
        // Only if really needed ! One AdminRoot should be enough for all the logic in MFL
        pub fun createNewAdminRoot(): @AdminRoot {
            emit AdminRootCreated(by: self.owner?.address)
            return <- create AdminRoot()
        }

        // Set a Claim capabability for a given AdminProxy
        pub fun setAdminProxyClaimCapability(name: String, adminProxyRef: &{MFLAdmin.AdminProxyPublic}, newCapability: Capability) {
            adminProxyRef.setClaimCapability(name: name, capability: newCapability)
        }
	}

    init() {
        // Set our named paths
        self.AdminRootStoragePath = /storage/MFLAdminRoot
        self.AdminProxyStoragePath = /storage/MFLAdminProxy
        self.AdminProxyPublicPath = /public/MFLAdminProxy

        // Create an AdminRoot resource and save it to storage
        let adminRoot <- create AdminRoot()
        self.account.save(<- adminRoot, to: self.AdminRootStoragePath)

        emit ContractInitialized()
    }

}
"
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract RedSquirrelNFT: NonFungibleToken {

    pub var totalSupply: UInt64

    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath

    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        pub let id: UInt64

        pub let name: String
        pub let description: String
        pub let thumbnail: String

        init(
            id: UInt64,
            name: String,
            description: String,
            thumbnail: String,
        ) {
            self.id = id
            self.name = name
            self.description = description
            self.thumbnail = thumbnail
        }

        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                      name: self.name,
                      description: self.description,
                      thumbnail: MetadataViews.IPFSFile(
                          cid: self.thumbnail,
                          path: nil
                      )
                  )
            }

            return nil
        }
    }

    pub resource interface RedSquirrelNFTCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowRedSquirrelNFT(id: UInt64): &RedSquirrelNFT.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow RedSquirrelNFT reference: the ID of the returned reference is incorrect"
            }
        }
    }

    pub resource Collection: RedSquirrelNFTCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with an `UInt64` ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        // withdraw removes an NFT from the collection and moves it to the caller
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        // deposit takes a NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @RedSquirrelNFT.NFT

            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        // getIDs returns an array of the IDs that are in the collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT gets a reference to an NFT in the collection
        // so that the caller can read its metadata and call its methods
        // pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
        //     return &self.ownedNFTs[id] as &NonFungibleToken.NFT
        // }

        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?) ?? panic("nothing in this index")
        }

        // pub fun borrowRedSquirrelNFT(id: UInt64): &RedSquirrelNFT.NFT? {
        //     if self.ownedNFTs[id] != nil {
        //         // Create an authorized reference to allow downcasting
        //         let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT
        //         return ref as! &RedSquirrelNFT.NFT
        //     }

        //     return nil
        // }

        pub fun borrowRedSquirrelNFT(id: UInt64): &NFT {
            let refNFT = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?) ?? panic("something1")
            return refNFT as! &NFT
        }


        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?) ?? panic("something2")
            let redSquirrelNFT = nft as! &RedSquirrelNFT.NFT
            return redSquirrelNFT as &AnyResource{MetadataViews.Resolver}
        }

        // pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
        //     let nft <- self.ownedNFTs.remove(key: id)
        //     if nft == nil {
        //         panic("NFT does not exist")
        //     }
        //     let redSquirrelNFT = nft as! &RedSquirrelNFT.NFT
        //     self.ownedNFTs[id] <-! nft
        //     return redSquirrelNFT as &AnyResource{MetadataViews.Resolver}
        // }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    // public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    // Resource that an admin or something similar would own to be
    // able to mint new NFTs
    //
    pub resource NFTMinter {

        // mintNFT mints a new NFT with a new ID
        // and deposit it in the recipients collection using their collection reference
        pub fun mintNFT(
            recipient: &{NonFungibleToken.CollectionPublic},
            name: String,
            description: String,
            thumbnail: String,
        ) {

            // create a new NFT
            var newNFT <- create NFT(
                id: RedSquirrelNFT.totalSupply,
                name: name,
                description: description,
                thumbnail: thumbnail,
            )

            // deposit it in the recipient's account using their reference
            recipient.deposit(token: <-newNFT)

            RedSquirrelNFT.totalSupply = RedSquirrelNFT.totalSupply + UInt64(1)
        }
    }

    init() {
        // Initialize the total supply
        self.totalSupply = 0

        // Set the named paths
        self.CollectionStoragePath = /storage/redSquirrelNFTCollection
        self.CollectionPublicPath = /public/redSquirrelNFTCollection
        self.MinterStoragePath = /storage/redSquirrelNFTMinter

        // Create a Collection resource and save it to storage
        let collection <- create Collection()
        self.account.save(<-collection, to: self.CollectionStoragePath)

        // create a public capability for the collection
        self.account.link<&RedSquirrelNFT.Collection{NonFungibleToken.CollectionPublic, RedSquirrelNFT.RedSquirrelNFTCollectionPublic}>(
            self.CollectionPublicPath,
            target: self.CollectionStoragePath
        )

        // Create a Minter resource and save it to storage
        let minter <- create NFTMinter()
        self.account.save(<-minter, to: self.MinterStoragePath)

        emit ContractInitialized()
    }
}"
-------
"// Description: Smart Contract for Live Nation Virtual Commemorative Tickets
// SPDX-License-Identifier: UNLICENSED

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448


pub contract LNVCT : NonFungibleToken{
    pub var totalSupply: UInt64
    pub var maxEditionNumbersForShows: {String: UInt64}
    pub var name: String

    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath

    pub struct Rarity{
        pub let rarity: UFix64?
        pub let rarityName: String
        pub let parts: {String: RarityPart}

        init(rarity: UFix64?, rarityName: String, parts:{String:RarityPart}) {
            self.rarity=rarity
            self.rarityName=rarityName
            self.parts=parts
        }
    }

    pub struct RarityPart{
        pub let rarity: UFix64?
        pub let rarityName: String
        pub let name: String

        init(rarity: UFix64?, rarityName: String, name:String) {

            self.rarity=rarity
            self.rarityName=rarityName
            self.name=name
        }
    }

    pub resource interface NFTModifier {
        access(account) fun markAttendanceHelper(attendance: String)
        access(account) fun setURLMetadataHelper(newURL:String,newThumbnail:String)
        access(account) fun setRarityHelper(rarity:UFix64, rarityName:String, rarityValue:String)
        access(account) fun setEditionHelper(editionNumber:UInt64, maxEdition:UInt64)
        access(account) fun setMaxEditionForShowHelper(description:String, maxEdition:UInt64)
        access(account) fun setMetadataHelper(metadata_name: String, metadata_value: String)
    }

    pub resource NFT : NonFungibleToken.INFT, MetadataViews.Resolver, NFTModifier {
        pub let id: UInt64
        pub var link: String
        pub var batch: UInt32
        pub var sequence: UInt16
        pub var limit: UInt16
        pub var attendance: String
        pub var name: String
        pub var description: String
        pub var thumbnail: String

        pub var rarity: UFix64?
		pub var rarityName: String
        pub var rarityValue: String
		pub var parts: {String: RarityPart}

        pub var editionNumber: UInt64
        pub var maxEdition: UInt64?

        pub var metadata: {String: String}

        access(account) fun markAttendanceHelper(attendance: String) {
            self.attendance = attendance
            log("Attendance is set to: ")
            log(self.attendance)
        }

        access(account) fun setURLMetadataHelper(newURL:String,newThumbnail:String){
            self.link = newURL
            self.thumbnail = newThumbnail
            log("URL metadata is set to: ")
            log(self.link)
            log(self.thumbnail)
        }

        access(account) fun setRarityHelper(rarity:UFix64, rarityName:String, rarityValue:String)  {
            self.rarity = rarity
            self.rarityName = rarityName
            self.rarityValue = rarityValue

            self.parts = {rarityName:RarityPart(rarity: rarity, rarityName: rarityName, name:rarityValue)}

            log("Rarity metadata is updated")
        }

        access(account) fun setEditionHelper(editionNumber:UInt64, maxEdition:UInt64)  {
            self.editionNumber = editionNumber
            self.maxEdition = maxEdition

            log("Edition metadata is updated")
        }

        access(account) fun setMaxEditionForShowHelper(description:String, maxEdition:UInt64)  {
            LNVCT.maxEditionNumbersForShows.insert(key: description,maxEdition)
            log("Max Edition metadata for the Show is updated")
        }

        access(account) fun setMetadataHelper(metadata_name: String, metadata_value: String)  {
            self.metadata.insert(key: metadata_name, metadata_value)
            log("Custom Metadata store is updated")
        }

        init(
            initID: UInt64,
            initlink: String,
            initbatch: UInt32,
            initsequence: UInt16,
            initlimit: UInt16,
            name: String,
            description: String,
            thumbnail: String,
            editionNumber: UInt64,
            metadata:{ String: String }
        ) {
            self.id = initID
            self.link = initlink
            self.batch = initbatch
            self.sequence=initsequence
            self.limit=initlimit

            self.attendance = "null"

            self.name = name
            self.description = description
            self.thumbnail = thumbnail

            self.rarity = nil
            self.rarityName = "Tier"
            self.rarityValue= "null"
            self.parts = {self.rarityName:RarityPart(rarity: self.rarity, rarityName: self.rarityName, name:self.rarityValue)}
            self.editionNumber =editionNumber

            let containsShowName= LNVCT.maxEditionNumbersForShows.containsKey(description)

            if containsShowName{
                let currentMaxEditionValue = LNVCT.maxEditionNumbersForShows[description] ?? nil
                self.maxEdition = currentMaxEditionValue
            }
            else{
                self.maxEdition = nil
            }

            self.metadata = metadata
        }

        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.NFTCollectionData>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: LNVCT.CollectionStoragePath,
                        publicPath: LNVCT.CollectionPublicPath,
                        providerPath: /private/LNVCTCollection,
                        publicCollection: Type<&LNVCT.Collection{LNVCT.LNVCTCollectionPublic}>(),
                        publicLinkedType: Type<&LNVCT.Collection{LNVCT.LNVCTCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&LNVCT.Collection{LNVCT.LNVCTCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Provider, MetadataViews.ResolverCollection}>(),
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                            return <-LNVCT.createEmptyCollection()
                        })
                    )
            }

            return nil
        }
    }

    pub resource interface LNVCTCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowLNVCT(id: UInt64): &LNVCT.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow LNVCT reference: The ID of the returned reference is incorrect"
            }
        }
    }


    pub resource Collection: LNVCTCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID)!

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @LNVCT.NFT
            let id: UInt64 = token.id
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        destroy() {
            destroy self.ownedNFTs
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let exampleNFT = nft as! &LNVCT.NFT

            return exampleNFT as &AnyResource{MetadataViews.Resolver}
        }

        pub fun borrowLNVCT(id: UInt64): &LNVCT.NFT? {
            if self.ownedNFTs[id] == nil {
                return nil
            }
            else {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &LNVCT.NFT
            }
        }
    }

    pub fun createEmptyCollection(): @LNVCT.Collection {
        return <- create Collection()
    }

    pub resource NFTMinter {
        pub var minterID: UInt64

        init() {
            self.minterID = 0
        }

        pub fun mintNFT(
            glink: String,
            gbatch: UInt32,
            glimit: UInt16,
            gsequence: UInt16,
            name: String,
            description: String,
            thumbnail: String,
            editionNumber: UInt64,
            metadata: { String: String }
        ): @NFT {
            let tokenID = (UInt64(gbatch) << 32) | (UInt64(glimit) << 16) | UInt64(gsequence)
            var newNFT <- create NFT(initID: tokenID, initlink: glink, initbatch: gbatch, initsequence: gsequence, initlimit: glimit, name: name, description: description, thumbnail: thumbnail, editionNumber: editionNumber, metadata: metadata)
            self.minterID= tokenID

            LNVCT.totalSupply = LNVCT.totalSupply + 1

            return <-newNFT
        }
    }

    pub resource Modifier {
        pub var ModifierID: UInt64

        pub fun markAttendance(currentNFT: &LNVCT.NFT?, attendance: String) : String {
            let ref2 =  currentNFT!

            ref2.markAttendanceHelper(attendance: attendance)

            log("Attendance is set to: ")
            log(ref2.attendance)

            return ref2.attendance
        }

        pub fun setURLMetadata(currentNFT: &LNVCT.NFT?, newURL:String,newThumbnail:String) : String {
            let ref2 =  currentNFT!
            ref2.setURLMetadataHelper(newURL: newURL,newThumbnail:newThumbnail)

            log("URL metadata is set to: ")
            log(newURL)

            return newURL
        }

        pub fun setRarity(currentNFT: &LNVCT.NFT?, rarity:UFix64, rarityName:String, rarityValue:String)  {

            let ref2 =  currentNFT!
            ref2.setRarityHelper(rarity: rarity, rarityName: rarityName, rarityValue: rarityValue)

            log("Rarity metadata is updated")
        }


        pub fun setEdition(currentNFT: &LNVCT.NFT?, editionNumber:UInt64, maxEdition:UInt64)  {
            let ref2 =  currentNFT!

            ref2.setEditionHelper(editionNumber: editionNumber, maxEdition: maxEdition)

            log("Edition metadata is updated")
        }

        pub fun setMaxEditionForShow(description:String, maxEdition:UInt64)  {
            LNVCT.maxEditionNumbersForShows.insert(key: description,maxEdition)

            log("Max Edition metadata for the Show is updated")
        }

        pub fun setMetadata(currentNFT: &LNVCT.NFT?, metadata_name: String, metadata_value: String)  {
            let ref2 =  currentNFT!

            ref2.setMetadataHelper(metadata_name: metadata_name, metadata_value: metadata_value)

            log("Custom Metadata store is updated")
        }

        init() {
            self.ModifierID = 0
        }

    }
	init() {
        self.CollectionStoragePath = /storage/LNVCTCollection
        self.CollectionPublicPath = /public/LNVCTCollection
        self.MinterStoragePath = /storage/LNVCTMinter

        self.totalSupply = 0
        self.maxEditionNumbersForShows = {}
        self.name = "Live Nation Virtual Commemorative Tickets"

		self.account.save(<-self.createEmptyCollection(), to: self.CollectionStoragePath)
        self.account.link<&{LNVCT.LNVCTCollectionPublic}>(self.CollectionPublicPath, target: self.CollectionStoragePath)
        self.account.save(<-create NFTMinter(), to: self.MinterStoragePath)
        self.account.save(<-create Modifier(), to: /storage/LNVCTModifier)

        emit ContractInitialized()
	}
}

 "
-------
"import FungibleToken from 0xf233dcee88fe0abe
import FungibleTokenMetadataViews from 0xf233dcee88fe0abe
import MetadataViews from 0x1d7e57aa55817448
import Toucans from 0x577a3c409c5dcb5e
import ToucansTokens from 0x577a3c409c5dcb5e

pub contract QuitoForestMetaverseFC: FungibleToken {

    // The amount of tokens in existance
    pub var totalSupply: UFix64
    // nil if there is none
    pub let maxSupply: UFix64?

    // Paths
    pub let VaultStoragePath: StoragePath
    pub let ReceiverPublicPath: PublicPath
    pub let VaultPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath
    pub let AdministratorStoragePath: StoragePath

    // Events
    pub event TokensInitialized(initialSupply: UFix64)
    pub event TokensWithdrawn(amount: UFix64, from: Address?)
    pub event TokensDeposited(amount: UFix64, to: Address?)
    pub event TokensTransferred(amount: UFix64, from: Address, to: Address)
    pub event TokensMinted(amount: UFix64)
    pub event TokensBurned(amount: UFix64)

    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance, MetadataViews.Resolver {
        pub var balance: UFix64

        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)

            if let owner: Address = self.owner?.address {
                QuitoForestMetaverseFC.setBalance(address: owner, balance: self.balance)
            }
            return <- create Vault(balance: amount)
        }

        pub fun deposit(from: @FungibleToken.Vault) {
            let vault: @Vault <- from as! @Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)

            // We set the balance to 0.0 here so that it doesn't
            // decrease the totalSupply in the `destroy` function.
            vault.balance = 0.0
            destroy vault

            if let owner: Address = self.owner?.address {
                QuitoForestMetaverseFC.setBalance(address: owner, balance: self.balance)
            }
        }

        pub fun getViews(): [Type]{
            return [Type<FungibleTokenMetadataViews.FTView>(),
                    Type<FungibleTokenMetadataViews.FTDisplay>(),
                    Type<FungibleTokenMetadataViews.FTVaultData>()]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<FungibleTokenMetadataViews.FTView>():
                    return FungibleTokenMetadataViews.FTView(
                        ftDisplay: self.resolveView(Type<FungibleTokenMetadataViews.FTDisplay>()) as! FungibleTokenMetadataViews.FTDisplay?,
                        ftVaultData: self.resolveView(Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
                    )
                case Type<FungibleTokenMetadataViews.FTDisplay>():
                    let media = MetadataViews.Media(
                            file: MetadataViews.HTTPFile(
                            url: "https://nftstorage.link/ipfs/bafkreiaec2b3rvq73bwf3vaj2s4k3zeh5jzmgckuexwfenqbdf2kciwvr4"
                        ),
                        mediaType: "image"
                    )
                    let bannerMedia = MetadataViews.Media(
                            file: MetadataViews.HTTPFile(
                            url: "https://nftstorage.link/ipfs/bafkreifoj5i5mmcbiydzg4vgypg26tdmlxtahyaswyqfkvam3zvwbefhjm"
                        ),
                        mediaType: "image"
                    )
                    let medias = MetadataViews.Medias([media, bannerMedia])
                    return FungibleTokenMetadataViews.FTDisplay(
                        name: "Quito Forest Metaverse FC",
                        symbol: "QFMFC",
                        description: "A DAO for the ownership, investors, management and supporters of Quito Forest Metaverse Football Club, and all assets associated in the MFL platform.",
                        externalURL: MetadataViews.ExternalURL(""),
                        logos: medias,
                        socials: {
                            "twitter": MetadataViews.ExternalURL("QuitoForestMFC"),
                            "discord": MetadataViews.ExternalURL("Quito Forest MFC#0703")
                        }
                    )
                case Type<FungibleTokenMetadataViews.FTVaultData>():
                    return FungibleTokenMetadataViews.FTVaultData(
                        storagePath: QuitoForestMetaverseFC.VaultStoragePath,
                        receiverPath: QuitoForestMetaverseFC.ReceiverPublicPath,
                        metadataPath: QuitoForestMetaverseFC.VaultPublicPath,
                        providerPath: /private/QuitoForestMetaverseFCVault,
                        receiverLinkedType: Type<&Vault{FungibleToken.Receiver}>(),
                        metadataLinkedType: Type<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(),
                        providerLinkedType: Type<&Vault{FungibleToken.Provider}>(),
                        createEmptyVaultFunction: (fun (): @Vault {
                            return <- QuitoForestMetaverseFC.createEmptyVault()
                        })
                    )
            }
            return nil
        }

        init(balance: UFix64) {
            self.balance = balance
        }

        destroy() {
            emit TokensBurned(amount: self.balance)
            QuitoForestMetaverseFC.totalSupply = QuitoForestMetaverseFC.totalSupply - self.balance
        }
    }

    pub fun createEmptyVault(): @Vault {
        return <- create Vault(balance: 0.0)
    }

    pub resource Minter: Toucans.Minter {
        pub fun mint(amount: UFix64): @Vault {
            post {
                QuitoForestMetaverseFC.maxSupply == nil || QuitoForestMetaverseFC.totalSupply <= QuitoForestMetaverseFC.maxSupply!:
                    "Exceeded the max supply of tokens allowd."
            }
            QuitoForestMetaverseFC.totalSupply = QuitoForestMetaverseFC.totalSupply + amount
            emit TokensMinted(amount: amount)
            return <- create Vault(balance: amount)
        }
    }

    // We follow this pattern of storage
    // so the (potentially) huge dictionary
    // isn't loaded when the contract is imported
    pub resource Administrator {
        // This is an experimental index and should
        // not be used for anything official
        // or monetary related
        access(self) let balances: {Address: UFix64}

        access(contract) fun setBalance(address: Address, balance: UFix64) {
            self.balances[address] = balance
        }

        pub fun getBalance(address: Address): UFix64 {
            return self.balances[address] ?? 0.0
        }

        pub fun getBalances(): {Address: UFix64} {
            return self.balances
        }

        init() {
            self.balances = {}
        }
    }

    access(contract) fun setBalance(address: Address, balance: UFix64) {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        admin.setBalance(address: address, balance: balance)
    }

    pub fun getBalance(address: Address): UFix64 {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalance(address: address)
    }

    pub fun getBalances(): {Address: UFix64} {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalances()
    }

    init(
      _paymentTokenInfo: ToucansTokens.TokenInfo,
      _editDelay: UFix64,
      _minting: Bool,
      _initialTreasurySupply: UFix64,
      _maxSupply: UFix64?,
      _extra: {String: AnyStruct}
    ) {

      // Contract Variables
      self.totalSupply = 0.0
      self.maxSupply = _maxSupply

      // Paths
      self.VaultStoragePath = /storage/QuitoForestMetaverseFCVault
      self.ReceiverPublicPath = /public/QuitoForestMetaverseFCReceiver
      self.VaultPublicPath = /public/QuitoForestMetaverseFCMetadata
      self.MinterStoragePath = /storage/QuitoForestMetaverseFCMinter
      self.AdministratorStoragePath = /storage/QuitoForestMetaverseFCAdmin

      // Admin Setup
      let vault <- create Vault(balance: self.totalSupply)
      self.account.save(<- vault, to: self.VaultStoragePath)

      self.account.link<&Vault{FungibleToken.Receiver}>(
          self.ReceiverPublicPath,
          target: self.VaultStoragePath
      )

      self.account.link<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(
          self.VaultPublicPath,
          target: self.VaultStoragePath
      )

      if self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath) == nil {
        self.account.save(<- Toucans.createCollection(), to: Toucans.CollectionStoragePath)
        self.account.link<&Toucans.Collection{Toucans.CollectionPublic}>(Toucans.CollectionPublicPath, target: Toucans.CollectionStoragePath)
      }

      let toucansProjectCollection = self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath)!
      toucansProjectCollection.createProject(
        projectTokenInfo: ToucansTokens.TokenInfo("QuitoForestMetaverseFC", self.account.address, "QFMFC", self.ReceiverPublicPath, self.VaultPublicPath, self.VaultStoragePath),
        paymentTokenInfo: _paymentTokenInfo,
        minter: <- create Minter(),
        editDelay: _editDelay,
        minting: _minting,
        initialTreasurySupply: _initialTreasurySupply,
        extra: _extra
      )

      self.account.save(<- create Administrator(), to: self.AdministratorStoragePath)

      // Events
      emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
 "
-------
"import FlowToken from 0x1654653399040a61
import FiatToken from 0xb19436aae4d94622
import FungibleToken from 0xf233dcee88fe0abe

pub contract ToucansTokens {

  access(self) let tokens: {Type: TokenInfo}

  pub struct TokenInfo {
    pub let contractName: String
    pub let contractAddress: Address
    pub let tokenType: Type
    pub let symbol: String
    pub let receiverPath: PublicPath
    pub let publicPath: PublicPath
    pub let storagePath: StoragePath

    init(_ cn: String, _ ca: Address, _ s: String, _ rp: PublicPath, _ pp: PublicPath, _ sp: StoragePath) {
      self.contractName = cn
      self.contractAddress = ca
      let caToString: String = ca.toString()
      self.tokenType = CompositeType("A.".concat(caToString.slice(from: 2, upTo: caToString.length)).concat(".".concat(cn)).concat(".Vault"))!
      self.symbol = s
      self.receiverPath = rp
      self.publicPath = pp
      self.storagePath = sp
    }
  }

  pub resource Admin {
    pub fun addToken(tokenInfo: TokenInfo) {
      ToucansTokens.tokens[tokenInfo.tokenType] = tokenInfo
    }

    pub fun removeToken(tokenType: Type) {
      ToucansTokens.tokens.remove(key: tokenType)
    }
  }

  pub fun getTokenInfo(tokenType: Type): TokenInfo? {
    return self.tokens[tokenType]
  }

  pub fun getTokenSymbol(tokenType: Type): String? {
    return self.tokens[tokenType]?.symbol
  }

  pub fun getTokenInfoFromSymbol(symbol: String): TokenInfo? {
    for info in self.tokens.values {
      if info.symbol == symbol {
        return info
      }
    }
    return nil
  }

  // stringAddress DOES NOT include the `0x`
  pub fun stringToAddress(stringAddress: String): Address {
    var r: UInt64 = 0
    var bytes: [UInt8] = stringAddress.decodeHex()

    while bytes.length > 0 {
      r = r + (UInt64(bytes.removeFirst()) << UInt64(bytes.length * 8))
    }

    return Address(r)
  }

  init() {
    self.tokens = {
      Type<@FlowToken.Vault>(): TokenInfo("FlowToken", self.stringToAddress(stringAddress: FlowToken.getType().identifier.slice(from: 2, upTo: 18)), "FLOW", /public/flowTokenReceiver, /public/flowTokenBalance, /storage/flowTokenVault),
      Type<@FiatToken.Vault>(): TokenInfo("FiatToken", self.stringToAddress(stringAddress: FiatToken.getType().identifier.slice(from: 2, upTo: 18)), "USDC", /public/USDCVaultReceiver, /public/USDCVaultBalance, /storage/USDCVault)
    }
    self.account.save(<- create Admin(), to: /storage/ToucansTokensAdmin)
  }

}"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import FungibleTokenMetadataViews from 0xf233dcee88fe0abe
import MetadataViews from 0x1d7e57aa55817448
import Toucans from 0x577a3c409c5dcb5e
import ToucansTokens from 0x577a3c409c5dcb5e

pub contract GreenBitcoin: FungibleToken {

    // The amount of tokens in existance
    pub var totalSupply: UFix64
    // nil if there is none
    pub let maxSupply: UFix64?

    // Paths
    pub let VaultStoragePath: StoragePath
    pub let ReceiverPublicPath: PublicPath
    pub let VaultPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath
    pub let AdministratorStoragePath: StoragePath

    // Events
    pub event TokensInitialized(initialSupply: UFix64)
    pub event TokensWithdrawn(amount: UFix64, from: Address?)
    pub event TokensDeposited(amount: UFix64, to: Address?)
    pub event TokensTransferred(amount: UFix64, from: Address, to: Address)
    pub event TokensMinted(amount: UFix64)
    pub event TokensBurned(amount: UFix64)

    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance, MetadataViews.Resolver {
        pub var balance: UFix64

        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)

            if let owner: Address = self.owner?.address {
                GreenBitcoin.setBalance(address: owner, balance: self.balance)
            }
            return <- create Vault(balance: amount)
        }

        pub fun deposit(from: @FungibleToken.Vault) {
            let vault: @Vault <- from as! @Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)

            // We set the balance to 0.0 here so that it doesn't
            // decrease the totalSupply in the `destroy` function.
            vault.balance = 0.0
            destroy vault

            if let owner: Address = self.owner?.address {
                GreenBitcoin.setBalance(address: owner, balance: self.balance)
            }
        }

        pub fun getViews(): [Type]{
            return [Type<FungibleTokenMetadataViews.FTView>(),
                    Type<FungibleTokenMetadataViews.FTDisplay>(),
                    Type<FungibleTokenMetadataViews.FTVaultData>()]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<FungibleTokenMetadataViews.FTView>():
                    return FungibleTokenMetadataViews.FTView(
                        ftDisplay: self.resolveView(Type<FungibleTokenMetadataViews.FTDisplay>()) as! FungibleTokenMetadataViews.FTDisplay?,
                        ftVaultData: self.resolveView(Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
                    )
                case Type<FungibleTokenMetadataViews.FTDisplay>():
                    let media = MetadataViews.Media(
                            file: MetadataViews.HTTPFile(
                            url: "https://nftstorage.link/ipfs/bafkreigglohoo25a4zqqf6qauofnkaufoz3g7g4huijphy3jwhyyzbpnxa"
                        ),
                        mediaType: "image"
                    )
                    let medias = MetadataViews.Medias([media])
                    return FungibleTokenMetadataViews.FTDisplay(
                        name: "Green Bitcoin",
                        symbol: "GBTC",
                        description: "Every blockchain deserves a Bitcoin, and with Green Bitcoin, we aim to provide the long-awaited stability that users deserve.In a world filled with digital transactions and innovation, cryptocurrencies have revolutionized the way we store and exchange value. Blockchain technology has brought unprecedented levels of decentralization and security, but it is not without challenges.Green Bitcoin takes it a step further by focusing on sustainability and ecological responsibility. We recognize that the success of a cryptocurrency should not only be measured in financial gains but also in its impact on the environment. Therefore, we strive to create a green and sustainable Bitcoin, utilizing energy-efficient mining processes and renewable energy sources.With Green Bitcoin, we want to bestow the long-awaited stability upon users. We understand the need for stability and reliability in the cryptocurrency market. By combining a solid technological foundation, green mining practices, and a passionate community, we aim to provide a cryptocurrency that not only preserves value but also maximizes positive environmental impact.Join the Green Bitcoin movement and experience a new dimension of cryptocurrency. Together, we can pave the way towards a more sustainable and stable future.",
                        externalURL: MetadataViews.ExternalURL(""),
                        logos: medias,
                        socials: {
                            "twitter": MetadataViews.ExternalURL(""),
                            "discord": MetadataViews.ExternalURL("https://discord.gg/vY8pK9x8")
                        }
                    )
                case Type<FungibleTokenMetadataViews.FTVaultData>():
                    return FungibleTokenMetadataViews.FTVaultData(
                        storagePath: GreenBitcoin.VaultStoragePath,
                        receiverPath: GreenBitcoin.ReceiverPublicPath,
                        metadataPath: GreenBitcoin.VaultPublicPath,
                        providerPath: /private/GreenBitcoinVault,
                        receiverLinkedType: Type<&Vault{FungibleToken.Receiver}>(),
                        metadataLinkedType: Type<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(),
                        providerLinkedType: Type<&Vault{FungibleToken.Provider}>(),
                        createEmptyVaultFunction: (fun (): @Vault {
                            return <- GreenBitcoin.createEmptyVault()
                        })
                    )
            }
            return nil
        }

        init(balance: UFix64) {
            self.balance = balance
        }

        destroy() {
            emit TokensBurned(amount: self.balance)
            GreenBitcoin.totalSupply = GreenBitcoin.totalSupply - self.balance
        }
    }

    pub fun createEmptyVault(): @Vault {
        return <- create Vault(balance: 0.0)
    }

    pub resource Minter: Toucans.Minter {
        pub fun mint(amount: UFix64): @Vault {
            post {
                GreenBitcoin.maxSupply == nil || GreenBitcoin.totalSupply <= GreenBitcoin.maxSupply!:
                    "Exceeded the max supply of tokens allowd."
            }
            GreenBitcoin.totalSupply = GreenBitcoin.totalSupply + amount
            emit TokensMinted(amount: amount)
            return <- create Vault(balance: amount)
        }
    }

    // We follow this pattern of storage
    // so the (potentially) huge dictionary
    // isn't loaded when the contract is imported
    pub resource Administrator {
        // This is an experimental index and should
        // not be used for anything official
        // or monetary related
        access(self) let balances: {Address: UFix64}

        access(contract) fun setBalance(address: Address, balance: UFix64) {
            self.balances[address] = balance
        }

        pub fun getBalance(address: Address): UFix64 {
            return self.balances[address] ?? 0.0
        }

        pub fun getBalances(): {Address: UFix64} {
            return self.balances
        }

        init() {
            self.balances = {}
        }
    }

    access(contract) fun setBalance(address: Address, balance: UFix64) {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        admin.setBalance(address: address, balance: balance)
    }

    pub fun getBalance(address: Address): UFix64 {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalance(address: address)
    }

    pub fun getBalances(): {Address: UFix64} {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalances()
    }

    init(
      _paymentTokenInfo: ToucansTokens.TokenInfo,
      _editDelay: UFix64,
      _minting: Bool,
      _initialTreasurySupply: UFix64,
      _maxSupply: UFix64?,
      _extra: {String: AnyStruct}
    ) {

      // Contract Variables
      self.totalSupply = 0.0
      self.maxSupply = _maxSupply

      // Paths
      self.VaultStoragePath = /storage/GreenBitcoinVault
      self.ReceiverPublicPath = /public/GreenBitcoinReceiver
      self.VaultPublicPath = /public/GreenBitcoinMetadata
      self.MinterStoragePath = /storage/GreenBitcoinMinter
      self.AdministratorStoragePath = /storage/GreenBitcoinAdmin

      // Admin Setup
      let vault <- create Vault(balance: self.totalSupply)
      self.account.save(<- vault, to: self.VaultStoragePath)

      self.account.link<&Vault{FungibleToken.Receiver}>(
          self.ReceiverPublicPath,
          target: self.VaultStoragePath
      )

      self.account.link<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(
          self.VaultPublicPath,
          target: self.VaultStoragePath
      )

      if self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath) == nil {
        self.account.save(<- Toucans.createCollection(), to: Toucans.CollectionStoragePath)
        self.account.link<&Toucans.Collection{Toucans.CollectionPublic}>(Toucans.CollectionPublicPath, target: Toucans.CollectionStoragePath)
      }

      let toucansProjectCollection = self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath)!
      toucansProjectCollection.createProject(
        projectTokenInfo: ToucansTokens.TokenInfo("GreenBitcoin", self.account.address, "GBTC", self.ReceiverPublicPath, self.VaultPublicPath, self.VaultStoragePath),
        paymentTokenInfo: _paymentTokenInfo,
        minter: <- create Minter(),
        editDelay: _editDelay,
        minting: _minting,
        initialTreasurySupply: _initialTreasurySupply,
        extra: _extra
      )

      self.account.save(<- create Administrator(), to: self.AdministratorStoragePath)

      // Events
      emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
 "
-------
"pub contract AllCodeNFTContract {
    pub resource NFT {
        pub let id: UInt64
        init(initID: UInt64) {
            self.id = initID
        }
    }

    pub resource interface NFTReceiver {
        pub fun deposit(token: @NFT, metadata: {String : String})
        pub fun getIDs(): [UInt64]
        pub fun idExists(id: UInt64): Bool
        pub fun getMetadata(id: UInt64) : {String : String}
    }

    pub resource Collection: NFTReceiver {
        pub var ownedNFTs: @{UInt64: NFT}
        pub var metadataObjs: {UInt64: { String : String }}

        init () {
            self.ownedNFTs <- {}
            self.metadataObjs = {}
        }

        pub fun withdraw(withdrawID: UInt64): @NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID)!

            return <-token
        }

            pub fun deposit(token: @NFT, metadata: {String : String}) {
                self.metadataObjs[token.id] = metadata
                self.ownedNFTs[token.id] <-! token
            }

            pub fun idExists(id: UInt64): Bool {
                return self.ownedNFTs[id] != nil
            }

            pub fun getIDs(): [UInt64] {
                return self.ownedNFTs.keys
            }

            pub fun updateMetadata(id: UInt64, metadata: {String: String}) {
                self.metadataObjs[id] = metadata
            }

            pub fun getMetadata(id: UInt64): {String : String} {
                return self.metadataObjs[id]!
            }

            destroy() {
                destroy self.ownedNFTs
            }
    }

    pub fun createEmptyCollection(): @Collection {
        return <- create Collection()
    }

    pub resource NFTMinter {
        pub var idCount: UInt64

        init() {
            self.idCount = 1
        }

        pub fun mintNFT(): @NFT {
            var newNFT <- create NFT(initID: self.idCount)

            self.idCount = self.idCount + 1 as UInt64

            return <-newNFT
        }
    }

    //The init contract is required if the contract contains any fields
    init() {
          self.account.save(<-self.createEmptyCollection(), to: /storage/NFTCollection)
          self.account.link<&{NFTReceiver}>(/public/NFTReceiver, target: /storage/NFTCollection)
          self.account.save(<-create NFTMinter(), to: /storage/NFTMinter)
    }
}"
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import FreshmintMetadataViews from 0x0c82d33d4666f1f7

pub contract SportsCast: NonFungibleToken {

    pub let version: String

    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event Minted(id: UInt64, editionID: UInt64, serialNumber: UInt64)
    pub event Burned(id: UInt64)
    pub event EditionCreated(edition: Edition)
    pub event EditionClosed(id: UInt64, size: UInt64)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let CollectionPrivatePath: PrivatePath
    pub let AdminStoragePath: StoragePath

    /// The total number of SportsCast NFTs that have been minted.
    ///
    pub var totalSupply: UInt64

    /// The total number of SportsCast editions that have been created.
    ///
    pub var totalEditions: UInt64

    /// A list of royalty recipients that is attached to all NFTs
    /// minted by this contract.
    ///
    access(contract) let royalties: [MetadataViews.Royalty]

    /// Return the royalty recipients for this contract.
    ///
    pub fun getRoyalties(): [MetadataViews.Royalty] {
        return SportsCast.royalties
    }

    /// The collection-level metadata for all NFTs minted by this contract.
    ///
    pub let collectionMetadata: MetadataViews.NFTCollectionDisplay

    pub struct Metadata {

        /// The core metadata fields for a SportsCast NFT edition.
        ///
        pub let name: String
        pub let description: String
        pub let thumbnail: String
        pub let asset: String
        pub let colorCard: String
        pub let itemType: String
        pub let athleteName: String
        pub let assetType: String
        pub let itemCategory: String
        pub let series: String
        pub let eventName: String
        pub let eventDate: String
        pub let eventType: String
        pub let signed: Bool
        pub let userURL: String

        /// Optional attributes for a SportsCast NFT edition.
        ///
        pub let attributes: {String: String}

        init(
            name: String,
            description: String,
            thumbnail: String,
            asset: String,
            colorCard: String,
            itemType: String,
            athleteName: String,
            assetType: String,
            itemCategory: String,
            series: String,
            eventName: String,
            eventDate: String,
            eventType: String,
            signed: Bool,
            userURL: String,
            attributes: {String: String}
        ) {
            self.name = name
            self.description = description
            self.thumbnail = thumbnail
            self.asset = asset
            self.colorCard = colorCard
            self.itemType = itemType
            self.athleteName = athleteName
            self.assetType = assetType
            self.itemCategory = itemCategory
            self.series = series
            self.eventName = eventName
            self.eventDate = eventDate
            self.eventType = eventType
            self.signed = signed
            self.userURL = userURL

            self.attributes = attributes
        }
    }

    pub struct Edition {

        pub let id: UInt64

        /// The maximum number of NFTs that can be minted in this edition.
        ///
        /// If nil, the edition has no size limit.
        ///
        pub let limit: UInt64?

        /// The number of NFTs minted in this edition.
        ///
        /// This field is incremented each time a new NFT is minted.
        /// It cannot exceed the limit defined above.
        ///
        pub var size: UInt64

        /// The number of NFTs in this edition that have been burned.
        ///
        /// This field is incremented each time an NFT is burned.
        ///
        pub var burned: UInt64

        /// Return the total supply of NFTs in this edition.
        ///
        /// The supply is the number of NFTs minted minus the number burned.
        ///
        pub fun supply(): UInt64 {
            return self.size - self.burned
        }

        /// A flag indicating whether this edition is closed for minting.
        ///
        pub var isClosed: Bool

        /// The metadata for this edition.
        ///
        pub let metadata: Metadata

        init(
            id: UInt64,
            limit: UInt64?,
            metadata: Metadata
        ) {
            self.id = id
            self.limit = limit
            self.metadata = metadata

            self.size = 0
            self.burned = 0

            self.isClosed = false
        }

        /// Increment the size of this edition.
        ///
        access(contract) fun incrementSize() {
            self.size = self.size + (1 as UInt64)
        }

        /// Increment the burn count for this edition.
        ///
        access(contract) fun incrementBurned() {
            self.burned = self.burned + (1 as UInt64)
        }

        /// Close this edition and prevent further minting.
        ///
        /// Note: an edition is automatically closed when
        /// it reaches its size limit, if defined.
        ///
        access(contract) fun close() {
            self.isClosed = true
        }
    }

    access(self) let editions: {UInt64: Edition}

    pub fun getEdition(id: UInt64): Edition? {
        return SportsCast.editions[id]
    }

    /// This dictionary indexes editions by their mint ID.
    ///
    /// It is populated at mint time and used to prevent duplicate mints.
    /// The mint ID can be any unique string value,
    /// for example the hash of the edition metadata.
    ///
    access(self) let editionsByMintID: {String: UInt64}

    pub fun getEditionByMintID(mintID: String): UInt64? {
        return SportsCast.editionsByMintID[mintID]
    }

    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {

        pub let id: UInt64

        pub let editionID: UInt64
        pub let serialNumber: UInt64

        init(
            editionID: UInt64,
            serialNumber: UInt64
        ) {
            self.id = self.uuid
            self.editionID = editionID
            self.serialNumber = serialNumber
        }

        /// Return the edition that this NFT belongs to.
        ///
        pub fun getEdition(): Edition {
            return SportsCast.getEdition(id: self.editionID)!
        }

        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.NFTView>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.Edition>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.Media>(),
                Type<MetadataViews.Medias>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            let edition = self.getEdition()

            switch view {
                case Type<MetadataViews.Display>():
                    return self.resolveDisplay(edition.metadata)
                case Type<MetadataViews.ExternalURL>():
                    return self.resolveExternalURL()
                case Type<MetadataViews.NFTView>():
                    return self.resolveNFTView(edition.metadata)
                case Type<MetadataViews.NFTCollectionDisplay>():
                    return self.resolveNFTCollectionDisplay()
                case Type<MetadataViews.NFTCollectionData>():
                    return self.resolveNFTCollectionData()
                case Type<MetadataViews.Royalties>():
                    return self.resolveRoyalties()
                case Type<MetadataViews.Edition>():
                    return self.resolveEditionView(edition)
                case Type<MetadataViews.Serial>():
                    return self.resolveSerialView(self.serialNumber)
                case Type<MetadataViews.Media>():
                    return self.resolveMedia(edition.metadata)
                case Type<MetadataViews.Medias>():
                    return self.resolveMedias(edition.metadata)
            }

            return nil
        }

        pub fun resolveDisplay(_ metadata: Metadata): MetadataViews.Display {
            return MetadataViews.Display(
                name: metadata.name,
                description: metadata.description,
                thumbnail: FreshmintMetadataViews.ipfsFile(file: metadata.thumbnail)
            )
        }

        pub fun resolveExternalURL(): MetadataViews.ExternalURL {
            return MetadataViews.ExternalURL("TODO")
        }

        pub fun resolveNFTView(_ metadata: Metadata): MetadataViews.NFTView {
            return MetadataViews.NFTView(
                id: self.id,
                uuid: self.uuid,
                display: self.resolveDisplay(metadata),
                externalURL: self.resolveExternalURL(),
                collectionData: self.resolveNFTCollectionData(),
                collectionDisplay: self.resolveNFTCollectionDisplay(),
                royalties : self.resolveRoyalties(),
                traits: nil
            )
        }

        pub fun resolveNFTCollectionDisplay(): MetadataViews.NFTCollectionDisplay {
            return SportsCast.collectionMetadata
        }

        pub fun resolveNFTCollectionData(): MetadataViews.NFTCollectionData {
            return MetadataViews.NFTCollectionData(
                storagePath: SportsCast.CollectionStoragePath,
                publicPath: SportsCast.CollectionPublicPath,
                providerPath: SportsCast.CollectionPrivatePath,
                publicCollection: Type<&SportsCast.Collection{SportsCast.SportsCastCollectionPublic}>(),
                publicLinkedType: Type<&SportsCast.Collection{SportsCast.SportsCastCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
                providerLinkedType: Type<&SportsCast.Collection{SportsCast.SportsCastCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Provider, MetadataViews.ResolverCollection}>(),
                createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                    return <-SportsCast.createEmptyCollection()
                })
            )
        }

        pub fun resolveRoyalties(): MetadataViews.Royalties {
            return MetadataViews.Royalties(SportsCast.getRoyalties())
        }

        pub fun resolveEditionView(_ edition: Edition): MetadataViews.Edition {
            return MetadataViews.Edition(
                name: "Edition",
                number: self.serialNumber,
                max: edition.size
            )
        }

        pub fun resolveSerialView(_ serialNumber: UInt64): MetadataViews.Serial {
            return MetadataViews.Serial(
                number: serialNumber
            )
        }
        pub fun resolveMedia(_ metadata: Metadata): MetadataViews.Media {
            return MetadataViews.Media(
                file: MetadataViews.IPFSFile(cid: metadata.asset, path: nil),
                mediaType: metadata.assetType
            )
        }

        pub fun resolveMedias(_ metadata: Metadata): MetadataViews.Medias {
            return MetadataViews.Medias(
                items: [
                    MetadataViews.Media(
                        file: MetadataViews.IPFSFile(cid: metadata.asset, path: nil),
                        mediaType: metadata.assetType
                    ),
                    MetadataViews.Media(
                        file: MetadataViews.IPFSFile(cid: metadata.thumbnail, path: nil),
                        mediaType: "image/png"
                    )
                ]
            )
        }

        destroy() {
            SportsCast.totalSupply = SportsCast.totalSupply - (1 as UInt64)

            // Update the burn count for the NFT's edition
            let edition = self.getEdition()

            edition.incrementBurned()

            SportsCast.editions[edition.id] = edition

            emit Burned(id: self.id)
        }
    }

    pub resource interface SportsCastCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowSportsCast(id: UInt64): &SportsCast.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow SportsCast reference: The ID of the returned reference is incorrect"
            }
        }
    }

    pub resource Collection: SportsCastCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {

        /// A dictionary of all NFTs in this collection indexed by ID.
        ///
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        /// Remove an NFT from the collection and move it to the caller.
        ///
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID)
                ?? panic("Requested NFT to withdraw does not exist in this collection")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <- token
        }

        /// Deposit an NFT into this collection.
        ///
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @SportsCast.NFT

            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        /// Return an array of the NFT IDs in this collection.
        ///
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        /// Return a reference to an NFT in this collection.
        ///
        /// This function panics if the NFT does not exist in this collection.
        ///
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        /// Return a reference to an NFT in this collection
        /// typed as SportsCast.NFT.
        ///
        /// This function returns nil if the NFT does not exist in this collection.
        ///
        pub fun borrowSportsCast(id: UInt64): &SportsCast.NFT? {
            if self.ownedNFTs[id] != nil {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &SportsCast.NFT
            }

            return nil
        }

        /// Return a reference to an NFT in this collection
        /// typed as MetadataViews.Resolver.
        ///
        /// This function panics if the NFT does not exist in this collection.
        ///
        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let nftRef = nft as! &SportsCast.NFT
            return nftRef as &AnyResource{MetadataViews.Resolver}
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    /// Return a new empty collection.
    ///
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    /// The administrator resource used to mint and reveal NFTs.
    ///
    pub resource Admin {

        /// Create a new NFT edition.
        ///
        /// This function does not mint any NFTs. It only creates the
        /// edition data that will later be associated with minted NFTs.
        ///
        pub fun createEdition(
            mintID: String,
            limit: UInt64?,
            name: String,
            description: String,
            thumbnail: String,
            asset: String,
            colorCard: String,
            itemType: String,
            athleteName: String,
            assetType: String,
            itemCategory: String,
            series: String,
            eventName: String,
            eventDate: String,
            eventType: String,
            signed: Bool,
            userURL: String,
            attributes: {String: String}
        ): UInt64 {
            let metadata = Metadata(
                name: name,
                description: description,
                thumbnail: thumbnail,
                asset: asset,
                colorCard: colorCard,
                itemType: itemType,
                athleteName: athleteName,
                assetType: assetType,
                itemCategory: itemCategory,
                series: series,
                eventName: eventName,
                eventDate: eventDate,
                eventType: eventType,
                signed: signed,
                userURL: userURL,
                attributes: attributes
            )

            // Prevent multiple editions from being minted with the same mint ID
            assert(
                SportsCast.editionsByMintID[mintID] == nil,
                message: "an edition has already been created with mintID=".concat(mintID)
            )

            let edition = Edition(
                id: SportsCast.totalEditions,
                limit: limit,
                metadata: metadata
            )

            // Save the edition
            SportsCast.editions[edition.id] = edition

            // Update the mint ID index
            SportsCast.editionsByMintID[mintID] = edition.id

            emit EditionCreated(edition: edition)

            SportsCast.totalEditions = SportsCast.totalEditions + (1 as UInt64)

            return edition.id
        }

        /// Close an existing edition.
        ///
        /// This prevents new NFTs from being minted into the edition.
        /// An edition cannot be reopened after it is closed.
        ///
        pub fun closeEdition(editionID: UInt64) {
            let edition = SportsCast.editions[editionID]
                ?? panic("edition does not exist")

            // Prevent the edition from being closed more than once
            assert(edition.isClosed == false, message: "edition is already closed")

            edition.close()

            // Save the updated edition
            SportsCast.editions[editionID] = edition

            emit EditionClosed(id: edition.id, size: edition.size)
        }

        /// Mint a new NFT.
        ///
        /// This function will mint the next NFT in this edition
        /// and automatically assign the serial number.
        ///
        /// This function will panic if the edition has already
        /// reached its maximum size.
        ///
        pub fun mintNFT(editionID: UInt64): @SportsCast.NFT {
            let edition = SportsCast.editions[editionID]
                ?? panic("edition does not exist")

            // Do not mint into a closed edition
            assert(edition.isClosed == false, message: "edition is closed for minting")

            // Increase the edition size by one
            edition.incrementSize()

            // The NFT serial number is the new edition size
            let serialNumber = edition.size

            let nft <- create SportsCast.NFT(
                editionID: editionID,
                serialNumber: serialNumber
            )

            emit Minted(id: nft.id, editionID: editionID, serialNumber: serialNumber)

            // Close the edition if it reaches its size limit
            if let limit = edition.limit {
                if edition.size == limit {
                    edition.close()

                    emit EditionClosed(id: edition.id, size: edition.size)
                }
            }

            // Save the updated edition
            SportsCast.editions[editionID] = edition

            SportsCast.totalSupply = SportsCast.totalSupply + (1 as UInt64)

            return <- nft
        }
    }

    /// Return a public path that is scoped to this contract.
    ///
    pub fun getPublicPath(suffix: String): PublicPath {
        return PublicPath(identifier: "SportsCast_".concat(suffix))!
    }

    /// Return a private path that is scoped to this contract.
    ///
    pub fun getPrivatePath(suffix: String): PrivatePath {
        return PrivatePath(identifier: "SportsCast_".concat(suffix))!
    }

    /// Return a storage path that is scoped to this contract.
    ///
    pub fun getStoragePath(suffix: String): StoragePath {
        return StoragePath(identifier: "SportsCast_".concat(suffix))!
    }

    /// Return a collection name with an optional bucket suffix.
    ///
    pub fun makeCollectionName(bucketName maybeBucketName: String?): String {
        if let bucketName = maybeBucketName {
            return "Collection_".concat(bucketName)
        }

        return "Collection"
    }

    /// Return a queue name with an optional bucket suffix.
    ///
    pub fun makeQueueName(bucketName maybeBucketName: String?): String {
        if let bucketName = maybeBucketName {
            return "Queue_".concat(bucketName)
        }

        return "Queue"
    }

    priv fun initAdmin(admin: AuthAccount) {
        // Create an empty collection and save it to storage
        let collection <- SportsCast.createEmptyCollection()

        admin.save(<- collection, to: SportsCast.CollectionStoragePath)

        admin.link<&SportsCast.Collection>(SportsCast.CollectionPrivatePath, target: SportsCast.CollectionStoragePath)

        admin.link<&SportsCast.Collection{NonFungibleToken.CollectionPublic, SportsCast.SportsCastCollectionPublic, MetadataViews.ResolverCollection}>(SportsCast.CollectionPublicPath, target: SportsCast.CollectionStoragePath)

        // Create an admin resource and save it to storage
        let adminResource <- create Admin()

        admin.save(<- adminResource, to: self.AdminStoragePath)
    }

    init(collectionMetadata: MetadataViews.NFTCollectionDisplay, royalties: [MetadataViews.Royalty]) {

        self.version = "0.7.0"

        self.CollectionPublicPath = SportsCast.getPublicPath(suffix: "Collection")
        self.CollectionStoragePath = SportsCast.getStoragePath(suffix: "Collection")
        self.CollectionPrivatePath = SportsCast.getPrivatePath(suffix: "Collection")

        self.AdminStoragePath = SportsCast.getStoragePath(suffix: "Admin")

        self.royalties = royalties
        self.collectionMetadata = collectionMetadata

        self.totalSupply = 0
        self.totalEditions = 0

        self.editions = {}
        self.editionsByMintID = {}

        self.initAdmin(admin: self.account)

        emit ContractInitialized()
    }
}

"
-------
"// Description: Smart Contract for Sharks Virtual Commemorative Tickets
// SPDX-License-Identifier: UNLICENSED


import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract Sharks : NonFungibleToken{

    pub var totalSupply: UInt64

    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath

    pub resource NFT : NonFungibleToken.INFT, MetadataViews.Resolver {
        pub let id: UInt64
        pub var link: String
        pub var batch: UInt32
        pub var sequence: UInt16
        pub var limit: UInt16

        init(
            initID: UInt64,
            initlink: String,
            initbatch: UInt32,
            initsequence: UInt16,
            initlimit: UInt16
        ) {
            self.id = initID
            self.link = initlink
            self.batch = initbatch
            self.sequence = initsequence
            self.limit = initlimit
        }

        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.NFTCollectionData>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: Sharks.CollectionStoragePath,
                        publicPath: Sharks.CollectionPublicPath,
                        providerPath: /private/SharksCollection,
                        publicCollection: Type<&Sharks.Collection{Sharks.SharksCollectionPublic}>(),
                        publicLinkedType: Type<&Sharks.Collection{Sharks.SharksCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&Sharks.Collection{Sharks.SharksCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Provider, MetadataViews.ResolverCollection}>(),
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                            return <-Sharks.createEmptyCollection()
                        })
                    )

            }

            return nil
        }
    }

    pub resource interface SharksCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowSharks(id: UInt64): &Sharks.NFT? {

            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow Sharks reference: The ID of the returned reference is incorrect"
            }
        }
    }

    pub resource Collection: SharksCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID)!

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @Sharks.NFT
            let id: UInt64 = token.id
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }


        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        destroy() {
            destroy self.ownedNFTs
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let sharksNFT = nft as! &Sharks.NFT
            return sharksNFT as &AnyResource{MetadataViews.Resolver}
        }

        pub fun borrowSharks(id: UInt64): &Sharks.NFT? {
            if self.ownedNFTs[id] == nil {
                return nil
            }
            else {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &Sharks.NFT
            }
        }

    }

    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    pub resource NFTMinter {
        pub var minterID: UInt64

        init() {
            self.minterID = 0
        }

        pub fun mintNFT(glink: String, gbatch: UInt32, glimit: UInt16, gsequence:UInt16): @NFT {
            let tokenID = (UInt64(gbatch) << 32) | (UInt64(glimit) << 16) | UInt64(gsequence)
            var newNFT <- create NFT(initID: tokenID, initlink: glink, initbatch: gbatch, initsequence: gsequence, initlimit: glimit)

            self.minterID= tokenID
            Sharks.totalSupply = Sharks.totalSupply + UInt64(1)
            return <-newNFT
        }
    }

	init() {
        self.CollectionStoragePath = /storage/SharksCollection
        self.CollectionPublicPath = /public/SharksCollection
        self.MinterStoragePath = /storage/SharksMinter

        self.totalSupply = 0
        self.account.save(<-self.createEmptyCollection(), to: self.CollectionStoragePath)

        self.account.link<&{Sharks.SharksCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(
            self.CollectionPublicPath,
            target: self.CollectionStoragePath
        )
        self.account.save(<-create NFTMinter(), to: self.MinterStoragePath)
	}
}

 "
-------
"// Description: Smart Contract for Ticketmaster Digital Collectibles
// SPDX-License-Identifier: UNLICENSED


import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract TMNFT : NonFungibleToken{

    pub var totalSupply: UInt64

    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)


    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath



    pub resource NFT : NonFungibleToken.INFT, MetadataViews.Resolver {
        pub let id: UInt64
        pub var link: String
        pub var batch: UInt32
        pub var sequence: UInt16
        pub var limit: UInt16


        init(initID: UInt64, initlink: String, initbatch: UInt32, initsequence: UInt16, initlimit: UInt16) {
            self.id = initID
            self.link = initlink
            self.batch = initbatch
            self.sequence=initsequence
            self.limit=initlimit

        }

        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.NFTCollectionData>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: TMNFT.CollectionStoragePath,
                        publicPath: TMNFT.CollectionPublicPath,
                        providerPath: /private/TMNFTCollection,
                        publicCollection: Type<&TMNFT.Collection{TMNFT.TMNFTCollectionPublic}>(),
                        publicLinkedType: Type<&TMNFT.Collection{TMNFT.TMNFTCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&TMNFT.Collection{TMNFT.TMNFTCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Provider, MetadataViews.ResolverCollection}>(),
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                            return <-TMNFT.createEmptyCollection()
                        })
                    )
            }

            return nil
        }
    }


    pub resource interface TMNFTCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowTMNFT(id: UInt64): &TMNFT.NFT? {

            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow TMNFT reference: The ID of the returned reference is incorrect"
            }
        }
    }



    pub resource Collection: TMNFTCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {

        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}


        init () {
            self.ownedNFTs <- {}
        }


        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {

            let token <- self.ownedNFTs.remove(key: withdrawID)!
            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }


        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @TMNFT.NFT
            let id: UInt64 = token.id

            let oldToken <- self.ownedNFTs[id] <- token
            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }


        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }


        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        destroy() {
            destroy self.ownedNFTs
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let exampleNFT = nft as! &TMNFT.NFT

            return exampleNFT as &AnyResource{MetadataViews.Resolver}
        }

        pub fun borrowTMNFT(id: UInt64): &TMNFT.NFT? {
            if self.ownedNFTs[id] == nil {
                return nil
            }
            else {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &TMNFT.NFT
            }
        }
    }

    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    pub resource NFTMinter {
        pub var minterID: UInt64

        init() {
            self.minterID = 0
        }

        pub fun mintNFT(glink: String, gbatch: UInt32, glimit: UInt16, gsequence:UInt16): @NFT {
            let tokenID = (UInt64(gbatch) << 32) | (UInt64(glimit) << 16) | UInt64(gsequence)
            var newNFT <- create NFT(initID: tokenID, initlink: glink, initbatch: gbatch, initsequence: gsequence, initlimit: glimit)

            self.minterID= tokenID

            TMNFT.totalSupply = TMNFT.totalSupply + UInt64(1)
            return <-newNFT
        }
    }

	init() {
        self.CollectionStoragePath = /storage/TMNFTCollection
        self.CollectionPublicPath = /public/TMNFTCollection
        self.MinterStoragePath = /storage/TMNFTMinter

        self.totalSupply = 0

        self.account.save(<-self.createEmptyCollection(), to: self.CollectionStoragePath)
        self.account.link<&{NonFungibleToken.CollectionPublic}>(self.CollectionPublicPath, target: self.CollectionStoragePath)
        self.account.save(<-create NFTMinter(), to: self.MinterStoragePath)
	}
}

 "
-------
"import NonFungibleToken from 0x1d7e57aa55817448

pub contract CryptoPoops: NonFungibleToken {
    pub var totalSupply: UInt64

    pub event ContractInitialized()

    pub event Withdraw(id: UInt64, from: Address?)

    pub event Deposit(id: UInt64, to: Address?)

    pub resource NFT: NonFungibleToken.INFT {
        pub let id: UInt64
        pub let name: String

        init() {
            self.id = CryptoPoops.totalSupply
            CryptoPoops.totalSupply = CryptoPoops.totalSupply + (1 as UInt64)

            self.name = "Max"
        }
    }

    pub resource interface MyCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowEntireNFT(id: UInt64): &NFT
    }

    pub resource Collection: NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MyCollectionPublic {
        // id of the NFT -> NFT with that id
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        pub fun deposit(token: @NonFungibleToken.NFT) {
            let cryptoPoop <- token as! @NFT
            emit Deposit(id: cryptoPoop.id, to:self.owner!.address)
            self.ownedNFTs[cryptoPoop.id] <-! cryptoPoop
        }

        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("This collection doesn't cotain nft with that id")
            emit Withdraw(id: withdrawID, from: self.owner?.address)
            return <- token
        }

        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?) ?? panic("nothing in this index")
        }

        pub fun borrowEntireNFT(id: UInt64): &NFT {
            let refNFT = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?) ?? panic("something")
            return refNFT as! &NFT
        }

        init() {
            self.ownedNFTs <- {}
        }

        destroy () {
            destroy self.ownedNFTs
        }
    }

    pub fun createEmptyCollection(): @Collection {
        return <- create Collection()
    }

    pub resource NFTMinter {
        pub fun createNFT(): @NFT {
            return <- create NFT()
        }

        init() {

        }
    }

    init() {
        self.totalSupply = 0
        emit ContractInitialized()

        self.account.save(<- create NFTMinter(), to: /storage/Minter)
    }
}"
-------
"import NonFungibleToken from 0x1d7e57aa55817448

pub contract CryptoPoopss: NonFungibleToken {
    pub var totalSupply: UInt64

    pub event ContractInitialized()

    pub event Withdraw(id: UInt64, from: Address?)

    pub event Deposit(id: UInt64, to: Address?)

    pub resource NFT: NonFungibleToken.INFT {
        pub let id: UInt64
        pub(set) var metadata: {String: String}

        init(metadata: {String: String}) {
            self.id = CryptoPoopss.totalSupply
            CryptoPoopss.totalSupply = CryptoPoopss.totalSupply + (1 as UInt64)

            self.metadata = metadata
        }
    }

    pub resource interface MyCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowEntireNFT(id: UInt64): &NFT
    }

    pub resource Collection: NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MyCollectionPublic {
        // id of the NFT -> NFT with that id
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        pub fun deposit(token: @NonFungibleToken.NFT) {
            let cryptoPoop <- token as! @NFT
            emit Deposit(id: cryptoPoop.id, to:self.owner!.address)
            self.ownedNFTs[cryptoPoop.id] <-! cryptoPoop
        }

        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("This collection doesn't cotain nft with that id")
            emit Withdraw(id: withdrawID, from: self.owner?.address)
            return <- token
        }

        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?) ?? panic("nothing in this index")
        }

        pub fun borrowEntireNFT(id: UInt64): &NFT {
            let refNFT = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?) ?? panic("something")
            return refNFT as! &NFT
        }

        init() {
            self.ownedNFTs <- {}
        }

        destroy () {
            destroy self.ownedNFTs
        }
    }

    pub fun createEmptyCollection(): @Collection {
        return <- create Collection()
    }

    pub resource NFTMinter {
        pub fun createNFT(metadata: {String: String}): @NFT {
            let newNFT <- create NFT(metadata: metadata)
            return <- newNFT
        }

        init() {

        }
    }

    init() {
        self.totalSupply = 0
        emit ContractInitialized()

        self.account.save(<- create NFTMinter(), to: /storage/Mintere)
    }
}"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import FungibleTokenMetadataViews from 0xf233dcee88fe0abe
import MetadataViews from 0x1d7e57aa55817448
import Toucans from 0x577a3c409c5dcb5e
import ToucansTokens from 0x577a3c409c5dcb5e

pub contract FlovatarDAO: FungibleToken {

    // The amount of tokens in existance
    pub var totalSupply: UFix64
    // nil if there is none
    pub let maxSupply: UFix64?

    // Paths
    pub let VaultStoragePath: StoragePath
    pub let ReceiverPublicPath: PublicPath
    pub let VaultPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath
    pub let AdministratorStoragePath: StoragePath

    // Events
    pub event TokensInitialized(initialSupply: UFix64)
    pub event TokensWithdrawn(amount: UFix64, from: Address?)
    pub event TokensDeposited(amount: UFix64, to: Address?)
    pub event TokensTransferred(amount: UFix64, from: Address, to: Address)
    pub event TokensMinted(amount: UFix64)
    pub event TokensBurned(amount: UFix64)

    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance, MetadataViews.Resolver {
        pub var balance: UFix64

        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)

            if let owner: Address = self.owner?.address {
                FlovatarDAO.setBalance(address: owner, balance: self.balance)
            }
            return <- create Vault(balance: amount)
        }

        pub fun deposit(from: @FungibleToken.Vault) {
            let vault: @Vault <- from as! @Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)

            // We set the balance to 0.0 here so that it doesn't
            // decrease the totalSupply in the `destroy` function.
            vault.balance = 0.0
            destroy vault

            if let owner: Address = self.owner?.address {
                FlovatarDAO.setBalance(address: owner, balance: self.balance)
            }
        }

        pub fun getViews(): [Type]{
            return [Type<FungibleTokenMetadataViews.FTView>(),
                    Type<FungibleTokenMetadataViews.FTDisplay>(),
                    Type<FungibleTokenMetadataViews.FTVaultData>()]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<FungibleTokenMetadataViews.FTView>():
                    return FungibleTokenMetadataViews.FTView(
                        ftDisplay: self.resolveView(Type<FungibleTokenMetadataViews.FTDisplay>()) as! FungibleTokenMetadataViews.FTDisplay?,
                        ftVaultData: self.resolveView(Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
                    )
                case Type<FungibleTokenMetadataViews.FTDisplay>():
                    let media = MetadataViews.Media(
                            file: MetadataViews.HTTPFile(
                            url: "https://nftstorage.link/ipfs/bafkreif2crr6a6z4kqs4krkzgcikoof3kmm5yhduy64iupqva4xk35hel4"
                        ),
                        mediaType: "image"
                    )
                    let bannerMedia = MetadataViews.Media(
                            file: MetadataViews.HTTPFile(
                            url: "https://nftstorage.link/ipfs/bafybeienx7za7vnmewqaztdxwzz5nt4zaqnis3qg6tqv5k3xjgem74lhn4"
                        ),
                        mediaType: "image"
                    )
                    let medias = MetadataViews.Medias([media, bannerMedia])
                    return FungibleTokenMetadataViews.FTDisplay(
                        name: "Flovatar DAO",
                        symbol: "FLDAO",
                        description: "This is the official Flovatar DAO managed by all the Flovatar owners.",
                        externalURL: MetadataViews.ExternalURL("flovatar.com"),
                        logos: medias,
                        socials: {
                            "twitter": MetadataViews.ExternalURL("flovatar"),
                            "discord": MetadataViews.ExternalURL("flovatar")
                        }
                    )
                case Type<FungibleTokenMetadataViews.FTVaultData>():
                    return FungibleTokenMetadataViews.FTVaultData(
                        storagePath: FlovatarDAO.VaultStoragePath,
                        receiverPath: FlovatarDAO.ReceiverPublicPath,
                        metadataPath: FlovatarDAO.VaultPublicPath,
                        providerPath: /private/FlovatarDAOVault,
                        receiverLinkedType: Type<&Vault{FungibleToken.Receiver}>(),
                        metadataLinkedType: Type<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(),
                        providerLinkedType: Type<&Vault{FungibleToken.Provider}>(),
                        createEmptyVaultFunction: (fun (): @Vault {
                            return <- FlovatarDAO.createEmptyVault()
                        })
                    )
            }
            return nil
        }

        init(balance: UFix64) {
            self.balance = balance
        }

        destroy() {
            emit TokensBurned(amount: self.balance)
            FlovatarDAO.totalSupply = FlovatarDAO.totalSupply - self.balance
        }
    }

    pub fun createEmptyVault(): @Vault {
        return <- create Vault(balance: 0.0)
    }

    pub resource Minter: Toucans.Minter {
        pub fun mint(amount: UFix64): @Vault {
            post {
                FlovatarDAO.maxSupply == nil || FlovatarDAO.totalSupply <= FlovatarDAO.maxSupply!:
                    "Exceeded the max supply of tokens allowd."
            }
            FlovatarDAO.totalSupply = FlovatarDAO.totalSupply + amount
            emit TokensMinted(amount: amount)
            return <- create Vault(balance: amount)
        }
    }

    // We follow this pattern of storage
    // so the (potentially) huge dictionary
    // isn't loaded when the contract is imported
    pub resource Administrator {
        // This is an experimental index and should
        // not be used for anything official
        // or monetary related
        access(self) let balances: {Address: UFix64}

        access(contract) fun setBalance(address: Address, balance: UFix64) {
            self.balances[address] = balance
        }

        pub fun getBalance(address: Address): UFix64 {
            return self.balances[address] ?? 0.0
        }

        pub fun getBalances(): {Address: UFix64} {
            return self.balances
        }

        init() {
            self.balances = {}
        }
    }

    access(contract) fun setBalance(address: Address, balance: UFix64) {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        admin.setBalance(address: address, balance: balance)
    }

    pub fun getBalance(address: Address): UFix64 {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalance(address: address)
    }

    pub fun getBalances(): {Address: UFix64} {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalances()
    }

    init(
      _paymentTokenInfo: ToucansTokens.TokenInfo,
      _editDelay: UFix64,
      _minting: Bool,
      _initialTreasurySupply: UFix64,
      _maxSupply: UFix64?,
      _extra: {String: AnyStruct}
    ) {

      // Contract Variables
      self.totalSupply = 0.0
      self.maxSupply = _maxSupply

      // Paths
      self.VaultStoragePath = /storage/FlovatarDAOVault
      self.ReceiverPublicPath = /public/FlovatarDAOReceiver
      self.VaultPublicPath = /public/FlovatarDAOMetadata
      self.MinterStoragePath = /storage/FlovatarDAOMinter
      self.AdministratorStoragePath = /storage/FlovatarDAOAdmin

      // Admin Setup
      let vault <- create Vault(balance: self.totalSupply)
      self.account.save(<- vault, to: self.VaultStoragePath)

      self.account.link<&Vault{FungibleToken.Receiver}>(
          self.ReceiverPublicPath,
          target: self.VaultStoragePath
      )

      self.account.link<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(
          self.VaultPublicPath,
          target: self.VaultStoragePath
      )

      if self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath) == nil {
        self.account.save(<- Toucans.createCollection(), to: Toucans.CollectionStoragePath)
        self.account.link<&Toucans.Collection{Toucans.CollectionPublic}>(Toucans.CollectionPublicPath, target: Toucans.CollectionStoragePath)
      }

      let toucansProjectCollection = self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath)!
      toucansProjectCollection.createProject(
        projectTokenInfo: ToucansTokens.TokenInfo("FlovatarDAO", self.account.address, "FLDAO", self.ReceiverPublicPath, self.VaultPublicPath, self.VaultStoragePath),
        paymentTokenInfo: _paymentTokenInfo,
        minter: <- create Minter(),
        editDelay: _editDelay,
        minting: _minting,
        initialTreasurySupply: _initialTreasurySupply,
        extra: _extra
      )

      self.account.save(<- create Administrator(), to: self.AdministratorStoragePath)

      // Events
      emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
 "
-------
"import FungibleToken from 0xf233dcee88fe0abe

pub contract SendTokenMessage {
    pub event Delivered(tokenType: Type, amount: UFix64, to: Address, message: String?)

    pub fun deliver(vault: @FungibleToken.Vault, receiverPath: PublicPath, receiver: Address, message: String?) {
        emit Delivered(tokenType: vault.getType(), amount: vault.balance, to: receiver, message: message)

        let receiverVault = getAccount(receiver).getCapability(receiverPath)
                        .borrow<&{FungibleToken.Receiver}>()
                        ?? panic("Receiver does not have a vault set up to accept this delivery.")
        receiverVault.deposit(from: <- vault)
    }
}"
-------
"// SPDX-License-Identifier: Unlicense

pub contract Base64Util {
    pub fun encodeFromDict(_ dict: {String: String}): String {
        let jsonStr = Base64Util.dictToJsonStr(dict)
        return Base64Util.encode(jsonStr)
    }

    pub fun encode(_ str: String): String {
        let base64Map: {UInt8: String} = {
            0: "A", 1: "B", 2: "C", 3: "D",
            4: "E", 5: "F", 6: "G", 7: "H",
            8: "I", 9: "J", 10: "K", 11: "L",
            12: "M", 13: "N", 14: "O", 15: "P",
            16: "Q", 17: "R", 18: "S", 19: "T",
            20: "U", 21: "V", 22: "W", 23: "X",
            24: "Y", 25: "Z", 26: "a", 27: "b",
            28: "c", 29: "d", 30: "e", 31: "f",
            32: "g", 33: "h", 34: "i", 35: "j",
            36: "k", 37: "l", 38: "m", 39: "n",
            40: "o", 41: "p", 42: "q", 43: "r",
            44: "s", 45: "t", 46: "u", 47: "v",
            48: "w", 49: "x", 50: "y", 51: "z",
            52: "0", 53: "1", 54: "2", 55: "3",
            56: "4", 57: "5", 58: "6", 59: "7",
            60: "8", 61: "9", 62: "+", 63: "/"
        }

        var res = "";
        let bytes = str.utf8
        let remainder = bytes.length % 3
        while bytes.length % 3 != 0 {
            bytes.append(0)
        }
        var i = 0
        while i < bytes.length {
            res = res.concat(base64Map[bytes[i] >> 2]!)
            res = res.concat(base64Map[((bytes[i] << 6) >> 2) + (bytes[i + 1] >> 4)]!)
            res = res.concat(base64Map[((bytes[i + 1] << 4) >> 2) + (bytes[i + 2] >> 6)]!)
            res = res.concat(base64Map[((bytes[i + 2] << 2) >> 2)]!)
            i = i + 3
        }
        if remainder > 0 {
            res = res.slice(from: 0, upTo: res.length - (remainder == 1 ? 2 : 1))
        }
        return res
    }

    priv fun dictToJsonStr(_ dict: {String: String}): String {
        var res = "{"
        var flag = false
        for key in dict.keys {
            if !flag {
                flag = true
            } else {
                res = res.concat(",")
            }
            res = res.concat("\"")
                    .concat(key)
                    .concat("\":\"")
                    .concat(Base64Util.escape(dict[key]!))
                    .concat("\"")
        }
        res = res.concat("}")
        return res
    }

    priv fun escape(_ str: String): String {
        var res = ""
        var i = 0
        while i < str.length {
            let s = str.slice(from: i, upTo: i + 1)
            if s == "\"" || s == "\\" {
            res = res.concat("\\")
            }
            res = res.concat(s)
            i = i + 1
        }
        return res
    }
}
"
-------
"/**
This contract implements the metadata standard proposed
in FLIP-0636
Ref: https://github.com/onflow/flow/blob/master/flips/20210916-nft-metadata.md
Structs and resources can implement one or more
metadata types, called views. Each view type represents
a different kind of metadata, such as a creator biography
or a JPEG image file.
*/

pub contract MetadataViews {

    // A Resolver provides access to a set of metadata views.
    //
    // A struct or resource (e.g. an NFT) can implement this interface
    // to provide access to the views that it supports.
    //
    pub resource interface Resolver {
        pub fun getViews(): [Type]
        pub fun resolveView(_ view: Type): AnyStruct?
    }

    // A ResolverCollection is a group of view resolvers index by ID.
    //
    pub resource interface ResolverCollection {
        pub fun borrowViewResolver(id: UInt64): &{Resolver}
        pub fun getIDs(): [UInt64]
    }

    // Display is a basic view that includes the name and description
    // of an object. Most objects should implement this view.
    //
    pub struct Display {
        pub let name: String
        pub let description: String
        pub let thumbnail: AnyStruct{File}

        init(
            name: String,
            description: String,
            thumbnail: AnyStruct{File}
        ) {
            self.name = name
            self.description = description
            self.thumbnail = thumbnail
        }
    }

    // File is a generic interface that represents a file stored on or off chain.
    //
    // Files can be used to references images, videos and other media.
    //
    pub struct interface File {
        pub fun uri(): String
    }

    // HTTPFile is a file that is accessible at an HTTP (or HTTPS) URL.
    //
    pub struct HTTPFile: File {
        pub let url: String

        init(url: String) {
            self.url = url
        }

        pub fun uri(): String {
            return self.url
        }
    }

    // IPFSThumbnail returns a thumbnail image for an object
    // stored as an image file in IPFS.
    //
    // IPFS images are referenced by their content identifier (CID)
    // rather than a direct URI. A client application can use this CID
    // to find and load the image via an IPFS gateway.
    //
    pub struct IPFSFile: File {

        // CID is the content identifier for this IPFS file.
        //
        // Ref: https://docs.ipfs.io/concepts/content-addressing/
        //
        pub let cid: String

        // Path is an optional path to the file resource in an IPFS directory.
        //
        // This field is only needed if the file is inside a directory.
        //
        // Ref: https://docs.ipfs.io/concepts/file-systems/
        //
        pub let path: String?

        init(cid: String, path: String?) {
            self.cid = cid
            self.path = path
        }

        // This function returns the IPFS native URL for this file.
        //
        // Ref: https://docs.ipfs.io/how-to/address-ipfs-on-web/#native-urls
        //
        pub fun uri(): String {
            if let path = self.path {
                return "ipfs://".concat(self.cid).concat("/").concat(path)
            }

            return "ipfs://".concat(self.cid)
        }
    }
}"
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import Snapshot from 0x36b1a29d10c00c1a
import Base64Util from 0x36b1a29d10c00c1a

// The `SnapshotViewer` contract is a sample implementation of the `IViewer` struct interface.
//
pub contract SnapshotViewer {

    pub struct BasicHTMLViewer: Snapshot.IViewer {

        pub fun getView(snap: &Snapshot.Snap): AnyStruct {
            var html = "<!DOCTYPE html>\n"
            html = html.concat("<html lang=\"ja\">\n")
            html = html.concat("<head>\n")
            html = html.concat("<meta charset=\"UTF-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n")
            html = html.concat("<style>\n")
            html = html.concat("body, html { margin: 0; padding: 0; width: 100%; height: 100%; }\n")
            html = html.concat("canvas { border: 1px solid black; display: block; width: 100%; height: 100%; }\n")
            html = html.concat("#popup { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 20px; border: 0; box-shadow: 0 0 8px gray; font-size: 0.8em; }\n")
            html = html.concat("</style>\n")
            html = html.concat("</head>\n")
            html = html.concat("<body>\n")
            html = html.concat("<canvas id=\"viewerCanvas\"></canvas>\n")
            html = html.concat("<div id=\"popup\"></div>\n")
            html = html.concat("<script>\n")
            html = html.concat("const canvas = document.getElementById(\"viewerCanvas\");\n")
            html = html.concat("const ctx = canvas.getContext(\"2d\");\n")
            html = html.concat("const popup = document.getElementById(\"popup\");\n")
            html = html.concat("let isAnimating = true;\n")
            html = html.concat("\n")
            html = html.concat("function resizeCanvas() {\n")
            html = html.concat("    canvas.width = window.innerWidth;\n")
            html = html.concat("    canvas.height = window.innerHeight;\n")
            html = html.concat("}\n")
            html = html.concat("\n")
            html = html.concat("function escapeHtml(unsafe) {\n")
            html = html.concat("    return String(unsafe).replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\");\n")
            html = html.concat("}\n")
            html = html.concat("\n")
            html = html.concat("function decodeBase64(base64) {\n")
            html = html.concat("    try {\n")
            html = html.concat("        const binary = atob(base64);\n")
            html = html.concat("        let bytes = new Uint8Array(binary.length);\n")
            html = html.concat("        for (let i = 0; i < binary.length; i++) {\n")
            html = html.concat("            bytes[i] = binary.charCodeAt(i);\n")
            html = html.concat("        }\n")
            html = html.concat("        return new TextDecoder().decode(bytes);\n")
            html = html.concat("    } catch (e) {\n")
            html = html.concat("        console.error(e);\n")
            html = html.concat("        return \"\";\n")
            html = html.concat("    }\n")
            html = html.concat("}\n")
            html = html.concat("\n")
            html = html.concat("window.addEventListener(\"resize\", resizeCanvas);\n")
            html = html.concat("resizeCanvas();\n")
            html = html.concat("\n")

            html = html.concat("const ownerAddress = \"").concat(snap.ownerAddress.toString()).concat("\"\n")
            html = html.concat("const snapshotTime = Number((").concat(snap.time.toString()).concat(" | 0) * 1000)\n")

            html = html.concat("const data = [\n")

            for collectionPublicPath in snap.ownedNFTs.keys {
                let nftsInfo = snap.ownedNFTs[collectionPublicPath]!
                for id in nftsInfo.keys {
                    let metadata = nftsInfo[id]!.metadata
                    let name = metadata?.name ?? nftsInfo[id]!.nftID.toString()
                    let collectionPublicPath = nftsInfo[id]!.collectionPublicPath
                    let nftType = nftsInfo[id]!.nftType.identifier
                    let thumbnail = metadata?.thumbnail?.uri() ?? ""
                    html = html.concat("    {\n")
                    html = html.concat("        nftID: ").concat(nftsInfo[id]!.nftID.toString()).concat(",\n")
                    html = html.concat("        name: decodeBase64(\"").concat(Base64Util.encode(name)).concat("\"),\n")
                    html = html.concat("        collectionPublicPath: \"").concat(collectionPublicPath).concat("\",\n")
                    html = html.concat("        nftType: \"").concat(nftType).concat("\",\n")
                    html = html.concat("        thumbnail: decodeBase64(\"").concat(Base64Util.encode(thumbnail)).concat("\").replace(\"ipfs://\", \"https://dweb.link/ipfs/\"),\n")
                    html = html.concat("    },\n")
                }
            }

            html = html.concat("];\n")
            html = html.concat("\n")
            html = html.concat("data.map(info => {\n")
            html = html.concat("    const angle = Math.random() * 2 * Math.PI;\n")
            html = html.concat("    info.x = Math.random() * canvas.width;\n")
            html = html.concat("    info.y = Math.random() * canvas.height;\n")
            html = html.concat("    info.dx = Math.cos(angle) * 0.2;\n")
            html = html.concat("    info.dy = Math.sin(angle) * 0.2;\n")
            html = html.concat("    info.width = canvas.width * 0.08,\n")
            html = html.concat("    info.height = null,\n")
            html = html.concat("    info.image = null\n")
            html = html.concat("});\n")
            html = html.concat("\n")
            html = html.concat("let loadedImages = 0;\n")
            html = html.concat("\n")
            html = html.concat("data.forEach(item => {\n")
            html = html.concat("    const img = new Image();\n")
            html = html.concat("    img.onload = function() {\n")
            html = html.concat("        loadedImages++;\n")
            html = html.concat("        item.image = img;\n")
            html = html.concat("        item.height = img.height * (item.width / img.width);\n")
            html = html.concat("        if (loadedImages === data.length) {\n")
            html = html.concat("            requestAnimationFrame(draw);\n")
            html = html.concat("        }\n")
            html = html.concat("    }\n")
            html = html.concat("    img.onerror = function() {\n")
            html = html.concat("        loadedImages++;\n")
            html = html.concat("        if (loadedImages === data.length) {\n")
            html = html.concat("            requestAnimationFrame(draw);\n")
            html = html.concat("        }\n")
            html = html.concat("    }\n")
            html = html.concat("    img.src = item.thumbnail;\n")
            html = html.concat("});\n")
            html = html.concat("\n")
            html = html.concat("canvas.addEventListener(\"click\", function(event) {\n")
            html = html.concat("    const rect = canvas.getBoundingClientRect();\n")
            html = html.concat("    const x = event.clientX - rect.left;\n")
            html = html.concat("    const y = event.clientY - rect.top;\n")
            html = html.concat("\n")
            html = html.concat("    let clickedItem = null;\n")
            html = html.concat("    for (const item of data) {\n")
            html = html.concat("        if (x > item.x - item.width/2 && x < item.x + item.width/2 &&\n")
            html = html.concat("            y > item.y - item.height/2 && y < item.y + item.height/2) {\n")
            html = html.concat("            clickedItem = item;\n")
            html = html.concat("            break;\n")
            html = html.concat("        }\n")
            html = html.concat("    }\n")
            html = html.concat("\n")
            html = html.concat("    if (clickedItem) {\n")
            html = html.concat("        isAnimating = false;\n")
            html = html.concat("        let imageHtml = \"\";\n")
            html = html.concat("        if (clickedItem.image) {\n")
            html = html.concat("            imageHtml = `<img src=\"${clickedItem.thumbnail}\" width=\"${clickedItem.width * 3}\" height=\"${clickedItem.height * 3}\" style=\"display:block; margin:auto;\">`;\n")
            html = html.concat("        }\n")
            html = html.concat("        popup.innerHTML = imageHtml +\n")
            html = html.concat("                        \"<p>Name: \" + escapeHtml(clickedItem.name) + \"</p>\" + \n")
            html = html.concat("                        \"<p>PublicPath: \" + clickedItem.collectionPublicPath + \"</p>\" +\n")
            html = html.concat("                        \"<p>Type: \" + escapeHtml(clickedItem.nftType) + \"</p>\" +\n")
            html = html.concat("                        \"<p>ID: \" + clickedItem.nftID + \"</p>\" +\n")
            html = html.concat("                        \"<p>Owner: \" + ownerAddress + \"</p>\" +\n")
            html = html.concat("                        \"<p>Time: \" + new Date(snapshotTime).toLocaleString() + \"</p>\";\n")
            html = html.concat("        popup.style.display = \"block\";\n")
            html = html.concat("    } else {\n")
            html = html.concat("        isAnimating = true;\n")
            html = html.concat("        popup.style.display = \"none\";\n")
            html = html.concat("        requestAnimationFrame(draw);\n")
            html = html.concat("    }\n")
            html = html.concat("});\n")
            html = html.concat("\n")
            html = html.concat("function draw() {\n")
            html = html.concat("    if (!isAnimating) return;\n")
            html = html.concat("\n")
            html = html.concat("    ctx.clearRect(0, 0, canvas.width, canvas.height);\n")
            html = html.concat("\n")
            html = html.concat("    data.forEach(item => {\n")
            html = html.concat("        item.x += item.dx;\n")
            html = html.concat("        item.y += item.dy;\n")
            html = html.concat("\n")
            html = html.concat("        if (item.x - item.width/2 > canvas.width) item.x = -item.width/2;\n")
            html = html.concat("        if (item.x + item.width/2 < 0) item.x = canvas.width + item.width/2;\n")
            html = html.concat("        if (item.y - item.height/2 > canvas.height) item.y = -item.height/2;\n")
            html = html.concat("        if (item.y + item.height/2 < 0) item.y = canvas.height + item.height/2;\n")
            html = html.concat("\n")
            html = html.concat("        if (item.image) {\n")
            html = html.concat("            ctx.drawImage(item.image, 0, 0, item.image.width, item.image.height, item.x - item.width/2, item.y - item.height/2, item.width, item.height);\n")
            html = html.concat("        } else {\n")
            html = html.concat("            item.height = item.width;\n")
            html = html.concat("            ctx.fillStyle = \"#ddd\";\n")
            html = html.concat("            ctx.fillRect(item.x - item.width/2, item.y - item.height/2, item.width, item.height);\n")
            html = html.concat("\n")
            html = html.concat("            ctx.fillStyle = \"#999\";\n")
            html = html.concat("            ctx.textAlign = \"center\";\n")
            html = html.concat("            ctx.textBaseline = \"middle\";\n")
            html = html.concat("            ctx.fillText(\"NFT\", item.x, item.y);\n")
            html = html.concat("        }\n")
            html = html.concat("\n")
            html = html.concat("        ctx.fillStyle = \"black\";\n")
            html = html.concat("        ctx.textAlign = \"center\";\n")
            html = html.concat("        ctx.textBaseline = \"alphabetic\";\n")
            html = html.concat("        ctx.fillText(item.name, item.x, item.y + item.height/2 + 15);\n")
            html = html.concat("    });\n")
            html = html.concat("\n")
            html = html.concat("    requestAnimationFrame(draw);\n")
            html = html.concat("}\n")
            html = html.concat("</script>\n")
            html = html.concat("</body>\n")
            html = html.concat("</html>")

            return html
        }
    }
}
"
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import GaiaPrimarySale from 0x01ddf82c652e36ef
import DimensionXComics from 0xe3ad6030cbaff1c2

pub contract DimensionXComicsPrimarySaleMinter {

    pub event ContractInitialized()
    pub event MinterCreated(maxMints: Int)

    pub let MinterStoragePath: StoragePath
    pub let MinterPrivatePath: PrivatePath
    pub let MinterPublicPath: PublicPath

    pub resource interface MinterCapSetter {
        pub fun setMinterCap(minterCap: Capability<&DimensionXComics.NFTMinter>)
    }

    pub resource Minter: GaiaPrimarySale.IMinter, MinterCapSetter {
        access(contract) var dmxComicsMinterCap: Capability<&DimensionXComics.NFTMinter>?
        access(contract) let escrowCollection: @DimensionXComics.Collection

        pub let maxMints: Int
        pub var currentMints: Int

        pub fun mint(assetID: UInt64, creator: Address): @NonFungibleToken.NFT {
            pre {
                self.currentMints < self.maxMints: "mints exhausted: ".concat(self.currentMints.toString()).concat("/").concat(self.maxMints.toString())
            }

            let minter = self.dmxComicsMinterCap!.borrow() ?? panic("Unable to borrow minter")

            minter.mintNFT(recipient: &self.escrowCollection as &DimensionXComics.Collection)

            let ids = self.escrowCollection.getIDs()

            assert(ids.length == 1, message: "Escrow collection count invalid")

            let nft <- self.escrowCollection.withdraw(withdrawID: ids[0])

            self.currentMints = self.currentMints + 1
            return <- nft
        }

        pub fun setMinterCap(minterCap: Capability<&DimensionXComics.NFTMinter>) {
            self.dmxComicsMinterCap = minterCap
        }

        pub fun hasValidMinterCap(): Bool {
            return self.dmxComicsMinterCap != nil && self.dmxComicsMinterCap!.check()
        }

        init(
            maxMints: Int,
        ) {
            self.maxMints = maxMints
            self.currentMints = 0
            self.escrowCollection <- DimensionXComics.createEmptyCollection() as! @DimensionXComics.Collection
            self.dmxComicsMinterCap = nil

            emit MinterCreated(maxMints: self.maxMints)
        }

        destroy() {
            destroy self.escrowCollection
        }
    }

    pub fun createMinter(
        maxMints: Int,
    ): @Minter {
        return <- create Minter(
            maxMints: maxMints
        )
    }

    init() {
        self.MinterPrivatePath = /private/DimensionXComicsPrimarySaleMinterPrivatePath001
        self.MinterStoragePath = /storage/DimensionXComicsPrimarySaleMinterStoragePath001
        self.MinterPublicPath = /public/DimensionXComicsPrimarySaleMinterPublicPath001

        emit ContractInitialized()
    }
}
"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

access(all) contract Swap {

    /// ProposalCreated
    /// Event to notify when a user has created a swap proposal
    access(all) event ProposalCreated(proposal: ReadableSwapProposal)

    /// ProposalExecuted
    /// Event to notify when a user has executed a previously created swap proposal
    access(all) event ProposalExecuted(proposal: ReadableSwapProposal)

    /// ProposalDeleted
    /// Event to notify when a user has deleted a previously created swap proposal
    access(all) event ProposalDeleted(proposal: ReadableSwapProposal)

    /// AllowSwapProposalCreation
    /// Toggle to control creation of new swap proposals
    access(all) var AllowSwapProposalCreation: Bool

    /// SwapCollectionStoragePath
    /// Storage directory used to store the SwapCollection object
    access(all) let SwapCollectionStoragePath: StoragePath

    /// SwapCollectionPrivatePath
    /// Private directory used to expose the SwapCollectionManager capability
    access(all) let SwapCollectionPrivatePath: PrivatePath

    /// SwapCollectionPublicPath
    /// Public directory used to store the SwapCollectionPublic capability
    access(all) let SwapCollectionPublicPath: PublicPath

    /// SwapAdminStoragePath
    /// Storage directory used to store SwapAdmin object
    access(all) let SwapAdminStoragePath: StoragePath

    /// SwapAdminPrivatePath
    /// Storage directory used to store SwapAdmin capability
    access(all) let SwapAdminPrivatePath: PrivatePath

    /// SwapFees
    /// Array of all fees currently applied to swap proposals
    access(all) let SwapFees: [Fee]

    /// SwapProposalMinExpirationMinutes
    /// Minimum number of minutes that a swap proposal can be set to expire in
    access(all) var SwapProposalMinExpirationMinutes: UFix64

    /// SwapProposalMaxExpirationMinutes
    /// Maximum number of minutes that a swap proposal can be set to expire in
    access(all) var SwapProposalMaxExpirationMinutes: UFix64

    /// SwapProposalDefaultExpirationMinutes
    /// Default nubmer of minutes for swap proposal exiration
    access(all) var SwapProposalDefaultExpirationMinutes: UFix64

    /// Readable
    /// An interface for publicly readable structs.
    access(all) struct interface Readable {
        access(all) view fun getReadable(): {String: AnyStruct}
    }

    /// ProposedTradeAsset
    /// An NFT asset proposed as part of a swap.
    access(all) struct ProposedTradeAsset: Readable {
        access(all) let nftID: UInt64
        access(all) let type: Type
        access(all) let collectionData: MetadataViews.NFTCollectionData

        access(all) view fun getReadable(): {String: String} {
            return {
                "nftID": self.nftID.toString(),
                "type": self.type.identifier
            }
        }

        init(
            nftID: UInt64,
            type: String,
            collectionData: MetadataViews.NFTCollectionData
        ) {

            let inputType = CompositeType(type) ?? panic("unable to cast type; must be a valid NFT type reference")

            self.nftID = nftID
            self.type = inputType
            self.collectionData = collectionData
        }
    }

    /// Fee
    /// This struct represents a fee to be paid upon execution of the swap proposal.
    /// The feeGroup indicates the set of payment methods to which this fee belongs. For each feeGroup, the user is only
    /// required to provide one matching feeProvider in the UserCapabilities objects. This allows for a single fee to be
    /// payable in multiple currencies.
    access(all) struct Fee: Readable {
        access(all) let receiver: Capability<&AnyResource{FungibleToken.Receiver}>
        access(all) let amount: UFix64
        access(all) let feeGroup: UInt8
        access(all) let tokenType: Type

        init(
            receiver: Capability<&AnyResource{FungibleToken.Receiver}>,
            amount: UFix64,
            feeGroup: UInt8
        ) {

            assert(receiver.check(), message: "invalid fee receiver")
            let tokenType = receiver.borrow()!.getType()
            assert(amount > 0.0, message: "fee amount must be greater than zero")

            self.receiver = receiver
            self.amount = amount
            self.feeGroup = feeGroup
            self.tokenType = tokenType
        }

        access(all) view fun getReadable(): {String: String} {
            return {
                "receiverAddress": self.receiver.address.toString(),
                "amount": self.amount.toString(),
                "feeGroup": self.feeGroup.toString(),
                "tokenType": self.tokenType.identifier
            }
        }
    }

    /// UserOffer
    /// This struct represents one user's half of a swap, detailing their address and proposed assets as well as any
    /// metadata that might be required (currently not used)
    access(all) struct UserOffer: Readable {
        access(all) let userAddress: Address
        access(all) let proposedNfts: [ProposedTradeAsset]
        access(all) let metadata: {String: String}?

        access(all) view fun getReadable(): {String: [{String: String}]} {

            let readableOffer: {String: [{String: String}]} = {}
            let readableProposedNfts: [{String: String}] = []
            for proposedNft in self.proposedNfts {
                readableProposedNfts.append(proposedNft.getReadable())
            }
            readableOffer.insert(key: "proposedNfts", readableProposedNfts)

            if (self.metadata != nil && self.metadata!.keys!.length! > 0) {
                readableOffer.insert(key: "metadata", [self.metadata!])
            }

            return readableOffer
        }

        init(
            userAddress: Address,
            proposedNfts: [ProposedTradeAsset],
            metadata: {String: String}?
        ) {
            self.userAddress = userAddress
            self.proposedNfts = proposedNfts
            self.metadata = metadata
        }
    }

    /// UserCapabilities
    /// This struct contains the providers needed to send the user's offered tokens and any required fees, as well as the
    /// receivers needed to accept the trading partner's tokens and any extra capabilities that might be required.
    /// For capability dictionaries, each token's type identifier is used as the key for each entry in each dict.
    access(all) struct UserCapabilities {
        access(contract) let collectionReceiverCapabilities: {String: Capability<&{NonFungibleToken.Receiver}>}
        access(contract) let collectionProviderCapabilities: {String: Capability<&{NonFungibleToken.Provider}>}
        access(contract) let feeProviderCapabilities: {String: Capability<&{FungibleToken.Provider, FungibleToken.Balance}>}?
        access(contract) let extraCapabilities: {String: Capability}?

        init(
            collectionReceiverCapabilities: {String: Capability<&{NonFungibleToken.Receiver}>},
            collectionProviderCapabilities: {String: Capability<&{NonFungibleToken.Provider}>},
            feeProviderCapabilities: {String: Capability<&{FungibleToken.Provider, FungibleToken.Balance}>}?,
            extraCapabilities: {String: Capability}?
        ) {
            self.collectionReceiverCapabilities = collectionReceiverCapabilities
            self.collectionProviderCapabilities = collectionProviderCapabilities
            self.feeProviderCapabilities = feeProviderCapabilities
            self.extraCapabilities = extraCapabilities
        }
    }

    /// ReadableSwapProposal
    /// Struct for return type to SwapProposal.getReadable()
    access(all) struct ReadableSwapProposal {
        access(all) let id: String
        access(all) let fees: [{String: String}]
        access(all) let minutesRemainingBeforeExpiration: String
        access(all) let leftUserAddress: String
        access(all) let leftUserOffer: {String: [{String: String}]}
        access(all) let rightUserAddress: String
        access(all) let rightUserOffer: {String: [{String: String}]}
        access(all) let metadata: {String: String}?

        init(
            id: String,
            fees: [Fee],
            expirationEpochMilliseconds: UFix64,
            leftUserOffer: UserOffer,
            rightUserOffer: UserOffer,
            metadata: {String: String}?
        ) {

            let readableFees: [{String: String}] = []
            for fee in fees {
                readableFees.append(fee.getReadable())
            }

            let currentTimestamp: UFix64 = getCurrentBlock().timestamp
            var minutesRemaining: UFix64 = 0.0
            if (expirationEpochMilliseconds > currentTimestamp) {
                minutesRemaining = (expirationEpochMilliseconds - currentTimestamp) / 60000.0
            }

            self.id = id
            self.fees = readableFees
            self.minutesRemainingBeforeExpiration = minutesRemaining.toString()
            self.leftUserAddress = leftUserOffer.userAddress.toString()
            self.leftUserOffer = leftUserOffer.getReadable()
            self.rightUserAddress = rightUserOffer.userAddress.toString()
            self.rightUserOffer = rightUserOffer.getReadable()
            self.metadata = metadata
        }
    }

    /// SwapProposal
    /// Struct to represent a proposed swap, which is stored in a user's SwapCollection until executed by the right user
    access(all) struct SwapProposal {

        // Semi-unique identifier (unique within the left user's account) to identify swap proposals
        access(all) let id: String

        // Array of all fees to be paid out on execution of swap proposal (can be empty array in case of zero fees)
        access(all) let fees: [Fee]

        // When this swap proposal should no longer be eligible to be accepted (in epoch milliseconds)
        access(all) let expirationEpochMilliseconds: UFix64

        // The offer of the initializing user
        access(all) let leftUserOffer: UserOffer

        // The offer of the secondary proposer
        access(all) let rightUserOffer: UserOffer

        // The trading capabilities of the initializing user
        access(self) let leftUserCapabilities: UserCapabilities

        // A dictionary of metadata
        // Currently used for "sourceId"
        access(self) let metadata: {String: String}?

        init(
            id: String,
            leftUserOffer: UserOffer,
            rightUserOffer: UserOffer,
            leftUserCapabilities: UserCapabilities,
            expirationOffsetMinutes: UFix64,
            metadata: {String: String}?
        ) {

            assert(expirationOffsetMinutes >= Swap.SwapProposalMinExpirationMinutes,
                message: "expirationOffsetMinutes must be greater than or equal to Swap.SwapProposalMinExpirationMinutes")
            assert(expirationOffsetMinutes <= Swap.SwapProposalMaxExpirationMinutes,
                message: "expirationOffsetMinutes must be less than or equal to Swap.SwapProposalMaxExpirationMinutes")
            assert(Swap.AllowSwapProposalCreation, message: "swap proposal creation is paused")

            // convert offset minutes to epoch milliseconds
            let expirationEpochMilliseconds = getCurrentBlock().timestamp + (expirationOffsetMinutes * 1000.0 * 60.0)

            // verify that the left user owns their proposed assets has supplied proper capabilities
            Swap.verifyUserOffer(
                userOffer: leftUserOffer,
                userCapabilities: leftUserCapabilities,
                partnerOffer: rightUserOffer,
                fees: Swap.SwapFees
            )

            self.id = id
            self.fees = Swap.SwapFees
            self.leftUserOffer = leftUserOffer
            self.rightUserOffer = rightUserOffer
            self.leftUserCapabilities = leftUserCapabilities
            self.expirationEpochMilliseconds = expirationEpochMilliseconds
            self.metadata = metadata

            emit ProposalCreated(proposal: self.getReadableSwapProposal())
        }

        // Get a human-readable version of the swap proposal data
        access(contract) view fun getReadableSwapProposal(): ReadableSwapProposal {
            return ReadableSwapProposal(
                id: self.id,
                fees: self.fees,
                expirationEpochMilliseconds: self.expirationEpochMilliseconds,
                leftUserOffer: self.leftUserOffer,
                rightUserOffer: self.rightUserOffer,
                metadata: self.metadata
            )
        }

        // Function to execute the proposed swap
        access(contract) fun execute(rightUserCapabilities: UserCapabilities) {

            assert(getCurrentBlock().timestamp <= self.expirationEpochMilliseconds, message: "swap proposal is expired")

            // verify capabilities and ownership of tokens for both users
            Swap.verifyUserOffer(
                userOffer: self.leftUserOffer,
                userCapabilities: self.leftUserCapabilities,
                partnerOffer: self.rightUserOffer,
                fees: self.fees
            )
            Swap.verifyUserOffer(
                userOffer: self.rightUserOffer,
                userCapabilities: rightUserCapabilities,
                partnerOffer: self.leftUserOffer,
                fees: self.fees
            )

            // execute both sides of the offer
            Swap.executeUserOffer(
                userOffer: self.leftUserOffer,
                userCapabilities: self.leftUserCapabilities,
                partnerCapabilities: rightUserCapabilities,
                fees: self.fees
            )
            Swap.executeUserOffer(
                userOffer: self.rightUserOffer,
                userCapabilities: rightUserCapabilities,
                partnerCapabilities: self.leftUserCapabilities,
                fees: self.fees
            )

            emit ProposalExecuted(proposal: self.getReadableSwapProposal())
        }
    }

    /// SwapCollectionManager
    /// This interface allows private linking of management methods for the SwapCollection owner
    access(all) resource interface SwapCollectionManager {
        access(all) fun createProposal(
            leftUserOffer: UserOffer,
            rightUserOffer: UserOffer,
            leftUserCapabilities: UserCapabilities,
            expirationOffsetMinutes: UFix64?,
            metadata: {String: String}?
        ): String
        access(all) view fun getAllProposals(): {String: ReadableSwapProposal}
        access(all) fun deleteProposal(id: String)
    }

    /// SwapCollectionPublic
    /// This interface allows public linking of the get and execute methods for trading partners
    access(all) resource interface SwapCollectionPublic {
        access(all) view fun getProposal(id: String): ReadableSwapProposal
        access(all) view fun getUserOffer(proposalId: String, leftOrRight: String): UserOffer
        access(all) fun executeProposal(id: String, rightUserCapabilities: UserCapabilities)
    }

    access(all) resource SwapCollection: SwapCollectionManager, SwapCollectionPublic {

        // Dict to store by swap id all trade offers created by the end user
        access(self) let swapProposals: {String: SwapProposal}

        // Function to create and store a swap proposal
        access(all) fun createProposal(
            leftUserOffer: UserOffer,
            rightUserOffer: UserOffer,
            leftUserCapabilities: UserCapabilities,
            expirationOffsetMinutes: UFix64?,
            metadata: {String: String}?
        ): String {

            // generate semi-random number for the SwapProposal id
            var semiRandomId: String = unsafeRandom().toString()
            while (self.swapProposals[semiRandomId] != nil) {
                semiRandomId = unsafeRandom().toString()
            }

            // create swap proposal and add to swapProposals
            let newSwapProposal = SwapProposal(
                id: semiRandomId,
                leftUserOffer: leftUserOffer,
                rightUserOffer: rightUserOffer,
                leftUserCapabilities: leftUserCapabilities,
                expirationOffsetMinutes: expirationOffsetMinutes ?? Swap.SwapProposalDefaultExpirationMinutes,
                metadata: metadata
            )
            self.swapProposals.insert(key: semiRandomId, newSwapProposal)

            return semiRandomId
        }

        // Function to get a readable version of a single swap proposal
        access(all) view fun getProposal(id: String): ReadableSwapProposal {

            let noSwapProposalMessage: String = "found no swap proposal with id "
            let swapProposal: SwapProposal = self.swapProposals[id] ?? panic(noSwapProposalMessage.concat(id))

            return swapProposal.getReadableSwapProposal()
        }

        // Function to get a readable version of all swap proposals
        access(all) view fun getAllProposals(): {String: ReadableSwapProposal} {

            let proposalReadErrorMessage: String = "unable to get readable swap proposal for id "
            let readableSwapProposals: {String: ReadableSwapProposal} = {}

            for swapProposalId in self.swapProposals.keys {
                let swapProposal = self.swapProposals[swapProposalId] ?? panic(proposalReadErrorMessage.concat(swapProposalId))
                readableSwapProposals.insert(key: swapProposalId, swapProposal!.getReadableSwapProposal())
            }

            return readableSwapProposals
        }

        // Function to provide the specified user offer details
        access(all) view fun getUserOffer(proposalId: String, leftOrRight: String): UserOffer {

            let noSwapProposalMessage: String = "found no swap proposal with id "
            let swapProposal: SwapProposal = self.swapProposals[proposalId] ?? panic(noSwapProposalMessage.concat(proposalId))

            var userOffer: UserOffer? = nil

            switch leftOrRight.toLower() {
                case "left":
                    userOffer = swapProposal.leftUserOffer
                case "right":
                    userOffer = swapProposal.rightUserOffer
                default:
                    panic("argument leftOrRight must be either 'left' or 'right'")
            }

            return userOffer!
        }

        // Function to delete a swap proposal
        access(all) fun deleteProposal(id: String) {

            let noSwapProposalMessage: String = "found no swap proposal with id "
            let swapProposal: SwapProposal = self.swapProposals[id] ?? panic(noSwapProposalMessage.concat(id))
            let readableSwapProposal: ReadableSwapProposal = swapProposal.getReadableSwapProposal()

            self.swapProposals.remove(key: id)
            emit ProposalDeleted(proposal: readableSwapProposal)
        }

        // Function to execute a previously created swap proposal
        access(all) fun executeProposal(id: String, rightUserCapabilities: UserCapabilities) {

            let noSwapProposalMessage: String = "found no swap proposal with id "
            let swapProposal: SwapProposal = self.swapProposals[id] ?? panic(noSwapProposalMessage.concat(id))

            swapProposal.execute(rightUserCapabilities: rightUserCapabilities)
            self.deleteProposal(id: id)
        }

        init() {
            self.swapProposals = {}
        }
    }

    /// SwapProposalManager
    /// This interface allows private linking of swap proposal management functionality
    access(all) resource interface SwapProposalManager {
        access(account) fun stopProposalCreation()
        access(account) fun startProposalCreation()
        access(account) fun updateMinExpiration(_ exp: UFix64)
        access(all) fun updateMaxExpiration(_ exp: UFix64)
        access(account) fun updateDefaultExpiration(_ exp: UFix64)
    }

    access(all) resource interface SwapFeeManager {
        access(account) fun addFee(fee: Fee)
        access(account) fun removeFeeGroup(feeGroup: UInt8)
    }

    /// SwapAdmin
    /// This object provides admin controls for swap proposals
    access(all) resource SwapAdmin: SwapProposalManager, SwapFeeManager {

        // Pause all new swap proposal creation (for maintenance)
        access(account) fun stopProposalCreation() {
            Swap.AllowSwapProposalCreation = false
        }

        // Resume new swap proposal creation
        access(account) fun startProposalCreation() {
            Swap.AllowSwapProposalCreation = true
        }

        access(account) fun updateMinExpiration(_ exp: UFix64) {
            Swap.SwapProposalMinExpirationMinutes = exp
        }

        access(all) fun updateMaxExpiration(_ exp: UFix64) {
            Swap.SwapProposalMaxExpirationMinutes = exp
        }

        access(account) fun updateDefaultExpiration(_ exp: UFix64) {
            Swap.SwapProposalDefaultExpirationMinutes = exp
        }

        access(account) fun addFee(fee: Fee) {
            Swap.SwapFees.append(fee)
        }

        access(account) fun removeFeeGroup(feeGroup: UInt8) {
            for index, fee in Swap.SwapFees {
                if (fee.feeGroup == feeGroup) {
                    Swap.SwapFees.remove(at: index)
                }
            }
        }
    }

    access(all) view fun getFees(): [Fee] {
        return Swap.SwapFees
    }

    /// createEmptySwapCollection
    /// This function allows user to create a swap collection resource for future swap proposal creation.
    access(all) fun createEmptySwapCollection(): @SwapCollection {
        return <-create SwapCollection()
    }

    /// verifyUserOffer
    /// This function verifies that all assets in user offer are owned by the user.
    /// If userCapabilities is provided, the function checks that the provider capabilities are valid and that the
    /// address of each capability matches the address of the userOffer.
    /// If partnerOffer is provided in addition to userCapabilities, the function checks that the receiver
    /// capabilities are valid and that one exists for each of the collections in the partnerOffer.
    access(contract) fun verifyUserOffer(
        userOffer: UserOffer,
        userCapabilities: UserCapabilities?,
        partnerOffer: UserOffer?,
        fees: [Fee]
    ) {

        let capabilityNilMessage: String = "capability not found for "
        let addressMismatchMessage: String = "capability address does not match userOffer address for "
        let capabilityCheckMessage: String = "capability is invalid for "

        let userPublicAccount: PublicAccount = getAccount(userOffer.userAddress)

        for proposedNft in userOffer.proposedNfts {

            // attempt to load CollectionPublic capability and verify ownership
            let publicCapability = userPublicAccount.getCapability<&AnyResource{NonFungibleToken.CollectionPublic}>(proposedNft.collectionData.publicPath)

            let collectionPublicRef = publicCapability.borrow()
                ?? panic("could not borrow collectionPublic for ".concat(proposedNft.type.identifier))

            let ownedNftIds: [UInt64] = collectionPublicRef.getIDs()
            assert(ownedNftIds.contains(proposedNft.nftID),
                message: "could not verify ownership for ".concat(proposedNft.type.identifier))

            let nftRef = collectionPublicRef.borrowNFT(id: proposedNft.nftID)
            assert(nftRef.getType() == proposedNft.type,
                message: "proposedNft.type and stored asset type do not match for ".concat(proposedNft.type.identifier))

            if (userCapabilities != nil) {

                // check NFT provider capabilities
                let providerCapability = userCapabilities!.collectionProviderCapabilities[proposedNft.type.identifier]
                assert(providerCapability != nil, message: capabilityNilMessage.concat(proposedNft.type.identifier))
                assert(providerCapability!.address == userOffer.userAddress, message: addressMismatchMessage.concat(proposedNft.type.identifier))
                assert(providerCapability!.check(), message: capabilityCheckMessage.concat(proposedNft.type.identifier))
            }
        }

        if (userCapabilities != nil && partnerOffer != nil) {

            for partnerProposedNft in partnerOffer!.proposedNfts {

                // check NFT receiver capabilities
                let receiverCapability = userCapabilities!.collectionReceiverCapabilities[partnerProposedNft.type.identifier]
                assert(receiverCapability != nil, message: capabilityNilMessage.concat(partnerProposedNft.type.identifier))
                assert(receiverCapability!.address == userOffer.userAddress, message: addressMismatchMessage.concat(partnerProposedNft.type.identifier))
                assert(receiverCapability!.check(), message: capabilityCheckMessage.concat(partnerProposedNft.type.identifier))
            }
        }

        // check fee provider and receiver capabilities
        if (fees.length > 0 && userCapabilities != nil) {

            assert(userCapabilities!.feeProviderCapabilities != nil && userCapabilities!.feeProviderCapabilities!.keys.length > 0,
                message: "feeProviderCapabilities dictionary cannot be empty if fees are required")

            let feeTotals: {String: UFix64} = {}
            let feeGroupPaymentMap: {UInt8: Bool} = {}

            for fee in fees {

                if (feeGroupPaymentMap[fee.feeGroup] != true) {
                    feeGroupPaymentMap.insert(key: fee.feeGroup, false)

                    // check whether capability was provided for this fee
                    let feeProviderCapability = userCapabilities!.feeProviderCapabilities![fee.tokenType.identifier]
                    if (feeProviderCapability != nil && feeProviderCapability!.check()) {

                        let feeProviderRef: &AnyResource{FungibleToken.Provider, FungibleToken.Balance}? = feeProviderCapability!.borrow()
                        let feeReceiverRef = fee.receiver.borrow()
                            ?? panic("could not borrow feeReceiverRef for ".concat(fee.tokenType.identifier))

                        // if this is a payment option for the feeGroup, check balance, otherwise continue
                        if (feeProviderRef != nil && feeProviderRef!.getType() == feeReceiverRef.getType()) {

                            // tally running fee totals
                            let previousFeeTotal = feeTotals[fee.tokenType.identifier] ?? 0.0
                            let newFeeTotal = previousFeeTotal + fee.amount

                            // ensure that user has enough available balance of token for fee
                            if (feeProviderRef!.balance >= newFeeTotal) {

                                // update feeTotals and mark feeGroup as payable
                                feeTotals.insert(key: fee.tokenType.identifier, newFeeTotal)
                                feeGroupPaymentMap.insert(key: fee.feeGroup, true)
                            }
                        }
                    }
                }
            }

            // check that all feeGroups have been marked as payable
            feeGroupPaymentMap.forEachKey(fun (key: UInt8): Bool {
                if (feeGroupPaymentMap[key] != true) {
                    panic("no valid payment method provided for feeGroup ".concat(key.toString()))
                }
                return true
            })
        }
    }

    /// executeUserOffer
    /// This function verifies for each token in the user offer that both users have the required capabilites for the
    /// trade and that the token type matches that of the offer, and then it moves the token to the receiving collection.
    access(contract) fun executeUserOffer(
        userOffer: UserOffer,
        userCapabilities: UserCapabilities,
        partnerCapabilities: UserCapabilities,
        fees: [Fee]
    ) {

        let typeMismatchMessage: String = "token type mismatch for "
        let receiverRefMessage: String = "could not borrow receiver reference for "
        let providerRefMessage: String = "could not borrow provider reference for "

        let feeGroupPaymentMap: {UInt8: Bool} = {}

        for fee in fees {

            if (feeGroupPaymentMap[fee.feeGroup] != true) {
                feeGroupPaymentMap.insert(key: fee.feeGroup, false)

                // check whether capability was provided for this fee
                let feeProviderCapability = userCapabilities.feeProviderCapabilities![fee.tokenType.identifier]
                if (feeProviderCapability != nil && feeProviderCapability!.check()) {

                    // get fee provider and receiver
                    let feeProviderRef = feeProviderCapability!.borrow()
                    let feeReceiverRef = fee.receiver.borrow()
                        ?? panic(receiverRefMessage.concat(fee.tokenType.identifier))

                    if (feeProviderRef != nil && feeReceiverRef.getType() == feeProviderRef!.getType()) {

                        // verify token type and tranfer fee
                        let feePayment <- feeProviderRef!.withdraw(amount: fee.amount)
                        assert(feePayment.isInstance(fee.tokenType), message: typeMismatchMessage.concat(fee.tokenType.identifier))
                        feeReceiverRef.deposit(from: <-feePayment)
                        feeGroupPaymentMap.insert(key: fee.feeGroup, true)
                    }
                }
            }
        }

        // check that all feeGroups have been marked as paid
        feeGroupPaymentMap.forEachKey(fun (key: UInt8): Bool {
            if (feeGroupPaymentMap[key] != true) {
                panic("no valid payment provided for feeGroup ".concat(key.toString()))
            }
            return true
        })

        for proposedNft in userOffer.proposedNfts {

            // get receiver and provider
            let receiverReference = partnerCapabilities.collectionReceiverCapabilities[proposedNft.type.identifier]!.borrow()
                ?? panic(receiverRefMessage.concat(proposedNft.type.identifier))
            let providerReference = userCapabilities.collectionProviderCapabilities[proposedNft.type.identifier]!.borrow()
                ?? panic(providerRefMessage.concat(proposedNft.type.identifier))

            // verify token type
            let nft <- providerReference.withdraw(withdrawID: proposedNft.nftID)
            assert(nft.isInstance(proposedNft.type), message: typeMismatchMessage.concat(proposedNft.type.identifier))

            // transfer token
            receiverReference.deposit(token: <-nft)
        }
    }

    init() {

        // initialize contract constants
        self.AllowSwapProposalCreation = true
        self.SwapCollectionStoragePath = /storage/emSwapCollection
        self.SwapCollectionPrivatePath = /private/emSwapCollectionManager
        self.SwapCollectionPublicPath = /public/emSwapCollectionPublic
        self.SwapAdminStoragePath = /storage/emSwapAdmin
        self.SwapAdminPrivatePath = /private/emSwapAdmin
        self.SwapFees = []
        self.SwapProposalMinExpirationMinutes = 2.0
        self.SwapProposalMaxExpirationMinutes = 43800.0
        self.SwapProposalDefaultExpirationMinutes = 5.0

        // save swap proposal admin object and link capabilities
        self.account.save(<- create SwapAdmin(), to: self.SwapAdminStoragePath)
        self.account.link<&SwapAdmin{SwapProposalManager, SwapFeeManager}>(self.SwapAdminPrivatePath, target: self.SwapAdminStoragePath)
    }
}
"
-------
"// auction.cdc
// by Ami Rajpal, 2021 // DAAM Agency

import FungibleToken    from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews    from 0x1d7e57aa55817448
import DAAM             from 0x7db4d10c78bad30a

pub contract AuctionHouse {
    // Event
    pub event AuctionCreated(auctionID: UInt64, start: UFix64)   // Auction has been created.
    pub event AuctionClosed(auctionID: UInt64)    // Auction has been finalized and has been removed.
    pub event AuctionEnded(auctionID: UInt64, time: UFix64)   // Auction has ended, time is Unix timestamp.
    pub event AuctionCancelled(auctionID: UInt64) // Auction has been canceled
    pub event ItemReturned(auctionID: UInt64, seller: Address)     // Auction has ended and the Reserve price was not met.
    pub event BidMade(auctionID: UInt64, bidder: Address) // Bid has been made on an Item
    pub event BidWithdrawn(auctionID: UInt64, bidder: Address)                // Bidder has withdrawn their bid
    pub event ItemWon(auctionID: UInt64, winner: Address, tokenID: UInt64, amount: UFix64, sale: SaleHistoryEntry)  // Item has been Won in an auction
    pub event BuyItNow(auctionID: UInt64, winner: Address, amount: UFix64) // Buy It Now has been completed
    pub event FundsReturned(auctionID: UInt64)   // Funds have been returned accordingly

    // Path for Auction Wallet
    pub let auctionStoragePath: StoragePath
    pub let auctionPublicPath : PublicPath

    // Variables; *Note: Do not confuse (Token)ID with MID
    access(contract) var metadataGen     : {UInt64 : Capability<&DAAM.MetadataGenerator{DAAM.MetadataGeneratorMint}> }
    access(contract) var auctionCounter  : UInt64               // Incremental counter used for AID (Auction ID)
    access(contract) var currentAuctions : {Address : [UInt64]} // {Auctioneer Address : [list of Auction IDs (AIDs)] }  // List of all auctions
    access(contract) var fee             : {UInt64 : UFix64}    // { MID : Fee precentage, 1.025 = 0.25% }
    access(contract) var agencyFirstSale : {UInt64 : UFix64}    // { MID : Agency fist sale precentage}
    access(contract) var saleHistory     : {UInt64 : SaleHistory} // Stores sale history using the id as a center point of search. {TokenID : SaleHistory} }
    access(contract) var history         : {UInt64 : {UInt64 : SaleHistory} } // Stores history using the mid as a center point of search. { MID : {TokenID : SaleHistory} }
    access(contract) var crypto          : {String : PublicPath}    // Stores accepted Cryptos { A.Address.Vault : PublicPath of Crypto}

/************************************************************************/
pub struct SaleHistoryEntry {
    pub let id      : UInt64
    pub let auction : AuctionHolder
    pub let price   : UFix64
    pub let from    : Address
    pub let to      : Address
    pub let timestamp : UFix64

    init(id: UInt64, auctionHolder: AuctionHolder, price: UFix64, from: Address, to: Address) {
        self.id      = id
        self.auction = auctionHolder
        self.price   = price
        self.from    = from
        self.to      = to
        self.timestamp = getCurrentBlock().timestamp
    }
}
/************************************************************************/
pub struct SaleHistory {
    pub let metadata    : DAAM.MetadataHolder
    pub var saleHistory : [SaleHistoryEntry]

    init(metadata: DAAM.MetadataHolder) {
        self.metadata = metadata
        self.saleHistory = []
    }

    access(contract) fun add(_ history: SaleHistoryEntry) {
        self.saleHistory.append(history)
    }
}
/************************************************************************/
pub struct AuctionHolder {
        pub let status        : Bool? // nil = auction not started or no bid, true = started (with bid), false = auction ended
        pub let auctionID     : UInt64       // Auction ID number. Note: Series auctions keep the same number.
        pub let creatorInfo   : DAAM.CreatorInfo
        pub let mid           : UInt64       // collect Metadata ID
        pub let start         : UFix64       // timestamp
        pub let length        : UFix64   // post{!isExtended && length == before(length)}
        pub let isExtended    : Bool     // true = Auction extends with every bid.
        pub let extendedTime  : UFix64   // when isExtended=true and extendedTime = 0.0. This is equal to a direct Purchase. // Time of Extension.
        pub let leader        : Address? // leading bidder
        pub let minBid        : UFix64?  // minimum bid
        pub let startingBid   : UFix64?  // the starting bid od an auction. Nil = No Bidding. Direct Purchase
        pub let reserve       : UFix64   // the reserve. must be sold at min price.
        pub let fee           : UFix64   // the fee
        pub let price         : UFix64   // original price
        pub let buyNow        : UFix64   // buy now price (original price + AuctionHouse.fee)
        pub let reprintSeries : UInt64?  // Active Series Minter (if series)
        pub let auctionLog    : {Address: UFix64}    // {Bidders, Amount} // Log of the Auction
        pub let requiredCurrency: Type

        init(
            _ status:Bool?, _ auctionID:UInt64, _ creator: DAAM.CreatorInfo, _ mid: UInt64, _ start: UFix64, _ length: UFix64,
            _ isExtended: Bool, _ extendedTime: UFix64, _ leader: Address?, _ minBid: UFix64?, _ startingBid: UFix64?,
            _ reserve: UFix64, _ fee: UFix64, _ price: UFix64, _ buyNow: UFix64, _ reprintSeries: UInt64?,
            _ auctionLog: {Address: UFix64}, _ requiredCurrency: Type
            )
            {
                self.status        = status// nil = auction not started or no bid, true = started (with bid), false = auction ended
                self.auctionID     = auctionID       // Auction ID number. Note: Series auctions keep the same number.
                self.creatorInfo   = creator
                self.mid           = mid       // collect Metadata ID
                self.start         = start       // timestamp
                self.length        = length   // post{!isExtended && length == before(length)}
                self.isExtended    = isExtended     // true = Auction extends with every bid.
                self.extendedTime  = extendedTime   // when isExtended=true and extendedTime = 0.0. This is equal to a direct Purchase. // Time of Extension.
                self.leader        = leader // leading bidder
                self.minBid        = minBid  // minimum bid
                self.startingBid   = startingBid // the starting bid od an auction. Nil = No Bidding. Direct Purchase
                self.reserve       = reserve   // the reserve. must be sold at min price.
                self.fee           = fee   // the fee
                self.price         = price   // original price
                self.buyNow        = buyNow   // buy now price (original price + AuctionHouse.fee)
                self.reprintSeries = reprintSeries     // Active Series Minter (if series)
                self.auctionLog    = auctionLog    // {Bidders, Amount} // Log of the Auction
                self.requiredCurrency = requiredCurrency
            }
}
/************************************************************************/
    pub resource interface AuctionWalletPublic {
        // Public Interface for AuctionWallet
        pub fun getAuctions()     : [UInt64]                 // MIDs in Auctions
        pub fun getAgentAuctions(): [UInt64]                 // Returns the Auctions deposited by Agent
        pub fun item(_ id: UInt64): &Auction{AuctionPublic}? // item(Token ID) will return the apporiate auction.
        pub fun closeAuctions()                              // Close all finilise auctions
        pub fun closeAuction(_ auctionID: UInt64)            // Close auction by AID

        pub fun deposit(agent: &DAAM.Admin{DAAM.Agent}, metadataGenerator: Capability<&DAAM.MetadataGenerator{DAAM.MetadataGeneratorMint}>, mid: UInt64, start: UFix64,
            length: UFix64, isExtended: Bool, extendedTime: UFix64, vault: @FungibleToken.Vault, incrementByPrice: Bool, incrementAmount: UFix64,
            startingBid: UFix64?, reserve: UFix64, buyNow: UFix64, reprintSeries: UInt64?): UInt64
    }
/************************************************************************/
    pub resource AuctionWallet: AuctionWalletPublic {
        priv var currentAuctions: @{UInt64 : Auction}  // { AuctionID : Auction }
        priv var approveAuctions: @{UInt64 : Auction}

        init() {  // Auction Resources are stored here. The Auctions themselves.
            self.currentAuctions <- {}
            self.approveAuctions <- {}
        }

        // createAuction: An Original Auction is defined as a newly minted NFT.
        // MetadataGenerator: Reference to Metadata or nil when nft argument is enterd
        // nft: DAAM.NFT or nil when MetadataGenerator argument is entered
        // id: DAAM Metadata ID or Token ID depenedent whether nft or MetadataGenerator is entered
        // start: Enter UNIX Flow Blockchain Time
        // length: Length of auction
        // isExtended: if the auction lenght is to be an Extended Auction
        // extendedTime: The amount of time the extension is to be.
        // incrementByPrice: increment by fixed amount or percentage. True = fixed amount, False = Percentage
        // incrementAmount: the increment value. when incrementByPrice is true, the minimum bid is increased by this amount.
        //                  when False, the minimin bid is increased by that Percentage. Note: 1.0 = 100%
        // startingBid: the initial price. May not be 0.0
        // reserve: The minimum price that must be meet
        // buyNow: To amount to purchase an item directly. Note: 0.0 = OFF
        // reprintSeries: to duplicate the current auction, with a reprint (Next Mint os Series)
        // *** new is defines as "never sold", age is not a consideration. ***
        pub fun createAuction(metadataGenerator: Capability<&DAAM.MetadataGenerator{DAAM.MetadataGeneratorMint}>?, nft: @DAAM.NFT?, id: UInt64, start: UFix64,
            length: UFix64, isExtended: Bool, extendedTime: UFix64, vault: @FungibleToken.Vault, incrementByPrice: Bool, incrementAmount: UFix64,
            startingBid: UFix64?, reserve: UFix64, buyNow: UFix64, reprintSeries: UInt64?): UInt64
        {
            let auction <- self.createAuctionResource(metadataGenerator: metadataGenerator, nft: <-nft, id: id, start: start, length: length, isExtended: isExtended,
                extendedTime: extendedTime, vault: <-vault, incrementByPrice: incrementByPrice, incrementAmount: incrementAmount, startingBid: startingBid,
                reserve: reserve, buyNow: buyNow, reprintSeries: reprintSeries)
            // Add Auction
            let aid = auction.auctionID // Auction ID
            let oldAuction <- self.currentAuctions.insert(key: aid, <- auction!) // Store Auction
            destroy oldAuction // destroy placeholder

            AuctionHouse.currentAuctions.insert(key: self.owner?.address!, self.currentAuctions.keys) // Update Current Auctions
            return aid
        }

        pub fun deposit(agent: &DAAM.Admin{DAAM.Agent}, metadataGenerator: Capability<&DAAM.MetadataGenerator{DAAM.MetadataGeneratorMint}>, mid: UInt64, start: UFix64,
            length: UFix64, isExtended: Bool, extendedTime: UFix64, vault: @FungibleToken.Vault, incrementByPrice: Bool, incrementAmount: UFix64,
            startingBid: UFix64?, reserve: UFix64, buyNow: UFix64, reprintSeries: UInt64?): UInt64
        {
            pre { DAAM.isAgent(agent.grantee) == true : "Not a DAAM Agent." }

            let metadataRef = metadataGenerator!.borrow()! as &DAAM.MetadataGenerator{DAAM.MetadataGeneratorMint} // Get MetadataHolder
            let creatorAgent   = metadataRef.viewMetadata(mid : mid)!.creatorInfo.agent
            assert(agent.grantee == creatorAgent, message: "You are not a DAAM Agent.")

            let creator = metadataRef.viewMetadata(mid : mid)!.creatorInfo.creator
            let auction <- self.createAuctionResource(metadataGenerator:metadataGenerator, nft:nil, id:mid, start:start, length:length,
                isExtended:isExtended, extendedTime:extendedTime, vault:<-vault, incrementByPrice:incrementByPrice, incrementAmount:incrementAmount,
                startingBid:startingBid, reserve:reserve, buyNow: buyNow, reprintSeries:reprintSeries)
            let aid = auction.auctionID! // Auction ID

            let old <- self.approveAuctions.insert(key: aid, <- auction) // Update Current Auctions
            destroy old
            return aid
        }

        pub fun agentAuction(auctionID: UInt64, approve: Bool) {
            pre { self.approveAuctions.containsKey(auctionID) : "AID does not exist." }
            // set to Approve, regardless
            let removed <- self.approveAuctions.remove(key: auctionID)!
            let old <- self.currentAuctions.insert(key: auctionID, <- removed)
            destroy old
            // If (dis)approve (false) cancel Auction
            if !approve {
                self.cancelAuction(auctionID: auctionID)
            } else {
                AuctionHouse.currentAuctions.insert(key: self.owner?.address!, self.currentAuctions.keys) // Update Current Auctions
            }
        }

        priv fun createAuctionResource(metadataGenerator: Capability<&DAAM.MetadataGenerator{DAAM.MetadataGeneratorMint}>?, nft: @DAAM.NFT?, id: UInt64, start: UFix64,
            length: UFix64, isExtended: Bool, extendedTime: UFix64, vault: @FungibleToken.Vault, incrementByPrice: Bool, incrementAmount: UFix64,
            startingBid: UFix64?, reserve: UFix64, buyNow: UFix64, reprintSeries: UInt64?): @Auction
        {
            pre {
                (metadataGenerator == nil && nft != nil) || (metadataGenerator != nil && nft == nil) : "You can not enter a Metadata and NFT."
                self.validToken(vault: &vault as &FungibleToken.Vault)       : "We do not except this Token."
            }

            var auction: @Auction? <- nil
            // Is Metadata, not NFT
            if metadataGenerator != nil {
                assert(DAAM.getCopyright(mid: id) != DAAM.CopyrightStatus.FRAUD, message: "This submission has been flaged for Copyright Issues.")
                assert(DAAM.getCopyright(mid: id) != DAAM.CopyrightStatus.CLAIM, message: "This submission has been flaged for a Copyright Claim.")

                AuctionHouse.metadataGen.insert(key: id, metadataGenerator!) // add access to Creators' Metadata
                let metadataRef = metadataGenerator!.borrow()! as &DAAM.MetadataGenerator{DAAM.MetadataGeneratorMint} // Get MetadataHolder
                let minterAccess <- AuctionHouse.minterAccess(mid: id)
                let metadata <-! metadataRef.generateMetadata(minter: <- minterAccess)      // Create MetadataHolder
                // Create Auctions
                let old <- auction <- create Auction(metadata: <-metadata!, nft: nil, start: start, length: length, isExtended: isExtended, extendedTime: extendedTime, vault: <-vault, incrementByPrice: incrementByPrice,
                    incrementAmount: incrementAmount, startingBid: startingBid, reserve: reserve, buyNow: buyNow, reprintSeries: reprintSeries)
                destroy old
                destroy nft // is always empyty
            } else {
                let old <- auction <- create Auction(metadata: nil, nft: <-nft!, start: start, length: length, isExtended: isExtended, extendedTime: extendedTime, vault: <-vault, incrementByPrice: incrementByPrice,
                    incrementAmount: incrementAmount, startingBid: startingBid, reserve: reserve, buyNow: buyNow, reprintSeries: reprintSeries)
                destroy old
            }
            return <- auction!
        }

        // Resolves all Auctions. Closes ones that have been ended or restarts them due to being a reprintSeries auctions.
        // This allows the auctioneer to close auctions to auctions that have ended, returning funds and appropriating items accordingly
        // even in instances where the Winner has not claimed their item.
        pub fun closeAuctions()
        {
            for act in self.currentAuctions.keys {
                let current_status = self.currentAuctions[act]?.updateStatus() // status may have been changed in verifyReservePrive() called by seriesMinter()
                if current_status == false { // Check to see if auction has ended. A false value.
                    let auctionID = self.currentAuctions[act]?.auctionID! // get AID
                    log("Closing Token ID: ")
                    if self.currentAuctions[act]?.auctionNFT != nil || self.currentAuctions[act]?.auctionMetadata != nil { // Winner has not yet collected
                        self.currentAuctions[act]?.verifyReservePrice()! // Winner has not claimed their item. Verify they have meet the reserve price?
                    }

                    if self.currentAuctions[act]?.status == true { // Series Minter is minting another Metadata to NFT. Auction Restarting.
                        continue
                    }

                    self.removeAuction(auctionID)

                    log("Auction Closed: ".concat(auctionID.toString()) )
                    emit AuctionClosed(auctionID: auctionID)
                }
            }
        }

        pub fun closeAuction(_ auctionID: UInt64)
        {
            pre { self.currentAuctions.containsKey(auctionID) : "AID is not in your Wallet." }
            let current_status = self.currentAuctions[auctionID]?.updateStatus() // status may have been changed in verifyReservePrive() called by seriesMinter()
            assert(current_status==false, message: "Auction has not ended.");

            log("Closing Token ID: ")
            if self.currentAuctions[auctionID]?.auctionNFT != nil || self.currentAuctions[auctionID]?.auctionMetadata != nil { // Winner has not yet collected
                self.currentAuctions[auctionID]?.verifyReservePrice()! // Winner has not claimed their item. Verify they have meet the reserve price?
            }

            if self.currentAuctions[auctionID]?.status == true { // Series Minter is minting another Metadata to NFT. Auction Restarting.
                return
            }

            self.removeAuction(auctionID)

            log("Auction Closed: ".concat(auctionID.toString()) )
            emit AuctionClosed(auctionID: auctionID)
        }


        priv fun removeAuction(_ auctionID: UInt64) {
            let auction <- self.currentAuctions.remove(key:auctionID)!   // No Series minting or last mint
            destroy auction                                              // end auction.!
            // Update Current Auctions List
            if self.currentAuctions.keys.length == 0 {
                AuctionHouse.currentAuctions.remove(key:self.owner!.address) // If auctioneer has no more auctions remove from list
            } else {
                AuctionHouse.currentAuctions.insert(key:self.owner!.address, self.currentAuctions.keys) // otherwise update list with reset values
            }
        }

        // Auctions can be cancelled if they have no bids.
        pub fun cancelAuction(auctionID: UInt64) {
            pre { self.currentAuctions.containsKey(auctionID) : "AID is not in your Wallet." }
            self.currentAuctions[auctionID]?.cancelAuction()
        }

        // item(Auction ID) return a reference of the auctionID Auction
        pub fun item(_ aid: UInt64): &Auction{AuctionPublic}? {
            pre { self.currentAuctions.containsKey(aid) }
            return &self.currentAuctions[aid] as &Auction{AuctionPublic}?
        }

        pub fun getAuctions(): [UInt64] { return self.currentAuctions.keys } // Return all auctions by User

        pub fun getAgentAuctions(): [UInt64] { return self.approveAuctions.keys } // Return all auctions by Agent, requires Approval

        pub fun endReprints(auctionID: UInt64) { // Toggles the reprint to OFF. Note: This is not a toggle
            pre {
                self.currentAuctions.containsKey(auctionID)         : "AuctionID does not exist"
                self.currentAuctions[auctionID]?.reprintSeries != 0 : "Reprint is already set to Off."
            }
            self.currentAuctions[auctionID]?.endReprints()
        }

        priv fun validToken(vault: &FungibleToken.Vault): Bool {
            let type = vault.getType()
            let identifier = type.identifier
            return AuctionHouse.crypto.containsKey(identifier)
        }

        destroy() {
        pre { self.currentAuctions.length == 0 && self.approveAuctions.length == 0 }
            destroy self.currentAuctions
            destroy self.approveAuctions
        }
    }
/************************************************************************/
    pub resource interface AuctionPublic {
        pub fun depositToBid(bidder: Address, amount: @FungibleToken.Vault) // @AnyResource{FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance}
        pub fun withdrawBid(bidder: AuthAccount): @FungibleToken.Vault
        pub fun auctionInfo(): AuctionHolder
        pub fun winnerCollect()
        pub fun getBuyNowAmount(bidder: Address): UFix64
        pub fun getMinBidAmount(bidder: Address): UFix64?
        pub fun buyItNow(bidder: Address, amount: @FungibleToken.Vault)
        pub fun buyItNowStatus(): Bool
        pub fun getAuctionLog(): {Address:UFix64}
        pub fun getStatus(): Bool?
        pub fun itemInfo(): DAAM.MetadataHolder?
        pub fun getDisplay(): {String : MetadataViews.Media}
        pub fun timeLeft(): UFix64?
    }
/************************************************************************/
    pub resource Auction: AuctionPublic {
        access(contract) var status: Bool? // nil = auction not started or no bid, true = started (with bid), false = auction ended
        priv var height     : UInt64?      // Stores the final block height made by the final bid only.
        pub var auctionID   : UInt64       // Auction ID number. Note: Series auctions keep the same number.
        pub let creatorInfo : DAAM.CreatorInfo
        pub let mid         : UInt64       // collect Metadata ID
        pub var start       : UFix64       // timestamp
        priv let origLength   : UFix64   // original length of auction, needed to reset if Series
        pub var length        : UFix64   // post{!isExtended && length == before(length)}
        pub let isExtended    : Bool     // true = Auction extends with every bid.
        pub let extendedTime  : UFix64   // when isExtended=true and extendedTime = 0.0. This is equal to a direct Purchase. // Time of Extension.
        pub var leader        : Address? // leading bidder
        pub var minBid        : UFix64?  // minimum bid
        priv let increment    : {Bool : UFix64} // true = is amount, false = is percentage *Note 1.0 = 100%
        pub let startingBid   : UFix64?  // the starting bid of an auction. nil = No Bidding. Direct Purchase
        pub let reserve       : UFix64   // the reserve. must be sold at min price.
        pub let fee           : UFix64   // the fee
        pub let price         : UFix64   // original price
        pub let buyNow        : UFix64   // buy now price original price
        pub var reprintSeries : UInt64?  // Number of reprints, nil = max prints.
        pub var auctionLog    : {Address: UFix64}    // {Bidders, Amount} // Log of the Auction
        access(contract) var auctionMetadata : @DAAM.Metadata? // Store NFT for auction
        access(contract) var auctionNFT : @DAAM.NFT? // Store NFT for auction
        priv var auctionVault : @FungibleToken.Vault // Vault, All funds are stored.
        pub let requiredCurrency: Type

        // Auction: A resource containg the auction itself.
        // start: Enter UNIX Flow Blockchain Time
        // length: Length of auction
        // isExtended: if the auction lenght is to be an Extended Auction
        // extendedTime: The amount of time the extension is to be.
        // incrementByPrice: increment by fixed amount or percentage. True = fixed amount, False = Percentage
        // incrementAmount: the increment value. when incrementByPrice is true, the minimum bid is increased by this amount.
        //                  when False, the minimin bid is increased by that Percentage. Note: 1.0 = 100%
        // startingBid: the initial price. May not be 0.0
        // reserve: The minimum price that must be meet
        // buyNow: To amount to purchase an item directly. Note: 0.0 = OFF
        // reprintSeries: to duplicate the current auction, with a reprint (Next Mint os Series)
        // *** new is defines as "never sold", age is not a consideration. ***
        init(metadata: @DAAM.Metadata?, nft: @DAAM.NFT?, start: UFix64, length: UFix64, isExtended: Bool, extendedTime: UFix64, vault: @FungibleToken.Vault,
          incrementByPrice: Bool, incrementAmount: UFix64, startingBid: UFix64?, reserve: UFix64, buyNow: UFix64, reprintSeries: UInt64?) {
            pre {
                (metadata == nil && nft != nil) || (metadata != nil && nft == nil) : "Can not add NFT & Metadata"
                start >= getCurrentBlock().timestamp : "Time has already past."
                length >= 60.0                       : "Minimum is 1 min"
                buyNow > reserve || buyNow == 0.0    : "The BuyNow option must be greater then the Reserve."
                startingBid != 0.0 : "You can not have a Starting Bid of zero."
                isExtended && extendedTime >= 20.0 || !isExtended && extendedTime == 0.0 : "Extended Time setting are incorrect. The minimim is 20 seconds."
                startingBid == nil && buyNow != 0.0 || startingBid != nil : "Direct Purchase requires BuyItNow amount"
            }
            let metadataHolder: DAAM.MetadataHolder = (metadata != nil) ? metadata?.getHolder()! : nft?.metadata!
            if reprintSeries != nil && metadataHolder.edition.max != nil { assert(reprintSeries! <= metadataHolder.edition.max!, message: "") }
            // Verify starting bid is lower then the reserve price
            if startingBid != nil { assert(reserve > startingBid!, message: "The Reserve must be greater then your Starting Bid") }

            // Manage incrementByPrice
            if incrementByPrice == false && incrementAmount < 0.01  { panic("The minimum increment is 1.0%.")   }
            if incrementByPrice == false && incrementAmount > 0.05  { panic("The maximum increment is 5.0%.")     }
            if incrementByPrice == true  && incrementAmount < 1.0   { panic("The minimum increment is 1 Crypto.") }

            AuctionHouse.auctionCounter = AuctionHouse.auctionCounter + 1 // increment Auction Counter
            self.status = nil // nil = auction not started, true = auction ongoing, false = auction ended
            self.height = nil  // when auction is ended does it get a value
            self.auctionID = AuctionHouse.auctionCounter // Auction uinque ID number

            self.start = start        // When auction start
            self.length = length      // Length of auction
            self.origLength = length  // If length is reset (extneded auction), a new reprint can reset the original length
            self.leader = nil         // Current leader, when nil = no leader
            self.minBid = startingBid // when nil= Direct Purchase, buyNow Must have a value
            self.isExtended = isExtended // isExtended status
            self.extendedTime = (isExtended) ? extendedTime : 0.0 // Store extended time
            self.increment = {incrementByPrice : incrementAmount} // Store increment

            self.startingBid = startingBid
            self.reserve = reserve
            self.price = buyNow

            let ref = (nft != nil) ? &nft?.metadata! as &DAAM.MetadataHolder : &metadata?.getHolder()! as &DAAM.MetadataHolder
            self.creatorInfo = ref.creatorInfo

            if ref.edition.max != nil && reprintSeries == nil { // if there is max and reprint is set to nil ...
                self.reprintSeries = ref.edition.max!           // set reprint to max
            } else if reprintSeries != nil {
                self.reprintSeries = reprintSeries!             // otherwise reprint is equal to argument
            } else {
                self.reprintSeries = nil
            }

            self.mid = ref.mid! // Metadata ID
            if metadata != nil && !AuctionHouse.history.containsKey(self.mid) { // is Metadata and first Auction of Metadata
                let metadataHolder =  metadata?.getHolder()! //as &DAAM.MetadataHolder
                AuctionHouse.history.insert(key: self.mid, {0 : SaleHistory(metadata: metadataHolder)} ) // Element 0 if for data gathering of Metadata/Auction Holder through History.
            }

            self.fee = AuctionHouse.getFee(mid: self.mid)
            self.buyNow = self.price

            self.auctionLog = {} // Maintain record of Crypto // {Address : Crypto}
            self.auctionVault <- vault  // ALL Crypto is stored
            self.requiredCurrency = self.auctionVault.getType()
            self.auctionNFT <- nft // NFT Storage durning auction
            self.auctionMetadata <- metadata // NFT Storage durning auction

            log("Auction Initialized: ".concat(self.auctionID.toString()) )
            emit AuctionCreated(auctionID: self.auctionID, start: self.start)
        }

        // Makes Bid, Bids are deposited into vault
        pub fun depositToBid(bidder: Address, amount: @FungibleToken.Vault) {
            pre {
                amount.isInstance(self.requiredCurrency) : "Incorrect payment currency"
                self.minBid != nil                    : "No Bidding. Direct Purchase Only."
                self.updateStatus() == true           : "Auction is not in progress."
                self.validateBid(bidder: bidder, balance: amount.balance) : "You have made an invalid Bid."
                self.leader != bidder                 : "You are already lead bidder."
                self.creatorInfo.creator != bidder    : "You can not bid in your own auction."
                self.height == nil || getCurrentBlock().height < self.height! : "You bid was too late"
            }
            post { self.verifyAuctionLog() } // Verify Funds

            log("self.minBid: ".concat(self.minBid!.toString()) )

            self.leader = bidder                        // Set new leader
            self.updateAuctionLog(amount.balance)       // Update logs with new balance
            self.incrementminBid()                      // Increment accordingly
            self.auctionVault.deposit(from: <- amount)  // Deposit Crypto into Vault
            self.extendAuction()                        // Extendend auction if applicable

            log("Balance: ".concat(self.auctionLog[self.leader!]!.toString()) )
            log("Min Bid: ".concat(self.minBid!.toString()) )
            log("Bid Accepted")
            emit BidMade(auctionID: self.auctionID, bidder:self.leader! )
        }

        // validateBid: Verifies the amount given meets the minimum bid.
        priv fun validateBid(bidder: Address, balance: UFix64): Bool {
            // Bidders' first bid (New Bidder)
            if !self.auctionLog.containsKey(bidder) {
                if balance >= self.minBid! {
                    return true
                }
                log("Initial Bid too low.")
                return false
            }

            // Otherwise ... (not the Bidders' first bid)
            // Verify bidders' total amount is meets the minimum bid
            if (balance + self.auctionLog[bidder]!) >= self.minBid! {
                return true
            }
            // retutning false, reserve price not meet
            log("Bid Deposit too low.")
            return false
        }

        // increments minimum bid by fixed amount or percentage based on incrementByPrice
        priv fun incrementminBid() {
            let bid = self.auctionLog[self.leader!]! // get current bid
            if self.increment[false] != nil {        // check if increment is by percentage
                self.minBid = bid + (bid * self.increment[false]!) // increase minimum bid by percentage
            } else { // price incrememt by fixed amount
                self.minBid = bid + self.increment[true]!
            }
        }

        // Returns and Updates the current status of the Auction
        // nil = auction not started, true = started, false = auction ended
        access(contract) fun updateStatus(): Bool? {
            if self.status == false {  // false = Auction has already Ended
                log("Status: Auction Previously Ended")
                return false
            }
            // First time Auction has been flaged as Ended
            let auction_time = self.timeLeft() // a return of 0.0 signals the auction has ended.
            if auction_time == 0.0 {
                self.status = false                    // set auction to End (false)
                self.height = getCurrentBlock().height // get height for bids at enf of auction.
                log("Status: Time Limit Reached & Auction Ended")
                emit AuctionEnded(auctionID: self.auctionID, time: getCurrentBlock().timestamp)
                return false
            }

            if auction_time == nil { // nil = Auction has not yet started
                log("Status: Not Started")
                self.status = nil
            } else {
                log("Status: Auction Ongoing")
                self.status = true // true = Auction is ongoing
            }
            return self.status
        }

        // Allows bidder to withdraw their bid as long as they are not the lead bidder.
        pub fun withdrawBid(bidder: AuthAccount): @FungibleToken.Vault {
            pre {
                self.leader! != bidder.address : "You have the Winning Bid. You can not withdraw."
                self.updateStatus() != false   : "Auction has Ended."
                self.auctionLog.containsKey(bidder.address) : "You have not made a Bid"
                self.minBid != nil : "This is a Buy It Now only purchase."
                self.verifyAuctionLog() : "Internal Error!!"
            }
            post { self.verifyAuctionLog() }

            let balance = self.auctionLog[bidder.address]! // Get balance from log
            self.auctionLog.remove(key: bidder.address)!   // Remove from log
            let amount <- self.auctionVault.withdraw(amount: balance) // Withdraw balance from Vault
            log("Bid Withdrawn")
            emit BidWithdrawn(auctionID: self.auctionID, bidder: bidder.address)
            return <- amount  // return bidders deposit amount
        }

        pub fun auctionInfo(): AuctionHolder {
            let info = AuctionHolder(
                self.status, self.auctionID, self.creatorInfo, self.mid, self.start, self.length, self.isExtended,
                self.extendedTime, self.leader, self.minBid, self.startingBid, self.reserve, self.fee,
                self.price, self.buyNow, self.reprintSeries, self.auctionLog, self.requiredCurrency
            )
            return info
        }

        // Winner can 'Claim' an item. Reserve price must be meet, otherwise returned to auctioneer
        pub fun winnerCollect() {
            pre{ self.updateStatus() == false  : "Auction has not Ended." }
            log("Leader: ")
            log(self.leader)
            self.verifyReservePrice() // Verify Reserve price is met
        }

        // This is a key function where are all the action happens.
        // Verifies the Reserve Price is met.
        // Calls royalty() & ReturnFunds() and manages all royalities and funds are returned
        // Sends the item (NFT) or Mints Metadata then Sends, or Returns Metadata
        access(contract) fun verifyReservePrice() {
            pre  { self.updateStatus() == false   : "Auction still in progress" }
            post { self.verifyAuctionLog() } // Verify funds calcuate

            var pass = false       // false till reserve price is verified
            log("Auction Log Length: ".concat(self.auctionLog.length.toString()) )
            if self.leader != nil {
                if self.auctionLog[self.leader!]! >= self.reserve { // Does the leader meet the reserve price?
                    pass = true
                }
            }

            if pass { // leader met the reserve price
                if self.auctionMetadata != nil { // If Metadata turn into nFt
                    let metadata <- self.auctionMetadata <- nil
                    let old <-  self.auctionNFT <- AuctionHouse.mintNFT(metadata: <-metadata!)
                    destroy old
                }
                // remove leader from log before returnFunds()!!
                let amount = self.auctionLog[self.leader!]!
                self.auctionLog.remove(key: self.leader!)!
                self.returnFunds()  // Return funds to all bidders
                self.royalty()      // Pay royalty

                let nft <- self.auctionNFT <- nil // remove nft
                let id = nft?.id!
                let metadata = nft?.metadata!
                let leader = self.leader!
                self.finalise(receiver: self.leader!, nft: <-nft!, pass: pass)
                log("Item: Won")
                let saleHistoryEntry = SaleHistoryEntry(id: id, auctionHolder: self.auctionInfo(), price: amount, from: self.owner!.address, to: leader)
                AuctionHouse.updateAllHistory(mid: self.mid, id: id, metadata: metadata, history: saleHistoryEntry)

                emit ItemWon(auctionID: self.auctionID, winner: leader, tokenID: id, amount: amount, sale: saleHistoryEntry) // Auction Ended, but Item not delivered yet.
            } else {
                let receiver = self.owner!.address   // set receiver from leader to auctioneer
                if self.auctionMetadata != nil { // return Metadata to Creator
                    let metadata <- self.auctionMetadata <- nil
                    let ref = getAccount(receiver!).getCapability<&DAAM.MetadataGenerator{DAAM.MetadataGeneratorPublic}>(DAAM.metadataPublicPath).borrow()!
                    ref.returnMetadata(metadata: <- metadata!)
                    self.returnFunds()              // return funds to all bidders
                    log("Item: Returned")
                    emit ItemReturned(auctionID: self.auctionID, seller: receiver!)
                } else {      // return NFT to Seller, reerve not meet
                    let nft <- self.auctionNFT <- nil
                    self.returnFunds()              // return funds to all bidders
                    self.finalise(receiver: receiver, nft: <-nft!, pass: pass)
                    log("Item: Returned")
                    emit ItemReturned(auctionID: self.auctionID, seller: receiver!)
                }
            }
        }

        priv fun finalise(receiver: Address?, nft: @DAAM.NFT, pass: Bool) {
            log("receiver: ".concat(receiver!.toString()) )
            let collectionRef = getAccount(receiver!).getCapability<&{NonFungibleToken.CollectionPublic}>(DAAM.collectionPublicPath).borrow()!

            var isLast = false
            if nft.metadata!.edition.max != nil {
                isLast = (nft.metadata!.edition.number == nft.metadata!.edition.max!)
            }

            // NFT Deposot Must be LAST !!! *except for seriesMinter
            collectionRef.deposit(token: <- nft!) // deposit nft

            if pass && !isLast { // possible re-auction Series Minter
                self.seriesMinter() // Note must be last after transer of NFT
            }
        }

        // Verifies amount is equal to the buyNow amount. If not returns false
        priv fun verifyBuyNowAmount(bidder: Address, amount: UFix64): Bool {
            log("self.buyNow: ".concat(self.buyNow.toString()) )

            var total = amount
            log("total: ".concat(total.toString()) )
            if self.auctionLog[bidder] != nil {
                total = total + self.auctionLog[bidder]! // get bidders' total deposit
            }
            log("total: ".concat(total.toString()) )
            return self.buyNow == total // compare bidders' total deposit to buyNow
        }

        // Return the amount needed to make the correct bid
        pub fun getBuyNowAmount(bidder: Address): UFix64 {
            // If no bid had been made return buynow price, else return the difference
            return (self.auctionLog[bidder]==nil) ? self.buyNow : (self.buyNow-self.auctionLog[bidder]!)
        }

        // Return the amount needed to make the correct bid
        pub fun getMinBidAmount(bidder: Address): UFix64? {
            // If no bid had been made return minimum bid, else return the difference
            if self.minBid == nil { return nil } // Buy Now Only, return nil
            return (self.auctionLog[bidder]==nil) ? self.minBid : (self.minBid! - self.auctionLog[bidder]!)
        }

        // Record total amount of Crypto a bidder has deposited. Manages Log of that total.
        priv fun updateAuctionLog(_ amount: UFix64) {
            if !self.auctionLog.containsKey(self.leader!) {        // First bid by user
                self.auctionLog.insert(key: self.leader!, amount)  // append log for new bidder and log amount
            } else {
                let total = self.auctionLog[self.leader!]! + amount // get new total deposit of bidder
                self.auctionLog[self.leader!] = total               // append log with new amount
            }
        }

        // To purchase the item directly.
        pub fun buyItNow(bidder: Address, amount: @FungibleToken.Vault) {
            pre {
                amount.isInstance(self.requiredCurrency) : "Incorrect Crypto."
                self.creatorInfo.creator != bidder    : "You can not bid in your own auction."
                self.updateStatus() != false  : "Auction has Ended."
                self.buyNow != 0.0 : "Buy It Now option is not available."
                self.verifyBuyNowAmount(bidder: bidder, amount: amount.balance) : "Wrong Amount."
                // Must be after the above line.
                self.buyItNowStatus() : "Buy It Now option has expired."
            }
            post { self.verifyAuctionLog() } // verify log

            self.status = false          // ends the auction
            self.length = 0.0            // set length to 0; double end auction
            self.leader = bidder         // set new leader

            self.updateAuctionLog(amount.balance)       // update auction log with new leader
            let price = self.auctionLog[self.leader!]!
            self.auctionVault.deposit(from: <- amount)  // depsoit into Auction Vault

            emit BuyItNow(auctionID: self.auctionID, winner: self.leader!, amount: self.buyNow)

            self.winnerCollect() // Will receive NFT if reserve price is met
        }

        // returns BuyItNowStaus, true = active, false = inactive
        pub fun buyItNowStatus(): Bool {
            pre {
                self.buyNow != 0.0 : "No Buy It Now option for this auction."
                self.updateStatus() != false : "Auction is over or invalid."
            }
            if self.leader != nil {
                return self.buyNow > self.auctionLog[self.leader!]! // return 'Buy it Now' price to the current bid
            }
            return true
        }

        // Return all funds in auction log to bidder
        // Note: leader is typically removed from auctionLog before called.
        priv fun returnFunds() {
            post { self.auctionLog.length == 0 : "Illegal Operation: returnFunds" } // Verify auction log is empty
            for bidder in self.auctionLog.keys {
                // get Crypto Wallet capability
                let bidderRef =  getAccount(bidder).getCapability<&{FungibleToken.Receiver}>
                    (MetadataViews.getRoyaltyReceiverPublicPath())
                    .borrow()!
                let amount <- self.auctionVault.withdraw(amount: self.auctionLog[bidder]!)  // Withdraw amount
                self.auctionLog.remove(key: bidder)
                bidderRef.deposit(from: <- amount)  // Deposit amount to bidder
            }
            log("Funds Returned")
            emit FundsReturned(auctionID: self.auctionID)
        }

        pub fun getAuctionLog(): {Address:UFix64} {
            return self.auctionLog
        }

        // Checks for Extended Auction and extends auction accordingly by extendedTime
        priv fun extendAuction() {
            if !self.isExtended { return }     // not Extended Auction return
            let end = self.start + self.length // Get end time
            let new_length = (end - getCurrentBlock().timestamp) + self.extendedTime // get new length
            if new_length > end { self.length = new_length } // if new_length is greater then the original end, update
        }

        pub fun getStatus(): Bool? { // gets Auction status: nil = not started, true = ongoing, false = ended
            return self.updateStatus()
        }

        pub fun itemInfo(): DAAM.MetadataHolder? { // returns the metadata of the item NFT.
            return (self.auctionNFT != nil) ? self.auctionNFT?.metadata! : self.auctionMetadata?.getHolder()
        }

        pub fun getDisplay(): {String : MetadataViews.Media} {
            return (self.auctionNFT != nil) ? self.auctionNFT?.file! : self.auctionMetadata?.file!
        }

        pub fun timeLeft(): UFix64? { // returns time left, nil = not started yet.
            if self.length == 0.0 {
                return 0.0 as UFix64
            } // Extended Auction ended.

            let timeNow = getCurrentBlock().timestamp
            log("TimeNow: ".concat(timeNow.toString()) )
            if timeNow < self.start { return nil } // Auction has not started

            let end = self.start + self.length     // get end time of auction
            log("End: ".concat(end.toString()) )


            if timeNow >= self.start && timeNow < end { // if time is durning auction
                let timeleft = end - timeNow            // calculate time left
                return timeleft                         // return time left
            }
            return 0.0 as UFix64 // return no time left
        }

        priv fun payRoyalty(price: UFix64, royalties: [MetadataViews.Royalty]) {
            pre{ royalties.length > 0 : "Ilegal Operation 1: payRoyalties, price: ".concat(price.toString()) }

            var totalCut    = 0.0
            var totalAmount = 0.0
            var count       = 0
            let last        = royalties.length-1
            var amount      = 0.0

            for royalty in royalties {
                assert(royalty.receiver != nil, message: "Ilegal Operation 2: payRoyalties, price: ".concat(price.toString()) )
                amount   = price * royalty.cut
                totalAmount = totalAmount + amount
                // deals with remainder
                if count == last {
                    let offset = 1.0 - totalCut
                    let offsetAmount = price - totalAmount
                    amount = amount + offsetAmount
                    totalCut = totalCut + offset
                    totalAmount = totalAmount + offsetAmount
                }

                let cut <-! self.auctionVault.withdraw(amount: amount)  // Calculate Agency Crypto share
                let cap = royalty.receiver.borrow()!
                cap.deposit(from: <-cut ) //deposit royalty share

                count = count + 1
            }
            assert(totalCut == 1.0, message: "Price: ".concat(price.toString().concat(" totalCut: ").concat(totalCut.toString())))
            assert(totalAmount == price, message: "Price: ".concat(price.toString().concat(" totalAmount: ").concat(totalAmount.toString())))
        }

        priv fun convertTo100Percent(): [MetadataViews.Royalty] {
            post { rlist.length > 0 : "Illegal Operation: convertTo100Percent" }

            let royalties = self.auctionNFT?.royalty!.getRoyalties()
            assert(royalties.length > 0, message: "Illegal Operation: convertTo100Percent")

            var totalCut = 0.0
            for r in royalties { totalCut = totalCut + r.cut }
            let offset = 1.0 / totalCut
            var rlist: [MetadataViews.Royalty] = []
            let last = royalties.length-1
            var count = 0
            var cut = 0.0

            totalCut = 0.0
            for r in royalties {
                cut = r.cut * offset
                totalCut = totalCut + cut
                assert(r.receiver != nil, message: "Invald Entry: Receipient")
                if count == last { // takes care of remainder
                    let offset = 1.0 - totalCut
                    cut = cut + offset
                    totalCut = totalCut + offset
                }
                rlist.append(MetadataViews.Royalty(
                    receiver: r.receiver!,
                    cut: cut,
                    description: "Royalty Rate"
                ))
                count = count + 1
            }
            assert(totalCut == 1.0 , message: "Illegal Operation: convertTo100Percent, totalCut: ".concat(totalCut.toString()))
            return rlist
        }

        // Returns a percentage of Group. Ex: Bob owns 10%, with percentage at 0.2, will return Bob at 8% along with the rest of Group
        priv fun payFirstSale() {
            post { self.auctionVault.balance == 0.0 : "Royalty Error: ".concat(self.auctionVault.balance.toString() ) } // The Vault should always end empty
            let price       = self.auctionVault.balance / (1.0 + AuctionHouse.getFee(mid: self.mid))
            let fee         = self.auctionVault.balance - price   // Get fee amount
            let creatorRoyalties = self.convertTo100Percent() // get Royalty data
            let daamRoyalty = AuctionHouse.getAgencyFirstSale(mid: self.mid)
            let inHouse = 0.5 // Main setting here

            if self.auctionNFT?.metadata!.creatorInfo.agent == DAAM.company.receiver.address {
                // Below changes are calculated from above settings
                let agency = 1.0 - inHouse
                let nonCreatorAmont = (price * daamRoyalty) + fee
                let inHouseAmount = nonCreatorAmont * inHouse
                let daamAmount = nonCreatorAmont - inHouseAmount
                let creatorAmount = self.auctionVault.balance - nonCreatorAmont
                self.payRoyalty(price: inHouseAmount, royalties: [DAAM.company])
                self.payRoyalty(price: daamAmount, royalties: DAAM.agency.getRoyalties())
                self.payRoyalty(price: creatorAmount, royalties: creatorRoyalties)
            } else {
                // Agent payment
                let agentAmount  = price * self.auctionNFT?.metadata!.creatorInfo.firstSale!
                let agentAddress = self.auctionNFT?.metadata!.creatorInfo.agent!
                let agent = getAccount(agentAddress).getCapability<&{FungibleToken.Receiver}>
                    (MetadataViews.getRoyaltyReceiverPublicPath()!)
                    .borrow()! // get Seller FUSD Wallet Capability
                let agentCut <-! self.auctionVault.withdraw(amount: agentAmount) // Calcuate actual amount
                let feeInHouseAmount = fee * inHouse
                let feeAgencyAmount = fee - feeInHouseAmount
                agent.deposit(from: <-agentCut ) // deposit amount
                self.payRoyalty(price: feeInHouseAmount, royalties: [DAAM.company] ) // Fee Payment
                self.payRoyalty(price: feeAgencyAmount, royalties: DAAM.agency.getRoyalties() ) // Fee Paymen
                self.payRoyalty(price: self.auctionVault.balance, royalties: creatorRoyalties) // Royalty
            }
            assert(self.auctionVault.balance==0.0, message: self.auctionVault.balance.toString().concat(" fee: ").concat(fee.toString()) )
        }

        // Royalty rates are gathered from the NFTs metadata and funds are proportioned accordingly.
        priv fun royalty()
        {
            post { self.auctionVault.balance == 0.0 : "Royalty Error: ".concat(self.auctionVault.balance.toString() ) } // The Vault should always end empty
            if self.auctionVault.balance == 0.0 { return }     // No need to run, already processed.
            let tokenID = self.auctionNFT?.id!                 // Get TokenID
            let inHouse = 0.5                                  // Portion of fee that stays inHouse
            let agency = 1.0 - inHouse
            // If 1st sale is 'new' remove from 'new list'
            if DAAM.isNFTNew(id: tokenID) {
                AuctionHouse.notNew(tokenID: tokenID)
                self.payFirstSale()
            } else {   // 2nd Sale
                let price   = self.auctionVault.balance / (1.0 + self.fee)
                var fee     = self.auctionVault.balance - price   // Get fee amount
                let royalties = self.auctionNFT?.royalty!.getRoyalties() // get Royalty data

                self.payRoyalty(price: price, royalties:royalties)
                self.payRoyalty(price: fee * inHouse, royalties: [DAAM.company] ) // get Comapny share of fee
                self.payRoyalty(price: fee * agency, royalties: DAAM.agency.getRoyalties() ) // Pay Agency the fee

                let seller = self.owner?.getCapability<&{FungibleToken.Receiver}>
                    (MetadataViews.getRoyaltyReceiverPublicPath())!
                    .borrow()! // get Seller FUSD Wallet Capability
                let sellerCut <-! self.auctionVault.withdraw(amount: self.auctionVault.balance) // Calcuate actual amount
                seller.deposit(from: <-sellerCut ) // deposit amount
            }
        }

        // Comapres Log to Vault. Makes sure Funds match. Should always be true!
        priv fun verifyAuctionLog(): Bool {
            var total = 0.0
            for bidder in self.auctionLog.keys {
                total = total + self.auctionLog[bidder]! // get total in logs
            }
            log("Verify Auction Log: ")
            log(self.auctionLog)
            log("AID: ".concat(self.auctionID.toString()) )
            return total == self.auctionVault.balance    // compare total to Vault
        }

        // Resets all variables that need to be reset for restarting a reprintSeries auction.
        priv fun resetAuction() {
            pre { self.auctionVault.balance == 0.0 : "Internal Error: Serial Minter" }  // already called by SerialMinter

            if self.reprintSeries != nil {                   // nil is unlimited prints
                self.reprintSeries = self.reprintSeries! - 1 // Decrement reprint
            }

            self.leader = nil
            self.start = getCurrentBlock().timestamp // reset new auction to start at current time
            self.length = self.origLength
            self.auctionLog = {}
            self.minBid = self.startingBid
            self.status = true
            self.height = nil
            log("Reset: Variables")
        }

        // Where the reprintSeries Mints another NFT.
        priv fun seriesMinter() {
            pre { self.auctionVault.balance == 0.0 : "Internal Error: Serial Minter" } // Verifty funds from previous auction are gone.
            if self.reprintSeries == 1 { return } // if reprint is set to off (false) return
            if self.creatorInfo.creator != self.owner!.address { return } // Verify Owner is Creator (element 0) otherwise skip function

            let metadataRef = AuctionHouse.metadataGen[self.mid]!.borrow()!   // get Metadata Generator Reference
            let minterAccess <- AuctionHouse.minterAccess(mid: self.mid)
            let metadata <-! metadataRef.generateMetadata(minter: <- minterAccess)
            let old <- self.auctionNFT <- AuctionHouse.mintNFT(metadata: <-metadata) // Mint NFT and deposit into auction
            destroy old // destroy place holder

            self.resetAuction() // reset variables for next auction
        }

        // End reprints. Set to OFF
        access(contract) fun endReprints() {
           pre {
                self.reprintSeries != 0 : "Reprints is already off."
                self.auctionNFT?.metadata!.creatorInfo.creator == self.owner!.address : "You are not the Creator of this NFT"
           }
           self.reprintSeries = 0
        }

        // Auctions can be cancelled if they have no bids.
        pub fun cancelAuction() {
            pre {
                self.updateStatus() == nil || true         : "Too late to cancel Auction."
                self.auctionLog.length == 0                : "You already have a bid. Too late to Cancel."
            }

            self.status = false
            self.length = 0.0

            log("Auction Cancelled: ".concat(self.auctionID.toString()) )
            emit AuctionCancelled(auctionID: self.auctionID)
        }

        destroy() { // Verify no Funds, NFT are NOT in storage, Auction has ended/closed.
            pre{
                self.auctionNFT == nil           : "Illegal Operation: Auction still contains NFT Token ID: ".concat(self.auctionNFT?.metadata!.mid.toString())
                self.auctionMetadata == nil      : "Illegal Operation: Auction still contains MetadataID: ".concat(self.auctionMetadata?.mid!.toString())
                self.status == false             : "Illegal Operation: Auction is not Finished."
                self.auctionVault.balance == 0.0 : "Illegal Operation: Auction Balance is ".concat(self.auctionVault.balance.toString())
            }
            // Re-Verify Funds Allocated Properly, since it's empty it should just pass
            self.returnFunds()
            self.royalty()

            destroy self.auctionVault
            destroy self.auctionNFT
            destroy self.auctionMetadata
        }
    }
/************************************************************************/
// AuctionHouse Functions & Constructor

    // Sets NFT to 'not new'
    access(contract) fun notNew(tokenID: UInt64) {
        let minter = self.account.borrow<&DAAM.Minter>(from: DAAM.minterStoragePath)!
        minter.notNew(tokenID: tokenID) // Set to not new
    }

    // Get current auctions { Address : [AID] }
    pub fun getCurrentAuctions(): {Address:[UInt64]} {
        return self.currentAuctions
    }

    // Get current auctions { Address : [AID] }
    pub fun getCurrentAuctionsStatus(_ status: Bool?): {Address:[UInt64]} {
        let currentAuctions = self.currentAuctions
        let selectedAuction: {Address:[UInt64]} = {}
        for seller in currentAuctions.keys {
            let auctionHouse = getAccount(seller).getCapability<&AuctionHouse.AuctionWallet{AuctionHouse.AuctionWalletPublic}>
                (AuctionHouse.auctionPublicPath).borrow()!
            let aids = currentAuctions[seller]!
            let list: [UInt64] = []
            for aid in aids {
                let mRef = auctionHouse.item(aid) as &AuctionHouse.Auction{AuctionHouse.AuctionPublic}?
                let current_status = mRef!.getStatus()
                if status == current_status { list.append(aid) }
            }
            if list.length > 0 { selectedAuction.insert(key: seller, list)}
        }
        return selectedAuction
    }

    // Requires Minter Key // Minter function to mint
    access(contract) fun mintNFT(metadata: @DAAM.Metadata): @DAAM.NFT {
        let minterRef = self.account.borrow<&DAAM.Minter>(from: DAAM.minterStoragePath)! // get Minter Reference
        let nft <- minterRef.mintNFT(metadata: <-metadata)! // Mint NFT
        return <- nft                                    // Return NFT
    }

    // Requires Minter Key // Minter function to mint
    access(contract) fun minterAccess(mid: UInt64): @DAAM.MinterAccess {
        let minterRef = self.account.borrow<&DAAM.Minter>(from: DAAM.minterStoragePath)! // get Minter Reference
        let minter_access <- minterRef.createMinterAccess(mid: mid)
        return <- minter_access                                  // Return NFT
    }

    access(contract) fun updateAllHistory(mid: UInt64, id: UInt64, metadata: DAAM.MetadataHolder, history: SaleHistoryEntry) {
        // update saleHistory
        if self.saleHistory.containsKey(id) {
            self.saleHistory[id]!.add(history)
        } else {
            let saleHistory = SaleHistory(metadata: metadata)
            saleHistory.add(history)
            self.saleHistory.insert(key: id, saleHistory ) // Add new TokenID auction history
        }
        // update history
        if self.history.containsKey(mid) {
            let ref = &self.history[mid]! as &{UInt64 : SaleHistory}
            ref[id] = self.saleHistory[id]
        } else {
            self.history.insert(key: mid, {id : self.saleHistory[id]! } ) // Add new TokenID auction history
        }
    }

    pub fun getSaleHistory(id: UInt64?): {UInt64: SaleHistory}? { // {TokenID : SaleHistory}
        if id == nil { return self.saleHistory }
        if !self.saleHistory.containsKey(id!) { return nil}
        let salehistory = self.saleHistory[id!]!
        return {id! : salehistory}
    }

    pub fun getHistory(mid: UInt64?): {UInt64 : {UInt64: SaleHistory}}? { //{MID : {TokenID:SaleHistory} }
        if mid == nil { return self.history }
        if !self.history.containsKey(mid!) { return nil}
        let history = self.history[mid!]!
        return {mid! : history}
    }

    pub fun getFee(mid: UInt64): UFix64 {
        return (self.fee[mid] == nil) ? 0.025 : self.fee[mid]!
    }

    pub fun addFee(mid: UInt64, fee: UFix64, permission: &DAAM.Admin) {
        pre { DAAM.isAdmin(permission.owner!.address) == true : "Permission Denied" }
        self.fee[mid] = fee
    }

    pub fun removeFee(mid: UInt64, fee: UFix64, permission: &DAAM.Admin) {
        pre {
            DAAM.isAdmin(permission.owner!.address) == true : "Permission Denied"
            self.fee[mid] != nil : "No set Fee for this MID."
        }
        self.fee.remove(key: mid)
    }

    pub fun getAgencyFirstSale(mid: UInt64): UFix64 {
        return (self.agencyFirstSale[mid] == nil) ? 0.15 : self.agencyFirstSale[mid]!
    }

    pub fun addAgencyFirstSale(mid: UInt64, fee: UFix64, permission: &DAAM.Admin) {
        pre { DAAM.isAdmin(permission.owner!.address) == true : "Permission Denied" }
        self.agencyFirstSale[mid] = fee
    }

    pub fun removeAgencyFirstSale(mid: UInt64, fee: UFix64, permission: &DAAM.Admin) {
        pre {
            DAAM.isAdmin(permission.owner!.address) == true : "Permission Denied"
            self.fee[mid] != nil : "No set Fee for this MID."
        }
        self.agencyFirstSale.remove(key: mid)
    }

    pub fun addCrypto(crypto: &FungibleToken.Vault, path: PublicPath, permission: &DAAM.Admin) {
        pre { DAAM.isAdmin(permission.owner!.address) == true : "Permission Denied" }
        let type = crypto.getType()
        let identifier = type.identifier
        self.crypto.insert(key: identifier, path)
    }

    pub fun removeCrypto(crypto: String, permission: &DAAM.Admin) {
        pre {
            DAAM.isAdmin(permission.owner!.address) == true : "Permission Denied"
            self.crypto[crypto] != nil : "This Crypto is not accepted.."
        }
        self.crypto.remove(key: crypto)
    }

    pub fun getCrypto(): [String] {
        return self.crypto.keys
    }

    // Create Auction Wallet which is used for storing Auctions.
    pub fun createAuctionWallet(): @AuctionWallet {
        return <- create AuctionWallet()
    }

    init() {
        self.crypto          = {}
        self.metadataGen     = {}
        self.currentAuctions = {}
        self.fee             = {}
        self.saleHistory     = {}
        self.history         = {}
        self.agencyFirstSale = {}
        self.auctionCounter  = 0
        self.auctionStoragePath = /storage/DAAM_Auction
        self.auctionPublicPath  = /public/DAAM_Auction
    }
}

"
-------
"pub contract DapperWalletCollections {
    pub let StoragePath: StoragePath

    pub event TypeChanged(identifier: String, added: Bool)

    access(self) let types: {Type: Bool}

    pub resource Admin {
        pub fun addType(_ t: Type) {
            DapperWalletCollections.types.insert(key: t, true)
            emit TypeChanged(identifier: t.identifier, added: true)
        }

        pub fun removeType( _ t: Type) {
            DapperWalletCollections.types.remove(key: t)
            emit TypeChanged(identifier: t.identifier, added: false)
        }
    }

    pub fun containsType(_ t: Type): Bool {
        return self.types.containsKey(t)
    }

    pub fun getTypes(): {Type:Bool} {
        return self.types
    }

    init () {
        self.types = {}

        self.StoragePath = /storage/dapperWalletCollections
        self.account.save(<- create Admin(), to: self.StoragePath)
    }
}"
-------
"import MetadataViews from 0x1d7e57aa55817448
import NonFungibleToken from 0x1d7e57aa55817448
import StringUtils from 0xe52522745adf5c34

access(all) contract Utils {

    /// getCollectionPaths
    /// This function searches the specified account and returns a dictionary of NFTCollectionData structs by
    /// collectionIdentifier. If a collectionIdentifier is not found in the specified ownerAddress, or that collection
    /// does not provide a resolver for NFTCollectionData, the response value will be "nil".
    access(all) fun getNFTCollectionData(ownerAddress: Address, nftIdentifiers: [String]): {String: MetadataViews.NFTCollectionData} {

        let response: {String: MetadataViews.NFTCollectionData} = {}

        let account = getAccount(ownerAddress)

    	account.forEachPublic(fun (path: PublicPath, type: Type): Bool {

            let collectionPublic = account.getCapability<&{NonFungibleToken.CollectionPublic}>(path).borrow()
    	    if (collectionPublic == nil) {

    		    return true
    	    }

            let contractParts = StringUtils.split(collectionPublic!.getType().identifier, ".")
    		let contractIdentifier = StringUtils.join(contractParts.slice(from: 0, upTo: contractParts.length - 1), ".")
            let nftIdentifier = contractIdentifier.concat(".NFT")

    		if (!nftIdentifiers.contains(nftIdentifier) || response.containsKey(nftIdentifier)) {

    		    return true
    	    }

            let nftRef: &{NonFungibleToken.INFT} = collectionPublic!.borrowNFT(id: collectionPublic!.getIDs()[0]) as &{NonFungibleToken.INFT}

            let collectionData = (nftRef.resolveView(Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?)
                ?? panic("collection lookup failed")

            response.insert(key: nftIdentifier, collectionData)

            return true
        })

    	return response
    }
}
"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import FungibleTokenMetadataViews from 0xf233dcee88fe0abe
import MetadataViews from 0x1d7e57aa55817448
import Toucans from 0x577a3c409c5dcb5e
import ToucansTokens from 0x577a3c409c5dcb5e

pub contract Flowiykyk: FungibleToken {

    // The amount of tokens in existance
    pub var totalSupply: UFix64
    // nil if there is none
    pub let maxSupply: UFix64?

    // Paths
    pub let VaultStoragePath: StoragePath
    pub let ReceiverPublicPath: PublicPath
    pub let VaultPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath
    pub let AdministratorStoragePath: StoragePath

    // Events
    pub event TokensInitialized(initialSupply: UFix64)
    pub event TokensWithdrawn(amount: UFix64, from: Address?)
    pub event TokensDeposited(amount: UFix64, to: Address?)
    pub event TokensTransferred(amount: UFix64, from: Address, to: Address)
    pub event TokensMinted(amount: UFix64)
    pub event TokensBurned(amount: UFix64)

    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance, MetadataViews.Resolver {
        pub var balance: UFix64

        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)

            if let owner: Address = self.owner?.address {
                Flowiykyk.setBalance(address: owner, balance: self.balance)
            }
            return <- create Vault(balance: amount)
        }

        pub fun deposit(from: @FungibleToken.Vault) {
            let vault: @Vault <- from as! @Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)

            // We set the balance to 0.0 here so that it doesn't
            // decrease the totalSupply in the `destroy` function.
            vault.balance = 0.0
            destroy vault

            if let owner: Address = self.owner?.address {
                Flowiykyk.setBalance(address: owner, balance: self.balance)
            }
        }

        pub fun getViews(): [Type]{
            return [Type<FungibleTokenMetadataViews.FTView>(),
                    Type<FungibleTokenMetadataViews.FTDisplay>(),
                    Type<FungibleTokenMetadataViews.FTVaultData>()]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<FungibleTokenMetadataViews.FTView>():
                    return FungibleTokenMetadataViews.FTView(
                        ftDisplay: self.resolveView(Type<FungibleTokenMetadataViews.FTDisplay>()) as! FungibleTokenMetadataViews.FTDisplay?,
                        ftVaultData: self.resolveView(Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
                    )
                case Type<FungibleTokenMetadataViews.FTDisplay>():
                    let media = MetadataViews.Media(
                            file: MetadataViews.HTTPFile(
                            url: "https://nftstorage.link/ipfs/bafkreic7ubmxctthynqlkxdsueu3j6vluibjewufklcf4qbl4slu5n5vh4"
                        ),
                        mediaType: "image"
                    )
                    let bannerMedia = MetadataViews.Media(
                            file: MetadataViews.HTTPFile(
                            url: "https://nftstorage.link/ipfs/bafkreidsefca7voeczhz57kkt5fjlel3x43wqwbrhfhweq3zbe7z5rtc5i"
                        ),
                        mediaType: "image"
                    )
                    let medias = MetadataViews.Medias([media, bannerMedia])
                    return FungibleTokenMetadataViews.FTDisplay(
                        name: "Flow iykyk",
                        symbol: "FIFI",
                        description: "I hope FIFI can achieve complete decentralization and explore the spirit of memes on the Flow blockchain. Therefore, I have set the total supply to 10^11 (can't get it larger lol, maybe due to the setting of toucans), ensuring that everyone will have a significant amount of FIFI.",
                        externalURL: MetadataViews.ExternalURL(""),
                        logos: medias,
                        socials: {
                            "twitter": MetadataViews.ExternalURL(""),
                            "discord": MetadataViews.ExternalURL("")
                        }
                    )
                case Type<FungibleTokenMetadataViews.FTVaultData>():
                    return FungibleTokenMetadataViews.FTVaultData(
                        storagePath: Flowiykyk.VaultStoragePath,
                        receiverPath: Flowiykyk.ReceiverPublicPath,
                        metadataPath: Flowiykyk.VaultPublicPath,
                        providerPath: /private/FlowiykykVault,
                        receiverLinkedType: Type<&Vault{FungibleToken.Receiver}>(),
                        metadataLinkedType: Type<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(),
                        providerLinkedType: Type<&Vault{FungibleToken.Provider}>(),
                        createEmptyVaultFunction: (fun (): @Vault {
                            return <- Flowiykyk.createEmptyVault()
                        })
                    )
            }
            return nil
        }

        init(balance: UFix64) {
            self.balance = balance
        }

        destroy() {
            emit TokensBurned(amount: self.balance)
            Flowiykyk.totalSupply = Flowiykyk.totalSupply - self.balance
        }
    }

    pub fun createEmptyVault(): @Vault {
        return <- create Vault(balance: 0.0)
    }

    pub resource Minter: Toucans.Minter {
        pub fun mint(amount: UFix64): @Vault {
            post {
                Flowiykyk.maxSupply == nil || Flowiykyk.totalSupply <= Flowiykyk.maxSupply!:
                    "Exceeded the max supply of tokens allowd."
            }
            Flowiykyk.totalSupply = Flowiykyk.totalSupply + amount
            emit TokensMinted(amount: amount)
            return <- create Vault(balance: amount)
        }
    }

    // We follow this pattern of storage
    // so the (potentially) huge dictionary
    // isn't loaded when the contract is imported
    pub resource Administrator {
        // This is an experimental index and should
        // not be used for anything official
        // or monetary related
        access(self) let balances: {Address: UFix64}

        access(contract) fun setBalance(address: Address, balance: UFix64) {
            self.balances[address] = balance
        }

        pub fun getBalance(address: Address): UFix64 {
            return self.balances[address] ?? 0.0
        }

        pub fun getBalances(): {Address: UFix64} {
            return self.balances
        }

        init() {
            self.balances = {}
        }
    }

    access(contract) fun setBalance(address: Address, balance: UFix64) {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        admin.setBalance(address: address, balance: balance)
    }

    pub fun getBalance(address: Address): UFix64 {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalance(address: address)
    }

    pub fun getBalances(): {Address: UFix64} {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalances()
    }

    init(
      _paymentTokenInfo: ToucansTokens.TokenInfo,
      _editDelay: UFix64,
      _minting: Bool,
      _initialTreasurySupply: UFix64,
      _maxSupply: UFix64?,
      _extra: {String: AnyStruct}
    ) {

      // Contract Variables
      self.totalSupply = 0.0
      self.maxSupply = _maxSupply

      // Paths
      self.VaultStoragePath = /storage/FlowiykykVault
      self.ReceiverPublicPath = /public/FlowiykykReceiver
      self.VaultPublicPath = /public/FlowiykykMetadata
      self.MinterStoragePath = /storage/FlowiykykMinter
      self.AdministratorStoragePath = /storage/FlowiykykAdmin

      // Admin Setup
      let vault <- create Vault(balance: self.totalSupply)
      self.account.save(<- vault, to: self.VaultStoragePath)

      self.account.link<&Vault{FungibleToken.Receiver}>(
          self.ReceiverPublicPath,
          target: self.VaultStoragePath
      )

      self.account.link<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(
          self.VaultPublicPath,
          target: self.VaultStoragePath
      )

      if self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath) == nil {
        self.account.save(<- Toucans.createCollection(), to: Toucans.CollectionStoragePath)
        self.account.link<&Toucans.Collection{Toucans.CollectionPublic}>(Toucans.CollectionPublicPath, target: Toucans.CollectionStoragePath)
      }

      let toucansProjectCollection = self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath)!
      toucansProjectCollection.createProject(
        projectTokenInfo: ToucansTokens.TokenInfo("Flowiykyk", self.account.address, "FIFI", self.ReceiverPublicPath, self.VaultPublicPath, self.VaultStoragePath),
        paymentTokenInfo: _paymentTokenInfo,
        minter: <- create Minter(),
        editDelay: _editDelay,
        minting: _minting,
        initialTreasurySupply: _initialTreasurySupply,
        extra: _extra
      )

      self.account.save(<- create Administrator(), to: self.AdministratorStoragePath)

      // Events
      emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
 "
-------
"import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract Redeemables: NonFungibleToken {
	pub event ContractInitialized()
	pub event Withdraw(id: UInt64, from: Address?)
	pub event Deposit(id: UInt64, to: Address?)
	pub event Minted(id: UInt64, address: Address, setId: UInt64, templateId: UInt64, name: String)
	pub event Redeemed(id: UInt64, address: Address, setId: UInt64, templateId: UInt64, name: String)
	pub event Burned(id: UInt64, address: Address, setId: UInt64, templateId: UInt64, name: String)
    pub event SetCreated(id: UInt64, name: String)
	pub event TemplateCreated(id: UInt64, setId: UInt64, name: String)

	pub let CollectionStoragePath: StoragePath
	pub let CollectionPublicPath: PublicPath
	pub let CollectionPrivatePath: PrivatePath
	pub let AdminStoragePath: StoragePath

	pub var totalSupply: UInt64
	pub let sets: {UInt64 : Set}
	pub let templates: {UInt64 : Template}
	pub let templateNextSerialNumber: {UInt64 : UInt64}

	access(self) let extra: {String: AnyStruct}

	pub struct Set {
		pub let id: UInt64
		pub var name: String
		pub var canRedeem: Bool
        pub var redeemLimitTimestamp : UFix64
		pub var active: Bool
	    access(contract) let ownersRecord: [Address]

		access(self) let extra: {String: AnyStruct}

		init(name: String, canRedeem: Bool, redeemLimitTimestamp: UFix64, active: Bool) {
			self.id = UInt64(Redeemables.sets.keys.length) + 1
			self.name = name
			self.canRedeem = canRedeem
			self.redeemLimitTimestamp = redeemLimitTimestamp
			self.active = active
			self.ownersRecord = []
			self.extra = {}
		}

		pub fun getName() : String {
			return self.name
		}

		pub fun isRedeemLimitExceeded() : Bool {
			return self.redeemLimitTimestamp < getCurrentBlock().timestamp
		}

		access(contract) fun setActive(_ active: Bool) {
			self.active = active
		}

		access(contract) fun setCanRedeem(_ canRedeem: Bool) {
			self.canRedeem = canRedeem
		}

		access(contract) fun setRedeemLimitTimestamp(_ redeemLimitTimestamp: UFix64) {
			self.redeemLimitTimestamp = redeemLimitTimestamp
		}

		access(contract) fun addOwnerRecord(_ address: Address): Bool {
			if self.ownersRecord.contains(address) {
				return false
			}
			self.ownersRecord.append(address)
			return true
		}
	}

	pub struct Template {
		pub let id: UInt64
		pub let setId: UInt64
		pub var name: String
		pub var description: String
		pub var brand: String
		pub var royalties: [MetadataViews.Royalty]
		pub var type: String
		pub var thumbnail: MetadataViews.Media
		pub var image: MetadataViews.Media
		pub var active: Bool

		access(self) let extra: {String : AnyStruct}

		init(setId: UInt64, name: String, description: String, brand: String, royalties: [MetadataViews.Royalty], type: String, thumbnail: MetadataViews.Media, image: MetadataViews.Media, active: Bool) {
			pre {
				Redeemables.sets.containsKey(setId) : "Set does not exist. Id: ".concat(setId.toString())
			}
			self.id = UInt64(Redeemables.templates.keys.length) + 1
			self.setId = setId
			self.name = name
			self.description = description
			self.brand = brand
			self.royalties = royalties
			self.type = type
			self.thumbnail = thumbnail
			self.image = image
			self.active = active
			self.extra = {}
		}

		pub fun getSet() : Redeemables.Set {
			return Redeemables.sets[self.setId]!
		}

		access(contract) fun setActive(_ active: Bool) {
			self.active = active
		}

		pub fun getTermsOfService() : String? {
			return self.extra["termsOfService"] as! String?
		}

		access(contract) fun setTermsOfService(_ termsOfService: String) {
			self.extra["termsOfService"] = termsOfService
		}
	}

	pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
		pub let id:UInt64
		pub let templateId: UInt64
		pub let serialNumber: UInt64

		access(self) let extra: {String : AnyStruct}

		init(templateId: UInt64) {
			self.id = self.uuid
			self.templateId = templateId
			self.serialNumber = Redeemables.templateNextSerialNumber[templateId] ?? 1
			self.extra = {}

			Redeemables.templateNextSerialNumber[templateId] = self.serialNumber + 1
			Redeemables.totalSupply = Redeemables.totalSupply + 1
		}

		pub fun getViews(): [Type] {
			return  [
				Type<MetadataViews.Display>(),
				Type<MetadataViews.Royalties>(),
				Type<MetadataViews.ExternalURL>(),
				Type<MetadataViews.NFTCollectionData>(),
				Type<MetadataViews.NFTCollectionDisplay>(),
				Type<MetadataViews.Traits>(),
				Type<MetadataViews.Editions>()
			]
		}

		pub fun getTemplate() : Template {
			return Redeemables.templates[self.templateId]!
		}

		pub fun getSet() : Set {
			return self.getTemplate().getSet()
		}

		pub fun resolveView(_ view: Type): AnyStruct? {
			switch view {
				case Type<MetadataViews.Display>():
					let template = self.getTemplate()
					return MetadataViews.Display(
						name: template.name,
						description: template.description,
						thumbnail: template.thumbnail.file,
					)

				case Type<MetadataViews.ExternalURL>():
					return MetadataViews.ExternalURL("https://doodles.app")

				case Type<MetadataViews.Traits>():
					let template=self.getTemplate()
					let traits : [MetadataViews.Trait]= []

					traits.append(MetadataViews.Trait(
						name: "Name",
						value: template.name,
							displayType: "string",
						rarity: nil
					))

					traits.append(MetadataViews.Trait(
						name: "Brand",
						value: template.brand,
						displayType: "string",
						rarity: nil
					))

					traits.append(MetadataViews.Trait(
						name: "Set",
						value: template.getSet().name,
						displayType: "string",
						rarity: nil
					))

					traits.append(MetadataViews.Trait(
						name: "Type",
						value: template.type,
						displayType: "string",
						rarity: nil
					))

					traits.append(MetadataViews.Trait(
						name: "Redeem Limit Date",
						value: template.getSet().redeemLimitTimestamp,
						displayType: "Date",
						rarity: nil
					))

					if template.getTermsOfService() != nil {
						traits.append(MetadataViews.Trait(
							name: "Terms of Service",
							value: template.getTermsOfService(),
							displayType: "string",
							rarity: nil
						))
					}

					return MetadataViews.Traits(traits)

				case Type<MetadataViews.Royalties>():
					let royalties = self.getTemplate().royalties
					let royalty=royalties[0]

					let doodlesMerchantAccountMainnet="0x014e9ddc4aaaf557"
					//royalties if we sell on something else then DapperWallet cannot go to the address stored in the contract, and Dapper will not allow us to setup forwarders for Flow/USDC
					if royalty.receiver.address.toString() == doodlesMerchantAccountMainnet {

						//this is an account that have setup a forwarder for DUC/FUT to the merchant account of Doodles.
						let royaltyAccountWithDapperForwarder = getAccount(0x12be92985b852cb8)
						let cap = royaltyAccountWithDapperForwarder.getCapability<&{FungibleToken.Receiver}>(/public/fungibleTokenSwitchboardPublic)
						return MetadataViews.Royalties([MetadataViews.Royalty(receiver:cap, cut: royalty.cut, description:royalty.description)])
					}

					let doodlesMerchanAccountTestnet="0xd5b1a1553d0ed52e"
					if royalty.receiver.address.toString() == doodlesMerchanAccountTestnet {
						//on testnet we just send this to the main vault, it is not important
						let cap = Redeemables.account.getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)
						return MetadataViews.Royalties([MetadataViews.Royalty(receiver:cap, cut: royalty.cut, description:royalty.description)])
					}

					return royalties
			}

			return Redeemables.resolveView(view)
		}
	}

	pub resource interface RedeemablesCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowRedeemable(id: UInt64): &Redeemables.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow RedeemNFT reference: the ID of the returned reference is incorrect"
            }
        }
        pub fun redeem(id: UInt64)
        pub fun burnUnredeemedSet(set: Redeemables.Set)
    }

	pub resource Collection: RedeemablesCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection  {
		pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

		init () {
			self.ownedNFTs <- {}
		}

		pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
			let token <- (self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")) as! @NFT

			assert(!token.getSet().isRedeemLimitExceeded(), message: "Set redeem limit timestamp reached")

			emit Withdraw(id: token.id, from: self.owner?.address)

			return <-token
		}

		pub fun deposit(token: @NonFungibleToken.NFT) {
			let token <- token as! @NFT

			assert(!token.getSet().isRedeemLimitExceeded(), message: "Set redeem limit timestamp reached")

			let set = token.getSet()
			set.addOwnerRecord(self.owner!.address)
			Redeemables.sets[set.id] = set

			let id: UInt64 = token.id

			let oldToken <- self.ownedNFTs[id] <- token

			emit Deposit(id: id, to: self.owner?.address)

			destroy oldToken
		}

		pub fun getIDs(): [UInt64] {
			return self.ownedNFTs.keys
		}

		pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
			return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
		}

		pub fun borrowRedeemable(id: UInt64) : &Redeemables.NFT? {
			if self.ownedNFTs[id] != nil {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &Redeemables.NFT
            }

            return nil
		}

		pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
			let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
			let redeemable = nft as! &NFT
			return redeemable
		}

		pub fun redeem(id: UInt64) {
			let nft <- (self.ownedNFTs.remove(key: id) ?? panic("missing NFT")) as! @NFT
			let template = nft.getTemplate()
			let set = template.getSet()

			assert(set.canRedeem, message: "Set not available to redeem: ".concat(set.name))
			assert(!set.isRedeemLimitExceeded(), message: "Set redeem limit timestamp reached: ".concat(set.name))

			emit Redeemed(id: id, address: self.owner!.address, setId: set.id, templateId: template.id, name: template.name)
			emit Burned(id: id, address: self.owner!.address, setId: set.id, templateId: template.id, name: template.name)

			destroy nft
		}

		pub fun burnUnredeemedSet(set: Redeemables.Set) {
			assert(set.isRedeemLimitExceeded(), message: "Set redeem limit timestamp not reached: ".concat(set.name))

			let ids = self.ownedNFTs.keys
			for id in ids {
				let nft = self.borrowRedeemable(id: id)!
				let template = nft.getTemplate()
				if template.getSet().id == set.id {
					emit Burned(id: id, address: self.owner!.address, setId: set.id, templateId: template.id, name: template.name)
					destroy <- self.ownedNFTs.remove(key: id)!
				}
			}
		}

		destroy() {
			destroy self.ownedNFTs
		}
	}

	pub fun createEmptyCollection(): @NonFungibleToken.Collection {
		return <- create Collection()
	}

	pub resource Admin {}

	access(account) fun createSet(name: String, canRedeem: Bool, redeemLimitTimestamp: UFix64, active: Bool) {
		let set = Set(name: name, canRedeem: canRedeem, redeemLimitTimestamp: redeemLimitTimestamp, active: active)
		emit SetCreated(id: set.id, name: set.name)
		Redeemables.sets[set.id] = set
	}

	access(account) fun updateSetActive(setId: UInt64, active: Bool) {
		pre {
			Redeemables.sets.containsKey(setId) : "Set does not exist. Id: ".concat(setId.toString())
		}
		let set = Redeemables.sets[setId]!
		set.setActive(active)
		Redeemables.sets[setId] = set
	}

	access(account) fun updateSetCanRedeem(setId: UInt64, canRedeem: Bool) {
		pre {
			Redeemables.sets.containsKey(setId) : "Set does not exist. Id: ".concat(setId.toString())
		}
		let set = Redeemables.sets[setId]!
		set.setCanRedeem(canRedeem)
		Redeemables.sets[setId] = set
	}

	access(account) fun updateSetRedeemLimitTimestamp(setId: UInt64, redeemLimitTimestamp: UFix64) {
		pre {
			Redeemables.sets.containsKey(setId) : "Set does not exist. Id: ".concat(setId.toString())
		}
		let set = Redeemables.sets[setId]!
		set.setRedeemLimitTimestamp(redeemLimitTimestamp)
		Redeemables.sets[setId] = set
	}

	access(account) fun createTemplate(
		setId: UInt64,
		name: String,
		description: String,
		brand: String,
		royalties: [MetadataViews.Royalty],
		type: String,
		thumbnail: MetadataViews.Media,
		image: MetadataViews.Media,
		active: Bool,
		extra: {String: AnyStruct}
	) {
		pre {
			Redeemables.sets.containsKey(setId) : "Set does not exist. Id: ".concat(setId.toString())
		}
		let template = Template(setId: setId, name: name, description: description, brand: brand, royalties: royalties, type: type, thumbnail: thumbnail, image: image, active: active)

		let termsOfService = extra["termsOfService"] as! String?
		if termsOfService != nil {
			template.setTermsOfService(termsOfService!)
		}

		emit TemplateCreated(id: template.id, setId: setId, name: name)
		Redeemables.templates[template.id] = template
	}

	access(account) fun updateTemplateActive(templateId: UInt64, active: Bool) {
		pre {
			Redeemables.templates.containsKey(templateId) : "Template does not exist. Id: ".concat(templateId.toString())
		}
		let template = Redeemables.templates[templateId]!
		template.setActive(active)
		Redeemables.templates[templateId] = template
	}

	access(account) fun mintNFT(recipient: &{NonFungibleToken.Receiver}, templateId: UInt64){
		pre {
			recipient.owner != nil : "Recipients NFT collection is not owned"
			Redeemables.templates.containsKey(templateId) : "Template does not exist. Id: ".concat(templateId.toString())
		}

		let template = Redeemables.templates[templateId] ?? panic("Template does not exist. Id: ".concat(templateId.toString()))
		let set = Redeemables.sets[template.setId] ?? panic("Set does not exist. Id: ".concat(template.setId.toString()))

		assert(!set.isRedeemLimitExceeded(), message: "Set redeem limit timestamp reached: ".concat(set.name))
		assert(set.active, message: "Set not active: ".concat(set.name))
		assert(template.active, message: "Template not active: ".concat(template.name))

		var newNFT <- create NFT(templateId: templateId)

		emit Minted(id: newNFT.id, address:recipient.owner!.address, setId: set.id, templateId: template.id, name: template.name)

		recipient.deposit(token: <-newNFT)
	}

	access(account) fun burnUnredeemedSet(setId: UInt64) {
		let set = Redeemables.sets[setId] ?? panic("Set does not exist. Id: ".concat(setId.toString()))

		assert(set.isRedeemLimitExceeded(), message: "Set redeem limit timestamp not reached: ".concat(set.name))

		let addresses = set.ownersRecord

		for address in addresses {
			let collection =
				getAccount(address).getCapability<&{Redeemables.RedeemablesCollectionPublic}>(Redeemables.CollectionPublicPath).borrow()
			if collection != nil {
				collection!.burnUnredeemedSet(set: set)
			}
		}
	}

	pub fun getViews(): [Type] {
        return [
            Type<MetadataViews.NFTCollectionDisplay>(),
            Type<MetadataViews.NFTCollectionData>()
        ]
    }

    pub fun resolveView(_ view: Type): AnyStruct? {
        switch view {
            case Type<MetadataViews.NFTCollectionDisplay>():
				return MetadataViews.NFTCollectionDisplay(
					name: "Redeemables",
					description: "Doodles 2 lets anyone create a uniquely personalized and endlessly customizable character in a one-of-a-kind style. Wearables and other collectibles can easily be bought, traded, or sold. Doodles 2 will also incorporate collaborative releases with top brands in fashion, music, sports, gaming, and more. Redeemables are a part of the Doodles ecosystem that will allow you to turn in this NFT within a particular period of time to receive a physical collectible.",
					externalURL: MetadataViews.ExternalURL("https://doodles.app"),
					squareImage: MetadataViews.Media(file: MetadataViews.IPFSFile(cid: "QmVpAiutpnzp3zR4q2cUedMxsZd8h5HDeyxs9x3HibsnJb", path: nil), mediaType:"image/png"),
					bannerImage: MetadataViews.Media(file: MetadataViews.IPFSFile(cid: "QmVoTikzygffMaPcacyTjF8mQ71Eg3zsMF4p4fbsAtGQmQ", path: nil), mediaType:"image/png"),
					socials: {
						"instagram": MetadataViews.ExternalURL("https://www.instagram.com/thedoodles"),
						"discord": MetadataViews.ExternalURL("https://discord.gg/doodles"),
						"twitter": MetadataViews.ExternalURL("https://twitter.com/doodles")
					}
				)
			case Type<MetadataViews.NFTCollectionData>():
				return MetadataViews.NFTCollectionData(
					storagePath: Redeemables.CollectionStoragePath,
					publicPath: Redeemables.CollectionPublicPath,
					providerPath: Redeemables.CollectionPrivatePath,
					publicCollection: Type<&Collection{Redeemables.RedeemablesCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
					publicLinkedType: Type<&Collection{Redeemables.RedeemablesCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
					providerLinkedType: Type<&Collection{NonFungibleToken.Provider, Redeemables.RedeemablesCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
					createEmptyCollectionFunction: fun(): @NonFungibleToken.Collection {
						return <- Redeemables.createEmptyCollection()
					}
				)
        }
        return nil
    }

	init() {
		self.totalSupply = 0

		self.sets = {}
		self.templates = {}
		self.templateNextSerialNumber = {}
		self.extra = {}

		self.CollectionStoragePath = /storage/redeemables
		self.CollectionPublicPath = /public/redeemables
		self.CollectionPrivatePath = /private/redeemables

		self.AdminStoragePath = /storage/redeemablesAdmin

		self.account.save<@NonFungibleToken.Collection>(<- Redeemables.createEmptyCollection(), to: Redeemables.CollectionStoragePath)
		self.account.link<&Redeemables.Collection{Redeemables.RedeemablesCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(
			Redeemables.CollectionPublicPath,
			target: Redeemables.CollectionStoragePath
		)
		self.account.link<&Redeemables.Collection{Redeemables.RedeemablesCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(
			Redeemables.CollectionPrivatePath,
			target: Redeemables.CollectionStoragePath
		)

        self.account.save(<-create Admin(), to: self.AdminStoragePath)

		emit ContractInitialized()
	}
}
 "
-------
"import FungibleToken from 0xf233dcee88fe0abe
import FungibleTokenMetadataViews from 0xf233dcee88fe0abe
import MetadataViews from 0x1d7e57aa55817448
import Toucans from 0x577a3c409c5dcb5e
import ToucansTokens from 0x577a3c409c5dcb5e

pub contract Duckcoin: FungibleToken {

    // The amount of tokens in existance
    pub var totalSupply: UFix64
    // nil if there is none
    pub let maxSupply: UFix64?

    // Paths
    pub let VaultStoragePath: StoragePath
    pub let ReceiverPublicPath: PublicPath
    pub let VaultPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath
    pub let AdministratorStoragePath: StoragePath

    // Events
    pub event TokensInitialized(initialSupply: UFix64)
    pub event TokensWithdrawn(amount: UFix64, from: Address?)
    pub event TokensDeposited(amount: UFix64, to: Address?)
    pub event TokensTransferred(amount: UFix64, from: Address, to: Address)
    pub event TokensMinted(amount: UFix64)
    pub event TokensBurned(amount: UFix64)

    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance, MetadataViews.Resolver {
        pub var balance: UFix64

        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)

            if let owner: Address = self.owner?.address {
                Duckcoin.setBalance(address: owner, balance: self.balance)
            }
            return <- create Vault(balance: amount)
        }

        pub fun deposit(from: @FungibleToken.Vault) {
            let vault: @Vault <- from as! @Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)

            // We set the balance to 0.0 here so that it doesn't
            // decrease the totalSupply in the `destroy` function.
            vault.balance = 0.0
            destroy vault

            if let owner: Address = self.owner?.address {
                Duckcoin.setBalance(address: owner, balance: self.balance)
            }
        }

        pub fun getViews(): [Type]{
            return [Type<FungibleTokenMetadataViews.FTView>(),
                    Type<FungibleTokenMetadataViews.FTDisplay>(),
                    Type<FungibleTokenMetadataViews.FTVaultData>()]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<FungibleTokenMetadataViews.FTView>():
                    return FungibleTokenMetadataViews.FTView(
                        ftDisplay: self.resolveView(Type<FungibleTokenMetadataViews.FTDisplay>()) as! FungibleTokenMetadataViews.FTDisplay?,
                        ftVaultData: self.resolveView(Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
                    )
                case Type<FungibleTokenMetadataViews.FTDisplay>():
                    let media = MetadataViews.Media(
                            file: MetadataViews.HTTPFile(
                            url: "https://nftstorage.link/ipfs/bafkreicxpcbvwiwhlksi6gjwif6bivg67ti53lcjv3ozyo3h6iyul5otay"
                        ),
                        mediaType: "image"
                    )
                    let bannerMedia = MetadataViews.Media(
                            file: MetadataViews.HTTPFile(
                            url: "https://nftstorage.link/ipfs/bafkreig374egrfhgxvqabvgnu2gadm6nvgtzjsxda44zwis5zf4siyxw4u"
                        ),
                        mediaType: "image"
                    )
                    let medias = MetadataViews.Medias([media, bannerMedia])
                    return FungibleTokenMetadataViews.FTDisplay(
                        name: "Duck coin",
                        symbol: "DUCK",
                        description: "$Duck meme coin will unify people and start the next big Flow wave, from private company chain to people blockchain, one duck at a time.",
                        externalURL: MetadataViews.ExternalURL("www.duck-coin.vip/"),
                        logos: medias,
                        socials: {
                            "twitter": MetadataViews.ExternalURL("DuckCoin_flow"),
                            "discord": MetadataViews.ExternalURL("")
                        }
                    )
                case Type<FungibleTokenMetadataViews.FTVaultData>():
                    return FungibleTokenMetadataViews.FTVaultData(
                        storagePath: Duckcoin.VaultStoragePath,
                        receiverPath: Duckcoin.ReceiverPublicPath,
                        metadataPath: Duckcoin.VaultPublicPath,
                        providerPath: /private/DuckcoinVault,
                        receiverLinkedType: Type<&Vault{FungibleToken.Receiver}>(),
                        metadataLinkedType: Type<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(),
                        providerLinkedType: Type<&Vault{FungibleToken.Provider}>(),
                        createEmptyVaultFunction: (fun (): @Vault {
                            return <- Duckcoin.createEmptyVault()
                        })
                    )
            }
            return nil
        }

        init(balance: UFix64) {
            self.balance = balance
        }

        destroy() {
            emit TokensBurned(amount: self.balance)
            Duckcoin.totalSupply = Duckcoin.totalSupply - self.balance
        }
    }

    pub fun createEmptyVault(): @Vault {
        return <- create Vault(balance: 0.0)
    }

    pub resource Minter: Toucans.Minter {
        pub fun mint(amount: UFix64): @Vault {
            post {
                Duckcoin.maxSupply == nil || Duckcoin.totalSupply <= Duckcoin.maxSupply!:
                    "Exceeded the max supply of tokens allowd."
            }
            Duckcoin.totalSupply = Duckcoin.totalSupply + amount
            emit TokensMinted(amount: amount)
            return <- create Vault(balance: amount)
        }
    }

    // We follow this pattern of storage
    // so the (potentially) huge dictionary
    // isn't loaded when the contract is imported
    pub resource Administrator {
        // This is an experimental index and should
        // not be used for anything official
        // or monetary related
        access(self) let balances: {Address: UFix64}

        access(contract) fun setBalance(address: Address, balance: UFix64) {
            self.balances[address] = balance
        }

        pub fun getBalance(address: Address): UFix64 {
            return self.balances[address] ?? 0.0
        }

        pub fun getBalances(): {Address: UFix64} {
            return self.balances
        }

        init() {
            self.balances = {}
        }
    }

    access(contract) fun setBalance(address: Address, balance: UFix64) {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        admin.setBalance(address: address, balance: balance)
    }

    pub fun getBalance(address: Address): UFix64 {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalance(address: address)
    }

    pub fun getBalances(): {Address: UFix64} {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalances()
    }

    init(
      _paymentTokenInfo: ToucansTokens.TokenInfo,
      _editDelay: UFix64,
      _minting: Bool,
      _initialTreasurySupply: UFix64,
      _maxSupply: UFix64?,
      _extra: {String: AnyStruct}
    ) {

      // Contract Variables
      self.totalSupply = 0.0
      self.maxSupply = _maxSupply

      // Paths
      self.VaultStoragePath = /storage/DuckcoinVault
      self.ReceiverPublicPath = /public/DuckcoinReceiver
      self.VaultPublicPath = /public/DuckcoinMetadata
      self.MinterStoragePath = /storage/DuckcoinMinter
      self.AdministratorStoragePath = /storage/DuckcoinAdmin

      // Admin Setup
      let vault <- create Vault(balance: self.totalSupply)
      self.account.save(<- vault, to: self.VaultStoragePath)

      self.account.link<&Vault{FungibleToken.Receiver}>(
          self.ReceiverPublicPath,
          target: self.VaultStoragePath
      )

      self.account.link<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(
          self.VaultPublicPath,
          target: self.VaultStoragePath
      )

      if self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath) == nil {
        self.account.save(<- Toucans.createCollection(), to: Toucans.CollectionStoragePath)
        self.account.link<&Toucans.Collection{Toucans.CollectionPublic}>(Toucans.CollectionPublicPath, target: Toucans.CollectionStoragePath)
      }

      let toucansProjectCollection = self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath)!
      toucansProjectCollection.createProject(
        projectTokenInfo: ToucansTokens.TokenInfo("Duckcoin", self.account.address, "DUCK", self.ReceiverPublicPath, self.VaultPublicPath, self.VaultStoragePath),
        paymentTokenInfo: _paymentTokenInfo,
        minter: <- create Minter(),
        editDelay: _editDelay,
        minting: _minting,
        initialTreasurySupply: _initialTreasurySupply,
        extra: _extra
      )

      self.account.save(<- create Administrator(), to: self.AdministratorStoragePath)

      // Events
      emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
 "
-------
"import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import SwapStats from 0x15f55a75d7843780
import SwapStatsRegistry from 0x15f55a75d7843780
import SwapArchive from 0x15f55a75d7843780
import Utils from 0x15f55a75d7843780

access(all) contract Swap {

    /// ProposalCreated
    /// Event to notify when a user has created a swap proposal
    access(all) event ProposalCreated(proposal: ReadableSwapProposal)

    /// ProposalExecuted
    /// Event to notify when a user has executed a previously created swap proposal
    access(all) event ProposalExecuted(proposal: ReadableSwapProposal)

    /// ProposalDeleted
    /// Event to notify when a user has deleted a previously created swap proposal
    access(all) event ProposalDeleted(proposal: ReadableSwapProposal)

    /// AllowSwapProposalCreation
    /// Toggle to control creation of new swap proposals
    access(all) var AllowSwapProposalCreation: Bool

    /// SwapCollectionStoragePath
    /// Storage directory used to store the SwapCollection object
    access(all) let SwapCollectionStoragePath: StoragePath

    /// SwapCollectionPrivatePath
    /// Private directory used to expose the SwapCollectionManager capability
    access(all) let SwapCollectionPrivatePath: PrivatePath

    /// SwapCollectionPublicPath
    /// Public directory used to store the SwapCollectionPublic capability
    access(all) let SwapCollectionPublicPath: PublicPath

    /// SwapAdminStoragePath
    /// Storage directory used to store SwapAdmin object
    access(all) let SwapAdminStoragePath: StoragePath

    /// SwapAdminPrivatePath
    /// Storage directory used to store SwapAdmin capability
    access(all) let SwapAdminPrivatePath: PrivatePath

    /// SwapFees
    /// Array of all fees currently applied to swap proposals
    access(all) let SwapFees: [Fee]

    /// SwapProposalMinExpirationMinutes
    /// Minimum number of minutes that a swap proposal can be set to expire in
    access(all) var SwapProposalMinExpirationMinutes: UFix64

    /// SwapProposalMaxExpirationMinutes
    /// Maximum number of minutes that a swap proposal can be set to expire in
    access(all) var SwapProposalMaxExpirationMinutes: UFix64

    /// SwapProposalDefaultExpirationMinutes
    /// Default nubmer of minutes for swap proposal exiration
    access(all) var SwapProposalDefaultExpirationMinutes: UFix64

    /// Readable
    /// An interface for publicly readable structs.
    access(all) struct interface Readable {
        access(all) view fun getReadable(): {String: AnyStruct}
    }

    /// ProposedTradeAsset
    /// An NFT asset proposed as part of a swap.
    access(all) struct ProposedTradeAsset: Readable {
        access(all) let nftID: UInt64
        access(all) let type: Type
        access(all) let collectionData: Utils.StorableNFTCollectionData

        access(all) view fun getReadable(): {String: String} {
            return {
                "nftID": self.nftID.toString(),
                "type": self.type.identifier
            }
        }

        init(
            nftID: UInt64,
            type: String,
            collectionData: MetadataViews.NFTCollectionData
        ) {

            let inputType = CompositeType(type) ?? panic("unable to cast type; must be a valid NFT type reference")

            self.nftID = nftID
            self.type = inputType
            self.collectionData = Utils.StorableNFTCollectionData(collectionData)
        }
    }

    /// Fee
    /// This struct represents a fee to be paid upon execution of the swap proposal.
    /// The feeGroup indicates the set of payment methods to which this fee belongs. For each feeGroup, the user is only
    /// required to provide one matching feeProvider in the UserCapabilities objects. This allows for a single fee to be
    /// payable in multiple currencies.
    access(all) struct Fee: Readable {
        access(all) let receiver: Capability<&AnyResource{FungibleToken.Receiver}>
        access(all) let amount: UFix64
        access(all) let feeGroup: UInt8
        access(all) let tokenType: Type

        init(
            receiver: Capability<&AnyResource{FungibleToken.Receiver}>,
            amount: UFix64,
            feeGroup: UInt8
        ) {

            assert(receiver.check(), message: "invalid fee receiver")
            let tokenType = receiver.borrow()!.getType()
            assert(amount > 0.0, message: "fee amount must be greater than zero")

            self.receiver = receiver
            self.amount = amount
            self.feeGroup = feeGroup
            self.tokenType = tokenType
        }

        access(all) view fun getReadable(): {String: String} {
            return {
                "receiverAddress": self.receiver.address.toString(),
                "amount": self.amount.toString(),
                "feeGroup": self.feeGroup.toString(),
                "tokenType": self.tokenType.identifier
            }
        }
    }

    /// UserOffer
    /// This struct represents one user's half of a swap, detailing their address and proposed assets as well as any
    /// metadata that might be required (currently not used)
    access(all) struct UserOffer: Readable {
        access(all) let userAddress: Address
        access(all) let proposedNfts: [ProposedTradeAsset]
        access(all) let metadata: {String: String}?

        access(all) view fun getReadable(): {String: [{String: String}]} {

            let readableOffer: {String: [{String: String}]} = {}
            let readableProposedNfts: [{String: String}] = []
            for proposedNft in self.proposedNfts {
                readableProposedNfts.append(proposedNft.getReadable())
            }
            readableOffer.insert(key: "proposedNfts", readableProposedNfts)

            if (self.metadata != nil && self.metadata!.keys!.length! > 0) {
                readableOffer.insert(key: "metadata", [self.metadata!])
            }

            return readableOffer
        }

        init(
            userAddress: Address,
            proposedNfts: [ProposedTradeAsset],
            metadata: {String: String}?
        ) {
            self.userAddress = userAddress
            self.proposedNfts = proposedNfts
            self.metadata = metadata
        }
    }

    /// UserCapabilities
    /// This struct contains the providers needed to send the user's offered tokens and any required fees, as well as the
    /// receivers needed to accept the trading partner's tokens and any extra capabilities that might be required.
    /// For capability dictionaries, each token's type identifier is used as the key for each entry in each dict.
    access(all) struct UserCapabilities {
        access(contract) let collectionReceiverCapabilities: {String: Capability<&{NonFungibleToken.Receiver}>}
        access(contract) let collectionProviderCapabilities: {String: Capability<&{NonFungibleToken.Provider}>}
        access(contract) let feeProviderCapabilities: {String: Capability<&{FungibleToken.Provider, FungibleToken.Balance}>}?
        access(contract) let extraCapabilities: {String: Capability}?

        init(
            collectionReceiverCapabilities: {String: Capability<&{NonFungibleToken.Receiver}>},
            collectionProviderCapabilities: {String: Capability<&{NonFungibleToken.Provider}>},
            feeProviderCapabilities: {String: Capability<&{FungibleToken.Provider, FungibleToken.Balance}>}?,
            extraCapabilities: {String: Capability}?
        ) {
            self.collectionReceiverCapabilities = collectionReceiverCapabilities
            self.collectionProviderCapabilities = collectionProviderCapabilities
            self.feeProviderCapabilities = feeProviderCapabilities
            self.extraCapabilities = extraCapabilities
        }
    }

    /// ReadableSwapProposal
    /// Struct for return type to SwapProposal.getReadable()
    access(all) struct ReadableSwapProposal {
        access(all) let id: String
        access(all) let fees: [{String: String}]
        access(all) let minutesRemainingBeforeExpiration: String
        access(all) let leftUserAddress: String
        access(all) let leftUserOffer: {String: [{String: String}]}
        access(all) let rightUserAddress: String
        access(all) let rightUserOffer: {String: [{String: String}]}
        access(all) let metadata: {String: String}?

        init(
            id: String,
            fees: [Fee],
            expirationEpochMilliseconds: UFix64,
            leftUserOffer: UserOffer,
            rightUserOffer: UserOffer,
            metadata: {String: String}?
        ) {

            let readableFees: [{String: String}] = []
            for fee in fees {
                readableFees.append(fee.getReadable())
            }

            let currentTimestamp: UFix64 = getCurrentBlock().timestamp
            var minutesRemaining: UFix64 = 0.0
            if (expirationEpochMilliseconds > currentTimestamp) {
                minutesRemaining = (expirationEpochMilliseconds - currentTimestamp) / 60000.0
            }

            self.id = id
            self.fees = readableFees
            self.minutesRemainingBeforeExpiration = minutesRemaining.toString()
            self.leftUserAddress = leftUserOffer.userAddress.toString()
            self.leftUserOffer = leftUserOffer.getReadable()
            self.rightUserAddress = rightUserOffer.userAddress.toString()
            self.rightUserOffer = rightUserOffer.getReadable()
            self.metadata = metadata
        }
    }

    /// SwapProposal
    /// Struct to represent a proposed swap, which is stored in a user's SwapCollection until executed by the right user
    access(all) struct SwapProposal {

        // Semi-unique identifier (unique within the left user's account) to identify swap proposals
        access(all) let id: String

        // Array of all fees to be paid out on execution of swap proposal (can be empty array in case of zero fees)
        access(all) let fees: [Fee]

        // When this swap proposal should no longer be eligible to be accepted (in epoch milliseconds)
        access(all) let expirationEpochMilliseconds: UFix64

        // The offer of the initializing user
        access(all) let leftUserOffer: UserOffer

        // The offer of the secondary proposer
        access(all) let rightUserOffer: UserOffer

        // The trading capabilities of the initializing user
        access(self) let leftUserCapabilities: UserCapabilities

        // A dictionary of metadata
        // Currently used for "sourceId"
        access(self) let metadata: {String: String}?

        init(
            id: String,
            leftUserOffer: UserOffer,
            rightUserOffer: UserOffer,
            leftUserCapabilities: UserCapabilities,
            expirationOffsetMinutes: UFix64,
            metadata: {String: String}?
        ) {

            assert(leftUserOffer.proposedNfts.length > 0 || rightUserOffer.proposedNfts.length > 0,
                message: "At least one side of the swap needs an asset")
            assert(expirationOffsetMinutes >= Swap.SwapProposalMinExpirationMinutes,
                message: "expirationOffsetMinutes must be greater than or equal to Swap.SwapProposalMinExpirationMinutes")
            assert(expirationOffsetMinutes <= Swap.SwapProposalMaxExpirationMinutes,
                message: "expirationOffsetMinutes must be less than or equal to Swap.SwapProposalMaxExpirationMinutes")
            assert(Swap.AllowSwapProposalCreation, message: "swap proposal creation is paused")

            // convert offset minutes to epoch milliseconds
            let expirationEpochMilliseconds = getCurrentBlock().timestamp + (expirationOffsetMinutes * 1000.0 * 60.0)

            // verify that the left user owns their proposed assets has supplied proper capabilities
            Swap.verifyUserOffer(
                userOffer: leftUserOffer,
                userCapabilities: leftUserCapabilities,
                partnerOffer: rightUserOffer,
                fees: Swap.SwapFees
            )

            self.id = id
            self.fees = Swap.SwapFees
            self.leftUserOffer = leftUserOffer
            self.rightUserOffer = rightUserOffer
            self.leftUserCapabilities = leftUserCapabilities
            self.expirationEpochMilliseconds = expirationEpochMilliseconds
            self.metadata = metadata

            emit ProposalCreated(proposal: self.getReadableSwapProposal())
        }

        // Get a human-readable version of the swap proposal data
        access(contract) view fun getReadableSwapProposal(): ReadableSwapProposal {
            return ReadableSwapProposal(
                id: self.id,
                fees: self.fees,
                expirationEpochMilliseconds: self.expirationEpochMilliseconds,
                leftUserOffer: self.leftUserOffer,
                rightUserOffer: self.rightUserOffer,
                metadata: self.metadata
            )
        }

        // Function to execute the proposed swap
        access(contract) fun execute(rightUserCapabilities: UserCapabilities) {

            assert(getCurrentBlock().timestamp <= self.expirationEpochMilliseconds, message: "swap proposal is expired")

            // verify capabilities and ownership of tokens for both users
            Swap.verifyUserOffer(
                userOffer: self.leftUserOffer,
                userCapabilities: self.leftUserCapabilities,
                partnerOffer: self.rightUserOffer,
                fees: self.fees
            )
            Swap.verifyUserOffer(
                userOffer: self.rightUserOffer,
                userCapabilities: rightUserCapabilities,
                partnerOffer: self.leftUserOffer,
                fees: self.fees
            )

            var id = "default"
            if (self.metadata?.containsKey("environmentId") ?? false) {
                id = self.metadata!["environmentId"]!
            }

            let mapNfts = fun (_ array: [ProposedTradeAsset]) : [SwapArchive.SwapNftData] {
                var res : [SwapArchive.SwapNftData] = []
                for item in array {
                    let nftData = SwapArchive.SwapNftData(
                        id: item.nftID,
                        type: item.type
                    )
                    res.append(nftData)
                }
                return res
            }

            // archive swap
            SwapArchive.archiveSwap(id: id, SwapArchive.SwapData(
                id: self.id,
                leftAddress: self.leftUserOffer.userAddress,
                rightAddress: self.rightUserOffer.userAddress,
                leftNfts: mapNfts(self.leftUserOffer.proposedNfts),
                rightNfts: mapNfts(self.rightUserOffer.proposedNfts),
                metadata: nil
            ))

            // execute both sides of the offer
            Swap.executeUserOffer(
                userOffer: self.leftUserOffer,
                userCapabilities: self.leftUserCapabilities,
                partnerCapabilities: rightUserCapabilities,
                fees: self.fees
            )
            Swap.executeUserOffer(
                userOffer: self.rightUserOffer,
                userCapabilities: rightUserCapabilities,
                partnerCapabilities: self.leftUserCapabilities,
                fees: self.fees
            )

            // update swap stats
            SwapStatsRegistry.addAccountStats(id: id, address: self.leftUserOffer.userAddress, SwapStatsRegistry.AccountSwapData(
                partnerAddress: self.rightUserOffer.userAddress,
                totalTradeVolumeSent: UInt(self.leftUserOffer.proposedNfts.length)!,
                totalTradeVolumeReceived: UInt(self.rightUserOffer.proposedNfts.length)!
            ))

            SwapStatsRegistry.addAccountStats(id: id, address: self.rightUserOffer.userAddress, SwapStatsRegistry.AccountSwapData(
                partnerAddress: self.leftUserOffer.userAddress,
                totalTradeVolumeSent: UInt(self.rightUserOffer.proposedNfts.length)!,
                totalTradeVolumeReceived: UInt(self.leftUserOffer.proposedNfts.length)!
            ))

            emit ProposalExecuted(proposal: self.getReadableSwapProposal())
        }
    }

    /// SwapCollectionManager
    /// This interface allows private linking of management methods for the SwapCollection owner
    access(all) resource interface SwapCollectionManager {
        access(all) fun createProposal(
            leftUserOffer: UserOffer,
            rightUserOffer: UserOffer,
            leftUserCapabilities: UserCapabilities,
            expirationOffsetMinutes: UFix64?,
            metadata: {String: String}?
        ): String
        access(all) view fun getAllProposals(): {String: ReadableSwapProposal}
        access(all) fun deleteProposal(id: String)
    }

    /// SwapCollectionPublic
    /// This interface allows public linking of the get and execute methods for trading partners
    access(all) resource interface SwapCollectionPublic {
        access(all) view fun getProposal(id: String): ReadableSwapProposal
        access(all) view fun getUserOffer(proposalId: String, leftOrRight: String): UserOffer
        access(all) fun executeProposal(id: String, rightUserCapabilities: UserCapabilities)
    }

    access(all) resource SwapCollection: SwapCollectionManager, SwapCollectionPublic {

        // Dict to store by swap id all trade offers created by the end user
        access(self) let swapProposals: {String: SwapProposal}

        // Function to create and store a swap proposal
        access(all) fun createProposal(
            leftUserOffer: UserOffer,
            rightUserOffer: UserOffer,
            leftUserCapabilities: UserCapabilities,
            expirationOffsetMinutes: UFix64?,
            metadata: {String: String}?
        ): String {

            // generate semi-random number for the SwapProposal id
            var semiRandomId: String = unsafeRandom().toString()
            while (self.swapProposals[semiRandomId] != nil) {
                semiRandomId = unsafeRandom().toString()
            }

            // create swap proposal and add to swapProposals
            let newSwapProposal = SwapProposal(
                id: semiRandomId,
                leftUserOffer: leftUserOffer,
                rightUserOffer: rightUserOffer,
                leftUserCapabilities: leftUserCapabilities,
                expirationOffsetMinutes: expirationOffsetMinutes ?? Swap.SwapProposalDefaultExpirationMinutes,
                metadata: metadata
            )
            self.swapProposals.insert(key: semiRandomId, newSwapProposal)

            return semiRandomId
        }

        // Function to get a readable version of a single swap proposal
        access(all) view fun getProposal(id: String): ReadableSwapProposal {

            let noSwapProposalMessage: String = "found no swap proposal with id "
            let swapProposal: SwapProposal = self.swapProposals[id] ?? panic(noSwapProposalMessage.concat(id))

            return swapProposal.getReadableSwapProposal()
        }

        // Function to get a readable version of all swap proposals
        access(all) view fun getAllProposals(): {String: ReadableSwapProposal} {

            let proposalReadErrorMessage: String = "unable to get readable swap proposal for id "
            let readableSwapProposals: {String: ReadableSwapProposal} = {}

            for swapProposalId in self.swapProposals.keys {
                let swapProposal = self.swapProposals[swapProposalId] ?? panic(proposalReadErrorMessage.concat(swapProposalId))
                readableSwapProposals.insert(key: swapProposalId, swapProposal!.getReadableSwapProposal())
            }

            return readableSwapProposals
        }

        // Function to provide the specified user offer details
        access(all) view fun getUserOffer(proposalId: String, leftOrRight: String): UserOffer {

            let noSwapProposalMessage: String = "found no swap proposal with id "
            let swapProposal: SwapProposal = self.swapProposals[proposalId] ?? panic(noSwapProposalMessage.concat(proposalId))

            var userOffer: UserOffer? = nil

            switch leftOrRight.toLower() {
                case "left":
                    userOffer = swapProposal.leftUserOffer
                case "right":
                    userOffer = swapProposal.rightUserOffer
                default:
                    panic("argument leftOrRight must be either 'left' or 'right'")
            }

            return userOffer!
        }

        // Function to delete a swap proposal
        access(all) fun deleteProposal(id: String) {

            let noSwapProposalMessage: String = "found no swap proposal with id "
            let swapProposal: SwapProposal = self.swapProposals[id] ?? panic(noSwapProposalMessage.concat(id))
            let readableSwapProposal: ReadableSwapProposal = swapProposal.getReadableSwapProposal()

            self.swapProposals.remove(key: id)
            emit ProposalDeleted(proposal: readableSwapProposal)
        }

        // Function to execute a previously created swap proposal
        access(all) fun executeProposal(id: String, rightUserCapabilities: UserCapabilities) {

            let noSwapProposalMessage: String = "found no swap proposal with id "
            let swapProposal: SwapProposal = self.swapProposals[id] ?? panic(noSwapProposalMessage.concat(id))

            swapProposal.execute(rightUserCapabilities: rightUserCapabilities)
            self.deleteProposal(id: id)
        }

        init() {
            self.swapProposals = {}
        }
    }

    /// SwapProposalManager
    /// This interface allows private linking of swap proposal management functionality
    access(all) resource interface SwapProposalManager {
        access(all) fun stopProposalCreation()
        access(all) fun startProposalCreation()
        access(all) fun updateMinExpiration(_ exp: UFix64)
        access(all) fun updateMaxExpiration(_ exp: UFix64)
        access(all) fun updateDefaultExpiration(_ exp: UFix64)
    }

    access(all) resource interface SwapFeeManager {
        access(all) fun addFee(fee: Fee)
        access(all) fun removeFeeGroup(feeGroup: UInt8)
    }

    access(all) resource interface SwapStatsManager {
        access(all) fun addAccountStats(id: String, address: Address, _ data: SwapStatsRegistry.AccountSwapData)
        access(all) fun clearAccountStats(id: String, address: Address)
        access(all) fun clearAllAccountStatsById(id: String, limit: Int?)
        access(all) fun clearAllAccountStatsLookupById(id: String, limit: Int?)
        access(all) fun clearAllAccountStatsPartnersById(id: String, limit: Int?)
    }

    /// SwapAdmin
    /// This object provides admin controls for swap proposals
    access(all) resource SwapAdmin: SwapProposalManager, SwapFeeManager, SwapStatsManager {

        // Pause all new swap proposal creation (for maintenance)
        access(all) fun stopProposalCreation() {
            Swap.AllowSwapProposalCreation = false
        }

        // Resume new swap proposal creation
        access(all) fun startProposalCreation() {
            Swap.AllowSwapProposalCreation = true
        }

        access(all) fun updateMinExpiration(_ exp: UFix64) {
            Swap.SwapProposalMinExpirationMinutes = exp
        }

        access(all) fun updateMaxExpiration(_ exp: UFix64) {
            Swap.SwapProposalMaxExpirationMinutes = exp
        }

        access(all) fun updateDefaultExpiration(_ exp: UFix64) {
            Swap.SwapProposalDefaultExpirationMinutes = exp
        }

        access(all) fun addFee(fee: Fee) {
            Swap.SwapFees.append(fee)
        }

        access(all) fun removeFeeGroup(feeGroup: UInt8) {
            for index, fee in Swap.SwapFees {
                if (fee.feeGroup == feeGroup) {
                    Swap.SwapFees.remove(at: index)
                }
            }
        }

        access(all) fun addAccountStats(id: String, address: Address, _ data: SwapStatsRegistry.AccountSwapData) {
            SwapStatsRegistry.addAccountStats(id: id, address: address, data)
        }

        access(all) fun clearAccountStats(id: String, address: Address) {
            SwapStatsRegistry.clearAccountStats(id: id, address: address)
        }

        access(all) fun clearAllAccountStatsById(id: String, limit: Int?) {
            SwapStatsRegistry.clearAllAccountStatsById(id: id, limit: limit)
        }

        access(all) fun clearAllAccountStatsLookupById(id: String, limit: Int?) {
            SwapStatsRegistry.clearAllAccountStatsLookupById(id: id, limit: limit)
        }

        access(all) fun clearAllAccountStatsPartnersById(id: String, limit: Int?) {
            SwapStatsRegistry.clearAllAccountStatsPartnersById(id: id, limit: limit)
        }
    }

    access(all) view fun getFees(): [Fee] {
        return Swap.SwapFees
    }

    /// createEmptySwapCollection
    /// This function allows user to create a swap collection resource for future swap proposal creation.
    access(all) fun createEmptySwapCollection(): @SwapCollection {
        return <-create SwapCollection()
    }

    /// verifyUserOffer
    /// This function verifies that all assets in user offer are owned by the user.
    /// If userCapabilities is provided, the function checks that the provider capabilities are valid and that the
    /// address of each capability matches the address of the userOffer.
    /// If partnerOffer is provided in addition to userCapabilities, the function checks that the receiver
    /// capabilities are valid and that one exists for each of the collections in the partnerOffer.
    access(contract) fun verifyUserOffer(
        userOffer: UserOffer,
        userCapabilities: UserCapabilities?,
        partnerOffer: UserOffer?,
        fees: [Fee]
    ) {

        let capabilityNilMessage: String = "capability not found for "
        let addressMismatchMessage: String = "capability address does not match userOffer address for "
        let capabilityCheckMessage: String = "capability is invalid for "

        let userPublicAccount: PublicAccount = getAccount(userOffer.userAddress)

        for proposedNft in userOffer.proposedNfts {

            // attempt to load CollectionPublic capability and verify ownership
            let publicCapability = userPublicAccount.getCapability<&AnyResource{NonFungibleToken.CollectionPublic}>(proposedNft.collectionData.publicPath)

            let collectionPublicRef = publicCapability.borrow()
                ?? panic("could not borrow collectionPublic for ".concat(proposedNft.type.identifier))

            let ownedNftIds: [UInt64] = collectionPublicRef.getIDs()
            assert(ownedNftIds.contains(proposedNft.nftID),
                message: "could not verify ownership for ".concat(proposedNft.type.identifier))

            let nftRef = collectionPublicRef.borrowNFT(id: proposedNft.nftID)
            assert(nftRef.getType() == proposedNft.type,
                message: "proposedNft.type and stored asset type do not match for ".concat(proposedNft.type.identifier))

            if (userCapabilities != nil) {

                // check NFT provider capabilities
                let providerCapability = userCapabilities!.collectionProviderCapabilities[proposedNft.type.identifier]
                assert(providerCapability != nil, message: capabilityNilMessage.concat(proposedNft.type.identifier))
                assert(providerCapability!.address == userOffer.userAddress, message: addressMismatchMessage.concat(proposedNft.type.identifier))
                assert(providerCapability!.check(), message: capabilityCheckMessage.concat(proposedNft.type.identifier))
            }
        }

        if (userCapabilities != nil && partnerOffer != nil) {

            for partnerProposedNft in partnerOffer!.proposedNfts {

                // check NFT receiver capabilities
                let receiverCapability = userCapabilities!.collectionReceiverCapabilities[partnerProposedNft.type.identifier]
                assert(receiverCapability != nil, message: capabilityNilMessage.concat(partnerProposedNft.type.identifier))
                assert(receiverCapability!.address == userOffer.userAddress, message: addressMismatchMessage.concat(partnerProposedNft.type.identifier))
                assert(receiverCapability!.check(), message: capabilityCheckMessage.concat(partnerProposedNft.type.identifier))
            }
        }

        // check fee provider and receiver capabilities
        if (fees.length > 0 && userCapabilities != nil) {

            assert(userCapabilities!.feeProviderCapabilities != nil && userCapabilities!.feeProviderCapabilities!.keys.length > 0,
                message: "feeProviderCapabilities dictionary cannot be empty if fees are required")

            let feeTotals: {String: UFix64} = {}
            let feeGroupPaymentMap: {UInt8: Bool} = {}

            for fee in fees {

                if (feeGroupPaymentMap[fee.feeGroup] != true) {
                    feeGroupPaymentMap.insert(key: fee.feeGroup, false)

                    // check whether capability was provided for this fee
                    let feeProviderCapability = userCapabilities!.feeProviderCapabilities![fee.tokenType.identifier]
                    if (feeProviderCapability != nil && feeProviderCapability!.check()) {

                        let feeProviderRef: &AnyResource{FungibleToken.Provider, FungibleToken.Balance}? = feeProviderCapability!.borrow()
                        let feeReceiverRef = fee.receiver.borrow()
                            ?? panic("could not borrow feeReceiverRef for ".concat(fee.tokenType.identifier))

                        // if this is a payment option for the feeGroup, check balance, otherwise continue
                        if (feeProviderRef != nil && feeProviderRef!.getType() == feeReceiverRef.getType()) {

                            // tally running fee totals
                            let previousFeeTotal = feeTotals[fee.tokenType.identifier] ?? 0.0
                            let newFeeTotal = previousFeeTotal + fee.amount

                            // ensure that user has enough available balance of token for fee
                            if (feeProviderRef!.balance >= newFeeTotal) {

                                // update feeTotals and mark feeGroup as payable
                                feeTotals.insert(key: fee.tokenType.identifier, newFeeTotal)
                                feeGroupPaymentMap.insert(key: fee.feeGroup, true)
                            }
                        }
                    }
                }
            }

            // check that all feeGroups have been marked as payable
            feeGroupPaymentMap.forEachKey(fun (key: UInt8): Bool {
                if (feeGroupPaymentMap[key] != true) {
                    panic("no valid payment method provided for feeGroup ".concat(key.toString()))
                }
                return true
            })
        }
    }

    /// executeUserOffer
    /// This function verifies for each token in the user offer that both users have the required capabilites for the
    /// trade and that the token type matches that of the offer, and then it moves the token to the receiving collection.
    access(contract) fun executeUserOffer(
        userOffer: UserOffer,
        userCapabilities: UserCapabilities,
        partnerCapabilities: UserCapabilities,
        fees: [Fee]
    ) {

        let typeMismatchMessage: String = "token type mismatch for "
        let receiverRefMessage: String = "could not borrow receiver reference for "
        let providerRefMessage: String = "could not borrow provider reference for "

        let feeGroupPaymentMap: {UInt8: Bool} = {}

        for fee in fees {

            if (feeGroupPaymentMap[fee.feeGroup] != true) {
                feeGroupPaymentMap.insert(key: fee.feeGroup, false)

                // check whether capability was provided for this fee
                let feeProviderCapability = userCapabilities.feeProviderCapabilities![fee.tokenType.identifier]
                if (feeProviderCapability != nil && feeProviderCapability!.check()) {

                    // get fee provider and receiver
                    let feeProviderRef = feeProviderCapability!.borrow()
                    let feeReceiverRef = fee.receiver.borrow()
                        ?? panic(receiverRefMessage.concat(fee.tokenType.identifier))

                    if (feeProviderRef != nil && feeReceiverRef.getType() == feeProviderRef!.getType()) {

                        // verify token type and tranfer fee
                        let feePayment <- feeProviderRef!.withdraw(amount: fee.amount)
                        assert(feePayment.isInstance(fee.tokenType), message: typeMismatchMessage.concat(fee.tokenType.identifier))
                        feeReceiverRef.deposit(from: <-feePayment)
                        feeGroupPaymentMap.insert(key: fee.feeGroup, true)
                    }
                }
            }
        }

        // check that all feeGroups have been marked as paid
        feeGroupPaymentMap.forEachKey(fun (key: UInt8): Bool {
            if (feeGroupPaymentMap[key] != true) {
                panic("no valid payment provided for feeGroup ".concat(key.toString()))
            }
            return true
        })

        for proposedNft in userOffer.proposedNfts {

            // get receiver and provider
            let receiverReference = partnerCapabilities.collectionReceiverCapabilities[proposedNft.type.identifier]!.borrow()
                ?? panic(receiverRefMessage.concat(proposedNft.type.identifier))
            let providerReference = userCapabilities.collectionProviderCapabilities[proposedNft.type.identifier]!.borrow()
                ?? panic(providerRefMessage.concat(proposedNft.type.identifier))

            // verify token type
            let nft <- providerReference.withdraw(withdrawID: proposedNft.nftID)
            assert(nft.isInstance(proposedNft.type), message: typeMismatchMessage.concat(proposedNft.type.identifier))

            // transfer token
            receiverReference.deposit(token: <-nft)
        }
    }

    init() {

        // initialize contract constants
        self.AllowSwapProposalCreation = true
        self.SwapCollectionStoragePath = /storage/evaluateSwapCollection
        self.SwapCollectionPrivatePath = /private/evaluateSwapCollectionManager
        self.SwapCollectionPublicPath = /public/evaluateSwapCollectionPublic
        self.SwapAdminStoragePath = /storage/evaluateSwapAdmin
        self.SwapAdminPrivatePath = /private/evaluateSwapAdmin
        self.SwapFees = []
        self.SwapProposalMinExpirationMinutes = 2.0
        self.SwapProposalMaxExpirationMinutes = 43800.0
        self.SwapProposalDefaultExpirationMinutes = 5.0

        // save swap proposal admin object and link capabilities
        self.account.save(<- create SwapAdmin(), to: self.SwapAdminStoragePath)
        self.account.link<&SwapAdmin{SwapProposalManager, SwapFeeManager}>(self.SwapAdminPrivatePath, target: self.SwapAdminStoragePath)
    }
}
"
-------
"//SPDX-License-Identifier : CC-BY-NC-4.0
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import FlowToken from 0x1654653399040a61
import FlowUtilityToken from 0xead892083b3e2c6c

// Metaverse
// NFT for Metaverse
//
pub contract MetaverseMarket: NonFungibleToken {

    // Events
    //
    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event Minted(id: UInt64, typeID: UInt64, metadata: {String:String})
    pub event BatchMinted(ids: [UInt64], typeID: [UInt64], metadata: {String:String})
    pub event NFTBurned(id: UInt64)
    pub event NFTsBurned(ids: [UInt64])
    pub event CategoryCreated(categoryName: String)
    pub event SubCategoryCreated(subCategoryName: String)

    // Named Paths
    //
    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let AdminStoragePath: StoragePath

    // totalSupply
    // The total number of MetaverseMarkets that have been minted
    //
    pub var totalSupply: UInt64

    // List with all categories and respective code
    access(self) var categoriesList: {UInt64 :String}

    // {CategoryName: [NFT To Sell ID]}
    access(self) var categoriesNFTsToSell: {UInt64: [UInt64]}

    // Dictionary with NFT List Data
    access(self) var nftsToSell: {UInt64: OzoneListToSellMetadata}


    pub struct OzoneListToSellMetadata {
      //List ID that will came from the backend, all NFTs from same list will have same listId
      pub let listId: UInt64
      pub var name: String
      pub var description: String
      pub var categoryId: UInt64
      pub let creator: Address?
      pub let creatorDapperAddress: Address?
      pub let fileName: String
      pub var previewImage: String
      pub let format: String
      pub let fileIPFS: String
      pub var price: UFix64
      pub let maxSupply: UInt64
      pub var minted: UInt64

      pub fun addMinted(){
        self.minted = self.minted + 1
      }

      pub fun changePrice(newPrice: UFix64){
        self.price = newPrice
      }


      pub fun updateList(newPreviewImage: String?, newName: String?, newDescription: String?, newCategoryId: UInt64?){
        if newPreviewImage != nil {
            self.previewImage = newPreviewImage!
        }
        if newName != nil {
            self.name = newName!
        }
        if newDescription != nil {
            self.description = newDescription!
        }
        if newCategoryId != nil {
            self.categoryId = newCategoryId!
        }
      }

      init(_listId: UInt64, _name: String, _description: String, _categoryId: UInt64, _creator: Address?, _creatorDapperAddress: Address? ,_fileName: String, _previewImage: String, _format: String, _fileIPFS: String, _price: UFix64, _maxSupply: UInt64){
        self.listId = _listId
        self.name = _name
        self.description = _description
        self.categoryId = _categoryId
        self.creator = _creator
        self.creatorDapperAddress = _creatorDapperAddress
        self.fileName = _fileName
        self.previewImage = _previewImage
        self.format = _format
        self.fileIPFS = _fileIPFS
        self.price = _price
        self.maxSupply = _maxSupply
        self.minted = 0
      }
    }

    // NFT
    // MetaverseMarket as an NFT
    //
    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        // The token's ID
        //NFT CONTRACT GLOBAL ID -> Current TotalSupply
        pub let id: UInt64

        //Current List minted(List TotalSupply)
        pub let uniqueListId: UInt64

        //List ID that will came from the backend, all NFTs from same list will have same listId
        pub let listId: UInt64

        pub let name: String

        pub let description: String

        pub let previewImage: String

        pub let categoryId: UInt64

        pub let creator: Address?

        pub let creatorDapperWallet: Address?

        pub let fileName: String

        pub let format: String

        pub let fileIPFS: String



        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.name,
                        description: self.description,
                        thumbnail: MetadataViews.HTTPFile(
                            url: self.fileIPFS
                        )
                    )
                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL("https://ozonemetaverse.io/")
                case Type<MetadataViews.Royalties>():
                    let royalties : [MetadataViews.Royalty] = []
                    royalties.append(MetadataViews.Royalty(recipient: getAccount(MetaverseMarket.account.address).getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver), cut: 0.03, description: "Ozone Marketplace Secondary Sale Royalty"))
                    royalties.append(MetadataViews.Royalty(recipient: getAccount(self.creator!).getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver), cut: 0.07, description: "NFT Creator Secondary Sale Royalty"))
                    return MetadataViews.Royalties(cutInfos: royalties)
                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: MetaverseMarket.CollectionStoragePath,
                        publicPath: MetaverseMarket.CollectionPublicPath,
                        providerPath: /private/ProvenancedCollectionsV9,
                        publicCollection: Type<&MetaverseMarket.Collection{MetaverseMarket.MetaverseMarketCollectionPublic, NonFungibleToken.CollectionPublic}>(),
                        publicLinkedType: Type<&MetaverseMarket.Collection{MetaverseMarket.MetaverseMarketCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&MetaverseMarket.Collection{MetaverseMarket.MetaverseMarketCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                            return <-MetaverseMarket.createEmptyCollection()
                        })
                    )
                case Type<MetadataViews.NFTCollectionDisplay>():
                    let squareMedia = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                           url: "https://d19wottuqbmkwr.cloudfront.net/nft/banners1.jpg"
                        ),
                        mediaType: "image"
                    )
                    let bannerMedia = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: "https://d19wottuqbmkwr.cloudfront.net/nft/banners2.jpg"
                        ),
                        mediaType: "image"
                    )
                    return MetadataViews.NFTCollectionDisplay(
                        name: "Ozone Metaverse Marketplace",
                        description: "The first ever virtual world building creator NFT marketplace on Flow. Made by creators, for creators. Instantly create listings of all media file types including 3D models which can be immediately used in virtual world building studio. Build the new metaverse economy today by becoming a creator or simply start to build worlds today. Built on Flow. Powered by Ozone.",
                        externalURL: MetadataViews.ExternalURL("https://ozonemetaverse.io"),
                        squareImage: squareMedia,
                        bannerImage: bannerMedia,
                        socials: {
                            "twitter": MetadataViews.ExternalURL("https://twitter.com/ozonemetaverse"),
                            "discord": MetadataViews.ExternalURL("https://discord.gg/ozonemetaverse")
                        }
                    )
            }

            return nil
        }

        // initializer
        //
        init(initID: UInt64, uniqueListId: UInt64, listId: UInt64, name: String, categoryId: UInt64, description: String, previewImage: String, creator: Address?, creatorDapperWallet: Address?, fileName: String, format: String, fileIPFS: String) {
            self.id = initID
            self.uniqueListId = uniqueListId
            self.listId = listId
            self.name = name
            self.description = description
            self.previewImage = previewImage
            self.categoryId = categoryId
            self.creator = creator
            self.creatorDapperWallet = creatorDapperWallet
            self.fileName = fileName
            self.format = format
            self.fileIPFS = fileIPFS

        }

        // If the NFT is burned, emit an event to indicate
        // to outside observers that it has been destroyed
        destroy() {
            emit NFTBurned(id: self.id)
        }
    }

    // This is the interface that users can cast their MetaverseMarket Collection as
    // to allow others to deposit MetaverseMarket into their Collection. It also allows for reading
    // the details of MetaverseMarket in the Collection.
    pub resource interface MetaverseMarketCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun getNFTs(): &{UInt64: NonFungibleToken.NFT}
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowMetaverseMarket(id: UInt64): &MetaverseMarket.NFT? {
            // If the result isn't nil, the id of the returned reference
            // should be the same as the argument to the function
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow MetaverseMarket reference: The ID of the returned reference is incorrect"
            }
        }
    }

    // Collection
    // A collection of MetaverseMarket NFTs owned by an account
    //
    pub resource Collection: MetaverseMarketCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with an `UInt64` ID field
        //
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        // withdraw
        // Removes an NFT from the collection and moves it to the caller
        //
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        // deposit
        // Takes a NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        //
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @MetaverseMarket.NFT

            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        // getIDs
        // Returns an array of the IDs that are in the collection
        //
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        pub fun getNFTs(): &{UInt64: NonFungibleToken.NFT} {
            return (&self.ownedNFTs as &{UInt64: NonFungibleToken.NFT})
        }

        // borrowNFT
        // Gets a reference to an NFT in the collection
        // so that the caller can read its metadata and call its methods
        //
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        // borrowMetaverseMarket
        // Gets a reference to an NFT in the collection as a MetaverseMarket,
        // exposing all of its fields (including the typeID).
        // This is safe as there are no functions that can be called on the MetaverseMarket.
        //
        pub fun borrowMetaverseMarket(id: UInt64): &MetaverseMarket.NFT? {
            if self.ownedNFTs[id] != nil {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &MetaverseMarket.NFT
            } else {
                return nil
            }
        }

        pub fun borrowNFTSafe(id: UInt64): &NFT? {
            post {
                result == nil || result!.id == id: "The returned reference's ID does not match the requested ID"
            }

            return self.ownedNFTs[id] != nil
                ? (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)! as! &MetaverseMarket.NFT
                : nil
        }

        // borrowViewResolver
        // Gets a reference to the MetadataViews resolver in the collection,
        // giving access to all metadata information made available.
        //
        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let metaverseNft = nft as! &MetaverseMarket.NFT
            return metaverseNft
        }

        // destructor
        destroy() {
            emit NFTsBurned(ids: self.ownedNFTs.keys)
            destroy self.ownedNFTs
        }

        // initializer
        //
        init () {
            self.ownedNFTs <- {}
        }
    }

    // createEmptyCollection
    // public function that anyone can call to create a new empty collection
    //
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    // NFTAdmin
    // Resource that an admin or something similar would own to be
    // able to mint new NFTs
    //
	pub resource Admin {

        pub fun createCategory(categoryId: UInt64, categoryName: String){

            if UInt64(MetaverseMarket.categoriesList.length + 1) != categoryId {
                panic("Category ID already exists")
            }

            MetaverseMarket.categoriesList[categoryId] = categoryName

            MetaverseMarket.categoriesNFTsToSell[categoryId] = []

            emit CategoryCreated(categoryName: categoryName)
        }

        pub fun createList(
            listId: UInt64,
            name: String,
            description: String,
            categoryId: UInt64,
            creator: Address?,
            creatorDapperAddress: Address?,
            fileName: String,
            previewImage: String,
            format: String,
            fileIPFS: String,
            price: UFix64,
            maxSupply: UInt64
            ){

            var max = 0 as UInt64

            for element in MetaverseMarket.nftsToSell.keys {
                if(element > max){
                    max = element
                }
            }

            if listId != UInt64(max + 1) {
                panic("NFT List ID already exists")
            }

            let list = OzoneListToSellMetadata(
                _listId: listId,
                _name: name,
                _description: description,
                _categoryId: categoryId,
                _creator: creator,
                _creatorDapperAddress: creatorDapperAddress,
                _fileName: fileName,
                _previewImage: previewImage,
                _format: format,
                _fileIPFS: fileIPFS,
                _price: price,
                _maxSupply: maxSupply
            )

            MetaverseMarket.nftsToSell[listId] = list

            //Add the list to the categoriesNFTsToSell
            MetaverseMarket.categoriesNFTsToSell[categoryId]!.append(listId)

        }

		// mintNFT
        // Mints a new NFT with a new ID
		// and deposit it in the recipients collection using their collection reference
        //
		pub fun mintNFT(recipient: &{NonFungibleToken.CollectionPublic}, payment: @FungibleToken.Vault, listedNftId: UInt64) {
            pre{
                MetaverseMarket.nftsToSell[listedNftId] != nil: "Listed ID does not exists!"
                payment.balance == MetaverseMarket.nftsToSell[listedNftId]!.price: "Incorrect price!"
                MetaverseMarket.nftsToSell[listedNftId]!.maxSupply != MetaverseMarket.nftsToSell[listedNftId]!.minted: "Max Supply reached!"
            }

            let list = MetaverseMarket.nftsToSell[listedNftId]!
            MetaverseMarket.nftsToSell[listedNftId]!.addMinted()

            let royalty <- payment.withdraw(amount: payment.balance * 0.1)

            switch payment.getType() {
                case Type<@FlowToken.Vault>():
                    // Get a reference to the recipient's Receiver
                    let receiverRef =  getAccount(list.creator!).getCapability(/public/flowTokenReceiver).borrow<&{FungibleToken.Receiver}>()
                                    ?? panic("Could not borrow receiver reference to the recipient's Vault")

                    // Get a reference to the recipient's Receiver
                    let royaltyReceiver = getAccount(MetaverseMarket.account.address).getCapability(/public/flowTokenReceiver).borrow<&{FungibleToken.Receiver}>()
                                    ?? panic("Could not borrow receiver reference to the recipient's Vault")

                    royaltyReceiver.deposit(from: <- royalty)
                    receiverRef.deposit(from: <- payment)

                    // deposit it in the recipient's account using their reference
                    recipient.deposit(token: <- create MetaverseMarket.NFT(
                                            initID: MetaverseMarket.totalSupply,
                                            uniqueListId: list.minted,
                                            listId: list.listId,
                                            name: list.name,
                                            categoryId: list.categoryId,
                                            description: list.description,
                                            previewImage: list.previewImage,
                                            creator: list.creator,
                                            creatorDapperAddress: list.creatorDapperAddress,
                                            fileName: list.fileName,
                                            format: list.format,
                                            fileIPFS: list.fileIPFS
                                            ))

                case Type<@FlowUtilityToken.Vault>():
                    // Get a reference to the recipient's Receiver
                    let receiverRef =  getAccount(list.creatorDapperAddress!).getCapability(/public/flowUtilityTokenReceiver).borrow<&{FungibleToken.Receiver}>()
                                    ?? panic("Could not borrow receiver reference to the creator Dapper Address Vault")

                    // Get a reference to the recipient's Receiver
                    let royaltyReceiver = getAccount(0x43fbb5fb34ba8ef0).getCapability(/public/flowUtilityTokenReceiver).borrow<&{FungibleToken.Receiver}>()
                                    ?? panic("Could not borrow receiver reference to the recipient's Vault")

                    royaltyReceiver.deposit(from: <- royalty)
                    receiverRef.deposit(from: <- payment)

                    // deposit it in the recipient's account using their reference
                    recipient.deposit(token: <- create MetaverseMarket.NFT(
                                            initID: MetaverseMarket.totalSupply,
                                            uniqueListId: list.minted,
                                            listId: list.listId,
                                            name: list.name,
                                            categoryId: list.categoryId,
                                            description: list.description,
                                            previewImage: list.previewImage,
                                            creator: list.creatorDapperAddress,
                                            creatorDapperAddress: list.creatorDapperAddress,
                                            fileName: list.fileName,
                                            format: list.format,
                                            fileIPFS: list.fileIPFS
                                            ))

                default:
                    panic("Unsupported token type")
            }

            MetaverseMarket.totalSupply = MetaverseMarket.totalSupply + 1
		}

        //TransferNft, mint and transfer to Account NFT
        pub fun transferNFT(recipient: &{NonFungibleToken.CollectionPublic}, listedNftId: UInt64) {
                pre{
                    MetaverseMarket.nftsToSell[listedNftId] != nil: "Listed ID does not exists!"
                    MetaverseMarket.nftsToSell[listedNftId]!.maxSupply != MetaverseMarket.nftsToSell[listedNftId]!.minted: "Max Supply reached!"
                }

                let list = MetaverseMarket.nftsToSell[listedNftId]!
                MetaverseMarket.nftsToSell[listedNftId]!.addMinted()

                // deposit it in the recipient's account using their reference
                recipient.deposit(token: <- create MetaverseMarket.NFT(
                                        initID: MetaverseMarket.totalSupply,
                                        uniqueListId: list.minted,
                                        listId: list.listId,
                                        name: list.name,
                                        categoryId: list.categoryId,
                                        description: list.description,
                                        previewImage: list.previewImage,
                                        creator: list.creator,
                                        creatorDapperAddress: list.creatorDapperAddress,
                                        fileName: list.fileName,
                                        format: list.format,
                                        fileIPFS: list.fileIPFS
                                        ))

                MetaverseMarket.totalSupply = MetaverseMarket.totalSupply + 1
        }

        //Delete Listing
        pub fun deleteListing(listedNftId: UInt64) {
            pre{
                MetaverseMarket.nftsToSell[listedNftId] != nil: "Listed ID does not exists!"
            }

            let list = MetaverseMarket.nftsToSell[listedNftId]!

            MetaverseMarket.nftsToSell.remove(key: listedNftId)
        }

        //Change Price
        pub fun changePrice(listedNftId: UInt64, newPrice: UFix64){
            pre{
                MetaverseMarket.nftsToSell[listedNftId] != nil: "Listed ID does not exists!"
            }

            let list = MetaverseMarket.nftsToSell[listedNftId]!

            MetaverseMarket.nftsToSell[listedNftId]!.changePrice(newPrice: newPrice)
        }

        pub fun updateList(listedNftId: UInt64, newPreviewImage: String?, newName: String?, newDescription: String?, newCategoryId: UInt64?){
            pre{
                MetaverseMarket.nftsToSell[listedNftId] != nil: "Listed ID does not exists!"
            }

            let list = MetaverseMarket.nftsToSell[listedNftId]!

            MetaverseMarket.nftsToSell[listedNftId]!.updateList(newPreviewImage: newPreviewImage, newName: newName, newDescription: newDescription, newCategoryId: newCategoryId)
        }
	}



    // fetch
    // Get a reference to a MetaverseMarket from an account's Collection, if available.
    // If an account does not have a MetaverseMarket.Collection, panic.
    // If it has a collection but does not contain the itemID, return nil.
    // If it has a collection and that collection contains the itemID, return a reference to that.
    //
    pub fun fetch(_ from: Address, itemID: UInt64): &MetaverseMarket.NFT? {
        let collection = getAccount(from)
            .getCapability(MetaverseMarket.CollectionPublicPath)
            .borrow<&MetaverseMarket.Collection{MetaverseMarket.MetaverseMarketCollectionPublic}>()
            ?? panic("Couldn't get collection")
        // We trust MetaverseMarket.Collection.borowMetaverseMarket to get the correct itemID
        // (it checks it before returning it).
        return collection.borrowMetaverseMarket(id: itemID)
    }

    pub fun getAllNftsFromAccount(_ from: Address): &{UInt64: NonFungibleToken.NFT}? {
        let collection = getAccount(from)
            .getCapability(MetaverseMarket.CollectionPublicPath)
            .borrow<&MetaverseMarket.Collection{MetaverseMarket.MetaverseMarketCollectionPublic}>()
            ?? panic("Couldn't get collection")
        return collection.getNFTs()
    }

    pub fun getCategories(): {UInt64:String} {
        return MetaverseMarket.categoriesList
    }

    pub fun getCategoriesIds(): [UInt64] {
        return MetaverseMarket.categoriesList.keys
    }

    pub fun getCategorieName(id: UInt64): String {
        return MetaverseMarket.categoriesList[id] ?? panic("Category does not exists")
    }

    pub fun getCategoriesListLength(): UInt64 {
        return UInt64(MetaverseMarket.categoriesList.length)
    }

    pub fun getNftToSellListLength(): UInt64{
        var max = 0 as UInt64

        for element in MetaverseMarket.nftsToSell.keys {
            if(element > max){
                max = element
            }
        }

        return max
    }

    pub fun getCategoriesNFTsToSell(categoryId: UInt64): [UInt64]?{
        return MetaverseMarket.categoriesNFTsToSell[categoryId]
    }

    pub fun getNftToSellData(listId: UInt64): OzoneListToSellMetadata? {
         return MetaverseMarket.nftsToSell[listId]
    }

    pub fun getAllListToSell(): [UInt64]{
        return MetaverseMarket.nftsToSell.keys
    }

    pub fun cleanListing(listId: UInt64){
        pre{
            MetaverseMarket.nftsToSell[listId]!.minted != MetaverseMarket.nftsToSell[listId]!.maxSupply: "Only Admin can deleted a not finished listing"
        }

        MetaverseMarket.nftsToSell.remove(key: listId)
    }

    // initializer
    //
	init() {
        // Set our named paths
        self.CollectionStoragePath = /storage/NftMetaverseMarketCollectionVersionTwo
        self.CollectionPublicPath = /public/NftMetaverseMarketCollectionVersionTwo
        self.AdminStoragePath = /storage/metaverseMarketV2Admin

        self.categoriesList = {}

        self.categoriesNFTsToSell = {}

        self.nftsToSell = {}

        // Initialize the total supply
        self.totalSupply = 0

        // Create a Admin resource and save it to storage
        let admin <- create Admin()
        self.account.save(<-admin, to: self.AdminStoragePath)

        // Create and link collection to this account
        self.account.save(<- self.createEmptyCollection(), to: self.CollectionStoragePath)
        self.account.link<&MetaverseMarket.Collection{NonFungibleToken.CollectionPublic, MetaverseMarket.MetaverseMarketCollectionPublic}>(self.CollectionPublicPath, target: self.CollectionStoragePath)

        emit ContractInitialized()
	}
}
 "
-------
"pub contract ConstantUpdate {

    pub event HardMaximum(value: UFix64)

    pub let hardMaximum: UFix64

    pub fun doSomethingUnrelated(): Bool {
        return true
    }

    pub fun broadcastHardMaximum() {
        emit HardMaximum(value: self.hardMaximum)
    }

    init() {
        self.hardMaximum = 100.0
    }
}
"
-------
"/*
============================================================
Name: NFT Verifier Contract for Mindtrix
============================================================
This contract is inspired from FLOATVerifiers that comes from
Emerald City, Jacob Tucker.
It abstracts the verification logic out of the main contract.
Therefore, this contract is scalable with other forms of
conditions.
*/

import MindtrixViews from 0x74266bc086680e5e

pub contract MindtrixVerifier {

  pub struct TimeLock: MindtrixViews.IVerifier {

    pub let startTime: UFix64
    pub let endTime: UFix64

    pub fun verify(_ params: {String: AnyStruct}, _ isAssert: Bool): {String: Bool} {
      let currentTime = getCurrentBlock().timestamp
      let isYetToStart = currentTime < self.startTime
      let isEnd = currentTime > self.endTime

      if isAssert {
        assert(!isYetToStart, message: "This Mindtrix NFT is yet to start.")
        assert(!isEnd, message: "Oops! The time has run out to mint this Mindtrix NFT.")
      }
      return {
        "isYetToStart": isYetToStart,
        "isEnd": isEnd
      }
    }

    init(startTime: UFix64, endTime: UFix64) {
      self.startTime = startTime
      self.endTime = endTime
    }
  }

  // deprecated, use LimitedQuantityV2 instead
  pub struct LimitedQuantity: MindtrixViews.IVerifier {
    pub var maxEdition: UInt64
    pub var maxMintTimesPerAddress: UInt64

    pub fun verify(_ params: {String: AnyStruct}, _ isAssert: Bool): {String: Bool} {
      let currentEdition = params["currentEdition"]! as! UInt64
      let recipientMintTimes = params["recipientMintQuantityPerTransaction"]! as! UInt64
      let isOverSupply = currentEdition >= self.maxEdition
      let isOverMintTimesPerAddress = recipientMintTimes >= self.maxMintTimesPerAddress
      if isAssert {
        assert(!isOverSupply, message: "Oops! Run out of the supply!")
        assert(!isOverMintTimesPerAddress, message: "The address has reached the max mint times.")
      }

      return {
        "isOverSupply": isOverSupply,
        "isOverMintTimesPerAddress": isOverMintTimesPerAddress
      }
    }

    init(maxEdition: UInt64, maxMintTimesPerAddress: UInt64, maxQuantityPerTransaction: UInt64) {
      self.maxEdition = maxEdition
      self.maxMintTimesPerAddress = maxMintTimesPerAddress
    }
  }

  pub struct LimitedQuantityV2: MindtrixViews.IVerifier {
    pub var intDic: {String: UInt64}
    pub var fixDic: {String: UFix64}

    pub fun verify(_ params: {String: AnyStruct}, _ isAssert: Bool): {String: Bool} {
      let maxEdition = self.intDic["maxEdition"]!
      let maxSupplyPerRound = self.intDic["maxSupplyPerRound"] ?? nil
      let maxSupplyPerEntity = self.intDic["maxSupplyPerEntity"] ?? nil
      let maxMintTimesPerAddress = self.intDic["maxMintTimesPerAddress"]!
      let maxMintQuantityPerTransaction = self.intDic["maxMintQuantityPerTransaction"]!
      let maxMintTimesPerEntity = self.intDic["maxMintTimesPerEntity"]

      let currentEdition = params["currentEdition"]! as! UInt64
      let currentEntityEdition = params["currentEntityEdition"] as? UInt64
      let recipientMaxMintTimesPerAddress = params["recipientMaxMintTimesPerAddress"]! as! UInt64
      let recipientMintQuantityPerTransaction = params["recipientMintQuantityPerTransaction"]! as! UInt64
      let recipientMintQuantityPerEntity = params["recipientMintQuantityPerEntity"]! as! UInt64

      let isMaxEditionPerRoundExist = maxSupplyPerRound != nil && maxSupplyPerRound! > 0
      let isEntitySupplyLimitExist = maxSupplyPerEntity != nil && currentEntityEdition != nil
      // supply condition priority: maxSupplyPerRound -> maxSupplyPerEntity -> maxEdition
      let isOverSupply = isMaxEditionPerRoundExist
      ? currentEdition >= maxSupplyPerRound!
      : isEntitySupplyLimitExist
      ? currentEntityEdition! >= maxSupplyPerEntity!
      : currentEdition >= maxEdition
      let isOverMintTimesPerAddress = recipientMaxMintTimesPerAddress >= maxMintTimesPerAddress
      let isOverMintQuantityPerTransaction = recipientMintQuantityPerTransaction > maxMintQuantityPerTransaction
      let isOverMintTimesPerEntity = recipientMintQuantityPerEntity >= maxMintTimesPerEntity!

      if isAssert == true {
        assert(!isOverSupply, message: "Oops! Run out of the supply!")
        assert(!isOverMintTimesPerAddress, message: "The address has reached the max mint times.")
        assert(!isOverMintQuantityPerTransaction, message: "recipientMaxMintTimesPerAddress", "Cannot mint over ".concat(maxMintQuantityPerTransaction.toString()).concat(" per transaction!"))
        assert(!isOverMintTimesPerEntity, message: "Cannot mint over ".concat(recipientMintQuantityPerEntity.toString()).concat(" per entity!"))
      }

      return {
        "isOverSupply": isOverSupply,
        "isOverMintTimesPerAddress": isOverMintTimesPerAddress,
        "isOverMintQuantityPerTransaction": isOverMintQuantityPerTransaction,
        "isOverMintTimesPerEntity": isOverMintTimesPerEntity
      }
    }

    init(intDic: {String: UInt64}, fixDic: {String: UFix64} ) {
      self.intDic = intDic
      self.fixDic = fixDic
    }
  }

  pub struct ClaimCode: MindtrixViews.IVerifier {
    pub let publicKey: String
    pub let randomstamp: UInt64

    pub fun verify(_ params: {String: AnyStruct},  _ isAssert: Bool): {String: Bool} {
      let randomstampStr = (params["claimCodeRandomstamp"]! as! UInt64).toString()
      let recipientAddressStr = (params["recipientAddress"]! as! Address).toString()
      let data: [UInt8] = recipientAddressStr.concat("-").concat(randomstampStr).utf8
      let sig: [UInt8] = (params["claimCodeSig"]! as! String).decodeHex()
      let publicKey = PublicKey(publicKey: self.publicKey.decodeHex(), signatureAlgorithm: SignatureAlgorithm.ECDSA_P256)
      let valid = publicKey.verify(
        signature: sig,
        signedData: data,
        domainSeparationTag: "FLOW-V0.0-user",
        hashAlgorithm: HashAlgorithm.SHA3_256
      )

      if isAssert == true {
        assert(valid, message: "You did not input the correct claim code.")
      }

       return {
        "isClaimCodePassed": valid
      }
    }

    init(publicKey: String, randomstamp: UInt64) {
        self.publicKey = publicKey
        self.randomstamp = randomstamp
    }
  }

}
"
-------
"import JoyridePayments from 0xecfad18ba9582d4f

pub contract JoyrideGameShim {
    pub event PlayerTransaction(gameID: String)
    pub event FinalizeTransaction(gameID: String)
    pub event RefundTransaction(gameID: String)

    //Fake Token Events for User Mapping
    pub event TokensWithdrawn(amount: UFix64, from: Address?)
    pub event TokensDeposited(amount: UFix64, to: Address?)

    pub fun GameIDtoStoragePath(_ gameID:String) : StoragePath {
      return StoragePath(identifier: "JoyrideGame_".concat(gameID))!
    }

    pub fun GameIDtoCapabilityPath(_ gameID:String) : PrivatePath {
      return PrivatePath(identifier: "JoyrideGame_".concat(gameID))!
    }

    pub fun CreateJoyrideGame(paymentsAdmin: Capability<&{JoyridePayments.WalletAdmin}>,gameID:String) : @JoyrideGameShim.JoyrideGame {
      return <- create JoyrideGameShim.JoyrideGame(paymentsAdmin:paymentsAdmin, gameID:gameID)
    }

    pub resource interface JoyrideGameData {
      pub fun readGameInfo(_ key:String) : AnyStruct
      pub fun setGameInfo(_ key:String, value:AnyStruct)
    }

    pub resource JoyrideGame: JoyrideGameData, JoyridePayments.WalletAdmin
    {
      access(self) let gameInfo:{String:AnyStruct}
      access(self) var paymentsAdmin: Capability<&{JoyridePayments.WalletAdmin}>

      init(paymentsAdmin: Capability<&{JoyridePayments.WalletAdmin}>, gameID:String) {
        self.gameInfo = {"gameID":gameID}
        self.paymentsAdmin = paymentsAdmin
      }

      pub fun readGameInfo(_ key:String) : AnyStruct {
        return self.gameInfo[key]
      }

      pub fun setGameInfo(_ key:String, value:AnyStruct) {
        self.gameInfo[key] = value
      }

      pub fun PlayerTransaction(playerID: String, tokenContext: String, amount:Fix64, gameID: String, txID: String, reward: Bool, notes: String) : Bool {
        if(!self.gameInfo.containsKey("gameID")) {
            panic("gameID not set")
        }
        let _gameID = self.readGameInfo("gameID")! as! String
        if(gameID != _gameID) { panic("Incorrect GameID for Shim") }

        emit JoyrideGameShim.PlayerTransaction(gameID: gameID)
        return self.paymentsAdmin.borrow()!.PlayerTransaction(playerID: playerID, tokenContext: tokenContext, amount: amount, gameID: gameID, txID: txID, reward: reward, notes: notes)
      }

      pub fun FinalizeTransactionWithDevPercentage(txID: String, profit: UFix64, devPercentage: UFix64) : Bool {
        emit JoyrideGameShim.FinalizeTransaction(gameID: self.readGameInfo("gameID")! as! String)
        return self.paymentsAdmin.borrow()!.FinalizeTransactionWithDevPercentage(txID: txID, profit: profit, devPercentage: devPercentage)
      }

      pub fun RefundTransaction(txID: String) : Bool {
        emit JoyrideGameShim.RefundTransaction(gameID: self.readGameInfo("gameID")! as! String)
        return self.paymentsAdmin.borrow()!.RefundTransaction(txID: txID)
      }
    }
}
"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import FungibleTokenMetadataViews from 0xf233dcee88fe0abe
import MetadataViews from 0x1d7e57aa55817448
import Toucans from 0x577a3c409c5dcb5e
import ToucansTokens from 0x577a3c409c5dcb5e

pub contract RohamsWieners: FungibleToken {

    // The amount of tokens in existance
    pub var totalSupply: UFix64
    // nil if there is none
    pub let maxSupply: UFix64?

    // Paths
    pub let VaultStoragePath: StoragePath
    pub let ReceiverPublicPath: PublicPath
    pub let VaultPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath
    pub let AdministratorStoragePath: StoragePath

    // Events
    pub event TokensInitialized(initialSupply: UFix64)
    pub event TokensWithdrawn(amount: UFix64, from: Address?)
    pub event TokensDeposited(amount: UFix64, to: Address?)
    pub event TokensTransferred(amount: UFix64, from: Address, to: Address)
    pub event TokensMinted(amount: UFix64)
    pub event TokensBurned(amount: UFix64)

    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance, MetadataViews.Resolver {
        pub var balance: UFix64

        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)

            if let owner: Address = self.owner?.address {
                RohamsWieners.setBalance(address: owner, balance: self.balance)
            }
            return <- create Vault(balance: amount)
        }

        pub fun deposit(from: @FungibleToken.Vault) {
            let vault: @Vault <- from as! @Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)

            // We set the balance to 0.0 here so that it doesn't
            // decrease the totalSupply in the `destroy` function.
            vault.balance = 0.0
            destroy vault

            if let owner: Address = self.owner?.address {
                RohamsWieners.setBalance(address: owner, balance: self.balance)
            }
        }

        pub fun getViews(): [Type]{
            return [Type<FungibleTokenMetadataViews.FTView>(),
                    Type<FungibleTokenMetadataViews.FTDisplay>(),
                    Type<FungibleTokenMetadataViews.FTVaultData>()]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<FungibleTokenMetadataViews.FTView>():
                    return FungibleTokenMetadataViews.FTView(
                        ftDisplay: self.resolveView(Type<FungibleTokenMetadataViews.FTDisplay>()) as! FungibleTokenMetadataViews.FTDisplay?,
                        ftVaultData: self.resolveView(Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
                    )
                case Type<FungibleTokenMetadataViews.FTDisplay>():
                    let media = MetadataViews.Media(
                            file: MetadataViews.HTTPFile(
                            url: "https://nftstorage.link/ipfs/bafkreifecwzpw5xoufaakty4eekxbuobitshs3kbdzjtm7t3pbicbf3v5u"
                        ),
                        mediaType: "image"
                    )
                    let bannerMedia = MetadataViews.Media(
                            file: MetadataViews.HTTPFile(
                            url: "https://nftstorage.link/ipfs/bafkreieef4d3di7mz4pdb73mlozwso5ys6nwqmxqs5wbdbqrhbr57zlpda"
                        ),
                        mediaType: "image"
                    )
                    let medias = MetadataViews.Medias([media, bannerMedia])
                    return FungibleTokenMetadataViews.FTDisplay(
                        name: "Roham's Wieners",
                        symbol: "ROHAM",
                        description: "Nearly 2 years ago, Dapper CEO Roham Gharegozlou promised that a key perk of being a Top Shot collector would be free hot dogs at NBA arenas. As of today, that promise has yet to be delivered upon. We are here to change that.",
                        externalURL: MetadataViews.ExternalURL(""),
                        logos: medias,
                        socials: {
                            "twitter": MetadataViews.ExternalURL("RohamsWieners"),
                            "discord": MetadataViews.ExternalURL("")
                        }
                    )
                case Type<FungibleTokenMetadataViews.FTVaultData>():
                    return FungibleTokenMetadataViews.FTVaultData(
                        storagePath: RohamsWieners.VaultStoragePath,
                        receiverPath: RohamsWieners.ReceiverPublicPath,
                        metadataPath: RohamsWieners.VaultPublicPath,
                        providerPath: /private/RohamsWienersVault,
                        receiverLinkedType: Type<&Vault{FungibleToken.Receiver}>(),
                        metadataLinkedType: Type<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(),
                        providerLinkedType: Type<&Vault{FungibleToken.Provider}>(),
                        createEmptyVaultFunction: (fun (): @Vault {
                            return <- RohamsWieners.createEmptyVault()
                        })
                    )
            }
            return nil
        }

        init(balance: UFix64) {
            self.balance = balance
        }

        destroy() {
            if (self.balance > 0.0) {
                emit TokensBurned(amount: self.balance)
                RohamsWieners.totalSupply = RohamsWieners.totalSupply - self.balance
            }
        }
    }

    pub fun createEmptyVault(): @Vault {
        return <- create Vault(balance: 0.0)
    }

    pub resource Minter: Toucans.Minter {
        pub fun mint(amount: UFix64): @Vault {
            post {
                RohamsWieners.maxSupply == nil || RohamsWieners.totalSupply <= RohamsWieners.maxSupply!:
                    "Exceeded the max supply of tokens allowd."
            }
            RohamsWieners.totalSupply = RohamsWieners.totalSupply + amount
            emit TokensMinted(amount: amount)
            return <- create Vault(balance: amount)
        }
    }

    // We follow this pattern of storage
    // so the (potentially) huge dictionary
    // isn't loaded when the contract is imported
    pub resource Administrator {
        // This is an experimental index and should
        // not be used for anything official
        // or monetary related
        access(self) let balances: {Address: UFix64}

        access(contract) fun setBalance(address: Address, balance: UFix64) {
            self.balances[address] = balance
        }

        pub fun getBalance(address: Address): UFix64 {
            return self.balances[address] ?? 0.0
        }

        pub fun getBalances(): {Address: UFix64} {
            return self.balances
        }

        init() {
            self.balances = {}
        }
    }

    access(contract) fun setBalance(address: Address, balance: UFix64) {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        admin.setBalance(address: address, balance: balance)
    }

    pub fun getBalance(address: Address): UFix64 {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalance(address: address)
    }

    pub fun getBalances(): {Address: UFix64} {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalances()
    }

    init(
      _paymentTokenInfo: ToucansTokens.TokenInfo,
      _editDelay: UFix64,
      _minting: Bool,
      _initialTreasurySupply: UFix64,
      _maxSupply: UFix64?,
      _extra: {String: AnyStruct}
    ) {

      // Contract Variables
      self.totalSupply = 0.0
      self.maxSupply = _maxSupply

      // Paths
      self.VaultStoragePath = /storage/RohamsWienersVault
      self.ReceiverPublicPath = /public/RohamsWienersReceiver
      self.VaultPublicPath = /public/RohamsWienersMetadata
      self.MinterStoragePath = /storage/RohamsWienersMinter
      self.AdministratorStoragePath = /storage/RohamsWienersAdmin

      // Admin Setup
      let vault <- create Vault(balance: self.totalSupply)
      self.account.save(<- vault, to: self.VaultStoragePath)

      self.account.link<&Vault{FungibleToken.Receiver}>(
          self.ReceiverPublicPath,
          target: self.VaultStoragePath
      )

      self.account.link<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(
          self.VaultPublicPath,
          target: self.VaultStoragePath
      )

      if self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath) == nil {
        self.account.save(<- Toucans.createCollection(), to: Toucans.CollectionStoragePath)
        self.account.link<&Toucans.Collection{Toucans.CollectionPublic}>(Toucans.CollectionPublicPath, target: Toucans.CollectionStoragePath)
      }

      let toucansProjectCollection = self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath)!
      toucansProjectCollection.createProject(
        projectTokenInfo: ToucansTokens.TokenInfo("RohamsWieners", self.account.address, "ROHAM", self.ReceiverPublicPath, self.VaultPublicPath, self.VaultStoragePath),
        paymentTokenInfo: _paymentTokenInfo,
        minter: <- create Minter(),
        editDelay: _editDelay,
        minting: _minting,
        initialTreasurySupply: _initialTreasurySupply,
        extra: _extra
      )

      self.account.save(<- create Administrator(), to: self.AdministratorStoragePath)

      // Events
      emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
 "
-------
"import Crypto
import FungibleToken from 0xf233dcee88fe0abe
import NFTCatalog from 0x49a7cda3a1eecc29
import NonFungibleToken from 0x1d7e57aa55817448
import FIND from 0x097bafa4e0b48eef
import EmeraldIdentity from 0x39e42c67cc851cfb

pub contract ToucansUtils {
  pub fun ownsNFTFromCatalogCollectionIdentifier(collectionIdentifier: String, user: Address): Bool {
    if let entry: NFTCatalog.NFTCatalogMetadata = NFTCatalog.getCatalogEntry(collectionIdentifier: collectionIdentifier) {
      let publicPath: PublicPath = entry.collectionData.publicPath
      let contractAddressToString: String = entry.contractAddress.toString()
      let constructedIdentifier: String = "A.".concat(contractAddressToString.slice(from: 2, upTo: contractAddressToString.length)).concat(".").concat(entry.contractName).concat(".Collection")

      var addresses: [Address] = [user]
      if let discordID: String = EmeraldIdentity.getDiscordFromAccount(account: user) {
        addresses = EmeraldIdentity.getEmeraldIDs(discordID: discordID).values
      }
      assert(addresses.contains(user), message: "Should always be true. Just making sure so the user doesn't get punished accidentally ;)")
      for address in addresses {
        if let collection: &{NonFungibleToken.CollectionPublic} = getAccount(address).getCapability(publicPath).borrow<&{NonFungibleToken.CollectionPublic}>() {
          let identifier: String = collection.getType().identifier
          if identifier == constructedIdentifier && collection.getIDs().length > 0 {
            return true
          }
        }
      }
    }

    return false
  }

  pub fun depositTokensToAccount(funds: @FungibleToken.Vault, to: Address, publicPath: PublicPath) {
    let vault = getAccount(to).getCapability(publicPath).borrow<&{FungibleToken.Receiver}>()
              ?? panic("Account does not have a proper Vault set up.")
    vault.deposit(from: <- funds)
  }

  pub fun rangeFunc(_ start: Int, _ end: Int, _ f : ((Int):Void) ) {
    var current = start
    while current < end{
        f(current)
        current = current + 1
    }
  }

  pub fun range(_ start: Int, _ end: Int): [Int]{
    var res:[Int] = []
    self.rangeFunc(start, end, fun (i:Int){
        res.append(i)
    })
    return res
  }

  pub fun index(_ s : String, _ substr : String, _ startIndex: Int): Int?{
    for i in self.range(startIndex,s.length-substr.length+1){
        if s[i]==substr[0] && s.slice(from:i, upTo:i+substr.length) == substr{
            return i
        }
    }
    return nil
  }

  pub fun getFind(_ address: Address): String {
    if let name = FIND.reverseLookup(address) {
      return name.concat(".find")
    }
    return address.toString()
  }

  pub fun fixToReadableString(num: UFix64): String {
    let numToString: String = num.toString()
    let indexOfDot: Int = ToucansUtils.index(numToString, ".", 1)!
    return numToString.slice(from: 0, upTo: indexOfDot + 3)
  }
}"
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import ViewResolver from 0x1d7e57aa55817448

pub contract UFCStrikeInfinity: NonFungibleToken, ViewResolver {
    pub var baseUri: String

    // Signer
    pub var signer: Address

    // Collection
    pub let collectionName: String
    pub let collectionDescription: String
    // External link to a URL to view more information about this collection.
    pub let collectionExternalURL: MetadataViews.ExternalURL
    // Square-sized image to represent this collection.
    pub let collectionSquareImage: MetadataViews.Media
    // Banner-sized image for this collection, recommended to have a size near 1200x630.
    pub let collectionBannerImage: MetadataViews.Media
    // Social links to reach this collection's social homepages.
    // Possible keys may be "instagram", "twitter", "discord", etc.
    pub let collectionSocials: {String: MetadataViews.ExternalURL}

    pub var totalSupply: UInt64

    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event Minted(id: UInt64, address: Address)

    pub event Claim(campaign_id: UInt256, verify_id: UInt256, minter: Address, owner: Address, nft_id: UInt64)
    pub event Transfer(id: UInt64, from: Address, to: Address)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let OwnerStoragePath: StoragePath

    /// Maps each token ID to its owner address
    access(self) let owners: [Address]

    /// Maps each verify ID to its minted status
    access(self) let minted: {UInt256: Bool}

    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        /// The unique ID of each NFT
        pub let id: UInt64

        /// Metadata fields
        pub let name: String
        pub let description: String
        pub let thumbnail: String
        access(self) let metadata: {String: String}

        init(
            id: UInt64,
            name: String,
            description: String,
            thumbnail: String,
            metadata: {String: String}
        ) {
            self.id = id
            self.name = name
            self.description = description
            self.thumbnail = thumbnail
            self.metadata = metadata
        }

        /// Function that returns all the Metadata Views implemented by a Non Fungible Token
        ///
        /// @return An array of Types defining the implemented views. This value will be used by
        ///         developers to know which parameter to pass to the resolveView() method.
        ///
        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.Editions>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.Traits>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.name,
                        description: self.description,
                        thumbnail: MetadataViews.HTTPFile(
                            url: self.thumbnail
                        )
                    )

                case Type<MetadataViews.Editions>():
                    // There is no max number of NFTs that can be minted from this contract
                    // so the max edition field value is set to nil
                    let editionInfo = MetadataViews.Edition(
                        name: self.name.concat(" NFT Edition"),
                        number: self.id, max: nil
                    )
                    let editionList: [MetadataViews.Edition] = [editionInfo]
                    return MetadataViews.Editions(
                        editionList
                    )

                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(
                        self.id
                    )

                case Type<MetadataViews.Royalties>():
                    return MetadataViews.Royalties([])

                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL(
                        UFCStrikeInfinity.baseUri.concat(self.id.toString()).concat(".json")
                    )

                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: UFCStrikeInfinity.CollectionStoragePath,
                        publicPath: UFCStrikeInfinity.CollectionPublicPath,
                        providerPath: /private/UFCStrikeInfinityCollection,
                        publicCollection: Type<&UFCStrikeInfinity.Collection{UFCStrikeInfinity.UFCStrikeInfinityCollectionPublic,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(),
                        publicLinkedType: Type<&UFCStrikeInfinity.Collection{UFCStrikeInfinity.UFCStrikeInfinityCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&UFCStrikeInfinity.Collection{UFCStrikeInfinity.UFCStrikeInfinityCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(),
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                            return <-UFCStrikeInfinity.createEmptyCollection()
                        })
                    )

                case Type<MetadataViews.NFTCollectionDisplay>():
                    return MetadataViews.NFTCollectionDisplay(
                        name: UFCStrikeInfinity.collectionName,
                        description: UFCStrikeInfinity.collectionDescription,
                        externalURL: UFCStrikeInfinity.collectionExternalURL,
                        squareImage: UFCStrikeInfinity.collectionSquareImage,
                        bannerImage: UFCStrikeInfinity.collectionBannerImage,
                        socials: UFCStrikeInfinity.collectionSocials,
                    )

                case Type<MetadataViews.Traits>():
                    return MetadataViews.dictToTraits(dict: self.metadata, excludedNames: [])
                }
                return nil
            }
        }

        /// Defines the methods that are particular to this NFT contract collection
        ///
        pub resource interface UFCStrikeInfinityCollectionPublic {
            pub fun deposit(token: @NonFungibleToken.NFT)
            pub fun getIDs(): [UInt64]
            pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver}
            pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
            pub fun borrowUFCStrikeInfinity(id: UInt64): &UFCStrikeInfinity.NFT? {
                post {
                    (result == nil) || (result?.id == id):
                        "Cannot borrow UFCStrikeInfinity reference: The ID of the returned reference is incorrect"
                }
            }
        }

    /// The resource that will be holding the NFTs inside any account.
    /// In order to be able to manage NFTs any account will need to create
    /// an empty collection first
    ///
    pub resource Collection: UFCStrikeInfinityCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with an `UInt64` ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        /// Removes an NFT from the collection and moves it to the caller
        ///
        /// @param withdrawID: The ID of the NFT that wants to be withdrawn
        /// @return The NFT resource that has been taken out of the collection
        ///
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        /// Adds an NFT to the collections dictionary and adds the ID to the id array
        ///
        /// @param token: The NFT resource to be included in the collection
        ///
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @UFCStrikeInfinity.NFT

            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token

            UFCStrikeInfinity.owners[id] = self.owner!.address

            emit Deposit(id: id, to: self.owner!.address)

            destroy oldToken
        }

        // transfer takes an NFT ID and a reference to a recipient's collection
        // and transfers the NFT corresponding to that ID to the recipient
        pub fun transfer(id: UInt64, recipient: &{NonFungibleToken.CollectionPublic}) {
            post {
                self.ownedNFTs[id] == nil: "The specified NFT was not transferred"
                recipient.borrowNFT(id: id) != nil: "Recipient did not receive the intended NFT"
            }

            let nft: @NonFungibleToken.NFT <- self.withdraw(withdrawID: id)

            emit Transfer(id: id, from: recipient.owner!.address, to: self.owner!.address)

            recipient.deposit(token: <- nft)
        }

        // burn destroys an NFT
        pub fun burn(id: UInt64) {
            post {
                self.ownedNFTs[id] == nil: "The specified NFT was not burned"
            }

            destroy <- self.withdraw(withdrawID: id)
        }

        /// Helper method for getting the collection IDs
        ///
        /// @return An array containing the IDs of the NFTs in the collection
        ///
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        /// Gets a reference to an NFT in the collection so that
        /// the caller can read its metadata and call its methods
        ///
        /// @param id: The ID of the wanted NFT
        /// @return A reference to the wanted NFT resource
        ///
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        /// Gets a reference to an NFT in the collection so that
        /// the caller can read its metadata and call its methods
        ///
        /// @param id: The ID of the wanted NFT
        /// @return A reference to the wanted NFT resource
        ///
        pub fun borrowUFCStrikeInfinity(id: UInt64): &UFCStrikeInfinity.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorized reference to allow downcasting
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &UFCStrikeInfinity.NFT
            }

            return nil
        }

        /// Gets a reference to the NFT only conforming to the `{MetadataViews.Resolver}`
        /// interface so that the caller can retrieve the views that the NFT
        /// is implementing and resolve them
        ///
        /// @param id: The ID of the wanted NFT
        /// @return The resource reference conforming to the Resolver interface
        ///
        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let ufcNft = nft as! &UFCStrikeInfinity.NFT
            return ufcNft
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    /// Allows anyone to create a new empty collection
    ///
    /// @return The new Collection resource
    ///
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    /// Allows anyone to claim an NFT with a valid claim signature from Galxe
    ///
    pub fun claim(
        chain_id: String,
        campaign_id: UInt256,
        verify_id: UInt256,
        cap: UInt256,
        recipient: Address,
        signature: String,
        name: String,
        description: String,
        thumbnail: String,
        metadata: {String: String}
    ) {
        // check if verify_id is already minted
        if UFCStrikeInfinity.minted[verify_id] != nil {
            panic("NFT already minted")
        }

        // turn metadata into a string to verify signature
        var metadataStr = "{"
        metadata.forEachKey(fun (key: String): Bool {
            metadataStr = metadataStr.concat(key).concat(":").concat(metadata[key]!).concat(",")
            return true
        })
        // Removing the trailing comma and space
        if (metadataStr.length > 1) {
            metadataStr = metadataStr.slice(from: 0, upTo: metadataStr.length-1)
        }
        metadataStr = metadataStr.concat("}")

        // get current contract address
        let acct = self.account.address.toString()
        let contractAddr = "A.".concat(acct.slice(from: 2, upTo: acct.length)).concat(".UFCStrikeInfinity")

        let message = "NFT(chain_id:String,contract:String,campaign_id:u64,verify_id:u64,cap:u64,owner:u64,name:String,description:String,thumbnail:String:metadata:{String: String})"
            .concat(chain_id)
            .concat(contractAddr)
            .concat(campaign_id.toString())
            .concat(verify_id.toString())
            .concat(cap.toString())
            .concat(recipient.toString())
            .concat(String.encodeHex(HashAlgorithm.SHA3_256.hash(name.utf8)))
            .concat(String.encodeHex(HashAlgorithm.SHA3_256.hash(description.utf8)))
            .concat(String.encodeHex(HashAlgorithm.SHA3_256.hash(thumbnail.utf8)))
            .concat(String.encodeHex(HashAlgorithm.SHA3_256.hash(metadataStr.utf8)))
        log(message)
        if !self.verifyClaimSignature(
            address: self.signer,
            signature: signature,
            signedData: message.utf8
        ) {
            panic("Invalid signature")
        }

        // Increment the totalSupply for a new ID
        let id = UFCStrikeInfinity.totalSupply

        // Create the new NFT
        var newNFT <- create NFT(
            id: id,
            name: name,
            description: description,
            thumbnail: thumbnail,
            metadata: metadata
        )

        UFCStrikeInfinity.minted[verify_id] = true
        emit Minted(id: id, address: recipient)

        // Get the collection of the current account using a borrowed reference
        let receiver = getAccount(recipient)
            .getCapability(UFCStrikeInfinity.CollectionPublicPath)
            .borrow<&{NonFungibleToken.CollectionPublic}>()
            ?? panic("Could not get receiver reference to the NFT Collection")

        // Update the owners mapping
        UFCStrikeInfinity.owners.append(recipient)

        // Deposit the new NFT into the current account's collection
        receiver.deposit(token: <-newNFT)

        // Increment the total supply
        UFCStrikeInfinity.totalSupply = UFCStrikeInfinity.totalSupply + 1

        let minter = self.account.address

        emit Claim(campaign_id: campaign_id, verify_id: verify_id, minter: minter, owner: recipient, nft_id: id)
    }

    access(self) fun verifyClaimSignature(address: Address, signature: String, signedData: [UInt8]): Bool {
        let signatureBytes = signature.decodeHex()
	    let account = getAccount(self.signer)
	    let keys = account.keys
        var i = 0
        while true {
            if let key = keys.get(keyIndex: i) {
                if key.isRevoked {
                    // do not check revoked keys
                    i = i + 1
                    continue
                }
                let pk = PublicKey(
                        publicKey: key.publicKey.publicKey,
                        signatureAlgorithm: key.publicKey.signatureAlgorithm
                )
                if pk.verify(
                    signature: signatureBytes,
                    signedData: signedData,
                    domainSeparationTag: "",
                    hashAlgorithm: HashAlgorithm.SHA3_256
                ) {
                    return true
                }
            } else {
                return false
            }
            i = i + 1
        }

        return false
    }

    /// Resource that an admin or something similar would own to have admin operations access
    ///
    pub resource Owner {
        pub fun updateSigner(newSigner: Address) {
            UFCStrikeInfinity.signer = newSigner
        }

        pub fun updateBaseUri(newBaseUri: String) {
            UFCStrikeInfinity.baseUri = newBaseUri
        }
    }

    // Gets the owner of the given token ID
    pub fun ownerOf(tokenId: UInt64): Address? {
        if tokenId >= 0 {
            return UFCStrikeInfinity.owners[tokenId]
        }
        return nil
    }

    init() {
        self.baseUri = "https://graphigo.prd.galaxy.eco/metadata/ufcstrikeinfinity/"

        // Initialize signer
        self.signer = self.account.address

        // Initialize collection metadatas
        self.collectionName = "UFC Strike Infinity"
        self.collectionDescription = "Introducing UFC Strike Infinity - Earn Stellar Rewards. This is a collection of the rewards you can earn via our inaugural campaign on the Galxe platform."
        self.collectionExternalURL = MetadataViews.ExternalURL("https://galxe.com/ufcstrike")
        self.collectionSquareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
                url: "https://cdn.galxe.com/galaxy/ufcstrike/ufcstrikeinfinity.jpeg"
            ),
            mediaType: "image/jpeg"
        )
        self.collectionBannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
                url: "https://cdn.galxe.com/galaxy/ufcstrike/ufcstrikeinfinity.jpeg"
            ),
            mediaType: "image/jpeg"
        )
        self.collectionSocials = {
            "twitter": MetadataViews.ExternalURL("https://twitter.com/ufcstrike"),
            "instagram": MetadataViews.ExternalURL("https://www.instagram.com/ufcstrike"),
            "discord": MetadataViews.ExternalURL("https://discord.gg/UFCStrike")
        }

        // Initialize contract internal metadatas
        // Initialize the total supply
        self.totalSupply = 0

        // Initalize mapping from ID to address
        self.owners = []

        // Initialize mapping from verify_id to bool
        self.minted = {}

        // Set the named paths
        self.CollectionStoragePath = /storage/UFCStrikeInfinityCollection
        self.CollectionPublicPath = /public/UFCStrikeInfinityCollection
        self.OwnerStoragePath = /storage/UFCStrikeInfinityOwner

        // Create a Collection resource and save it to storage
        let collection <- create Collection()
        self.account.save(<-collection, to: self.CollectionStoragePath)

        // create a public capability for the collection
        self.account.link<&UFCStrikeInfinity.Collection{NonFungibleToken.CollectionPublic, UFCStrikeInfinity.UFCStrikeInfinityCollectionPublic, MetadataViews.ResolverCollection}>(
            self.CollectionPublicPath,
            target: self.CollectionStoragePath
        )

        emit ContractInitialized()
    }
}
 "
-------
"pub contract TransactionsRegistry {
	pub event TransactionRegistered(key: String, transactionId: String)

	access(self) let registry: {String: String}

	access(self) let extra: {String: AnyStruct}

	// Doodles Drops Wearables Mint

	pub fun getRegistryDoodlesDropsWearablesMint(packTypeId: UInt64, packId: UInt64): String? {
		let key: String = self.getKeyDoodlesDropsWearablesMint(packTypeId: packTypeId, packId: packId)
		return self.registry[key]
	}

	access(account) fun registerDoodlesDropsWearablesMint(packTypeId: UInt64, packId: UInt64, transactionId: String) {
		let key: String = self.getKeyDoodlesDropsWearablesMint(packTypeId: packTypeId, packId: packId)
		if self.registry[key] != nil {
			panic("Transaction already registered")
		}
		self.registry[key] = transactionId
		emit TransactionRegistered(key: key, transactionId: transactionId)
	}

	access(self) fun getKeyDoodlesDropsWearablesMint(packTypeId: UInt64, packId: UInt64): String {
		let prefix: String = "doodles-drops-wearables-mint-"
		let key: String = prefix.concat(packTypeId.toString()).concat("-").concat(packId.toString())
		return key
	}

	// Doodles Drops Redeemables Mint

	pub fun getRegistryDoodlesDropsRedeemablesMint(packTypeId: UInt64, packId: UInt64): String? {
		let key: String = self.getKeyDoodlesDropsRedeemablesMint(packTypeId: packTypeId, packId: packId)
		return self.registry[key]
	}

	access(account) fun registerDoodlesDropsRedeemablesMint(packTypeId: UInt64, packId: UInt64, transactionId: String) {
		let key: String = self.getKeyDoodlesDropsRedeemablesMint(packTypeId: packTypeId, packId: packId)
		if self.registry[key] != nil {
			panic("Transaction already registered")
		}
		self.registry[key] = transactionId
		emit TransactionRegistered(key: key, transactionId: transactionId)
	}

	access(self) fun getKeyDoodlesDropsRedeemablesMint(packTypeId: UInt64, packId: UInt64): String {
		let prefix: String = "doodles-drops-redeemables-mint-"
		let key: String = prefix.concat(packTypeId.toString()).concat("-").concat(packId.toString())
		return key
	}

	init() {
		self.registry = {}
		self.extra = {}
	}

}
"
-------
"// Flickplay

import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract BarelyABear: NonFungibleToken {
    /// Events
    ///
    pub event ContractInitialized() /// emitted when the contract is initialized
    pub event Withdraw(id: UInt64, from: Address?) /// emitted when an NFT is withdrawn from an account
    pub event Deposit(id: UInt64, to: Address?) /// emitted when an NFT is deposited into an account
    pub event Minted(id: UInt64) /// emitted when a new NFT is minted
    pub event NFTDestroyed(id: UInt64) /// emitted when an NFT is destroyed
    pub event SetCreated(setId: UInt32) /// emitted when a new NFT set is created
    pub event SetMetadataUpdated(setId: UInt32) /// emitted when the metadata of an NFT set is updated
    pub event NFTMinted(tokenId: UInt64,setId: UInt32, editionNum: UInt64) /// emitted when a new NFT is minted within a specific set
    pub event ActionsAllowed(setId: UInt32, ids: [UInt64]) /// emitted when actions are allowed for a specific set and IDs
    pub event ActionsRestricted(setId: UInt32, ids: [UInt64]) /// emitted when actions are restricted for a specific set and IDs
    pub event AddedToWhitelist(addedAddresses: [Address]) /// emitted when addresses are added to the whitelist
    pub event RemovedFromWhitelist(removedAddresses: [Address]) /// emitted when addresses are removed from the whitelist
    pub event RoyaltyCutUpdated(newRoyaltyCut: UFix64) /// emitted when the royalty cut is updated
    pub event RoyaltyAddressUpdated(newAddress: Address) /// emitted when the royalty address is updated
    pub event NewAdminCreated() /// emitted when a new admin is created
    pub event Unboxed(setId: UInt32) /// emitted when set id updated when unboxing

    /// Contract paths
    ///
    pub let CollectionStoragePath: StoragePath /// the storage path for NFT collections
    pub let CollectionPublicPath: PublicPath /// the public path for NFT collections
    pub let AdminStoragePath: StoragePath
    pub let AdminPrivatePath: PrivatePath

    pub var totalSupply: UInt64 /// the total number of NFTs minted by the contract
    access(self) var royaltyCut: UFix64 //// the percentage of royalties to be distributed
    pub var royaltyAddress: Address /// the address to receive royalties
    pub var whitelist:{Address:Bool} /// a dictionary that maps addresses to a boolean value, indicating if the address is whitelisted
    access(self) var setMetadata: {UInt32: NFTSetMetadata} /// a dictionary that maps set IDs to NFTSetMetadata resources
    pub var allowedActions: {UInt32:{UInt64: Bool}} /// a dictionary that maps set IDs to a dictionary of token IDs and their allowed actions
    access(self) var series: @Series /// a reference to the Series resource




    pub resource Series {

        /// Resource state variables
        ///
        access(self) var setIds: [UInt32]
        access(self) var tokenIDs: UInt64
        access(self) var numberEditionsMintedPerSet: {UInt32: UInt64}

        /// Initialize the Series resource
        ///
        init() {
            self.numberEditionsMintedPerSet = {}
            self.setIds = []
            self.tokenIDs = 0
        }



        pub fun addNftSet(
            setId: UInt32,
            name: String,
            edition:String,
            thumbnail: String,
            description: String,
            httpFile: String,
            maxEditions: UInt64,
            mediaFile: String,
            externalUrl:String,
            twitterLink:String,
            toyStats: ToyStats,
            toyProperties: {String: AnyStruct}
           ) {
            pre {
                self.setIds.contains(setId) == false: "The Set has already been added to the Series."
            }

            var newNFTSet = NFTSetMetadata(
                setId: setId,
                name: name,
                edition: edition,
                thumbnail: thumbnail,
                description: description,
                httpFile: httpFile,
                maxEditions: maxEditions,
                mediaFile: mediaFile,
                externalUrl: externalUrl,
                twitterLink: twitterLink,
                toyStats: toyStats,
                toyProperties: toyProperties
            )
            self.setIds.append(setId)
            self.numberEditionsMintedPerSet[setId] = 0
            BarelyABear.setMetadata[setId] = newNFTSet

            emit SetCreated(setId: setId)
        }


        pub fun updateSetMetadata(
            setId: UInt32,
            name: String,
            edition:String,
            thumbnail: String,
            description: String,
            httpFile: String,
            maxEditions: UInt64,
            mediaFile: String,
            externalUrl:String,
            twitterLink:String,
            toyStats: ToyStats,
            toyProperties: {String: AnyStruct}
            ) {
            pre {
                self.setIds.contains(setId) == true: "The Set is not part of this Series."
            }
            let newSetMetadata = NFTSetMetadata(
                setId: setId,
                name: name,
                edition: edition,
                thumbnail: thumbnail,
                description: description,
                httpFile: httpFile,
                maxEditions: maxEditions,
                mediaFile: mediaFile,
                externalUrl: externalUrl,
                twitterLink: twitterLink,
                toyStats: toyStats,
                toyProperties: toyProperties
            )
            BarelyABear.setMetadata[setId] = newSetMetadata

            emit SetMetadataUpdated(setId: setId)
        }


        pub fun updateSetStats(
            setId: UInt32,
            toyStats: ToyStats,
            ) {
            pre {
                self.setIds.contains(setId) == true: "The Set is not part of this Series."
            }

            let newSetMetadata = NFTSetMetadata(
                setId: setId,
                name: BarelyABear.getSetMetadata(setId: setId).name,
                edition: BarelyABear.getSetMetadata(setId: setId).edition,
                thumbnail: BarelyABear.getSetMetadata(setId: setId).thumbnail,
                description: BarelyABear.getSetMetadata(setId: setId).description,
                httpFile: BarelyABear.getSetMetadata(setId: setId).httpFile,
                maxEditions: BarelyABear.getSetMetadata(setId: setId).maxEditions,
                mediaFile: BarelyABear.getSetMetadata(setId: setId).mediaFile,
                externalUrl: BarelyABear.getSetMetadata(setId: setId).externalUrl,
                twitterLink: BarelyABear.getSetMetadata(setId: setId).twitterLink,
                toyStats: toyStats,
                toyProperties: BarelyABear.getSetMetadata(setId: setId).toyProperties
            )
            BarelyABear.setMetadata[setId] = newSetMetadata

            emit SetMetadataUpdated(setId: setId)
        }

        pub fun updateSetTraits(
            setId: UInt32,
            toyProperties: {String: AnyStruct},
            ) {
            pre {
                self.setIds.contains(setId) == true: "The Set is not part of this Series."
            }

            let newSetMetadata = NFTSetMetadata(
                setId: setId,
                name: BarelyABear.getSetMetadata(setId: setId).name,
                edition: BarelyABear.getSetMetadata(setId: setId).edition,
                thumbnail: BarelyABear.getSetMetadata(setId: setId).thumbnail,
                description: BarelyABear.getSetMetadata(setId: setId).description,
                httpFile: BarelyABear.getSetMetadata(setId: setId).httpFile,
                maxEditions: BarelyABear.getSetMetadata(setId: setId).maxEditions,
                mediaFile: BarelyABear.getSetMetadata(setId: setId).mediaFile,
                externalUrl: BarelyABear.getSetMetadata(setId: setId).externalUrl,
                twitterLink: BarelyABear.getSetMetadata(setId: setId).twitterLink,
                toyStats: BarelyABear.getSetMetadata(setId: setId).toyStats,
                toyProperties: toyProperties
            )
            BarelyABear.setMetadata[setId] = newSetMetadata

            emit SetMetadataUpdated(setId: setId)
        }

        pub fun updateGenericMetadata(
            setId: UInt32,
            name: String,
            edition: String,
            thumbnail: String,
            description: String,
            httpFile: String,
            maxEditions: UInt64,
            mediaFile: String,
            externalUrl:String,
            twitterLink:String,
        ) {
            pre {
                self.setIds.contains(setId) == true: "The Set is not part of this Series."
            }
            let newSetMetadata = NFTSetMetadata(
                setId: setId,
                name: name,
                edition: edition,
                thumbnail: thumbnail,
                description: description,
                httpFile: httpFile,
                maxEditions: maxEditions,
                mediaFile: mediaFile,
                externalUrl: externalUrl,
                twitterLink: twitterLink,
                toyStats: BarelyABear.getSetMetadata(setId: setId).toyStats,
                toyProperties: BarelyABear.getSetMetadata(setId: setId).toyProperties
            )
            BarelyABear.setMetadata[setId] = newSetMetadata

            emit SetMetadataUpdated(setId: setId)
        }

	    pub fun mintFlickplaySeriesNFT(
            recipient: &{NonFungibleToken.CollectionPublic},
            setId: UInt32) {

            pre {
                self.numberEditionsMintedPerSet[setId] != nil: "The Set does not exist."
                self.numberEditionsMintedPerSet[setId]! < BarelyABear.getSetMaxEditions(setId: setId)!:
                    "Set has reached maximum NFT edition capacity."
            }

            let tokenId: UInt64 = self.tokenIDs
            let editionNum: UInt64 = self.numberEditionsMintedPerSet[setId]! + 1

			recipient.deposit(token: <-create BarelyABear.NFT(
                tokenId: tokenId,
                setId: setId,
                editionNum: editionNum,
                name: BarelyABear.getSetMetadata(setId: setId).name,
                description: BarelyABear.getSetMetadata(setId: setId).description,
                thumbnail: BarelyABear.getSetMetadata(setId: setId).thumbnail
            ))

            self.tokenIDs = self.tokenIDs + 1

            BarelyABear.totalSupply = BarelyABear.totalSupply + 1
            self.numberEditionsMintedPerSet[setId] = editionNum

            emit NFTMinted(tokenId: tokenId,setId: setId, editionNum: editionNum)
        }


		pub fun batchMintFlickplaySeriesNFT(
            recipient: &{NonFungibleToken.CollectionPublic},
            setId: UInt32,
            amount: UInt32,
            ) {

            pre {
                amount > 0:
                    "Amount must be > 0"
            }

            var i: UInt32 = 0
            while i < amount {
                self.mintFlickplaySeriesNFT(
                    recipient: recipient,
                    setId: setId,
                )
                i = i + 1
            }
		}
	}

    pub struct ToyStats {
        pub var level: UInt32
        pub var xp: UInt32
        pub var likes: UInt32
        pub var views: UInt32
        pub var uses: UInt32
        // pub var animation: String

        init(
            level: UInt32,
            xp: UInt32,
            likes: UInt32,
            views: UInt32,
            uses: UInt32
            // animation: String,
        ) {
            self.level = level
            self.xp = xp
            self.likes = likes
            self.views = views
            self.uses = uses
            // self.animation = animation
        }
    }

    pub fun getStats(_ viewResolver: &{MetadataViews.Resolver}) : ToyStats? {
        if let view = viewResolver.resolveView(Type<BarelyABear.ToyStats>()) {
            if let v = view as? ToyStats {
                return v
            }
        }
        return nil
    }

       pub struct NFTSetMetadata {

        pub var setId: UInt32
        pub var name: String
        pub var edition: String
        pub var thumbnail: String
        pub var description: String
        pub var httpFile: String
        pub var maxEditions: UInt64
        pub var mediaFile: String
        pub var externalUrl: String
        pub var twitterLink: String
        pub var toyStats: ToyStats
        pub var toyProperties: {String: AnyStruct}

        init(
            setId: UInt32,
            name: String,
            edition: String,
            thumbnail: String,
            description: String,
            httpFile: String,
            maxEditions: UInt64,
            mediaFile: String,
            externalUrl: String,
            twitterLink: String,
            toyStats: ToyStats,
            toyProperties: {String: AnyStruct}
) {

            self.setId = setId
            self.name = name
            self.edition = edition
            self.thumbnail = thumbnail
            self.description = description
            self.httpFile = httpFile
            self.maxEditions = maxEditions
            self.mediaFile = mediaFile
            self.externalUrl = externalUrl
            self.twitterLink = twitterLink
            self.toyStats = toyStats
            self.toyProperties = toyProperties


            emit SetCreated(setId: self.setId)
        }
    }



    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        pub let id: UInt64
        pub var setId: UInt32
        pub let editionNum: UInt64
        pub let name: String
        pub let description: String
        pub let thumbnail: String
        init(
          tokenId: UInt64,
          setId: UInt32,
          editionNum: UInt64,
          name: String,
          description: String,
          thumbnail: String) {
            self.id = tokenId
            self.setId = setId
            self.editionNum = editionNum
            self.name = name
            self.description = description
            self.thumbnail = thumbnail
            emit Minted(id: self.id)
        }

        destroy() {
            BarelyABear.totalSupply = BarelyABear.totalSupply - 1
            emit NFTDestroyed(id: self.id)
        }

        access(contract) fun unbox(newSetId: UInt32){
            self.setId = newSetId
            emit Unboxed(setId: newSetId)
        }



        pub fun getViews(): [Type] {
            return [
               Type<MetadataViews.Display>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.Editions>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.Traits>(),
                Type<BarelyABear.ToyStats>()
            ]
        }


      pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: BarelyABear.getSetMetadata(setId: self.setId).name,
                        description: BarelyABear.getSetMetadata(setId: self.setId).description,
                        thumbnail: MetadataViews.HTTPFile(
                            url: BarelyABear.getSetMetadata(setId: self.setId).thumbnail,
                        )
                    )
                case Type<MetadataViews.Editions>():
                    let editionInfo = MetadataViews.Edition(
                     name: BarelyABear.getSetMetadata(setId: self.setId).edition,
                     number: self.editionNum,
                     max: BarelyABear.getSetMetadata(setId: self.setId).maxEditions)
                    let editionList: [MetadataViews.Edition] = [editionInfo]
                        return MetadataViews.Editions(
                        editionList
                     )
                case Type<MetadataViews.HTTPFile>():
                    return MetadataViews.HTTPFile(
                        BarelyABear.getSetMetadata(setId: self.setId).httpFile
                    )
                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(
                        self.id
                    )
                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL(BarelyABear.getSetMetadata(setId: self.setId).externalUrl)
                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: BarelyABear.CollectionStoragePath,
                        publicPath: BarelyABear.CollectionPublicPath,
                        providerPath: /private/BarelyABearCollection,
                        publicCollection: Type<&BarelyABear.Collection{BarelyABear.FlickplaySeriesCollectionPublic}>(),
                        publicLinkedType: Type<&BarelyABear.Collection{BarelyABear.FlickplaySeriesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&BarelyABear.Collection{BarelyABear.FlickplaySeriesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(),
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                            return <-BarelyABear.createEmptyCollection()
                        })
                    )
                case Type<MetadataViews.NFTCollectionDisplay>():
                    let media = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: BarelyABear.getSetMetadata(setId: self.setId).mediaFile
                        ),
                        mediaType: "image/svg+xml"
                    )
                    return MetadataViews.NFTCollectionDisplay(
                        name: BarelyABear.getSetMetadata(setId: self.setId).name,
                        description:  BarelyABear.getSetMetadata(setId: self.setId).description,
                        externalURL: MetadataViews.ExternalURL(BarelyABear.getSetMetadata(setId: self.setId).externalUrl),
                        squareImage: media,
                        bannerImage: media,
                        socials: {
                            "twitter": MetadataViews.ExternalURL(BarelyABear.getSetMetadata(setId: self.setId).twitterLink)
                        }
                    )
                case Type<MetadataViews.Royalties>():
                    let royaltyReceiver: Capability<&{FungibleToken.Receiver}> =
                        getAccount(BarelyABear.royaltyAddress).getCapability<&AnyResource{FungibleToken.Receiver}>(MetadataViews.getRoyaltyReceiverPublicPath())
                    return MetadataViews.Royalties(
                        royalties: [
                            MetadataViews.Royalty(
                                receiver: royaltyReceiver,
                                cut: BarelyABear.royaltyCut,
                                description: "Flickplay Royalty"
                            )
                        ]
                    )
                case Type<MetadataViews.Traits>():
                    let traitsView = MetadataViews.dictToTraits(dict:  BarelyABear.getSetMetadata(setId: self.setId).toyProperties, excludedNames: [])
                    return traitsView
                case Type<BarelyABear.ToyStats>():
                    return  BarelyABear.getSetMetadata(setId: self.setId).toyStats
            }
            return nil
        }
    }



    pub resource Admin: IAdminSafeShare {



        pub fun borrowSeries(): &Series  {
            return &BarelyABear.series as &Series
        }



        pub fun setAllowedActions(setId: UInt32, ids: [UInt64]) {
            let set = BarelyABear.allowedActions[setId] ?? {}
            for id in ids {
                set[id] = true
                }
            BarelyABear.allowedActions[setId] = set
            emit ActionsAllowed(setId: setId, ids: ids)
        }



        pub fun setRestrictedActions(setId: UInt32, ids: [UInt64]) {
            let set = BarelyABear.allowedActions[setId] ?? {}
            for id in ids {
                set[id] = false
            }
            BarelyABear.allowedActions[setId] = set
            emit ActionsRestricted(setId: setId, ids: ids)
        }




        pub fun addToWhitelist(_toAddAddresses: [Address]) {
            for address in _toAddAddresses {
                BarelyABear.whitelist[address] = true
            }
            emit AddedToWhitelist(addedAddresses: _toAddAddresses)
        }



        pub fun removeFromWhitelist(_toRemoveAddresses: [Address]) {
            for address in _toRemoveAddresses {
                BarelyABear.whitelist[address] = false
            }
            emit RemovedFromWhitelist(removedAddresses: _toRemoveAddresses)
        }




        pub fun unboxNft(address: Address, nftId: UInt64, newSetId: UInt32 ){
            let collectionRef = getAccount(address).getCapability<&{BarelyABear.FlickplaySeriesCollectionPublic}>(BarelyABear.CollectionPublicPath).borrow()
            let nftRef = collectionRef!.borrowFlickplaySeries(id: nftId)
            nftRef?.unbox(newSetId: newSetId)
        }



        pub fun setRoyaltyCut(newRoyalty: UFix64){
            BarelyABear.royaltyCut = newRoyalty
            emit RoyaltyCutUpdated(newRoyaltyCut: newRoyalty)
        }



        pub fun setRoyaltyAddress(newReceiver: Address){
            BarelyABear.royaltyAddress = newReceiver
            emit RoyaltyAddressUpdated(newAddress: newReceiver)
        }



        pub fun createNewAdmin(): @Admin {
            return <-create Admin()
        }

    }



    pub resource interface IAdminSafeShare{
        pub fun borrowSeries(): &Series
        pub fun setAllowedActions(setId: UInt32, ids: [UInt64])
        pub fun setRestrictedActions(setId: UInt32, ids: [UInt64])
        pub fun addToWhitelist(_toAddAddresses: [Address])
        pub fun removeFromWhitelist(_toRemoveAddresses: [Address])
        pub fun unboxNft(address: Address, nftId: UInt64, newSetId: UInt32 )
    }




    pub resource interface FlickplaySeriesCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowFlickplaySeries(id: UInt64): &BarelyABear.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow BarelyABear reference: The ID of the returned reference is incorrect"
            }
        }
    }



    pub resource Collection: FlickplaySeriesCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {

        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}



        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let ref = (&self.ownedNFTs[withdrawID] as auth &NonFungibleToken.NFT?)!
            let flickplayNFT = ref as! &BarelyABear.NFT
            BarelyABear.getAllowedActionsStatus(setId: flickplayNFT.setId,tokenId: flickplayNFT.id) ?? panic("Actions for this token NOT allowed")
            let token <- self.ownedNFTs.remove(key: withdrawID)  ?? panic("missing NFT")
            emit Withdraw(id: token.id, from: self.owner?.address)
            return <-token
        }



        pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {
            var batchCollection <- create Collection()
            for id in ids {
                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))
            }
            return <-batchCollection
        }



        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @BarelyABear.NFT
            // BarelyABear.getAllowedActionsStatus(setId: token.setId,tokenId: token.id) ?? panic("Actions for this token NOT allowed")
            let id: UInt64 = token.id
            let oldToken <- self.ownedNFTs[id] <- token
            emit Deposit(id: id, to: self.owner?.address)
            destroy oldToken
        }

        // access(contract) fun depositInternal(token: @BarelyABear.NFT) {
        //     let id: UInt64 = token.id
        //     let oldToken <- self.ownedNFTs[id] <- token
        //     emit Deposit(id: id, to: self.owner?.address)
        //     destroy oldToken
        // }



        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {
            let keys = tokens.getIDs()
            for key in keys {
                self.deposit(token: <-tokens.withdraw(withdrawID: key))
            }
            destroy tokens
        }



        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }



        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }



        pub fun borrowFlickplaySeries(id: UInt64): &BarelyABear.NFT? {
            if self.ownedNFTs[id] != nil {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &BarelyABear.NFT
            } else {
                return nil
            }
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let flickplayNFT = nft as! &BarelyABear.NFT
            return flickplayNFT as &AnyResource{MetadataViews.Resolver}
        }



        destroy() {
            destroy self.ownedNFTs
        }


        pub fun burn(id: UInt64) {
            let nft <- self.ownedNFTs.remove(key: id) as! @BarelyABear.NFT?
            destroy nft
        }

        init () {
            self.ownedNFTs <- {}
        }
    }



    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create BarelyABear.Collection()
    }



    pub fun fetch(_ from: Address, id: UInt64): &BarelyABear.NFT? {
        let collection = getAccount(from)
            .getCapability(BarelyABear.CollectionPublicPath)
            .borrow<&BarelyABear.Collection{BarelyABear.FlickplaySeriesCollectionPublic}>()
            ?? panic("Couldn't get collection")
        return collection.borrowFlickplaySeries(id: id)
    }




    pub fun getSetMetadata(setId: UInt32): BarelyABear.NFTSetMetadata {
        return BarelyABear.setMetadata[setId]!
    }



    pub fun getAllowedActionsStatus(setId: UInt32, tokenId: UInt64): Bool? {
        if let set = BarelyABear.allowedActions[setId] {
            return set[tokenId]
        } else {
            return nil
        }
    }


    pub fun getAllSets(): [BarelyABear.NFTSetMetadata] {
        return BarelyABear.setMetadata.values
    }



    pub fun getSetMaxEditions(setId: UInt32): UInt64? {
        return BarelyABear.setMetadata[setId]?.maxEditions
    }



	init() {
        self.CollectionStoragePath = /storage/BarelyABearCollection
        self.CollectionPublicPath = /public/BarelyABearCollection
        self.AdminStoragePath = /storage/BarelyABearAdmin
        self.AdminPrivatePath = /private/BarelyABearAdminPrivate
        self.totalSupply = 0
        self.royaltyCut = 0.02
        self.royaltyAddress = self.account.address
        self.setMetadata = {}
        self.whitelist = {}
        self.allowedActions = {}
        self.series <- create Series()
        self.account.save(<-create Admin(), to: self.AdminStoragePath)
        self.account.link<&BarelyABear.Admin>(
            self.AdminPrivatePath,
            target: self.AdminStoragePath
        ) ?? panic("Could not get a capability to the admin")

        emit ContractInitialized()
	}
}
 "
-------
"// MADE BY: Bohao Tang

import FLOAT from 0x2d4c3caffbeab845
import FLOATEventSeries from 0x1dd5caae66e2c440

pub contract FLOATChallengeVerifiers {
    //
    // ChallengeAchievementPoint
    //
    // Specifies a FLOAT Challenge to limit who accomplished
    // a number of achievement point can claim the FLOAT
    pub struct ChallengeAchievementPoint: FLOAT.IVerifier {
        pub let challengeIdentifier: FLOATEventSeries.EventSeriesIdentifier
        pub let challengeThresholdPoints: UInt64

        pub fun verify(_ params: {String: AnyStruct}) {
            let claimee: Address = params["claimee"]! as! Address
            if let achievementBoard = getAccount(claimee)
                .getCapability(FLOATEventSeries.FLOATAchievementBoardPublicPath)
                .borrow<&FLOATEventSeries.AchievementBoard{FLOATEventSeries.AchievementBoardPublic}>()
            {
                // build goal status by different ways
                if let record = achievementBoard.borrowAchievementRecordRef(
                    host: self.challengeIdentifier.host,
                    seriesId: self.challengeIdentifier.id
                ) {
                    assert(
                        record.score >= self.challengeThresholdPoints,
                        message: "You do not meet the minimum required Achievement Point for Challenge#".concat(self.challengeIdentifier.id.toString())
                    )
                } else {
                    panic("You do not have Challenge Achievement Record for Challenge#".concat(self.challengeIdentifier.id.toString()))
                }
            } else {
                panic("You do not have Challenge Achievement Board")
            }
        }

        init(_challengeHost: Address, _challengeId: UInt64, thresholdPoints: UInt64) {
            self.challengeThresholdPoints = thresholdPoints
            self.challengeIdentifier = FLOATEventSeries.EventSeriesIdentifier(_challengeHost, _challengeId)
            // ensure challenge exists
            self.challengeIdentifier.getEventSeriesPublic()
        }
    }
}"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import ExpToken from 0x16e5460970ceb4ef
import DailyTask from 0x16e5460970ceb4ef

import TopShot from 0x0b2a3299cc857e29
import Market from 0xc1e4f4f4c4257510
import DapperUtilityCoin from 0xead892083b3e2c6c

pub contract GamingIntegration_NBATopshot {

    pub event ExpRewarded(amount: UFix64, to: Address)
    pub event NewExpWeight(weight: UFix64)

    pub var nbaExpWeight: UFix64

    // The wrapper function to purchase nba nfts
    pub fun purchase(
        playerAddr: Address,
        salePublic: &{Market.SalePublic},
        tokenID: UInt64,
        buyTokens: @DapperUtilityCoin.Vault
    ): @TopShot.NFT
    {
        // Gamification Rewards
        let expAmount = buyTokens.balance * self.nbaExpWeight
        ExpToken.gainExp(expAmount: expAmount, playerAddr: playerAddr)

        emit ExpRewarded(amount: expAmount, to: playerAddr)

        // Daily task
        DailyTask.completeDailyTask(playerAddr: playerAddr, taskType: "BUY_NBA")

        // Purchase NBA
        return <-salePublic.purchase(tokenID: 15172405, buyTokens: <-buyTokens)
    }

    pub resource Admin {
        pub fun setExpWeight(weight: UFix64) {
            emit NewExpWeight(weight: weight)
            GamingIntegration_NBATopshot.nbaExpWeight = weight
        }
    }

    init() {
        self.nbaExpWeight = 1.0

        self.account.save(<-create Admin(), to: /storage/adminPath_nba)
    }
}
 "
-------
"import ExpToken from 0x16e5460970ceb4ef

pub contract DailyTask {

    // Task Types
    // {TaskName: IfValid}, e.g. SWAP_ONCE, MINT_FLOAT, BUY_NBA
    // Not using enums to represent task types because it's not convenient to add, delete, or modify them
    pub let taskTypes: {String: Bool}

    // {playerAddr: {taskType: taskStatus}}
    // 0: incomplete
    // 1: completed
    // 2: reward claimed
    pub let playerTaskComplete: {Address: {String: Int}}

    pub event NewTaskType(taskType: String)
    pub event CompleteTask(day: UInt64, taskType: String, playerAddr: Address)
    pub event claimTaskReward(day: UInt64, taskType: String, playerAddr: Address, amount: UFix64)

    // Determine current date using block's timestamp modulo the number of seconds in a day
    pub fun getCurrentDate(): UInt64 {
        let secondsInADay: UFix64 = 86400.0 // 24 hours * 60 minutes * 60 seconds
        return UInt64(getCurrentBlock().timestamp / secondsInADay)
    }

    // Generate a random task for the day
    pub fun getTodayTaskType(): String {
        let today = self.getCurrentDate()
        let totalTaskTypeCount = self.taskTypes.keys.length

        return self.taskTypes.keys[Int(today) % Int(totalTaskTypeCount)]
    }

    // Complete the task, called by other GamingIntegration, based on the current timestamp within a day as the unit
    access(account) fun completeDailyTask(playerAddr: Address, taskType: String) {
        let today = self.getCurrentDate()
        if (self.playerTaskComplete.containsKey(playerAddr) == false) {
            self.playerTaskComplete[playerAddr] = {}
        }
        emit CompleteTask(day: today, taskType: taskType, playerAddr: playerAddr)
        if (self.playerTaskComplete[playerAddr]!.containsKey(taskType) == false) {
            self.playerTaskComplete[playerAddr]!.insert(key: taskType, 1)
            return
        }
        let curStatus = self.playerTaskComplete[playerAddr]![taskType]!
        // Task completed
        if (curStatus == 2) {
            return
        }
        self.playerTaskComplete[playerAddr]!.insert(key: taskType, 1)
    }

    // Claim reward for today's task
    pub fun claimTodayReward(dayIndex: UInt64, taskType: String, userCertificateCap: Capability<&ExpToken.UserCertificate>): @ExpToken.Vault {
        let playerAddr = userCertificateCap.borrow()!.owner!.address
        assert(self.playerTaskComplete[playerAddr]![taskType]! == 1, message: "Task has been claimed or remains incomplete")
        self.playerTaskComplete[playerAddr]!.insert(key: taskType, 2)
        let expReward = 100.0
        let expVault <- ExpToken.mintTokens(amount: expReward)
        emit claimTaskReward(day: dayIndex, taskType: taskType, playerAddr: playerAddr, amount: expReward)
        return <- expVault
    }

    pub resource Admin {
        pub fun setNewTaskType(taskType: String) {
            emit NewTaskType(taskType: taskType)
            DailyTask.taskTypes[taskType] = true
        }
    }
    init() {
        self.taskTypes = {}
        self.taskTypes["SWAP_ONCE"] = true
        self.taskTypes["MINT_FLOAT"] = true
        self.taskTypes["BUY_NBA"] = true

        self.playerTaskComplete = {}

        self.account.save(<-create Admin(), to: /storage/adminPath_dailyTask)
    }
}"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import ExpToken from 0xab0f1e1c08b6116d
import DailyTask from 0xab0f1e1c08b6116d

import TopShot from 0x0b2a3299cc857e29
import Market from 0xc1e4f4f4c4257510
import DapperUtilityCoin from 0xead892083b3e2c6c

pub contract GamingIntegration_NBATopshot {

    pub event ExpRewarded(amount: UFix64, to: Address)
    pub event NewExpWeight(weight: UFix64)

    pub var nbaExpWeight: UFix64

    // The wrapper function to purchase nba nfts
    pub fun purchase(
        playerAddr: Address,
        salePublic: &{Market.SalePublic},
        tokenID: UInt64,
        buyTokens: @DapperUtilityCoin.Vault
    ): @TopShot.NFT
    {
        // Gamification Rewards
        let expAmount = buyTokens.balance * self.nbaExpWeight
        ExpToken.gainExp(expAmount: expAmount, playerAddr: playerAddr)

        emit ExpRewarded(amount: expAmount, to: playerAddr)

        // Daily task
        DailyTask.completeDailyTask(playerAddr: playerAddr, taskType: "BUY_NBA")

        // Purchase NBA
        return <-salePublic.purchase(tokenID: 15172405, buyTokens: <-buyTokens)
    }

    pub resource Admin {
        pub fun setExpWeight(weight: UFix64) {
            emit NewExpWeight(weight: weight)
            GamingIntegration_NBATopshot.nbaExpWeight = weight
        }
    }

    init() {
        self.nbaExpWeight = 1.0

        self.account.save(<-create Admin(), to: /storage/adminPath_nba)
    }
}
 "
-------
"import ExpToken from 0x16e5460970ceb4ef

pub contract GamingIntegration {
    //
    pub resource Player {
        pub var Level: Int

        pub var Strength: UFix64
        pub var Agility: UFix64
        pub var Intelligence: UFix64

        pub var HP: UFix64
        pub var MP: UFix64

        access(self) let reservedAttrs: {String: AnyStruct}

        init() {
            self.Level = 1
            self.Strength = 1.0
            self.Agility = 1.0
            self.Intelligence = 1.0
            self.HP = 100.0
            self.MP = 10.0
            self.reservedAttrs = {}
        }

        pub fun levelUp(expVault: @ExpToken.Vault) {
            let expConsumed = self.getNextLevelExperienceCost(curLevel: self.Level)
            assert(expConsumed == expVault.balance, message: "Insufficient experience points or overflow")
            destroy expVault
            self.Level = self.Level + 1
            // TODO Implement a more meaningful allocation method for upgrading attributes.
            self.Strength = self.Strength + UFix64(unsafeRandom()%5)
            self.Agility = self.Agility + UFix64(unsafeRandom()%5)
            self.Intelligence = self.Intelligence + UFix64(unsafeRandom()%5)
            self.HP = self.HP + UFix64(unsafeRandom()%20)
            self.MP = self.MP + UFix64(unsafeRandom()%5)
        }

        pub fun getNextLevelExperienceCost(curLevel: Int): UFix64 {
            return UFix64(curLevel) * 100.0
        }
    }

    pub fun createNewPlayer(): @Player {
        return <-create Player()
    }

    init() {
    }
}"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import ExpToken from 0x16e5460970ceb4ef
import DailyTask from 0x16e5460970ceb4ef

import FLOAT from 0x2d4c3caffbeab845

pub contract GamingIntegration_FLOAT {

    pub event ExpRewarded(amount: UFix64, to: Address)
    pub event NewExpWeight(weight: UFix64)

    pub var floatExpWeight: UFix64

    // The wrapper function to claim FLOAT requires the playerAddress to be passed in.
    pub fun claim(
        playerAddr: Address,
        FLOATEvent: &FLOAT.FLOATEvent{FLOAT.FLOATEventPublic},
        recipient: &FLOAT.Collection,
        params: {String: AnyStruct})
    {
        // Gamification Rewards
        let expAmount = self.floatExpWeight
        ExpToken.gainExp(expAmount: expAmount, playerAddr: playerAddr)

        // Claim FLOAT
        FLOATEvent.claim(recipient: recipient, params: params)

        // Daily task
        DailyTask.completeDailyTask(playerAddr: playerAddr, taskType: "MINT_FLOAT")

        emit ExpRewarded(amount: expAmount, to: playerAddr)
    }

    pub resource Admin {
        pub fun setExpWeight(weight: UFix64) {
            emit NewExpWeight(weight: weight)
            GamingIntegration_FLOAT.floatExpWeight = weight
        }
    }

    init() {
        self.floatExpWeight = 10.0

        self.account.save(<-create Admin(), to: /storage/adminPath_float)
    }
}
 "
-------
"import FungibleToken from 0xf233dcee88fe0abe
import ExpToken from 0x16e5460970ceb4ef
import DailyTask from 0x16e5460970ceb4ef

import SwapInterfaces from 0xb78ef7afa52ff906
import SwapConfig from 0xb78ef7afa52ff906

pub contract GamingIntegration_IncrementSwap {

    pub event ExpRewarded(amount: UFix64, to: Address)
    pub event NewExpWeight(weight: UFix64, token: String)

    // The proportionate weight of exp amounts obtained from different tokens
    pub let tokenExpWeights: {String: UFix64}

    // The wrapper function for Swap not only accomplishes the increment of SwapPool's swaps but also integrates gamified numerical growth
    pub fun swap(
        playerAddr: Address,
        poolAddr: Address,
        vaultIn: @FungibleToken.Vault,
        exactAmountOut: UFix64?
    ): @FungibleToken.Vault {
        // Gamification Rewards
        let tokenInType = vaultIn.getType().identifier.slice(from: 0, upTo: vaultIn.getType().identifier.length - 6)
        var tokenWeight = 0.0;
        if (self.tokenExpWeights.containsKey(tokenInType)) {
            tokenWeight = self.tokenExpWeights[tokenInType]!
        }
        let expTokenAmount = vaultIn.balance * tokenWeight
        if (expTokenAmount > 0.0) {
            ExpToken.gainExp(expAmount: expTokenAmount, playerAddr: playerAddr)
        }

        emit ExpRewarded(amount: expTokenAmount, to: playerAddr)

        // Daily task
        DailyTask.completeDailyTask(playerAddr: playerAddr, taskType: "SWAP_ONCE")

        // Inrement Swap
        let poolRef: &{SwapInterfaces.PairPublic} = getAccount(poolAddr).getCapability<&{SwapInterfaces.PairPublic}>(SwapConfig.PairPublicPath).borrow()!
        return <- poolRef.swap(
            vaultIn: <- vaultIn,
            exactAmountOut: exactAmountOut
        )
    }

    pub resource Admin {
        pub fun setTokenExpWeight(tokenKey: String, weight: UFix64) {
            emit NewExpWeight(weight: weight, token: tokenKey)
            GamingIntegration_IncrementSwap.tokenExpWeights[tokenKey] = weight
        }
    }

    init() {
        self.account.save(<-create Admin(), to: /storage/adminPath_incrementSwap)

        self.tokenExpWeights = {}
        self.tokenExpWeights["A.1654653399040a61.FlowToken"] = 0.5
        self.tokenExpWeights["A.b19436aae4d94622.FiatToken"] = 1.0
    }
}
 "
-------
"import ExpToken from 0xab0f1e1c08b6116d

pub contract DailyTask {

    // Task Types
    // {TaskName: IfValid}, e.g. SWAP_ONCE, MINT_FLOAT, BUY_NBA
    // Not using enums to represent task types because it's not convenient to add, delete, or modify them
    pub let taskTypes: {String: Bool}

    // {playerAddr: {taskType: taskStatus}}
    // 0: incomplete
    // 1: completed
    // 2: reward claimed
    pub let playerTaskComplete: {Address: {String: Int}}

    pub event NewTaskType(taskType: String)
    pub event CompleteTask(day: UInt64, taskType: String, playerAddr: Address)
    pub event claimTaskReward(day: UInt64, taskType: String, playerAddr: Address, amount: UFix64)

    // Determine current date using block's timestamp modulo the number of seconds in a day
    pub fun getCurrentDate(): UInt64 {
        let secondsInADay: UFix64 = 86400.0 // 24 hours * 60 minutes * 60 seconds
        return UInt64(getCurrentBlock().timestamp / secondsInADay)
    }

    // Generate a random task for the day
    pub fun getTodayTaskType(): String {
        let today = self.getCurrentDate()
        let totalTaskTypeCount = self.taskTypes.keys.length

        return self.taskTypes.keys[Int(today) % Int(totalTaskTypeCount)]
    }

    // Complete the task, called by other GamingIntegration, based on the current timestamp within a day as the unit
    access(account) fun completeDailyTask(playerAddr: Address, taskType: String) {
        let today = self.getCurrentDate()
        if (self.playerTaskComplete.containsKey(playerAddr) == false) {
            self.playerTaskComplete[playerAddr] = {}
        }
        emit CompleteTask(day: today, taskType: taskType, playerAddr: playerAddr)
        if (self.playerTaskComplete[playerAddr]!.containsKey(taskType) == false) {
            self.playerTaskComplete[playerAddr]!.insert(key: taskType, 1)
            return
        }
        let curStatus = self.playerTaskComplete[playerAddr]![taskType]!
        // Task completed
        if (curStatus == 2) {
            return
        }
        self.playerTaskComplete[playerAddr]!.insert(key: taskType, 1)
    }

    // Claim reward for today's task
    pub fun claimTodayReward(dayIndex: UInt64, taskType: String, userCertificateCap: Capability<&ExpToken.UserCertificate>): @ExpToken.Vault {
        let playerAddr = userCertificateCap.borrow()!.owner!.address
        assert(self.playerTaskComplete[playerAddr]![taskType]! == 1, message: "Task has been claimed or remains incomplete")
        self.playerTaskComplete[playerAddr]!.insert(key: taskType, 2)
        let expReward = 100.0
        let expVault <- ExpToken.mintTokens(amount: expReward)
        emit claimTaskReward(day: dayIndex, taskType: taskType, playerAddr: playerAddr, amount: expReward)
        return <- expVault
    }

    pub resource Admin {
        pub fun setNewTaskType(taskType: String) {
            emit NewTaskType(taskType: taskType)
            DailyTask.taskTypes[taskType] = true
        }
    }
    init() {
        self.taskTypes = {}
        self.taskTypes["SWAP_ONCE"] = true
        self.taskTypes["MINT_FLOAT"] = true
        self.taskTypes["BUY_NBA"] = true

        self.playerTaskComplete = {}

        self.account.save(<-create Admin(), to: /storage/adminPath_dailyTask)
    }
}"
-------
"import ExpToken from 0xab0f1e1c08b6116d

pub contract GamingIntegration {
    //
    pub resource Player {
        pub var Level: Int

        pub var Strength: UFix64
        pub var Agility: UFix64
        pub var Intelligence: UFix64

        pub var HP: UFix64
        pub var MP: UFix64

        access(self) let reservedAttrs: {String: AnyStruct}

        init() {
            self.Level = 1
            self.Strength = 1.0
            self.Agility = 1.0
            self.Intelligence = 1.0
            self.HP = 100.0
            self.MP = 10.0
            self.reservedAttrs = {}
        }

        pub fun levelUp(expVault: @ExpToken.Vault) {
            let expConsumed = self.getNextLevelExperienceCost(curLevel: self.Level)
            assert(expConsumed == expVault.balance, message: "Insufficient experience points or overflow")
            destroy expVault
            self.Level = self.Level + 1
            // TODO Implement a more meaningful allocation method for upgrading attributes.
            self.Strength = self.Strength + UFix64(unsafeRandom()%5)
            self.Agility = self.Agility + UFix64(unsafeRandom()%5)
            self.Intelligence = self.Intelligence + UFix64(unsafeRandom()%5)
            self.HP = self.HP + UFix64(unsafeRandom()%20)
            self.MP = self.MP + UFix64(unsafeRandom()%5)
        }

        pub fun getNextLevelExperienceCost(curLevel: Int): UFix64 {
            return UFix64(curLevel) * 100.0
        }
    }

    pub fun createNewPlayer(): @Player {
        return <-create Player()
    }

    init() {
    }
}"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import ExpToken from 0xab0f1e1c08b6116d
import DailyTask from 0xab0f1e1c08b6116d

import FLOAT from 0x2d4c3caffbeab845

pub contract GamingIntegration_FLOAT {

    pub event ExpRewarded(amount: UFix64, to: Address)
    pub event NewExpWeight(weight: UFix64)

    pub var floatExpWeight: UFix64

    // The wrapper function to claim FLOAT requires the playerAddress to be passed in.
    pub fun claim(
        playerAddr: Address,
        FLOATEvent: &FLOAT.FLOATEvent{FLOAT.FLOATEventPublic},
        recipient: &FLOAT.Collection,
        params: {String: AnyStruct})
    {
        // Gamification Rewards
        let expAmount = self.floatExpWeight
        ExpToken.gainExp(expAmount: expAmount, playerAddr: playerAddr)

        // Claim FLOAT
        FLOATEvent.claim(recipient: recipient, params: params)

        // Daily task
        DailyTask.completeDailyTask(playerAddr: playerAddr, taskType: "MINT_FLOAT")

        emit ExpRewarded(amount: expAmount, to: playerAddr)
    }

    pub resource Admin {
        pub fun setExpWeight(weight: UFix64) {
            emit NewExpWeight(weight: weight)
            GamingIntegration_FLOAT.floatExpWeight = weight
        }
    }

    init() {
        self.floatExpWeight = 10.0

        self.account.save(<-create Admin(), to: /storage/adminPath_float)
    }
}
 "
-------
"import FungibleToken from 0xf233dcee88fe0abe
import ExpToken from 0xab0f1e1c08b6116d
import DailyTask from 0xab0f1e1c08b6116d

import SwapInterfaces from 0xb78ef7afa52ff906
import SwapConfig from 0xb78ef7afa52ff906

pub contract GamingIntegration_IncrementSwap {

    pub event ExpRewarded(amount: UFix64, to: Address)
    pub event NewExpWeight(weight: UFix64, token: String)

    // The proportionate weight of exp amounts obtained from different tokens
    pub let tokenExpWeights: {String: UFix64}

    // The wrapper function for Swap not only accomplishes the increment of SwapPool's swaps but also integrates gamified numerical growth
    pub fun swap(
        playerAddr: Address,
        poolAddr: Address,
        vaultIn: @FungibleToken.Vault,
        exactAmountOut: UFix64?
    ): @FungibleToken.Vault {
        // Gamification Rewards
        let tokenInType = vaultIn.getType().identifier.slice(from: 0, upTo: vaultIn.getType().identifier.length - 6)
        var tokenWeight = 0.0;
        if (self.tokenExpWeights.containsKey(tokenInType)) {
            tokenWeight = self.tokenExpWeights[tokenInType]!
        }
        let expTokenAmount = vaultIn.balance * tokenWeight
        if (expTokenAmount > 0.0) {
            ExpToken.gainExp(expAmount: expTokenAmount, playerAddr: playerAddr)
        }

        emit ExpRewarded(amount: expTokenAmount, to: playerAddr)

        // Daily task
        DailyTask.completeDailyTask(playerAddr: playerAddr, taskType: "SWAP_ONCE")

        // Inrement Swap
        let poolRef: &{SwapInterfaces.PairPublic} = getAccount(poolAddr).getCapability<&{SwapInterfaces.PairPublic}>(SwapConfig.PairPublicPath).borrow()!
        return <- poolRef.swap(
            vaultIn: <- vaultIn,
            exactAmountOut: exactAmountOut
        )
    }

    pub resource Admin {
        pub fun setTokenExpWeight(tokenKey: String, weight: UFix64) {
            emit NewExpWeight(weight: weight, token: tokenKey)
            GamingIntegration_IncrementSwap.tokenExpWeights[tokenKey] = weight
        }
    }

    init() {
        self.account.save(<-create Admin(), to: /storage/adminPath_incrementSwap)

        self.tokenExpWeights = {}
        self.tokenExpWeights["A.1654653399040a61.FlowToken"] = 0.5
        self.tokenExpWeights["A.b19436aae4d94622.FiatToken"] = 1.0
    }
}
 "
-------
"import MetadataViews from 0x1d7e57aa55817448
import NonFungibleToken from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import FlowToken from 0x1654653399040a61
import ViewResolver from 0x1d7e57aa55817448

pub contract Piece: NonFungibleToken, ViewResolver {

	// Collection Information
	access(self) let collectionInfo: {String: AnyStruct}

	// Contract Information
	pub var totalSupply: UInt64

    // Events
    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
	pub event Deposit(id: UInt64, to: Address?)
	pub event Minted(id: UInt64, serial: UInt64, recipient: Address, creatorID: UInt64)
	pub event MetadataSuccess(creatorID: UInt64, description: String)
	pub event MetadataError(error: String)

	// Paths
	pub let CollectionStoragePath: StoragePath
	pub let CollectionPublicPath: PublicPath
	pub let CollectionPrivatePath: PrivatePath
	pub let AdministratorStoragePath: StoragePath
	pub let MetadataStoragePath: StoragePath
	pub let MetadataPublicPath: PublicPath

	access(account) let nftStorage: @{Address: {UInt64: NFT}}

	pub resource MetadataStorage: MetadataStoragePublic {
		// List of Creator
		pub var creatorsIds: {UInt64: [NFTMetadata]}

		init () {
			self.creatorsIds = {}
		}
		access(account) fun creatorExist(_ creatorId: UInt64)  {
				if self.creatorsIds[creatorId] == nil {
					self.creatorsIds[creatorId] = []
				}
		}
		access (account) fun metadataIsNew(_ creatorId: UInt64, _ description: String): Bool {
			self.creatorExist(creatorId)
			let metadata = self.findMetadata(creatorId, description)
			if metadata == nil {
				return true
			} else {
				return false
			}
		}
		access(account) fun addMetadata(_ creatorId: UInt64,_ metadata: NFTMetadata) {
				if self.creatorsIds[creatorId] == nil {
					self.creatorsIds[creatorId] = []
				}

				self.creatorsIds[creatorId]?.append(metadata)
		}

		access(account) fun updateMinted(_ creatorId: UInt64,_ description: String) {
			let metadataRef = self.findMetadataRef(creatorId, description)!
			metadataRef.updateMinted()

		}
				// Public Functions
		pub fun findMetadataRef(_ creatorId: UInt64,_ description: String): &Piece.NFTMetadata? {
			let metadatas = self.creatorsIds[creatorId]!
			var i = metadatas.length - 1
    		while i >= 0 {
			    if (metadatas[i].description == description) {
					let metadataRef: &Piece.NFTMetadata = (&self.creatorsIds[creatorId]![i] as &NFTMetadata)
					return metadataRef
				 }
    			i = i - 1
    		}
			return nil
		}

		// Public Functions
		pub fun findMetadata(_ creatorId: UInt64,_ description: String): Piece.NFTMetadata? {
			let metadatas = self.creatorsIds[creatorId]!
			var i = metadatas.length - 1
    		while i >= 0 {
			    if (metadatas[i].description == description) {
					return metadatas[i]
				 }
    			i = i - 1
    		}
			return nil
		}
		pub fun getTimeRemaining(_ creatorID: UInt64,_ description: String): UFix64? {
			let metadata = self.findMetadata(creatorID, description)!
			let answer = (metadata.creationTime + 86400.0) - getCurrentBlock().timestamp
			return answer
		}
	}

    /// Defines the methods that are particular to this NFT contract collection
    ///
    pub resource interface MetadataStoragePublic {
		pub fun getTimeRemaining(_ creatorID: UInt64,_ description: String): UFix64?
		pub fun findMetadata(_ creatorId: UInt64,_ description: String): Piece.NFTMetadata?
    }

	pub struct NFTMetadata {
		pub let creatorID: UInt64
		pub var creatorUsername: String
		pub let creatorAddress: Address
		pub let description: String
		pub let image: MetadataViews.HTTPFile
		pub let metadataId: UInt64
		pub var supply: UInt64
		pub var minted: UInt64
		pub let unlimited: Bool
		pub var extra: {String: AnyStruct}
		pub var timer: UInt64
		pub let pieceCreationDate: String
		pub let contentCreationDate: String
		pub let creationTime: UFix64
		pub let lockdownTime: UFix64
		pub let embededHTML: String

		access(account) fun updateMinted() {
			self.minted = self.minted + 1
			if(self.unlimited) {
				self.supply = self.supply + 1
			}
		}
		init(
			_creatorID: UInt64,
			_creatorUsername: String,
			_creatorAddress: Address,
			_description: String,
			_image: MetadataViews.HTTPFile,
			_supply: UInt64,
			_extra: {String: AnyStruct},
			_pieceCreationDate: String,
			_contentCreationDate: String,
			_currentTime: UFix64,
			_lockdownTime: UFix64,
			_embededHTML: String,
			) {

			self.metadataId = _creatorID
			self.creatorID = _creatorID
			self.creatorUsername = _creatorUsername
			self.creatorAddress = _creatorAddress
			self.description = _description
			self.image = _image
			self.extra = _extra
			self.supply = _supply
			self.unlimited = _supply == 0
			self.minted = 0
			self.timer = 0
			self.pieceCreationDate = _pieceCreationDate
			self.contentCreationDate = _contentCreationDate
			self.creationTime = _currentTime
			self.lockdownTime = _lockdownTime
			self.embededHTML = _embededHTML
		}
	}

	pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
		pub let id: UInt64
		// The 'metadataId' is what maps this NFT to its 'NFTMetadata'
		pub let creatorID: UInt64
		pub let serial: UInt64
		pub let description: String
		pub let originalMinter: Address

		pub fun getMetadata(): NFTMetadata {
			return Piece.getNFTMetadata(self.creatorID, self.description )!
		}

		pub fun getViews(): [Type] {
			return [
				Type<MetadataViews.Display>(),
				Type<MetadataViews.ExternalURL>(),
				Type<MetadataViews.NFTCollectionData>(),
				Type<MetadataViews.NFTCollectionDisplay>(),
				Type<MetadataViews.Royalties>(),
				Type<MetadataViews.Serial>(),
				Type<MetadataViews.NFTView>()
			]
		}

		pub fun resolveView(_ view: Type): AnyStruct? {
			let metadata = self.getMetadata()
			switch view {
				case Type<MetadataViews.Display>():
					return MetadataViews.Display(
						creatorID: metadata.creatorUsername.concat(" ").concat(metadata.contentCreationDate),
						description: metadata.description,
						thumbnail: metadata.image
					)
				case Type<MetadataViews.Traits>():
					let metaCopy = metadata.extra
					metaCopy["Serial"] = self.serial
					metaCopy["Supply"] = metadata.supply
					return MetadataViews.dictToTraits(dict: metaCopy, excludedNames: nil)

				case Type<MetadataViews.NFTView>():
					return MetadataViews.NFTView(
						id: self.id,
						uuid: self.uuid,
						display: self.resolveView(Type<MetadataViews.Display>()) as! MetadataViews.Display?,
						externalURL: self.resolveView(Type<MetadataViews.ExternalURL>()) as! MetadataViews.ExternalURL?,
						collectionData: self.resolveView(Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?,
						collectionDisplay: self.resolveView(Type<MetadataViews.NFTCollectionDisplay>()) as! MetadataViews.NFTCollectionDisplay?,
						royalties: self.resolveView(Type<MetadataViews.Royalties>()) as! MetadataViews.Royalties?,
						traits: self.resolveView(Type<MetadataViews.Traits>()) as! MetadataViews.Traits?
					)
				case Type<MetadataViews.NFTCollectionData>():
					return Piece.resolveView(view)
        		case Type<MetadataViews.ExternalURL>():
        			return Piece.getCollectionAttribute(key: "website") as! MetadataViews.ExternalURL
		        case Type<MetadataViews.NFTCollectionDisplay>():
					return Piece.resolveView(view)
				case Type<MetadataViews.Medias>():
					if metadata.embededHTML != nil {
						return MetadataViews.Medias(
							items: [
								MetadataViews.Media(
									file: MetadataViews.HTTPFile(
										url: metadata.embededHTML
									),
									mediaType: "html"
								)
							]
						)
					}
        		case Type<MetadataViews.Royalties>():
          			return MetadataViews.Royalties([
            			MetadataViews.Royalty(
              				recepient: getAccount(metadata.creatorAddress).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),
              				cut: 0.10, // 10% royalty on secondary sales
              				description: "The creator of the original content gets 10% of every secondary sale."
            			)
          			])
				case Type<MetadataViews.Serial>():
					return MetadataViews.Serial(
						self.serial
					)
			}
			return nil
		}

		init(_creatorID: UInt64, _description: String, _recipient: Address) {

			// Fetch the metadata blueprint
			let metadatas <- Piece.account.load<@Piece.MetadataStorage>(from: Piece.MetadataStoragePath)!
			let metadataRef = metadatas.findMetadata(_creatorID, _description)!
			// Assign serial number to the NFT based on the number of minted NFTs
			self.id = self.uuid
			self.creatorID = _creatorID
			self.serial = metadataRef.minted
			self.description = _description
			self.originalMinter = _recipient

			// Update the total supply of this MetadataId by 1
			metadatas.updateMinted(_creatorID, _description)
			// Update Piece collection NFTs count
			Piece.totalSupply = Piece.totalSupply + 1

			emit Minted(id: self.id, serial: self.serial, recipient: _recipient, creatorID: _creatorID)

			Piece.account.save(<- metadatas, to: Piece.MetadataStoragePath)
		}
	}

    /// Defines the methods that are particular to this NFT contract collection
    ///
    pub resource interface PieceCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowPiece(id: UInt64): &Piece.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow Piece NFT reference: the ID of the returned reference is incorrect"
            }
        }
    }

	pub resource Collection: PieceCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {

		pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

		// Withdraw removes an NFT from the collection and moves it to the caller(for Trading)
		pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
			let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

			emit Withdraw(id: token.id, from: self.owner?.address)

			return <-token
		}
		// Deposit takes a NFT and adds it to the collections dictionary
		// and adds the ID to the id array
		pub fun deposit(token: @NonFungibleToken.NFT) {
			let token <- token as! @NFT

			let id: UInt64 = token.id

			// Add the new token to the dictionary
			self.ownedNFTs[id] <-! token

			emit Deposit(id: id, to: self.owner?.address)
		}

		// GetIDs returns an array of the IDs that are in the collection
		pub fun getIDs(): [UInt64] {
			return self.ownedNFTs.keys
		}

		// BorrowNFT gets a reference to an NFT in the collection
		pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
			return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
		}

        /// Gets a reference to an NFT in the collection so that
        /// the caller can read its metadata and call its methods
        ///
        /// @param id: The ID of the wanted NFT
        /// @return A reference to the wanted NFT resource
        ///
        pub fun borrowPiece(id: UInt64): &Piece.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorized reference to allow downcasting
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &Piece.NFT
            }

            return nil
        }

		pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
			let token = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
			let nft = token as! &NFT
			return nft
		}

		pub fun claim() {
			if let storage = &Piece.nftStorage[self.owner!.address] as &{UInt64: NFT}? {
				for id in storage.keys {
					self.deposit(token: <- storage.remove(key: id)!)
				}
			}
		}

		init () {
			self.ownedNFTs <- {}
		}

		destroy() {
			destroy self.ownedNFTs
		}
	}

	pub resource Administrator {
		// Function to upload the Metadata to the contract.
		pub fun createNFTMetadata(
			channel: String,
			creatorID: UInt64,
			creatorUsername: String,
			creatorAddress: Address,
			sourceURL: String,
			description: String,
			pieceCreationDate: String,
			contentCreationDate: String,
			lockdownOption: Int,
			supplyOption: UInt64,
			imgUrl: String,
			embededHTML: String,
		) {
			// Load the metadata from the Piece account
			let metadatas <- Piece.account.load<@Piece.MetadataStorage>(from: Piece.MetadataStoragePath)!
				// Check if Metadata already exist
			if metadatas.metadataIsNew(creatorID, description) {
					metadatas.addMetadata(creatorID, NFTMetadata(
							_creatorID: creatorID,
							_creatorUsername: creatorUsername,
							_creatorAddress: creatorAddress,
							_description: description,
							_image: MetadataViews.HTTPFile(
								url: imgUrl,
							),
							_supply: supplyOption,
							_extra: {
								"Creator username": creatorUsername,
								"Creator ID": creatorID,
								"Channel": channel,
								"Text content": description,
								"Source": sourceURL,
								"Piece creation date": pieceCreationDate,
								"Content creation date": contentCreationDate
								},
							_pieceCreationDate: pieceCreationDate,
							_contentCreationDate: contentCreationDate,
							_currentTime: getCurrentBlock().timestamp,
							_lockdownTime: self.getLockdownTime(lockdownOption),
							_embededHTML: embededHTML,
					))
					emit MetadataSuccess(creatorID: creatorID, description: description)
				} else {
					emit MetadataError(error: "A Metadata for this Event already exist")
				}

			Piece.account.save(<- metadatas, to: Piece.MetadataStoragePath)
		}

		// mintNFT mints a new NFT and deposits
		// it in the recipients collection
		pub fun mintNFT(creatorId: UInt64, description: String, recipient: Address) {
			pre {
				self.isMintingAvailable(creatorId, description): "Minting for this NFT has ended or reached max supply."
			}

			let nft <- create NFT(_creatorID: creatorId, _description: description, _recipient: recipient)

			if let recipientCollection = getAccount(recipient).getCapability(Piece.CollectionPublicPath).borrow<&Piece.Collection{NonFungibleToken.CollectionPublic}>() {
				recipientCollection.deposit(token: <- nft)
			} else {
				if let storage = &Piece.nftStorage[recipient] as &{UInt64: NFT}? {
					storage[nft.id] <-! nft
				} else {
					Piece.nftStorage[recipient] <-! {nft.id: <- nft}
				}
			}
		}

		// create a new Administrator resource
		pub fun createAdmin(): @Administrator {
			return <- create Administrator()
		}
		// change piece of collection info
		pub fun changeField(key: String, value: AnyStruct) {
			Piece.collectionInfo[key] = value
		}
		access(account) fun isMintingAvailable(_ creatorId: UInt64, _ description: String): Bool {
			let metadata = Piece.getNFTMetadata(creatorId, description)!
			if (metadata.unlimited) {
				if (metadata.lockdownTime != 0.0) {
					let answer = getCurrentBlock().timestamp <= (metadata.creationTime + metadata.lockdownTime)
					return answer

				} else {
					return true
				}
			} else {
				if(metadata.minted < metadata.supply) {
					if (metadata.lockdownTime != 0.0) {
						let answer = getCurrentBlock().timestamp <= (metadata.creationTime + metadata.lockdownTime)
						return answer

					} else {
						return true
					}

				} else {
					return false
				}
			}

		}
		access(account) fun getLockdownTime(_ lockdownOption: Int): UFix64 {
			switch lockdownOption {
				case 0:
					return 43200.0
				case 1:
					return 86400.0
				default:
					return 0.0
			}
		}

	}


	// public function that anyone can call to create a new empty collection
	pub fun createEmptyCollection(): @NonFungibleToken.Collection {
		return <- create Collection()
	}

    /// Function that resolves a metadata view for this contract.
    ///
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    pub fun resolveView(_ view: Type): AnyStruct? {
        switch view {
            case Type<MetadataViews.NFTCollectionData>():
                return MetadataViews.NFTCollectionData(
                    storagePath: Piece.CollectionStoragePath,
                    publicPath: Piece.CollectionPublicPath,
                    providerPath: Piece.CollectionPrivatePath,
                    publicCollection: Type<&Piece.Collection{Piece.PieceCollectionPublic}>(),
                    publicLinkedType: Type<&Piece.Collection{Piece.PieceCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
                    providerLinkedType: Type<&Piece.Collection{Piece.PieceCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(),
                    createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                        return <-Piece.createEmptyCollection()
                    })
                )
            case Type<MetadataViews.NFTCollectionDisplay>():
				let media = Piece.getCollectionAttribute(key: "image") as! MetadataViews.Media
                return MetadataViews.NFTCollectionDisplay(
                        name: "Piece",
                        description: "Sell Pieces of any Tweet in seconds.",
                        externalURL: MetadataViews.ExternalURL("https://piece.gg/"),
                        squareImage: media,
                        bannerImage: media,
                        socials: {
                            "twitter": MetadataViews.ExternalURL("https://twitter.com/CreateAPiece")
                        }
                    )
        }
        return nil
    }

	// Get information about a NFTMetadata
	pub fun getNFTMetadata(_ creatorId: UInt64,_ description: String): Piece.NFTMetadata? {
		let publicAccount = self.account
		let metadataCapability: Capability<&AnyResource{Piece.MetadataStoragePublic}> = publicAccount.getCapability<&{MetadataStoragePublic}>(self.MetadataPublicPath)
		let metadatasRef: &AnyResource{Piece.MetadataStoragePublic} = metadataCapability.borrow()!
		let metadatas: Piece.NFTMetadata? = metadatasRef.findMetadata(creatorId, description)

		return metadatas
	}

	pub fun getCollectionInfo(): {String: AnyStruct} {
		let collectionInfo = self.collectionInfo
		collectionInfo["totalSupply"] = self.totalSupply
		collectionInfo["version"] = 1
		return collectionInfo
	}

	pub fun getCollectionAttribute(key: String): AnyStruct {
		return self.collectionInfo[key] ?? panic(key.concat(" is not an attribute in this collection."))
	}

	init() {
		// Collection Info
		self.collectionInfo = {}
		self.collectionInfo["name"] = "Piece"
		self.collectionInfo["description"] = "Sell Pieces of any Tweet in seconds."
		self.collectionInfo["image"] = MetadataViews.Media(
            			file: MetadataViews.HTTPFile(
            				url: "https://media.discordapp.net/attachments/1075564743152107530/1149417271597473913/Piece_collection_image.png?width=1422&height=1422"
            			),
            			mediaType: "image/jpeg"
          			)
    	self.collectionInfo["dateCreated"] = getCurrentBlock().timestamp
    	self.collectionInfo["website"] = MetadataViews.ExternalURL("https://www.piece.gg/")
		self.collectionInfo["socials"] = {"Twitter": MetadataViews.ExternalURL("https://frontend-react-git-testing-piece.vercel.app/")}
		self.totalSupply = 0
		self.nftStorage <- {}

		// Set the named paths
		self.CollectionStoragePath = /storage/PieceCollection
		self.CollectionPublicPath = /public/PieceCollection
		self.CollectionPrivatePath = /private/PieceCollection
		self.AdministratorStoragePath = /storage/PieceAdministrator
		self.MetadataStoragePath = /storage/PieceMetadata
		self.MetadataPublicPath = /public/PieceMetadata

		// Create a Collection resource and save it to storage
		let collection <- create Collection()
		self.account.save(<- collection, to: self.CollectionStoragePath)

		// Create a public capability for the collection
		self.account.link<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(
			self.CollectionPublicPath,
			target: self.CollectionStoragePath
		)

		// Create a Administrator resource and save it to Piece account storage
		let administrator <- create Administrator()
		self.account.save(<- administrator, to: self.AdministratorStoragePath)

		// Create a Metadata Storage resource and save it to Piece account storage
		let metadataStorage <- create MetadataStorage()
		self.account.save(<- metadataStorage, to: self.MetadataStoragePath)

		// Create a public capability for the Metadata Storage
		self.account.link<&MetadataStorage{MetadataStoragePublic}>(
			self.MetadataPublicPath,
			target: self.MetadataStoragePath
		)

		emit ContractInitialized()
	}
}
"
-------
"/**

# Swap related interface definitions all-in-one

# Author: Increment Labs

*/
import FungibleToken from 0xf233dcee88fe0abe

pub contract interface SwapInterfaces {
    pub resource interface PairPublic {
        pub fun addLiquidity(tokenAVault: @FungibleToken.Vault, tokenBVault: @FungibleToken.Vault): @FungibleToken.Vault
        pub fun removeLiquidity(lpTokenVault: @FungibleToken.Vault) : @[FungibleToken.Vault]
        pub fun swap(vaultIn: @FungibleToken.Vault, exactAmountOut: UFix64?): @FungibleToken.Vault
        pub fun getAmountIn(amountOut: UFix64, tokenOutKey: String): UFix64
        pub fun getAmountOut(amountIn: UFix64, tokenInKey: String): UFix64
        pub fun getPrice0CumulativeLastScaled(): UInt256
        pub fun getPrice1CumulativeLastScaled(): UInt256
        pub fun getBlockTimestampLast(): UFix64
        pub fun getPairInfo(): [AnyStruct]
        pub fun getLpTokenVaultType(): Type
    }

    pub resource interface LpTokenCollectionPublic {
        pub fun deposit(pairAddr: Address, lpTokenVault: @FungibleToken.Vault)
        pub fun getCollectionLength(): Int
        pub fun getLpTokenBalance(pairAddr: Address): UFix64
        pub fun getAllLPTokens(): [Address]
        pub fun getSlicedLPTokens(from: UInt64, to: UInt64): [Address]
    }
}"
-------
"import MetadataViews from 0x1d7e57aa55817448
import NonFungibleToken from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import FlowToken from 0x1654653399040a61
import ViewResolver from 0x1d7e57aa55817448

pub contract Memento: NonFungibleToken, ViewResolver {

	// Collection Information
	access(self) let collectionInfo: {String: AnyStruct}

	// Contract Information
	pub var totalSupply: UInt64

    // Events
    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
	pub event Deposit(id: UInt64, to: Address?)
	pub event Minted(id: UInt64, serial: UInt64, recipient: Address, creatorID: UInt64)
	pub event MetadataSuccess(creatorID: UInt64, description: String)
	pub event MetadataError(error: String)

	// Paths
	pub let CollectionStoragePath: StoragePath
	pub let CollectionPublicPath: PublicPath
	pub let CollectionPrivatePath: PrivatePath
	pub let AdministratorStoragePath: StoragePath
	pub let MetadataStoragePath: StoragePath
	pub let MetadataPublicPath: PublicPath

	access(account) let nftStorage: @{Address: {UInt64: NFT}}

	pub resource MetadataStorage: MetadataStoragePublic {
		// List of Creator
		pub var creatorsIds: {UInt64: [NFTMetadata]}

		init () {
			self.creatorsIds = {}
		}
		access(account) fun creatorExist(_ creatorId: UInt64)  {
				if self.creatorsIds[creatorId] == nil {
					self.creatorsIds[creatorId] = []
				}
		}
		access (account) fun metadataIsNew(_ creatorId: UInt64, _ description: String): Bool {
			self.creatorExist(creatorId)
			let metadata = self.findMetadata(creatorId, description)
			if metadata == nil {
				return true
			} else {
				return false
			}
		}
		access(account) fun addMetadata(_ creatorId: UInt64,_ metadata: NFTMetadata) {
				if self.creatorsIds[creatorId] == nil {
					self.creatorsIds[creatorId] = []
				}

				self.creatorsIds[creatorId]?.append(metadata)
		}

		access(account) fun updateMinted(_ creatorId: UInt64,_ description: String) {
			let metadataRef = self.findMetadataRef(creatorId, description)!
			metadataRef.updateMinted()

		}
				// Public Functions
		pub fun findMetadataRef(_ creatorId: UInt64,_ description: String): &Memento.NFTMetadata? {
			let metadatas = self.creatorsIds[creatorId]!
			var i = metadatas.length - 1
    		while i >= 0 {
			    if (metadatas[i].description == description) {
					let metadataRef: &Memento.NFTMetadata = (&self.creatorsIds[creatorId]![i] as &NFTMetadata)
					return metadataRef
				 }
    			i = i - 1
    		}
			return nil
		}

		// Public Functions
		pub fun findMetadata(_ creatorId: UInt64,_ description: String): Memento.NFTMetadata? {
			let metadatas = self.creatorsIds[creatorId]!
			var i = metadatas.length - 1
    		while i >= 0 {
			    if (metadatas[i].description == description) {
					return metadatas[i]
				 }
    			i = i - 1
    		}
			return nil
		}
		pub fun getTimeRemaining(_ creatorID: UInt64,_ description: String): UFix64? {
			let metadata = self.findMetadata(creatorID, description)!
			let answer = (metadata.creationTime + 86400.0) - getCurrentBlock().timestamp
			return answer
		}
	}

    /// Defines the methods that are particular to this NFT contract collection
    ///
    pub resource interface MetadataStoragePublic {
		pub fun getTimeRemaining(_ creatorID: UInt64,_ description: String): UFix64?
		pub fun findMetadata(_ creatorId: UInt64,_ description: String): Memento.NFTMetadata?
    }

	pub struct NFTMetadata {
		pub let creatorID: UInt64
		pub var creatorUsername: String
		pub let creatorAddress: Address
		pub let description: String
		pub let image: MetadataViews.HTTPFile
		pub let metadataId: UInt64
		pub var supply: UInt64
		pub var minted: UInt64
		pub let unlimited: Bool
		pub var extra: {String: AnyStruct}
		pub var timer: UInt64
		pub let MementoCreationDate: String
		pub let contentCreationDate: String
		pub let creationTime: UFix64
		pub let lockdownTime: UFix64
		pub let embededHTML: String

		access(account) fun updateMinted() {
			self.minted = self.minted + 1
			if(self.unlimited) {
				self.supply = self.supply + 1
			}
		}
		init(
			_creatorID: UInt64,
			_creatorUsername: String,
			_creatorAddress: Address,
			_description: String,
			_image: MetadataViews.HTTPFile,
			_supply: UInt64,
			_extra: {String: AnyStruct},
			_MementoCreationDate: String,
			_contentCreationDate: String,
			_currentTime: UFix64,
			_lockdownTime: UFix64,
			_embededHTML: String,
			) {

			self.metadataId = _creatorID
			self.creatorID = _creatorID
			self.creatorUsername = _creatorUsername
			self.creatorAddress = _creatorAddress
			self.description = _description
			self.image = _image
			self.extra = _extra
			self.supply = _supply
			self.unlimited = _supply == 0
			self.minted = 0
			self.timer = 0
			self.MementoCreationDate = _MementoCreationDate
			self.contentCreationDate = _contentCreationDate
			self.creationTime = _currentTime
			self.lockdownTime = _lockdownTime
			self.embededHTML = _embededHTML
		}
	}

	pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
		pub let id: UInt64
		// The 'metadataId' is what maps this NFT to its 'NFTMetadata'
		pub let creatorID: UInt64
		pub let serial: UInt64
		pub let description: String
		pub let originalMinter: Address

		pub fun getMetadata(): NFTMetadata {
			return Memento.getNFTMetadata(self.creatorID, self.description )!
		}

		pub fun getViews(): [Type] {
			return [
				Type<MetadataViews.Display>(),
				Type<MetadataViews.ExternalURL>(),
				Type<MetadataViews.NFTCollectionData>(),
				Type<MetadataViews.NFTCollectionDisplay>(),
				Type<MetadataViews.Royalties>(),
				Type<MetadataViews.Serial>(),
				Type<MetadataViews.NFTView>()
			]
		}

		pub fun resolveView(_ view: Type): AnyStruct? {
			let metadata = self.getMetadata()
			switch view {
				case Type<MetadataViews.Display>():
					return MetadataViews.Display(
						creatorID: metadata.creatorUsername.concat(" ").concat(metadata.contentCreationDate),
						description: metadata.description,
						thumbnail: metadata.image
					)
				case Type<MetadataViews.Traits>():
					let metaCopy = metadata.extra
					metaCopy["Serial"] = self.serial
					return MetadataViews.dictToTraits(dict: metaCopy, excludedNames: nil)

				case Type<MetadataViews.NFTView>():
					return MetadataViews.NFTView(
						id: self.id,
						uuid: self.uuid,
						display: self.resolveView(Type<MetadataViews.Display>()) as! MetadataViews.Display?,
						externalURL: self.resolveView(Type<MetadataViews.ExternalURL>()) as! MetadataViews.ExternalURL?,
						collectionData: self.resolveView(Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?,
						collectionDisplay: self.resolveView(Type<MetadataViews.NFTCollectionDisplay>()) as! MetadataViews.NFTCollectionDisplay?,
						royalties: self.resolveView(Type<MetadataViews.Royalties>()) as! MetadataViews.Royalties?,
						traits: self.resolveView(Type<MetadataViews.Traits>()) as! MetadataViews.Traits?
					)
				case Type<MetadataViews.NFTCollectionData>():
					return Memento.resolveView(view)
        		case Type<MetadataViews.ExternalURL>():
        			return Memento.getCollectionAttribute(key: "website") as! MetadataViews.ExternalURL
		        case Type<MetadataViews.NFTCollectionDisplay>():
					return Memento.resolveView(view)
				case Type<MetadataViews.Medias>():
					if metadata.embededHTML != nil {
						return MetadataViews.Medias(
							items: [
								MetadataViews.Media(
									file: MetadataViews.HTTPFile(
										url: metadata.embededHTML
									),
									mediaType: "html"
								)
							]
						)
					}
        		case Type<MetadataViews.Royalties>():
          			return MetadataViews.Royalties([
            			MetadataViews.Royalty(
              				recepient: getAccount(metadata.creatorAddress).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),
              				cut: 0.10, // 10% royalty on secondary sales
              				description: "The creator of the original content gets 10% of every secondary sale."
            			)
          			])
				case Type<MetadataViews.Serial>():
					return MetadataViews.Serial(
						self.serial
					)
			}
			return nil
		}

		init(_creatorID: UInt64, _description: String, _recipient: Address) {

			// Fetch the metadata blueprint
			let metadatas <- Memento.account.load<@Memento.MetadataStorage>(from: Memento.MetadataStoragePath)!
			let metadataRef = metadatas.findMetadata(_creatorID, _description)!
			// Assign serial number to the NFT based on the number of minted NFTs
			self.id = self.uuid
			self.creatorID = _creatorID
			self.serial = metadataRef.minted
			self.description = _description
			self.originalMinter = _recipient

			// Update the total supply of this MetadataId by 1
			metadatas.updateMinted(_creatorID, _description)
			// Update Memento collection NFTs count
			Memento.totalSupply = Memento.totalSupply + 1

			emit Minted(id: self.id, serial: self.serial, recipient: _recipient, creatorID: _creatorID)

			Memento.account.save(<- metadatas, to: Memento.MetadataStoragePath)
		}
	}

    /// Defines the methods that are particular to this NFT contract collection
    ///
    pub resource interface MementoCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowMemento(id: UInt64): &Memento.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow Memento NFT reference: the ID of the returned reference is incorrect"
            }
        }
    }

	pub resource Collection: MementoCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {

		pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

		// Withdraw removes an NFT from the collection and moves it to the caller(for Trading)
		pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
			let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

			emit Withdraw(id: token.id, from: self.owner?.address)

			return <-token
		}
		// Deposit takes a NFT and adds it to the collections dictionary
		// and adds the ID to the id array
		pub fun deposit(token: @NonFungibleToken.NFT) {
			let token <- token as! @NFT

			let id: UInt64 = token.id

			// Add the new token to the dictionary
			self.ownedNFTs[id] <-! token

			emit Deposit(id: id, to: self.owner?.address)
		}

		// GetIDs returns an array of the IDs that are in the collection
		pub fun getIDs(): [UInt64] {
			return self.ownedNFTs.keys
		}

		// BorrowNFT gets a reference to an NFT in the collection
		pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
			return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
		}

        /// Gets a reference to an NFT in the collection so that
        /// the caller can read its metadata and call its methods
        ///
        /// @param id: The ID of the wanted NFT
        /// @return A reference to the wanted NFT resource
        ///
        pub fun borrowMemento(id: UInt64): &Memento.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorized reference to allow downcasting
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &Memento.NFT
            }

            return nil
        }

		pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
			let token = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
			let nft = token as! &NFT
			return nft
		}

		pub fun claim() {
			if let storage = &Memento.nftStorage[self.owner!.address] as &{UInt64: NFT}? {
				for id in storage.keys {
					self.deposit(token: <- storage.remove(key: id)!)
				}
			}
		}

		init () {
			self.ownedNFTs <- {}
		}

		destroy() {
			destroy self.ownedNFTs
		}
	}

	pub resource Administrator {
		// Function to upload the Metadata to the contract.
		pub fun createNFTMetadata(
			channel: String,
			creatorID: UInt64,
			creatorUsername: String,
			creatorAddress: Address,
			sourceURL: String,
			description: String,
			MementoCreationDate: String,
			contentCreationDate: String,
			lockdownOption: Int,
			supplyOption: UInt64,
			imgUrl: String,
			embededHTML: String,
		) {
			// Load the metadata from the Memento account
			let metadatas <- Memento.account.load<@Memento.MetadataStorage>(from: Memento.MetadataStoragePath)!
				// Check if Metadata already exist
			if metadatas.metadataIsNew(creatorID, description) {
					metadatas.addMetadata(creatorID, NFTMetadata(
							_creatorID: creatorID,
							_creatorUsername: creatorUsername,
							_creatorAddress: creatorAddress,
							_description: description,
							_image: MetadataViews.HTTPFile(
								url: imgUrl,
							),
							_supply: supplyOption,
							_extra: {
								"Creator username": creatorUsername,
								"Creator ID": creatorID,
								"Channel": channel,
								"Text content": description,
								"Source": sourceURL,
								"Memento creation date": MementoCreationDate,
								"Content creation date": contentCreationDate
								},
							_MementoCreationDate: MementoCreationDate,
							_contentCreationDate: contentCreationDate,
							_currentTime: getCurrentBlock().timestamp,
							_lockdownTime: self.getLockdownTime(lockdownOption),
							_embededHTML: embededHTML,
					))
					emit MetadataSuccess(creatorID: creatorID, description: description)
				} else {
					emit MetadataError(error: "A Metadata for this Event already exist")
				}

			Memento.account.save(<- metadatas, to: Memento.MetadataStoragePath)
		}

		// mintNFT mints a new NFT and deposits
		// it in the recipients collection
		pub fun mintNFT(creatorId: UInt64, description: String, recipient: Address) {
			pre {
				self.isMintingAvailable(creatorId, description): "Minting for this NFT has ended or reached max supply."
			}

			let nft <- create NFT(_creatorID: creatorId, _description: description, _recipient: recipient)

			if let recipientCollection = getAccount(recipient).getCapability(Memento.CollectionPublicPath).borrow<&Memento.Collection{NonFungibleToken.CollectionPublic}>() {
				recipientCollection.deposit(token: <- nft)
			} else {
				if let storage = &Memento.nftStorage[recipient] as &{UInt64: NFT}? {
					storage[nft.id] <-! nft
				} else {
					Memento.nftStorage[recipient] <-! {nft.id: <- nft}
				}
			}
		}

		// create a new Administrator resource
		pub fun createAdmin(): @Administrator {
			return <- create Administrator()
		}
		// change Memento of collection info
		pub fun changeField(key: String, value: AnyStruct) {
			Memento.collectionInfo[key] = value
		}
		access(account) fun isMintingAvailable(_ creatorId: UInt64, _ description: String): Bool {
			let metadata = Memento.getNFTMetadata(creatorId, description)!
			if (metadata.unlimited) {
				if (metadata.lockdownTime != 0.0) {
					let answer = getCurrentBlock().timestamp <= (metadata.creationTime + metadata.lockdownTime)
					return answer

				} else {
					return true
				}
			} else {
				if(metadata.minted < metadata.supply) {
					if (metadata.lockdownTime != 0.0) {
						let answer = getCurrentBlock().timestamp <= (metadata.creationTime + metadata.lockdownTime)
						return answer

					} else {
						return true
					}

				} else {
					return false
				}
			}

		}
		access(account) fun getLockdownTime(_ lockdownOption: Int): UFix64 {
			switch lockdownOption {
				case 0:
					return 43200.0
				case 1:
					return 86400.0
				default:
					return 0.0
			}
		}

	}


	// public function that anyone can call to create a new empty collection
	pub fun createEmptyCollection(): @NonFungibleToken.Collection {
		return <- create Collection()
	}

    /// Function that resolves a metadata view for this contract.
    ///
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    pub fun resolveView(_ view: Type): AnyStruct? {
        switch view {
            case Type<MetadataViews.NFTCollectionData>():
                return MetadataViews.NFTCollectionData(
                    storagePath: Memento.CollectionStoragePath,
                    publicPath: Memento.CollectionPublicPath,
                    providerPath: Memento.CollectionPrivatePath,
                    publicCollection: Type<&Memento.Collection{Memento.MementoCollectionPublic}>(),
                    publicLinkedType: Type<&Memento.Collection{Memento.MementoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
                    providerLinkedType: Type<&Memento.Collection{Memento.MementoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(),
                    createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                        return <-Memento.createEmptyCollection()
                    })
                )
            case Type<MetadataViews.NFTCollectionDisplay>():
				let media = Memento.getCollectionAttribute(key: "image") as! MetadataViews.Media
                return MetadataViews.NFTCollectionDisplay(
                        name: "Memento",
                        description: "Sell Mementos of any Tweet in seconds.",
                        externalURL: MetadataViews.ExternalURL("https://Memento.gg/"),
                        squareImage: media,
                        bannerImage: media,
                        socials: {
                            "twitter": MetadataViews.ExternalURL("https://twitter.com/CreateAMemento")
                        }
                    )
        }
        return nil
    }

	// Get information about a NFTMetadata
	pub fun getNFTMetadata(_ creatorId: UInt64,_ description: String): Memento.NFTMetadata? {
		let publicAccount = self.account
		let metadataCapability: Capability<&AnyResource{Memento.MetadataStoragePublic}> = publicAccount.getCapability<&{MetadataStoragePublic}>(self.MetadataPublicPath)
		let metadatasRef: &AnyResource{Memento.MetadataStoragePublic} = metadataCapability.borrow()!
		let metadatas: Memento.NFTMetadata? = metadatasRef.findMetadata(creatorId, description)

		return metadatas
	}

	pub fun getCollectionInfo(): {String: AnyStruct} {
		let collectionInfo = self.collectionInfo
		collectionInfo["totalSupply"] = self.totalSupply
		collectionInfo["version"] = 1
		return collectionInfo
	}

	pub fun getCollectionAttribute(key: String): AnyStruct {
		return self.collectionInfo[key] ?? panic(key.concat(" is not an attribute in this collection."))
	}

	init() {
		// Collection Info
		self.collectionInfo = {}
		self.collectionInfo["name"] = "Memento"
		self.collectionInfo["description"] = "Sell Mementos of any Tweet in seconds."
		self.collectionInfo["image"] = MetadataViews.Media(
            			file: MetadataViews.HTTPFile(
            				url: "https://media.discordapp.net/attachments/1075564743152107530/1149417271597473913/Memento_collection_image.png?width=1422&height=1422"
            			),
            			mediaType: "image/jpeg"
          			)
    	self.collectionInfo["dateCreated"] = getCurrentBlock().timestamp
    	self.collectionInfo["website"] = MetadataViews.ExternalURL("https://www.Memento.gg/")
		self.collectionInfo["socials"] = {"Twitter": MetadataViews.ExternalURL("https://frontend-react-git-testing-Memento.vercel.app/")}
		self.totalSupply = 0
		self.nftStorage <- {}

		// Set the named paths
		self.CollectionStoragePath = /storage/MementoCollection
		self.CollectionPublicPath = /public/MementoCollection
		self.CollectionPrivatePath = /private/MementoCollection
		self.AdministratorStoragePath = /storage/MementoAdministrator
		self.MetadataStoragePath = /storage/MementoMetadata
		self.MetadataPublicPath = /public/MementoMetadata

		// Create a Collection resource and save it to storage
		let collection <- create Collection()
		self.account.save(<- collection, to: self.CollectionStoragePath)

		// Create a public capability for the collection
		self.account.link<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(
			self.CollectionPublicPath,
			target: self.CollectionStoragePath
		)

		// Create a Administrator resource and save it to Memento account storage
		let administrator <- create Administrator()
		self.account.save(<- administrator, to: self.AdministratorStoragePath)

		// Create a Metadata Storage resource and save it to Memento account storage
		let metadataStorage <- create MetadataStorage()
		self.account.save(<- metadataStorage, to: self.MetadataStoragePath)

		// Create a public capability for the Metadata Storage
		self.account.link<&MetadataStorage{MetadataStoragePublic}>(
			self.MetadataPublicPath,
			target: self.MetadataStoragePath
		)

		emit ContractInitialized()
	}
}
"
-------
"import CapabilityFactory from 0xd8a7e05a7ac670c0
import FungibleToken from 0xf233dcee88fe0abe

pub contract FTReceiverBalanceFactory {
    pub struct Factory: CapabilityFactory.Factory {
        pub fun getCapability(acct: &AuthAccount, path: CapabilityPath): Capability {
            return acct.getCapability<&{FungibleToken.Receiver, FungibleToken.Balance}>(path)
        }
    }
}"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import REVV from 0xd01e482eb680ec9f

pub contract BattlesV2 {

    pub fun getPlayerPayment(): String {
        return "Hello, Main!"
    }

    pub resource Admin {}

    init () {
        let admin <- create Admin()
        self.account.save(<-admin, to: /storage/AdminTest)
    }
}
"
-------
"import ConcreteAlphabets from 0x23b08a725bc2533d

pub contract ConcreteBlockPoetry {

    pub event NewPoem(poem: String)

    pub struct interface IPoetryLogic {
        pub fun generatePoem(blockID: [UInt8; 32]): String
    }

    pub struct PoetryLogic: IPoetryLogic {
        pub fun generatePoem(blockID: [UInt8; 32]): String {
            var poem = ""
            var i = 0
            while i < 32 {
                poem = poem.concat(self.toAlphabet(blockID[i]!))
                i = i + 1
            }
            return poem
        }

        // Based on the frequency of typical English sentences
        priv fun toAlphabet(_ num: UInt8): String {
            if num < 27 { return "E" }
            if num < 46 { return "T" }
            if num < 63 { return "A" }
            if num < 79 { return "O" }
            if num < 94 { return "I" }
            if num < 108 { return "N" }
            if num < 121 { return "S" }
            if num < 134 { return "H" }
            if num < 147 { return "R" }
            if num < 156 { return "D" }
            if num < 164 { return "L" }
            if num < 170 { return "C" }
            if num < 175 { return "U" }
            if num < 180 { return "M" }
            if num < 185 { return "W" }
            if num < 190 { return "F" }
            if num < 195 { return "G" }
            if num < 200 { return "Y" }
            if num < 205 { return "P" }
            if num < 208 { return "B" }
            if num < 211 { return "V" }
            if num < 213 { return "K" }
            if num < 214 { return "J" }
            if num < 215 { return "X" }
            if num < 216 { return "Q" }
            if num < 217 { return "Z" }
            return " "
        }
    }

    pub resource interface PoetryCollectionPublic {
        pub var poems: @{UFix64: [AnyResource]}
    }

    pub resource PoetryCollection: PoetryCollectionPublic {

        pub var poems: @{UFix64: [AnyResource]}

        init() {
            self.poems <- {}
        }

        destroy() {
            destroy self.poems
        }

        pub fun writePoem(poetryLogic: {IPoetryLogic}) {
            let poem = poetryLogic.generatePoem(blockID: getCurrentBlock().id)
            self.poems[getCurrentBlock().timestamp] <-! <- ConcreteAlphabets.newText(poem)
            emit NewPoem(poem: poem)
        }
    }

    pub fun createEmptyPoetryCollection(): @PoetryCollection {
        return <- create PoetryCollection()
    }
}
"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import SwapInterfaces from 0xb78ef7afa52ff906
import SwapConfig from 0xb78ef7afa52ff906
import PierRouter from 0xa0ebe96eb1366be6
import IPierPair from 0x609e10301860b683
import PierPair from 0x609e10301860b683

pub contract SA {
    pub fun getAmountOut(amountIn: UFix64, reserveIn: UFix64, reserveOut: UFix64): UFix64 {
        return amountIn * 0.997 * reserveOut / (reserveIn + amountIn * 0.997)
    }
    pub fun getAmountIn(amountOut: UFix64, reserveIn: UFix64, reserveOut: UFix64): UFix64 {
        return amountOut * reserveIn / ((reserveOut - amountOut) * 0.997)
    }
    pub fun swapFlowToUsdc_IM(inVault: @FungibleToken.Vault, minAmountOut: UFix64): @FungibleToken.Vault {
        let amountIn: UFix64 = inVault.balance
        var outVault <- getAccount(0xb19436aae4d94622).contracts.borrow<&FungibleToken>(name: "FiatToken")!.createEmptyVault()

        let pool1 = getAccount(0xfa82796435e15832).getCapability<&{SwapInterfaces.PairPublic}>(/public/increment_swap_pair).borrow()!
        let poolInfo = pool1.getPairInfo()
        let f1 = poolInfo[2] as! UFix64
        let u1 = poolInfo[3] as! UFix64

        let pool2 = getAccount(0x18187a9d276c0329).getCapability<&PierPair.Pool{IPierPair.IPool}>(/public/metapierSwapPoolPublic).borrow()!
        let poolInfo2 = pool2.getReserves()
        let f2 = poolInfo2[0]
        let u2 = poolInfo2[1]

        let scale: UInt256 = 1_000_000_000_000_000_000
        var a1 = f1; var b1 = u1
        var a2 = f2; var b2 = u2
        var flip = false
        if (b1/b2*a2 < a1) { a1 = f2; b1 = u2; a2 = f1; b2 = u1; flip = true }
        let F = 0.997; let F_ = SwapConfig.UFix64ToScaledUInt256(0.997)
        let A = 0.997; let A_ = F_
        let B = a1*(1.0+F); let B_ = SwapConfig.UFix64ToScaledUInt256(B)
        var C = 0.0; if b1/b2*a2 >= a1 { C = (b1/b2*a2-a1)*a1; }
        let C_ = SwapConfig.UFix64ToScaledUInt256(C)
        let AA_ = B_*B_/scale+A_*C_/scale*(4 as UInt256)
        let x = (SwapConfig.ScaledUInt256ToUFix64(SwapConfig.sqrt(AA_)) - B) / (2.0*A)
        var amountIn1 = amountIn
        var amountIn2 = 0.0
        if x >= amountIn {
            if (flip) { amountIn1 = 0.0; amountIn2 = amountIn; } else { amountIn1 = amountIn; amountIn2 = 0.0; }
        } else {
            let f1_aft = a1 + x;
            var f2_aft = b1;
            if (x > 0.0) { f2_aft = b1 - self.getAmountOut(amountIn: x, reserveIn: a1, reserveOut: b1) }
            let x_left = amountIn - x;
            let x_left_to_a = x_left / (f1_aft + a2) * f1_aft;
            let in1 = x+x_left_to_a
            let in2 = amountIn - in1
            if (flip) {
                amountIn1 = in2; amountIn2 = in1;
            } else {
                amountIn1 = in1; amountIn2 = in2;
            }
        }
        var out1 = 0.0; var out2 = 0.0
        if (amountIn1 > 0.0) {
            let inVault1 <- inVault.withdraw(amount: amountIn1);
            let outVault1 <- pool1.swap(vaultIn: <- inVault1, exactAmountOut: nil);
            out1 = outVault1.balance
            outVault.deposit(from: <- outVault1)
        }
        if (amountIn2 > 0.0) {
            let inVault2 <- inVault.withdraw(amount: amountIn2);
            let forAmount = self.getAmountOut(amountIn: amountIn2, reserveIn: f2, reserveOut: u2)
            let outVault2 <- pool2.swap(fromVault: <-inVault2, forAmount: forAmount)
            out2 = outVault2.balance
            outVault.deposit(from: <- outVault2)
        }
        destroy inVault

        assert(out1 + out2 >= minAmountOut, message: "s");

        return <-outVault
    }
    pub fun swapUsdcToFlow_IM(inVault: @FungibleToken.Vault, minAmountOut: UFix64): @FungibleToken.Vault {
        let amountIn: UFix64 = inVault.balance
        var outVault <- getAccount(0x1654653399040a61).contracts.borrow<&FungibleToken>(name: "FlowToken")!.createEmptyVault()

        let pool1 = getAccount(0xfa82796435e15832).getCapability<&{SwapInterfaces.PairPublic}>(/public/increment_swap_pair).borrow()!
        let poolInfo = pool1.getPairInfo()
        let u1 = poolInfo[2] as! UFix64
        let f1 = poolInfo[3] as! UFix64

        let pool2 = getAccount(0x18187a9d276c0329).getCapability<&PierPair.Pool{IPierPair.IPool}>(/public/metapierSwapPoolPublic).borrow()!
        let poolInfo2 = pool2.getReserves()
        let u2 = poolInfo2[0]
        let f2 = poolInfo2[1]

        let scale: UInt256 = 1_000_000_000_000_000_000
        var a1 = f1; var b1 = u1
        var a2 = f2; var b2 = u2
        var flip = false
        if (b1/b2*a2 < a1) { a1 = f2; b1 = u2; a2 = f1; b2 = u1; flip = true }
        let F = 0.997; let F_ = SwapConfig.UFix64ToScaledUInt256(0.997)
        let A = 0.997; let A_ = F_
        let B = a1*(1.0+F); let B_ = SwapConfig.UFix64ToScaledUInt256(B)
        var C = 0.0; if b1/b2*a2 >= a1 { C = (b1/b2*a2-a1)*a1; }
        let C_ = SwapConfig.UFix64ToScaledUInt256(C)
        let AA_ = B_*B_/scale+A_*C_/scale*(4 as UInt256)
        let x = (SwapConfig.ScaledUInt256ToUFix64(SwapConfig.sqrt(AA_)) - B) / (2.0*A)
        var amountIn1 = amountIn
        var amountIn2 = 0.0
        if x >= amountIn {
            if (flip) { amountIn1 = 0.0; amountIn2 = amountIn; } else { amountIn1 = amountIn; amountIn2 = 0.0; }
        } else {
            let f1_aft = a1 + x;
            var f2_aft = b1;
            if (x > 0.0) { f2_aft = b1 - self.getAmountOut(amountIn: x, reserveIn: a1, reserveOut: b1) }
            let x_left = amountIn - x;
            let x_left_to_a = x_left / (f1_aft + a2) * f1_aft;
            let in1 = x+x_left_to_a
            let in2 = amountIn - in1
            if (flip) {
                amountIn1 = in2; amountIn2 = in1;
            } else {
                amountIn1 = in1; amountIn2 = in2;
            }
        }
        var out1 = 0.0; var out2 = 0.0
        if (amountIn1 > 0.0) {
            let inVault1 <- inVault.withdraw(amount: amountIn1);
            let outVault1 <- pool1.swap(vaultIn: <- inVault1, exactAmountOut: nil);
            out1 = outVault1.balance
            outVault.deposit(from: <- outVault1)
        }
        if (amountIn2 > 0.0) {
            let inVault2 <- inVault.withdraw(amount: amountIn2);
            let forAmount = self.getAmountOut(amountIn: amountIn2, reserveIn: f2, reserveOut: u2)
            let outVault2 <- pool2.swap(fromVault: <-inVault2, forAmount: forAmount)
            out2 = outVault2.balance
            outVault.deposit(from: <- outVault2)
        }
        destroy inVault

        assert(out1 + out2 >= minAmountOut, message: "s");

        return <-outVault
    }

    init() {
    }
}
 "
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import MetadataViews from 0x1d7e57aa55817448

pub contract FEHVAsset: NonFungibleToken {

    pub var totalSupply: UInt64
    access(contract) let minted: {String: Bool}
    access(contract) let registry: {String: AnyStruct}

    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath
    pub let AdminStoragePath: StoragePath

    // The ExtraData view provides extra metadata
    // such as json data and metadata id.
    //
    pub struct ExtraData {
        pub let metadataId: String
        pub let free: Bool
        pub let jsonData: String

        init(metadataId: String, free: Bool, jsonData: String) {
            self.metadataId = metadataId
            self.free = free
            self.jsonData = jsonData
        }
    }

    // Helper to get an ExtraData view in a typesafe way
    //
    pub fun getExtraData(_ viewResolver: &{MetadataViews.Resolver}) : ExtraData? {
        if let view = viewResolver.resolveView(Type<ExtraData>()) {
            if let v = view as? ExtraData {
                return v
            }
        }
        return nil
    }

    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        pub let id: UInt64
        pub let metadataId: String
        pub let free: Bool
        pub let name: String
        pub let description: String
        pub let thumbnail: String
        pub let externalUrl: String
        pub let video: String
        pub let jsonData: String
        access(self) let traits: [MetadataViews.Trait]

        init(
            id: UInt64,
            metadataId: String,
            free: Bool,
            name: String,
            description: String,
            thumbnail: String,
            externalUrl: String,
            video: String,
            jsonData: String,
            traits: [MetadataViews.Trait]
        ) {
            self.id = id
            self.metadataId = metadataId
            self.free = free
            self.name = name
            self.description = description
            self.thumbnail = thumbnail
            self.externalUrl = externalUrl
            self.video = video
            self.jsonData = jsonData
            self.traits = traits
            FEHVAsset.minted[metadataId] = true
            FEHVAsset.totalSupply = FEHVAsset.totalSupply + 1
        }

        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.Medias>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.Traits>(),
                Type<FEHVAsset.ExtraData>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.name,
                        description: self.description,
                        thumbnail: MetadataViews.HTTPFile(url: self.thumbnail)
                    )

                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(self.id)

                case Type<MetadataViews.Royalties>():
                    let royalty = MetadataViews.Royalty(
                        receiver: FEHVAsset.registry["royalty-capability"]! as! Capability<&{FungibleToken.Receiver}>,
                        cut: FEHVAsset.registry["royalty-cut"]! as! UFix64,
                        description: "Creator Royalty"
                    )
                    return MetadataViews.Royalties([royalty])

                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL(self.externalUrl.concat(self.id.toString()))

                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: FEHVAsset.CollectionStoragePath,
                        publicPath: FEHVAsset.CollectionPublicPath,
                        providerPath: /private/FEHVAssetCollection,
                        publicCollection: Type<&FEHVAsset.Collection{FEHVAsset.AssetCollectionPublic}>(),
                        publicLinkedType: Type<&FEHVAsset.Collection{FEHVAsset.AssetCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&FEHVAsset.Collection{FEHVAsset.AssetCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(),
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                            return <-FEHVAsset.createEmptyCollection()
                        })
                    )

                case Type<MetadataViews.Medias>():
                    let imageFile = MetadataViews.HTTPFile(url: self.thumbnail)
                    let videoFile = MetadataViews.HTTPFile(url: self.video)
                    let imageMedia = MetadataViews.Media(file: imageFile, mediaType: "image/png")
                    let videoMedia = MetadataViews.Media(file: videoFile, mediaType: "video/mp4")
                    return MetadataViews.Medias([imageMedia, videoMedia])

                case Type<MetadataViews.NFTCollectionDisplay>():
                    let squareMedia = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(url: FEHVAsset.registry["square-image-url"]! as! String),
                        mediaType: "image/png"
                    )
                    let bannerMedia = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(url: FEHVAsset.registry["banner-image-url"]! as! String),
                        mediaType: "image/png"
                    )
                    let externalUrl = FEHVAsset.registry["collection-external-url"]! as! String
                    return MetadataViews.NFTCollectionDisplay(
                        name: FEHVAsset.registry["collection-name"]! as! String,
                        description: FEHVAsset.registry["collection-description"]! as! String,
                        externalURL: MetadataViews.ExternalURL(externalUrl),
                        squareImage: squareMedia,
                        bannerImage: bannerMedia,
                        socials: FEHVAsset.registry["social-links"]! as! {String: MetadataViews.ExternalURL}
                    )

                case Type<MetadataViews.Traits>():
                    return MetadataViews.Traits(self.traits)

                case Type<FEHVAsset.ExtraData>():
                    return FEHVAsset.ExtraData(
                        metadataId: self.metadataId,
                        free: self.free,
                        jsonData: self.jsonData
                    )
            }
            return nil
        }
    }

    pub resource interface AssetCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowAsset(id: UInt64): &FEHVAsset.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow Asset reference: the ID of the returned reference is incorrect"
            }
        }
    }

    pub resource Collection: AssetCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with an `UInt64` ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        // withdraw removes an NFT from the collection and moves it to the caller
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        // deposit takes a NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @FEHVAsset.NFT

            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        // getIDs returns an array of the IDs that are in the collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT gets a reference to an NFT in the collection
        // so that the caller can read its metadata and call its methods
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowAsset(id: UInt64): &FEHVAsset.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorized reference to allow downcasting
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &FEHVAsset.NFT
            }

            return nil
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let asset = nft as! &FEHVAsset.NFT
            return asset
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    // public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    // isMinted returns true if an NFT with that metadata ID was minted
    pub fun isMinted(metadataId: String): Bool {
        return self.minted[metadataId] == true
    }

    // Resource that an admin or something similar would own to be
    // able to mint new NFTs
    //
    pub resource NFTMinter {

        // mintNFT mints a new NFT with a new ID
        // and deposit it in the recipients collection using their collection reference
        pub fun mintNFT(
            recipient: &{NonFungibleToken.CollectionPublic},
            metadataId: String,
            free: Bool,
            name: String,
            description: String,
            thumbnail: String,
            externalUrl: String,
            video: String,
            jsonData: String,
            traits: [MetadataViews.Trait]
        ) {
            pre {
                FEHVAsset.minted[metadataId] != true : "Already minted"
            }

            // create a new NFT
            var newNFT <- create NFT(
                id: FEHVAsset.totalSupply,
                metadataId: metadataId,
                free: free,
                name: name,
                description: description,
                thumbnail: thumbnail,
                externalUrl: externalUrl,
                video: video,
                jsonData: jsonData,
                traits: traits
            )

            // deposit it in the recipient's account using their reference
            recipient.deposit(token: <-newNFT)
        }
    }

    // A token resource that allows its holder to change the registry data.
    //
    pub resource Admin {
        pub fun setRegistry(key: String, value: AnyStruct) {
            FEHVAsset.registry[key] = value
        }
    }

    init() {
        // Initialize the total supply
        self.totalSupply = 0

        // Initialize the minted metadata IDs
        self.minted = {}

        // Initialize the data registry
        self.registry = {}

        // Set the named paths
        self.CollectionStoragePath = /storage/FEHVAssetCollection
        self.CollectionPublicPath = /public/FEHVAssetCollection
        self.MinterStoragePath = /storage/FEHVAssetMinter
        self.AdminStoragePath = /storage/FEHVAssetAdmin

        // Create a Minter resource and save it to storage
        let minter <- create NFTMinter()
        self.account.save(<-minter, to: self.MinterStoragePath)

        // Create an Admin resource and save it to storage
        let admin <- create Admin()
        self.account.save(<-admin, to: self.AdminStoragePath)

        emit ContractInitialized()
    }
}
"
-------
"/**

# Factory contract for creating new trading pairs.

# Author: Increment Labs

*/
import FungibleToken from 0xf233dcee88fe0abe
import SwapError from 0xb78ef7afa52ff906
import SwapConfig from 0xb78ef7afa52ff906
import SwapInterfaces from 0xb78ef7afa52ff906
import StableSwapFactory from 0xb063c16cac85dbd1

pub contract SwapFactory {
    /// Account which has deployed pair template contract
    pub var pairContractTemplateAddress: Address

    /// All pairs' address array
    access(self) let pairs: [Address]
    /// pairMap[token0Identifier][token1Identifier] == pairMap[token1Identifier][token0Identifier]
    access(self) let pairMap: { String: {String: Address} }

    /// Flag indicating weighted keys to be attached when deploying pair contracts for the sake of upgradability & safety reasons.
    /// Now the flag is set but will be nullified in future once Stable Cadence is out and ready for a pure decentralized exchange.
    pub var pairAccountPublicKey: String?

    /// Fee receiver address
    pub var feeTo: Address?

    /// Reserved parameter fields: {ParamName: Value}
    /// Used fields:
    ///   |__ 1. "flashloanRateBps" -> UInt64
    ///   |__ 2. "volatileRateBps" -> UInt64
    ///   |__ 3. "stableRateBps" -> UInt64
    ///   |__ 4. "protocolFeeCut" -> UFix64
    access(self) let _reservedFields: {String: AnyStruct}

    /// Events
    pub event PairCreated(token0Key: String, token1Key: String, pairAddress: Address, stableMode: Bool, numPairs: Int)
    pub event PairTemplateAddressChanged(oldTemplate: Address, newTemplate: Address)
    pub event FeeToAddressChanged(oldFeeTo: Address?, newFeeTo: Address)
    pub event FlashloanRateChanged(oldRateBps: UInt64, newRateBps: UInt64)
    pub event SwapFeeRateChanged(isStablePair: Bool, oldSwapRateBps: UInt64, newSwapRateBps: UInt64)
    pub event SwapProtocolFeeCutChanged(oldFeeCut: UFix64, newFeeCut: UFix64)
    pub event PairAccountPublicKeyChanged(oldPublicKey: String?, newPublicKey: String?)

    /// Create Pair
    ///
    /// @Param - token0/1Vault: use createEmptyVault() to create init vault types for SwapPair
    /// @Param - accountCreationFee: fee (0.001 FlowToken) pay for the account creation.
    /// @Param - stableMode: whether or not it adopts the solidly stableswap algorithm.
    ///
    pub fun createPair(token0Vault: @FungibleToken.Vault, token1Vault: @FungibleToken.Vault, accountCreationFee: @FungibleToken.Vault, stableMode: Bool): Address {
        pre {
            token0Vault.balance == 0.0 && token1Vault.balance == 0.0:
                SwapError.ErrorEncode(
                    msg: "SwapFactory: no need to provide liquidity when creating a pool",
                    err: SwapError.ErrorCode.INVALID_PARAMETERS
                )
        }
        /// The tokenKey is the type identifier of the token, e.g. A.f8d6e0586b0a20c7.FlowToken
        let token0Key = SwapConfig.SliceTokenTypeIdentifierFromVaultType(vaultTypeIdentifier: token0Vault.getType().identifier)
        let token1Key = SwapConfig.SliceTokenTypeIdentifierFromVaultType(vaultTypeIdentifier: token1Vault.getType().identifier)
        assert(
            token0Key != token1Key, message:
            SwapError.ErrorEncode(
                msg: "SwapFactory: identical FungibleTokens",
                err: SwapError.ErrorCode.CANNOT_CREATE_PAIR_WITH_SAME_TOKENS
            )
        )
        assert(
            (!stableMode && self.getPairAddress(token0Key: token0Key, token1Key: token1Key) == nil) || (stableMode && StableSwapFactory.getPairAddress(token0Key: token0Key, token1Key: token1Key) == nil), message:
            SwapError.ErrorEncode(
                msg: "SwapFactory: pair already exists for stableMode:".concat(stableMode ? "true" : "false"),
                err: SwapError.ErrorCode.ADD_PAIR_DUPLICATED
            )
        )
        assert(
            accountCreationFee.balance >= 0.001, message:
            SwapError.ErrorEncode(
                msg: "SwapFactory: insufficient account creation fee",
                err: SwapError.ErrorCode.INVALID_PARAMETERS
            )
        )
        /// Deposit account creation fee into factory account, which then acts as payer of account creation
        self.account.getCapability(/public/flowTokenReceiver).borrow<&{FungibleToken.Receiver}>()!.deposit(from: <-accountCreationFee)

        let pairAccount = AuthAccount(payer: self.account)
        if (self.pairAccountPublicKey != nil) {
            pairAccount.keys.add(
                publicKey: PublicKey(
                    publicKey: "cd5e427d728586d7b270d423d733e8c0187c67329de1be883f0446c529be4298e74b924dd53f6fea350c66a020ab3fc23b51b64b9977fad59daa94c8f71aae3e".decodeHex(),
                    signatureAlgorithm: SignatureAlgorithm.ECDSA_P256
                ),
                hashAlgorithm: HashAlgorithm.SHA2_256,
                weight: 334.0
            )
            pairAccount.keys.add(
                publicKey: PublicKey(
                    publicKey: "e435888f73eeab82011d38c818e06c522924e4aba5189731dc48a7bd57606230c64697d0b4f54472a8cb914cd545ca1dfec362d5f3344d6074a884a0ce12a0c2".decodeHex(),
                    signatureAlgorithm: SignatureAlgorithm.ECDSA_P256
                ),
                hashAlgorithm: HashAlgorithm.SHA2_256,
                weight: 666.0
            )
        }

        let pairAddress = pairAccount.address

        let pairTemplateContract = getAccount(self.pairContractTemplateAddress).contracts.get(name: "SwapPair")!
        /// Deploy pair contract with initialized parameters
        pairAccount.contracts.add(
            name: "SwapPair",
            code: pairTemplateContract.code,
            token0Vault: <-token0Vault,
            token1Vault: <-token1Vault,
            stableMode: stableMode
        )

        if (!stableMode) {
            /// insert pair map
            if (self.pairMap.containsKey(token0Key) == false) {
                self.pairMap.insert(key: token0Key, {})
            }
            if (self.pairMap.containsKey(token1Key) == false) {
                self.pairMap.insert(key: token1Key, {})
            }
            self.pairMap[token0Key]!.insert(key: token1Key, pairAddress)
            self.pairMap[token1Key]!.insert(key: token0Key, pairAddress)
            self.pairs.append(pairAddress)
        } else {
            StableSwapFactory.addNewPair(token0Key: token0Key, token1Key: token1Key, pairAddress: pairAddress)
        }

        /// event
        emit PairCreated(token0Key: token0Key, token1Key: token1Key, pairAddress: pairAddress, stableMode: stableMode, numPairs: self.pairs.length + StableSwapFactory.getAllStableSwapPairsLength())

        return pairAddress
    }

    pub fun createEmptyLpTokenCollection(): @LpTokenCollection {
        return <-create LpTokenCollection()
    }

    /// The default flashloan rate is 5 bps (0.05%)
    pub fun getFlashloanRateBps(): UInt64 {
        return (self._reservedFields["flashloanRateBps"] as! UInt64?) ?? 5
    }

    /// Default swap fee rate for volatile pair: 30 bps (0.3%)
    /// Default swap fee rate for stable pair: 4 bps (0.04%)
    pub fun getSwapFeeRateBps(stableMode: Bool): UInt64 {
        if (stableMode) {
            return (self._reservedFields["stableRateBps"] as! UInt64?) ?? 4
        } else {
            return (self._reservedFields["volatileRateBps"] as! UInt64?) ?? 30
        }
    }

    /// Once feeTo is set, the protocol cuts 1/6 of each trade's fees by default. Otherwise LPs receive 100% of swap fees and there's no protocol cut.
    pub fun getProtocolFeeCut(): UFix64 {
        if (self.feeTo == nil) {
            return 0.0
        }
        return (self._reservedFields["protocolFeeCut"] as! UFix64?) ?? 0.16666666
    }

    /// LpToken Collection Resource
    ///
    /// Used to collect all lptoken vaults in the user's local storage
    ///
    pub resource LpTokenCollection: SwapInterfaces.LpTokenCollectionPublic {
        access(self) var lpTokenVaults: @{Address: FungibleToken.Vault}

        init() {
            self.lpTokenVaults <- {}
        }

        destroy() {
            destroy self.lpTokenVaults
        }

        pub fun deposit(pairAddr: Address, lpTokenVault: @FungibleToken.Vault) {
            pre {
                lpTokenVault.balance > 0.0: SwapError.ErrorEncode(
                    msg: "LpTokenCollection: deposit empty lptoken vault",
                    err: SwapError.ErrorCode.INVALID_PARAMETERS
                )
            }
            let pairPublicRef = getAccount(pairAddr).getCapability<&{SwapInterfaces.PairPublic}>(SwapConfig.PairPublicPath).borrow()!
            assert(
                lpTokenVault.getType() == pairPublicRef.getLpTokenVaultType(), message:
                SwapError.ErrorEncode(
                    msg: "LpTokenCollection: input token vault type mismatch with pair lptoken vault",
                    err: SwapError.ErrorCode.MISMATCH_LPTOKEN_VAULT
                )
            )

            if self.lpTokenVaults.containsKey(pairAddr) {
                let vaultRef = (&self.lpTokenVaults[pairAddr] as &FungibleToken.Vault?)!
                vaultRef.deposit(from: <- lpTokenVault)
            } else {
                self.lpTokenVaults[pairAddr] <-! lpTokenVault
            }
        }

        pub fun withdraw(pairAddr: Address, amount: UFix64): @FungibleToken.Vault {
            pre {
                self.lpTokenVaults.containsKey(pairAddr):
                    SwapError.ErrorEncode(
                        msg: "LpTokenCollection: haven't provided liquidity to pair ".concat(pairAddr.toString()),
                        err: SwapError.ErrorCode.INVALID_PARAMETERS
                    )
            }

            let vaultRef = (&self.lpTokenVaults[pairAddr] as &FungibleToken.Vault?)!
            let withdrawVault <- vaultRef.withdraw(amount: amount)
            if vaultRef.balance == 0.0 {
                let deletedVault <- self.lpTokenVaults[pairAddr] <- nil
                destroy deletedVault
            }
            return <- withdrawVault
        }

        pub fun getCollectionLength(): Int {
            return self.lpTokenVaults.keys.length
        }

        pub fun getLpTokenBalance(pairAddr: Address): UFix64 {
            if self.lpTokenVaults.containsKey(pairAddr) {
                let vaultRef = (&self.lpTokenVaults[pairAddr] as &FungibleToken.Vault?)!
                return vaultRef.balance
            }
            return 0.0
        }

        pub fun getAllLPTokens(): [Address] {
            return self.lpTokenVaults.keys
        }

        pub fun getSlicedLPTokens(from: UInt64, to: UInt64): [Address] {
            pre {
                from <= to && from < UInt64(self.getCollectionLength()):
                    SwapError.ErrorEncode(
                        msg: "from index out of range",
                        err: SwapError.ErrorCode.INVALID_PARAMETERS
                    )
            }
            let pairLen = UInt64(self.getCollectionLength())
            let endIndex = to >= pairLen ? pairLen - 1 : to
            var curIndex = from
            // Array.slice() is not supported yet.
            let list: [Address] = []
            while curIndex <= endIndex {
                list.append(self.lpTokenVaults.keys[curIndex])
                curIndex = curIndex + 1
            }
            return list
        }
    }

    pub fun getPairAddress(token0Key: String, token1Key: String): Address? {
        let pairExist0To1 = self.pairMap.containsKey(token0Key) && self.pairMap[token0Key]!.containsKey(token1Key)
        let pairExist1To0 = self.pairMap.containsKey(token1Key) && self.pairMap[token1Key]!.containsKey(token0Key)
        if (pairExist0To1 && pairExist1To0) {
            return self.pairMap[token0Key]![token1Key]!
        } else {
            return nil
        }
    }

    pub fun getPairInfo(token0Key: String, token1Key: String): AnyStruct? {
        var pairAddr = self.getPairAddress(token0Key: token0Key, token1Key: token1Key)
        if pairAddr == nil {
            return nil
        }
        return getAccount(pairAddr!).getCapability<&{SwapInterfaces.PairPublic}>(SwapConfig.PairPublicPath).borrow()!.getPairInfo()
    }

    pub fun getAllPairsLength(): Int {
        return self.pairs.length
    }

    /// Get sliced array of pair addresses (inclusive for both indexes)
    pub fun getSlicedPairs(from: UInt64, to: UInt64): [Address] {
        pre {
            from <= to && from < UInt64(self.pairs.length):
                SwapError.ErrorEncode(
                    msg: "from index out of range",
                    err: SwapError.ErrorCode.INVALID_PARAMETERS
                )
        }
        let pairLen = UInt64(self.pairs.length)
        let endIndex = to >= pairLen ? pairLen - 1 : to
        var curIndex = from
        // Array.slice() is not supported yet.
        let list: [Address] = []
        while curIndex <= endIndex {
            list.append(self.pairs[curIndex])
            curIndex = curIndex + 1
        }
        return list
    }

    /// Get sliced array of PairInfos (inclusive for both indexes)
    pub fun getSlicedPairInfos(from: UInt64, to: UInt64): [AnyStruct] {
        let pairSlice: [Address] = self.getSlicedPairs(from: from, to: to)
        var i = 0
        var res: [AnyStruct] = []
        while(i < pairSlice.length) {
            res.append(
                getAccount(pairSlice[i]).getCapability<&{SwapInterfaces.PairPublic}>(SwapConfig.PairPublicPath).borrow()!.getPairInfo()
            )
            i = i + 1
        }

        return res
    }

    /// Admin function to update feeTo and pair template
    ///
    pub resource Admin {
        pub fun setPairContractTemplateAddress(newAddr: Address) {
            emit PairTemplateAddressChanged(oldTemplate: SwapFactory.pairContractTemplateAddress, newTemplate: newAddr)
            SwapFactory.pairContractTemplateAddress = newAddr
        }
        pub fun setFeeTo(feeToAddr: Address) {
            let lpTokenCollectionCap = getAccount(feeToAddr).getCapability<&{SwapInterfaces.LpTokenCollectionPublic}>(SwapConfig.LpTokenCollectionPublicPath)
            assert(
                lpTokenCollectionCap.check(), message:
                SwapError.ErrorEncode(
                    msg: "SwapFactory: feeTo account not properly setup with LpTokenCollection resource",
                    err: SwapError.ErrorCode.LOST_PUBLIC_CAPABILITY
                )
            )
            emit FeeToAddressChanged(oldFeeTo: SwapFactory.feeTo, newFeeTo: feeToAddr)
            SwapFactory.feeTo = feeToAddr
        }
        pub fun togglePermissionless() {
            SwapFactory.pairAccountPublicKey = nil
        }
        pub fun setFlashloanRateBps(rateBps: UInt64) {
            pre {
                rateBps <= 10000:
                    SwapError.ErrorEncode(
                        msg: "SwapFactory: flashloan rateBps should be in [0, 10000]",
                        err: SwapError.ErrorCode.INVALID_PARAMETERS
                    )
            }
            emit FlashloanRateChanged(oldRateBps: SwapFactory.getFlashloanRateBps(), newRateBps: rateBps)
            SwapFactory._reservedFields["flashloanRateBps"] = rateBps
        }
        pub fun setSwapFeeRateBps(rateBps: UInt64, isStable: Bool) {
            pre {
                rateBps <= 10000:
                    SwapError.ErrorEncode(
                        msg: "SwapFactory: swap fee bps should be in [0, 10000]",
                        err: SwapError.ErrorCode.INVALID_PARAMETERS
                    )
            }
            emit SwapFeeRateChanged(isStablePair: isStable, oldSwapRateBps: SwapFactory.getSwapFeeRateBps(stableMode: isStable), newSwapRateBps: rateBps)
            if (!isStable) {
                SwapFactory._reservedFields["volatileRateBps"] = rateBps
            } else {
                SwapFactory._reservedFields["stableRateBps"] = rateBps
            }
        }
        /// Once feeTo is turned on, (swapFeeRateBps * feeCut) will be collected and sent to feeTo account as protocol fees.
        pub fun setProtocolFeeCut(cut: UFix64) {
            pre {
                SwapFactory.feeTo != nil:
                    SwapError.ErrorEncode(
                        msg: "SwapFactory: protocol feeTo address not setup yet",
                        err: SwapError.ErrorCode.FEE_TO_SETUP
                    )
                cut < 1.0:
                    SwapError.ErrorEncode(
                        msg: "SwapFactory: feeCut should be < 1.0",
                        err: SwapError.ErrorCode.INVALID_PARAMETERS
                    )
            }
            emit SwapProtocolFeeCutChanged(oldFeeCut: SwapFactory.getProtocolFeeCut(), newFeeCut: cut)
            SwapFactory._reservedFields["protocolFeeCut"] = cut
        }
    }

    init(pairTemplate: Address) {
        self.pairContractTemplateAddress = pairTemplate
        self.pairs = []
        self.pairMap = {}
        self.pairAccountPublicKey = nil
        self.feeTo = nil
        self._reservedFields = {}

        destroy <-self.account.load<@AnyResource>(from: /storage/swapFactoryAdmin)
        self.account.save(<-create Admin(), to: /storage/swapFactoryAdmin)
    }
}
"
-------
"/**

# Common swap errors

# Author: Increment Labs

*/
pub contract SwapError {
    pub enum ErrorCode: UInt8 {
        pub case NO_ERROR

        pub case INVALID_PARAMETERS
        pub case CANNOT_CREATE_PAIR_WITH_SAME_TOKENS
        pub case ADD_PAIR_DUPLICATED
        pub case NONEXISTING_SWAP_PAIR
        pub case LOST_PUBLIC_CAPABILITY // 5
        pub case SLIPPAGE_OFFSET_TOO_LARGE
        pub case EXCESSIVE_INPUT_AMOUNT
        pub case EXPIRED
        pub case INSUFFICIENT_OUTPUT_AMOUNT
        pub case MISMATCH_LPTOKEN_VAULT // 10
        pub case ADD_ZERO_LIQUIDITY
        pub case REENTRANT
        pub case FLASHLOAN_EXECUTOR_SETUP
        pub case FEE_TO_SETUP
        pub case BELOW_MINIMUM_INITIAL_LIQUIDITY // 15
    }

    pub fun ErrorEncode(msg: String, err: ErrorCode): String {
        return "[IncSwapErrorMsg:".concat(msg).concat("]").concat(
               "[IncSwapErrorCode:").concat(err.rawValue.toString()).concat("]")
    }

    init() {
    }
}"
-------
"pub contract Components {

    pub let AdminPath: StoragePath

    pub struct Colors {
        pub let accessories: String
        pub let clothing: String
        pub let hair: String
        pub let hat: String
        pub let facialHair: String
        pub let background: String
        pub let skin: String

        init(_ accessories: String, _ clothing: String, _ hair: String, _ hat: String, _ facialHair: String, _ bg: String, _ skin: String) {
            self.accessories = accessories
            self.clothing = clothing
            self.hair = hair
            self.hat = hat
            self.facialHair = facialHair
            self.background = bg
            self.skin = skin
        }
    }

    pub struct interface Component {
        pub let name: String
        pub fun build(components: {String: {Component}}, colors: Colors): String
    }

    pub struct Accessories: Component {
        pub let name: String

        pub fun build(components: {String: {Component}}, colors: Colors): String {
            let content = Components.account.borrow<&[String]>(from: StoragePath(identifier: "accessories_".concat(self.name))!)
                ?? panic("accessory not found")
            switch self.name {
                case "eyepatch":
                    return content[0]
                default:
                    return content[0].concat(colors.accessories).concat(content[1])
            }
        }

        init(_ n: String) {
            self.name = n
        }
    }

    pub struct Clothing: Component {
        pub let name: String

        pub fun build(components: {String: {Component}}, colors: Colors): String {
            let content = Components.account.borrow<&[String]>(from: StoragePath(identifier: "clothing_".concat(self.name))!)
                ?? panic("clothing not found")
            switch self.name {
                case "graphicShirt":
                    if let graphic = components["clothingGraphic"] {
                        return content[0].concat(colors.clothing).concat(content[1]).concat(graphic.build(components: components, colors: colors)).concat(content[2])
                    }

                    return content[0].concat(colors.clothing).concat(content[1])
                default:
                    return content[0].concat(colors.clothing).concat(content[1])
            }
        }

        init(_ n: String) {
            self.name = n
        }
    }

    pub struct ClothingGraphic: Component {
        pub let name: String

        pub fun build(components: {String: {Component}}, colors: Colors): String {
            let content = Components.account.borrow<&[String]>(from: StoragePath(identifier: "clothingGraphic_".concat(self.name))!)
                ?? panic("clothing not found")
            return content[0]
        }

        init(_ n: String) {
            self.name = n
        }
    }

    pub struct Eyebrows: Component {
        pub let name: String

        pub fun build(components: {String: {Component}}, colors: Colors): String {
            let content = Components.account.borrow<&[String]>(from: StoragePath(identifier: "eyebrows_".concat(self.name))!)
                ?? panic("eyebrows not found")
            return content[0]
        }

        init(_ n: String) {
            self.name = n
        }
    }

    pub struct Eyes: Component {
        pub let name: String

        pub fun build(components: {String: {Component}}, colors: Colors): String {
            let content = Components.account.borrow<&[String]>(from: StoragePath(identifier: "eyes_".concat(self.name))!)
                ?? panic("eyes not found")
            return content[0]
        }

        init(_ n: String) {
            self.name = n
        }
    }

    pub struct FacialHair: Component {
        pub let name: String

        pub fun build(components: {String: {Component}}, colors: Colors): String {
            let content = Components.account.borrow<&[String]>(from: StoragePath(identifier: "facialHair_".concat(self.name))!)
                ?? panic("facialHair not found")
            return content[0].concat(colors.facialHair).concat(content[1])
        }

        init(_ n: String) {
            self.name = n
        }
    }

    pub struct Mouth: Component {
        pub let name: String

        pub fun build(components: {String: {Component}}, colors: Colors): String {
            let content = Components.account.borrow<&[String]>(from: StoragePath(identifier: "mouth_".concat(self.name))!)
                ?? panic("mouth not found")
            return content[0]
        }

        init(_ n: String) {
            self.name = n
        }
    }

    pub struct Nose: Component {
        pub let name: String

        pub fun build(components: {String: {Component}}, colors: Colors): String {
            let content = Components.account.borrow<&[String]>(from: StoragePath(identifier: "nose_".concat(self.name))!)
                ?? panic("nose not found")
            return content[0]
        }

        init(_ n: String) {
            self.name = n
        }
    }

    pub struct Style: Component {
        pub let name: String

        pub fun build(components: {String: {Component}}, colors: Colors): String {
            let content = Components.account.borrow<&[String]>(from: StoragePath(identifier: "style_".concat(self.name))!)
                ?? panic("style not found")
            let base = components["base"]!.build(components: components, colors: colors)
            switch self.name {
                case "circle":
                    return content[0].concat(colors.background).concat(content[1]).concat(base).concat(content[2])
                case "default":
                    return base
            }

            return ""
        }

        init(_ n: String) {
            self.name = n
        }
    }

    pub struct Top: Component {
        pub let name: String

        pub fun build(components: {String: {Component}}, colors: Colors): String {
            let content = Components.account.borrow<&[String]>(from: StoragePath(identifier: "top_".concat(self.name))!)
                ?? panic("top not found")

            switch self.name {
                case "hat":
                    return content[0].concat(colors.hat).concat(content[1])
                case "hijab":
                    return content[0].concat(colors.hat).concat(content[1])
                case "turban":
                    return content[0].concat(colors.hat).concat(content[1])
                case "winterHat1":
                    return content[0].concat(colors.hat).concat(content[1])
                case "winterHat2":
                    return content[0].concat(colors.hat).concat(content[1])
                case "winterHat3":
                    return content[0].concat(colors.hat).concat(content[1])
                case "winterHat4":
                    return content[0].concat(colors.hat).concat(content[1])
                default:
                    return content[0].concat(colors.hair).concat(content[1])
            }
        }

        init(_ n: String) {
            self.name = n
        }
    }

    pub struct Renderer {
        pub let components: {String: {Component}}
        pub let colors: Colors
        pub let flattened: {String: String}

        pub fun build(): String {
            let content = Components.account.borrow<&[String]>(from: StoragePath(identifier: "base_".concat("default"))!)
                ?? panic("base not found")

            let document = Components.account.borrow<&[String]>(from: StoragePath(identifier: "document_default")!)
                ?? panic("document not found")

            let tmp = content[0]
                .concat(self.colors.skin)
                .concat(content[1])
                .concat(self.components["clothing"]?.build(components: self.components, colors: self.colors) ?? "")
                .concat(content[2])
                .concat(self.components["mouth"]?.build(components: self.components, colors: self.colors) ?? "")
                .concat(content[3])
                .concat(self.components["nose"]?.build(components: self.components, colors: self.colors) ?? "")
                .concat(content[4])
                .concat(self.components["eyes"]?.build(components: self.components, colors: self.colors) ?? "")
                .concat(content[5])
                .concat(self.components["eyebrows"]?.build(components: self.components, colors: self.colors) ?? "")
                .concat(content[6])
                .concat(self.components["top"]?.build(components: self.components, colors: self.colors) ?? "")
                .concat(content[7])
                .concat(self.components["facialHair"]?.build(components: self.components, colors: self.colors) ?? "")
                .concat(content[8])
                .concat(self.components["accessories"]?.build(components: self.components, colors: self.colors) ?? "")
                .concat(content[9])
            return document[0].concat(tmp).concat(document[1])
        }

        init(components: {String: {Component}}, colors: Colors) {
            self.components = components
            self.colors = colors

            self.flattened = {}
            for k in self.components.keys {
                self.flattened[k] = self.components[k]!.name
            }
            self.flattened["accessoriesColor"] = self.colors.accessories
            self.flattened["clothingColor"] = self.colors.clothing
            self.flattened["hairColor"] = self.colors.hair
            self.flattened["hatColor"] = self.colors.hat
            self.flattened["facialColor"] = self.colors.facialHair
            self.flattened["backgroundColor"] = self.colors.background
            self.flattened["skinColor"] = self.colors.skin
        }
    }

    pub resource Admin {
        pub let options: {String: {String: Bool}}
        pub let colors: {String: Bool}

        pub fun createRandom(): Renderer {
            let c: [String] = []
            var count = 0
            while count < 7 {
                count = count + 1

                c.append(self.colors.keys[unsafeRandom() % UInt64(self.colors.keys.length)])
            }

            let colors = Colors(c[0], c[1], c[2], c[3], c[4], c[5], c[6])
            let components: {String: {Component}} = {}

            let clothing = Clothing(self.rollOption(segment: "clothing"))
            components["clothing"] = clothing
            if clothing.name == "graphicShirt" {
                components["clothingGraphic"] = ClothingGraphic(self.rollOption(segment: "clothingGraphic"))
            }
            components["mouth"] = Mouth(self.rollOption(segment: "mouth"))
            components["nose"] = Nose(self.rollOption(segment: "nose"))
            components["eyes"] = Eyes(self.rollOption(segment: "eyes"))
            components["eyebrows"] = Eyebrows(self.rollOption(segment: "eyebrows"))
            components["top"] = Top(self.rollOption(segment: "top"))
            components["facialHair"] = FacialHair(self.rollOption(segment: "facialHair"))
            components["accessories"] = Accessories(self.rollOption(segment: "accessories"))

            return Renderer(components: components, colors: colors)
        }

        pub fun rollOption(segment: String): String {
            let keys = self.options[segment]!.keys
            return keys[unsafeRandom() % UInt64(keys.length)]
        }

        pub fun registerContent(component: String, name: String, content: [String]) {
            let storagePath = StoragePath(identifier: component.concat("_").concat(name))!
            Components.account.save(content, to: storagePath)

            if self.options[component] == nil {
                self.options[component] = {
                    name: true
                }
            } else {
                let tmp = self.options[component]!
                tmp[name] = true
                self.options[component] = tmp
            }
        }

        pub fun addColor(_ c: String) {
            self.colors.insert(key: c, true)
        }

        pub fun removeColor(_ c: String) {
            self.colors.remove(key: c)
        }

        init() {
            self.colors = {}
            self.options = {}
        }
    }

    init() {
        self.AdminPath = /storage/ComponentsAdmin

        let admin <- create Admin()
        let colors =  [
                "Red",
                "Blue",
                "Green",
                "Yellow",
                "Orange",
                "Purple",
                "Pink",
                "Brown",
                "Black",
                "White",
                "Gray",
                "Cyan",
                "Magenta",
                "Teal",
                "Maroon",
                "Navy",
                "Olive",
                "Turquoise",
                "Gold",
                "Silver",
                "Indigo",
                "Lavender",
                "Coral",
                "Salmon",
                "Plum"
            ]
            for c in colors {
                admin.addColor(c)
            }


        self.account.save(<- admin, to: self.AdminPath)
    }
}"
-------
"// import FungibleToken from 0x9a0766d93b6608b7
// import NonFungibleToken from 0x631e88ae7f1d7c20
// import MetadataViews from 0x631e88ae7f1d7c20

import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract Syllables: NonFungibleToken {
    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event PublishedMinted(id: UInt64, name: String, ipfsLink: String, type: UInt64)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterPublishedPath: StoragePath

    pub var totalSupply: UInt64
    pub var libraryPassTotalSupply: UInt64
    pub var willoTotalSupply: UInt64

    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        pub let serialId: UInt64
        pub let id: UInt64
        pub let name: String
        pub let ipfsLink: String
        pub let type: UInt64

        init(serialId: UInt64, initID: UInt64, name: String, ipfsLink: String, type: UInt64) {
            self.serialId = serialId
            self.id = initID
            self.name = name
            self.ipfsLink = ipfsLink
            self.type= type
        }

        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.Serial>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            let url = "https://ipfs.io/ipfs/".concat(self.ipfsLink)
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.name,
                        description: "Photographer, best-selling author, mentor, consultant. Recipient of the Hamdan International Photography Award Content Creator Award 2019. Sony Digital Imaging Ambassador\n\n Registration group element - New Zealand \n Registrant element - Published NFT \n Publication element - Edition #1 \n ISBN: 978-0241426418 \n",
                        thumbnail: MetadataViews.IPFSFile(
                            cid: self.ipfsLink,
                            path: nil
                        )
                    )
                case Type<MetadataViews.Royalties>():
                    var royalties: [MetadataViews.Royalty] = []
                    return MetadataViews.Royalties(royalties)
                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(
                        self.serialId
                    )
                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL(url)

                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: Syllables.CollectionStoragePath,
                        publicPath: Syllables.CollectionPublicPath,
                        providerPath: /private/SyllablesCollection,
                        publicCollection: Type<&Syllables.Collection{Syllables.SyllablesCollectionPublic}>(),
                        publicLinkedType: Type<&Syllables.Collection{Syllables.SyllablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&Syllables.Collection{Syllables.SyllablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(),
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                            return <-Syllables.createEmptyCollection()
                        })
                    )

                case Type<MetadataViews.NFTCollectionDisplay>():
                    let media = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: "https://publishednft.io/logo-desktop.png"
                        ),
                        mediaType: "image/png"
                    )
                    return MetadataViews.NFTCollectionDisplay(
                        name: "The Published NFT Collection",
                        description: "Published NFT is a blockchain eBook publishing platform built on the Flow blockchain, where authors can publish eBooks, Lyrics, Comics, Magazines, Articles, Poems, Recipes, Movie Scripts, Computer Language, etc.",
                        externalURL: MetadataViews.ExternalURL("https://publishednft.io/"),
                        squareImage: media,
                        bannerImage: media,
                        socials: {
                            "twitter": MetadataViews.ExternalURL("https://twitter.com/publishednft/"),
                            "discord": MetadataViews.ExternalURL("https://discord.gg/ct5RPudqpG"),
                            "instagram": MetadataViews.ExternalURL("https://www.instagram.com/publishednft/"),
                            "telegram": MetadataViews.ExternalURL("https://t.me/published_nft"),
                            "reddit": MetadataViews.ExternalURL("https://www.reddit.com/user/PublishedNFT")
                        }
                    )
            }
            return nil
        }
    }

    pub resource interface SyllablesCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowSyllables(id: UInt64): &Syllables.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow Syllables reference: The ID of the returned reference is incorrect"
            }
        }
    }

    pub resource Collection: SyllablesCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @Syllables.NFT

            let id: UInt64 = token.id

            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowSyllables(id: UInt64): &Syllables.NFT? {
            if self.ownedNFTs[id] != nil {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &Syllables.NFT
            } else {
                return nil
            }
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let publishedNFT = nft as! &Syllables.NFT
            return publishedNFT as &AnyResource{MetadataViews.Resolver}
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    pub resource PublishedMinter{
        pub fun mintLibraryPass(_name: String, _ipfsLink: String): @Syllables.NFT?{

          if Syllables.libraryPassTotalSupply == 9999 {return nil}

          let libraryPassNft <- create Syllables.NFT(
            serialId: Syllables.libraryPassTotalSupply,
            initID: Syllables.totalSupply,
            name: _name,
            ipfsLink: _ipfsLink,
            type: 1
          )

          emit PublishedMinted(id: Syllables.totalSupply, name: _name, ipfsLink: _ipfsLink, type: 1)

          Syllables.totalSupply = Syllables.totalSupply + (1 as UInt64)
          Syllables.libraryPassTotalSupply = Syllables.libraryPassTotalSupply + (1 as UInt64)

          return <- libraryPassNft
        }

         pub fun mintWillo(_name: String, _ipfsLink: String): @Syllables.NFT?{

          if Syllables.willoTotalSupply == 100 {return nil}

          let willoNft <- create Syllables.NFT(
            serialId: Syllables.willoTotalSupply,
            initID: Syllables.totalSupply,
            name: _name,
            ipfsLink: _ipfsLink,
            type: 1
          )

          emit PublishedMinted(id: Syllables.totalSupply, name: _name, ipfsLink: _ipfsLink, type: 2)

          Syllables.totalSupply = Syllables.totalSupply + (1 as UInt64)
          Syllables.willoTotalSupply = Syllables.willoTotalSupply + (1 as UInt64)

          return <- willoNft
        }
    }

    init() {
        self.CollectionStoragePath = /storage/SyllablesCollection
        self.CollectionPublicPath = /public/SyllablesCollection
        self.MinterPublishedPath = /storage/minterSyllablesPath

        self.totalSupply = 0
        self.libraryPassTotalSupply = 0
        self.willoTotalSupply = 0

        self.account.save(<- create PublishedMinter(), to: self.MinterPublishedPath)

        self.account.save(<- create Collection(), to: self.CollectionStoragePath)
        self.account.link<&Syllables.Collection{NonFungibleToken.CollectionPublic, Syllables.SyllablesCollectionPublic, MetadataViews.ResolverCollection}>(
            self.CollectionPublicPath,
            target: self.CollectionStoragePath
        )

        emit ContractInitialized()
    }
}
"
-------
"import AFLNFT from 0x8f9231920da9af6d
import AFLPack from 0x8f9231920da9af6d
import AFLBurnExchange from 0x8f9231920da9af6d
import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import PackRestrictions from 0x8f9231920da9af6d

pub contract AFLAdmin {

    // Admin
    // the admin resource is defined so that only the admin account
    // can have this resource. It possesses the ability to open packs
    // given a user's Pack Collection and Card Collection reference.
    // It can also create a new pack type and mint Packs.
    //
    pub resource Admin {

        pub fun createTemplate(maxSupply:UInt64, immutableData:{String: AnyStruct}){
            AFLNFT.createTemplate(maxSupply:maxSupply, immutableData:immutableData)
        }

        pub fun updateImmutableData(templateID:UInt64, immutableData:{String: AnyStruct}){
            let templateRef = &AFLNFT.allTemplates[templateID] as &AFLNFT.Template?
            templateRef?.updateImmutableData(immutableData) ?? panic("Template does not exist")
        }

        pub fun addRestrictedPack(id: UInt64) {
            PackRestrictions.addPackId(id: id)
        }

        pub fun removeRestrictedPack(id: UInt64) {
            PackRestrictions.removePackId(id: id)
        }

        pub fun openPack(templateInfo: {String: UInt64}, account: Address){
            AFLNFT.mintNFT(templateInfo:templateInfo, account:account)
        }

        pub fun mintNFT(templateInfo: {String: UInt64}): @NonFungibleToken.NFT {
            return <- AFLNFT.mintAndReturnNFT(templateInfo:templateInfo)
        }

        pub fun addTokenForExchange(nftId: UInt64, token: @NonFungibleToken.NFT) {
            AFLBurnExchange.addTokenForExchange(nftId: nftId, token: <- token)
        }

        pub fun withdrawTokenFromBurnExchange(nftId: UInt64): @NonFungibleToken.NFT {
            return <- AFLBurnExchange.withdrawToken(nftId: nftId)
        }

        // createAdmin
        // only an admin can ever create
        // a new Admin resource
        //
        pub fun createAdmin(): @Admin {
            return <- create Admin()
        }

        init() {

        }
    }

    init() {
        self.account.save(<- create Admin(), to: /storage/AFLAdmin)
    }
}"
-------
"/**

# Swap related interface definitions all-in-one

# Author: Increment Labs

*/
import FungibleToken from 0xf233dcee88fe0abe

pub contract interface SwapInterfaces {
    pub resource interface PairPublic {
        pub fun addLiquidity(tokenAVault: @FungibleToken.Vault, tokenBVault: @FungibleToken.Vault): @FungibleToken.Vault
        pub fun removeLiquidity(lpTokenVault: @FungibleToken.Vault) : @[FungibleToken.Vault]
        pub fun swap(vaultIn: @FungibleToken.Vault, exactAmountOut: UFix64?): @FungibleToken.Vault
        pub fun getAmountIn(amountOut: UFix64, tokenOutKey: String): UFix64
        pub fun getAmountOut(amountIn: UFix64, tokenInKey: String): UFix64
        pub fun getPrice0CumulativeLastScaled(): UInt256
        pub fun getPrice1CumulativeLastScaled(): UInt256
        pub fun getBlockTimestampLast(): UFix64
        pub fun getPairInfo(): [AnyStruct]
        pub fun getLpTokenVaultType(): Type
    }

    pub resource interface LpTokenCollectionPublic {
        pub fun deposit(pairAddr: Address, lpTokenVault: @FungibleToken.Vault)
        pub fun getCollectionLength(): Int
        pub fun getLpTokenBalance(pairAddr: Address): UFix64
        pub fun getAllLPTokens(): [Address]
        pub fun getSlicedLPTokens(from: UInt64, to: UInt64): [Address]
    }
}"
-------
"
// this contract used to storage required NFT metadata
pub contract MikoSeaNFTMetadata {
  // map nftType, NFT ID and required metadata
  // {nftType: {nftID: metadata}}
  access(self) var NFTMetadata: {String:{UInt64:{String:String}}}

  pub let AdminStoragePath: StoragePath

  pub resource Admin {
    pub fun patchMetadata(nftType: String, nftID: UInt64, metadata: {String:String}) {
      if !MikoSeaNFTMetadata.NFTMetadata.containsKey(nftType) {
        MikoSeaNFTMetadata.NFTMetadata[nftType] =  {}
      }
      if !MikoSeaNFTMetadata.NFTMetadata[nftType]!.containsKey(nftID) {
        MikoSeaNFTMetadata.NFTMetadata[nftType]!.insert(key: nftID, metadata)
        return
      }
      metadata.forEachKey(fun (key: String): Bool {
        MikoSeaNFTMetadata.NFTMetadata[nftType]![nftID]!.insert(key: key, metadata[key] ?? "")
        return true
      })
    }

    pub fun removeMetadataByKeys(nftType: String, nftID: UInt64, metadataKeys: [String]) {
      if let nftTypeMetadata = MikoSeaNFTMetadata.NFTMetadata[nftType] {
        if let nftMetadata = nftTypeMetadata[nftID] {
          nftMetadata.forEachKey(fun (key: String): Bool {
            if metadataKeys.contains(key) {
              nftMetadata.remove(key: key)
            }
            return true
          })
          nftTypeMetadata.insert(key: nftID, nftMetadata)
          MikoSeaNFTMetadata.NFTMetadata.insert(key: nftType, nftTypeMetadata)
        }
      }
    }
  }

  pub fun getNFTMetadata(nftType: String, nftID: UInt64): {String:String}? {
    return (self.NFTMetadata[nftType] ?? {})[nftID]
  }

  init() {
    self.AdminStoragePath = /storage/MikoSeaNFTMetadataAdminStoragePath

    self.NFTMetadata = { }

    // Put the Admin in storage
    self.account.save(<- create Admin(), to: self.AdminStoragePath)
  }
}
"
-------
"pub contract PackRestrictions {
    pub let restrictedIds: [UInt64]

    pub event PackIdAdded(id: UInt64)
    pub event PackIdRemoved(id: UInt64)

    pub fun getAllRestrictedIds(): [UInt64] {
        return PackRestrictions.restrictedIds
    }

    pub fun isRestricted(id: UInt64): Bool {
        return PackRestrictions.restrictedIds.contains(id)
    }

    pub fun accessCheck(id: UInt64) {
        assert(!PackRestrictions.restrictedIds.contains(id), message: "Pack opening is restricted")
    }

    access(account) fun addPackId(id: UInt64) {
        pre {
            !PackRestrictions.restrictedIds.contains(id): "Pack id already restricted"
        }
        PackRestrictions.restrictedIds.append(id)
        emit PackIdAdded(id: id)
    }

    access(account) fun removePackId(id: UInt64) {
        pre {
            PackRestrictions.restrictedIds.contains(id): "Pack id not restricted"
        }
        let index = PackRestrictions.restrictedIds.firstIndex(of: id)
        if index != nil {
            PackRestrictions.restrictedIds.remove(at: index!)
            emit PackIdRemoved(id: id)
        }
    }

    init() {
        self.restrictedIds = []
    }
}"
-------
"/*
 * Copyright (c) 2021 24Karat. All rights reserved.
 *
 * SPDX-License-Identifier: MIT
 *
 * This file is part of Project: 24karat flow contract (https://github.com/24karat-io/flow-contract)
 *
 * This source code is licensed under the MIT License found in the
 * LICENSE file in the root directory of this source tree or at
 * https://opensource.org/licenses/MIT.
 */

import FungibleToken from 0xf233dcee88fe0abe

pub contract DUNK: FungibleToken {
    // TokensInitialized
    //
    // The event that is emitted when the contract is created
    pub event TokensInitialized(initialSupply: UFix64)

    // TokensWithdrawn
    //
    // The event that is emitted when tokens are withdrawn from a Vault
    pub event TokensWithdrawn(amount: UFix64, from: Address?)

    // TokensDeposited
    //
    // The event that is emitted when tokens are deposited to a Vault
    pub event TokensDeposited(amount: UFix64, to: Address?)

    // TokensMinted
    //
    // The event that is emitted when new tokens are minted
    pub event TokensMinted(amount: UFix64)

    // TokensBurned
    //
    // The event that is emitted when tokens are destroyed
    pub event TokensBurned(amount: UFix64)

    // MinterCreated
    //
    // The event that is emitted when a new minter resource is created
    pub event MinterCreated(allowedAmount: UFix64)

    // Named paths
    //
    pub let VaultStoragePath: StoragePath
    pub let ReceiverPublicPath: PublicPath
    pub let BalancePublicPath: PublicPath
    pub let AdminStoragePath: StoragePath

    // Total supply of token in existence
    pub var totalSupply: UFix64

    // Vault
    //
    // Each user stores an instance of only the Vault in their storage
    // The functions in the Vault and governed by the pre and post conditions
    // in FungibleToken when they are called.
    // The checks happen at runtime whenever a function is called.
    //
    // Resources can only be created in the context of the contract that they
    // are defined in, so there is no way for a malicious user to create Vaults
    // out of thin air. A special Minter resource needs to be defined to mint
    // new tokens.
    //
    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {

        // The total balance of this vault
        pub var balance: UFix64

        // initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        // withdraw
        //
        // Function that takes an amount as an argument
        // and withdraws that amount from the Vault.
        //
        // It creates a new temporary Vault that is used to hold
        // the money that is being transferred. It returns the newly
        // created Vault to the context that called so it can be deposited
        // elsewhere.
        //
        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)
            return <-create Vault(balance: amount)
        }

        // deposit
        //
        // Function that takes a Vault object as an argument and adds
        // its balance to the balance of the owners Vault.
        //
        // It is allowed to destroy the sent Vault because the Vault
        // was a temporary holder of the tokens. The Vault's balance has
        // been consumed and therefore can be destroyed.
        //
        pub fun deposit(from: @FungibleToken.Vault) {
            let vault <- from as! @DUNK.Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)
            vault.balance = 0.0
            destroy vault
        }

        destroy() {
            DUNK.totalSupply = DUNK.totalSupply - self.balance
            if(self.balance > 0.0) {
                emit TokensBurned(amount: self.balance)
            }
        }
    }

    // createEmptyVault
    //
    // Function that creates a new Vault with a balance of zero
    // and returns it to the calling context. A user must call this function
    // and store the returned Vault in their storage in order to allow their
    // account to be able to receive deposits of this token type.
    //
    pub fun createEmptyVault(): @Vault {
        return <-create Vault(balance: 0.0)
    }

    pub resource Administrator {

        // createNewMinter
        //
        // Function that creates and returns a new minter resource
        //
        pub fun createNewMinter(allowedAmount: UFix64): @Minter {
            emit MinterCreated(allowedAmount: allowedAmount)
            return <-create Minter(allowedAmount: allowedAmount)
        }
    }

    // Minter
    //
    // Resource object that token admin accounts can hold to mint new tokens.
    //
    pub resource Minter {

        // The amount of tokens that the minter is allowed to mint
        pub var allowedAmount: UFix64

        // mintTokens
        //
        // Function that mints new tokens, adds them to the total supply,
        // and returns them to the calling context.
        //
        pub fun mintTokens(amount: UFix64): @DUNK.Vault {
            pre {
                amount > 0.0: "Amount minted must be greater than zero"
                amount <= self.allowedAmount: "Amount minted must be less than the allowed amount"
            }
            DUNK.totalSupply = DUNK.totalSupply + amount
            self.allowedAmount = self.allowedAmount - amount
            emit TokensMinted(amount: amount)
            return <-create Vault(balance: amount)
        }

        init(allowedAmount: UFix64) {
            self.allowedAmount = allowedAmount
        }
    }

    init() {
        // Set our named paths.
        self.VaultStoragePath = /storage/DUNKVault
        self.ReceiverPublicPath = /public/DUNKReceiver
        self.BalancePublicPath = /public/DUNKBalance
        self.AdminStoragePath = /storage/DUNKAdmin

        // Initialize contract state.
        self.totalSupply = 0.0

        // Create the one true Admin object and deposit it into the conttract account.
        let admin <- create Administrator()
        self.account.save(<-admin, to: self.AdminStoragePath)

        // Emit an event that shows that the contract was initialized.
        emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
"
-------
"/*
 * Copyright (c) 2021 24Karat. All rights reserved.
 *
 * SPDX-License-Identifier: MIT
 *
 * This file is part of Project: 24karat flow contract (https://github.com/24karat-io/flow-contract)
 *
 * This source code is licensed under the MIT License found in the
 * LICENSE file in the root directory of this source tree or at
 * https://opensource.org/licenses/MIT.
 */

import FungibleToken from 0xf233dcee88fe0abe

pub contract VO_FINANCE: FungibleToken {
    // TokensInitialized
    //
    // The event that is emitted when the contract is created
    pub event TokensInitialized(initialSupply: UFix64)

    // TokensWithdrawn
    //
    // The event that is emitted when tokens are withdrawn from a Vault
    pub event TokensWithdrawn(amount: UFix64, from: Address?)

    // TokensDeposited
    //
    // The event that is emitted when tokens are deposited to a Vault
    pub event TokensDeposited(amount: UFix64, to: Address?)

    // TokensMinted
    //
    // The event that is emitted when new tokens are minted
    pub event TokensMinted(amount: UFix64)

    // TokensBurned
    //
    // The event that is emitted when tokens are destroyed
    pub event TokensBurned(amount: UFix64)

    // MinterCreated
    //
    // The event that is emitted when a new minter resource is created
    pub event MinterCreated(allowedAmount: UFix64)

    // Named paths
    //
    pub let VaultStoragePath: StoragePath
    pub let ReceiverPublicPath: PublicPath
    pub let BalancePublicPath: PublicPath
    pub let AdminStoragePath: StoragePath

    // Total supply of token in existence
    pub var totalSupply: UFix64

    // Vault
    //
    // Each user stores an instance of only the Vault in their storage
    // The functions in the Vault and governed by the pre and post conditions
    // in FungibleToken when they are called.
    // The checks happen at runtime whenever a function is called.
    //
    // Resources can only be created in the context of the contract that they
    // are defined in, so there is no way for a malicious user to create Vaults
    // out of thin air. A special Minter resource needs to be defined to mint
    // new tokens.
    //
    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {

        // The total balance of this vault
        pub var balance: UFix64

        // initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        // withdraw
        //
        // Function that takes an amount as an argument
        // and withdraws that amount from the Vault.
        //
        // It creates a new temporary Vault that is used to hold
        // the money that is being transferred. It returns the newly
        // created Vault to the context that called so it can be deposited
        // elsewhere.
        //
        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)
            return <-create Vault(balance: amount)
        }

        // deposit
        //
        // Function that takes a Vault object as an argument and adds
        // its balance to the balance of the owners Vault.
        //
        // It is allowed to destroy the sent Vault because the Vault
        // was a temporary holder of the tokens. The Vault's balance has
        // been consumed and therefore can be destroyed.
        //
        pub fun deposit(from: @FungibleToken.Vault) {
            let vault <- from as! @VO_FINANCE.Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)
            vault.balance = 0.0
            destroy vault
        }

        destroy() {
            VO_FINANCE.totalSupply = VO_FINANCE.totalSupply - self.balance
            if(self.balance > 0.0) {
                emit TokensBurned(amount: self.balance)
            }
        }
    }

    // createEmptyVault
    //
    // Function that creates a new Vault with a balance of zero
    // and returns it to the calling context. A user must call this function
    // and store the returned Vault in their storage in order to allow their
    // account to be able to receive deposits of this token type.
    //
    pub fun createEmptyVault(): @Vault {
        return <-create Vault(balance: 0.0)
    }

    pub resource Administrator {

        // createNewMinter
        //
        // Function that creates and returns a new minter resource
        //
        pub fun createNewMinter(allowedAmount: UFix64): @Minter {
            emit MinterCreated(allowedAmount: allowedAmount)
            return <-create Minter(allowedAmount: allowedAmount)
        }
    }

    // Minter
    //
    // Resource object that token admin accounts can hold to mint new tokens.
    //
    pub resource Minter {

        // The amount of tokens that the minter is allowed to mint
        pub var allowedAmount: UFix64

        // mintTokens
        //
        // Function that mints new tokens, adds them to the total supply,
        // and returns them to the calling context.
        //
        pub fun mintTokens(amount: UFix64): @VO_FINANCE.Vault {
            pre {
                amount > 0.0: "Amount minted must be greater than zero"
                amount <= self.allowedAmount: "Amount minted must be less than the allowed amount"
            }
            VO_FINANCE.totalSupply = VO_FINANCE.totalSupply + amount
            self.allowedAmount = self.allowedAmount - amount
            emit TokensMinted(amount: amount)
            return <-create Vault(balance: amount)
        }

        init(allowedAmount: UFix64) {
            self.allowedAmount = allowedAmount
        }
    }

    init() {
        // Set our named paths.
        self.VaultStoragePath = /storage/VO_FINANCEVault
        self.ReceiverPublicPath = /public/VO_FINANCEReceiver
        self.BalancePublicPath = /public/VO_FINANCEBalance
        self.AdminStoragePath = /storage/VO_FINANCEAdmin

        // Initialize contract state.
        self.totalSupply = 0.0

        // Create the one true Admin object and deposit it into the conttract account.
        let admin <- create Administrator()
        self.account.save(<-admin, to: self.AdminStoragePath)

        // Emit an event that shows that the contract was initialized.
        emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
"
-------
"/*
 * Copyright (c) 2021 24Karat. All rights reserved.
 *
 * SPDX-License-Identifier: MIT
 *
 * This file is part of Project: 24karat flow contract (https://github.com/24karat-io/flow-contract)
 *
 * This source code is licensed under the MIT License found in the
 * LICENSE file in the root directory of this source tree or at
 * https://opensource.org/licenses/MIT.
 */

import FungibleToken from 0xf233dcee88fe0abe

pub contract VO_RESEARCH: FungibleToken {
    // TokensInitialized
    //
    // The event that is emitted when the contract is created
    pub event TokensInitialized(initialSupply: UFix64)

    // TokensWithdrawn
    //
    // The event that is emitted when tokens are withdrawn from a Vault
    pub event TokensWithdrawn(amount: UFix64, from: Address?)

    // TokensDeposited
    //
    // The event that is emitted when tokens are deposited to a Vault
    pub event TokensDeposited(amount: UFix64, to: Address?)

    // TokensMinted
    //
    // The event that is emitted when new tokens are minted
    pub event TokensMinted(amount: UFix64)

    // TokensBurned
    //
    // The event that is emitted when tokens are destroyed
    pub event TokensBurned(amount: UFix64)

    // MinterCreated
    //
    // The event that is emitted when a new minter resource is created
    pub event MinterCreated(allowedAmount: UFix64)

    // Named paths
    //
    pub let VaultStoragePath: StoragePath
    pub let ReceiverPublicPath: PublicPath
    pub let BalancePublicPath: PublicPath
    pub let AdminStoragePath: StoragePath

    // Total supply of token in existence
    pub var totalSupply: UFix64

    // Vault
    //
    // Each user stores an instance of only the Vault in their storage
    // The functions in the Vault and governed by the pre and post conditions
    // in FungibleToken when they are called.
    // The checks happen at runtime whenever a function is called.
    //
    // Resources can only be created in the context of the contract that they
    // are defined in, so there is no way for a malicious user to create Vaults
    // out of thin air. A special Minter resource needs to be defined to mint
    // new tokens.
    //
    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {

        // The total balance of this vault
        pub var balance: UFix64

        // initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        // withdraw
        //
        // Function that takes an amount as an argument
        // and withdraws that amount from the Vault.
        //
        // It creates a new temporary Vault that is used to hold
        // the money that is being transferred. It returns the newly
        // created Vault to the context that called so it can be deposited
        // elsewhere.
        //
        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)
            return <-create Vault(balance: amount)
        }

        // deposit
        //
        // Function that takes a Vault object as an argument and adds
        // its balance to the balance of the owners Vault.
        //
        // It is allowed to destroy the sent Vault because the Vault
        // was a temporary holder of the tokens. The Vault's balance has
        // been consumed and therefore can be destroyed.
        //
        pub fun deposit(from: @FungibleToken.Vault) {
            let vault <- from as! @VO_RESEARCH.Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)
            vault.balance = 0.0
            destroy vault
        }

        destroy() {
            VO_RESEARCH.totalSupply = VO_RESEARCH.totalSupply - self.balance
            if(self.balance > 0.0) {
                emit TokensBurned(amount: self.balance)
            }
        }
    }

    // createEmptyVault
    //
    // Function that creates a new Vault with a balance of zero
    // and returns it to the calling context. A user must call this function
    // and store the returned Vault in their storage in order to allow their
    // account to be able to receive deposits of this token type.
    //
    pub fun createEmptyVault(): @Vault {
        return <-create Vault(balance: 0.0)
    }

    pub resource Administrator {

        // createNewMinter
        //
        // Function that creates and returns a new minter resource
        //
        pub fun createNewMinter(allowedAmount: UFix64): @Minter {
            emit MinterCreated(allowedAmount: allowedAmount)
            return <-create Minter(allowedAmount: allowedAmount)
        }
    }

    // Minter
    //
    // Resource object that token admin accounts can hold to mint new tokens.
    //
    pub resource Minter {

        // The amount of tokens that the minter is allowed to mint
        pub var allowedAmount: UFix64

        // mintTokens
        //
        // Function that mints new tokens, adds them to the total supply,
        // and returns them to the calling context.
        //
        pub fun mintTokens(amount: UFix64): @VO_RESEARCH.Vault {
            pre {
                amount > 0.0: "Amount minted must be greater than zero"
                amount <= self.allowedAmount: "Amount minted must be less than the allowed amount"
            }
            VO_RESEARCH.totalSupply = VO_RESEARCH.totalSupply + amount
            self.allowedAmount = self.allowedAmount - amount
            emit TokensMinted(amount: amount)
            return <-create Vault(balance: amount)
        }

        init(allowedAmount: UFix64) {
            self.allowedAmount = allowedAmount
        }
    }

    init() {
        // Set our named paths.
        self.VaultStoragePath = /storage/VO_RESEARCHVault
        self.ReceiverPublicPath = /public/VO_RESEARCHReceiver
        self.BalancePublicPath = /public/VO_RESEARCHBalance
        self.AdminStoragePath = /storage/VO_RESEARCHAdmin

        // Initialize contract state.
        self.totalSupply = 0.0

        // Create the one true Admin object and deposit it into the conttract account.
        let admin <- create Administrator()
        self.account.save(<-admin, to: self.AdminStoragePath)

        // Emit an event that shows that the contract was initialized.
        emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
"
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract SwirlNametag: NonFungibleToken {
    pub var totalSupply: UInt64
    priv let profiles: {UInt64: Profile}

    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let ProviderPrivatePath: PrivatePath

    pub struct SocialHandle {
        pub let channel: String
        pub let handle: String

        init(channel: String, handle: String) {
            self.channel = channel
            self.handle = handle
        }
    }

    pub struct Profile {
        pub let nickname: String
        pub let profileImage: String
        pub let keywords: [String]
        pub let color: String
        pub let socialHandles: [SocialHandle]

        init(
            nickname: String,
            profileImage: String,
            keywords: [String],
            color: String,
            socialHandles: [SocialHandle]
        ) {
            self.nickname = nickname
            self.profileImage = profileImage
            self.keywords = keywords
            self.color = color
            self.socialHandles = socialHandles
        }
    }

    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        pub let id: UInt64

        init(id: UInt64) {
            self.id = id
        }

        pub fun getViews(): [Type] {
            let views: [Type] = [
                    Type<Profile>(),
                    Type<MetadataViews.Display>(),
                    Type<MetadataViews.Serial>(),
                    Type<MetadataViews.NFTCollectionData>(),
                    Type<MetadataViews.NFTCollectionDisplay>(),
                    Type<MetadataViews.Traits>()
                ]
            return views
        }

        pub fun name(): String {
            return "Swirl Nametag: ".concat(self.profile().nickname)
        }

        pub fun profile(): Profile {
            return SwirlNametag.getProfile(self.id)
        }

        pub fun profileImageUrl(): String {
            let profile = self.profile()
            var url = "https://swirl.deno.dev/dnft/nametag.svg?"
            url = url.concat("nickname=").concat(profile.nickname)
            url = url.concat("&profile_img=").concat(String.encodeHex(profile.profileImage.utf8))
            url = url.concat("&color=").concat(String.encodeHex(profile.color.utf8))
            return url
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<Profile>():
                    return self.profile()

                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.name(),
                        description: "Swirl, share your digital profiles as NFT and keep IRL moment with others.",
                        thumbnail: MetadataViews.HTTPFile(url: self.profileImageUrl())
                    )
                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(
                        self.id
                    )
                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: SwirlNametag.CollectionStoragePath,
                        publicPath: SwirlNametag.CollectionPublicPath,
                        providerPath: SwirlNametag.ProviderPrivatePath,
                        publicCollection: Type<&SwirlNametag.Collection{SwirlNametag.SwirlNametagCollectionPublic}>(),
                        publicLinkedType: Type<&SwirlNametag.Collection{SwirlNametag.SwirlNametagCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&SwirlNametag.Collection{SwirlNametag.SwirlNametagCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Provider, MetadataViews.ResolverCollection}>(),
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                            return <-SwirlNametag.createEmptyCollection()
                        })
                    )
                case Type<MetadataViews.NFTCollectionDisplay>():
                    let media = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(url: self.profileImageUrl()),
                        mediaType: "image/svg+xml"
                    )
                    let socials: {String: MetadataViews.ExternalURL} = {}
                    for handle in self.profile().socialHandles {
                        socials[handle.channel] = MetadataViews.ExternalURL(handle.handle)
                    }

                    return MetadataViews.NFTCollectionDisplay(
                        name: "Swirl Nametag",
                        description: "Swirl, share your digital profiles as NFT and keep IRL moment with others.",
                        externalURL: MetadataViews.ExternalURL("https://hyphen.at/"),
                        squareImage: media,
                        bannerImage: media,
                        socials: socials,
                    )
                case Type<MetadataViews.Traits>():
                    let profile = self.profile()
                    let traits: {String: AnyStruct} = {}
                    traits["nickname"] = profile.nickname
                    traits["keywords"] = profile.keywords
                    traits["color"] = profile.color
                    for handle in profile.socialHandles {
                        traits[handle.channel] = handle.handle
                    }
                    let traitsView = MetadataViews.dictToTraits(dict: traits, excludedNames: [])

                    return traitsView
                default:
                    return nil
            }
        }
    }

    pub resource interface SwirlNametagCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowSwirlNametag(id: UInt64): &SwirlNametag.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow SwirlNametag reference: the ID of the returned reference is incorrect"
            }
        }
    }

    pub resource Collection: SwirlNametagCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with an `UInt64` ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        // withdraw removes an NFT from the collection and moves it to the caller
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            panic("soulbound; SBT is not transferable")
        }

        // deposit takes an NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @SwirlNametag.NFT

            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        // getIDs returns an array of the IDs that are in the collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT gets a reference to an NFT in the collection
        // so that the caller can read its metadata and call its methods
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowSwirlNametag(id: UInt64): &SwirlNametag.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorized reference to allow downcasting
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &SwirlNametag.NFT
            }

            return nil
        }

        pub fun updateSwirlNametag(profile: Profile) {
            let tokenIDs = self.getIDs()
            if tokenIDs.length == 0 {
                panic("no nametags")
            }
            SwirlNametag.setProfile(tokenID: tokenIDs[0], profile: profile)
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let SwirlNametagNFT = nft as! &SwirlNametag.NFT
            return SwirlNametagNFT as &AnyResource{MetadataViews.Resolver}
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    pub fun getProfile(_ tokenID: UInt64): Profile {
        return self.profiles[tokenID] ?? panic("no profile for token ID")
    }

    access(contract) fun setProfile(tokenID: UInt64, profile: Profile) {
        self.profiles[tokenID] = profile
    }

    // public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    pub fun mintNFT(recipient: &{NonFungibleToken.CollectionPublic}, profile: Profile) {
        // create a new NFT
        var newNFT <- create NFT(id: SwirlNametag.totalSupply + 1)
        SwirlNametag.setProfile(tokenID: newNFT.id, profile: profile)
        recipient.deposit(token: <-newNFT)
        SwirlNametag.totalSupply = SwirlNametag.totalSupply + 1
    }

    init() {
        self.totalSupply = 0
        self.profiles = {}

        self.CollectionStoragePath = /storage/SwirlNametagCollection
        self.CollectionPublicPath = /public/SwirlNametagCollection
        self.ProviderPrivatePath = /private/SwirlNFTCollectionProvider

        // Create a Collection resource and save it to storage
        let collection <- create Collection()
        self.account.save(<-collection, to: self.CollectionStoragePath)

        self.account.link<&SwirlNametag.Collection{NonFungibleToken.CollectionPublic, SwirlNametag.SwirlNametagCollectionPublic, MetadataViews.ResolverCollection}>(
            self.CollectionPublicPath,
            target: self.CollectionStoragePath
        )

        emit ContractInitialized()
    }
}
"
-------
"/*
GreatApeEscape

This is the contract for GreatApeEscape NFTs!

This was implemented using Niftory interfaces. For full details on how this
contract functions, please see the Niftory and NFTRegistry contracts.

*/

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import ViewResolver from 0x1d7e57aa55817448

import MutableMetadata from 0x7ec1f607f0872a9e
import MutableMetadataTemplate from 0x7ec1f607f0872a9e
import MutableMetadataSet from 0x7ec1f607f0872a9e
import MutableMetadataSetManager from 0x7ec1f607f0872a9e
import MetadataViewsManager from 0x7ec1f607f0872a9e

import NiftoryNonFungibleToken from 0x7ec1f607f0872a9e
import NiftoryNFTRegistry from 0x7ec1f607f0872a9e

import NiftoryMetadataViewsResolvers from 0x7ec1f607f0872a9e
import NiftoryNonFungibleTokenProxy from 0x7ec1f607f0872a9e

pub contract GreatApeEscape: NonFungibleToken, ViewResolver {

  // ========================================================================
  // Constants
  // ========================================================================

  // Suggested paths where collection could be stored
  pub let COLLECTION_PRIVATE_PATH: PrivatePath
  pub let COLLECTION_PUBLIC_PATH: PublicPath
  pub let COLLECTION_STORAGE_PATH: StoragePath

  // Accessor token to be used with NiftoryNFTRegistry to retrieve
  // meta-information about this NFT project
  pub let REGISTRY_ADDRESS: Address
  pub let REGISTRY_BRAND: String

  // ========================================================================
  // Attributes
  // ========================================================================

  // Arbitrary metadata for this NFT contract
  pub var metadata: AnyStruct?

  // Number of NFTs created
  pub var totalSupply: UInt64

  // ========================================================================
  // Contract Events
  // ========================================================================

  // This contract was initialized
  pub event ContractInitialized()

  // A withdrawal of NFT `id` has occurred from the `from` Address
  pub event Withdraw(id: UInt64, from: Address?)

  // A deposit of an NFT `id` has occurred to the `to` Address
  pub event Deposit(id: UInt64, to: Address?)

  ///////////////////////////////////////////////////////////////////////////

  // Contract metadata was modified
  pub event ContractMetadataUpdated()

  // Metadata Views Manager was locked
  pub event MetadataViewsManagerLocked()

  // Metadata Views Resolver was added
  pub event MetadataViewsResolverAdded(type: Type)

  // Metadata Views Resolver was removed
  pub event MetadataViewsResolverRemoved(type: Type)

  // Set Manager Name or Description updated
  pub event SetManagerMetadataUpdated()

  // Set added to Set Manager
  pub event SetAddedToSetManager(setID: Int)

  ///////////////////////////////////////////////////////////////////////////

  // Set `setId` was locked (no new templates can be added)
  pub event SetLocked(setId: Int)

  // The metadata for Set `setId` was locked and cannot be modified
  pub event SetMetadataLocked(setId: Int)

  // Set `setId` was modified
  pub event SetMetadataModified(setId: Int)

  // A new Template `templateId` was added to Set `setId`
  pub event TemplateAddedToSet(setId: Int, templateId: Int)

  ///////////////////////////////////////////////////////////////////////////

  // Template `templateId` was locked in Set `setId`, which disables minting
  pub event TemplateLocked(setId: Int, templateId: Int)

  // Template `templateId` of Set `setId` had it's maxMint set to `maxMint`
  pub event TemplateMaxMintSet(setId: Int, templateId: Int, maxMint: UInt64)

  // Template `templateId` of Set `setId` has minted NFT with serial `serial`
  pub event NFTMinted(id: UInt64, setId: Int, templateId: Int, serial: UInt64)

  ///////////////////////////////////////////////////////////////////////////

  // The metadata for NFT/Template `templateId` of Set `setId` was locked
  pub event NFTMetadataLocked(setId: Int, templateId: Int)

  // The metadata for NFT/Template `templateId` of Set `setId` was modified
  pub event NFTMetadataModified(setId: Int, templateId: Int)

  ///////////////////////////////////////////////////////////////////////////

  // NFT `serial` from Template `templateId` of Set `setId` was burned
  pub event NFTBurned(setId: Int, templateId: Int, serial: UInt64)

  // ========================================================================
  // NFT
  // ========================================================================

  pub resource NFT:
    NonFungibleToken.INFT,
    MetadataViews.Resolver,
    NiftoryNonFungibleToken.NFTPublic
  {
    pub let id: UInt64
    pub let setId: Int
    pub let templateId: Int
    pub let serial: UInt64

    pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
      return GreatApeEscape.contract()
    }

    pub fun set(): &MutableMetadataSet.Set{MutableMetadataSet.Public} {
      return self
        .contract()
        .getSetManagerPublic()
        .getSet(self.setId)
    }

    pub fun metadata(): &MutableMetadata.Metadata{MutableMetadata.Public} {
      return self
        .set()
        .getTemplate(self.templateId)
        .metadata()
    }

    pub fun getViews(): [Type] {
      return self
        .contract()
        .getMetadataViewsManagerPublic()
        .getViews()
    }

    pub fun resolveView(_ view: Type): AnyStruct? {
      let nftRef = &self as &{NiftoryNonFungibleToken.NFTPublic}
      return self
        .contract()
        .getMetadataViewsManagerPublic()
        .resolveView(view: view, nftRef: nftRef)
    }

    init(setId: Int, templateId: Int, serial: UInt64) {
      self.id = GreatApeEscape.totalSupply
      GreatApeEscape.totalSupply =
        GreatApeEscape.totalSupply + 1
      self.setId = setId
      self.templateId = templateId
      self.serial = serial
    }

    destroy() {
      emit NFTBurned(
        setId: self.setId,
        templateId: self.templateId,
        serial: self.serial
      )
    }
  }

  // ========================================================================
  // Collection
  // ========================================================================

  pub resource Collection:
    NonFungibleToken.Provider,
    NonFungibleToken.Receiver,
    NonFungibleToken.CollectionPublic,
    MetadataViews.ResolverCollection,
    NiftoryNonFungibleToken.CollectionPublic,
    NiftoryNonFungibleToken.CollectionPrivate
  {
    pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

    pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
      return GreatApeEscape.contract()
    }

    pub fun getIDs(): [UInt64] {
      return self.ownedNFTs.keys
    }

    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
      pre {
        self.ownedNFTs[id] != nil : "NFT "
          .concat(id.toString())
          .concat(" does not exist in collection.")
      }
      return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
    }

    pub fun borrow(id: UInt64): &NFT{NiftoryNonFungibleToken.NFTPublic} {
      pre {
        self.ownedNFTs[id] != nil : "NFT does not exist in collection."
      }
      let nftRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let fullNft = nftRef as! &NFT
      return fullNft
    }

    pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {
      pre {
        self.ownedNFTs[id] != nil : "NFT does not exist in collection."
      }
      let nftRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let fullNft = nftRef as! &NFT
      return fullNft
    }

    pub fun deposit(token: @NonFungibleToken.NFT) {
      let token <- token as! @GreatApeEscape.NFT
      let id: UInt64 = token.id
      let oldToken <- self.ownedNFTs[id] <- token
      emit Deposit(id: id, to: self.owner?.address)
      destroy oldToken
    }

    pub fun depositBulk(tokens: @[NonFungibleToken.NFT]) {
      while tokens.length > 0 {
        let token <- tokens.removeLast() as! @GreatApeEscape.NFT
        self.deposit(token: <-token)
      }
      destroy tokens
    }

    pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
      pre {
        self.ownedNFTs[withdrawID] != nil
          : "NFT "
            .concat(withdrawID.toString())
            .concat(" does not exist in collection.")
      }
      let token <-self.ownedNFTs.remove(key: withdrawID)!
      emit Withdraw(id: token.id, from: self.owner?.address)
      return <-token
    }

    pub fun withdrawBulk(withdrawIDs: [UInt64]): @[NonFungibleToken.NFT] {
      let tokens: @[NonFungibleToken.NFT] <- []
      while withdrawIDs.length > 0 {
        tokens.append(<- self.withdraw(withdrawID: withdrawIDs.removeLast()))
      }
      return <-tokens
    }

    init() {
      self.ownedNFTs <- {}
    }

    destroy() {
      destroy self.ownedNFTs
    }
  }

  pub fun createEmptyCollection(): @Collection {
    return <-create Collection()
  }

  // ========================================================================
  // Manager
  // ========================================================================

  pub resource Manager:
    NiftoryNonFungibleToken.ManagerPublic,
    NiftoryNonFungibleToken.ManagerPrivate
  {
    // ========================================================================
    // Public
    // ========================================================================

    pub fun metadata(): AnyStruct? {
      return GreatApeEscape.metadata
    }

    pub fun getSetManagerPublic():
      &MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public}
    {
      return NiftoryNFTRegistry
        .getSetManagerPublic(
          GreatApeEscape.REGISTRY_ADDRESS,
          GreatApeEscape.REGISTRY_BRAND
        )
    }

    pub fun getMetadataViewsManagerPublic():
      &MetadataViewsManager.Manager{MetadataViewsManager.Public}
    {
      return NiftoryNFTRegistry
        .getMetadataViewsManagerPublic(
          GreatApeEscape.REGISTRY_ADDRESS,
          GreatApeEscape.REGISTRY_BRAND
        )
    }

    pub fun getNFTCollectionData(): MetadataViews.NFTCollectionData {
      return NiftoryNFTRegistry
        .buildNFTCollectionData(
          GreatApeEscape.REGISTRY_ADDRESS,
          GreatApeEscape.REGISTRY_BRAND,
          (fun (): @NonFungibleToken.Collection {
            return <-GreatApeEscape.createEmptyCollection()
          })
        )
    }

    // ========================================================================
    // Contract metadata
    // ========================================================================

    pub fun modifyContractMetadata(): auth &AnyStruct {
      emit ContractMetadataUpdated()
      let maybeMetadata = GreatApeEscape.metadata
      if maybeMetadata == nil {
        let blankMetadata: {String: String} = {}
        GreatApeEscape.metadata = blankMetadata
      }
      return (&GreatApeEscape.metadata as auth &AnyStruct?)!
    }

    pub fun replaceContractMetadata(_ metadata: AnyStruct?) {
      emit ContractMetadataUpdated()
      GreatApeEscape.metadata = metadata
    }

    // ========================================================================
    // Metadata Views Manager
    // ========================================================================

    access(self) fun _getMetadataViewsManagerPrivate():
      &MetadataViewsManager.Manager{MetadataViewsManager.Private}
    {
      let record =
        NiftoryNFTRegistry.getRegistryRecord(
          GreatApeEscape.REGISTRY_ADDRESS,
          GreatApeEscape.REGISTRY_BRAND
        )
      let manager =
        GreatApeEscape.account
          .getCapability<&MetadataViewsManager.Manager{MetadataViewsManager.Private}>(
            record.metadataViewsManager.paths.private
          ).borrow()!
      return manager
    }

    pub fun lockMetadataViewsManager() {
      self._getMetadataViewsManagerPrivate().lock()
      emit MetadataViewsManagerLocked()
    }

    pub fun setMetadataViewsResolver(
      _ resolver: AnyStruct{MetadataViewsManager.Resolver}
    ) {
      self._getMetadataViewsManagerPrivate().addResolver(resolver)
      emit MetadataViewsResolverAdded(type: resolver.type)
    }

    pub fun removeMetadataViewsResolver(_ type: Type) {
      self._getMetadataViewsManagerPrivate().removeResolver(type)
      emit MetadataViewsResolverRemoved(type: type)
    }

    // ========================================================================
    // Set Manager
    // ========================================================================

    access(self) fun _getSetManagerPrivate():
      &MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public, MutableMetadataSetManager.Private}
    {
      let record =
        NiftoryNFTRegistry.getRegistryRecord(
          GreatApeEscape.REGISTRY_ADDRESS,
          GreatApeEscape.REGISTRY_BRAND
        )
      let setManager =
        GreatApeEscape.account
          .getCapability<&MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public, MutableMetadataSetManager.Private}>(
            record.setManager.paths.private
          ).borrow()!
      return setManager
    }

    pub fun setMetadataManagerName(_ name: String) {
      self._getSetManagerPrivate().setName(name)
      emit SetManagerMetadataUpdated()
    }

    pub fun setMetadataManagerDescription(_ description: String) {
      self._getSetManagerPrivate().setDescription(description)
      emit SetManagerMetadataUpdated()
    }

    pub fun addSet(_ set: @MutableMetadataSet.Set) {
      let setManager = self._getSetManagerPrivate()
      let setId = setManager.numSets()
      setManager.addSet(<-set)
      emit SetAddedToSetManager(setID: setId)
    }

    // ========================================================================
    // Set
    // ========================================================================

    access(self) fun _getSetMutable(_ setId: Int):
      &MutableMetadataSet.Set{MutableMetadataSet.Private,
        MutableMetadataSet.Public} {
      return self._getSetManagerPrivate().getSetMutable(setId)
    }

    pub fun lockSet(setId: Int) {
      self._getSetMutable(setId).lock()
      emit SetLocked(setId: setId)
    }

    pub fun lockSetMetadata(setId: Int) {
      self._getSetMutable(setId).metadataMutable().lock()
      emit SetMetadataLocked(setId: setId)
    }

    pub fun modifySetMetadata(setId: Int): auth &AnyStruct {
      emit SetMetadataModified(setId: setId)
      return self._getSetMutable(setId).metadataMutable().getMutable()
    }

    pub fun replaceSetMetadata(setId: Int, new: AnyStruct) {
      self._getSetMutable(setId).metadataMutable().replace(new)
      emit SetMetadataModified(setId: setId)
    }

    pub fun addTemplate(
      setId: Int,
      template: @MutableMetadataTemplate.Template
    ) {
      let set = self._getSetMutable(setId)
      let templateId = set.numTemplates()
      set.addTemplate(<-template)
      emit TemplateAddedToSet(setId: setId, templateId: templateId)
    }

    // ========================================================================
    // Minting
    // ========================================================================

    access(self) fun _getTemplateMutable(_ setId: Int, _ templateId: Int):
      &MutableMetadataTemplate.Template{MutableMetadataTemplate.Public,
        MutableMetadataTemplate.Private} {
      return self._getSetMutable(setId).getTemplateMutable(templateId)
    }

    pub fun lockTemplate(setId: Int, templateId: Int) {
      self._getTemplateMutable(setId, templateId).lock()
      emit TemplateLocked(setId: setId, templateId: templateId)
    }

    pub fun setTemplateMaxMint(setId: Int, templateId: Int, max: UInt64) {
      self._getTemplateMutable(setId, templateId).setMaxMint(max)
      emit TemplateMaxMintSet(
        setId: setId,
        templateId: templateId,
        maxMint: max
      )
    }

    pub fun mint(setId: Int, templateId: Int): @NonFungibleToken.NFT {
      let template = self._getTemplateMutable(setId, templateId)
      template.registerMint()
      let serial = template.minted()
      let nft <-create NFT(
        setId: setId,
        templateId: templateId,
        serial: serial
      )
      emit NFTMinted(
        id: nft.id,
        setId: setId,
        templateId: templateId,
        serial: serial
      )
      return <-nft
    }

    pub fun mintBulk(
      setId: Int,
      templateId: Int,
      numToMint: UInt64,
    ): @[NonFungibleToken.NFT] {
      pre {
        numToMint > 0: "Must mint at least one NFT"
      }
      let template = self._getTemplateMutable(setId, templateId)
      let nfts: @[NonFungibleToken.NFT] <- []
      var leftToMint = numToMint
      while leftToMint > 0 {
        template.registerMint()
        let serial = template.minted()
        let nft <-create NFT(
          setId: setId,
          templateId: templateId,
          serial: serial
        )
        emit NFTMinted(
          id: nft.id,
          setId: setId,
          templateId: templateId,
          serial: serial
        )
        nfts.append(<-nft)
        leftToMint = leftToMint - 1
      }
      return <-nfts
    }

    // ========================================================================
    // NFT metadata
    // ========================================================================

    access(self) fun _getNFTMetadata(_ setId: Int, _ templateId: Int):
      &MutableMetadata.Metadata{MutableMetadata.Public,
        MutableMetadata.Private
      } {
        return self._getTemplateMutable(setId, templateId).metadataMutable()
    }

    pub fun lockNFTMetadata(setId: Int, templateId: Int) {
      self._getNFTMetadata(setId, templateId).lock()
      emit NFTMetadataLocked(setId: setId, templateId: templateId)
    }

    pub fun modifyNFTMetadata(setId: Int, templateId: Int): auth &AnyStruct {
      emit NFTMetadataModified(setId: setId, templateId: templateId)
      return self._getNFTMetadata(setId, templateId).getMutable()
    }

    pub fun replaceNFTMetadata(setId: Int, templateId: Int, new: AnyStruct) {
      self._getNFTMetadata(setId, templateId).replace(new)
      emit NFTMetadataModified(setId: setId, templateId: templateId)
    }
  }

  // ========================================================================
  // Contract functions
  // ========================================================================

  pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
    return NiftoryNFTRegistry
      .getNFTManagerPublic(
        GreatApeEscape.REGISTRY_ADDRESS,
        GreatApeEscape.REGISTRY_BRAND
      )
  }

  pub fun getViews(): [Type] {
    let possibleViews = [
      Type<MetadataViews.NFTCollectionDisplay>(),
      Type<MetadataViews.ExternalURL>()
    ]
    let views: [Type] = [Type<MetadataViews.NFTCollectionData>()]

    let viewManager = self.contract().getMetadataViewsManagerPublic()
    for view in possibleViews {
      if viewManager.inspectView(view: view) != nil {
        views.append(view)
      }
    }
    return views
  }

  pub fun resolveView(_ view: Type): AnyStruct? {
    let viewManager = self.contract().getMetadataViewsManagerPublic()
    switch view {

      case Type<MetadataViews.NFTCollectionData>():
        return self.contract().getNFTCollectionData()

      case Type<MetadataViews.NFTCollectionDisplay>():
        let maybeView = viewManager.inspectView(
          view: Type<MetadataViews.NFTCollectionDisplay>()
        )
        if maybeView == nil {
          return nil
        }
        let view = maybeView!

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver

          // External URL
          let externalURL = MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultExternalURLPrefix,
              uri: resolver.defaultExternalURL
            )
          )

          // Square image
          let squareImageURL = NiftoryMetadataViewsResolvers._prefixUri(
            allowedPrefixes:
              NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
            default: resolver.defaultSquareImagePrefix,
            uri: resolver.defaultSquareImage
          )
          let squareImageMediaType = resolver.defaultSquareImageMediaType
          let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: squareImageURL),
            mediaType: squareImageMediaType
          )

          // Banner image
          let bannerImageURL = NiftoryMetadataViewsResolvers._prefixUri(
            allowedPrefixes:
              NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
            default: resolver.defaultBannerImagePrefix,
            uri: resolver.defaultBannerImage
          )
          let bannerImageMediaType = resolver.defaultBannerImageMediaType
          let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
              url: bannerImageURL
            ),
            mediaType: bannerImageMediaType
          )

          return MetadataViews.NFTCollectionDisplay(
            name: resolver.defaultName,
            description: resolver.defaultDescription,
            externalURL: externalURL,
            squareImage: squareImage,
            bannerImage: bannerImage,
            socials: {}

          )
        }

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolverWithIpfsGateway>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolverWithIpfsGateway

          // External URL
          let externalURL = MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultExternalURLPrefix,
              uri: resolver.defaultExternalURL
            )
          )

          // Square image
          let squareImageURL = NiftoryMetadataViewsResolvers._useIpfsGateway(
            ipfsGateway: resolver.ipfsGateway,
            uri: NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultSquareImagePrefix,
              uri: resolver.defaultSquareImage
            )
        )
          let squareImageMediaType = resolver.defaultSquareImageMediaType
          let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: squareImageURL),
            mediaType: squareImageMediaType
          )

          // Banner image
          let bannerImageURL = NiftoryMetadataViewsResolvers._useIpfsGateway(
            ipfsGateway: resolver.ipfsGateway,
            uri: NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultBannerImagePrefix,
              uri: resolver.defaultBannerImage
            )
          )
          let bannerImageMediaType = resolver.defaultBannerImageMediaType
          let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
              url: bannerImageURL
            ),
            mediaType: bannerImageMediaType
          )

          return MetadataViews.NFTCollectionDisplay(
            name: resolver.defaultName,
            description: resolver.defaultDescription,
            externalURL: externalURL,
            squareImage: squareImage,
            bannerImage: bannerImage,
            socials: {}
          )
        }

        return nil

      case Type<MetadataViews.ExternalURL>():
        let maybeView = viewManager.inspectView(
          view: Type<MetadataViews.ExternalURL>()
        )
        if maybeView == nil {
          return nil
        }
        let view = maybeView!

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.ExternalURLResolver>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.ExternalURLResolver
          return MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultPrefix,
              uri: resolver.defaultURL
            )
          )
        }

        return nil
      }
      return nil

  }

  // ========================================================================
  // Init
  // ========================================================================

  init(
    nftManagerProxy: &{
      NiftoryNonFungibleTokenProxy.Public,
      NiftoryNonFungibleTokenProxy.Private
    }
  ) {

    let record = NiftoryNFTRegistry.generateRecord(
      account: self.account.address,
      project: "clo6ms6vf000kkw0vlwsjtin9_GreatApeEscape"
    )

    self.REGISTRY_ADDRESS = 0x32d62d5c43ad1038
    self.REGISTRY_BRAND = "clo6ms6vf000kkw0vlwsjtin9_GreatApeEscape"

    self.COLLECTION_PUBLIC_PATH = record.collectionPaths.public
    self.COLLECTION_PRIVATE_PATH = record.collectionPaths.private
    self.COLLECTION_STORAGE_PATH = record.collectionPaths.storage

    // No metadata to start with
    self.metadata = nil

    // Initialize the total supply to 0.
    self.totalSupply = 0

    // The Manager for this NFT
    //
    // NFT Manager storage
    let nftManager <- create Manager()

    // Save a MutableSetManager to this contract's storage, as the source of
    // this NFT contract's metadata.
    //
    // MutableMetadataSetManager storage
    self
      .account
      .save<@MutableMetadataSetManager.Manager>(
        <-MutableMetadataSetManager.create(
          name: "GreatApeEscape",
          description: "The set manager for GreatApeEscape."
        ),
        to: record.setManager.paths.storage
      )

    // MutableMetadataSetManager public
    self
      .account
      .link<&MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public}>(
        record.setManager.paths.public,
        target: record.setManager.paths.storage
      )

    // MutableMetadataSetManager private
    self
      .account
      .link<&
        MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public,
        MutableMetadataSetManager.Private
      }>(
        record.setManager.paths.private,
        target: record.setManager.paths.storage
      )

    // Save a MetadataViewsManager to this contract's storage, which will
    // allow observers to inspect standardized metadata through any of its
    // configured MetadataViews resolvers.
    //
    // MetadataViewsManager storage
    self
      .account
      .save<@MetadataViewsManager.Manager>(
        <-MetadataViewsManager.create(),
        to: record.metadataViewsManager.paths.storage
      )

    // MetadataViewsManager public
    self
      .account
      .link<&MetadataViewsManager.Manager{MetadataViewsManager.Public}>(
        record.metadataViewsManager.paths.public,
        target: record.metadataViewsManager.paths.storage
      )

    // MetadataViewsManager private
    self
      .account
      .link<&
        MetadataViewsManager.Manager{MetadataViewsManager.Private,
        MetadataViewsManager.Public
      }>(
        record.metadataViewsManager.paths.private,
        target: record.metadataViewsManager.paths.storage
      )

    let contractName = "GreatApeEscape"

    // Royalties
    let royaltiesResolver = NiftoryMetadataViewsResolvers.RoyaltiesResolver(
        royalties: MetadataViews.Royalties([])
    )
    nftManager.setMetadataViewsResolver(royaltiesResolver)

    // Collection Data
    let collectionDataResolver
        = NiftoryMetadataViewsResolvers.NFTCollectionDataResolver()
    nftManager.setMetadataViewsResolver(collectionDataResolver)

    // Display
    let displayResolver = NiftoryMetadataViewsResolvers.DisplayResolver(
        "title",
        contractName.concat("NFT"),
        "description",
        contractName.concat(" NFT"),
        "mediaUrl",
        "ipfs://",
        "ipfs://bafybeig6la3me5x3veull7jzxmwle4sfuaguou2is3o3z44ayhe7ihlqpa/NiftoryBanner.png"
    )
    nftManager.setMetadataViewsResolver(displayResolver)

    // Collection Display
    let collectionResolver = NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver(
        "title",
        contractName,
        "description",
        contractName.concat(" Collection"),
        "domainUrl",
        "https://",
        "https://niftory.com",
        "squareImage",
        "ipfs://",
        "ipfs://bafybeihc76uodw2at2xi2l5jydpvscj5ophfpqgblbrmsfpeffhcmgdtl4/squareImage.png",
        "squareImageMediaType",
        "image/png",
        "bannerImage",
        "ipfs://",
        "ipfs://bafybeig6la3me5x3veull7jzxmwle4sfuaguou2is3o3z44ayhe7ihlqpa/NiftoryBanner.png",
        "bannerImageMediaType",
        "image/png",
        []
    )
    nftManager.setMetadataViewsResolver(collectionResolver)

    // ExternalURL
    let externalURLResolver = NiftoryMetadataViewsResolvers.ExternalURLResolver(
        "domainUrl",
        "https://",
        "https://niftory.com"
    )
    nftManager.setMetadataViewsResolver(externalURLResolver)

    // Save NFT Manager
    self
      .account
      .save<@Manager>(
        <-nftManager,
        to: record.nftManager.paths.storage
      )

    // NFT Manager public
    self
      .account
      .link<&{NiftoryNonFungibleToken.ManagerPublic}>(
        record.nftManager.paths.public,
        target: record.nftManager.paths.storage
      )

    // NFT Manager private
    self
      .account
      .link<&
        Manager{NiftoryNonFungibleToken.ManagerPublic,
        NiftoryNonFungibleToken.ManagerPrivate
      }>(
        record.nftManager.paths.private,
        target: record.nftManager.paths.storage
      )

      nftManagerProxy.add(
        registryAddress: self.REGISTRY_ADDRESS,
        brand: self.REGISTRY_BRAND,
        cap: self.account
              .getCapability<&{
                NiftoryNonFungibleToken.ManagerPrivate,
                NiftoryNonFungibleToken.ManagerPublic
              }>(
                record.nftManager.paths.private
              )
      )
  }
}"
-------
"pub contract TransactionTypes {
    /*
    pub fun createListing(
        nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,
        paymentReceiver: Capability<&{FungibleToken.Receiver}>,
        nftType: Type,
        nftID: UInt64,
        salePaymentVaultType: Type,
        price: UFix64,
        customID: String?,
        expiry: UInt64,
        buyer: Address?
    ): UInt64
    */
    pub struct StorefrontListingRequest {
        pub let nftProviderAddress: Address
        pub let nftProviderPathIdentifier: String
        pub let paymentReceiverAddress: Address
        pub let paymentReceiverPathIdentifier: String
        pub let nftTypeIdentifier: String
        pub let nftID: UInt64
        pub let salePaymentVaultTypeIdentifier: String
        pub let price: UFix64
        pub let customID: String?
        pub let expiry: UInt64
        pub let buyerAddress: Address?

        init(
            nftProviderAddress: Address,
            nftProviderPathIdentifier: String,
            paymentReceiverAddress: Address,
            paymentReceiverPathIdentifier: String,
            nftTypeIdentifier: String,
            nftID: UInt64,
            salePaymentVaultTypeIdentifier: String,
            price: UFix64,
            customID: String?,
            expiry: UInt64,
            buyerAddress: Address?
        ) {
            self.nftProviderAddress = nftProviderAddress
            self.nftProviderPathIdentifier = nftProviderPathIdentifier
            self.paymentReceiverAddress = paymentReceiverAddress
            self.paymentReceiverPathIdentifier = paymentReceiverPathIdentifier
            self.nftTypeIdentifier = nftTypeIdentifier
            self.nftID = nftID
            self.salePaymentVaultTypeIdentifier = salePaymentVaultTypeIdentifier
            self.price = price
            self.customID = customID
            self.expiry = expiry
            self.buyerAddress = buyerAddress
        }
    }
}"
-------
"/*
 * Copyright (c) 2021 24Karat. All rights reserved.
 *
 * SPDX-License-Identifier: MIT
 *
 * This file is part of Project: 24karat flow contract (https://github.com/24karat-io/flow-contract)
 *
 * This source code is licensed under the MIT License found in the
 * LICENSE file in the root directory of this source tree or at
 * https://opensource.org/licenses/MIT.
 */

import FungibleToken from 0xf233dcee88fe0abe

pub contract VO_LEGAL: FungibleToken {
    // TokensInitialized
    //
    // The event that is emitted when the contract is created
    pub event TokensInitialized(initialSupply: UFix64)

    // TokensWithdrawn
    //
    // The event that is emitted when tokens are withdrawn from a Vault
    pub event TokensWithdrawn(amount: UFix64, from: Address?)

    // TokensDeposited
    //
    // The event that is emitted when tokens are deposited to a Vault
    pub event TokensDeposited(amount: UFix64, to: Address?)

    // TokensMinted
    //
    // The event that is emitted when new tokens are minted
    pub event TokensMinted(amount: UFix64)

    // TokensBurned
    //
    // The event that is emitted when tokens are destroyed
    pub event TokensBurned(amount: UFix64)

    // MinterCreated
    //
    // The event that is emitted when a new minter resource is created
    pub event MinterCreated(allowedAmount: UFix64)

    // Named paths
    //
    pub let VaultStoragePath: StoragePath
    pub let ReceiverPublicPath: PublicPath
    pub let BalancePublicPath: PublicPath
    pub let AdminStoragePath: StoragePath

    // Total supply of token in existence
    pub var totalSupply: UFix64

    // Vault
    //
    // Each user stores an instance of only the Vault in their storage
    // The functions in the Vault and governed by the pre and post conditions
    // in FungibleToken when they are called.
    // The checks happen at runtime whenever a function is called.
    //
    // Resources can only be created in the context of the contract that they
    // are defined in, so there is no way for a malicious user to create Vaults
    // out of thin air. A special Minter resource needs to be defined to mint
    // new tokens.
    //
    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {

        // The total balance of this vault
        pub var balance: UFix64

        // initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        // withdraw
        //
        // Function that takes an amount as an argument
        // and withdraws that amount from the Vault.
        //
        // It creates a new temporary Vault that is used to hold
        // the money that is being transferred. It returns the newly
        // created Vault to the context that called so it can be deposited
        // elsewhere.
        //
        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)
            return <-create Vault(balance: amount)
        }

        // deposit
        //
        // Function that takes a Vault object as an argument and adds
        // its balance to the balance of the owners Vault.
        //
        // It is allowed to destroy the sent Vault because the Vault
        // was a temporary holder of the tokens. The Vault's balance has
        // been consumed and therefore can be destroyed.
        //
        pub fun deposit(from: @FungibleToken.Vault) {
            let vault <- from as! @VO_LEGAL.Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)
            vault.balance = 0.0
            destroy vault
        }

        destroy() {
            VO_LEGAL.totalSupply = VO_LEGAL.totalSupply - self.balance
            if(self.balance > 0.0) {
                emit TokensBurned(amount: self.balance)
            }
        }
    }

    // createEmptyVault
    //
    // Function that creates a new Vault with a balance of zero
    // and returns it to the calling context. A user must call this function
    // and store the returned Vault in their storage in order to allow their
    // account to be able to receive deposits of this token type.
    //
    pub fun createEmptyVault(): @Vault {
        return <-create Vault(balance: 0.0)
    }

    pub resource Administrator {

        // createNewMinter
        //
        // Function that creates and returns a new minter resource
        //
        pub fun createNewMinter(allowedAmount: UFix64): @Minter {
            emit MinterCreated(allowedAmount: allowedAmount)
            return <-create Minter(allowedAmount: allowedAmount)
        }
    }

    // Minter
    //
    // Resource object that token admin accounts can hold to mint new tokens.
    //
    pub resource Minter {

        // The amount of tokens that the minter is allowed to mint
        pub var allowedAmount: UFix64

        // mintTokens
        //
        // Function that mints new tokens, adds them to the total supply,
        // and returns them to the calling context.
        //
        pub fun mintTokens(amount: UFix64): @VO_LEGAL.Vault {
            pre {
                amount > 0.0: "Amount minted must be greater than zero"
                amount <= self.allowedAmount: "Amount minted must be less than the allowed amount"
            }
            VO_LEGAL.totalSupply = VO_LEGAL.totalSupply + amount
            self.allowedAmount = self.allowedAmount - amount
            emit TokensMinted(amount: amount)
            return <-create Vault(balance: amount)
        }

        init(allowedAmount: UFix64) {
            self.allowedAmount = allowedAmount
        }
    }

    init() {
        // Set our named paths.
        self.VaultStoragePath = /storage/VO_LEGALVault
        self.ReceiverPublicPath = /public/VO_LEGALReceiver
        self.BalancePublicPath = /public/VO_LEGALBalance
        self.AdminStoragePath = /storage/VO_LEGALAdmin

        // Initialize contract state.
        self.totalSupply = 0.0

        // Create the one true Admin object and deposit it into the conttract account.
        let admin <- create Administrator()
        self.account.save(<-admin, to: self.AdminStoragePath)

        // Emit an event that shows that the contract was initialized.
        emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
"
-------
"/*
 * Copyright (c) 2021 24Karat. All rights reserved.
 *
 * SPDX-License-Identifier: MIT
 *
 * This file is part of Project: 24karat flow contract (https://github.com/24karat-io/flow-contract)
 *
 * This source code is licensed under the MIT License found in the
 * LICENSE file in the root directory of this source tree or at
 * https://opensource.org/licenses/MIT.
 */

import FungibleToken from 0xf233dcee88fe0abe

pub contract VO_GA: FungibleToken {
    // TokensInitialized
    //
    // The event that is emitted when the contract is created
    pub event TokensInitialized(initialSupply: UFix64)

    // TokensWithdrawn
    //
    // The event that is emitted when tokens are withdrawn from a Vault
    pub event TokensWithdrawn(amount: UFix64, from: Address?)

    // TokensDeposited
    //
    // The event that is emitted when tokens are deposited to a Vault
    pub event TokensDeposited(amount: UFix64, to: Address?)

    // TokensMinted
    //
    // The event that is emitted when new tokens are minted
    pub event TokensMinted(amount: UFix64)

    // TokensBurned
    //
    // The event that is emitted when tokens are destroyed
    pub event TokensBurned(amount: UFix64)

    // MinterCreated
    //
    // The event that is emitted when a new minter resource is created
    pub event MinterCreated(allowedAmount: UFix64)

    // Named paths
    //
    pub let VaultStoragePath: StoragePath
    pub let ReceiverPublicPath: PublicPath
    pub let BalancePublicPath: PublicPath
    pub let AdminStoragePath: StoragePath

    // Total supply of token in existence
    pub var totalSupply: UFix64

    // Vault
    //
    // Each user stores an instance of only the Vault in their storage
    // The functions in the Vault and governed by the pre and post conditions
    // in FungibleToken when they are called.
    // The checks happen at runtime whenever a function is called.
    //
    // Resources can only be created in the context of the contract that they
    // are defined in, so there is no way for a malicious user to create Vaults
    // out of thin air. A special Minter resource needs to be defined to mint
    // new tokens.
    //
    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {

        // The total balance of this vault
        pub var balance: UFix64

        // initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        // withdraw
        //
        // Function that takes an amount as an argument
        // and withdraws that amount from the Vault.
        //
        // It creates a new temporary Vault that is used to hold
        // the money that is being transferred. It returns the newly
        // created Vault to the context that called so it can be deposited
        // elsewhere.
        //
        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)
            return <-create Vault(balance: amount)
        }

        // deposit
        //
        // Function that takes a Vault object as an argument and adds
        // its balance to the balance of the owners Vault.
        //
        // It is allowed to destroy the sent Vault because the Vault
        // was a temporary holder of the tokens. The Vault's balance has
        // been consumed and therefore can be destroyed.
        //
        pub fun deposit(from: @FungibleToken.Vault) {
            let vault <- from as! @VO_GA.Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)
            vault.balance = 0.0
            destroy vault
        }

        destroy() {
            VO_GA.totalSupply = VO_GA.totalSupply - self.balance
            if(self.balance > 0.0) {
                emit TokensBurned(amount: self.balance)
            }
        }
    }

    // createEmptyVault
    //
    // Function that creates a new Vault with a balance of zero
    // and returns it to the calling context. A user must call this function
    // and store the returned Vault in their storage in order to allow their
    // account to be able to receive deposits of this token type.
    //
    pub fun createEmptyVault(): @Vault {
        return <-create Vault(balance: 0.0)
    }

    pub resource Administrator {

        // createNewMinter
        //
        // Function that creates and returns a new minter resource
        //
        pub fun createNewMinter(allowedAmount: UFix64): @Minter {
            emit MinterCreated(allowedAmount: allowedAmount)
            return <-create Minter(allowedAmount: allowedAmount)
        }
    }

    // Minter
    //
    // Resource object that token admin accounts can hold to mint new tokens.
    //
    pub resource Minter {

        // The amount of tokens that the minter is allowed to mint
        pub var allowedAmount: UFix64

        // mintTokens
        //
        // Function that mints new tokens, adds them to the total supply,
        // and returns them to the calling context.
        //
        pub fun mintTokens(amount: UFix64): @VO_GA.Vault {
            pre {
                amount > 0.0: "Amount minted must be greater than zero"
                amount <= self.allowedAmount: "Amount minted must be less than the allowed amount"
            }
            VO_GA.totalSupply = VO_GA.totalSupply + amount
            self.allowedAmount = self.allowedAmount - amount
            emit TokensMinted(amount: amount)
            return <-create Vault(balance: amount)
        }

        init(allowedAmount: UFix64) {
            self.allowedAmount = allowedAmount
        }
    }

    init() {
        // Set our named paths.
        self.VaultStoragePath = /storage/VO_GAVault
        self.ReceiverPublicPath = /public/VO_GAReceiver
        self.BalancePublicPath = /public/VO_GABalance
        self.AdminStoragePath = /storage/VO_GAAdmin

        // Initialize contract state.
        self.totalSupply = 0.0

        // Create the one true Admin object and deposit it into the conttract account.
        let admin <- create Administrator()
        self.account.save(<-admin, to: self.AdminStoragePath)

        // Emit an event that shows that the contract was initialized.
        emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
"
-------
"// You can create concrete poems with these alphabet resources.

pub contract ConcreteAlphabets {
    pub resource A {}
    pub resource B {}
    pub resource C {}
    pub resource D {}
    pub resource E {}
    pub resource F {}
    pub resource G {}
    pub resource H {}
    pub resource I {}
    pub resource J {}
    pub resource K {}
    pub resource L {}
    pub resource M {}
    pub resource N {}
    pub resource O {}
    pub resource P {}
    pub resource Q {}
    pub resource R {}
    pub resource S {}
    pub resource T {}
    pub resource U {}
    pub resource V {}
    pub resource W {}
    pub resource X {}
    pub resource Y {}
    pub resource Z {}
    pub resource a {}
    pub resource b {}
    pub resource c {}
    pub resource d {}
    pub resource e {}
    pub resource f {}
    pub resource g {}
    pub resource h {}
    pub resource i {}
    pub resource j {}
    pub resource k {}
    pub resource l {}
    pub resource m {}
    pub resource n {}
    pub resource o {}
    pub resource p {}
    pub resource q {}
    pub resource r {}
    pub resource s {}
    pub resource t {}
    pub resource u {}
    pub resource v {}
    pub resource w {}
    pub resource x {}
    pub resource y {}
    pub resource z {}
    pub resource _ {}

    pub fun newLetter(_ ch: Character): @AnyResource {
        switch ch {
            case "A": return <- create A()
            case "B": return <- create B()
            case "C": return <- create C()
            case "D": return <- create D()
            case "E": return <- create E()
            case "F": return <- create F()
            case "G": return <- create G()
            case "H": return <- create H()
            case "I": return <- create I()
            case "J": return <- create J()
            case "K": return <- create K()
            case "L": return <- create L()
            case "M": return <- create M()
            case "N": return <- create N()
            case "O": return <- create O()
            case "P": return <- create P()
            case "Q": return <- create Q()
            case "R": return <- create R()
            case "S": return <- create S()
            case "T": return <- create T()
            case "U": return <- create U()
            case "V": return <- create V()
            case "W": return <- create W()
            case "X": return <- create X()
            case "Y": return <- create Y()
            case "Z": return <- create Z()
            case "a": return <- create a()
            case "b": return <- create b()
            case "c": return <- create c()
            case "d": return <- create d()
            case "e": return <- create e()
            case "f": return <- create f()
            case "g": return <- create g()
            case "h": return <- create h()
            case "i": return <- create i()
            case "j": return <- create j()
            case "k": return <- create k()
            case "l": return <- create l()
            case "m": return <- create m()
            case "n": return <- create n()
            case "o": return <- create o()
            case "p": return <- create p()
            case "q": return <- create q()
            case "r": return <- create r()
            case "s": return <- create s()
            case "t": return <- create t()
            case "u": return <- create u()
            case "v": return <- create v()
            case "w": return <- create w()
            case "x": return <- create x()
            case "y": return <- create y()
            case "z": return <- create z()
            default: return <- create _()
        }
    }

    pub fun newText(_ str: String): @[AnyResource] {
        var res: @[AnyResource] <- []
        for ch in str {
            res.append(<- ConcreteAlphabets.newLetter(ch))
        }
        return <- res
    }

    pub fun toCharacter(_ letter: &AnyResource): Character {
        switch letter.getType() {
            case Type<@A>(): return "A"
            case Type<@B>(): return "B"
            case Type<@C>(): return "C"
            case Type<@D>(): return "D"
            case Type<@E>(): return "E"
            case Type<@F>(): return "F"
            case Type<@G>(): return "G"
            case Type<@H>(): return "H"
            case Type<@I>(): return "I"
            case Type<@J>(): return "J"
            case Type<@K>(): return "K"
            case Type<@L>(): return "L"
            case Type<@M>(): return "M"
            case Type<@N>(): return "N"
            case Type<@O>(): return "O"
            case Type<@P>(): return "P"
            case Type<@Q>(): return "Q"
            case Type<@R>(): return "R"
            case Type<@S>(): return "S"
            case Type<@T>(): return "T"
            case Type<@U>(): return "U"
            case Type<@V>(): return "V"
            case Type<@W>(): return "W"
            case Type<@X>(): return "X"
            case Type<@Y>(): return "Y"
            case Type<@Z>(): return "Z"
            case Type<@a>(): return "a"
            case Type<@b>(): return "b"
            case Type<@c>(): return "c"
            case Type<@d>(): return "d"
            case Type<@e>(): return "e"
            case Type<@f>(): return "f"
            case Type<@g>(): return "g"
            case Type<@h>(): return "h"
            case Type<@i>(): return "i"
            case Type<@j>(): return "j"
            case Type<@k>(): return "k"
            case Type<@l>(): return "l"
            case Type<@m>(): return "m"
            case Type<@n>(): return "n"
            case Type<@o>(): return "o"
            case Type<@p>(): return "p"
            case Type<@q>(): return "q"
            case Type<@r>(): return "r"
            case Type<@s>(): return "s"
            case Type<@t>(): return "t"
            case Type<@u>(): return "u"
            case Type<@v>(): return "v"
            case Type<@w>(): return "w"
            case Type<@x>(): return "x"
            case Type<@y>(): return "y"
            case Type<@z>(): return "z"
            case Type<@_>(): return " "
            default: return "?"
        }
    }

    pub fun toString(_ text: &[AnyResource]): String {
        var res: String = ""
        var i = 0
        while i < text.length {
            let letter = &text[i] as &AnyResource
            res = res.concat(ConcreteAlphabets.toCharacter(letter).toString())
            i = i + 1
        }
        return res
    }
}
"
-------
"/*
 * Copyright (c) 2021 24Karat. All rights reserved.
 *
 * SPDX-License-Identifier: MIT
 *
 * This file is part of Project: 24karat flow contract (https://github.com/24karat-io/flow-contract)
 *
 * This source code is licensed under the MIT License found in the
 * LICENSE file in the root directory of this source tree or at
 * https://opensource.org/licenses/MIT.
 */

import FungibleToken from 0xf233dcee88fe0abe

pub contract VO_DOCUMENTATION: FungibleToken {
    // TokensInitialized
    //
    // The event that is emitted when the contract is created
    pub event TokensInitialized(initialSupply: UFix64)

    // TokensWithdrawn
    //
    // The event that is emitted when tokens are withdrawn from a Vault
    pub event TokensWithdrawn(amount: UFix64, from: Address?)

    // TokensDeposited
    //
    // The event that is emitted when tokens are deposited to a Vault
    pub event TokensDeposited(amount: UFix64, to: Address?)

    // TokensMinted
    //
    // The event that is emitted when new tokens are minted
    pub event TokensMinted(amount: UFix64)

    // TokensBurned
    //
    // The event that is emitted when tokens are destroyed
    pub event TokensBurned(amount: UFix64)

    // MinterCreated
    //
    // The event that is emitted when a new minter resource is created
    pub event MinterCreated(allowedAmount: UFix64)

    // Named paths
    //
    pub let VaultStoragePath: StoragePath
    pub let ReceiverPublicPath: PublicPath
    pub let BalancePublicPath: PublicPath
    pub let AdminStoragePath: StoragePath

    // Total supply of token in existence
    pub var totalSupply: UFix64

    // Vault
    //
    // Each user stores an instance of only the Vault in their storage
    // The functions in the Vault and governed by the pre and post conditions
    // in FungibleToken when they are called.
    // The checks happen at runtime whenever a function is called.
    //
    // Resources can only be created in the context of the contract that they
    // are defined in, so there is no way for a malicious user to create Vaults
    // out of thin air. A special Minter resource needs to be defined to mint
    // new tokens.
    //
    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {

        // The total balance of this vault
        pub var balance: UFix64

        // initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        // withdraw
        //
        // Function that takes an amount as an argument
        // and withdraws that amount from the Vault.
        //
        // It creates a new temporary Vault that is used to hold
        // the money that is being transferred. It returns the newly
        // created Vault to the context that called so it can be deposited
        // elsewhere.
        //
        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)
            return <-create Vault(balance: amount)
        }

        // deposit
        //
        // Function that takes a Vault object as an argument and adds
        // its balance to the balance of the owners Vault.
        //
        // It is allowed to destroy the sent Vault because the Vault
        // was a temporary holder of the tokens. The Vault's balance has
        // been consumed and therefore can be destroyed.
        //
        pub fun deposit(from: @FungibleToken.Vault) {
            let vault <- from as! @VO_DOCUMENTATION.Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)
            vault.balance = 0.0
            destroy vault
        }

        destroy() {
            VO_DOCUMENTATION.totalSupply = VO_DOCUMENTATION.totalSupply - self.balance
            if(self.balance > 0.0) {
                emit TokensBurned(amount: self.balance)
            }
        }
    }

    // createEmptyVault
    //
    // Function that creates a new Vault with a balance of zero
    // and returns it to the calling context. A user must call this function
    // and store the returned Vault in their storage in order to allow their
    // account to be able to receive deposits of this token type.
    //
    pub fun createEmptyVault(): @Vault {
        return <-create Vault(balance: 0.0)
    }

    pub resource Administrator {

        // createNewMinter
        //
        // Function that creates and returns a new minter resource
        //
        pub fun createNewMinter(allowedAmount: UFix64): @Minter {
            emit MinterCreated(allowedAmount: allowedAmount)
            return <-create Minter(allowedAmount: allowedAmount)
        }
    }

    // Minter
    //
    // Resource object that token admin accounts can hold to mint new tokens.
    //
    pub resource Minter {

        // The amount of tokens that the minter is allowed to mint
        pub var allowedAmount: UFix64

        // mintTokens
        //
        // Function that mints new tokens, adds them to the total supply,
        // and returns them to the calling context.
        //
        pub fun mintTokens(amount: UFix64): @VO_DOCUMENTATION.Vault {
            pre {
                amount > 0.0: "Amount minted must be greater than zero"
                amount <= self.allowedAmount: "Amount minted must be less than the allowed amount"
            }
            VO_DOCUMENTATION.totalSupply = VO_DOCUMENTATION.totalSupply + amount
            self.allowedAmount = self.allowedAmount - amount
            emit TokensMinted(amount: amount)
            return <-create Vault(balance: amount)
        }

        init(allowedAmount: UFix64) {
            self.allowedAmount = allowedAmount
        }
    }

    init() {
        // Set our named paths.
        self.VaultStoragePath = /storage/VO_DOCUMENTATIONVault
        self.ReceiverPublicPath = /public/VO_DOCUMENTATIONReceiver
        self.BalancePublicPath = /public/VO_DOCUMENTATIONBalance
        self.AdminStoragePath = /storage/VO_DOCUMENTATIONAdmin

        // Initialize contract state.
        self.totalSupply = 0.0

        // Create the one true Admin object and deposit it into the conttract account.
        let admin <- create Administrator()
        self.account.save(<-admin, to: self.AdminStoragePath)

        // Emit an event that shows that the contract was initialized.
        emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
"
-------
"/*
 * Copyright (c) 2021 24Karat. All rights reserved.
 *
 * SPDX-License-Identifier: MIT
 *
 * This file is part of Project: 24karat flow contract (https://github.com/24karat-io/flow-contract)
 *
 * This source code is licensed under the MIT License found in the
 * LICENSE file in the root directory of this source tree or at
 * https://opensource.org/licenses/MIT.
 */

import FungibleToken from 0xf233dcee88fe0abe

pub contract VO_IDEATION: FungibleToken {
    // TokensInitialized
    //
    // The event that is emitted when the contract is created
    pub event TokensInitialized(initialSupply: UFix64)

    // TokensWithdrawn
    //
    // The event that is emitted when tokens are withdrawn from a Vault
    pub event TokensWithdrawn(amount: UFix64, from: Address?)

    // TokensDeposited
    //
    // The event that is emitted when tokens are deposited to a Vault
    pub event TokensDeposited(amount: UFix64, to: Address?)

    // TokensMinted
    //
    // The event that is emitted when new tokens are minted
    pub event TokensMinted(amount: UFix64)

    // TokensBurned
    //
    // The event that is emitted when tokens are destroyed
    pub event TokensBurned(amount: UFix64)

    // MinterCreated
    //
    // The event that is emitted when a new minter resource is created
    pub event MinterCreated(allowedAmount: UFix64)

    // Named paths
    //
    pub let VaultStoragePath: StoragePath
    pub let ReceiverPublicPath: PublicPath
    pub let BalancePublicPath: PublicPath
    pub let AdminStoragePath: StoragePath

    // Total supply of token in existence
    pub var totalSupply: UFix64

    // Vault
    //
    // Each user stores an instance of only the Vault in their storage
    // The functions in the Vault and governed by the pre and post conditions
    // in FungibleToken when they are called.
    // The checks happen at runtime whenever a function is called.
    //
    // Resources can only be created in the context of the contract that they
    // are defined in, so there is no way for a malicious user to create Vaults
    // out of thin air. A special Minter resource needs to be defined to mint
    // new tokens.
    //
    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {

        // The total balance of this vault
        pub var balance: UFix64

        // initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        // withdraw
        //
        // Function that takes an amount as an argument
        // and withdraws that amount from the Vault.
        //
        // It creates a new temporary Vault that is used to hold
        // the money that is being transferred. It returns the newly
        // created Vault to the context that called so it can be deposited
        // elsewhere.
        //
        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)
            return <-create Vault(balance: amount)
        }

        // deposit
        //
        // Function that takes a Vault object as an argument and adds
        // its balance to the balance of the owners Vault.
        //
        // It is allowed to destroy the sent Vault because the Vault
        // was a temporary holder of the tokens. The Vault's balance has
        // been consumed and therefore can be destroyed.
        //
        pub fun deposit(from: @FungibleToken.Vault) {
            let vault <- from as! @VO_IDEATION.Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)
            vault.balance = 0.0
            destroy vault
        }

        destroy() {
            VO_IDEATION.totalSupply = VO_IDEATION.totalSupply - self.balance
            if(self.balance > 0.0) {
                emit TokensBurned(amount: self.balance)
            }
        }
    }

    // createEmptyVault
    //
    // Function that creates a new Vault with a balance of zero
    // and returns it to the calling context. A user must call this function
    // and store the returned Vault in their storage in order to allow their
    // account to be able to receive deposits of this token type.
    //
    pub fun createEmptyVault(): @Vault {
        return <-create Vault(balance: 0.0)
    }

    pub resource Administrator {

        // createNewMinter
        //
        // Function that creates and returns a new minter resource
        //
        pub fun createNewMinter(allowedAmount: UFix64): @Minter {
            emit MinterCreated(allowedAmount: allowedAmount)
            return <-create Minter(allowedAmount: allowedAmount)
        }
    }

    // Minter
    //
    // Resource object that token admin accounts can hold to mint new tokens.
    //
    pub resource Minter {

        // The amount of tokens that the minter is allowed to mint
        pub var allowedAmount: UFix64

        // mintTokens
        //
        // Function that mints new tokens, adds them to the total supply,
        // and returns them to the calling context.
        //
        pub fun mintTokens(amount: UFix64): @VO_IDEATION.Vault {
            pre {
                amount > 0.0: "Amount minted must be greater than zero"
                amount <= self.allowedAmount: "Amount minted must be less than the allowed amount"
            }
            VO_IDEATION.totalSupply = VO_IDEATION.totalSupply + amount
            self.allowedAmount = self.allowedAmount - amount
            emit TokensMinted(amount: amount)
            return <-create Vault(balance: amount)
        }

        init(allowedAmount: UFix64) {
            self.allowedAmount = allowedAmount
        }
    }

    init() {
        // Set our named paths.
        self.VaultStoragePath = /storage/VO_IDEATIONVault
        self.ReceiverPublicPath = /public/VO_IDEATIONReceiver
        self.BalancePublicPath = /public/VO_IDEATIONBalance
        self.AdminStoragePath = /storage/VO_IDEATIONAdmin

        // Initialize contract state.
        self.totalSupply = 0.0

        // Create the one true Admin object and deposit it into the conttract account.
        let admin <- create Administrator()
        self.account.save(<-admin, to: self.AdminStoragePath)

        // Emit an event that shows that the contract was initialized.
        emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
"
-------
"/// CapabilityFilter defines `Filter`, an interface to sit on top of a ChildAccount's capabilities. Requested
/// capabilities will only return if the filter's `allowed` method returns true.
///
/// Along with the `Filter` interface are three implementations:
/// - `DenylistFilter`  - A filter which contains a mapping of denied Types
/// - `AllowlistFilter` - A filter which contains a mapping of allowed Types
/// - `AllowAllFilter`  - A passthrough, all requested capabilities are allowed
///
pub contract CapabilityFilter {

    /* --- Canonical Paths --- */
    //
    pub let StoragePath: StoragePath
    pub let PublicPath: PublicPath
    pub let PrivatePath: PrivatePath

    /* --- Events --- */
    //
    pub event FilterUpdated(id: UInt64, filterType: Type, type: Type, active: Bool)

    /// `Filter` is a simple interface with methods to determine if a Capability is allowed and retrieve details about
    /// the Filter itself
    ///
    pub resource interface Filter {
        pub fun allowed(cap: Capability): Bool
        pub fun getDetails(): AnyStruct
    }

    /// `DenylistFilter` is a `Filter` which contains a mapping of denied Types
    ///
    pub resource DenylistFilter: Filter {

        /// Represents the underlying types which should not ever be returned by a RestrictedChildAccount. The filter
        /// will borrow a requested capability, and make sure that the type it gets back is not in the list of denied
        /// types
        access(self) let deniedTypes: {Type: Bool}

        /// Adds a type to the mapping of denied types with a value of true
        ///
        /// @param type: The type to add to the denied types mapping
        ///
        pub fun addType(_ type: Type) {
            self.deniedTypes.insert(key: type, true)
            emit FilterUpdated(id: self.uuid, filterType: self.getType(), type: type, active: true)
        }

        /// Removes a type from the mapping of denied types
        ///
        /// @param type: The type to remove from the denied types mapping
        ///
        pub fun removeType(_ type: Type) {
            if let removed = self.deniedTypes.remove(key: type) {
                emit FilterUpdated(id: self.uuid, filterType: self.getType(), type: type, active: false)
            }
        }

        /// Determines if a requested capability is allowed by this `Filter`
        ///
        /// @param cap: The capability to check
        /// @return: true if the capability is allowed, false otherwise
        ///
        pub fun allowed(cap: Capability): Bool {
            if let item = cap.borrow<&AnyResource>() {
                return !self.deniedTypes.containsKey(item.getType())
            }

            return false
        }

        /// Returns details about this filter
        ///
        /// @return A struct containing details about this filter including this Filter's Type indexed on the `type`
        ///         key as well as types denied indexed on the `deniedTypes` key
        ///
        pub fun getDetails(): AnyStruct {
            return {
                "type": self.getType(),
                "deniedTypes": self.deniedTypes.keys
            }
        }

        init() {
            self.deniedTypes = {}
        }
    }

    /// `AllowlistFilter` is a `Filter` which contains a mapping of allowed Types
    ///
    pub resource AllowlistFilter: Filter {
        // allowedTypes
        // Represents the set of underlying types which are allowed to be
        // returned by a RestrictedChildAccount. The filter will borrow
        // a requested capability, and make sure that the type it gets back is
        // in the list of allowed types
        access(self) let allowedTypes: {Type: Bool}

        /// Adds a type to the mapping of allowed types with a value of true
        ///
        /// @param type: The type to add to the allowed types mapping
        ///
        pub fun addType(_ type: Type) {
            self.allowedTypes.insert(key: type, true)
            emit FilterUpdated(id: self.uuid, filterType: self.getType(), type: type, active: true)
        }

        /// Removes a type from the mapping of allowed types
        ///
        /// @param type: The type to remove from the denied types mapping
        ///
        pub fun removeType(_ type: Type) {
            if let removed = self.allowedTypes.remove(key: type) {
                emit FilterUpdated(id: self.uuid, filterType: self.getType(), type: type, active: false)
            }
        }

        /// Determines if a requested capability is allowed by this `Filter`
        ///
        /// @param cap: The capability to check
        /// @return: true if the capability is allowed, false otherwise
        ///
        pub fun allowed(cap: Capability): Bool {
            if let item = cap.borrow<&AnyResource>() {
                return self.allowedTypes.containsKey(item.getType())
            }

            return false
        }

        /// Returns details about this filter
        ///
        /// @return A struct containing details about this filter including this Filter's Type indexed on the `type`
        ///         key as well as types allowed indexed on the `allowedTypes` key
        ///
        pub fun getDetails(): AnyStruct {
            return {
                "type": self.getType(),
                "allowedTypes": self.allowedTypes.keys
            }
        }

        init() {
            self.allowedTypes = {}
        }
    }

    /// AllowAllFilter is a passthrough, all requested capabilities are allowed
    ///
    pub resource AllowAllFilter: Filter {
        /// Determines if a requested capability is allowed by this `Filter`
        ///
        /// @param cap: The capability to check
        /// @return: true since this filter is a passthrough
        ///
        pub fun allowed(cap: Capability): Bool {
            return true
        }

        /// Returns details about this filter
        ///
        /// @return A struct containing details about this filter including this Filter's Type indexed on the `type`
        ///         key
        ///
        pub fun getDetails(): AnyStruct {
            return {
                "type": self.getType()
            }
        }
    }

    /// Creates a new `Filter` of the given type
    ///
    /// @param t: The type of `Filter` to create
    /// @return: A new instance of the given `Filter` type
    ///
    pub fun create(_ t: Type): @AnyResource{Filter} {
        post {
            result.getType() == t
        }

        switch t {
            case Type<@AllowAllFilter>():
                return <- create AllowAllFilter()
            case Type<@AllowlistFilter>():
                return <- create AllowlistFilter()
            case Type<@DenylistFilter>():
                return <- create DenylistFilter()
        }

        panic("unsupported type requested: ".concat(t.identifier))
    }

    init() {
        let identifier = "CapabilityFilter_".concat(self.account.address.toString())

        self.StoragePath = StoragePath(identifier: identifier)!
        self.PublicPath = PublicPath(identifier: identifier)!
        self.PrivatePath = PrivatePath(identifier: identifier)!
    }
}
"
-------
"/// CapabilityDelegator is a contract used to share Capabiltities to other accounts. It is used by the
/// HybridCustody contract to allow more flexible sharing of Capabilities when an app wants to share things
/// that aren't the NFT-standard interface types.
///
/// Inside of CapabilityDelegator is a resource called `Delegator` which maintains a mapping of public and private
/// Capabilities. They cannot and should not be mixed. A public `Delegator` is able to be borrowed by anyone, whereas a
/// private `Delegator` can only be borrowed from the child account when you have access to the full `ChildAccount`
/// resource.
///
pub contract CapabilityDelegator {

    /* --- Canonical Paths --- */
    //
    pub let StoragePath: StoragePath
    pub let PrivatePath: PrivatePath
    pub let PublicPath: PublicPath

    /* --- Events --- */
    //
    pub event DelegatorCreated(id: UInt64)
    pub event DelegatorUpdated(id: UInt64, capabilityType: Type, isPublic: Bool, active: Bool)

    /// Private interface for Capability retrieval
    ///
    pub resource interface GetterPrivate {
        pub fun getPrivateCapability(_ type: Type): Capability? {
            post {
                result == nil || type.isSubtype(of: result.getType()): "incorrect returned capability type"
            }
        }
        pub fun findFirstPrivateType(_ type: Type): Type?
        pub fun getAllPrivate(): [Capability]
    }

    /// Exposes public Capability retrieval
    ///
    pub resource interface GetterPublic {
        pub fun getPublicCapability(_ type: Type): Capability? {
            post {
                result == nil || type.isSubtype(of: result.getType()): "incorrect returned capability type "
            }
        }

        pub fun findFirstPublicType(_ type: Type): Type?
        pub fun getAllPublic(): [Capability]
    }

    /// This Delegator is used to store Capabilities, partitioned by public and private access with corresponding
    /// GetterPublic and GetterPrivate conformances.AccountCapabilityController
    ///
    pub resource Delegator: GetterPublic, GetterPrivate {
        access(self) let privateCapabilities: {Type: Capability}
        access(self) let publicCapabilities: {Type: Capability}

        // ------ Begin Getter methods
        //
        /// Returns the public Capability of the given Type if it exists
        ///
        pub fun getPublicCapability(_ type: Type): Capability? {
            return self.publicCapabilities[type]
        }

        /// Returns the private Capability of the given Type if it exists
        ///
        ///
        /// @param type: Type of the Capability to retrieve
        /// @return Capability of the given Type if it exists, nil otherwise
        ///
        pub fun getPrivateCapability(_ type: Type): Capability? {
            return self.privateCapabilities[type]
        }

        /// Returns all public Capabilities
        ///
        /// @return List of all public Capabilities
        ///
        pub fun getAllPublic(): [Capability] {
            return self.publicCapabilities.values
        }

        /// Returns all private Capabilities
        ///
        /// @return List of all private Capabilities
        ///
        pub fun getAllPrivate(): [Capability] {
            return self.privateCapabilities.values
        }

        /// Returns the first public Type that is a subtype of the given Type
        ///
        /// @param type: Type to check for subtypes
        /// @return First public Type that is a subtype of the given Type, nil otherwise
        ///
        pub fun findFirstPublicType(_ type: Type): Type? {
            for t in self.publicCapabilities.keys {
                if t.isSubtype(of: type) {
                    return t
                }
            }

            return nil
        }

        /// Returns the first private Type that is a subtype of the given Type
        ///
        /// @param type: Type to check for subtypes
        /// @return First private Type that is a subtype of the given Type, nil otherwise
        ///
        pub fun findFirstPrivateType(_ type: Type): Type? {
            for t in self.privateCapabilities.keys {
                if t.isSubtype(of: type) {
                    return t
                }
            }

            return nil
        }
        // ------- End Getter methods

        /// Adds a Capability to the Delegator
        ///
        /// @param cap: Capability to add
        /// @param isPublic: Whether the Capability should be public or private
        ///
        pub fun addCapability(cap: Capability, isPublic: Bool) {
            pre {
                cap.check<&AnyResource>(): "Invalid Capability provided"
            }
            if isPublic {
                self.publicCapabilities.insert(key: cap.getType(), cap)
            } else {
                self.privateCapabilities.insert(key: cap.getType(), cap)
            }
            emit DelegatorUpdated(id: self.uuid, capabilityType: cap.getType(), isPublic: isPublic, active: true)
        }

        /// Removes a Capability from the Delegator
        ///
        /// @param cap: Capability to remove
        ///
        pub fun removeCapability(cap: Capability) {
            if let removedPublic = self.publicCapabilities.remove(key: cap.getType()) {
                emit DelegatorUpdated(id: self.uuid, capabilityType: cap.getType(), isPublic: true, active: false)
            }

            if let removedPrivate = self.privateCapabilities.remove(key: cap.getType()) {
                emit DelegatorUpdated(id: self.uuid, capabilityType: cap.getType(), isPublic: false, active: false)
            }
        }

        init() {
            self.privateCapabilities = {}
            self.publicCapabilities = {}
        }
    }

    /// Creates a new Delegator and returns it
    ///
    /// @return Newly created Delegator
    ///
    pub fun createDelegator(): @Delegator {
        let delegator <- create Delegator()
        emit DelegatorCreated(id: delegator.uuid)
        return <- delegator
    }

    init() {
        let identifier = "CapabilityDelegator_".concat(self.account.address.toString())
        self.StoragePath = StoragePath(identifier: identifier)!
        self.PrivatePath = PrivatePath(identifier: identifier)!
        self.PublicPath = PublicPath(identifier: identifier)!
    }
}
 "
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import SwirlNametag from 0xed00d8ac249ee4b6

pub contract SwirlMoment: NonFungibleToken {
    pub var totalSupply: UInt64
    pub var nextNonceForProofOfMeeting: UInt64

    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event Log(str: String)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let ProviderPrivatePath: PrivatePath

    pub struct Coordinate {
        pub let lat: Fix64
        pub let lng: Fix64

        init(lat: Fix64, lng: Fix64) {
            self.lat = lat
            self.lng = lng
        }
    }

    pub struct ProofOfMeeting {
        pub let account: PublicAccount
        pub let location: Coordinate

        pub let nonce: UInt64
        pub let keyIndex: Int
        pub let signature: String

        init(account: PublicAccount, location: Coordinate, nonce: UInt64, keyIndex: Int, signature: String) {
            self.account = account
            self.location = location
            self.nonce = nonce
            self.keyIndex = keyIndex
            self.signature = signature
        }

        pub fun signedData(): [UInt8] {
            var json = "{"
            json = json.concat("\"address\":\"").concat(self.account.address.toString()).concat("\",")
            json = json.concat("\"lat\":").concat(self.location.lat.toString()).concat(",")
            json = json.concat("\"lng\":").concat(self.location.lng.toString()).concat(",")
            json = json.concat("\"nonce\":").concat(self.nonce.toString())
            json = json.concat("}")
            return json.utf8
        }

        pub fun signPubKey(): AccountKey {
            return self.account.keys.get(keyIndex: self.keyIndex) ?? panic("no key at given index")
        }
    }

    /// Mints a new NFT. Proof-of-Location is required to mint moment
    pub fun mint(proofs: [ProofOfMeeting]) {
        // validate swirl participants' messages
        for proof in proofs {
            // 0. resolve profile from the participant's SwirlNametag.
            let collectionRef = proof.account
                .getCapability(SwirlNametag.CollectionPublicPath)
                .borrow<&{SwirlNametag.SwirlNametagCollectionPublic}>()
                ?? panic("no SwirlNametag.Collection found: ".concat(proof.account.address.toString()))

            let nametags = collectionRef.getIDs()
            if nametags.length == 0 {
                panic("no nametag found: ".concat(proof.account.address.toString()))
            }
            let nametag = collectionRef.borrowSwirlNametag(id: nametags[0]) ?? panic("unable to borrow nametag")
            let profile = nametag.profile

            // 1. ensure that nonce is up to date (to prevent signature replay attack)
            if proof.nonce != SwirlMoment.nextNonceForProofOfMeeting {
                panic("nonce mismatch: ".concat(proof.account.address.toString()))
            }

            // 2. verify that the message is signed correctly
            let isValid = proof.signPubKey().publicKey.verify(
                signature: proof.signature.decodeHex(),
                signedData: proof.signedData(),
                domainSeparationTag: "",
                hashAlgorithm: HashAlgorithm.SHA2_256
            )
            if !isValid {
                panic("invalid signature: ".concat(proof.account.address.toString()))
            }

            // 3. make sure they're in a close location (<= 1km!)
            // since we can't correctly calculate harversine distance in cadence,
            // we use 0.00904372 degrees to approximate as 1km (without correcting the earth's curvature...)
            if self.abs(proofs[0].location.lat - proof.location.lat) > 0.00904372 {
                panic("location too far: ".concat(proof.account.address.toString()))
            }
            if self.abs(proofs[0].location.lng - proof.location.lng) > 0.00904372 {
                panic("location too far: ".concat(proof.account.address.toString()))
            }

            // 4. mint
            for p in proofs {
                if p.account.address == proof.account.address {
                    continue
                }
                let recipient = p.account.getCapability(SwirlMoment.CollectionPublicPath)
                    .borrow<&{NonFungibleToken.CollectionPublic}>()
                    ?? panic("no SwirlMoment.Collection found: ".concat(proof.account.address.toString()))

                self.mintNFT(recipient: recipient, nametagID: nametag.id, location: proof.location)
            }
        }
        SwirlMoment.nextNonceForProofOfMeeting = SwirlMoment.nextNonceForProofOfMeeting + 1
    }

    priv fun abs(_ x: Fix64): Fix64 {
        if x < 0.0 {
            return -x
        }
        return x
    }

    priv fun mintNFT(recipient: &{NonFungibleToken.CollectionPublic}, nametagID: UInt64, location: Coordinate) {
        // create a new NFT
        var newNFT <- create NFT(
            id: SwirlMoment.totalSupply,
            nametagID: nametagID,
            location: location,
            mintedAt: getCurrentBlock().timestamp,
        )
        recipient.deposit(token: <-newNFT)
        SwirlMoment.totalSupply = SwirlMoment.totalSupply + 1
    }

    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        /// the token ID
        pub let id: UInt64

        /// the token ID of the nametag, linked to the profile of the person you met
        pub let nametagID: UInt64

        /// where you met
        pub let location: Coordinate

        /// the time you met
        pub let mintedAt: UFix64

        init(id: UInt64, nametagID: UInt64, location: Coordinate, mintedAt: UFix64) {
            self.id = id
            self.nametagID = nametagID
            self.location = location
            self.mintedAt = mintedAt
        }

        pub fun profile(): SwirlNametag.Profile {
            return SwirlNametag.getProfile(self.nametagID)
        }

        pub fun getViews(): [Type] {
            let views: [Type] = [
                    Type<MetadataViews.Display>(),
                    Type<MetadataViews.Serial>(),
                    Type<MetadataViews.ExternalURL>(),
                    Type<MetadataViews.NFTCollectionData>(),
                    Type<MetadataViews.NFTCollectionDisplay>(),
                    Type<MetadataViews.Traits>()
                ]
            return views
        }

        pub fun name(): String {
            return "Swirl Moment with ".concat(self.profile().nickname)
        }

        pub fun profileImageUrl(): String {
            let profile = self.profile()
            var url = "https://swirl.deno.dev/dnft/moment.svg?"
            url = url.concat("nickname=").concat(profile.nickname)
            url = url.concat("&profile_img=").concat(String.encodeHex(profile.profileImage.utf8))
            url = url.concat("&color=").concat(String.encodeHex(profile.color.utf8))
            url = url.concat("&met_at=").concat(self.mintedAt.toString())
            return url
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<SwirlNametag.Profile>():
                    return self.profile()
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.name(),
                        description: "Swirl, share your digital profiles as NFT and keep IRL moment with others.",
                        thumbnail: MetadataViews.HTTPFile(url: self.profileImageUrl()),
                    )
                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(
                        self.id
                    )
                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL(self.profileImageUrl())

                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: SwirlMoment.CollectionStoragePath,
                        publicPath: SwirlMoment.CollectionPublicPath,
                        providerPath: SwirlMoment.ProviderPrivatePath,
                        publicCollection: Type<&SwirlMoment.Collection{SwirlMoment.SwirlMomentCollectionPublic}>(),
                        publicLinkedType: Type<&SwirlMoment.Collection{SwirlMoment.SwirlMomentCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&SwirlMoment.Collection{SwirlMoment.SwirlMomentCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Provider, MetadataViews.ResolverCollection}>(),
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                            return <-SwirlMoment.createEmptyCollection()
                        })
                    )
                case Type<MetadataViews.NFTCollectionDisplay>():
                    let media = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(url: self.profileImageUrl()),
                        mediaType: "image/svg+xml"
                    )
                    return MetadataViews.NFTCollectionDisplay(
                        name: "Swirl Moment",
                        description: "Swirl, share your digital profiles as NFT and keep IRL moment with others.",
                        externalURL: MetadataViews.ExternalURL("https://hyphen.at/"),
                        squareImage: media,
                        bannerImage: media,
                        socials: {}
                    )
                case Type<MetadataViews.Traits>():
                    let traits: {String: AnyStruct} = {}
                    traits["locationLat"] = self.location.lat
                    traits["locationLng"] = self.location.lng
                    traits["mintedAt"] = self.mintedAt
                    let traitsView = MetadataViews.dictToTraits(dict: traits, excludedNames: [])

                    return traitsView
                default:
                    return nil
            }
        }
    }

    pub resource interface SwirlMomentCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowSwirlMoment(id: UInt64): &SwirlMoment.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow SwirlMoment reference: the ID of the returned reference is incorrect"
            }
        }
    }

    pub resource Collection: SwirlMomentCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with an `UInt64` ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        // withdraw removes an NFT from the collection and moves it to the caller
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            panic("soulbound; SBT is not transferable")
        }

        pub fun burn(id: UInt64) {
            let token <- self.ownedNFTs.remove(key: id) ?? panic("missing NFT")
            emit Withdraw(id: token.id, from: self.owner?.address)
            destroy token
        }

        // deposit takes an NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @SwirlMoment.NFT

            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        // getIDs returns an array of the IDs that are in the collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT gets a reference to an NFT in the collection
        // so that the caller can read its metadata and call its methods
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowSwirlMoment(id: UInt64): &SwirlMoment.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorized reference to allow downcasting
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &SwirlMoment.NFT
            }

            return nil
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let SwirlMomentNFT = nft as! &SwirlMoment.NFT
            return SwirlMomentNFT as &AnyResource{MetadataViews.Resolver}
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    // public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    init() {
        self.totalSupply = 0
        self.nextNonceForProofOfMeeting = 0

        self.CollectionStoragePath = /storage/SwirlMomentCollection
        self.CollectionPublicPath = /public/SwirlMomentCollection
        self.ProviderPrivatePath = /private/SwirlNFTCollectionProvider

        // Create a Collection resource and save it to storage
        let collection <- create Collection()
        self.account.save(<-collection, to: self.CollectionStoragePath)

        self.account.link<&SwirlMoment.Collection{NonFungibleToken.CollectionPublic, SwirlMoment.SwirlMomentCollectionPublic, MetadataViews.ResolverCollection}>(
            self.CollectionPublicPath,
            target: self.CollectionStoragePath
        )

        emit ContractInitialized()
    }
}
"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import MetadataViews from 0x1d7e57aa55817448

/// This contract implements the metadata standard proposed
/// in FLIP-1087.
///
/// Ref: https://github.com/onflow/flow/blob/master/flips/20220811-fungible-tokens-metadata.md
///
/// Structs and resources can implement one or more
/// metadata types, called views. Each view type represents
/// a different kind of metadata.
///
pub contract FungibleTokenMetadataViews {
    /// FTView wraps FTDisplay and FTVaultData, and is used to give a complete
    /// picture of a Fungible Token. Most Fungible Token contracts should
    /// implement this view.
    ///
    pub struct FTView {
        pub let ftDisplay: FTDisplay?
        pub let ftVaultData: FTVaultData?
        init(
            ftDisplay: FTDisplay?,
            ftVaultData: FTVaultData?
        ) {
            self.ftDisplay = ftDisplay
            self.ftVaultData = ftVaultData
        }
    }

    /// Helper to get a FT view.
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A FTView struct
    ///
    pub fun getFTView(viewResolver: &{MetadataViews.Resolver}): FTView {
        let maybeFTView = viewResolver.resolveView(Type<FTView>())
        if let ftView = maybeFTView {
            return ftView as! FTView
        }
        return FTView(
            ftDisplay: self.getFTDisplay(viewResolver),
            ftVaultData: self.getFTVaultData(viewResolver)
        )
    }

    /// View to expose the information needed to showcase this FT.
    /// This can be used by applications to give an overview and
    /// graphics of the FT.
    ///
    pub struct FTDisplay {
        /// The display name for this token.
        ///
        /// Example: "Flow"
        ///
        pub let name: String

        /// The abbreviated symbol for this token.
        ///
        /// Example: "FLOW"
        pub let symbol: String

        /// A description the provides an overview of this token.
        ///
        /// Example: "The FLOW token is the native currency of the Flow network."
        pub let description: String

        /// External link to a URL to view more information about the fungible token.
        pub let externalURL: MetadataViews.ExternalURL

        /// One or more versions of the fungible token logo.
        pub let logos: MetadataViews.Medias

        /// Social links to reach the fungible token's social homepages.
        /// Possible keys may be "instagram", "twitter", "discord", etc.
        pub let socials: {String: MetadataViews.ExternalURL}

        init(
            name: String,
            symbol: String,
            description: String,
            externalURL: MetadataViews.ExternalURL,
            logos: MetadataViews.Medias,
            socials: {String: MetadataViews.ExternalURL}
        ) {
            self.name = name
            self.symbol = symbol
            self.description = description
            self.externalURL = externalURL
            self.logos = logos
            self.socials = socials
        }
    }

    /// Helper to get FTDisplay in a way that will return a typed optional.
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return An optional FTDisplay struct
    ///
    pub fun getFTDisplay(_ viewResolver: &{MetadataViews.Resolver}): FTDisplay? {
        if let maybeDisplayView = viewResolver.resolveView(Type<FTDisplay>()) {
            if let displayView = maybeDisplayView as? FTDisplay {
                return displayView
            }
        }
        return nil
    }

    /// View to expose the information needed store and interact with a FT vault.
    /// This can be used by applications to setup a FT vault with proper
    /// storage and public capabilities.
    ///
    pub struct FTVaultData {
        /// Path in storage where this FT vault is recommended to be stored.
        pub let storagePath: StoragePath

        /// Public path which must be linked to expose the public receiver capability.
        pub let receiverPath: PublicPath

        /// Public path which must be linked to expose the balance and resolver public capabilities.
        pub let metadataPath: PublicPath

        /// Private path which should be linked to expose the provider capability to withdraw funds
        /// from the vault.
        pub let providerPath: PrivatePath

        /// Type that should be linked at the `receiverPath`. This is a restricted type requiring
        /// the `FungibleToken.Receiver` interface.
        pub let receiverLinkedType: Type

        /// Type that should be linked at the `receiverPath`. This is a restricted type requiring
        /// the `FungibleToken.Balance` and `MetadataViews.Resolver` interfaces.
        pub let metadataLinkedType: Type

        /// Type that should be linked at the aforementioned private path. This
        /// is normally a restricted type with at a minimum the `FungibleToken.Provider` interface.
        pub let providerLinkedType: Type

        /// Function that allows creation of an empty FT vault that is intended
        /// to store the funds.
        pub let createEmptyVault: ((): @FungibleToken.Vault)

        init(
            storagePath: StoragePath,
            receiverPath: PublicPath,
            metadataPath: PublicPath,
            providerPath: PrivatePath,
            receiverLinkedType: Type,
            metadataLinkedType: Type,
            providerLinkedType: Type,
            createEmptyVaultFunction: ((): @FungibleToken.Vault)
        ) {
            pre {
                receiverLinkedType.isSubtype(of: Type<&{FungibleToken.Receiver}>()): "Receiver public type must include FungibleToken.Receiver."
                metadataLinkedType.isSubtype(of: Type<&{FungibleToken.Balance, MetadataViews.Resolver}>()): "Metadata public type must include FungibleToken.Balance and MetadataViews.Resolver interfaces."
                providerLinkedType.isSubtype(of: Type<&{FungibleToken.Provider}>()): "Provider type must include FungibleToken.Provider interface."
            }
            self.storagePath = storagePath
            self.receiverPath = receiverPath
            self.metadataPath = metadataPath
            self.providerPath = providerPath
            self.receiverLinkedType = receiverLinkedType
            self.metadataLinkedType = metadataLinkedType
            self.providerLinkedType = providerLinkedType
            self.createEmptyVault = createEmptyVaultFunction
        }
    }

    /// Helper to get FTVaultData in a way that will return a typed Optional.
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional FTVaultData struct
    ///
    pub fun getFTVaultData(_ viewResolver: &{MetadataViews.Resolver}): FTVaultData? {
        if let view = viewResolver.resolveView(Type<FTVaultData>()) {
            if let v = view as? FTVaultData {
                return v
            }
        }
        return nil
    }

}
 "
-------
" pub contract BasicNFT{

    pub var totalSupply: UInt64

    init(){
        self.totalSupply = 0
    }

    pub resource interface NFTPublic{
        pub fun getID(): UInt64
        pub fun getURL(): String
    }

    pub resource NFT: NFTPublic{

        pub let id: UInt64
        pub var metadata: {String: String}

        init(InitURL: String){
            self.id = BasicNFT.totalSupply
            self.metadata = {"URL": InitURL}
            BasicNFT.totalSupply = BasicNFT.totalSupply + 1
        }

        pub fun getID(): UInt64{
            return self.id
        }

        pub fun getURL(): String{
            return self.metadata["URL"]!
        }

    }

    pub fun createNFT(url: String): @NFT{
        return <- create NFT(InitURL: url)
    }

}"
-------
"import CapsuleNFT from 0xecb0408a4ab2329d

pub contract Merchandise: CapsuleNFT {
    pub var totalMinted: UInt64

    pub event ContractInitialized()
    pub event CollectionCreated()
    pub event CollectionDestroyed(length: Int)
    pub event Withdraw(id: String, size: UInt64, from: Address?)
    pub event Deposit(id: String, size: UInt64, to: Address?)
    pub event Minted(id: String)
    pub event MerchandiseMinted(
        id: String,
        item: String,
        collection: String,
        type: String,
        edition: String,
        description: String,
        retailPrice: UFix64,
        mediaUri: String,
        mintedTime: String,
        resourceId: UInt64
    )
    pub event MerchandiseDestroyed(id: String)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath

    /// NFT:
    /// A Merchandise as an NFT
    pub resource NFT: CapsuleNFT.INFT {
        pub let id: String
        pub let item: String
        pub let collection: String
        pub let type: String
        pub let edition: String
        pub let description: String
        pub let retailPrice: UFix64
        pub let mediaUri: String
        pub let mintedTime: String

        init(
            id: String,
            item: String,
            collection: String,
            type: String,
            edition: String,
            description: String,
            retailPrice: UFix64,
            mediaUri: String,
            mintedTime: String,
        ) {
            self.id = id
            self.item = item
            self.collection = collection
            self.type = type
            self.edition = edition
            self.description = description
            self.retailPrice = retailPrice
            self.mediaUri = mediaUri
            self.mintedTime = mintedTime
        }

        destroy() {
            emit MerchandiseDestroyed(id: self.id)
        }
    }

    /// MerchandiseCollectionPublic:
    /// This is the interface that users can cast their Merchandise Collection as,
    /// in order to allow others to deposit a Merchandise into their Collection.
    /// It also allows for reading the details of an Merchandise in the Collection.
    pub resource interface MerchandiseCollectionPublic {
        pub fun deposit(token: @CapsuleNFT.NFT)
        pub fun getIDs(): [String]
        pub fun borrowNFT(id: String): &CapsuleNFT.NFT
        pub fun borrowMerchandise(id: String): &Merchandise.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow Collectible reference: the ID of the returned reference is incorrect"
            }
        }
    }

    /// Collection:
    /// A collection of Merchandise NFTs owned by an account
    pub resource Collection: MerchandiseCollectionPublic, CapsuleNFT.Provider, CapsuleNFT.Receiver, CapsuleNFT.CollectionPublic {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with a `String` ID field
        pub var ownedNFTs: @{String: CapsuleNFT.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        /// Removes an NFT from the collection and moves it to the caller
        pub fun withdraw(id: String): @CapsuleNFT.NFT {
            let address: Address? = self.owner?.address
            let account: PublicAccount = getAccount(address!)
            let startUsed: UInt64 = account.storageUsed

            let token: @CapsuleNFT.NFT <- self.ownedNFTs.remove(key: id)
                ?? panic("Missing EventTicket NFT!")

            let endUsed: UInt64 = account.storageUsed
            let delta: UInt64 = endUsed - startUsed
            emit Withdraw(id: token.id, size: delta, from: address)

            return <-token
        }

        /// Takes an NFT, adds it to the Collection dictionary and adds the ID to the id array
        pub fun deposit(token: @CapsuleNFT.NFT) {
            let address: Address? = self.owner?.address
            let account: PublicAccount = getAccount(address!)
            let startUsed: UInt64 = account.storageUsed

            let token: @Merchandise.NFT <- token as! @Merchandise.NFT
            let id: String = token.id
            // Add the new token to the dictionary which removes the old one
            let oldToken: @CapsuleNFT.NFT? <- self.ownedNFTs[id] <- token

            let endUsed: UInt64 = account.storageUsed
            let delta: UInt64 = endUsed - startUsed
            emit Deposit(id: id, size: delta, to: address)

            destroy oldToken
        }

        /// Returns an array of the IDs that are in the collection
        pub fun getIDs(): [String] {
            return self.ownedNFTs.keys
        }

        /// Gets a reference to an NFT in the collection so that the caller can read its metadata and call its methods
        pub fun borrowNFT(id: String): &CapsuleNFT.NFT {
            return (&self.ownedNFTs[id] as &CapsuleNFT.NFT?)!
        }

        /// Gets a reference to a Merchandise in the Collection
        pub fun borrowMerchandise(id: String): &Merchandise.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorised reference to allow downcasting
                let ref: auth &CapsuleNFT.NFT = (&self.ownedNFTs[id] as auth &CapsuleNFT.NFT?)!
                return ref as! &Merchandise.NFT
            } else {
                return nil
            }
        }

        destroy() {
            let collectionLength = self.ownedNFTs.length
            destroy self.ownedNFTs
            emit CollectionDestroyed(length: collectionLength)
        }
    }

    /// Public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(): @CapsuleNFT.Collection {
        emit CollectionCreated()
        return <- create Collection()
    }

    /// Resource that an admin or similar would own to be able to mint new NFTs
    pub resource NFTMinter {
        /// Mints a new Merchandise.
        /// Deposits it in the recipients Collection using their PublicCollection reference.
        pub fun mintMerchandise(
            recipientCollection: &{CapsuleNFT.CollectionPublic},
            id: String,
            item: String,
            collection: String,
            type: String,
            edition: String,
            description: String,
            retailPrice: UFix64,
            mediaUri: String,
            mintedTime: String,
        ) {
            // Create a new Merchandise NFT
            var merchandise: @Merchandise.NFT <- create NFT(
                id: id,
                item: item,
                collection: collection,
                type: type,
                edition: edition,
                description: description,
                retailPrice: retailPrice,
                mediaUri: mediaUri,
                mintedTime: mintedTime
            )
            // Emit Events
            // emit Minted(id: id)
            emit MerchandiseMinted(
                id: id,
                item: item,
                collection: collection,
                type: type,
                edition: edition,
                description: description,
                retailPrice: retailPrice,
                mediaUri: mediaUri,
                mintedTime: mintedTime,
                resourceId: merchandise.uuid
            )
            // Increment the total of minted Merchandise
            Merchandise.totalMinted = Merchandise.totalMinted + 1

            // Deposit it in the recipient's account using their reference
            recipientCollection.deposit(token: <-merchandise)
        }
    }

    init() {
        // Initialize the total of minted Merchandise
        self.totalMinted = 0

        // Set the itemd paths
        self.CollectionStoragePath = /storage/CapsuleMerchandiseCollection
        self.CollectionPublicPath = /public/CapsuleMerchandiseCollection
        self.MinterStoragePath = /storage/CapsuleMerchandiseMinter

        // Create a Merchandise resource and save it to storage
        let collection: @Merchandise.Collection <- create Collection()
        self.account.save(<-collection, to: self.CollectionStoragePath)

        // Create a public capability for the collection
        self.account.link<&Merchandise.Collection{CapsuleNFT.CollectionPublic, Merchandise.MerchandiseCollectionPublic}>
            (self.CollectionPublicPath, target: self.CollectionStoragePath)

        // Create a Minter resource and save it to storage
        let minter: @Merchandise.NFTMinter <- create NFTMinter()
        self.account.save(<-minter, to: self.MinterStoragePath)

        emit ContractInitialized()
    }
}
 "
-------
"import CapsuleNFT from 0xd8f6dd312265bd2c

pub contract EventTickets: CapsuleNFT {
    pub var totalMinted: UInt64

    pub event ContractInitialized()
    pub event CollectionCreated()
    pub event CollectionDestroyed(length: Int)
    pub event Withdraw(id: String, size: UInt64, from: Address?)
    pub event Deposit(id: String, size: UInt64, to: Address?)
    pub event Minted(id: String)
    pub event TicketMinted(
        id: String,
        ticketId: UInt64,
        ticketCategory: String,
        eventName: String,
        retailPrice: UFix64,
        mintedTime: String,
        rarity: String,
        edition: String,
        mediaUri: String,
        resourceId: UInt64
    )
    pub event TicketDestroyed(id: String)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath

    /// NFT:
    /// An EventTicket as an NFT
    pub resource NFT: CapsuleNFT.INFT {
        pub let id: String
        pub let ticketId: UInt64
        pub let ticketCategory: String
        pub let eventName: String
        pub let retailPrice: UFix64
        pub let mintedTime: String
        pub let rarity: String
        pub let edition: String
        pub let mediaUri: String

        init(
            id: String,
            ticketId: UInt64,
            ticketCategory: String,
            eventName: String,
            retailPrice: UFix64,
            mintedTime: String,
            rarity: String,
            edition: String,
            mediaUri: String,
        ) {
            self.id = id
            self.ticketId = ticketId
            self.ticketCategory = ticketCategory
            self.eventName = eventName
            self.retailPrice = retailPrice
            self.mintedTime = mintedTime
            self.rarity = rarity
            self.edition = edition
            self.mediaUri = mediaUri
        }

        destroy() {
            emit TicketDestroyed(id: self.id)
        }
    }

    /// EventTicketsCollectionPublic:
    /// This is the interface that users can cast their EventTicket Collection as,
    /// in order to allow others to deposit an EventTicket into their Collection.
    /// It also allows for reading the details of an EventTicket in the Collection.
    pub resource interface EventTicketsCollectionPublic {
        pub fun deposit(token: @CapsuleNFT.NFT)
        pub fun getIDs(): [String]
        pub fun borrowNFT(id: String): &CapsuleNFT.NFT
        pub fun borrowTicket(id: String): &EventTickets.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow EventTicket reference: the ID of the returned reference is incorrect"
            }
        }
    }

    /// Collection:
    /// A collection of EventTicket NFTs owned by an account
    pub resource Collection: EventTicketsCollectionPublic, CapsuleNFT.Provider, CapsuleNFT.Receiver, CapsuleNFT.CollectionPublic {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with a `String` ID field
        pub var ownedNFTs: @{String: CapsuleNFT.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        /// Removes an NFT from the collection and moves it to the caller
        pub fun withdraw(id: String): @CapsuleNFT.NFT {
            let address: Address? = self.owner?.address
            let account: PublicAccount = getAccount(address!)
            let startUsed: UInt64 = account.storageUsed

            let token: @CapsuleNFT.NFT <- self.ownedNFTs.remove(key: id)
                ?? panic("Missing EventTicket NFT!")

            let endUsed: UInt64 = account.storageUsed
            let delta: UInt64 = startUsed - endUsed
            emit Withdraw(id: token.id, size: delta, from: address)

            return <-token
        }

        /// Takes an NFT, adds it to the Collections dictionary, and adds the ID to the id array
        pub fun deposit(token: @CapsuleNFT.NFT) {
            let address: Address? = self.owner?.address
            let account: PublicAccount = getAccount(address!)
            let startUsed: UInt64 = account.storageUsed

            let token: @EventTickets.NFT <- token as! @EventTickets.NFT
            let id: String = token.id
            // Add the new token to the dictionary which removes the old one
            let oldToken: @CapsuleNFT.NFT? <- self.ownedNFTs[id] <- token

            let endUsed: UInt64 = account.storageUsed
            let delta: UInt64 = endUsed - startUsed
            emit Deposit(id: id, size: delta, to: address)

            destroy oldToken
        }

        /// Returns an array of the IDs that are in the collection
        pub fun getIDs(): [String] {
            return self.ownedNFTs.keys
        }

        /// Gets a reference to an NFT in the Collection so that the caller can read its metadata and call its methods
        pub fun borrowNFT(id: String): &CapsuleNFT.NFT {
            return (&self.ownedNFTs[id] as &CapsuleNFT.NFT?)!
        }

        // Safe way to borrow a reference to an NFT that does not panic
        // Also now part of the CapsuleNFT.PublicCollection interface
        //
        // Parameters: id: The ID of the NFT to get the reference for
        //
        // Returns: An optional reference to the desired NFT, will be nil if the passed ID does not exist
        pub fun borrowNFTSafe(id: String): &CapsuleNFT.NFT? {
            if let nftRef = &self.ownedNFTs[id] as &CapsuleNFT.NFT? {
                return nftRef
            }
            return nil
        }

        pub fun borrowTicket(id: String): &EventTickets.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorised reference to allow downcasting
                let ref = (&self.ownedNFTs[id] as auth &CapsuleNFT.NFT?)!
                return ref as! &EventTickets.NFT
            } else {
                return nil
            }
        }

        // If a transaction destroys the Collection resource,
        // All the NFTs contained within are also destroyed.
        //
        destroy() {
            let collectionLength = self.ownedNFTs.length
            destroy self.ownedNFTs
            emit CollectionDestroyed(length: collectionLength)
        }
    }

    /// Public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(): @CapsuleNFT.Collection {
        emit CollectionCreated()
        return <- create Collection()
    }

    /// Minter:
    /// Resource that an Admin (or similar) would own to be able to mint new EventTicket NFTs.
    pub resource NFTMinter {
        /// Mints a new EventTicket NFT with a new ID and deposits it in the recipients Collection.
        pub fun mintTicket(
            recipient: &{CapsuleNFT.CollectionPublic},
            id: String,
            ticketId: UInt64,
            ticketCategory: String,
            eventName: String,
            retailPrice: UFix64,
            mintedTime: String,
            rarity: String,
            edition: String,
            mediaUri: String,
        ) {
            // Create a new EventTicket
            var ticket: @EventTickets.NFT <- create NFT(
                id: id,
                ticketId: ticketId,
                ticketCategory: ticketCategory,
                eventName: eventName,
                retailPrice: retailPrice,
                mintedTime: mintedTime,
                rarity: rarity,
                edition: edition,
                mediaUri: mediaUri,
            )
            // Emit Events
            // emit Minted(id: id)
            emit TicketMinted(
                id: id,
                ticketId: ticketId,
                ticketCategory: ticketCategory,
                eventName: eventName,
                retailPrice: retailPrice,
                mintedTime: mintedTime,
                rarity: rarity,
                edition: edition,
                mediaUri: mediaUri,
                resourceId: ticket.uuid
            )
            // Increment the total of minted EventTickets
            EventTickets.totalMinted = EventTickets.totalMinted + 1

            // Deposit it in the recipient's account using their reference
            recipient.deposit(token: <-ticket)
        }
    }

    init() {
        // Initialize the total minted number of EventTickets
        self.totalMinted = 0

        // Set the named paths
        self.CollectionStoragePath = /storage/CapsuleTicketsCollection
        self.CollectionPublicPath = /public/CapsuleTicketsCollection
        self.MinterStoragePath = /storage/CapsuleTicketsMinter

        // Create a Collection resource and save it to storage
        let collection: @EventTickets.Collection <- create Collection()
        self.account.save(<-collection, to: self.CollectionStoragePath)

        // Create a public capability for the Collection
        self.account.link<&EventTickets.Collection{CapsuleNFT.CollectionPublic, EventTickets.EventTicketsCollectionPublic}>
            (self.CollectionPublicPath, target: self.CollectionStoragePath)

        // Create a Minter resource and save it to storage
        let minter: @EventTickets.NFTMinter <- create NFTMinter()
        self.account.save(<-minter, to: self.MinterStoragePath)

        emit ContractInitialized()
    }
}
 "
-------
"// CREATED BY: Touchstone (https://touchstone.city/), a platform crafted by your best friends at Emerald City DAO (https://ecdao.org/).
// STATEMENT: This contract promises to keep the 5% royalty off of primary sales and 2.5% off of secondary sales to Emerald City DAO or risk permanent suspension from participation in the DAO and its tools.

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import FlowToken from 0x1654653399040a61
import MintVerifiers from 0x7a696d6136e1dce2
import FUSD from 0x3c5959b568896393
import EmeraldPass from 0x6a07dbeb03167a13

pub contract TouchstoneTheGritIronNFT: NonFungibleToken {

	// Collection Information
	access(self) let collectionInfo: {String: AnyStruct}

	// Contract Information
	pub var nextEditionId: UInt64
	pub var nextMetadataId: UInt64
	pub var totalSupply: UInt64

	// Events
	pub event ContractInitialized()
	pub event Withdraw(id: UInt64, from: Address?)
	pub event Deposit(id: UInt64, to: Address?)
	pub event TouchstonePurchase(id: UInt64, recipient: Address, metadataId: UInt64, name: String, description: String, image: MetadataViews.IPFSFile, price: UFix64)
	pub event Minted(id: UInt64, recipient: Address, metadataId: UInt64)
	pub event MintBatch(metadataIds: [UInt64], recipients: [Address])

	// Paths
	pub let CollectionStoragePath: StoragePath
	pub let CollectionPublicPath: PublicPath
	pub let CollectionPrivatePath: PrivatePath
	pub let AdministratorStoragePath: StoragePath

	// Maps metadataId of NFT to NFTMetadata
	access(account) let metadatas: {UInt64: NFTMetadata}

	// Maps the metadataId of an NFT to the primary buyer
	access(account) let primaryBuyers: {Address: {UInt64: [UInt64]}}

	access(account) let nftStorage: @{Address: {UInt64: NFT}}

	pub struct NFTMetadata {
		pub let metadataId: UInt64
		pub let name: String
		pub let description: String
		// The main image of the NFT
		pub let image: MetadataViews.IPFSFile
		// An optional thumbnail that can go along with it
		// for easier loading
		pub let thumbnail: MetadataViews.IPFSFile?
		// If price is nil, defaults to the collection price
		pub let price: UFix64?
		pub var extra: {String: AnyStruct}
		pub let supply: UInt64
		pub let purchasers: {UInt64: Address}

		access(account) fun purchased(serial: UInt64, buyer: Address) {
			self.purchasers[serial] = buyer
		}

		init(_name: String, _description: String, _image: MetadataViews.IPFSFile, _thumbnail: MetadataViews.IPFSFile?, _price: UFix64?, _extra: {String: AnyStruct}, _supply: UInt64) {
			self.metadataId = TouchstoneTheGritIronNFT.nextMetadataId
			self.name = _name
			self.description = _description
			self.image = _image
			self.thumbnail = _thumbnail
			self.price = _price
			self.extra = _extra
			self.supply = _supply
			self.purchasers = {}
		}
	}

	pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
		// The 'id' is the same as the 'uuid'
		pub let id: UInt64
		// The 'metadataId' is what maps this NFT to its 'NFTMetadata'
		pub let metadataId: UInt64
		pub let serial: UInt64

		pub fun getMetadata(): NFTMetadata {
			return TouchstoneTheGritIronNFT.getNFTMetadata(self.metadataId)!
		}

		pub fun getViews(): [Type] {
			return [
				Type<MetadataViews.Display>(),
				Type<MetadataViews.ExternalURL>(),
				Type<MetadataViews.NFTCollectionData>(),
				Type<MetadataViews.NFTCollectionDisplay>(),
				Type<MetadataViews.Royalties>(),
				Type<MetadataViews.Serial>(),
				Type<MetadataViews.Traits>(),
				Type<MetadataViews.NFTView>()
			]
		}

		pub fun resolveView(_ view: Type): AnyStruct? {
			switch view {
				case Type<MetadataViews.Display>():
					let metadata = self.getMetadata()
					return MetadataViews.Display(
						name: metadata.name,
						description: metadata.description,
						thumbnail: metadata.thumbnail ?? metadata.image
					)
				case Type<MetadataViews.NFTCollectionData>():
					return MetadataViews.NFTCollectionData(
						storagePath: TouchstoneTheGritIronNFT.CollectionStoragePath,
						publicPath: TouchstoneTheGritIronNFT.CollectionPublicPath,
						providerPath: TouchstoneTheGritIronNFT.CollectionPrivatePath,
						publicCollection: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
						publicLinkedType: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
						providerLinkedType: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, NonFungibleToken.Provider}>(),
						createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
								return <- TouchstoneTheGritIronNFT.createEmptyCollection()
						})
					)
				case Type<MetadataViews.ExternalURL>():
          return MetadataViews.ExternalURL("https://touchstone.city/discover/".concat(self.owner!.address.toString()).concat("/TouchstoneTheGritIronNFT"))
				case Type<MetadataViews.NFTCollectionDisplay>():
					let squareMedia = MetadataViews.Media(
						file: TouchstoneTheGritIronNFT.getCollectionAttribute(key: "image") as! MetadataViews.IPFSFile,
						mediaType: "image"
					)

					// If a banner image exists, use it
					// Otherwise, default to the main square image
					var bannerMedia: MetadataViews.Media? = nil
					if let bannerImage = TouchstoneTheGritIronNFT.getOptionalCollectionAttribute(key: "bannerImage") as! MetadataViews.IPFSFile? {
						bannerMedia = MetadataViews.Media(
							file: bannerImage,
							mediaType: "image"
						)
					}
					return MetadataViews.NFTCollectionDisplay(
						name: TouchstoneTheGritIronNFT.getCollectionAttribute(key: "name") as! String,
						description: TouchstoneTheGritIronNFT.getCollectionAttribute(key: "description") as! String,
						externalURL: MetadataViews.ExternalURL("https://touchstone.city/discover/".concat(self.owner!.address.toString()).concat("/TouchstoneTheGritIronNFT")),
						squareImage: squareMedia,
						bannerImage: bannerMedia ?? squareMedia,
						socials: TouchstoneTheGritIronNFT.getCollectionAttribute(key: "socials") as! {String: MetadataViews.ExternalURL}
					)
				case Type<MetadataViews.Royalties>():
					return MetadataViews.Royalties([
						// This is for Emerald City in favor of producing Touchstone, a free platform for our users. Failure to keep this in the contract may result in permanent suspension from Emerald City.
						MetadataViews.Royalty(
							recepient: getAccount(0x5643fd47a29770e7).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),
							cut: 0.025, // 2.5% royalty on secondary sales
							description: "Emerald City DAO receives a 2.5% royalty from secondary sales because this collection was created using Touchstone (https://touchstone.city/), a tool for creating your own NFT collections, crafted by Emerald City DAO."
						)
					])
				case Type<MetadataViews.Serial>():
					return MetadataViews.Serial(
						self.serial
					)
				case Type<MetadataViews.Traits>():
					return MetadataViews.dictToTraits(dict: self.getMetadata().extra, excludedNames: nil)
				case Type<MetadataViews.NFTView>():
					return MetadataViews.NFTView(
						id: self.id,
						uuid: self.uuid,
						display: self.resolveView(Type<MetadataViews.Display>()) as! MetadataViews.Display?,
						externalURL: self.resolveView(Type<MetadataViews.ExternalURL>()) as! MetadataViews.ExternalURL?,
						collectionData: self.resolveView(Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?,
						collectionDisplay: self.resolveView(Type<MetadataViews.NFTCollectionDisplay>()) as! MetadataViews.NFTCollectionDisplay?,
						royalties: self.resolveView(Type<MetadataViews.Royalties>()) as! MetadataViews.Royalties?,
						traits: self.resolveView(Type<MetadataViews.Traits>()) as! MetadataViews.Traits?
					)
			}
			return nil
		}

		init(_metadataId: UInt64, _serial: UInt64, _recipient: Address) {
			pre {
				TouchstoneTheGritIronNFT.metadatas[_metadataId] != nil:
					"This NFT does not exist yet."
				_serial < TouchstoneTheGritIronNFT.getNFTMetadata(_metadataId)!.supply:
					"This serial does not exist for this metadataId."
				!TouchstoneTheGritIronNFT.getNFTMetadata(_metadataId)!.purchasers.containsKey(_serial):
					"This serial has already been purchased."
			}
			self.id = self.uuid
			self.metadataId = _metadataId
			self.serial = _serial

			// Update the buyers list so we keep track of who is purchasing
			if let buyersRef = &TouchstoneTheGritIronNFT.primaryBuyers[_recipient] as &{UInt64: [UInt64]}? {
				if let metadataIdMap = &buyersRef[_metadataId] as &[UInt64]? {
					metadataIdMap.append(_serial)
				} else {
					buyersRef[_metadataId] = [_serial]
				}
			} else {
				TouchstoneTheGritIronNFT.primaryBuyers[_recipient] = {_metadataId: [_serial]}
			}

			// Update who bought this serial inside NFTMetadata so it cannot be purchased again.
			let metadataRef = (&TouchstoneTheGritIronNFT.metadatas[_metadataId] as &NFTMetadata?)!
			metadataRef.purchased(serial: _serial, buyer: _recipient)

			TouchstoneTheGritIronNFT.totalSupply = TouchstoneTheGritIronNFT.totalSupply + 1
			emit Minted(id: self.id, recipient: _recipient, metadataId: _metadataId)
		}
	}

	pub resource Collection: NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
		// dictionary of NFT conforming tokens
		// NFT is a resource type with an 'UInt64' ID field
		pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

		// withdraw removes an NFT from the collection and moves it to the caller
		pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
			let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

			emit Withdraw(id: token.id, from: self.owner?.address)

			return <-token
		}

		// deposit takes a NFT and adds it to the collections dictionary
		// and adds the ID to the id array
		pub fun deposit(token: @NonFungibleToken.NFT) {
			let token <- token as! @NFT

			let id: UInt64 = token.id

			// add the new token to the dictionary
			self.ownedNFTs[id] <-! token

			emit Deposit(id: id, to: self.owner?.address)
		}

		// getIDs returns an array of the IDs that are in the collection
		pub fun getIDs(): [UInt64] {
			return self.ownedNFTs.keys
		}

		// borrowNFT gets a reference to an NFT in the collection
		// so that the caller can read its metadata and call its methods
		pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
			return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
		}

		pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
			let token = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
			let nft = token as! &NFT
			return nft as &AnyResource{MetadataViews.Resolver}
		}

		pub fun claim() {
			if let storage = &TouchstoneTheGritIronNFT.nftStorage[self.owner!.address] as &{UInt64: NFT}? {
				for id in storage.keys {
					self.deposit(token: <- storage.remove(key: id)!)
				}
			}
		}

		init () {
			self.ownedNFTs <- {}
		}

		destroy() {
			destroy self.ownedNFTs
		}
	}

	// A function to mint NFTs.
	// You can only call this function if minting
	// is currently active.
	pub fun mintNFT(metadataId: UInt64, recipient: &{NonFungibleToken.Receiver}, payment: @FUSD.Vault, serial: UInt64): UInt64 {
		pre {
			self.canMint(): "Minting is currently closed by the Administrator!"
			payment.balance == self.getPriceOfNFT(metadataId):
				"Payment does not match the price. You passed in ".concat(payment.balance.toString()).concat(" but this NFT costs ").concat(self.getPriceOfNFT(metadataId)!.toString())
		}
		let price: UFix64 = self.getPriceOfNFT(metadataId)!

		// Confirm recipient passes all verifiers
		for verifier in self.getMintVerifiers() {
			let params = {"minter": recipient.owner!.address}
			if let error = verifier.verify(params) {
				panic(error)
			}
		}

		// Handle Emerald City DAO royalty (5%)
		let EmeraldCityTreasury = getAccount(0x5643fd47a29770e7).getCapability(/public/fusdReceiver)
								.borrow<&FUSD.Vault{FungibleToken.Receiver}>()!
		let emeraldCityCut: UFix64 = 0.05 * price

		// Handle royalty to user that was configured upon creation
		if let royalty = TouchstoneTheGritIronNFT.getOptionalCollectionAttribute(key: "royalty") as! MetadataViews.Royalty? {
			royalty.receiver.borrow()!.deposit(from: <- payment.withdraw(amount: price * royalty.cut))
		}

		EmeraldCityTreasury.deposit(from: <- payment.withdraw(amount: emeraldCityCut))

		// Give the rest to the collection owner
		let paymentRecipient = self.account.getCapability(/public/fusdReceiver)
								.borrow<&FUSD.Vault{FungibleToken.Receiver}>()!
		paymentRecipient.deposit(from: <- payment)

		// Mint the nft
		let nft <- create NFT(_metadataId: metadataId, _serial: serial, _recipient: recipient.owner!.address)
		let nftId: UInt64 = nft.id
		let metadata = self.getNFTMetadata(metadataId)!
		self.collectionInfo["profit"] = (self.getCollectionAttribute(key: "profit") as! UFix64) + price

		// Emit event
		emit TouchstonePurchase(id: nftId, recipient: recipient.owner!.address, metadataId: metadataId, name: metadata.name, description: metadata.description, image: metadata.image, price: price)

		// Deposit nft
		recipient.deposit(token: <- nft)

		return nftId
	}

	pub resource Administrator {
		pub fun createNFTMetadata(name: String, description: String, imagePath: String, thumbnailPath: String?, ipfsCID: String, price: UFix64?, extra: {String: AnyStruct}, supply: UInt64) {
			TouchstoneTheGritIronNFT.metadatas[TouchstoneTheGritIronNFT.nextMetadataId] = NFTMetadata(
				_name: name,
				_description: description,
				_image: MetadataViews.IPFSFile(
					cid: ipfsCID,
					path: imagePath
				),
				_thumbnail: thumbnailPath == nil ? nil : MetadataViews.IPFSFile(cid: ipfsCID, path: thumbnailPath),
				_price: price,
				_extra: extra,
				_supply: supply
			)
			TouchstoneTheGritIronNFT.nextMetadataId = TouchstoneTheGritIronNFT.nextMetadataId + 1
		}

		// mintNFT mints a new NFT and deposits
		// it in the recipients collection
		pub fun mintNFT(metadataId: UInt64, serial: UInt64, recipient: Address) {
			pre {
				EmeraldPass.isActive(user: TouchstoneTheGritIronNFT.account.address): "You must have an active Emerald Pass subscription to airdrop NFTs. You can purchase Emerald Pass at https://pass.ecdao.org/"
			}
			let nft <- create NFT(_metadataId: metadataId, _serial: serial, _recipient: recipient)
			if let recipientCollection = getAccount(recipient).getCapability(TouchstoneTheGritIronNFT.CollectionPublicPath).borrow<&TouchstoneTheGritIronNFT.Collection{NonFungibleToken.CollectionPublic}>() {
				recipientCollection.deposit(token: <- nft)
			} else {
				if let storage = &TouchstoneTheGritIronNFT.nftStorage[recipient] as &{UInt64: NFT}? {
					storage[nft.id] <-! nft
				} else {
					TouchstoneTheGritIronNFT.nftStorage[recipient] <-! {nft.id: <- nft}
				}
			}
		}

		pub fun mintBatch(metadataIds: [UInt64], serials: [UInt64], recipients: [Address]) {
			pre {
				metadataIds.length == recipients.length: "You need to pass in an equal number of metadataIds and recipients."
			}
			var i = 0
			while i < metadataIds.length {
				self.mintNFT(metadataId: metadataIds[i], serial: serials[i], recipient: recipients[i])
				i = i + 1
			}

			emit MintBatch(metadataIds: metadataIds, recipients: recipients)
		}

		// create a new Administrator resource
		pub fun createAdmin(): @Administrator {
			return <- create Administrator()
		}

		// change piece of collection info
		pub fun changeField(key: String, value: AnyStruct) {
			TouchstoneTheGritIronNFT.collectionInfo[key] = value
		}
	}

	// public function that anyone can call to create a new empty collection
	pub fun createEmptyCollection(): @NonFungibleToken.Collection {
		return <- create Collection()
	}

	// Get information about a NFTMetadata
	pub fun getNFTMetadata(_ metadataId: UInt64): NFTMetadata? {
		return self.metadatas[metadataId]
	}

	pub fun getNFTMetadatas(): {UInt64: NFTMetadata} {
		return self.metadatas
	}

	pub fun getPrimaryBuyers(): {Address: {UInt64: [UInt64]}} {
		return self.primaryBuyers
	}

	pub fun getCollectionInfo(): {String: AnyStruct} {
		let collectionInfo = self.collectionInfo
		collectionInfo["metadatas"] = self.metadatas
		collectionInfo["primaryBuyers"] = self.primaryBuyers
		collectionInfo["totalSupply"] = self.totalSupply
		collectionInfo["nextMetadataId"] = self.nextMetadataId
		collectionInfo["version"] = 1
		return collectionInfo
	}

	pub fun getCollectionAttribute(key: String): AnyStruct {
		return self.collectionInfo[key] ?? panic(key.concat(" is not an attribute in this collection."))
	}

	pub fun getOptionalCollectionAttribute(key: String): AnyStruct? {
		return self.collectionInfo[key]
	}

	pub fun getMintVerifiers(): [{MintVerifiers.IVerifier}] {
		return self.getCollectionAttribute(key: "mintVerifiers") as! [{MintVerifiers.IVerifier}]
	}

	pub fun canMint(): Bool {
		return self.getCollectionAttribute(key: "minting") as! Bool
	}

	// Returns nil if an NFT with this metadataId doesn't exist
	pub fun getPriceOfNFT(_ metadataId: UInt64): UFix64? {
		if let metadata: TouchstoneTheGritIronNFT.NFTMetadata = self.getNFTMetadata(metadataId) {
			let defaultPrice: UFix64 = self.getCollectionAttribute(key: "price") as! UFix64
			if self.getCollectionAttribute(key: "lotteryBuying") as! Bool {
				return defaultPrice
			}
			return metadata.price ?? defaultPrice
		}
		// If the metadataId doesn't exist
		return nil
	}

	// Returns an mapping of `id` to NFTMetadata
	// for the NFTs a user can claim
	pub fun getClaimableNFTs(user: Address): {UInt64: NFTMetadata} {
		let answer: {UInt64: NFTMetadata} = {}
		if let storage = &TouchstoneTheGritIronNFT.nftStorage[user] as &{UInt64: NFT}? {
			for id in storage.keys {
				let nftRef = (&storage[id] as &NFT?)!
				answer[id] = self.getNFTMetadata(nftRef.metadataId)
			}
		}
		return answer
	}

	init(
		_name: String,
		_description: String,
		_imagePath: String,
		_bannerImagePath: String?,
		_minting: Bool,
		_royalty: MetadataViews.Royalty?,
		_defaultPrice: UFix64,
		_paymentType: String,
		_ipfsCID: String,
		_lotteryBuying: Bool,
		_socials: {String: MetadataViews.ExternalURL},
		_mintVerifiers: [{MintVerifiers.IVerifier}]
	) {
		// Collection Info
		self.collectionInfo = {}
		self.collectionInfo["name"] = _name
		self.collectionInfo["description"] = _description
		self.collectionInfo["image"] = MetadataViews.IPFSFile(
			cid: _ipfsCID,
			path: _imagePath
		)
		if let bannerImagePath = _bannerImagePath {
			self.collectionInfo["bannerImage"] = MetadataViews.IPFSFile(
				cid: _ipfsCID,
				path: _bannerImagePath
			)
		}
		self.collectionInfo["ipfsCID"] = _ipfsCID
		self.collectionInfo["socials"] = _socials
		self.collectionInfo["minting"] = _minting
		self.collectionInfo["lotteryBuying"] = _lotteryBuying
		if let royalty = _royalty {
			assert(royalty.receiver.check(), message: "The passed in royalty receiver is not valid. The royalty account must set up the intended payment token.")
			assert(royalty.cut <= 0.95, message: "The royalty cut cannot be bigger than 95% because 5% goes to Emerald City treasury for primary sales.")
			self.collectionInfo["royalty"] = royalty
		}
		self.collectionInfo["price"] = _defaultPrice
		self.collectionInfo["paymentType"] = _paymentType
		self.collectionInfo["dateCreated"] = getCurrentBlock().timestamp
		self.collectionInfo["mintVerifiers"] = _mintVerifiers
		self.collectionInfo["profit"] = 0.0

		self.nextEditionId = 0
		self.nextMetadataId = 0
		self.totalSupply = 0
		self.metadatas = {}
		self.primaryBuyers = {}
		self.nftStorage <- {}

		// Set the named paths
		// We include the user's address in the paths.
		// This is to prevent clashing with existing
		// Collection paths in the ecosystem.
		self.CollectionStoragePath = /storage/TouchstoneTheGritIronNFTCollection_0x84e5586a3fae8ff3
		self.CollectionPublicPath = /public/TouchstoneTheGritIronNFTCollection_0x84e5586a3fae8ff3
		self.CollectionPrivatePath = /private/TouchstoneTheGritIronNFTCollection_0x84e5586a3fae8ff3
		self.AdministratorStoragePath = /storage/TouchstoneTheGritIronNFTAdministrator_0x84e5586a3fae8ff3

		// Create a Collection resource and save it to storage
		let collection <- create Collection()
		self.account.save(<- collection, to: self.CollectionStoragePath)

		// create a public capability for the collection
		self.account.link<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(
			self.CollectionPublicPath,
			target: self.CollectionStoragePath
		)

		// Create a Administrator resource and save it to storage
		let administrator <- create Administrator()
		self.account.save(<- administrator, to: self.AdministratorStoragePath)

		emit ContractInitialized()
	}
}
 "
-------
"
  import FungibleToken from 0xf233dcee88fe0abe

   access(all) contract brasil: FungibleToken {
      pub var totalSupply: UFix64

      /// TokensInitialized
      ///
      /// The event that is emitted when the contract is created
      pub event TokensInitialized(initialSupply: UFix64)

      /// TokensWithdrawn
      ///
      /// The event that is emitted when tokens are withdrawn from a Vault
      pub event TokensWithdrawn(amount: UFix64, from: Address?)

      /// TokensDeposited
      ///
      /// The event that is emitted when tokens are deposited to a Vault
      pub event TokensDeposited(amount: UFix64, to: Address?)

      /// TokensMinted
      ///
      /// The event that is emitted when new tokens are minted
      pub event TokensMinted(amount: UFix64)


      pub let TokenMinterStoragePath: StoragePath

      pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {
          pub var balance: UFix64

          init(balance: UFix64) {
              self.balance = balance
          }

          pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
              self.balance = self.balance - amount
              emit TokensWithdrawn(amount: amount, from: self.owner?.address)
              return <- create Vault(balance: amount)
          }

          pub fun deposit(from: @FungibleToken.Vault) {
              let vault <- from as! @brasil.Vault
              self.balance = self.balance + vault.balance
              emit TokensDeposited(amount: vault.balance, to: self.owner?.address)
              vault.balance = 0.0
              destroy vault // Make sure we get rid of the vault
          }

          destroy() {
              brasil.totalSupply = brasil.totalSupply - self.balance
          }
      }

      pub fun createEmptyVault(): @FungibleToken.Vault {
          return <- create Vault(balance: 0.0)
      }

      pub resource Minter {
          pub fun mintToken(amount: UFix64): @FungibleToken.Vault {
              brasil.totalSupply = brasil.totalSupply + amount
              return <- create Vault(balance:amount)
          }

      }

      init() {
          self.totalSupply = 0.0

          self.TokenMinterStoragePath = /storage/brasilMinter

          self.account.save(<- create Minter(), to: brasil.TokenMinterStoragePath)
      }
   }

    "
-------
"import CapabilityFactory from 0xea86b9b77d95aeea
import FungibleToken from 0xf233dcee88fe0abe

pub contract FTProviderFactory {
    pub struct Factory: CapabilityFactory.Factory {
        pub fun getCapability(acct: &AuthAccount, path: CapabilityPath): Capability {
            return acct.getCapability<&{FungibleToken.Provider}>(path)
        }
    }
}"
-------
"import LendingConfig from 0x2df970b6cdee5735
import LendingError from 0x2df970b6cdee5735
import LendingInterfaces from 0x2df970b6cdee5735

pub contract LendingAprSnapshot {
    pub let AdminStoragePath: StoragePath
    /// { marketAddr => perMarketAprData}
    access(self) let _markets: {Address: AprSnapshot}

    /// Reserved parameter fields: {ParamName: Value}
    access(self) let _reservedFields: {String: AnyStruct}

    pub event MarketDataTracked(market: Address, marketType: String, startTrackingFrom: UFix64)
    pub event MarketDataErased(market: Address, erasedFrom: UFix64)
    pub event AprSampled(market: Address, truncatedTimestamp: UInt64, supplyApr: UFix64, borrowApr: UFix64)

    /// Per-snapshot data point
    pub struct Observation {
        // Unix timestamp
        pub let timestamp: UFix64
        // supplyApr in ufix64
        pub let supplyApr: UFix64
        // borrowApr in ufix64 (e.g. 0.12345678 => 12.35%)
        pub let borrowApr: UFix64

        init (t: UFix64, supplyApr: UFix64, borrowApr: UFix64) {
            self.timestamp = t
            self.supplyApr = supplyApr
            self.borrowApr = borrowApr
        }
    }

    /// Per-market snapshot configurations and data points
    pub struct AprSnapshot {
        /// Contains functions to query public market data
        pub let poolPublicCap: Capability<&{LendingInterfaces.PoolPublic}>
        /// Each sample covers a 6-hour window: i.e. sampleLength = 21600s
        pub let sampleLength: UInt64
        /// We store 1 year of apr data in maximum: i.e. numSamples = 1460
        pub let numSamples: UInt64
        /// A circular buffer storing apr samples
        access(self) let aprObservations: [Observation]
        /// Reserved parameter fields: {ParamName: Value}
        access(self) let _reservedFields: {String: AnyStruct}

        /// Returns the index into the circular buffer of the given timestamp
        pub fun observationIndexOf(timestamp: UFix64): UInt64 {
            return UInt64(timestamp) / self.sampleLength % self.numSamples
        }

        pub fun sample(): Bool {
            let now = getCurrentBlock().timestamp
            let idx = self.observationIndexOf(timestamp: now)
            let ob = self.aprObservations[idx]
            let timeElapsed = now - ob.timestamp

            if (UInt64(timeElapsed) > self.sampleLength) {
                let poolRef = self.poolPublicCap.borrow()
                    ?? panic("cannot borrow reference to lendingPool")
                let newSupplyApr: UFix64 = LendingConfig.ScaledUInt256ToUFix64(poolRef.getPoolSupplyAprScaled())
                let newBorrowApr: UFix64 = LendingConfig.ScaledUInt256ToUFix64(poolRef.getPoolBorrowAprScaled())
                // Truncate timestamp for better plotting in frontend
                let samplePeriodStart: UInt64 = UInt64(now) / self.sampleLength * self.sampleLength
                self.aprObservations[idx] = Observation(t: UFix64(samplePeriodStart), supplyApr: newSupplyApr, borrowApr: newBorrowApr)
                emit AprSampled(market: poolRef.getPoolAddress(), truncatedTimestamp: samplePeriodStart, supplyApr: newSupplyApr, borrowApr: newBorrowApr)
                return true
            }
            return false
        }

        pub fun queryHistoricalAprData(scale: UInt8, plotPoints: UInt64): [Observation] {
            let now = getCurrentBlock().timestamp
            let idxNow: UInt64 = self.observationIndexOf(timestamp: now)
            var idxPrev: UInt64 = 0
            switch scale {
                case 0:
                    // idx for timestamp 1 month ago
                    idxPrev = self.observationIndexOf(timestamp: now - 30.0 * UFix64(self.sampleLength) * 4.0)
                case 1:
                    // idx for timestamp 6 month ago
                    idxPrev = self.observationIndexOf(timestamp: now - 180.0 * UFix64(self.sampleLength) * 4.0)
                case 2:
                    // idx for timestamp 1 year ago. (Use 360 instead of 365 for the purpose of exact-division)
                    idxPrev = self.observationIndexOf(timestamp: now - 360.0 * UFix64(self.sampleLength) * 4.0)
                default:
                    panic("invalid spanning param")
            }
            let numSampledPoints = idxPrev < idxNow ? (idxNow - idxPrev + 1) : (self.numSamples + idxNow - idxPrev + 1)
            assert(
                plotPoints <= numSampledPoints,
                message: "invalid plotPoints param: cannot plot due to insufficient samples"
            )
            let step: UInt64 = numSampledPoints / plotPoints
            var res: [Observation] = []
            var i: UInt64 = 0
            while i < plotPoints {
                let ob = self.aprObservations[idxPrev]
                // Filtering non-meaningful data
                if (ob.timestamp > 0.0) {
                    res.append(
                        Observation(
                            t: ob.timestamp,
                            supplyApr: ob.supplyApr,
                            borrowApr: ob.borrowApr
                        )
                    )
                }
                idxPrev = idxPrev + step
                if idxPrev >= self.numSamples {
                    idxPrev = idxPrev - self.numSamples
                }
                i = i + 1
            }
            return res
        }

        pub fun getLatestData(): Observation {
            let now = getCurrentBlock().timestamp
            let idx = self.observationIndexOf(timestamp: now)
            return self.aprObservations[idx]
        }

        /// Proposed params: sampleLength = 21600 (6h) && numSamples = 1460 (store 1 year's data)
        init(poolPublicCap: Capability<&{LendingInterfaces.PoolPublic}>) {
            self.poolPublicCap = poolPublicCap
            // 6h
            self.sampleLength = 30
            // stores 1 year's data
            self.numSamples = 1460
            self.aprObservations = []
            var i: UInt64 = 0
            // Init circular buffer
            while (i < self.numSamples) {
                self.aprObservations.append(Observation(t: 0.0, supplyApr: 0.0, borrowApr: 0.0))
                i = i + 1
            }
            self._reservedFields = {}
        }
    }

    /// sample() is made public so everyone can sample the given market's apr data, as long as it's expired.
    /// @Returns sampled or not
    pub fun sample(poolAddr: Address): Bool {
        pre {
            self._markets.containsKey(poolAddr) == true:
                LendingError.ErrorEncode(
                        msg: "Market not tracked yet",
                        err: LendingError.ErrorCode.MARKET_NOT_OPEN
                )
        }
        return self._markets[poolAddr]!.sample()
    }

/////////////// TODO: Check if it's ok to pull 120 x (3 UFix64) in 1 script?
    /// A getter function for frontend to query stored samples and plot data.
    /// @scale: Spanning of time the drawing should cover - 0 (1 month), 1 (6 months), 2 (1 year).
    /// @plotPoints: Maximum data points the drawing needs, e.g. 120 points in maximum
    /// @Returns historical apy data in a timestamp-ascending order. Note: only meaningful data is returned, so the length is not guaranteed to be equal to `plotPoints`.
    pub fun queryHistoricalAprData(poolAddr: Address, scale: UInt8, plotPoints: UInt64): [Observation] {
        pre {
            self._markets.containsKey(poolAddr) == true:
                LendingError.ErrorEncode(
                        msg: "Market not tracked yet",
                        err: LendingError.ErrorCode.MARKET_NOT_OPEN
                )
        }
        return self._markets[poolAddr]!.queryHistoricalAprData(scale: scale, plotPoints: plotPoints)
    }

    pub fun getLatestData(poolAddr: Address): Observation {
        return self._markets[poolAddr]!.getLatestData()
    }

    access(contract) fun trackMarketData(poolAddr: Address) {
        pre {
            self._markets.containsKey(poolAddr) == false:
                LendingError.ErrorEncode(
                        msg: "Market has already been tracked",
                        err: LendingError.ErrorCode.ADD_MARKET_DUPLICATED
                )
        }
        // Start tracking a new market
        let poolPublicCap = getAccount(poolAddr).getCapability<&{LendingInterfaces.PoolPublic}>(LendingConfig.PoolPublicPublicPath)
        assert(poolPublicCap.check() == true, message:
            LendingError.ErrorEncode(
                msg: "Cannot borrow reference to PoolPublic resource",
                err: LendingError.ErrorCode.CANNOT_ACCESS_POOL_PUBLIC_CAPABILITY
            )
        )

        self._markets[poolAddr] = AprSnapshot(poolPublicCap: poolPublicCap)
        emit MarketDataTracked(
            market: poolAddr,
            marketType: poolPublicCap.borrow()!.getUnderlyingTypeString(),
            startTrackingFrom: getCurrentBlock().timestamp
        )
    }

    access(contract) fun eraseMarketData(poolAddr: Address) {
        pre {
            self._markets.containsKey(poolAddr) == true:
                LendingError.ErrorEncode(
                        msg: "Market not tracked yet",
                        err: LendingError.ErrorCode.MARKET_NOT_OPEN
                )
        }
        self._markets.remove(key: poolAddr)
        emit MarketDataErased(
            market: poolAddr,
            erasedFrom: getCurrentBlock().timestamp
        )
    }

    pub resource Admin {
        pub fun trackMarketData(poolAddr: Address) {
            LendingAprSnapshot.trackMarketData(poolAddr: poolAddr)
        }
        pub fun eraseMarketData(poolAddr: Address) {
            LendingAprSnapshot.eraseMarketData(poolAddr: poolAddr)
        }
    }

    init() {
        self.AdminStoragePath = /storage/lendingAprSnapshotAdmin
        self._markets = {}
        self._reservedFields = {}

        destroy <-self.account.load<@AnyResource>(from: self.AdminStoragePath)
        self.account.save(<-create Admin(), to: self.AdminStoragePath)
    }
}"
-------
"pub contract ObjectOrientedOntology {

    pub resource interface SensualObject {
        pub fun undermine(): &[Object]
        pub fun overmine(): [Capability<&Object{SensualObject}>]
    }

    pub resource Object: SensualObject {
        pub(set) var causes: @[Object]
        pub(set) var effects: [Capability<&Object{SensualObject}>]

        init() {
            self.causes <- []
            self.effects = []
        }

        pub fun undermine(): &[Object] {
            return (&self.causes as! &[Object])!
        }

        pub fun overmine(): [Capability<&Object{SensualObject}>] {
            return self.effects
        }

        destroy() {
            destroy self.causes
        }
    }

    pub fun createObject(): @Object {
        return <- create Object()
    }
}
"
-------
"/*
MintMe

This is the contract for MintMe NFTs!

This was implemented using Niftory interfaces. For full details on how this
contract functions, please see the Niftory and NFTRegistry contracts.

*/

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import ViewResolver from 0x1d7e57aa55817448

import MutableMetadata from 0x7ec1f607f0872a9e
import MutableMetadataTemplate from 0x7ec1f607f0872a9e
import MutableMetadataSet from 0x7ec1f607f0872a9e
import MutableMetadataSetManager from 0x7ec1f607f0872a9e
import MetadataViewsManager from 0x7ec1f607f0872a9e

import NiftoryNonFungibleToken from 0x7ec1f607f0872a9e
import NiftoryNFTRegistry from 0x7ec1f607f0872a9e

import NiftoryMetadataViewsResolvers from 0x7ec1f607f0872a9e
import NiftoryNonFungibleTokenProxy from 0x7ec1f607f0872a9e

pub contract MintMe: NonFungibleToken, ViewResolver {

  // ========================================================================
  // Constants
  // ========================================================================

  // Suggested paths where collection could be stored
  pub let COLLECTION_PRIVATE_PATH: PrivatePath
  pub let COLLECTION_PUBLIC_PATH: PublicPath
  pub let COLLECTION_STORAGE_PATH: StoragePath

  // Accessor token to be used with NiftoryNFTRegistry to retrieve
  // meta-information about this NFT project
  pub let REGISTRY_ADDRESS: Address
  pub let REGISTRY_BRAND: String

  // ========================================================================
  // Attributes
  // ========================================================================

  // Arbitrary metadata for this NFT contract
  pub var metadata: AnyStruct?

  // Number of NFTs created
  pub var totalSupply: UInt64

  // ========================================================================
  // Contract Events
  // ========================================================================

  // This contract was initialized
  pub event ContractInitialized()

  // A withdrawal of NFT `id` has occurred from the `from` Address
  pub event Withdraw(id: UInt64, from: Address?)

  // A deposit of an NFT `id` has occurred to the `to` Address
  pub event Deposit(id: UInt64, to: Address?)

  ///////////////////////////////////////////////////////////////////////////

  // Contract metadata was modified
  pub event ContractMetadataUpdated()

  // Metadata Views Manager was locked
  pub event MetadataViewsManagerLocked()

  // Metadata Views Resolver was added
  pub event MetadataViewsResolverAdded(type: Type)

  // Metadata Views Resolver was removed
  pub event MetadataViewsResolverRemoved(type: Type)

  // Set Manager Name or Description updated
  pub event SetManagerMetadataUpdated()

  // Set added to Set Manager
  pub event SetAddedToSetManager(setID: Int)

  ///////////////////////////////////////////////////////////////////////////

  // Set `setId` was locked (no new templates can be added)
  pub event SetLocked(setId: Int)

  // The metadata for Set `setId` was locked and cannot be modified
  pub event SetMetadataLocked(setId: Int)

  // Set `setId` was modified
  pub event SetMetadataModified(setId: Int)

  // A new Template `templateId` was added to Set `setId`
  pub event TemplateAddedToSet(setId: Int, templateId: Int)

  ///////////////////////////////////////////////////////////////////////////

  // Template `templateId` was locked in Set `setId`, which disables minting
  pub event TemplateLocked(setId: Int, templateId: Int)

  // Template `templateId` of Set `setId` had it's maxMint set to `maxMint`
  pub event TemplateMaxMintSet(setId: Int, templateId: Int, maxMint: UInt64)

  // Template `templateId` of Set `setId` has minted NFT with serial `serial`
  pub event NFTMinted(id: UInt64, setId: Int, templateId: Int, serial: UInt64)

  ///////////////////////////////////////////////////////////////////////////

  // The metadata for NFT/Template `templateId` of Set `setId` was locked
  pub event NFTMetadataLocked(setId: Int, templateId: Int)

  // The metadata for NFT/Template `templateId` of Set `setId` was modified
  pub event NFTMetadataModified(setId: Int, templateId: Int)

  ///////////////////////////////////////////////////////////////////////////

  // NFT `serial` from Template `templateId` of Set `setId` was burned
  pub event NFTBurned(setId: Int, templateId: Int, serial: UInt64)

  // ========================================================================
  // NFT
  // ========================================================================

  pub resource NFT:
    NonFungibleToken.INFT,
    MetadataViews.Resolver,
    NiftoryNonFungibleToken.NFTPublic
  {
    pub let id: UInt64
    pub let setId: Int
    pub let templateId: Int
    pub let serial: UInt64

    pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
      return MintMe.contract()
    }

    pub fun set(): &MutableMetadataSet.Set{MutableMetadataSet.Public} {
      return self
        .contract()
        .getSetManagerPublic()
        .getSet(self.setId)
    }

    pub fun metadata(): &MutableMetadata.Metadata{MutableMetadata.Public} {
      return self
        .set()
        .getTemplate(self.templateId)
        .metadata()
    }

    pub fun getViews(): [Type] {
      return self
        .contract()
        .getMetadataViewsManagerPublic()
        .getViews()
    }

    pub fun resolveView(_ view: Type): AnyStruct? {
      let nftRef = &self as &{NiftoryNonFungibleToken.NFTPublic}
      return self
        .contract()
        .getMetadataViewsManagerPublic()
        .resolveView(view: view, nftRef: nftRef)
    }

    init(setId: Int, templateId: Int, serial: UInt64) {
      self.id = MintMe.totalSupply
      MintMe.totalSupply =
        MintMe.totalSupply + 1
      self.setId = setId
      self.templateId = templateId
      self.serial = serial
    }

    destroy() {
      emit NFTBurned(
        setId: self.setId,
        templateId: self.templateId,
        serial: self.serial
      )
    }
  }

  // ========================================================================
  // Collection
  // ========================================================================

  pub resource Collection:
    NonFungibleToken.Provider,
    NonFungibleToken.Receiver,
    NonFungibleToken.CollectionPublic,
    MetadataViews.ResolverCollection,
    NiftoryNonFungibleToken.CollectionPublic,
    NiftoryNonFungibleToken.CollectionPrivate
  {
    pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

    pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
      return MintMe.contract()
    }

    pub fun getIDs(): [UInt64] {
      return self.ownedNFTs.keys
    }

    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
      pre {
        self.ownedNFTs[id] != nil : "NFT "
          .concat(id.toString())
          .concat(" does not exist in collection.")
      }
      return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
    }

    pub fun borrow(id: UInt64): &NFT{NiftoryNonFungibleToken.NFTPublic} {
      pre {
        self.ownedNFTs[id] != nil : "NFT does not exist in collection."
      }
      let nftRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let fullNft = nftRef as! &NFT
      return fullNft
    }

    pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {
      pre {
        self.ownedNFTs[id] != nil : "NFT does not exist in collection."
      }
      let nftRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let fullNft = nftRef as! &NFT
      return fullNft
    }

    pub fun deposit(token: @NonFungibleToken.NFT) {
      let token <- token as! @MintMe.NFT
      let id: UInt64 = token.id
      let oldToken <- self.ownedNFTs[id] <- token
      emit Deposit(id: id, to: self.owner?.address)
      destroy oldToken
    }

    pub fun depositBulk(tokens: @[NonFungibleToken.NFT]) {
      while tokens.length > 0 {
        let token <- tokens.removeLast() as! @MintMe.NFT
        self.deposit(token: <-token)
      }
      destroy tokens
    }

    pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
      pre {
        self.ownedNFTs[withdrawID] != nil
          : "NFT "
            .concat(withdrawID.toString())
            .concat(" does not exist in collection.")
      }
      let token <-self.ownedNFTs.remove(key: withdrawID)!
      emit Withdraw(id: token.id, from: self.owner?.address)
      return <-token
    }

    pub fun withdrawBulk(withdrawIDs: [UInt64]): @[NonFungibleToken.NFT] {
      let tokens: @[NonFungibleToken.NFT] <- []
      while withdrawIDs.length > 0 {
        tokens.append(<- self.withdraw(withdrawID: withdrawIDs.removeLast()))
      }
      return <-tokens
    }

    init() {
      self.ownedNFTs <- {}
    }

    destroy() {
      destroy self.ownedNFTs
    }
  }

  pub fun createEmptyCollection(): @Collection {
    return <-create Collection()
  }

  // ========================================================================
  // Manager
  // ========================================================================

  pub resource Manager:
    NiftoryNonFungibleToken.ManagerPublic,
    NiftoryNonFungibleToken.ManagerPrivate
  {
    // ========================================================================
    // Public
    // ========================================================================

    pub fun metadata(): AnyStruct? {
      return MintMe.metadata
    }

    pub fun getSetManagerPublic():
      &MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public}
    {
      return NiftoryNFTRegistry
        .getSetManagerPublic(
          MintMe.REGISTRY_ADDRESS,
          MintMe.REGISTRY_BRAND
        )
    }

    pub fun getMetadataViewsManagerPublic():
      &MetadataViewsManager.Manager{MetadataViewsManager.Public}
    {
      return NiftoryNFTRegistry
        .getMetadataViewsManagerPublic(
          MintMe.REGISTRY_ADDRESS,
          MintMe.REGISTRY_BRAND
        )
    }

    pub fun getNFTCollectionData(): MetadataViews.NFTCollectionData {
      return NiftoryNFTRegistry
        .buildNFTCollectionData(
          MintMe.REGISTRY_ADDRESS,
          MintMe.REGISTRY_BRAND,
          (fun (): @NonFungibleToken.Collection {
            return <-MintMe.createEmptyCollection()
          })
        )
    }

    // ========================================================================
    // Contract metadata
    // ========================================================================

    pub fun modifyContractMetadata(): auth &AnyStruct {
      emit ContractMetadataUpdated()
      let maybeMetadata = MintMe.metadata
      if maybeMetadata == nil {
        let blankMetadata: {String: String} = {}
        MintMe.metadata = blankMetadata
      }
      return (&MintMe.metadata as auth &AnyStruct?)!
    }

    pub fun replaceContractMetadata(_ metadata: AnyStruct?) {
      emit ContractMetadataUpdated()
      MintMe.metadata = metadata
    }

    // ========================================================================
    // Metadata Views Manager
    // ========================================================================

    access(self) fun _getMetadataViewsManagerPrivate():
      &MetadataViewsManager.Manager{MetadataViewsManager.Private}
    {
      let record =
        NiftoryNFTRegistry.getRegistryRecord(
          MintMe.REGISTRY_ADDRESS,
          MintMe.REGISTRY_BRAND
        )
      let manager =
        MintMe.account
          .getCapability<&MetadataViewsManager.Manager{MetadataViewsManager.Private}>(
            record.metadataViewsManager.paths.private
          ).borrow()!
      return manager
    }

    pub fun lockMetadataViewsManager() {
      self._getMetadataViewsManagerPrivate().lock()
      emit MetadataViewsManagerLocked()
    }

    pub fun setMetadataViewsResolver(
      _ resolver: AnyStruct{MetadataViewsManager.Resolver}
    ) {
      self._getMetadataViewsManagerPrivate().addResolver(resolver)
      emit MetadataViewsResolverAdded(type: resolver.type)
    }

    pub fun removeMetadataViewsResolver(_ type: Type) {
      self._getMetadataViewsManagerPrivate().removeResolver(type)
      emit MetadataViewsResolverRemoved(type: type)
    }

    // ========================================================================
    // Set Manager
    // ========================================================================

    access(self) fun _getSetManagerPrivate():
      &MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public, MutableMetadataSetManager.Private}
    {
      let record =
        NiftoryNFTRegistry.getRegistryRecord(
          MintMe.REGISTRY_ADDRESS,
          MintMe.REGISTRY_BRAND
        )
      let setManager =
        MintMe.account
          .getCapability<&MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public, MutableMetadataSetManager.Private}>(
            record.setManager.paths.private
          ).borrow()!
      return setManager
    }

    pub fun setMetadataManagerName(_ name: String) {
      self._getSetManagerPrivate().setName(name)
      emit SetManagerMetadataUpdated()
    }

    pub fun setMetadataManagerDescription(_ description: String) {
      self._getSetManagerPrivate().setDescription(description)
      emit SetManagerMetadataUpdated()
    }

    pub fun addSet(_ set: @MutableMetadataSet.Set) {
      let setManager = self._getSetManagerPrivate()
      let setId = setManager.numSets()
      setManager.addSet(<-set)
      emit SetAddedToSetManager(setID: setId)
    }

    // ========================================================================
    // Set
    // ========================================================================

    access(self) fun _getSetMutable(_ setId: Int):
      &MutableMetadataSet.Set{MutableMetadataSet.Private,
        MutableMetadataSet.Public} {
      return self._getSetManagerPrivate().getSetMutable(setId)
    }

    pub fun lockSet(setId: Int) {
      self._getSetMutable(setId).lock()
      emit SetLocked(setId: setId)
    }

    pub fun lockSetMetadata(setId: Int) {
      self._getSetMutable(setId).metadataMutable().lock()
      emit SetMetadataLocked(setId: setId)
    }

    pub fun modifySetMetadata(setId: Int): auth &AnyStruct {
      emit SetMetadataModified(setId: setId)
      return self._getSetMutable(setId).metadataMutable().getMutable()
    }

    pub fun replaceSetMetadata(setId: Int, new: AnyStruct) {
      self._getSetMutable(setId).metadataMutable().replace(new)
      emit SetMetadataModified(setId: setId)
    }

    pub fun addTemplate(
      setId: Int,
      template: @MutableMetadataTemplate.Template
    ) {
      let set = self._getSetMutable(setId)
      let templateId = set.numTemplates()
      set.addTemplate(<-template)
      emit TemplateAddedToSet(setId: setId, templateId: templateId)
    }

    // ========================================================================
    // Minting
    // ========================================================================

    access(self) fun _getTemplateMutable(_ setId: Int, _ templateId: Int):
      &MutableMetadataTemplate.Template{MutableMetadataTemplate.Public,
        MutableMetadataTemplate.Private} {
      return self._getSetMutable(setId).getTemplateMutable(templateId)
    }

    pub fun lockTemplate(setId: Int, templateId: Int) {
      self._getTemplateMutable(setId, templateId).lock()
      emit TemplateLocked(setId: setId, templateId: templateId)
    }

    pub fun setTemplateMaxMint(setId: Int, templateId: Int, max: UInt64) {
      self._getTemplateMutable(setId, templateId).setMaxMint(max)
      emit TemplateMaxMintSet(
        setId: setId,
        templateId: templateId,
        maxMint: max
      )
    }

    pub fun mint(setId: Int, templateId: Int): @NonFungibleToken.NFT {
      let template = self._getTemplateMutable(setId, templateId)
      template.registerMint()
      let serial = template.minted()
      let nft <-create NFT(
        setId: setId,
        templateId: templateId,
        serial: serial
      )
      emit NFTMinted(
        id: nft.id,
        setId: setId,
        templateId: templateId,
        serial: serial
      )
      return <-nft
    }

    pub fun mintBulk(
      setId: Int,
      templateId: Int,
      numToMint: UInt64,
    ): @[NonFungibleToken.NFT] {
      pre {
        numToMint > 0: "Must mint at least one NFT"
      }
      let template = self._getTemplateMutable(setId, templateId)
      let nfts: @[NonFungibleToken.NFT] <- []
      var leftToMint = numToMint
      while leftToMint > 0 {
        template.registerMint()
        let serial = template.minted()
        let nft <-create NFT(
          setId: setId,
          templateId: templateId,
          serial: serial
        )
        emit NFTMinted(
          id: nft.id,
          setId: setId,
          templateId: templateId,
          serial: serial
        )
        nfts.append(<-nft)
        leftToMint = leftToMint - 1
      }
      return <-nfts
    }

    // ========================================================================
    // NFT metadata
    // ========================================================================

    access(self) fun _getNFTMetadata(_ setId: Int, _ templateId: Int):
      &MutableMetadata.Metadata{MutableMetadata.Public,
        MutableMetadata.Private
      } {
        return self._getTemplateMutable(setId, templateId).metadataMutable()
    }

    pub fun lockNFTMetadata(setId: Int, templateId: Int) {
      self._getNFTMetadata(setId, templateId).lock()
      emit NFTMetadataLocked(setId: setId, templateId: templateId)
    }

    pub fun modifyNFTMetadata(setId: Int, templateId: Int): auth &AnyStruct {
      emit NFTMetadataModified(setId: setId, templateId: templateId)
      return self._getNFTMetadata(setId, templateId).getMutable()
    }

    pub fun replaceNFTMetadata(setId: Int, templateId: Int, new: AnyStruct) {
      self._getNFTMetadata(setId, templateId).replace(new)
      emit NFTMetadataModified(setId: setId, templateId: templateId)
    }
  }

  // ========================================================================
  // Contract functions
  // ========================================================================

  pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
    return NiftoryNFTRegistry
      .getNFTManagerPublic(
        MintMe.REGISTRY_ADDRESS,
        MintMe.REGISTRY_BRAND
      )
  }

  pub fun getViews(): [Type] {
    let possibleViews = [
      Type<MetadataViews.NFTCollectionDisplay>(),
      Type<MetadataViews.ExternalURL>()
    ]
    let views: [Type] = [Type<MetadataViews.NFTCollectionData>()]

    let viewManager = self.contract().getMetadataViewsManagerPublic()
    for view in possibleViews {
      if viewManager.inspectView(view: view) != nil {
        views.append(view)
      }
    }
    return views
  }

  pub fun resolveView(_ view: Type): AnyStruct? {
    let viewManager = self.contract().getMetadataViewsManagerPublic()
    switch view {

      case Type<MetadataViews.NFTCollectionData>():
        return self.contract().getNFTCollectionData()

      case Type<MetadataViews.NFTCollectionDisplay>():
        let maybeView = viewManager.inspectView(
          view: Type<MetadataViews.NFTCollectionDisplay>()
        )
        if maybeView == nil {
          return nil
        }
        let view = maybeView!

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver

          // External URL
          let externalURL = MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultExternalURLPrefix,
              uri: resolver.defaultExternalURL
            )
          )

          // Square image
          let squareImageURL = NiftoryMetadataViewsResolvers._prefixUri(
            allowedPrefixes:
              NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
            default: resolver.defaultSquareImagePrefix,
            uri: resolver.defaultSquareImage
          )
          let squareImageMediaType = resolver.defaultSquareImageMediaType
          let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: squareImageURL),
            mediaType: squareImageMediaType
          )

          // Banner image
          let bannerImageURL = NiftoryMetadataViewsResolvers._prefixUri(
            allowedPrefixes:
              NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
            default: resolver.defaultBannerImagePrefix,
            uri: resolver.defaultBannerImage
          )
          let bannerImageMediaType = resolver.defaultBannerImageMediaType
          let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
              url: bannerImageURL
            ),
            mediaType: bannerImageMediaType
          )

          return MetadataViews.NFTCollectionDisplay(
            name: resolver.defaultName,
            description: resolver.defaultDescription,
            externalURL: externalURL,
            squareImage: squareImage,
            bannerImage: bannerImage,
            socials: {}

          )
        }

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolverWithIpfsGateway>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolverWithIpfsGateway

          // External URL
          let externalURL = MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultExternalURLPrefix,
              uri: resolver.defaultExternalURL
            )
          )

          // Square image
          let squareImageURL = NiftoryMetadataViewsResolvers._useIpfsGateway(
            ipfsGateway: resolver.ipfsGateway,
            uri: NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultSquareImagePrefix,
              uri: resolver.defaultSquareImage
            )
        )
          let squareImageMediaType = resolver.defaultSquareImageMediaType
          let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: squareImageURL),
            mediaType: squareImageMediaType
          )

          // Banner image
          let bannerImageURL = NiftoryMetadataViewsResolvers._useIpfsGateway(
            ipfsGateway: resolver.ipfsGateway,
            uri: NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultBannerImagePrefix,
              uri: resolver.defaultBannerImage
            )
          )
          let bannerImageMediaType = resolver.defaultBannerImageMediaType
          let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
              url: bannerImageURL
            ),
            mediaType: bannerImageMediaType
          )

          return MetadataViews.NFTCollectionDisplay(
            name: resolver.defaultName,
            description: resolver.defaultDescription,
            externalURL: externalURL,
            squareImage: squareImage,
            bannerImage: bannerImage,
            socials: {}
          )
        }

        return nil

      case Type<MetadataViews.ExternalURL>():
        let maybeView = viewManager.inspectView(
          view: Type<MetadataViews.ExternalURL>()
        )
        if maybeView == nil {
          return nil
        }
        let view = maybeView!

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.ExternalURLResolver>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.ExternalURLResolver
          return MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultPrefix,
              uri: resolver.defaultURL
            )
          )
        }

        return nil
      }
      return nil

  }

  // ========================================================================
  // Init
  // ========================================================================

  init(
    nftManagerProxy: &{
      NiftoryNonFungibleTokenProxy.Public,
      NiftoryNonFungibleTokenProxy.Private
    }
  ) {

    let record = NiftoryNFTRegistry.generateRecord(
      account: self.account.address,
      project: "clatvzb2z00000ilf7yxyjn21_MintMe"
    )

    self.REGISTRY_ADDRESS = 0x32d62d5c43ad1038
    self.REGISTRY_BRAND = "clatvzb2z00000ilf7yxyjn21_MintMe"

    self.COLLECTION_PUBLIC_PATH = record.collectionPaths.public
    self.COLLECTION_PRIVATE_PATH = record.collectionPaths.private
    self.COLLECTION_STORAGE_PATH = record.collectionPaths.storage

    // No metadata to start with
    self.metadata = nil

    // Initialize the total supply to 0.
    self.totalSupply = 0

    // The Manager for this NFT
    //
    // NFT Manager storage
    let nftManager <- create Manager()

    // Save a MutableSetManager to this contract's storage, as the source of
    // this NFT contract's metadata.
    //
    // MutableMetadataSetManager storage
    self
      .account
      .save<@MutableMetadataSetManager.Manager>(
        <-MutableMetadataSetManager.create(
          name: "MintMe",
          description: "The set manager for MintMe."
        ),
        to: record.setManager.paths.storage
      )

    // MutableMetadataSetManager public
    self
      .account
      .link<&MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public}>(
        record.setManager.paths.public,
        target: record.setManager.paths.storage
      )

    // MutableMetadataSetManager private
    self
      .account
      .link<&
        MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public,
        MutableMetadataSetManager.Private
      }>(
        record.setManager.paths.private,
        target: record.setManager.paths.storage
      )

    // Save a MetadataViewsManager to this contract's storage, which will
    // allow observers to inspect standardized metadata through any of its
    // configured MetadataViews resolvers.
    //
    // MetadataViewsManager storage
    self
      .account
      .save<@MetadataViewsManager.Manager>(
        <-MetadataViewsManager.create(),
        to: record.metadataViewsManager.paths.storage
      )

    // MetadataViewsManager public
    self
      .account
      .link<&MetadataViewsManager.Manager{MetadataViewsManager.Public}>(
        record.metadataViewsManager.paths.public,
        target: record.metadataViewsManager.paths.storage
      )

    // MetadataViewsManager private
    self
      .account
      .link<&
        MetadataViewsManager.Manager{MetadataViewsManager.Private,
        MetadataViewsManager.Public
      }>(
        record.metadataViewsManager.paths.private,
        target: record.metadataViewsManager.paths.storage
      )

    let contractName = "MintMe"

    // Royalties
    let royaltiesResolver = NiftoryMetadataViewsResolvers.RoyaltiesResolver(
        royalties: MetadataViews.Royalties([])
    )
    nftManager.setMetadataViewsResolver(royaltiesResolver)

    // Collection Data
    let collectionDataResolver
        = NiftoryMetadataViewsResolvers.NFTCollectionDataResolver()
    nftManager.setMetadataViewsResolver(collectionDataResolver)

    // Display
    let displayResolver = NiftoryMetadataViewsResolvers.DisplayResolver(
        "title",
        contractName.concat("NFT"),
        "description",
        contractName.concat(" NFT"),
        "mediaUrl",
        "ipfs://",
        "ipfs://bafybeig6la3me5x3veull7jzxmwle4sfuaguou2is3o3z44ayhe7ihlqpa/NiftoryBanner.png"
    )
    nftManager.setMetadataViewsResolver(displayResolver)

    // Collection Display
    let collectionResolver = NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver(
        "title",
        contractName,
        "description",
        contractName.concat(" Collection"),
        "domainUrl",
        "https://",
        "https://niftory.com",
        "squareImage",
        "ipfs://",
        "ipfs://bafybeihc76uodw2at2xi2l5jydpvscj5ophfpqgblbrmsfpeffhcmgdtl4/squareImage.png",
        "squareImageMediaType",
        "image/png",
        "bannerImage",
        "ipfs://",
        "ipfs://bafybeig6la3me5x3veull7jzxmwle4sfuaguou2is3o3z44ayhe7ihlqpa/NiftoryBanner.png",
        "bannerImageMediaType",
        "image/png",
        []
    )
    nftManager.setMetadataViewsResolver(collectionResolver)

    // ExternalURL
    let externalURLResolver = NiftoryMetadataViewsResolvers.ExternalURLResolver(
        "domainUrl",
        "https://",
        "https://niftory.com"
    )
    nftManager.setMetadataViewsResolver(externalURLResolver)

    // Save NFT Manager
    self
      .account
      .save<@Manager>(
        <-nftManager,
        to: record.nftManager.paths.storage
      )

    // NFT Manager public
    self
      .account
      .link<&{NiftoryNonFungibleToken.ManagerPublic}>(
        record.nftManager.paths.public,
        target: record.nftManager.paths.storage
      )

    // NFT Manager private
    self
      .account
      .link<&
        Manager{NiftoryNonFungibleToken.ManagerPublic,
        NiftoryNonFungibleToken.ManagerPrivate
      }>(
        record.nftManager.paths.private,
        target: record.nftManager.paths.storage
      )

      nftManagerProxy.add(
        registryAddress: self.REGISTRY_ADDRESS,
        brand: self.REGISTRY_BRAND,
        cap: self.account
              .getCapability<&{
                NiftoryNonFungibleToken.ManagerPrivate,
                NiftoryNonFungibleToken.ManagerPublic
              }>(
                record.nftManager.paths.private
              )
      )
  }
}"
-------
"/*
BreakTickets

This is the contract for BreakTickets NFTs!

This was implemented using Niftory interfaces. For full details on how this
contract functions, please see the Niftory and NFTRegistry contracts.

*/

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import ViewResolver from 0x1d7e57aa55817448

import MutableMetadata from 0x7ec1f607f0872a9e
import MutableMetadataTemplate from 0x7ec1f607f0872a9e
import MutableMetadataSet from 0x7ec1f607f0872a9e
import MutableMetadataSetManager from 0x7ec1f607f0872a9e
import MetadataViewsManager from 0x7ec1f607f0872a9e

import NiftoryNonFungibleToken from 0x7ec1f607f0872a9e
import NiftoryNFTRegistry from 0x7ec1f607f0872a9e

import NiftoryMetadataViewsResolvers from 0x7ec1f607f0872a9e
import NiftoryNonFungibleTokenProxy from 0x7ec1f607f0872a9e

pub contract BreakTickets: NonFungibleToken, ViewResolver {

  // ========================================================================
  // Constants
  // ========================================================================

  // Suggested paths where collection could be stored
  pub let COLLECTION_PRIVATE_PATH: PrivatePath
  pub let COLLECTION_PUBLIC_PATH: PublicPath
  pub let COLLECTION_STORAGE_PATH: StoragePath

  // Accessor token to be used with NiftoryNFTRegistry to retrieve
  // meta-information about this NFT project
  pub let REGISTRY_ADDRESS: Address
  pub let REGISTRY_BRAND: String

  // ========================================================================
  // Attributes
  // ========================================================================

  // Arbitrary metadata for this NFT contract
  pub var metadata: AnyStruct?

  // Number of NFTs created
  pub var totalSupply: UInt64

  // ========================================================================
  // Contract Events
  // ========================================================================

  // This contract was initialized
  pub event ContractInitialized()

  // A withdrawal of NFT `id` has occurred from the `from` Address
  pub event Withdraw(id: UInt64, from: Address?)

  // A deposit of an NFT `id` has occurred to the `to` Address
  pub event Deposit(id: UInt64, to: Address?)

  ///////////////////////////////////////////////////////////////////////////

  // Contract metadata was modified
  pub event ContractMetadataUpdated()

  // Metadata Views Manager was locked
  pub event MetadataViewsManagerLocked()

  // Metadata Views Resolver was added
  pub event MetadataViewsResolverAdded(type: Type)

  // Metadata Views Resolver was removed
  pub event MetadataViewsResolverRemoved(type: Type)

  // Set Manager Name or Description updated
  pub event SetManagerMetadataUpdated()

  // Set added to Set Manager
  pub event SetAddedToSetManager(setID: Int)

  ///////////////////////////////////////////////////////////////////////////

  // Set `setId` was locked (no new templates can be added)
  pub event SetLocked(setId: Int)

  // The metadata for Set `setId` was locked and cannot be modified
  pub event SetMetadataLocked(setId: Int)

  // Set `setId` was modified
  pub event SetMetadataModified(setId: Int)

  // A new Template `templateId` was added to Set `setId`
  pub event TemplateAddedToSet(setId: Int, templateId: Int)

  ///////////////////////////////////////////////////////////////////////////

  // Template `templateId` was locked in Set `setId`, which disables minting
  pub event TemplateLocked(setId: Int, templateId: Int)

  // Template `templateId` of Set `setId` had it's maxMint set to `maxMint`
  pub event TemplateMaxMintSet(setId: Int, templateId: Int, maxMint: UInt64)

  // Template `templateId` of Set `setId` has minted NFT with serial `serial`
  pub event NFTMinted(id: UInt64, setId: Int, templateId: Int, serial: UInt64)

  ///////////////////////////////////////////////////////////////////////////

  // The metadata for NFT/Template `templateId` of Set `setId` was locked
  pub event NFTMetadataLocked(setId: Int, templateId: Int)

  // The metadata for NFT/Template `templateId` of Set `setId` was modified
  pub event NFTMetadataModified(setId: Int, templateId: Int)

  ///////////////////////////////////////////////////////////////////////////

  // NFT `serial` from Template `templateId` of Set `setId` was burned
  pub event NFTBurned(setId: Int, templateId: Int, serial: UInt64)

  // ========================================================================
  // NFT
  // ========================================================================

  pub resource NFT:
    NonFungibleToken.INFT,
    MetadataViews.Resolver,
    NiftoryNonFungibleToken.NFTPublic
  {
    pub let id: UInt64
    pub let setId: Int
    pub let templateId: Int
    pub let serial: UInt64

    pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
      return BreakTickets.contract()
    }

    pub fun set(): &MutableMetadataSet.Set{MutableMetadataSet.Public} {
      return self
        .contract()
        .getSetManagerPublic()
        .getSet(self.setId)
    }

    pub fun metadata(): &MutableMetadata.Metadata{MutableMetadata.Public} {
      return self
        .set()
        .getTemplate(self.templateId)
        .metadata()
    }

    pub fun getViews(): [Type] {
      return self
        .contract()
        .getMetadataViewsManagerPublic()
        .getViews()
    }

    pub fun resolveView(_ view: Type): AnyStruct? {
      let nftRef = &self as &{NiftoryNonFungibleToken.NFTPublic}
      return self
        .contract()
        .getMetadataViewsManagerPublic()
        .resolveView(view: view, nftRef: nftRef)
    }

    init(setId: Int, templateId: Int, serial: UInt64) {
      self.id = BreakTickets.totalSupply
      BreakTickets.totalSupply =
        BreakTickets.totalSupply + 1
      self.setId = setId
      self.templateId = templateId
      self.serial = serial
    }

    destroy() {
      emit NFTBurned(
        setId: self.setId,
        templateId: self.templateId,
        serial: self.serial
      )
    }
  }

  // ========================================================================
  // Collection
  // ========================================================================

  pub resource Collection:
    NonFungibleToken.Provider,
    NonFungibleToken.Receiver,
    NonFungibleToken.CollectionPublic,
    MetadataViews.ResolverCollection,
    NiftoryNonFungibleToken.CollectionPublic,
    NiftoryNonFungibleToken.CollectionPrivate
  {
    pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

    pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
      return BreakTickets.contract()
    }

    pub fun getIDs(): [UInt64] {
      return self.ownedNFTs.keys
    }

    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
      pre {
        self.ownedNFTs[id] != nil : "NFT "
          .concat(id.toString())
          .concat(" does not exist in collection.")
      }
      return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
    }

    pub fun borrow(id: UInt64): &NFT{NiftoryNonFungibleToken.NFTPublic} {
      pre {
        self.ownedNFTs[id] != nil : "NFT does not exist in collection."
      }
      let nftRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let fullNft = nftRef as! &NFT
      return fullNft
    }

    pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {
      pre {
        self.ownedNFTs[id] != nil : "NFT does not exist in collection."
      }
      let nftRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let fullNft = nftRef as! &NFT
      return fullNft
    }

    pub fun deposit(token: @NonFungibleToken.NFT) {
      let token <- token as! @BreakTickets.NFT
      let id: UInt64 = token.id
      let oldToken <- self.ownedNFTs[id] <- token
      emit Deposit(id: id, to: self.owner?.address)
      destroy oldToken
    }

    pub fun depositBulk(tokens: @[NonFungibleToken.NFT]) {
      while tokens.length > 0 {
        let token <- tokens.removeLast() as! @BreakTickets.NFT
        self.deposit(token: <-token)
      }
      destroy tokens
    }

    pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
      pre {
        self.ownedNFTs[withdrawID] != nil
          : "NFT "
            .concat(withdrawID.toString())
            .concat(" does not exist in collection.")
      }
      let token <-self.ownedNFTs.remove(key: withdrawID)!
      emit Withdraw(id: token.id, from: self.owner?.address)
      return <-token
    }

    pub fun withdrawBulk(withdrawIDs: [UInt64]): @[NonFungibleToken.NFT] {
      let tokens: @[NonFungibleToken.NFT] <- []
      while withdrawIDs.length > 0 {
        tokens.append(<- self.withdraw(withdrawID: withdrawIDs.removeLast()))
      }
      return <-tokens
    }

    init() {
      self.ownedNFTs <- {}
    }

    destroy() {
      destroy self.ownedNFTs
    }
  }

  pub fun createEmptyCollection(): @Collection {
    return <-create Collection()
  }

  // ========================================================================
  // Manager
  // ========================================================================

  pub resource Manager:
    NiftoryNonFungibleToken.ManagerPublic,
    NiftoryNonFungibleToken.ManagerPrivate
  {
    // ========================================================================
    // Public
    // ========================================================================

    pub fun metadata(): AnyStruct? {
      return BreakTickets.metadata
    }

    pub fun getSetManagerPublic():
      &MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public}
    {
      return NiftoryNFTRegistry
        .getSetManagerPublic(
          BreakTickets.REGISTRY_ADDRESS,
          BreakTickets.REGISTRY_BRAND
        )
    }

    pub fun getMetadataViewsManagerPublic():
      &MetadataViewsManager.Manager{MetadataViewsManager.Public}
    {
      return NiftoryNFTRegistry
        .getMetadataViewsManagerPublic(
          BreakTickets.REGISTRY_ADDRESS,
          BreakTickets.REGISTRY_BRAND
        )
    }

    pub fun getNFTCollectionData(): MetadataViews.NFTCollectionData {
      return NiftoryNFTRegistry
        .buildNFTCollectionData(
          BreakTickets.REGISTRY_ADDRESS,
          BreakTickets.REGISTRY_BRAND,
          (fun (): @NonFungibleToken.Collection {
            return <-BreakTickets.createEmptyCollection()
          })
        )
    }

    // ========================================================================
    // Contract metadata
    // ========================================================================

    pub fun modifyContractMetadata(): auth &AnyStruct {
      emit ContractMetadataUpdated()
      let maybeMetadata = BreakTickets.metadata
      if maybeMetadata == nil {
        let blankMetadata: {String: String} = {}
        BreakTickets.metadata = blankMetadata
      }
      return (&BreakTickets.metadata as auth &AnyStruct?)!
    }

    pub fun replaceContractMetadata(_ metadata: AnyStruct?) {
      emit ContractMetadataUpdated()
      BreakTickets.metadata = metadata
    }

    // ========================================================================
    // Metadata Views Manager
    // ========================================================================

    access(self) fun _getMetadataViewsManagerPrivate():
      &MetadataViewsManager.Manager{MetadataViewsManager.Private}
    {
      let record =
        NiftoryNFTRegistry.getRegistryRecord(
          BreakTickets.REGISTRY_ADDRESS,
          BreakTickets.REGISTRY_BRAND
        )
      let manager =
        BreakTickets.account
          .getCapability<&MetadataViewsManager.Manager{MetadataViewsManager.Private}>(
            record.metadataViewsManager.paths.private
          ).borrow()!
      return manager
    }

    pub fun lockMetadataViewsManager() {
      self._getMetadataViewsManagerPrivate().lock()
      emit MetadataViewsManagerLocked()
    }

    pub fun setMetadataViewsResolver(
      _ resolver: AnyStruct{MetadataViewsManager.Resolver}
    ) {
      self._getMetadataViewsManagerPrivate().addResolver(resolver)
      emit MetadataViewsResolverAdded(type: resolver.type)
    }

    pub fun removeMetadataViewsResolver(_ type: Type) {
      self._getMetadataViewsManagerPrivate().removeResolver(type)
      emit MetadataViewsResolverRemoved(type: type)
    }

    // ========================================================================
    // Set Manager
    // ========================================================================

    access(self) fun _getSetManagerPrivate():
      &MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public, MutableMetadataSetManager.Private}
    {
      let record =
        NiftoryNFTRegistry.getRegistryRecord(
          BreakTickets.REGISTRY_ADDRESS,
          BreakTickets.REGISTRY_BRAND
        )
      let setManager =
        BreakTickets.account
          .getCapability<&MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public, MutableMetadataSetManager.Private}>(
            record.setManager.paths.private
          ).borrow()!
      return setManager
    }

    pub fun setMetadataManagerName(_ name: String) {
      self._getSetManagerPrivate().setName(name)
      emit SetManagerMetadataUpdated()
    }

    pub fun setMetadataManagerDescription(_ description: String) {
      self._getSetManagerPrivate().setDescription(description)
      emit SetManagerMetadataUpdated()
    }

    pub fun addSet(_ set: @MutableMetadataSet.Set) {
      let setManager = self._getSetManagerPrivate()
      let setId = setManager.numSets()
      setManager.addSet(<-set)
      emit SetAddedToSetManager(setID: setId)
    }

    // ========================================================================
    // Set
    // ========================================================================

    access(self) fun _getSetMutable(_ setId: Int):
      &MutableMetadataSet.Set{MutableMetadataSet.Private,
        MutableMetadataSet.Public} {
      return self._getSetManagerPrivate().getSetMutable(setId)
    }

    pub fun lockSet(setId: Int) {
      self._getSetMutable(setId).lock()
      emit SetLocked(setId: setId)
    }

    pub fun lockSetMetadata(setId: Int) {
      self._getSetMutable(setId).metadataMutable().lock()
      emit SetMetadataLocked(setId: setId)
    }

    pub fun modifySetMetadata(setId: Int): auth &AnyStruct {
      emit SetMetadataModified(setId: setId)
      return self._getSetMutable(setId).metadataMutable().getMutable()
    }

    pub fun replaceSetMetadata(setId: Int, new: AnyStruct) {
      self._getSetMutable(setId).metadataMutable().replace(new)
      emit SetMetadataModified(setId: setId)
    }

    pub fun addTemplate(
      setId: Int,
      template: @MutableMetadataTemplate.Template
    ) {
      let set = self._getSetMutable(setId)
      let templateId = set.numTemplates()
      set.addTemplate(<-template)
      emit TemplateAddedToSet(setId: setId, templateId: templateId)
    }

    // ========================================================================
    // Minting
    // ========================================================================

    access(self) fun _getTemplateMutable(_ setId: Int, _ templateId: Int):
      &MutableMetadataTemplate.Template{MutableMetadataTemplate.Public,
        MutableMetadataTemplate.Private} {
      return self._getSetMutable(setId).getTemplateMutable(templateId)
    }

    pub fun lockTemplate(setId: Int, templateId: Int) {
      self._getTemplateMutable(setId, templateId).lock()
      emit TemplateLocked(setId: setId, templateId: templateId)
    }

    pub fun setTemplateMaxMint(setId: Int, templateId: Int, max: UInt64) {
      self._getTemplateMutable(setId, templateId).setMaxMint(max)
      emit TemplateMaxMintSet(
        setId: setId,
        templateId: templateId,
        maxMint: max
      )
    }

    pub fun mint(setId: Int, templateId: Int): @NonFungibleToken.NFT {
      let template = self._getTemplateMutable(setId, templateId)
      template.registerMint()
      let serial = template.minted()
      let nft <-create NFT(
        setId: setId,
        templateId: templateId,
        serial: serial
      )
      emit NFTMinted(
        id: nft.id,
        setId: setId,
        templateId: templateId,
        serial: serial
      )
      return <-nft
    }

    pub fun mintBulk(
      setId: Int,
      templateId: Int,
      numToMint: UInt64,
    ): @[NonFungibleToken.NFT] {
      pre {
        numToMint > 0: "Must mint at least one NFT"
      }
      let template = self._getTemplateMutable(setId, templateId)
      let nfts: @[NonFungibleToken.NFT] <- []
      var leftToMint = numToMint
      while leftToMint > 0 {
        template.registerMint()
        let serial = template.minted()
        let nft <-create NFT(
          setId: setId,
          templateId: templateId,
          serial: serial
        )
        emit NFTMinted(
          id: nft.id,
          setId: setId,
          templateId: templateId,
          serial: serial
        )
        nfts.append(<-nft)
        leftToMint = leftToMint - 1
      }
      return <-nfts
    }

    // ========================================================================
    // NFT metadata
    // ========================================================================

    access(self) fun _getNFTMetadata(_ setId: Int, _ templateId: Int):
      &MutableMetadata.Metadata{MutableMetadata.Public,
        MutableMetadata.Private
      } {
        return self._getTemplateMutable(setId, templateId).metadataMutable()
    }

    pub fun lockNFTMetadata(setId: Int, templateId: Int) {
      self._getNFTMetadata(setId, templateId).lock()
      emit NFTMetadataLocked(setId: setId, templateId: templateId)
    }

    pub fun modifyNFTMetadata(setId: Int, templateId: Int): auth &AnyStruct {
      emit NFTMetadataModified(setId: setId, templateId: templateId)
      return self._getNFTMetadata(setId, templateId).getMutable()
    }

    pub fun replaceNFTMetadata(setId: Int, templateId: Int, new: AnyStruct) {
      self._getNFTMetadata(setId, templateId).replace(new)
      emit NFTMetadataModified(setId: setId, templateId: templateId)
    }
  }

  // ========================================================================
  // Contract functions
  // ========================================================================

  pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
    return NiftoryNFTRegistry
      .getNFTManagerPublic(
        BreakTickets.REGISTRY_ADDRESS,
        BreakTickets.REGISTRY_BRAND
      )
  }

  pub fun getViews(): [Type] {
    let possibleViews = [
      Type<MetadataViews.NFTCollectionDisplay>(),
      Type<MetadataViews.ExternalURL>()
    ]
    let views: [Type] = [Type<MetadataViews.NFTCollectionData>()]

    let viewManager = self.contract().getMetadataViewsManagerPublic()
    for view in possibleViews {
      if viewManager.inspectView(view: view) != nil {
        views.append(view)
      }
    }
    return views
  }

  pub fun resolveView(_ view: Type): AnyStruct? {
    let viewManager = self.contract().getMetadataViewsManagerPublic()
    switch view {

      case Type<MetadataViews.NFTCollectionData>():
        return self.contract().getNFTCollectionData()

      case Type<MetadataViews.NFTCollectionDisplay>():
        let maybeView = viewManager.inspectView(
          view: Type<MetadataViews.NFTCollectionDisplay>()
        )
        if maybeView == nil {
          return nil
        }
        let view = maybeView!

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver

          // External URL
          let externalURL = MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultExternalURLPrefix,
              uri: resolver.defaultExternalURL
            )
          )

          // Square image
          let squareImageURL = NiftoryMetadataViewsResolvers._prefixUri(
            allowedPrefixes:
              NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
            default: resolver.defaultSquareImagePrefix,
            uri: resolver.defaultSquareImage
          )
          let squareImageMediaType = resolver.defaultSquareImageMediaType
          let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: squareImageURL),
            mediaType: squareImageMediaType
          )

          // Banner image
          let bannerImageURL = NiftoryMetadataViewsResolvers._prefixUri(
            allowedPrefixes:
              NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
            default: resolver.defaultBannerImagePrefix,
            uri: resolver.defaultBannerImage
          )
          let bannerImageMediaType = resolver.defaultBannerImageMediaType
          let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
              url: bannerImageURL
            ),
            mediaType: bannerImageMediaType
          )

          return MetadataViews.NFTCollectionDisplay(
            name: resolver.defaultName,
            description: resolver.defaultDescription,
            externalURL: externalURL,
            squareImage: squareImage,
            bannerImage: bannerImage,
            socials: {}

          )
        }

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolverWithIpfsGateway>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolverWithIpfsGateway

          // External URL
          let externalURL = MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultExternalURLPrefix,
              uri: resolver.defaultExternalURL
            )
          )

          // Square image
          let squareImageURL = NiftoryMetadataViewsResolvers._useIpfsGateway(
            ipfsGateway: resolver.ipfsGateway,
            uri: NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultSquareImagePrefix,
              uri: resolver.defaultSquareImage
            )
        )
          let squareImageMediaType = resolver.defaultSquareImageMediaType
          let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: squareImageURL),
            mediaType: squareImageMediaType
          )

          // Banner image
          let bannerImageURL = NiftoryMetadataViewsResolvers._useIpfsGateway(
            ipfsGateway: resolver.ipfsGateway,
            uri: NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultBannerImagePrefix,
              uri: resolver.defaultBannerImage
            )
          )
          let bannerImageMediaType = resolver.defaultBannerImageMediaType
          let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
              url: bannerImageURL
            ),
            mediaType: bannerImageMediaType
          )

          return MetadataViews.NFTCollectionDisplay(
            name: resolver.defaultName,
            description: resolver.defaultDescription,
            externalURL: externalURL,
            squareImage: squareImage,
            bannerImage: bannerImage,
            socials: {}
          )
        }

        return nil

      case Type<MetadataViews.ExternalURL>():
        let maybeView = viewManager.inspectView(
          view: Type<MetadataViews.ExternalURL>()
        )
        if maybeView == nil {
          return nil
        }
        let view = maybeView!

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.ExternalURLResolver>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.ExternalURLResolver
          return MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultPrefix,
              uri: resolver.defaultURL
            )
          )
        }

        return nil
      }
      return nil

  }

  // ========================================================================
  // Init
  // ========================================================================

  init(
    nftManagerProxy: &{
      NiftoryNonFungibleTokenProxy.Public,
      NiftoryNonFungibleTokenProxy.Private
    }
  ) {

    let record = NiftoryNFTRegistry.generateRecord(
      account: self.account.address,
      project: "cleja1rzo0000l20vexbhn46y_BreakTickets"
    )

    self.REGISTRY_ADDRESS = 0x32d62d5c43ad1038
    self.REGISTRY_BRAND = "cleja1rzo0000l20vexbhn46y_BreakTickets"

    self.COLLECTION_PUBLIC_PATH = record.collectionPaths.public
    self.COLLECTION_PRIVATE_PATH = record.collectionPaths.private
    self.COLLECTION_STORAGE_PATH = record.collectionPaths.storage

    // No metadata to start with
    self.metadata = nil

    // Initialize the total supply to 0.
    self.totalSupply = 0

    // The Manager for this NFT
    //
    // NFT Manager storage
    let nftManager <- create Manager()

    // Save a MutableSetManager to this contract's storage, as the source of
    // this NFT contract's metadata.
    //
    // MutableMetadataSetManager storage
    self
      .account
      .save<@MutableMetadataSetManager.Manager>(
        <-MutableMetadataSetManager.create(
          name: "BreakTickets",
          description: "The set manager for BreakTickets."
        ),
        to: record.setManager.paths.storage
      )

    // MutableMetadataSetManager public
    self
      .account
      .link<&MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public}>(
        record.setManager.paths.public,
        target: record.setManager.paths.storage
      )

    // MutableMetadataSetManager private
    self
      .account
      .link<&
        MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public,
        MutableMetadataSetManager.Private
      }>(
        record.setManager.paths.private,
        target: record.setManager.paths.storage
      )

    // Save a MetadataViewsManager to this contract's storage, which will
    // allow observers to inspect standardized metadata through any of its
    // configured MetadataViews resolvers.
    //
    // MetadataViewsManager storage
    self
      .account
      .save<@MetadataViewsManager.Manager>(
        <-MetadataViewsManager.create(),
        to: record.metadataViewsManager.paths.storage
      )

    // MetadataViewsManager public
    self
      .account
      .link<&MetadataViewsManager.Manager{MetadataViewsManager.Public}>(
        record.metadataViewsManager.paths.public,
        target: record.metadataViewsManager.paths.storage
      )

    // MetadataViewsManager private
    self
      .account
      .link<&
        MetadataViewsManager.Manager{MetadataViewsManager.Private,
        MetadataViewsManager.Public
      }>(
        record.metadataViewsManager.paths.private,
        target: record.metadataViewsManager.paths.storage
      )

    let contractName = "BreakTickets"

    // Royalties
    let royaltiesResolver = NiftoryMetadataViewsResolvers.RoyaltiesResolver(
        royalties: MetadataViews.Royalties([])
    )
    nftManager.setMetadataViewsResolver(royaltiesResolver)

    // Collection Data
    let collectionDataResolver
        = NiftoryMetadataViewsResolvers.NFTCollectionDataResolver()
    nftManager.setMetadataViewsResolver(collectionDataResolver)

    // Display
    let displayResolver = NiftoryMetadataViewsResolvers.DisplayResolver(
        "title",
        contractName.concat("NFT"),
        "description",
        contractName.concat(" NFT"),
        "mediaUrl",
        "ipfs://",
        "ipfs://bafybeig6la3me5x3veull7jzxmwle4sfuaguou2is3o3z44ayhe7ihlqpa/NiftoryBanner.png"
    )
    nftManager.setMetadataViewsResolver(displayResolver)

    // Collection Display
    let collectionResolver = NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver(
        "title",
        contractName,
        "description",
        contractName.concat(" Collection"),
        "domainUrl",
        "https://",
        "https://niftory.com",
        "squareImage",
        "ipfs://",
        "ipfs://bafybeihc76uodw2at2xi2l5jydpvscj5ophfpqgblbrmsfpeffhcmgdtl4/squareImage.png",
        "squareImageMediaType",
        "image/png",
        "bannerImage",
        "ipfs://",
        "ipfs://bafybeig6la3me5x3veull7jzxmwle4sfuaguou2is3o3z44ayhe7ihlqpa/NiftoryBanner.png",
        "bannerImageMediaType",
        "image/png",
        []
    )
    nftManager.setMetadataViewsResolver(collectionResolver)

    // ExternalURL
    let externalURLResolver = NiftoryMetadataViewsResolvers.ExternalURLResolver(
        "domainUrl",
        "https://",
        "https://niftory.com"
    )
    nftManager.setMetadataViewsResolver(externalURLResolver)

    // Save NFT Manager
    self
      .account
      .save<@Manager>(
        <-nftManager,
        to: record.nftManager.paths.storage
      )

    // NFT Manager public
    self
      .account
      .link<&{NiftoryNonFungibleToken.ManagerPublic}>(
        record.nftManager.paths.public,
        target: record.nftManager.paths.storage
      )

    // NFT Manager private
    self
      .account
      .link<&
        Manager{NiftoryNonFungibleToken.ManagerPublic,
        NiftoryNonFungibleToken.ManagerPrivate
      }>(
        record.nftManager.paths.private,
        target: record.nftManager.paths.storage
      )

      nftManagerProxy.add(
        registryAddress: self.REGISTRY_ADDRESS,
        brand: self.REGISTRY_BRAND,
        cap: self.account
              .getCapability<&{
                NiftoryNonFungibleToken.ManagerPrivate,
                NiftoryNonFungibleToken.ManagerPublic
              }>(
                record.nftManager.paths.private
              )
      )
  }
}"
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import AFLNFT from 0x8f9231920da9af6d

pub contract AFLBurnExchange {
    access(self) let tokens: @{UInt64: NonFungibleToken.NFT} // nftId of token to be swapped -> new token

    pub event TokenAddedForExchange(oldTokenId: UInt64, newTokenId: UInt64)
    pub event TokenExchanged(oldTokenId: UInt64, newTokenId: UInt64)

    pub fun getTokenId(id: UInt64): UInt64 {
        let tokenRef = &self.tokens[id] as &NonFungibleToken.NFT?
        return tokenRef?.id ?? 0
    }

    pub fun swap(token: @NonFungibleToken.NFT): @NonFungibleToken.NFT {
        pre {
            token.getType() == Type<@AFLNFT.NFT>() : "Wrong token type."
            self.tokens[token.id] != nil: "No token found available in exchange for the provided token id: ".concat(token.id.toString()
        }
        let oldTokenId = token.id

        // get the token details
        let data = AFLNFT.getNFTData(nftId: token.id)
        let templateId = data.templateId
        let serial = data.mintNumber

        // withdraw new token
        let newToken <- self.tokens.remove(key: token.id) ?? panic("No token found for exchange")

        // burn old token
        destroy token

        emit TokenExchanged(oldTokenId: oldTokenId, newTokenId: newToken.id)

        // return new token to user
        return <- newToken
    }

    pub fun getTokenIds(): [UInt64] {
        return self.tokens.keys
    }

    // nftId = duplicateTokenId
    // @token = new token
    access(account) fun addTokenForExchange(nftId: UInt64, token: @NonFungibleToken.NFT) {
        pre {
            self.tokens[nftId] == nil: "Token already exists: ".concat(nftId.toString())
        }
        let newTokenId = token.id
        self.tokens[nftId] <-! token
        emit TokenAddedForExchange(oldTokenId: nftId, newTokenId: newTokenId)
    }

    access(account) fun withdrawToken(nftId: UInt64): @NonFungibleToken.NFT {
        pre {
            self.tokens[nftId] != nil: "No token found available in exchange for the provided token id: ".concat(nftId.toString())
        }
        let token <- self.tokens.remove(key: nftId)!
        return <- token
    }

    init() {
        self.tokens <- {}
    }
}

"
-------
"import MetadataViews from 0x1d7e57aa55817448
import NonFungibleToken from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import FlowToken from 0x1654653399040a61
import ViewResolver from 0x1d7e57aa55817448

pub contract Piece: NonFungibleToken, ViewResolver {

	// Collection Information
	access(self) let collectionInfo: {String: AnyStruct}

	// Contract Information
	pub var totalSupply: UInt64

    // Events
    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
	pub event Deposit(id: UInt64, to: Address?)
	pub event Minted(id: UInt64, serial: UInt64, recipient: Address, creatorID: UInt64)
	pub event MetadataSuccess(creatorID: UInt64, description: String)
	pub event MetadataError(error: String)

	// Paths
	pub let CollectionStoragePath: StoragePath
	pub let CollectionPublicPath: PublicPath
	pub let CollectionPrivatePath: PrivatePath
	pub let AdministratorStoragePath: StoragePath
	pub let MetadataStoragePath: StoragePath
	pub let MetadataPublicPath: PublicPath

	access(account) let nftStorage: @{Address: {UInt64: NFT}}

	pub resource MetadataStorage: MetadataStoragePublic {
		// List of Creator
		pub var creatorsIds: {UInt64: [NFTMetadata]}

		init () {
			self.creatorsIds = {}
		}
		access(account) fun creatorExist(_ creatorId: UInt64)  {
				if self.creatorsIds[creatorId] == nil {
					self.creatorsIds[creatorId] = []
				}
		}
		access (account) fun metadataIsNew(_ creatorId: UInt64, _ description: String): Bool {
			self.creatorExist(creatorId)
			let metadata = self.findMetadata(creatorId, description)
			if metadata == nil {
				return true
			} else {
				return false
			}
		}
		access(account) fun addMetadata(_ creatorId: UInt64,_ metadata: NFTMetadata) {
				if self.creatorsIds[creatorId] == nil {
					self.creatorsIds[creatorId] = []
				}

				self.creatorsIds[creatorId]?.append(metadata)
		}

		access(account) fun updateMinted(_ creatorId: UInt64,_ description: String) {
			let metadataRef = self.findMetadataRef(creatorId, description)!
			metadataRef.updateMinted()

		}
				// Public Functions
		pub fun findMetadataRef(_ creatorId: UInt64,_ description: String): &Piece.NFTMetadata? {
			let metadatas = self.creatorsIds[creatorId]!
			var i = metadatas.length - 1
    		while i >= 0 {
			    if (metadatas[i].description == description) {
					let metadataRef: &Piece.NFTMetadata = (&self.creatorsIds[creatorId]![i] as &NFTMetadata)
					return metadataRef
				 }
    			i = i - 1
    		}
			return nil
		}

		// Public Functions
		pub fun findMetadata(_ creatorId: UInt64,_ description: String): Piece.NFTMetadata? {
			let metadatas = self.creatorsIds[creatorId]!
			var i = metadatas.length - 1
    		while i >= 0 {
			    if (metadatas[i].description == description) {
					return metadatas[i]
				 }
    			i = i - 1
    		}
			return nil
		}
		pub fun getTimeRemaining(_ creatorID: UInt64,_ description: String): UFix64? {
			let metadata = self.findMetadata(creatorID, description)!
			let answer = (metadata.creationTime + 86400.0) - getCurrentBlock().timestamp
			return answer
		}
	}

    /// Defines the methods that are particular to this NFT contract collection
    ///
    pub resource interface MetadataStoragePublic {
		pub fun getTimeRemaining(_ creatorID: UInt64,_ description: String): UFix64?
		pub fun findMetadata(_ creatorId: UInt64,_ description: String): Piece.NFTMetadata?
    }

	pub struct NFTMetadata {
		pub let creatorID: UInt64
		pub var creatorUsername: String
		pub let creatorAddress: Address
		pub let description: String
		pub let image: MetadataViews.HTTPFile
		pub let metadataId: UInt64
		pub var supply: UInt64
		pub var minted: UInt64
		pub let unlimited: Bool
		pub var extra: {String: AnyStruct}
		pub var timer: UInt64
		pub let pieceCreationDate: String
		pub let contentCreationDate: String
		pub let creationTime: UFix64
		pub let lockdownTime: UFix64
		pub let embededHTML: String

		access(account) fun updateMinted() {
			self.minted = self.minted + 1
			if(self.unlimited) {
				self.supply = self.supply + 1
			}
		}
		init(
			_creatorID: UInt64,
			_creatorUsername: String,
			_creatorAddress: Address,
			_description: String,
			_image: MetadataViews.HTTPFile,
			_supply: UInt64,
			_extra: {String: AnyStruct},
			_pieceCreationDate: String,
			_contentCreationDate: String,
			_currentTime: UFix64,
			_lockdownTime: UFix64,
			_embededHTML: String,
			) {

			self.metadataId = _creatorID
			self.creatorID = _creatorID
			self.creatorUsername = _creatorUsername
			self.creatorAddress = _creatorAddress
			self.description = _description
			self.image = _image
			self.extra = _extra
			self.supply = _supply
			self.unlimited = _supply == 0
			self.minted = 0
			self.timer = 0
			self.pieceCreationDate = _pieceCreationDate
			self.contentCreationDate = _contentCreationDate
			self.creationTime = _currentTime
			self.lockdownTime = _lockdownTime
			self.embededHTML = _embededHTML
		}
	}

	pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
		pub let id: UInt64
		// The 'metadataId' is what maps this NFT to its 'NFTMetadata'
		pub let creatorID: UInt64
		pub let serial: UInt64
		pub let description: String
		pub let originalMinter: Address

		pub fun getMetadata(): NFTMetadata {
			return Piece.getNFTMetadata(self.creatorID, self.description )!
		}

		pub fun getViews(): [Type] {
			return [
				Type<MetadataViews.Display>(),
				Type<MetadataViews.ExternalURL>(),
				Type<MetadataViews.NFTCollectionData>(),
				Type<MetadataViews.NFTCollectionDisplay>(),
				Type<MetadataViews.Royalties>(),
				Type<MetadataViews.Serial>(),
				Type<MetadataViews.NFTView>()
			]
		}

		pub fun resolveView(_ view: Type): AnyStruct? {
			let metadata = self.getMetadata()
			switch view {
				case Type<MetadataViews.Display>():
					return MetadataViews.Display(
						creatorID: metadata.creatorUsername.concat(" ").concat(metadata.contentCreationDate),
						description: metadata.description,
						thumbnail: metadata.image
					)
				case Type<MetadataViews.Traits>():
					let metaCopy = metadata.extra
					metaCopy["Serial"] = self.serial
					return MetadataViews.dictToTraits(dict: metaCopy, excludedNames: nil)

				case Type<MetadataViews.NFTView>():
					return MetadataViews.NFTView(
						id: self.id,
						uuid: self.uuid,
						display: self.resolveView(Type<MetadataViews.Display>()) as! MetadataViews.Display?,
						externalURL: self.resolveView(Type<MetadataViews.ExternalURL>()) as! MetadataViews.ExternalURL?,
						collectionData: self.resolveView(Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?,
						collectionDisplay: self.resolveView(Type<MetadataViews.NFTCollectionDisplay>()) as! MetadataViews.NFTCollectionDisplay?,
						royalties: self.resolveView(Type<MetadataViews.Royalties>()) as! MetadataViews.Royalties?,
						traits: self.resolveView(Type<MetadataViews.Traits>()) as! MetadataViews.Traits?
					)
				case Type<MetadataViews.NFTCollectionData>():
					return Piece.resolveView(view)
        		case Type<MetadataViews.ExternalURL>():
        			return Piece.getCollectionAttribute(key: "website") as! MetadataViews.ExternalURL
		        case Type<MetadataViews.NFTCollectionDisplay>():
					return Piece.resolveView(view)
				case Type<MetadataViews.Medias>():
					if metadata.embededHTML != nil {
						return MetadataViews.Medias(
							items: [
								MetadataViews.Media(
									file: MetadataViews.HTTPFile(
										url: metadata.embededHTML
									),
									mediaType: "html"
								)
							]
						)
					}
        		case Type<MetadataViews.Royalties>():
          			return MetadataViews.Royalties([
            			MetadataViews.Royalty(
              				recepient: getAccount(metadata.creatorAddress).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),
              				cut: 0.10, // 10% royalty on secondary sales
              				description: "The creator of the original content gets 10% of every secondary sale."
            			)
          			])
				case Type<MetadataViews.Serial>():
					return MetadataViews.Serial(
						self.serial
					)
			}
			return nil
		}

		init(_creatorID: UInt64, _description: String, _recipient: Address) {

			// Fetch the metadata blueprint
			let metadatas = Piece.account.borrow<&Piece.MetadataStorage>(from: Piece.MetadataStoragePath)!
			let metadataRef = metadatas.findMetadata(_creatorID, _description)!
			// Assign serial number to the NFT based on the number of minted NFTs
			self.id = self.uuid
			self.creatorID = _creatorID
			self.serial = metadataRef.minted + 1
			self.description = _description
			self.originalMinter = _recipient

			// Update the total supply of this MetadataId by 1
			metadatas.updateMinted(_creatorID, _description)
			// Update Piece collection NFTs count
			Piece.totalSupply = Piece.totalSupply + 1

			emit Minted(id: self.id, serial: self.serial, recipient: _recipient, creatorID: _creatorID)

		//	Piece.account.save(<- metadatas, to: Piece.MetadataStoragePath)
		}
	}

    /// Defines the methods that are particular to this NFT contract collection
    ///
    pub resource interface PieceCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowPiece(id: UInt64): &Piece.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow Piece NFT reference: the ID of the returned reference is incorrect"
            }
        }
    }

	pub resource Collection: PieceCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {

		pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

		// Withdraw removes an NFT from the collection and moves it to the caller(for Trading)
		pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
			let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

			emit Withdraw(id: token.id, from: self.owner?.address)

			return <-token
		}
		// Deposit takes a NFT and adds it to the collections dictionary
		// and adds the ID to the id array
		pub fun deposit(token: @NonFungibleToken.NFT) {
			let token <- token as! @NFT

			let id: UInt64 = token.id

			// Add the new token to the dictionary
			self.ownedNFTs[id] <-! token

			emit Deposit(id: id, to: self.owner?.address)
		}

		// GetIDs returns an array of the IDs that are in the collection
		pub fun getIDs(): [UInt64] {
			return self.ownedNFTs.keys
		}

		// BorrowNFT gets a reference to an NFT in the collection
		pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
			return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
		}

        /// Gets a reference to an NFT in the collection so that
        /// the caller can read its metadata and call its methods
        ///
        /// @param id: The ID of the wanted NFT
        /// @return A reference to the wanted NFT resource
        ///
        pub fun borrowPiece(id: UInt64): &Piece.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorized reference to allow downcasting
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &Piece.NFT
            }

            return nil
        }

		pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
			let token = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
			let nft = token as! &NFT
			return nft
		}

		pub fun claim() {
			if let storage = &Piece.nftStorage[self.owner!.address] as &{UInt64: NFT}? {
				for id in storage.keys {
					self.deposit(token: <- storage.remove(key: id)!)
				}
			}
		}

		init () {
			self.ownedNFTs <- {}
		}

		destroy() {
			destroy self.ownedNFTs
		}
	}

	pub resource Administrator {
		// Function to upload the Metadata to the contract.
		pub fun createNFTMetadata(
			channel: String,
			creatorID: UInt64,
			creatorUsername: String,
			creatorAddress: Address,
			sourceURL: String,
			description: String,
			pieceCreationDate: String,
			contentCreationDate: String,
			lockdownOption: Int,
			supplyOption: UInt64,
			imgUrl: String,
			embededHTML: String,
		) {
			// Load the metadata from the Piece account
			let metadatas = Piece.account.borrow<&Piece.MetadataStorage>(from: Piece.MetadataStoragePath)!
				// Check if Metadata already exist
			if metadatas.metadataIsNew(creatorID, description) {
					metadatas.addMetadata(creatorID, NFTMetadata(
							_creatorID: creatorID,
							_creatorUsername: creatorUsername,
							_creatorAddress: creatorAddress,
							_description: description,
							_image: MetadataViews.HTTPFile(
								url: imgUrl,
							),
							_supply: supplyOption,
							_extra: {
								"Creator username": creatorUsername,
								"Creator ID": creatorID,
								"Channel": channel,
								"Text content": description,
								"Source": sourceURL,
								"Piece creation date": pieceCreationDate,
								"Content creation date": contentCreationDate
								},
							_pieceCreationDate: pieceCreationDate,
							_contentCreationDate: contentCreationDate,
							_currentTime: getCurrentBlock().timestamp,
							_lockdownTime: self.getLockdownTime(lockdownOption),
							_embededHTML: embededHTML,
					))
					emit MetadataSuccess(creatorID: creatorID, description: description)
				} else {
					emit MetadataError(error: "A Metadata for this Event already exist")
				}

			// Piece.account.save(<- metadatas, to: Piece.MetadataStoragePath)
		}

		// mintNFT mints a new NFT and deposits
		// it in the recipients collection
		pub fun mintNFT(creatorId: UInt64, description: String, recipient: Address) {
			pre {
				self.isMintingAvailable(creatorId, description): "Minting for this NFT has ended or reached max supply."
			}

			let nft <- create NFT(_creatorID: creatorId, _description: description, _recipient: recipient)

			if let recipientCollection = getAccount(recipient).getCapability(Piece.CollectionPublicPath).borrow<&Piece.Collection{NonFungibleToken.CollectionPublic}>() {
				recipientCollection.deposit(token: <- nft)
			} else {
				if let storage = &Piece.nftStorage[recipient] as &{UInt64: NFT}? {
					storage[nft.id] <-! nft
				} else {
					Piece.nftStorage[recipient] <-! {nft.id: <- nft}
				}
			}
		}

		// create a new Administrator resource
		pub fun createAdmin(): @Administrator {
			return <- create Administrator()
		}
		// change piece of collection info
		pub fun changeField(key: String, value: AnyStruct) {
			Piece.collectionInfo[key] = value
		}
		access(account) fun isMintingAvailable(_ creatorId: UInt64, _ description: String): Bool {
			let metadata = Piece.getNFTMetadata(creatorId, description)!
			if (metadata.unlimited) {
				if (metadata.lockdownTime != 0.0) {
					let answer = getCurrentBlock().timestamp <= (metadata.creationTime + metadata.lockdownTime)
					return answer

				} else {
					return true
				}
			} else {
				if(metadata.minted < metadata.supply) {
					if (metadata.lockdownTime != 0.0) {
						let answer = getCurrentBlock().timestamp <= (metadata.creationTime + metadata.lockdownTime)
						return answer

					} else {
						return true
					}

				} else {
					return false
				}
			}

		}
		access(account) fun getLockdownTime(_ lockdownOption: Int): UFix64 {
			switch lockdownOption {
				case 0:
					return 21600.0
				case 1:
					return 43200.0
				case 2:
					return 86400.0
				case 3:
					return 172800.0
				default:
					return 0.0
			}
		}

	}


	// public function that anyone can call to create a new empty collection
	pub fun createEmptyCollection(): @NonFungibleToken.Collection {
		return <- create Collection()
	}

    /// Function that resolves a metadata view for this contract.
    ///
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    pub fun resolveView(_ view: Type): AnyStruct? {
        switch view {
            case Type<MetadataViews.NFTCollectionData>():
                return MetadataViews.NFTCollectionData(
                    storagePath: Piece.CollectionStoragePath,
                    publicPath: Piece.CollectionPublicPath,
                    providerPath: Piece.CollectionPrivatePath,
                    publicCollection: Type<&Piece.Collection{Piece.PieceCollectionPublic}>(),
                    publicLinkedType: Type<&Piece.Collection{Piece.PieceCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
                    providerLinkedType: Type<&Piece.Collection{Piece.PieceCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(),
                    createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                        return <-Piece.createEmptyCollection()
                    })
                )
            case Type<MetadataViews.NFTCollectionDisplay>():
				let media = Piece.getCollectionAttribute(key: "image") as! MetadataViews.Media
                return MetadataViews.NFTCollectionDisplay(
                        name: "Piece",
                        description: "Sell Pieces of any Tweet in seconds.",
                        externalURL: MetadataViews.ExternalURL("https://piece.gg/"),
                        squareImage: media,
                        bannerImage: media,
                        socials: {
                            "twitter": MetadataViews.ExternalURL("https://twitter.com/CreateAPiece")
                        }
                    )
        }
        return nil
    }

	// Get information about a NFTMetadata
	pub fun getNFTMetadata(_ creatorId: UInt64,_ description: String): Piece.NFTMetadata? {
		let publicAccount = self.account
		let metadataCapability: Capability<&AnyResource{Piece.MetadataStoragePublic}> = publicAccount.getCapability<&{MetadataStoragePublic}>(self.MetadataPublicPath)
		let metadatasRef: &AnyResource{Piece.MetadataStoragePublic} = metadataCapability.borrow()!
		let metadatas: Piece.NFTMetadata? = metadatasRef.findMetadata(creatorId, description)

		return metadatas
	}

	pub fun getCollectionInfo(): {String: AnyStruct} {
		let collectionInfo = self.collectionInfo
		collectionInfo["totalSupply"] = self.totalSupply
		collectionInfo["version"] = 1
		return collectionInfo
	}

	pub fun getCollectionAttribute(key: String): AnyStruct {
		return self.collectionInfo[key] ?? panic(key.concat(" is not an attribute in this collection."))
	}

	init() {
		// Collection Info
		self.collectionInfo = {}
		self.collectionInfo["name"] = "Piece"
		self.collectionInfo["description"] = "Sell Pieces of any Tweet in seconds."
		self.collectionInfo["image"] = MetadataViews.Media(
            			file: MetadataViews.HTTPFile(
            				url: "https://media.discordapp.net/attachments/1075564743152107530/1149417271597473913/Piece_collection_image.png?width=1422&height=1422"
            			),
            			mediaType: "image/jpeg"
          			)
    	self.collectionInfo["dateCreated"] = getCurrentBlock().timestamp
    	self.collectionInfo["website"] = MetadataViews.ExternalURL("https://www.piece.gg/")
		self.collectionInfo["socials"] = {"Twitter": MetadataViews.ExternalURL("https://frontend-react-git-testing-piece.vercel.app/")}
		self.totalSupply = 0
		self.nftStorage <- {}

		let identifier = "Piece_Collection".concat(self.account.address.toString())

		// Set the named paths
		self.CollectionStoragePath = StoragePath(identifier: identifier)!
		self.CollectionPublicPath = PublicPath(identifier: identifier)!
		self.CollectionPrivatePath = PrivatePath(identifier: identifier)!
		self.AdministratorStoragePath = StoragePath(identifier: identifier.concat("_Administrator"))!
		self.MetadataStoragePath = StoragePath(identifier: identifier.concat("_Metadata"))!
		self.MetadataPublicPath = PublicPath(identifier: identifier.concat("_Metadata"))!

		// Create a Collection resource and save it to storage
		let collection <- create Collection()
		self.account.save(<- collection, to: self.CollectionStoragePath)

		// Create a public capability for the collection
		self.account.link<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(
			self.CollectionPublicPath,
			target: self.CollectionStoragePath
		)

		// Create a Administrator resource and save it to Piece account storage
		let administrator <- create Administrator()
		self.account.save(<- administrator, to: self.AdministratorStoragePath)

		// Create a Metadata Storage resource and save it to Piece account storage
		let metadataStorage <- create MetadataStorage()
		self.account.save(<- metadataStorage, to: self.MetadataStoragePath)

		// Create a public capability for the Metadata Storage
		self.account.link<&MetadataStorage{MetadataStoragePublic}>(
			self.MetadataPublicPath,
			target: self.MetadataStoragePath
		)

		emit ContractInitialized()
	}
}
"
-------
"import MIKOSEANFTV2 from 0x0b80e42aaab305f0
import MIKOSEANFT from 0x0b80e42aaab305f0
import MikoSeaMarket from 0x0b80e42aaab305f0

pub contract MikoSeaUtility {
    // rate transform from yen to usd, ex: {"USD_TO_JPY": 171.2}
    pub var ratePrice: {String:UFix64}
    access(self) var metadata: {String:String}

    pub let AdminStoragePath: StoragePath
    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath

    // is not in used
    pub struct NFTDataCommon { }
    pub struct NFTDataWithListing { }

    pub struct NFTDataCommonWithListing {
        pub let id: UInt64
        pub let serialNumber: UInt64
        pub let image: String
        pub let name: String
        pub let nftMetadata: {String:String}
        pub let nftType: String

        pub let projectId: UInt64
        pub let projectTitle: String
        pub let projectDescription: String
        pub let flowProjectId: UInt64
        pub let projectMaxSupply: UInt64
        pub let isNFTReveal: Bool

        pub let blockHeight: UInt64
        pub let holder: Address
        pub let isInMarket: Bool
        pub let listingId: UInt64?

        init(id: UInt64,
        serialNumber: UInt64,
        name: String,
        image: String,
        nftMetadata: {String:String},
        projectId: UInt64,
        isNFTReveal: Bool,
        projectTitle: String,
        projectDescription: String,
        maxSupply: UInt64,
        blockHeight: UInt64,
        holder: Address,
        listingId: UInt64?,
        nftType: String
        ){
            self.id = id
            self.serialNumber = serialNumber
            self.projectId = projectId
            self.flowProjectId = projectId
            self.image = image
            self.isNFTReveal = isNFTReveal
            self.projectTitle = projectTitle
            self.projectDescription = projectDescription
            self.name = name
            self.nftMetadata = nftMetadata
            self.blockHeight = blockHeight
            self.projectMaxSupply = maxSupply
            self.holder = holder
            self.isInMarket = listingId != nil
            self.listingId = listingId
            self.nftType = nftType
        }
    }

    pub fun yenToDollar(yen: UFix64): UFix64 {
        if MikoSeaUtility.ratePrice["USD_TO_JPY"] == nil {
        return 0.0
        }
        if MikoSeaUtility.ratePrice["USD_TO_JPY"]! <= 0.0 {
        return 0.0
        }
        return yen / MikoSeaUtility.ratePrice["USD_TO_JPY"]!
    }

    pub resource Admin {
        pub fun updateRate(key: String, value: UFix64) {
            MikoSeaUtility.ratePrice[key] = value
        }
    }

    pub fun floor(_ num: Fix64): Int {
        var strRes = ""
        var numStr = num.toString()
        var i = 0;
        while i < numStr.length {
            if numStr[i] == "." {
                break;
            }
            strRes = strRes.concat(numStr.slice(from: i, upTo: i + 1))
            i = i + 1
        }
        let numInt = Int.fromString(strRes) ?? 0
        if Fix64(numInt) == num {
            return numInt
        }
        if num >= 0.0 {
            return numInt
        }
        return numInt - 1
    }

    pub fun getListingId(addr: Address, nftType: Type, nftID: UInt64): UInt64? {
        if let ref = getAccount(addr).getCapability<&{MikoSeaMarket.StorefrontPublic}>(MikoSeaMarket.MarketPublicPath).borrow() {
            for order in ref.getOrders() {
                if nftID == order.nftID && order.nftType == nftType && order.status != "done" {
                    return order.getId()
                }
            }
        }
        return nil
    }

    pub fun getNftV2Detail(_ nftID: UInt64): NFTDataCommonWithListing? {
        if let addr = MIKOSEANFTV2.getHolder(nftID: nftID) {
            let account = getAccount(addr)
            let collectioncap = account.getCapability<&{MIKOSEANFTV2.CollectionPublic}>(MIKOSEANFTV2.CollectionPublicPath)
            if let collectionRef = collectioncap.borrow() {
                if let nft = collectionRef.borrowMIKOSEANFTV2(id: nftID) {
                    let project = MIKOSEANFTV2.getProjectById(nft.nftData.projectId)!
                    return NFTDataCommonWithListing(
                        id: nft.id,
                        serialNumber: nft.nftData.serialNumber,
                        name: nft.getMetadata()["name"] ?? "",
                        image: nft.getImage(),
                        nftMetadata: nft.getMetadata(),
                        projectId: project.projectId,
                        isNFTReveal: project.isReveal,
                        projectTitle: nft.getTitle(),
                        projectDescription: nft.getDescription(),
                        maxSupply: project.maxSupply,
                        blockHeight: nft.nftData.blockHeight,
                        holder: addr,
                        listingId: MikoSeaUtility.getListingId(addr: addr, nftType: Type<@MIKOSEANFTV2.NFT>(), nftID: nft.id),
                        nftType: "mikoseav2"
                    )
                }
            }
        }
        return nil
    }

    pub fun getNftV1Detail(addr: Address, nftID: UInt64): NFTDataCommonWithListing? {
        let account = getAccount(addr)
        let collectionCapability = account.getCapability<&{MIKOSEANFT.MikoSeaCollectionPublic}>(MIKOSEANFT.CollectionPublicPath)
        let collectionRef = collectionCapability.borrow()
        if let collectionRef = collectionCapability.borrow() {
            if let nft = collectionRef.borrowMiKoSeaNFT(id: nftID) {
                let listingId= MikoSeaUtility.getListingId(addr: addr, nftType: Type<@MIKOSEANFTV2.NFT>(), nftID: nft.id)
                return NFTDataCommonWithListing(
                    id: nft.id,
                    serialNumber: nft.data.mintNumber,
                    name: nft.getTitle(),
                    image: nft.getImage(),
                    nftMetadata: {},
                    projectId: nft.data.projectId,
                    isNFTReveal: true,
                    projectTitle: nft.getTitle(),
                    projectDescription: nft.getDescription(),
                    maxSupply: MIKOSEANFT.getProjectTotalSupply(nft.data.projectId),
                    blockHeight: 0,
                    holder: addr,
                    listingId: MikoSeaUtility.getListingId(addr: addr, nftType: Type<@MIKOSEANFT.NFT>(), nftID: nft.id),
                    nftType: "mikosea"
                )
            }
        }
        return nil
    }

    pub fun parseNftV2List(_ nfts: [&MIKOSEANFTV2.NFT]): [NFTDataCommonWithListing] {
        let projects: {UInt64: &MIKOSEANFTV2.ProjectData} = {}
        let response: [NFTDataCommonWithListing] = []
        for nft in nfts {
            if projects[nft.nftData.projectId] == nil {
                projects[nft.nftData.projectId] = MIKOSEANFTV2.getProjectById(nft.nftData.projectId)!
            }
            let project = projects[nft.nftData.projectId]!
            if let addr = MIKOSEANFTV2.getHolder(nftID: nft.id) {
                let listingId= MikoSeaUtility.getListingId(addr: addr, nftType: Type<@MIKOSEANFTV2.NFT>(), nftID: nft.id)
                response.append(
                    NFTDataCommonWithListing(
                        id: nft.id,
                        serialNumber: nft.nftData.serialNumber,
                        name: nft.getMetadata()["name"] ?? "",
                        image: nft.getImage(),
                        nftMetadata: nft.getMetadata(),
                        projectId: project.projectId,
                        isNFTReveal: project.isReveal,
                        projectTitle: nft.getTitle(),
                        projectDescription: nft.getDescription(),
                        maxSupply: project.maxSupply,
                        blockHeight: nft.nftData.blockHeight,
                        holder: addr,
                        listingId: MikoSeaUtility.getListingId(addr: addr, nftType: Type<@MIKOSEANFTV2.NFT>(), nftID: nft.id),
                        nftType: "mikoseav2"
                    )
                )
            }
        }
        return response
    }

    init() {
        self.AdminStoragePath = /storage/MikoSeaUtilityAdminStoragePath
        self.CollectionStoragePath = /storage/MikoSeaUtilityCollectionStoragePath
        self.CollectionPublicPath = /public/MikoSeaUtilityCollectionPublicPath

        self.ratePrice = {
            "USD_TO_JPY": 130.75
        }
        self.metadata = { }

        // Put the Admin in storage
        self.account.save(<- create Admin(), to: self.AdminStoragePath)
    }
}
"
-------
"/// RandomBeaconHistory (FLIP 123)
///
/// This contract stores the history of random sources generated by the Flow network. The defined Heartbeat resource is
/// updated by the Flow Service Account at the end of every block with that block's source of randomness.
///
/// While the source values are safely generated by the Random Beacon (non-predictable, unbiasable, verifiable) and transmitted into the execution
/// environment via the committing transaction, using the raw values from this contract does not guarantee non-revertible
/// randomness. The Hearbeat is intended to be used in conjunction with a
/// commit-reveal mechanism to provide an onchain source of non-revertible randomness.
// It is also recommended to use the source values with a pseudo-random number
// generator (PRNG) to generate an arbitrary-long sequence of random values.
//
// For usage of randomness where result abortion is not an issue, it is recommended
// to use the Cadence built-in function `revertibleRandom`, which is also based on
// the safe Random Beacon.
///
/// Read the full FLIP here: https://github.com/onflow/flips/pull/123
///
access(all) contract RandomBeaconHistory {

    /// The height at which the first source of randomness was recorded
    access(contract) var lowestHeight: UInt64?
    /// Sequence of random sources recorded by the Heartbeat, stored as an array over a mapping to reduce storage
    access(contract) let randomSourceHistory: [[UInt8]]

    /// The path of the Heartbeat resource in the deployment account
    access(all) let HeartbeatStoragePath: StoragePath

    /* --- Hearbeat --- */
    //
    /// The Heartbeat resource containing each block's source of randomness in sequence
    ///
    access(all) resource Heartbeat {

        /// Callable by owner of the Heartbeat resource, Flow Service Account, records the provided random source
        ///
        /// @param randomSourceHistory The random source to record
        ///
        access(all) fun heartbeat(randomSourceHistory: [UInt8]) {

            let currentBlockHeight = getCurrentBlock().height
            if RandomBeaconHistory.lowestHeight == nil {
                RandomBeaconHistory.lowestHeight = currentBlockHeight
            }

            RandomBeaconHistory.randomSourceHistory.append(randomSourceHistory)
        }
    }

    /* --- RandomSourceHistory --- */
    //
    /// Represents a random source value for a given block height
    ///
    access(all) struct RandomSource {
        access(all) let blockHeight: UInt64
        access(all) let value: [UInt8]

        init(blockHeight: UInt64, value: [UInt8]) {
            self.blockHeight = blockHeight
            self.value = value
        }
    }

    /* --- RandomSourceHistoryPage --- */
    //
    /// Contains RandomSource values ordered chronologically according to associated block height
    ///
    access(all) struct RandomSourceHistoryPage {
        access(all) let page: UInt64
        access(all) let perPage: UInt64
        access(all) let totalLength: UInt64
        access(all) let values: [RandomSource]

        init(page: UInt64, perPage: UInt64, totalLength: UInt64, values: [RandomSource]) {
            self.page = page
            self.perPage = perPage
            self.totalLength = totalLength
            self.values = values
        }
    }

    /* --- Contract Methods --- */
    //
    /// Getter for the source of randomness at a given block height. Panics if the requested block height either
    /// precedes or exceeds the recorded history. Note that a source of randomness for block n will not be accessible
    /// until block n+1.
    ///
    /// @param atBlockHeight The block height at which to retrieve the source of randomness
    ///
    /// @return The source of randomness at the given block height as RandomSource struct
    ///
    access(all) fun sourceOfRandomness(atBlockHeight blockHeight: UInt64): RandomSource {
        pre {
            self.lowestHeight != nil: "History has not yet been initialized"
            blockHeight >= self.lowestHeight!: "Requested block height precedes recorded history"
            blockHeight < getCurrentBlock().height: "Source of randomness not yet recorded"
        }
        let index = blockHeight - self.lowestHeight!
        assert(
            index >= 0 && index < UInt64(self.randomSourceHistory.length),
            message: "Problem finding random source history index"
        )
        return RandomSource(blockHeight: blockHeight, value: self.randomSourceHistory[index])
    }

    /// Retrieves a page from the history of random sources, ordered chronologically
    ///
    /// @param page: The page number to retrieve, 0-indexed
    /// @param perPage: The number of random sources to include per page
    ///
    /// @return A RandomSourceHistoryPage containing RandomSource values in choronological order according to
    /// associated block height
    ///
    access(all) view fun getRandomSourceHistoryPage(_ page: UInt64, perPage: UInt64): RandomSourceHistoryPage {
        pre {
            self.lowestHeight != nil: "History has not yet been initialized"
        }
        let values: [RandomSource] = []
        let totalLength = UInt64(self.randomSourceHistory.length)

        var startIndex = page * perPage
        if startIndex > totalLength {
            startIndex = totalLength
        }
        var endIndex = startIndex + perPage
        if endIndex > totalLength {
            endIndex = totalLength
        }
        // Return empty page if request exceeds last page
        if startIndex == endIndex {
            return RandomSourceHistoryPage(page: page, perPage: perPage, totalLength: totalLength, values: values)
        }

        // Iterate over history and construct page RandomSource values
        let lowestHeight = self.lowestHeight!
        for i, block in self.randomSourceHistory.slice(from: Int(startIndex), upTo: Int(endIndex)) {
            values.append(
                RandomSource(
                    blockHeight: lowestHeight + startIndex + UInt64(i),
                    value: self.randomSourceHistory[startIndex + UInt64(i)]
                )
            )
        }

        return RandomSourceHistoryPage(
            page: page,
            perPage: perPage,
            totalLength: totalLength,
            values: values
        )
    }

    /// Getter for the block height at which the first source of randomness was recorded
    ///
    /// @return The block height at which the first source of randomness was recorded
    ///
    access(all) view fun getLowestHeight(): UInt64 {
        return self.lowestHeight ?? panic("History has not yet been initialized")
    }

    init() {
        self.lowestHeight = nil
        self.randomSourceHistory = []
        self.HeartbeatStoragePath = /storage/FlowRandomBeaconHistoryHeartbeat

        self.account.save(<-create Heartbeat(), to: self.HeartbeatStoragePath)
    }
}
"
-------
"pub contract TokenTransferEventContract {
    // Define an event that takes the amount of tokens transferred as an argument
    pub event TokensTransferred(amount: UFix64)

    // Define a public function to emit the event, which can be called by a transaction
    pub fun emitTokensTransferred(amount: UFix64) {
        emit TokensTransferred(amount: amount)
    }
}
"
-------
"
  import FungibleToken from 0xf233dcee88fe0abe

   access(all) contract TestToken: FungibleToken {
      pub var totalSupply: UFix64

      /// TokensInitialized
      ///
      /// The event that is emitted when the contract is created
      pub event TokensInitialized(initialSupply: UFix64)

      /// TokensWithdrawn
      ///
      /// The event that is emitted when tokens are withdrawn from a Vault
      pub event TokensWithdrawn(amount: UFix64, from: Address?)

      /// TokensDeposited
      ///
      /// The event that is emitted when tokens are deposited to a Vault
      pub event TokensDeposited(amount: UFix64, to: Address?)

      /// TokensMinted
      ///
      /// The event that is emitted when new tokens are minted
      pub event TokensMinted(amount: UFix64)

      pub let TokenVaultStoragePath: StoragePath
      pub let TokenVaultPublicPath: PublicPath
      pub let TokenMinterStoragePath: StoragePath

      pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {
          pub var balance: UFix64

          init(balance: UFix64) {
              self.balance = balance
          }

          pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
              self.balance = self.balance - amount
              emit TokensWithdrawn(amount: amount, from: self.owner?.address)
              return <- create Vault(balance: amount)
          }

          pub fun deposit(from: @FungibleToken.Vault) {
              let vault <- from as! @TestToken.Vault
              self.balance = self.balance + vault.balance
              emit TokensDeposited(amount: vault.balance, to: self.owner?.address)
              vault.balance = 0.0
              destroy vault // Make sure we get rid of the vault
          }

          destroy() {
              TestToken.totalSupply = TestToken.totalSupply - self.balance
          }
      }

      pub fun createEmptyVault(): @FungibleToken.Vault {
          return <- create Vault(balance: 0.0)
      }

      access(contract) fun initialMint(initialMintValue: UFix64): @FungibleToken.Vault {
          return <- create Vault(balance: initialMintValue)
      }

      pub resource Minter {
          pub fun mintTokens(amount: UFix64): @FungibleToken.Vault {
          pre {
                  amount > 0.0: "Amount minted must be greater than zero"
              }
              TestToken.totalSupply = TestToken.totalSupply + amount
              return <- create Vault(balance:amount)
          }

      }

      init() {
          self.totalSupply = 99.00
          self.TokenVaultStoragePath = /storage/TestTokenVault
          self.TokenVaultPublicPath = /public/TestTokenVault
          self.TokenMinterStoragePath = /storage/TestTokenMinter

          self.account.save(<- create Minter(), to: TestToken.TokenMinterStoragePath)

         //
         // Create an Empty Vault for the Minter
         //
          self.account.save(<- TestToken.initialMint(initialMintValue: self.totalSupply), to: TestToken.TokenVaultStoragePath)
          self.account.link<&TestToken.Vault{FungibleToken.Balance, FungibleToken.Receiver}>(TestToken.TokenVaultPublicPath, target: TestToken.TokenVaultStoragePath)
      }
   }

      "
-------
"/**

# Swap related interface definitions all-in-one

# Author: Increment Labs

*/
import FungibleToken from 0xf233dcee88fe0abe

pub contract interface SwapInterfaces {
    pub resource interface PairPublic {
        pub fun addLiquidity(tokenAVault: @FungibleToken.Vault, tokenBVault: @FungibleToken.Vault): @FungibleToken.Vault
        pub fun removeLiquidity(lpTokenVault: @FungibleToken.Vault) : @[FungibleToken.Vault]
        pub fun swap(vaultIn: @FungibleToken.Vault, exactAmountOut: UFix64?): @FungibleToken.Vault
        pub fun flashloan(executorCap: Capability<&{SwapInterfaces.FlashLoanExecutor}>, requestedTokenVaultType: Type, requestedAmount: UFix64, params: {String: AnyStruct}) { return }
        pub fun getAmountIn(amountOut: UFix64, tokenOutKey: String): UFix64
        pub fun getAmountOut(amountIn: UFix64, tokenInKey: String): UFix64
        pub fun getPrice0CumulativeLastScaled(): UInt256
        pub fun getPrice1CumulativeLastScaled(): UInt256
        pub fun getBlockTimestampLast(): UFix64
        pub fun getPairInfo(): [AnyStruct]
        pub fun getLpTokenVaultType(): Type
        pub fun isStableSwap(): Bool { return false }
        pub fun getStableCurveP(): UFix64 { return 1.0 }
    }

    pub resource interface LpTokenCollectionPublic {
        pub fun deposit(pairAddr: Address, lpTokenVault: @FungibleToken.Vault)
        pub fun getCollectionLength(): Int
        pub fun getLpTokenBalance(pairAddr: Address): UFix64
        pub fun getAllLPTokens(): [Address]
        pub fun getSlicedLPTokens(from: UInt64, to: UInt64): [Address]
    }

    pub resource interface FlashLoanExecutor {
        pub fun executeAndRepay(loanedToken: @FungibleToken.Vault, params: {String: AnyStruct}): @FungibleToken.Vault
    }
}
"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import MoxyToken from 0x123cb47fe122f6e3


pub contract PlayAndEarn {
    pub event PlayAndEarnEventCreated(eventCode: String, feeCost: UFix64)
    pub event PlayAndEarnEventParticipantAdded(eventCode: String, addressAdded: Address, feePaid: UFix64)
    pub event PlayAndEarnEventPaymentToAddress(eventCode: String, receiver: Address, amount: UFix64)
    pub event PlayAndEarnEventTokensDeposited(eventCode: String, amount: UFix64)

    pub resource PlayAndEarnEcosystem: PlayAndEarnEcosystemInfoInterface {
        access(contract) var events: @{String:PlayAndEarnEvent}

        pub fun getMOXYBalanceFor(eventCode: String): UFix64 {
            return self.events[eventCode]?.getMOXYBalance()!
        }

        pub fun getFeeAmountFor(eventCode: String): UFix64 {
            return self.events[eventCode]?.getFeeAmount()!
        }

        pub fun getParticipantsFor(eventCode: String): [Address] {
            return self.events[eventCode]?.getParticipants()!
        }

        pub fun getPaymentsFor(eventCode: String): {Address: UFix64} {
            return self.events[eventCode]?.getPayments()!
        }

        pub fun getCreatedAt(eventCode: String): UFix64 {
            return self.events[eventCode]?.getCreatedAt()!
        }

        pub fun getAllEvents(): [String] {
            return self.events.keys
        }

        pub fun addParticipantTo(eventCode: String, address: Address, feeVault: @FungibleToken.Vault ) {
            self.events[eventCode]?.addParticipant(address: address, feeVault: <-feeVault.withdraw(amount: feeVault.balance))
            destroy feeVault
        }

        pub fun depositTo(eventCode: String, vault: @FungibleToken.Vault ) {
            self.events[eventCode]?.deposit(vault: <- vault.withdraw(amount: vault.balance))
            destroy vault
        }

        pub fun payToAddressFor(eventCode: String, address: Address, amount: UFix64) {
            self.events[eventCode]?.payToAddress(address: address, amount: amount)
        }

        pub fun addEvent(code: String, feeAmount: UFix64) {
            if (self.events[code] != nil) {
                panic("Event already exists")
            }

            self.events[code] <-! create PlayAndEarnEvent(code: code, fee: feeAmount)
            emit PlayAndEarnEventCreated(eventCode: code, feeCost: feeAmount)
        }

        init() {
            self.events <- {}
        }

        destroy() {
            destroy self.events
        }
    }

    pub resource PlayAndEarnEvent {
        pub var code: String
        pub var fee: UFix64
        pub var vault: @FungibleToken.Vault
        access(contract) var participants: {Address:UFix64}
        access(contract) var payments: {Address:UFix64}
        pub var createdAt: UFix64

        pub fun getFeeAmount(): UFix64 {
            return self.fee
        }

        pub fun getMOXYBalance(): UFix64 {
            return self.vault.balance
        }

        pub fun getParticipants(): [Address] {
            return self.participants.keys
        }

        pub fun getPayments(): {Address: UFix64} {
            return self.payments
        }

        pub fun getCreatedAt(): UFix64 {
            return self.createdAt
        }

        pub fun hasParticipant(address: Address): Bool {
            return self.participants[address] != nil
        }

        pub fun addParticipant(address: Address, feeVault: @FungibleToken.Vault ) {
            let feePaid = feeVault.balance
            self.participants[address] = feePaid
            self.vault.deposit(from: <-feeVault)
            emit PlayAndEarnEventParticipantAdded(eventCode: self.code, addressAdded: address, feePaid: feePaid)
        }

        pub fun deposit(vault: @FungibleToken.Vault) {
            let amount = vault.balance
            self.vault.deposit(from: <-vault)
            emit PlayAndEarnEventTokensDeposited(eventCode: self.code, amount: amount)
        }

        pub fun payToAddress(address: Address, amount: UFix64) {
            // Get the amount from the event vault
            let vault <- self.vault.withdraw(amount: amount)

            // Get the recipient's public account object
            let recipient = getAccount(address)

            // Get a reference to the recipient's Receiver
            let receiverRef = recipient.getCapability(MoxyToken.moxyTokenReceiverPath)
                .borrow<&{FungibleToken.Receiver}>()
                ?? panic("Could not borrow receiver reference to the recipient's Vault")

            // Deposit the withdrawn tokens in the recipient's receiver
            receiverRef.deposit(from: <- vault)

            // Register address as payment recipient
            if (self.payments[address] == nil) {
                self.payments[address] = amount
            } else {
                self.payments[address] = self.payments[address]! + amount
            }
            emit PlayAndEarnEventPaymentToAddress(eventCode: self.code, receiver: address, amount: amount)
        }


        init(code:String, fee: UFix64){
            self.code = code
            self.fee = fee
            self.vault <- MoxyToken.createEmptyVault()
            self.participants = {}
            self.payments = {}
            self.createdAt = getCurrentBlock().timestamp
        }

        destroy() {
            destroy self.vault
        }
    }

    pub fun getPlayAndEarnEcosystemPublicCapability(): &PlayAndEarnEcosystem{PlayAndEarnEcosystemInfoInterface} {
        return self.account
                .getCapability(PlayAndEarn.playAndEarnEcosystemPublic)
                .borrow<&PlayAndEarn.PlayAndEarnEcosystem{PlayAndEarnEcosystemInfoInterface}>()!
    }

    pub resource interface PlayAndEarnEcosystemInfoInterface {
        pub fun getMOXYBalanceFor(eventCode: String): UFix64
        pub fun getFeeAmountFor(eventCode: String): UFix64
        pub fun getParticipantsFor(eventCode: String): [Address]
        pub fun getPaymentsFor(eventCode: String): {Address: UFix64}
        pub fun getCreatedAt(eventCode: String): UFix64
        pub fun getAllEvents(): [String]
        pub fun depositTo(eventCode: String, vault: @FungibleToken.Vault )
    }


    pub let playAndEarnEcosystemStorage: StoragePath
    pub let playAndEarnEcosystemPrivate: PrivatePath
    pub let playAndEarnEcosystemPublic: PublicPath

    init(){
        self.playAndEarnEcosystemStorage = /storage/playAndEarnEcosystem
        self.playAndEarnEcosystemPrivate = /private/playAndEarnEcosystem
        self.playAndEarnEcosystemPublic = /public/playAndEarnEcosystem

        let playAndEarnEcosystem <- create PlayAndEarnEcosystem()
        self.account.save(<-playAndEarnEcosystem, to: self.playAndEarnEcosystemStorage)
        self.account.link<&PlayAndEarnEcosystem>(self.playAndEarnEcosystemPrivate, target: self.playAndEarnEcosystemStorage)
        self.account.link<&PlayAndEarnEcosystem{PlayAndEarnEcosystemInfoInterface}>(
            self.playAndEarnEcosystemPublic,
            target: self.playAndEarnEcosystemStorage
        )
    }
}

"
-------
"pub contract MikoseaUserInformation {
    pub let storagePath: StoragePath
    pub let publicPath: PublicPath
    pub let adminPath: StoragePath

    access(contract) let userData: {Address:UserInfo}
    pub struct UserInfo {
        pub var metadata: {String:String}

        init(metadata:  {String:String}) {
            self.metadata = metadata
        }

        pub fun byKey(key: String): String? {
            return self.metadata[key]
        }

        pub fun setKeyValue(key: String, value: String) {
            self.metadata[key] = value
        }

        pub fun update(metadata: {String:String}) {
            self.metadata = metadata
        }
    }

    pub resource Admin {
        init() {
        }

        pub fun upsert(address: Address, metadata: {String:String}) {
            MikoseaUserInformation.userData[address] = UserInfo(metadata: metadata)
        }

        pub fun upsertKeyValue(address: Address, key: String, value: String) {
            if let user = MikoseaUserInformation.userData[address] {
                user.setKeyValue(key: key, value: value)
                self.upsert(address: address, metadata: user.metadata)
            } else {
                self.upsert(address: address, metadata: {key: value})
            }
        }
    }

    pub fun findByAddress(address: Address): UserInfo? {
        return MikoseaUserInformation.userData[address]
    }

    init() {
        // Initialize contract paths
        self.storagePath = /storage/MikoseaUserInformation
        self.publicPath = /public/MikoseaUserInformation
        self.adminPath = /storage/MikoseaUserInformationAdmin

        self.userData={}
        let admin <- create Admin()
        self.account.save(<- admin, to: self.adminPath)
    }
}"
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import Utils from 0x15f55a75d7843780

access(all) contract SwapArchive {

	access(self) let swaps: { String: [SwapData] }
	access(self) let swapLookup: { String: { String: Int } }

	access(all) struct SwapNft {

		pub let id: UInt64
		pub let type: Type
		pub let imageUri: String
		pub let name: String
		pub let collectionName: String
		pub let metadata: { String: AnyStruct }?

		init(
			nft: &{NonFungibleToken.INFT},
			metadata: { String: AnyStruct }?
		) {
			let collectionDisplay = (nft.resolveView(Type<MetadataViews.NFTCollectionDisplay>()) as! MetadataViews.NFTCollectionDisplay?) ?? panic("collection display lookup failed")
			let display = (nft.resolveView(Type<MetadataViews.Display>()) as! MetadataViews.Display?) ?? panic("dislay lookup failed")

			self.id = nft.id
			self.type = nft.getType()
			self.imageUri = display.thumbnail.uri()
			self.name = display.name
			self.collectionName = collectionDisplay.name
			self.metadata = metadata
		}
	}

	access(all) struct SwapNftData {

		pub let id: UInt64
		pub let type: Type

		init(
			id: UInt64,
			type: Type
		) {
			self.id = id
			self.type = type
		}
	}

	access(all) struct SwapData {

		pub let id: String
		pub let leftAddress: Address
		pub let rightAddress: Address
		pub let leftNfts: [SwapNft]
		pub let rightNfts: [SwapNft]
		pub let timestamp: UFix64
		pub let metadata: { String: AnyStruct }?

		init(
			id: String,
			leftAddress: Address,
			rightAddress: Address,
			leftNfts: [SwapNftData],
			rightNfts: [SwapNftData],
			metadata: { String: AnyStruct }?
		) {
			self.id = id
			self.leftAddress = leftAddress
			self.rightAddress = rightAddress
			self.leftNfts = SwapArchive.resolveNfts(address: leftAddress, leftNfts)
			self.rightNfts = SwapArchive.resolveNfts(address: rightAddress, rightNfts)
			self.timestamp = getCurrentBlock().timestamp
			self.metadata = metadata
		}
	}

	access(contract) fun resolveNfts(address: Address, _ nfts: [SwapNftData]): [SwapNft] {

		let account = getAccount(address)
		let response: [SwapNft] = []

        let nftIdentifiers: [String] = []
        for nft in nfts {
            nftIdentifiers.append(nft.type.identifier)
        }

		let collectionMetadata = Utils.getNFTCollectionData(ownerAddress: address, nftIdentifiers: nftIdentifiers)

		for nft in nfts {

			let collectionData = collectionMetadata[nft.type.identifier] ?? panic("collection data lookup failed")

			let collectionPublic = account.getCapability<&{NonFungibleToken.CollectionPublic}>(collectionData.publicPath).borrow()

			let nftRef = collectionPublic!.borrowNFT(id: nft.id) as &{NonFungibleToken.INFT}

			response.append(SwapNft(nft: nftRef, metadata: nil))
		}

		assert(nfts.length == response.length, message: "nft lookup mismatch")

		return response
	}

	access(all) fun getLatestSwaps(id: String, take: Int?): [SwapData] {

		if (!self.swaps.containsKey(id)) {

			return []
		}

		let response: [SwapData] = []

		let length = self.swaps[id]!.length

		var limit = (take ?? 5)
		limit = limit > length ? length : limit

		var i = 0
		while i < limit {

			response.append(self.swaps[id]![length - 1 - i]!)

			i = i + 1
		}

		return response
	}

	access(contract) fun getSwapIndex(id: String, _ swapId: String): Int? {

		if (!self.swaps.containsKey(id) || !self.swapLookup.containsKey(id)) {

			return nil
		}

		return self.swapLookup[id]![swapId]
	}

	access(all) fun getSwap(id: String, _ swapId: String): SwapData? {

		let index = self.getSwapIndex(id: id, swapId)
		if (index == nil) {

			return nil
		}

		return self.swaps[id]![index!]
	}

	access(account) fun archiveSwap(id: String, _ model: SwapData) {

		if (!self.swaps.containsKey(id)) {

			self.swaps.insert(key: id, [])
		}

		if (!self.swapLookup.containsKey(id)) {

			self.swapLookup.insert(key: id, {})
		}

		if (!self.swapLookup[id]!.containsKey(model.id)) {

			self.swapLookup[id]!.insert(key: model.id, self.swaps[id]!.length)
		}

		self.swaps[id]!.append(model)
	}

	init () {

		self.swaps = {}
		self.swapLookup = {}
	}
}
"
-------
"pub contract Metabolism {

    pub resource Cell {

        pub var is_dead: Bool

        init() {
            self.is_dead = false
        }

        destroy() {
            assert(self.is_dead, message: "Not dead yet.")
        }

        pub fun kill(): @Cell {
            self.is_dead = true
            return <- create Cell()
        }
    }

    init() {
        self.account.save(<- create Cell(), to: /storage/MetabolismCell)
    }
}
"
-------
"// This code poetry is dedicated to Minakata Kumagusu.

pub contract StudyOfThings {
    pub resource Object {}

    pub resource Mind {}

    pub event Thing(object: UInt64, mind: UInt64)


    pub fun get(): @Object {
        return <- create Object()
    }

    pub fun call(): @Mind {
        return <- create Mind()
    }

    pub fun produce(object: &Object, mind: &Mind) {
        emit Thing(object: object.uuid, mind: mind.uuid)
    }
}
"
-------
"/*
UntoldTest

This is the contract for UntoldTest NFTs!

This was implemented using Niftory interfaces. For full details on how this
contract functions, please see the Niftory and NFTRegistry contracts.

*/

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import ViewResolver from 0x1d7e57aa55817448

import MutableMetadata from 0x7ec1f607f0872a9e
import MutableMetadataTemplate from 0x7ec1f607f0872a9e
import MutableMetadataSet from 0x7ec1f607f0872a9e
import MutableMetadataSetManager from 0x7ec1f607f0872a9e
import MetadataViewsManager from 0x7ec1f607f0872a9e

import NiftoryNonFungibleToken from 0x7ec1f607f0872a9e
import NiftoryNFTRegistry from 0x7ec1f607f0872a9e

import NiftoryMetadataViewsResolvers from 0x7ec1f607f0872a9e
import NiftoryNonFungibleTokenProxy from 0x7ec1f607f0872a9e

pub contract UntoldTest: NonFungibleToken, ViewResolver {

  // ========================================================================
  // Constants
  // ========================================================================

  // Suggested paths where collection could be stored
  pub let COLLECTION_PRIVATE_PATH: PrivatePath
  pub let COLLECTION_PUBLIC_PATH: PublicPath
  pub let COLLECTION_STORAGE_PATH: StoragePath

  // Accessor token to be used with NiftoryNFTRegistry to retrieve
  // meta-information about this NFT project
  pub let REGISTRY_ADDRESS: Address
  pub let REGISTRY_BRAND: String

  // ========================================================================
  // Attributes
  // ========================================================================

  // Arbitrary metadata for this NFT contract
  pub var metadata: AnyStruct?

  // Number of NFTs created
  pub var totalSupply: UInt64

  // ========================================================================
  // Contract Events
  // ========================================================================

  // This contract was initialized
  pub event ContractInitialized()

  // A withdrawal of NFT `id` has occurred from the `from` Address
  pub event Withdraw(id: UInt64, from: Address?)

  // A deposit of an NFT `id` has occurred to the `to` Address
  pub event Deposit(id: UInt64, to: Address?)

  ///////////////////////////////////////////////////////////////////////////

  // Contract metadata was modified
  pub event ContractMetadataUpdated()

  // Metadata Views Manager was locked
  pub event MetadataViewsManagerLocked()

  // Metadata Views Resolver was added
  pub event MetadataViewsResolverAdded(type: Type)

  // Metadata Views Resolver was removed
  pub event MetadataViewsResolverRemoved(type: Type)

  // Set Manager Name or Description updated
  pub event SetManagerMetadataUpdated()

  // Set added to Set Manager
  pub event SetAddedToSetManager(setID: Int)

  ///////////////////////////////////////////////////////////////////////////

  // Set `setId` was locked (no new templates can be added)
  pub event SetLocked(setId: Int)

  // The metadata for Set `setId` was locked and cannot be modified
  pub event SetMetadataLocked(setId: Int)

  // Set `setId` was modified
  pub event SetMetadataModified(setId: Int)

  // A new Template `templateId` was added to Set `setId`
  pub event TemplateAddedToSet(setId: Int, templateId: Int)

  ///////////////////////////////////////////////////////////////////////////

  // Template `templateId` was locked in Set `setId`, which disables minting
  pub event TemplateLocked(setId: Int, templateId: Int)

  // Template `templateId` of Set `setId` had it's maxMint set to `maxMint`
  pub event TemplateMaxMintSet(setId: Int, templateId: Int, maxMint: UInt64)

  // Template `templateId` of Set `setId` has minted NFT with serial `serial`
  pub event NFTMinted(id: UInt64, setId: Int, templateId: Int, serial: UInt64)

  ///////////////////////////////////////////////////////////////////////////

  // The metadata for NFT/Template `templateId` of Set `setId` was locked
  pub event NFTMetadataLocked(setId: Int, templateId: Int)

  // The metadata for NFT/Template `templateId` of Set `setId` was modified
  pub event NFTMetadataModified(setId: Int, templateId: Int)

  ///////////////////////////////////////////////////////////////////////////

  // NFT `serial` from Template `templateId` of Set `setId` was burned
  pub event NFTBurned(setId: Int, templateId: Int, serial: UInt64)

  // ========================================================================
  // NFT
  // ========================================================================

  pub resource NFT:
    NonFungibleToken.INFT,
    MetadataViews.Resolver,
    NiftoryNonFungibleToken.NFTPublic
  {
    pub let id: UInt64
    pub let setId: Int
    pub let templateId: Int
    pub let serial: UInt64

    pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
      return UntoldTest.contract()
    }

    pub fun set(): &MutableMetadataSet.Set{MutableMetadataSet.Public} {
      return self
        .contract()
        .getSetManagerPublic()
        .getSet(self.setId)
    }

    pub fun metadata(): &MutableMetadata.Metadata{MutableMetadata.Public} {
      return self
        .set()
        .getTemplate(self.templateId)
        .metadata()
    }

    pub fun getViews(): [Type] {
      return self
        .contract()
        .getMetadataViewsManagerPublic()
        .getViews()
    }

    pub fun resolveView(_ view: Type): AnyStruct? {
      let nftRef = &self as &{NiftoryNonFungibleToken.NFTPublic}
      return self
        .contract()
        .getMetadataViewsManagerPublic()
        .resolveView(view: view, nftRef: nftRef)
    }

    init(setId: Int, templateId: Int, serial: UInt64) {
      self.id = UntoldTest.totalSupply
      UntoldTest.totalSupply =
        UntoldTest.totalSupply + 1
      self.setId = setId
      self.templateId = templateId
      self.serial = serial
    }

    destroy() {
      emit NFTBurned(
        setId: self.setId,
        templateId: self.templateId,
        serial: self.serial
      )
    }
  }

  // ========================================================================
  // Collection
  // ========================================================================

  pub resource Collection:
    NonFungibleToken.Provider,
    NonFungibleToken.Receiver,
    NonFungibleToken.CollectionPublic,
    MetadataViews.ResolverCollection,
    NiftoryNonFungibleToken.CollectionPublic,
    NiftoryNonFungibleToken.CollectionPrivate
  {
    pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

    pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
      return UntoldTest.contract()
    }

    pub fun getIDs(): [UInt64] {
      return self.ownedNFTs.keys
    }

    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
      pre {
        self.ownedNFTs[id] != nil : "NFT "
          .concat(id.toString())
          .concat(" does not exist in collection.")
      }
      return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
    }

    pub fun borrow(id: UInt64): &NFT{NiftoryNonFungibleToken.NFTPublic} {
      pre {
        self.ownedNFTs[id] != nil : "NFT does not exist in collection."
      }
      let nftRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let fullNft = nftRef as! &NFT
      return fullNft
    }

    pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {
      pre {
        self.ownedNFTs[id] != nil : "NFT does not exist in collection."
      }
      let nftRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let fullNft = nftRef as! &NFT
      return fullNft
    }

    pub fun deposit(token: @NonFungibleToken.NFT) {
      let token <- token as! @UntoldTest.NFT
      let id: UInt64 = token.id
      let oldToken <- self.ownedNFTs[id] <- token
      emit Deposit(id: id, to: self.owner?.address)
      destroy oldToken
    }

    pub fun depositBulk(tokens: @[NonFungibleToken.NFT]) {
      while tokens.length > 0 {
        let token <- tokens.removeLast() as! @UntoldTest.NFT
        self.deposit(token: <-token)
      }
      destroy tokens
    }

    pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
      pre {
        self.ownedNFTs[withdrawID] != nil
          : "NFT "
            .concat(withdrawID.toString())
            .concat(" does not exist in collection.")
      }
      let token <-self.ownedNFTs.remove(key: withdrawID)!
      emit Withdraw(id: token.id, from: self.owner?.address)
      return <-token
    }

    pub fun withdrawBulk(withdrawIDs: [UInt64]): @[NonFungibleToken.NFT] {
      let tokens: @[NonFungibleToken.NFT] <- []
      while withdrawIDs.length > 0 {
        tokens.append(<- self.withdraw(withdrawID: withdrawIDs.removeLast()))
      }
      return <-tokens
    }

    init() {
      self.ownedNFTs <- {}
    }

    destroy() {
      destroy self.ownedNFTs
    }
  }

  pub fun createEmptyCollection(): @Collection {
    return <-create Collection()
  }

  // ========================================================================
  // Manager
  // ========================================================================

  pub resource Manager:
    NiftoryNonFungibleToken.ManagerPublic,
    NiftoryNonFungibleToken.ManagerPrivate
  {
    // ========================================================================
    // Public
    // ========================================================================

    pub fun metadata(): AnyStruct? {
      return UntoldTest.metadata
    }

    pub fun getSetManagerPublic():
      &MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public}
    {
      return NiftoryNFTRegistry
        .getSetManagerPublic(
          UntoldTest.REGISTRY_ADDRESS,
          UntoldTest.REGISTRY_BRAND
        )
    }

    pub fun getMetadataViewsManagerPublic():
      &MetadataViewsManager.Manager{MetadataViewsManager.Public}
    {
      return NiftoryNFTRegistry
        .getMetadataViewsManagerPublic(
          UntoldTest.REGISTRY_ADDRESS,
          UntoldTest.REGISTRY_BRAND
        )
    }

    pub fun getNFTCollectionData(): MetadataViews.NFTCollectionData {
      return NiftoryNFTRegistry
        .buildNFTCollectionData(
          UntoldTest.REGISTRY_ADDRESS,
          UntoldTest.REGISTRY_BRAND,
          (fun (): @NonFungibleToken.Collection {
            return <-UntoldTest.createEmptyCollection()
          })
        )
    }

    // ========================================================================
    // Contract metadata
    // ========================================================================

    pub fun modifyContractMetadata(): auth &AnyStruct {
      emit ContractMetadataUpdated()
      let maybeMetadata = UntoldTest.metadata
      if maybeMetadata == nil {
        let blankMetadata: {String: String} = {}
        UntoldTest.metadata = blankMetadata
      }
      return (&UntoldTest.metadata as auth &AnyStruct?)!
    }

    pub fun replaceContractMetadata(_ metadata: AnyStruct?) {
      emit ContractMetadataUpdated()
      UntoldTest.metadata = metadata
    }

    // ========================================================================
    // Metadata Views Manager
    // ========================================================================

    access(self) fun _getMetadataViewsManagerPrivate():
      &MetadataViewsManager.Manager{MetadataViewsManager.Private}
    {
      let record =
        NiftoryNFTRegistry.getRegistryRecord(
          UntoldTest.REGISTRY_ADDRESS,
          UntoldTest.REGISTRY_BRAND
        )
      let manager =
        UntoldTest.account
          .getCapability<&MetadataViewsManager.Manager{MetadataViewsManager.Private}>(
            record.metadataViewsManager.paths.private
          ).borrow()!
      return manager
    }

    pub fun lockMetadataViewsManager() {
      self._getMetadataViewsManagerPrivate().lock()
      emit MetadataViewsManagerLocked()
    }

    pub fun setMetadataViewsResolver(
      _ resolver: AnyStruct{MetadataViewsManager.Resolver}
    ) {
      self._getMetadataViewsManagerPrivate().addResolver(resolver)
      emit MetadataViewsResolverAdded(type: resolver.type)
    }

    pub fun removeMetadataViewsResolver(_ type: Type) {
      self._getMetadataViewsManagerPrivate().removeResolver(type)
      emit MetadataViewsResolverRemoved(type: type)
    }

    // ========================================================================
    // Set Manager
    // ========================================================================

    access(self) fun _getSetManagerPrivate():
      &MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public, MutableMetadataSetManager.Private}
    {
      let record =
        NiftoryNFTRegistry.getRegistryRecord(
          UntoldTest.REGISTRY_ADDRESS,
          UntoldTest.REGISTRY_BRAND
        )
      let setManager =
        UntoldTest.account
          .getCapability<&MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public, MutableMetadataSetManager.Private}>(
            record.setManager.paths.private
          ).borrow()!
      return setManager
    }

    pub fun setMetadataManagerName(_ name: String) {
      self._getSetManagerPrivate().setName(name)
      emit SetManagerMetadataUpdated()
    }

    pub fun setMetadataManagerDescription(_ description: String) {
      self._getSetManagerPrivate().setDescription(description)
      emit SetManagerMetadataUpdated()
    }

    pub fun addSet(_ set: @MutableMetadataSet.Set) {
      let setManager = self._getSetManagerPrivate()
      let setId = setManager.numSets()
      setManager.addSet(<-set)
      emit SetAddedToSetManager(setID: setId)
    }

    // ========================================================================
    // Set
    // ========================================================================

    access(self) fun _getSetMutable(_ setId: Int):
      &MutableMetadataSet.Set{MutableMetadataSet.Private,
        MutableMetadataSet.Public} {
      return self._getSetManagerPrivate().getSetMutable(setId)
    }

    pub fun lockSet(setId: Int) {
      self._getSetMutable(setId).lock()
      emit SetLocked(setId: setId)
    }

    pub fun lockSetMetadata(setId: Int) {
      self._getSetMutable(setId).metadataMutable().lock()
      emit SetMetadataLocked(setId: setId)
    }

    pub fun modifySetMetadata(setId: Int): auth &AnyStruct {
      emit SetMetadataModified(setId: setId)
      return self._getSetMutable(setId).metadataMutable().getMutable()
    }

    pub fun replaceSetMetadata(setId: Int, new: AnyStruct) {
      self._getSetMutable(setId).metadataMutable().replace(new)
      emit SetMetadataModified(setId: setId)
    }

    pub fun addTemplate(
      setId: Int,
      template: @MutableMetadataTemplate.Template
    ) {
      let set = self._getSetMutable(setId)
      let templateId = set.numTemplates()
      set.addTemplate(<-template)
      emit TemplateAddedToSet(setId: setId, templateId: templateId)
    }

    // ========================================================================
    // Minting
    // ========================================================================

    access(self) fun _getTemplateMutable(_ setId: Int, _ templateId: Int):
      &MutableMetadataTemplate.Template{MutableMetadataTemplate.Public,
        MutableMetadataTemplate.Private} {
      return self._getSetMutable(setId).getTemplateMutable(templateId)
    }

    pub fun lockTemplate(setId: Int, templateId: Int) {
      self._getTemplateMutable(setId, templateId).lock()
      emit TemplateLocked(setId: setId, templateId: templateId)
    }

    pub fun setTemplateMaxMint(setId: Int, templateId: Int, max: UInt64) {
      self._getTemplateMutable(setId, templateId).setMaxMint(max)
      emit TemplateMaxMintSet(
        setId: setId,
        templateId: templateId,
        maxMint: max
      )
    }

    pub fun mint(setId: Int, templateId: Int): @NonFungibleToken.NFT {
      let template = self._getTemplateMutable(setId, templateId)
      template.registerMint()
      let serial = template.minted()
      let nft <-create NFT(
        setId: setId,
        templateId: templateId,
        serial: serial
      )
      emit NFTMinted(
        id: nft.id,
        setId: setId,
        templateId: templateId,
        serial: serial
      )
      return <-nft
    }

    pub fun mintBulk(
      setId: Int,
      templateId: Int,
      numToMint: UInt64,
    ): @[NonFungibleToken.NFT] {
      pre {
        numToMint > 0: "Must mint at least one NFT"
      }
      let template = self._getTemplateMutable(setId, templateId)
      let nfts: @[NonFungibleToken.NFT] <- []
      var leftToMint = numToMint
      while leftToMint > 0 {
        template.registerMint()
        let serial = template.minted()
        let nft <-create NFT(
          setId: setId,
          templateId: templateId,
          serial: serial
        )
        emit NFTMinted(
          id: nft.id,
          setId: setId,
          templateId: templateId,
          serial: serial
        )
        nfts.append(<-nft)
        leftToMint = leftToMint - 1
      }
      return <-nfts
    }

    // ========================================================================
    // NFT metadata
    // ========================================================================

    access(self) fun _getNFTMetadata(_ setId: Int, _ templateId: Int):
      &MutableMetadata.Metadata{MutableMetadata.Public,
        MutableMetadata.Private
      } {
        return self._getTemplateMutable(setId, templateId).metadataMutable()
    }

    pub fun lockNFTMetadata(setId: Int, templateId: Int) {
      self._getNFTMetadata(setId, templateId).lock()
      emit NFTMetadataLocked(setId: setId, templateId: templateId)
    }

    pub fun modifyNFTMetadata(setId: Int, templateId: Int): auth &AnyStruct {
      emit NFTMetadataModified(setId: setId, templateId: templateId)
      return self._getNFTMetadata(setId, templateId).getMutable()
    }

    pub fun replaceNFTMetadata(setId: Int, templateId: Int, new: AnyStruct) {
      self._getNFTMetadata(setId, templateId).replace(new)
      emit NFTMetadataModified(setId: setId, templateId: templateId)
    }
  }

  // ========================================================================
  // Contract functions
  // ========================================================================

  pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
    return NiftoryNFTRegistry
      .getNFTManagerPublic(
        UntoldTest.REGISTRY_ADDRESS,
        UntoldTest.REGISTRY_BRAND
      )
  }

  pub fun getViews(): [Type] {
    let possibleViews = [
      Type<MetadataViews.NFTCollectionDisplay>(),
      Type<MetadataViews.ExternalURL>()
    ]
    let views: [Type] = [Type<MetadataViews.NFTCollectionData>()]

    let viewManager = self.contract().getMetadataViewsManagerPublic()
    for view in possibleViews {
      if viewManager.inspectView(view: view) != nil {
        views.append(view)
      }
    }
    return views
  }

  pub fun resolveView(_ view: Type): AnyStruct? {
    let viewManager = self.contract().getMetadataViewsManagerPublic()
    switch view {

      case Type<MetadataViews.NFTCollectionData>():
        return self.contract().getNFTCollectionData()

      case Type<MetadataViews.NFTCollectionDisplay>():
        let maybeView = viewManager.inspectView(
          view: Type<MetadataViews.NFTCollectionDisplay>()
        )
        if maybeView == nil {
          return nil
        }
        let view = maybeView!

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver

          // External URL
          let externalURL = MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultExternalURLPrefix,
              uri: resolver.defaultExternalURL
            )
          )

          // Square image
          let squareImageURL = NiftoryMetadataViewsResolvers._prefixUri(
            allowedPrefixes:
              NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
            default: resolver.defaultSquareImagePrefix,
            uri: resolver.defaultSquareImage
          )
          let squareImageMediaType = resolver.defaultSquareImageMediaType
          let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: squareImageURL),
            mediaType: squareImageMediaType
          )

          // Banner image
          let bannerImageURL = NiftoryMetadataViewsResolvers._prefixUri(
            allowedPrefixes:
              NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
            default: resolver.defaultBannerImagePrefix,
            uri: resolver.defaultBannerImage
          )
          let bannerImageMediaType = resolver.defaultBannerImageMediaType
          let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
              url: bannerImageURL
            ),
            mediaType: bannerImageMediaType
          )

          return MetadataViews.NFTCollectionDisplay(
            name: resolver.defaultName,
            description: resolver.defaultDescription,
            externalURL: externalURL,
            squareImage: squareImage,
            bannerImage: bannerImage,
            socials: {}

          )
        }

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolverWithIpfsGateway>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolverWithIpfsGateway

          // External URL
          let externalURL = MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultExternalURLPrefix,
              uri: resolver.defaultExternalURL
            )
          )

          // Square image
          let squareImageURL = NiftoryMetadataViewsResolvers._useIpfsGateway(
            ipfsGateway: resolver.ipfsGateway,
            uri: NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultSquareImagePrefix,
              uri: resolver.defaultSquareImage
            )
        )
          let squareImageMediaType = resolver.defaultSquareImageMediaType
          let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: squareImageURL),
            mediaType: squareImageMediaType
          )

          // Banner image
          let bannerImageURL = NiftoryMetadataViewsResolvers._useIpfsGateway(
            ipfsGateway: resolver.ipfsGateway,
            uri: NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultBannerImagePrefix,
              uri: resolver.defaultBannerImage
            )
          )
          let bannerImageMediaType = resolver.defaultBannerImageMediaType
          let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
              url: bannerImageURL
            ),
            mediaType: bannerImageMediaType
          )

          return MetadataViews.NFTCollectionDisplay(
            name: resolver.defaultName,
            description: resolver.defaultDescription,
            externalURL: externalURL,
            squareImage: squareImage,
            bannerImage: bannerImage,
            socials: {}
          )
        }

        return nil

      case Type<MetadataViews.ExternalURL>():
        let maybeView = viewManager.inspectView(
          view: Type<MetadataViews.ExternalURL>()
        )
        if maybeView == nil {
          return nil
        }
        let view = maybeView!

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.ExternalURLResolver>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.ExternalURLResolver
          return MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultPrefix,
              uri: resolver.defaultURL
            )
          )
        }

        return nil
      }
      return nil

  }

  // ========================================================================
  // Init
  // ========================================================================

  init(
    nftManagerProxy: &{
      NiftoryNonFungibleTokenProxy.Public,
      NiftoryNonFungibleTokenProxy.Private
    }
  ) {

    let record = NiftoryNFTRegistry.generateRecord(
      account: self.account.address,
      project: "cljmwry2q0001jx0vfq9e7fni_UntoldTest"
    )

    self.REGISTRY_ADDRESS = 0x32d62d5c43ad1038
    self.REGISTRY_BRAND = "cljmwry2q0001jx0vfq9e7fni_UntoldTest"

    self.COLLECTION_PUBLIC_PATH = record.collectionPaths.public
    self.COLLECTION_PRIVATE_PATH = record.collectionPaths.private
    self.COLLECTION_STORAGE_PATH = record.collectionPaths.storage

    // No metadata to start with
    self.metadata = nil

    // Initialize the total supply to 0.
    self.totalSupply = 0

    // The Manager for this NFT
    //
    // NFT Manager storage
    let nftManager <- create Manager()

    // Save a MutableSetManager to this contract's storage, as the source of
    // this NFT contract's metadata.
    //
    // MutableMetadataSetManager storage
    self
      .account
      .save<@MutableMetadataSetManager.Manager>(
        <-MutableMetadataSetManager.create(
          name: "UntoldTest",
          description: "The set manager for UntoldTest."
        ),
        to: record.setManager.paths.storage
      )

    // MutableMetadataSetManager public
    self
      .account
      .link<&MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public}>(
        record.setManager.paths.public,
        target: record.setManager.paths.storage
      )

    // MutableMetadataSetManager private
    self
      .account
      .link<&
        MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public,
        MutableMetadataSetManager.Private
      }>(
        record.setManager.paths.private,
        target: record.setManager.paths.storage
      )

    // Save a MetadataViewsManager to this contract's storage, which will
    // allow observers to inspect standardized metadata through any of its
    // configured MetadataViews resolvers.
    //
    // MetadataViewsManager storage
    self
      .account
      .save<@MetadataViewsManager.Manager>(
        <-MetadataViewsManager.create(),
        to: record.metadataViewsManager.paths.storage
      )

    // MetadataViewsManager public
    self
      .account
      .link<&MetadataViewsManager.Manager{MetadataViewsManager.Public}>(
        record.metadataViewsManager.paths.public,
        target: record.metadataViewsManager.paths.storage
      )

    // MetadataViewsManager private
    self
      .account
      .link<&
        MetadataViewsManager.Manager{MetadataViewsManager.Private,
        MetadataViewsManager.Public
      }>(
        record.metadataViewsManager.paths.private,
        target: record.metadataViewsManager.paths.storage
      )

    let contractName = "UntoldTest"

    // Royalties
    let royaltiesResolver = NiftoryMetadataViewsResolvers.RoyaltiesResolver(
        royalties: MetadataViews.Royalties([])
    )
    nftManager.setMetadataViewsResolver(royaltiesResolver)

    // Collection Data
    let collectionDataResolver
        = NiftoryMetadataViewsResolvers.NFTCollectionDataResolver()
    nftManager.setMetadataViewsResolver(collectionDataResolver)

    // Display
    let displayResolver = NiftoryMetadataViewsResolvers.DisplayResolver(
        "title",
        contractName.concat("NFT"),
        "description",
        contractName.concat(" NFT"),
        "mediaUrl",
        "ipfs://",
        "ipfs://bafybeig6la3me5x3veull7jzxmwle4sfuaguou2is3o3z44ayhe7ihlqpa/NiftoryBanner.png"
    )
    nftManager.setMetadataViewsResolver(displayResolver)

    // Collection Display
    let collectionResolver = NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver(
        "title",
        contractName,
        "description",
        contractName.concat(" Collection"),
        "domainUrl",
        "https://",
        "https://niftory.com",
        "squareImage",
        "ipfs://",
        "ipfs://bafybeihc76uodw2at2xi2l5jydpvscj5ophfpqgblbrmsfpeffhcmgdtl4/squareImage.png",
        "squareImageMediaType",
        "image/png",
        "bannerImage",
        "ipfs://",
        "ipfs://bafybeig6la3me5x3veull7jzxmwle4sfuaguou2is3o3z44ayhe7ihlqpa/NiftoryBanner.png",
        "bannerImageMediaType",
        "image/png",
        []
    )
    nftManager.setMetadataViewsResolver(collectionResolver)

    // ExternalURL
    let externalURLResolver = NiftoryMetadataViewsResolvers.ExternalURLResolver(
        "domainUrl",
        "https://",
        "https://niftory.com"
    )
    nftManager.setMetadataViewsResolver(externalURLResolver)

    // Save NFT Manager
    self
      .account
      .save<@Manager>(
        <-nftManager,
        to: record.nftManager.paths.storage
      )

    // NFT Manager public
    self
      .account
      .link<&{NiftoryNonFungibleToken.ManagerPublic}>(
        record.nftManager.paths.public,
        target: record.nftManager.paths.storage
      )

    // NFT Manager private
    self
      .account
      .link<&
        Manager{NiftoryNonFungibleToken.ManagerPublic,
        NiftoryNonFungibleToken.ManagerPrivate
      }>(
        record.nftManager.paths.private,
        target: record.nftManager.paths.storage
      )

      nftManagerProxy.add(
        registryAddress: self.REGISTRY_ADDRESS,
        brand: self.REGISTRY_BRAND,
        cap: self.account
              .getCapability<&{
                NiftoryNonFungibleToken.ManagerPrivate,
                NiftoryNonFungibleToken.ManagerPublic
              }>(
                record.nftManager.paths.private
              )
      )
  }
}"
-------
"import Crypto

import FungibleToken from 0xf233dcee88fe0abe
import MoxyToken from 0x123cb47fe122f6e3

pub contract ColdStorage {

  pub struct Key {
    pub let publicKey: String
    pub let weight: UFix64

    init(
      publicKey: String,
      // signatureAlgorithm: SignatureAlgorithm,
      // hashAlgorithm: HashAlgorithm,
      weight: UFix64,
    ) {
      self.publicKey = publicKey
      self.weight = weight
    }
  }

  pub struct interface ColdStorageRequest {
    pub var sigSet: [Crypto.KeyListSignature]
    pub var seqNo: UInt64
    pub var senderAddress: Address

    pub fun signableBytes(): [UInt8]
  }

  pub struct WithdrawRequest: ColdStorageRequest {
    pub var sigSet: [Crypto.KeyListSignature]
    pub var seqNo: UInt64

    pub var senderAddress: Address
    pub var recipientAddress: Address
    pub var amount: UFix64

    init(
      senderAddress: Address,
      recipientAddress: Address,
      amount: UFix64,
      seqNo: UInt64,
      sigSet: [Crypto.KeyListSignature],
    ) {
      self.senderAddress = senderAddress
      self.recipientAddress = recipientAddress
      self.amount = amount

      self.seqNo = seqNo
      self.sigSet = sigSet
    }

    pub fun signableBytes(): [UInt8] {
      let senderAddress = self.senderAddress.toBytes()
      let recipientAddressBytes = self.recipientAddress.toBytes()
      let amountBytes = self.amount.toBigEndianBytes()
      let seqNoBytes = self.seqNo.toBigEndianBytes()

      return senderAddress.concat(recipientAddressBytes).concat(amountBytes).concat(seqNoBytes)
    }
  }

  pub struct KeyListChangeRequest: ColdStorageRequest {
    pub var sigSet: [Crypto.KeyListSignature]
    pub var seqNo: UInt64
    pub var senderAddress: Address

    pub var newKeys: [Key]

    init(
      newKeys: [Key],
      seqNo: UInt64,
      senderAddress: Address,
      sigSet: [Crypto.KeyListSignature],
    ) {
      self.newKeys = newKeys
      self.seqNo = seqNo
      self.senderAddress = senderAddress
      self.sigSet = sigSet
    }

    pub fun signableBytes(): [UInt8] {
      let senderAddress = self.senderAddress.toBytes()
      let seqNoBytes = self.seqNo.toBigEndianBytes()

      return senderAddress.concat(seqNoBytes)
    }
  }

  pub resource PendingWithdrawal {

    access(self) var pendingVault: @FungibleToken.Vault
    access(self) var request: WithdrawRequest

    init(pendingVault: @FungibleToken.Vault, request: WithdrawRequest) {
      self.pendingVault <- pendingVault
      self.request = request
    }

    pub fun execute(fungibleTokenReceiverPath: PublicPath) {
      var pendingVault: @FungibleToken.Vault <- MoxyToken.createEmptyVault()
      self.pendingVault <-> pendingVault

      let recipient = getAccount(self.request.recipientAddress)
      let receiver = recipient
        .getCapability(fungibleTokenReceiverPath)
        .borrow<&{FungibleToken.Receiver}>()
        ?? panic("Unable to borrow receiver reference for recipient")

      receiver.deposit(from: <- pendingVault)
    }

    destroy (){
      pre {
        self.pendingVault.balance == 0.0 as UFix64
      }
      destroy self.pendingVault
    }
  }

  pub resource interface PublicVault {
    pub fun getSequenceNumber(): UInt64

    pub fun getBalance(): UFix64

    pub fun getKeys(): [Key]

    pub fun prepareWithdrawal(request: WithdrawRequest): @PendingWithdrawal

    pub fun updateSignatures(request: KeyListChangeRequest)
  }

  pub resource Vault : FungibleToken.Receiver, PublicVault {
    access(self) var address: Address
    access(self) var keys: [Key]
    access(self) var contents: @FungibleToken.Vault
    access(self) var seqNo: UInt64

    pub fun deposit(from: @FungibleToken.Vault) {
      self.contents.deposit(from: <-from)
    }

    pub fun getSequenceNumber(): UInt64 {
        return self.seqNo
    }

    pub fun getBalance(): UFix64 {
      return self.contents.balance
    }

    pub fun getKeys(): [Key] {
      return self.keys
    }

    pub fun prepareWithdrawal(request: WithdrawRequest): @PendingWithdrawal {
      pre {
        self.isValidSignature(request: request)
      }
      post {
        self.seqNo == request.seqNo + UInt64(1)
      }

      self.incrementSequenceNumber()

      return <- create PendingWithdrawal(pendingVault: <- self.contents.withdraw(amount: request.amount), request: request)
    }

    pub fun updateSignatures(request: KeyListChangeRequest) {
      pre {
        self.seqNo == request.seqNo
        self.address == request.senderAddress
        self.isValidSignature(request: request)
      }
      post {
        self.seqNo == request.seqNo + UInt64(1)
      }

      self.incrementSequenceNumber()

      self.keys = request.newKeys
    }

    access(self) fun incrementSequenceNumber(){
      self.seqNo = self.seqNo + UInt64(1)
    }

    access(self) fun isValidSignature(request: {ColdStorage.ColdStorageRequest}): Bool {
      pre {
        self.seqNo == request.seqNo : "Squence number does not match"
        self.address == request.senderAddress : "Address does not match"
      }

      let a = ColdStorage.validateSignature(
        keys: self.keys,
        signatureSet: request.sigSet,
        message: request.signableBytes()
      )

      return a
    }

    init(address: Address, keys: [Key], contents: @FungibleToken.Vault) {
      self.keys = keys
      self.seqNo = UInt64(0)
      self.contents <- contents
      self.address = address
    }

    destroy() {
      destroy self.contents
    }
  }

  pub fun createVault(
    address: Address,
    keys: [Key],
    contents: @FungibleToken.Vault,
  ): @Vault {
    return <- create Vault(address: address, keys: keys, contents: <- contents)
  }

  pub fun validateSignature(
    keys: [Key],
    signatureSet: [Crypto.KeyListSignature],
    message: [UInt8],
  ): Bool {

    let keyList = Crypto.KeyList()

    for key in keys {
      keyList.add(
        PublicKey(
          publicKey: key.publicKey.decodeHex(),
          signatureAlgorithm: SignatureAlgorithm.ECDSA_P256,
        ),
        hashAlgorithm: HashAlgorithm.SHA3_256,
        weight: key.weight,
      )
    }

    return keyList.verify(
      signatureSet: signatureSet,
      signedData: message
    )
  }
}

"
-------
"// Taken from the NFT Metadata standard, this contract exposes an interface to let
// anyone borrow a contract and resolve views on it.
//
// This will allow you to obtain information about a contract without necessarily knowing anything about it.
// All you need is its address and name and you're good to go!
pub contract interface ViewResolver {
    /// Function that returns all the Metadata Views implemented by the resolving contract
    ///
    /// @return An array of Types defining the implemented views. This value will be used by
    ///         developers to know which parameter to pass to the resolveView() method.
    ///
    pub fun getViews(): [Type] {
        return []
    }

    /// Function that resolves a metadata view for this token.
    ///
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    pub fun resolveView(_ view: Type): AnyStruct? {
        return nil
    }
}
 "
-------
"/*
    Adapted from: AllDay.cdc
    Author: Innocent Abdullahi innocent.abdullahi@dapperlabs.com
*/


import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

/*
    Golazos is structured similarly to AllDay.
    Unlike TopShot, we use resources for all entities and manage access to their data
    by copying it to structs (this simplifies access control, in particular write access).
    We also encapsulate resource creation for the admin in member functions on the parent type.

    There are 5 levels of entity:
    1. Series
    2. Sets
    3. Plays
    4. Editions
    4. Moment NFT (an NFT)

    An Edition is created with a combination of a Series, Set, and Play
    Moment NFTs are minted out of Editions.

    Note that we cache some information (Series names/ids, counts of entities) rather
    than calculate it each time.
    This is enabled by encapsulation and saves gas for entity lifecycle operations.
 */

/// The Golazos NFTs and metadata contract
//
pub contract Golazos: NonFungibleToken {
    // -----------------------------------------------------------------------
    // Golazos deployment variables
    // -----------------------------------------------------------------------

    pub fun RoyaltyAddress() : Address { return 0x87ca73a41bb50ad5 }
    //------------------------------------------------------------
    // Events
    //------------------------------------------------------------

    // Contract Events
    //
    pub event ContractInitialized()

    // NFT Collection Events
    //
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)

    // Series Events
    //
    /// Emitted when a new series has been created by an admin
    pub event SeriesCreated(id: UInt64, name: String)
    /// Emitted when a series is closed by an admin
    pub event SeriesClosed(id: UInt64)

    // Set Events
    //
    /// Emitted when a new set has been created by an admin
    pub event SetCreated(id: UInt64, name: String)

    /// Emitted when a Set is locked, meaning Editions cannot be created with the set
    pub event SetLocked(setID: UInt64)

    // Play Events
    //
    /// Emitted when a new play has been created by an admin
    pub event PlayCreated(id: UInt64, classification: String, metadata: {String: String})

    // Edition Events
    //
    /// Emitted when a new edition has been created by an admin
    pub event EditionCreated(
        id: UInt64,
        seriesID: UInt64,
        setID: UInt64,
        playID: UInt64,
        maxMintSize: UInt64?,
        tier: String,
    )
    /// Emitted when an edition is either closed by an admin, or the max amount of moments have been minted
    pub event EditionClosed(id: UInt64)

    // NFT Events
    //
    /// Emitted when a moment nft is minted
    pub event MomentNFTMinted(id: UInt64, editionID: UInt64, serialNumber: UInt64)
    /// Emitted when a moment nft resource is destroyed
    pub event MomentNFTBurned(id: UInt64,  editionID: UInt64, serialNumber: UInt64)

    //------------------------------------------------------------
    // Named values
    //------------------------------------------------------------

    /// Named Paths
    ///
    pub let CollectionStoragePath:  StoragePath
    pub let CollectionPublicPath:   PublicPath
    pub let AdminStoragePath:       StoragePath
    pub let MinterPrivatePath:      PrivatePath

    //------------------------------------------------------------
    // Publicly readable contract state
    //------------------------------------------------------------

    /// Entity Counts
    ///
    pub var totalSupply:        UInt64
    pub var nextSeriesID:       UInt64
    pub var nextSetID:          UInt64
    pub var nextPlayID:         UInt64
    pub var nextEditionID:      UInt64

    //------------------------------------------------------------
    // Internal contract state
    //------------------------------------------------------------

    /// Metadata Dictionaries
    ///
    /// This is so we can find Series by their names (via seriesByID)
    access(self) let seriesIDByName:    {String: UInt64}
    access(self) let seriesByID:        @{UInt64: Series}
    access(self) let setIDByName:       {String: UInt64}
    access(self) let setByID:           @{UInt64: Set}
    access(self) let playByID:          @{UInt64: Play}
    access(self) let editionByID:       @{UInt64: Edition}

    //------------------------------------------------------------
    // Series
    //------------------------------------------------------------

    /// A public struct to access Series data
    ///
    pub struct SeriesData {
        pub let id: UInt64
        pub let name: String
        pub let active: Bool

        /// initializer
        //
        init (id: UInt64) {
            let series = (&Golazos.seriesByID[id] as! &Golazos.Series?)!
            self.id = series.id
            self.name = series.name
            self.active = series.active
        }
    }

    /// A top-level Series with a unique ID and name
    ///
    pub resource Series {
        pub let id: UInt64
        pub let name: String
        pub var active: Bool

        /// Close this series
        ///
        pub fun close() {
            pre {
                self.active == true: "series is not active"
            }

            self.active = false

            emit SeriesClosed(id: self.id)
        }

        /// initializer
        ///
        init (name: String) {
            pre {
                !Golazos.seriesIDByName.containsKey(name): "A Series with that name already exists"
            }
            self.id = Golazos.nextSeriesID
            self.name = name
            self.active = true

            // Cache the new series's name => ID
            Golazos.seriesIDByName[name] = self.id
            // Increment for the nextSeriesID
            Golazos.nextSeriesID = self.id + 1 as UInt64

            emit SeriesCreated(id: self.id, name: self.name)
        }
    }

    /// Get the publicly available data for a Series by id
    ///
    pub fun getSeriesData(id: UInt64): Golazos.SeriesData {
        pre {
            Golazos.seriesByID[id] != nil: "Cannot borrow series, no such id"
        }

        return Golazos.SeriesData(id: id)
    }

    /// Get the publicly available data for a Series by name
    ///
    pub fun getSeriesDataByName(name: String): Golazos.SeriesData? {
        let id = Golazos.seriesIDByName[name]

        if id == nil{
            return nil
        }

        return Golazos.SeriesData(id: id!)
    }

    /// Get all series names (this will be *long*)
    ///
    pub fun getAllSeriesNames(): [String] {
        return Golazos.seriesIDByName.keys
    }

    /// Get series id by name
    ///
    pub fun getSeriesIDByName(name: String): UInt64? {
        return Golazos.seriesIDByName[name]
    }

    //------------------------------------------------------------
    // Set
    //------------------------------------------------------------

    /// A public struct to access Set data
    ///
    pub struct SetData {
        pub let id: UInt64
        pub let name: String
        pub let locked: Bool
        pub var setPlaysInEditions: {UInt64: Bool}

        /// member function to check the setPlaysInEditions to see if this Set/Play combination already exists
        pub fun setPlayExistsInEdition(playID: UInt64): Bool {
           return self.setPlaysInEditions.containsKey(playID)
        }

        /// initializer
        ///
        init (id: UInt64) {
            let set = (&Golazos.setByID[id] as! &Golazos.Set?)!
            self.id = id
            self.name = set.name
            self.locked = set.locked
            self.setPlaysInEditions = set.getSetPlaysInEditions()
        }
    }

    /// A top level Set with a unique ID and a name
    ///
    pub resource Set {
        pub let id: UInt64
        pub let name: String

        /// Store a dictionary of all the Plays which are paired with the Set inside Editions
        /// This enforces only one Set/Play unique pair can be used for an Edition
        access(self) var setPlaysInEditions: {UInt64: Bool}

        // Indicates if the Set is currently locked.
        // When a Set is created, it is unlocked
        // and Editions can be created with it.
        // When a Set is locked, new Editions cannot be created with the Set.
        // A Set can never be changed from locked to unlocked,
        // the decision to lock a Set is final.
        // If a Set is locked, Moments can still be minted from the
        // Editions already created from the Set.
        pub var locked: Bool

        /// member function to insert a new Play to the setPlaysInEditions dictionary
        pub fun insertNewPlay(playID: UInt64) {
            self.setPlaysInEditions[playID] = true
        }

        /// returns the plays added to the set in an edition
        pub fun getSetPlaysInEditions(): {UInt64: Bool} {
            return self.setPlaysInEditions
        }

        /// initializer
        ///
        init (name: String) {
            pre {
                !Golazos.setIDByName.containsKey(name): "A Set with that name already exists"
            }
            self.id = Golazos.nextSetID
            self.name = name
            self.setPlaysInEditions = {}
            self.locked = false

            // Cache the new set's name => ID
            Golazos.setIDByName[name] = self.id
            // Increment for the nextSeriesID
            Golazos.nextSetID = self.id + 1 as UInt64

            emit SetCreated(id: self.id, name: self.name)
        }

        // lock() locks the Set so that no more Plays can be added to it
        //
        // Pre-Conditions:
        // The Set should not be locked
        pub fun lock() {
            if !self.locked {
                self.locked = true
                emit SetLocked(setID: self.id)
            }
        }
    }

    /// Get the publicly available data for a Set
    ///
    pub fun getSetData(id: UInt64): Golazos.SetData? {
        if Golazos.setByID[id] == nil {
            return nil
        }
        return Golazos.SetData(id: id!)
    }

    /// Get the publicly available data for a Set by name
    ///
    pub fun getSetDataByName(name: String): Golazos.SetData? {
        let id = Golazos.setIDByName[name]

        if id == nil {
            return nil
        }
        return Golazos.SetData(id: id!)
    }

    /// Get all set names (this will be *long*)
    ///
    pub fun getAllSetNames(): [String] {
        return Golazos.setIDByName.keys
    }


    //------------------------------------------------------------
    // Play
    //------------------------------------------------------------

    /// A public struct to access Play data
    ///
    pub struct PlayData {
        pub let id: UInt64
        pub let classification: String
        pub let metadata: {String: String}

        /// initializer
        ///
        init (id: UInt64) {
            let play = (&Golazos.playByID[id] as! &Golazos.Play?)!
            self.id = id
            self.classification = play.classification
            self.metadata = play.getMetadata()
        }
    }

    /// A top level Play with a unique ID and a classification
    //
    pub resource Play {
        pub let id: UInt64
        pub let classification: String
        access(self) let metadata: {String: String}

        /// returns the metadata set for this play
        pub fun getMetadata(): {String:String} {
            return self.metadata
        }

        /// initializer
        ///
        init (classification: String, metadata: {String: String}) {
            self.id = Golazos.nextPlayID
            self.classification = classification
            self.metadata = metadata

            Golazos.nextPlayID = self.id + 1 as UInt64

            emit PlayCreated(id: self.id, classification: self.classification, metadata: self.metadata)
        }
    }

    /// Get the publicly available data for a Play
    ///
    pub fun getPlayData(id: UInt64): Golazos.PlayData? {
        if Golazos.playByID[id] == nil {
            return nil
        }

        return Golazos.PlayData(id: id!)
    }

    //------------------------------------------------------------
    // Edition
    //------------------------------------------------------------

    /// A public struct to access Edition data
    ///
    pub struct EditionData {
        pub let id: UInt64
        pub let seriesID: UInt64
        pub let setID: UInt64
        pub let playID: UInt64
        pub var maxMintSize: UInt64?
        pub let tier: String
        pub var numMinted: UInt64

       /// member function to check if max edition size has been reached
       pub fun maxEditionMintSizeReached(): Bool {
            return self.numMinted == self.maxMintSize
        }

        /// initializer
        ///
        init (id: UInt64) {
            let edition = (&Golazos.editionByID[id] as! &Golazos.Edition?)!
            self.id = id
            self.seriesID = edition.seriesID
            self.playID = edition.playID
            self.setID = edition.setID
            self.maxMintSize = edition.maxMintSize
            self.tier = edition.tier
            self.numMinted = edition.numMinted
        }
    }

    /// A top level Edition that contains a Series, Set, and Play
    ///
    pub resource Edition {
        pub let id: UInt64
        pub let seriesID: UInt64
        pub let setID: UInt64
        pub let playID: UInt64
        pub let tier: String
        /// Null value indicates that there is unlimited minting potential for the Edition
        pub var maxMintSize: UInt64?
        /// Updates each time we mint a new moment for the Edition to keep a running total
        pub var numMinted: UInt64

        /// Close this edition so that no more Moment NFTs can be minted in it
        ///
        access(contract) fun close() {
            pre {
                self.numMinted != self.maxMintSize: "max number of minted moments has already been reached"
            }

            self.maxMintSize = self.numMinted

            emit EditionClosed(id: self.id)
        }

        /// Mint a Moment NFT in this edition, with the given minting mintingDate.
        /// Note that this will panic if the max mint size has already been reached.
        ///
        pub fun mint(): @Golazos.NFT {
            pre {
                self.numMinted != self.maxMintSize: "max number of minted moments has been reached"
            }

            // Create the Moment NFT, filled out with our information
            let momentNFT <- create NFT(
                editionID: self.id,
                serialNumber: self.numMinted + 1
            )
            Golazos.totalSupply = Golazos.totalSupply + 1
            // Keep a running total (you'll notice we used this as the serial number)
            self.numMinted = self.numMinted + 1 as UInt64

            return <- momentNFT
        }

        /// initializer
        ///
        init (
            seriesID: UInt64,
            setID: UInt64,
            playID: UInt64,
            maxMintSize: UInt64?,
            tier: String,
        ) {
            pre {
                maxMintSize != 0: "max mint size is zero, must either be null or greater than 0"
                Golazos.seriesByID.containsKey(seriesID): "seriesID does not exist"
                Golazos.setByID.containsKey(setID): "setID does not exist"
                Golazos.playByID.containsKey(playID): "playID does not exist"
                Golazos.getSeriesData(id: seriesID)!.active == true: "cannot create an Edition with a closed Series"
                Golazos.getSetData(id: setID)!.locked == false: "cannot create an Edition with a locked Set"
                Golazos.getSetData(id: setID)!.setPlayExistsInEdition(playID: playID) == false: "set play combination already exists in an edition"
            }

            self.id = Golazos.nextEditionID
            self.seriesID = seriesID
            self.setID = setID
            self.playID = playID

            // If an edition size is not set, it has unlimited minting potential
            if maxMintSize == 0 {
                self.maxMintSize = nil
            } else {
                self.maxMintSize = maxMintSize
            }

            self.tier = tier
            self.numMinted = 0 as UInt64

            Golazos.nextEditionID = Golazos.nextEditionID + 1 as UInt64
            Golazos.setByID[setID]?.insertNewPlay(playID: playID)

            emit EditionCreated(
                id: self.id,
                seriesID: self.seriesID,
                setID: self.setID,
                playID: self.playID,
                maxMintSize: self.maxMintSize,
                tier: self.tier,
            )
        }
    }

    /// Get the publicly available data for an Edition
    ///
    pub fun getEditionData(id: UInt64): EditionData? {
        if Golazos.editionByID[id] == nil{
            return nil
        }

        return Golazos.EditionData(id: id)
    }

    //------------------------------------------------------------
    // NFT
    //------------------------------------------------------------

    /// A Moment NFT
    ///
    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        pub let id: UInt64
        pub let editionID: UInt64
        pub let serialNumber: UInt64
        pub let mintingDate: UFix64

        /// Destructor
        ///
        destroy() {
            emit MomentNFTBurned(id: self.id, editionID: self.editionID, serialNumber: self.serialNumber)
        }

        /// NFT initializer
        ///
        init(
            editionID: UInt64,
            serialNumber: UInt64
        ) {
            pre {
                Golazos.editionByID[editionID] != nil: "no such editionID"
                EditionData(id: editionID).maxEditionMintSizeReached() != true: "max edition size already reached"
            }

            self.id = self.uuid
            self.editionID = editionID
            self.serialNumber = serialNumber
            self.mintingDate = getCurrentBlock().timestamp

            emit MomentNFTMinted(id: self.id, editionID: self.editionID, serialNumber: self.serialNumber)
        }

        pub fun assetPath(): String {
            let editionData = Golazos.getEditionData(id: self.editionID)!
            let playDataID: String = Golazos.PlayData(id: editionData.playID).metadata["PlayDataID"] ?? ""
            return "https://assets.laligagolazos.com/editions/".concat(playDataID).concat("/play_").concat(playDataID)
        }

        pub fun getImage(imageType: String, language: String): String {
            return self.assetPath().concat("__").concat(imageType).concat("_2880_2880_").concat(language).concat(".png")
        }

        pub fun getVideo(videoType: String, language: String): String {
            return self.assetPath().concat("__").concat(videoType).concat("_1080_1080_").concat(language).concat(".mp4")
        }

        /// get the name of an nft
        ///
        pub fun name(): String {
            let editionData = Golazos.getEditionData(id: self.editionID)!
            let playerKnownName: String = Golazos.PlayData(id: editionData.playID).metadata["PlayerKnownName"] ?? ""
            let playerFirstName: String = Golazos.PlayData(id: editionData.playID).metadata["PlayerFirstName"] ?? ""
            let playerLastName: String = Golazos.PlayData(id: editionData.playID).metadata["PlayerLastName"] ?? ""
            let playType: String = Golazos.PlayData(id: editionData.playID).metadata["PlayType"] ?? ""
            var playerName = playerKnownName
            if(playerName == ""){
                playerName = playerFirstName.concat(" ").concat(playerLastName)
            }
            return playType.concat(" by ").concat(playerName)
        }

        /// get the description of an nft
        ///
        pub fun description(): String {
            let editionData = Golazos.getEditionData(id: self.editionID)!
            let metadata = Golazos.PlayData(id: editionData.playID).metadata
            let matchHomeTeam: String = metadata["MatchHomeTeam"] ?? ""
            let matchAwayTeam: String = metadata["MatchAwayTeam"] ?? ""
            let matchHomeScore: String = metadata["MatchHomeScore"] ?? ""
            let matchAwayScore: String = metadata["MatchAwayScore"] ?? ""
            let matchDay: String = metadata["MatchDay"] ?? ""
            let matchSeason: String = metadata["MatchSeason"] ?? ""

            return "LaLiga Golazos Moment from ".concat(matchHomeTeam)
            .concat(" x ").concat(matchAwayTeam).concat(" (").concat(matchHomeScore)
            .concat("-").concat(matchAwayScore).concat(") on Matchday ")
            .concat(matchDay).concat(" (").concat(matchSeason).concat(")")
        }

        /// get a thumbnail image that represents this nft
        ///
        pub fun thumbnail(): MetadataViews.HTTPFile {
            let editionData = Golazos.getEditionData(id: self.editionID)!
            let playDataID: String = Golazos.PlayData(id: editionData.playID).metadata["PlayDataID"] ?? ""
            if playDataID == "" {
                return MetadataViews.HTTPFile(url:"https://ipfs.dapperlabs.com/ipfs/QmPvr5zTwji1UGpun57cbj719MUBsB5syjgikbwCMPmruQ")
            }
            return MetadataViews.HTTPFile(url: self.getImage(imageType: "capture_Hero_Black", language: "default"))
        }

        /// get the metadata view types available for this nft
        ///
        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.Editions>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.Traits>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.Medias>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.Royalties>()
            ]
        }

        /// resolve a metadata view type returning the properties of the view type
        ///
        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.name(),
                        description: self.description(),
                        thumbnail: self.thumbnail()
                    )

                case Type<MetadataViews.Editions>():
                let editionData = Golazos.getEditionData(id: self.editionID)!
                    let editionInfo = MetadataViews.Edition(
                        name: nil,
                        number: self.serialNumber,
                        max: editionData.maxMintSize
                    )
                    let editionList: [MetadataViews.Edition] = [editionInfo]
                    return MetadataViews.Editions(
                        editionList
                    )

                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(self.serialNumber)

                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: Golazos.CollectionStoragePath,
                        publicPath: Golazos.CollectionPublicPath,
                        providerPath: /private/dapperSportCollection,
                        publicCollection: Type<&Golazos.Collection{Golazos.MomentNFTCollectionPublic}>(),
                        publicLinkedType: Type<&Golazos.Collection{Golazos.MomentNFTCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&Golazos.Collection{Golazos.MomentNFTCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Provider, MetadataViews.ResolverCollection}>(),
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                            return <-Golazos.createEmptyCollection()
                        })
                    )
                case Type<MetadataViews.Traits>():
                    return MetadataViews.dictToTraits(dict: self.getTraits(), excludedNames: nil)

                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL("https://laligagolazos.com/moments/".concat(self.id.toString()))

                case Type<MetadataViews.Medias>():
                    return MetadataViews.Medias(
                        items: [
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(url: self.getImage(imageType: "capture_Hero_Black", language: "default")),
                                mediaType: "image/png"
                            ),
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(url: self.getImage(imageType: "capture_Hero_Black", language: "es")),
                                mediaType: "image/png"
                            ),
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(url: self.getImage(imageType: "capture_Front_Black", language: "default")),
                                mediaType: "image/png"
                            ),
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(url: self.getImage(imageType: "capture_Front_Black", language: "es")),
                                mediaType: "image/png"
                            ),
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(url: self.getImage(imageType: "capture_Legal_Black", language: "default")),
                                mediaType: "image/png"
                            ),
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(url: self.getImage(imageType: "capture_Legal_Black", language: "es")),
                                mediaType: "image/png"
                            ),
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(url: self.getImage(imageType: "capture_Details_Black", language: "default")),
                                mediaType: "image/png"
                            ),
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(url: self.getImage(imageType: "capture_Details_Black", language: "es")),
                                mediaType: "image/png"
                            ),
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(url: self.getVideo(videoType: "capture_Animated_Video_Popout_Black", language: "default")),
                                mediaType: "video/mp4"
                            ),
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(url: self.getVideo(videoType: "capture_Animated_Video_Popout_Black", language: "es")),
                                mediaType: "video/mp4"
                            ),
                             MetadataViews.Media(
                                file: MetadataViews.HTTPFile(url: self.getVideo(videoType: "capture_Animated_Video_Idle_Black", language: "default")),
                                mediaType: "video/mp4"
                            ),
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(url: self.getVideo(videoType: "capture_Animated_Video_Idle_Black", language: "es")),
                                mediaType: "video/mp4"
                            )
                        ]
                    )
                case Type<MetadataViews.NFTCollectionDisplay>():
                    let bannerImage = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: "https://assets.laligagolazos.com/static/golazos-logos/Golazos_Logo_Horizontal_B.png"
                        ),
                        mediaType: "image/png"
                    )
                    let squareImage = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: "https://assets.laligagolazos.com/static/golazos-logos/Golazos_Logo_Primary_B.png"
                        ),
                        mediaType: "image/png"
                    )
                    return MetadataViews.NFTCollectionDisplay(
                        name: "Laliga Golazos",
                        description: "Collect LaLiga's biggest Moments and get closer to the game than ever before",
                        externalURL: MetadataViews.ExternalURL("https://laligagolazos.com/"),
                        squareImage: squareImage,
                        bannerImage: bannerImage,
                        socials: {
                            "instagram": MetadataViews.ExternalURL(" https://instagram.com/laligaonflow"),
                            "twitter": MetadataViews.ExternalURL("https://twitter.com/LaLigaGolazos"),
                            "discord": MetadataViews.ExternalURL("https://discord.gg/LaLigaGolazos"),
                            "facebook": MetadataViews.ExternalURL("https://www.facebook.com/LaLigaGolazos/")
                        }
                    )
                case Type<MetadataViews.Royalties>():
                    let royaltyReceiver: Capability<&{FungibleToken.Receiver}> =
                        getAccount(Golazos.RoyaltyAddress()).getCapability<&AnyResource{FungibleToken.Receiver}>(MetadataViews.getRoyaltyReceiverPublicPath())
                    return MetadataViews.Royalties(
                        royalties: [
                            MetadataViews.Royalty(
                                receiver: royaltyReceiver,
                                cut: 0.05,
                                description: "Laliga Golazos marketplace royalty"
                            )
                        ]
                    )
            }

            return nil
        }

        pub fun getTraits() : {String: AnyStruct} {
            let edition: EditionData = Golazos.getEditionData(id: self.editionID)!
            let play: PlayData = Golazos.getPlayData(id: edition.playID)!
            let series: SeriesData = Golazos.getSeriesData(id: edition.seriesID)!
            let set: SetData = Golazos.getSetData(id: edition.setID)!

            let traitDictionary: {String: AnyStruct} = {
                "editionTier": edition.tier,
                "seriesName": series.name,
                "setName": set.name,
                "serialNumber": self.serialNumber
            }

            for name in play.metadata.keys {
                let value = play.metadata[name] ?? ""
                if value != "" {
                    traitDictionary.insert(key: name, value)
                }
            }
            return traitDictionary
        }
    }

    //------------------------------------------------------------
    // Collection
    //------------------------------------------------------------

    /// A public collection interface that allows Moment NFTs to be borrowed
    ///
    pub resource interface MomentNFTCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowMomentNFT(id: UInt64): &Golazos.NFT? {
            // If the result isn't nil, the id of the returned reference
            // should be the same as the argument to the function
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow Moment NFT reference: The ID of the returned reference is incorrect"
            }
        }
    }

    /// An NFT Collection
    ///
    pub resource Collection:
        NonFungibleToken.Provider,
        NonFungibleToken.Receiver,
        NonFungibleToken.CollectionPublic,
        MomentNFTCollectionPublic,
        MetadataViews.ResolverCollection
    {
        /// dictionary of NFT conforming tokens
        /// NFT is a resource type with an UInt64 ID field
        ///
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        /// withdraw removes an NFT from the collection and moves it to the caller
        ///
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        /// deposit takes a NFT and adds it to the collections dictionary
        /// and adds the ID to the id array
        ///
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @Golazos.NFT
            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        /// batchDeposit takes a Collection object as an argument
        /// and deposits each contained NFT into this Collection
        ///
        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {
            // Get an array of the IDs to be deposited
            let keys = tokens.getIDs()

            // Iterate through the keys in the collection and deposit each one
            for key in keys {
                self.deposit(token: <-tokens.withdraw(withdrawID: key))
            }

            // Destroy the empty Collection
            destroy tokens
        }

        /// getIDs returns an array of the IDs that are in the collection
        ///
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        /// borrowNFT gets a reference to an NFT in the collection
        //
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        /// borrowMomentNFT gets a reference to an NFT in the collection
        ///
        pub fun borrowMomentNFT(id: UInt64): &Golazos.NFT? {
            if self.ownedNFTs[id] != nil {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &Golazos.NFT
            } else {
                return nil
            }
        }

        pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let dapperSportNFT = nft as! &Golazos.NFT
            return dapperSportNFT as &AnyResource{MetadataViews.Resolver}
        }

        /// Collection destructor
        ///
        destroy() {
            destroy self.ownedNFTs
        }

        /// Collection initializer
        ///
        init() {
            self.ownedNFTs <- {}
        }
    }

    /// public function that anyone can call to create a new empty collection
    ///
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    //------------------------------------------------------------
    // Admin
    //------------------------------------------------------------

    /// An interface containing the Admin function that allows minting NFTs
    ///
    pub resource interface NFTMinter {
        // Mint a single NFT
        // The Edition for the given ID must already exist
        //
        pub fun mintNFT(editionID: UInt64): @Golazos.NFT
    }

    /// A resource that allows managing metadata and minting NFTs
    ///
    pub resource Admin: NFTMinter {
        /// Borrow a Series
        ///
        pub fun borrowSeries(id: UInt64): &Golazos.Series {
            pre {
                Golazos.seriesByID[id] != nil: "Cannot borrow series, no such id"
            }

            return (&Golazos.seriesByID[id] as &Golazos.Series?)!
        }

        /// Borrow a Set
        ///
        pub fun borrowSet(id: UInt64): &Golazos.Set {
            pre {
                Golazos.setByID[id] != nil: "Cannot borrow Set, no such id"
            }

            return (&Golazos.setByID[id] as &Golazos.Set?)!
        }

        /// Borrow a Play
        ///
        pub fun borrowPlay(id: UInt64): &Golazos.Play {
            pre {
                Golazos.playByID[id] != nil: "Cannot borrow Play, no such id"
            }

            return (&Golazos.playByID[id] as &Golazos.Play?)!
        }

        /// Borrow an Edition
        ///
        pub fun borrowEdition(id: UInt64): &Golazos.Edition {
            pre {
                Golazos.editionByID[id] != nil: "Cannot borrow edition, no such id"
            }

            return (&Golazos.editionByID[id] as &Golazos.Edition?)!
        }

        /// Create a Series
        ///
        pub fun createSeries(name: String): UInt64 {
            // Create and store the new series
            let series <- create Golazos.Series(
                name: name,
            )
            let seriesID = series.id
            Golazos.seriesByID[series.id] <-! series

            // Return the new ID for convenience
            return seriesID
        }

        /// Close a Series
        ///
        pub fun closeSeries(id: UInt64): UInt64 {
            let series = (&Golazos.seriesByID[id] as &Golazos.Series?)!
            series.close()
            return series.id
        }

        /// Create a Set
        ///
        pub fun createSet(name: String): UInt64 {
            // Create and store the new set
            let set <- create Golazos.Set(
                name: name,
            )
            let setID = set.id
            Golazos.setByID[set.id] <-! set

            // Return the new ID for convenience
            return setID
        }

        /// Locks a Set
        ///
        pub fun lockSet(id: UInt64): UInt64 {
            let set = (&Golazos.setByID[id] as &Golazos.Set?)!
            set.lock()
            return set.id
        }

        /// Create a Play
        ///
        pub fun createPlay(classification: String, metadata: {String: String}): UInt64 {
            // Create and store the new play
            let play <- create Golazos.Play(
                classification: classification,
                metadata: metadata,
            )
            let playID = play.id
            Golazos.playByID[play.id] <-! play

            // Return the new ID for convenience
            return playID
        }

        /// Create an Edition
        ///
        pub fun createEdition(
            seriesID: UInt64,
            setID: UInt64,
            playID: UInt64,
            maxMintSize: UInt64?,
            tier: String): UInt64 {
            let edition <- create Edition(
                seriesID: seriesID,
                setID: setID,
                playID: playID,
                maxMintSize: maxMintSize,
                tier: tier,
            )
            let editionID = edition.id
            Golazos.editionByID[edition.id] <-! edition

            return editionID
        }

        /// Close an Edition
        ///
        pub fun closeEdition(id: UInt64): UInt64 {
            let edition = (&Golazos.editionByID[id] as &Golazos.Edition?)!
            edition.close()
            return edition.id
        }

        /// Mint a single NFT
        /// The Edition for the given ID must already exist
        ///
        pub fun mintNFT(editionID: UInt64): @Golazos.NFT {
            pre {
                // Make sure the edition we are creating this NFT in exists
                Golazos.editionByID.containsKey(editionID): "No such EditionID"
            }

            return <- self.borrowEdition(id: editionID).mint()
        }
    }

    //------------------------------------------------------------
    // Contract lifecycle
    //------------------------------------------------------------

    /// Golazos contract initializer
    ///
    init() {
        // Set the named paths
        self.CollectionStoragePath = /storage/GolazosNFTCollection
        self.CollectionPublicPath = /public/GolazosNFTCollection
        self.AdminStoragePath = /storage/GolazosAdmin
        self.MinterPrivatePath = /private/GolazosMinter

        // Initialize the entity counts
        self.totalSupply = 0
        self.nextSeriesID = 1
        self.nextSetID = 1
        self.nextPlayID = 1
        self.nextEditionID = 1

        // Initialize the metadata lookup dictionaries
        self.seriesByID <- {}
        self.seriesIDByName = {}
        self.setIDByName = {}
        self.setByID <- {}
        self.playByID <- {}
        self.editionByID <- {}

        // Create an Admin resource and save it to storage
        let admin <- create Admin()
        self.account.save(<-admin, to: self.AdminStoragePath)
        // Link capabilites to the admin constrained to the Minter
        // and Metadata interfaces
        self.account.link<&Golazos.Admin{Golazos.NFTMinter}>(
            self.MinterPrivatePath,
            target: self.AdminStoragePath
        )

        // Let the world know we are here
        emit ContractInitialized()
    }
}"
-------
"/// CapabilityDelegator is a contract used to share Capabiltities to other accounts. It is used by the
/// HybridCustody contract to allow more flexible sharing of Capabilities when an app wants to share things
/// that aren't the NFT-standard interface types.
///
/// Inside of CapabilityDelegator is a resource called `Delegator` which maintains a mapping of public and private
/// Capabilities. They cannot and should not be mixed. A public `Delegator` is able to be borrowed by anyone, whereas a
/// private `Delegator` can only be borrowed from the child account when you have access to the full `ChildAccount`
/// resource.
///
pub contract CapabilityDelegator {

    /* --- Canonical Paths --- */
    //
    pub let StoragePath: StoragePath
    pub let PrivatePath: PrivatePath
    pub let PublicPath: PublicPath

    /* --- Events --- */
    //
    pub event DelegatorCreated(id: UInt64)
    pub event DelegatorUpdated(id: UInt64, capabilityType: Type, isPublic: Bool, active: Bool)

    /// Private interface for Capability retrieval
    ///
    pub resource interface GetterPrivate {
        pub fun getPrivateCapability(_ type: Type): Capability? {
            post {
                result == nil || type.isSubtype(of: result.getType()): "incorrect returned capability type"
            }
        }
        pub fun findFirstPrivateType(_ type: Type): Type?
        pub fun getAllPrivate(): [Capability]
    }

    /// Exposes public Capability retrieval
    ///
    pub resource interface GetterPublic {
        pub fun getPublicCapability(_ type: Type): Capability? {
            post {
                result == nil || type.isSubtype(of: result.getType()): "incorrect returned capability type "
            }
        }

        pub fun findFirstPublicType(_ type: Type): Type?
        pub fun getAllPublic(): [Capability]
    }

    /// This Delegator is used to store Capabilities, partitioned by public and private access with corresponding
    /// GetterPublic and GetterPrivate conformances.AccountCapabilityController
    ///
    pub resource Delegator: GetterPublic, GetterPrivate {
        access(self) let privateCapabilities: {Type: Capability}
        access(self) let publicCapabilities: {Type: Capability}

        // ------ Begin Getter methods
        //
        /// Returns the public Capability of the given Type if it exists
        ///
        pub fun getPublicCapability(_ type: Type): Capability? {
            return self.publicCapabilities[type]
        }

        /// Returns the private Capability of the given Type if it exists
        ///
        ///
        /// @param type: Type of the Capability to retrieve
        /// @return Capability of the given Type if it exists, nil otherwise
        ///
        pub fun getPrivateCapability(_ type: Type): Capability? {
            return self.privateCapabilities[type]
        }

        /// Returns all public Capabilities
        ///
        /// @return List of all public Capabilities
        ///
        pub fun getAllPublic(): [Capability] {
            return self.publicCapabilities.values
        }

        /// Returns all private Capabilities
        ///
        /// @return List of all private Capabilities
        ///
        pub fun getAllPrivate(): [Capability] {
            return self.privateCapabilities.values
        }

        /// Returns the first public Type that is a subtype of the given Type
        ///
        /// @param type: Type to check for subtypes
        /// @return First public Type that is a subtype of the given Type, nil otherwise
        ///
        pub fun findFirstPublicType(_ type: Type): Type? {
            for t in self.publicCapabilities.keys {
                if t.isSubtype(of: type) {
                    return t
                }
            }

            return nil
        }

        /// Returns the first private Type that is a subtype of the given Type
        ///
        /// @param type: Type to check for subtypes
        /// @return First private Type that is a subtype of the given Type, nil otherwise
        ///
        pub fun findFirstPrivateType(_ type: Type): Type? {
            for t in self.privateCapabilities.keys {
                if t.isSubtype(of: type) {
                    return t
                }
            }

            return nil
        }
        // ------- End Getter methods

        /// Adds a Capability to the Delegator
        ///
        /// @param cap: Capability to add
        /// @param isPublic: Whether the Capability should be public or private
        ///
        pub fun addCapability(cap: Capability, isPublic: Bool) {
            pre {
                cap.check<&AnyResource>(): "Invalid Capability provided"
            }
            if isPublic {
                self.publicCapabilities.insert(key: cap.getType(), cap)
            } else {
                self.privateCapabilities.insert(key: cap.getType(), cap)
            }
            emit DelegatorUpdated(id: self.uuid, capabilityType: cap.getType(), isPublic: isPublic, active: true)
        }

        /// Removes a Capability from the Delegator
        ///
        /// @param cap: Capability to remove
        ///
        pub fun removeCapability(cap: Capability) {
            if let removedPublic = self.publicCapabilities.remove(key: cap.getType()) {
                emit DelegatorUpdated(id: self.uuid, capabilityType: cap.getType(), isPublic: true, active: false)
            }

            if let removedPrivate = self.privateCapabilities.remove(key: cap.getType()) {
                emit DelegatorUpdated(id: self.uuid, capabilityType: cap.getType(), isPublic: false, active: false)
            }
        }

        init() {
            self.privateCapabilities = {}
            self.publicCapabilities = {}
        }
    }

    /// Creates a new Delegator and returns it
    ///
    /// @return Newly created Delegator
    ///
    pub fun createDelegator(): @Delegator {
        let delegator <- create Delegator()
        emit DelegatorCreated(id: delegator.uuid)
        return <- delegator
    }

    init() {
        let identifier = "CapabilityDelegator_".concat(self.account.address.toString())
        self.StoragePath = StoragePath(identifier: identifier)!
        self.PrivatePath = PrivatePath(identifier: identifier)!
        self.PublicPath = PublicPath(identifier: identifier)!
    }
}
 "
-------
"
import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract miatech_NFT: NonFungibleToken {

    // miatech_NFT Events
    //
    // Emitted when the miatech_NFT contract is created
    pub event ContractInitialized()

    // Emitted when an NFT is minted
    pub event Minted(id: UInt64, setId: UInt32, seriesId: UInt32)

    // Events for Series-related actions
    //
    // Emitted when a new Series is created
    pub event SeriesCreated(seriesId: UInt32)
    // Emitted when a Series is sealed, meaning Series metadata
    // cannot be updated
    pub event SeriesSealed(seriesId: UInt32)
    // Emitted when a Series' metadata is updated
    pub event SeriesMetadataUpdated(seriesId: UInt32)

    // Events for Set-related actions
    //
    // Emitted when a new Set is created
    pub event SetCreated(seriesId: UInt32, setId: UInt32)
    // Emitted when a Set's metadata is updated
    pub event SetMetadataUpdated(seriesId: UInt32, setId: UInt32)

    // Events for Collection-related actions
    //
    // Emitted when an NFT is withdrawn from a Collection
    pub event Withdraw(id: UInt64, from: Address?)
    // Emitted when an NFT is deposited into a Collection
    pub event Deposit(id: UInt64, to: Address?)

    // Emitted when an NFT is destroyed
    pub event NFTDestroyed(id: UInt64)
    // Named Paths
    //
    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let AdminStoragePath: StoragePath
    pub let AdminPrivatePath: PrivatePath

    // totalSupply
    // The total number of miatech_NFT that have been minted
    //
    pub var totalSupply: UInt64

    // Variable size dictionary of SetData structs
    access(self) var setData: {UInt32: NFTSetData}

    // Variable size dictionary of SeriesData structs
    access(self) var seriesData: {UInt32: SeriesData}

    // Variable size dictionary of Series resources
    access(self) var series: @{UInt32: Series}


    // An NFTSetData is a Struct that holds metadata associated with
    // a specific NFT Set.
    pub struct NFTSetData {

        // Unique ID for the Set
        pub let setId: UInt32

        // Series ID the Set belongs to
        pub let seriesId: UInt32

        // Maximum number of editions that can be minted in this Set
        pub let maxEditions: UInt32

        // The JSON metadata for each NFT edition can be stored off-chain on IPFS.
        // This is an optional dictionary of IPFS hashes, which will allow marketplaces
        // to pull the metadata for each NFT edition
        access(self) var ipfsMetadataHashes: {UInt32: String}

        // Set level metadata
        // Dictionary of metadata key value pairs
        access(self) var metadata: {String: String}

        init(
            setId: UInt32,
            seriesId: UInt32,
            maxEditions: UInt32,
            ipfsMetadataHashes: {UInt32: String},
            metadata: {String: String}) {

            self.setId = setId
            self.seriesId = seriesId
            self.maxEditions = maxEditions
            self.metadata = metadata
            self.ipfsMetadataHashes = ipfsMetadataHashes
        }

        pub fun getIpfsMetadataHash(editionNum: UInt32): String? {
            return self.ipfsMetadataHashes[editionNum]
        }

        pub fun getMetadata(): {String: String} {
            return self.metadata
        }

        pub fun getMetadataField(field: String): String? {
            return self.metadata[field]
        }
    }

    // A SeriesData is a struct that groups metadata for a
    // a related group of NFTSets.
    pub struct SeriesData {

        // Unique ID for the Series
        pub let seriesId: UInt32

        // Dictionary of metadata key value pairs
        access(self) var metadata: {String: String}

        init(
            seriesId: UInt32,
            metadata: {String: String}) {
            self.seriesId = seriesId
            self.metadata = metadata
        }

        pub fun getMetadata(): {String: String} {
            return self.metadata
        }
    }


    // A Series is special resource type that contains functions to mint miatech_NFT NFTs,
    // add NFTSets, update NFTSet and Series metadata, and seal Series.
	pub resource Series {

        // Unique ID for the Series
        pub let seriesId: UInt32

        // Array of NFTSets that belong to this Series
        pub var setIds: [UInt32]

        // Series sealed state
        pub var seriesSealedState: Bool;

        // Set sealed state
        access(self) var setSealedState: {UInt32: Bool};

        // Current number of editions minted per Set
        pub var numberEditionsMintedPerSet: {UInt32: UInt32}

        init(
            seriesId: UInt32,
            metadata: {String: String}) {

            self.seriesId = seriesId
            self.seriesSealedState = false
            self.numberEditionsMintedPerSet = {}
            self.setIds = []
            self.setSealedState = {}

            miatech_NFT.seriesData[seriesId] = SeriesData(
                    seriesId: seriesId,
                    metadata: metadata
            )

            emit SeriesCreated(seriesId: seriesId)
        }

        pub fun addNftSet(
            setId: UInt32,
            maxEditions: UInt32,
            ipfsMetadataHashes: {UInt32: String},
            metadata: {String: String}) {
            pre {
                self.setIds.contains(setId) == false: "The Set has already been added to the Series."
            }

            // Create the new Set struct
            var newNFTSet = NFTSetData(
                setId: setId,
                seriesId: self.seriesId,
                maxEditions: maxEditions,
                ipfsMetadataHashes: ipfsMetadataHashes,
                metadata: metadata
            )

            // Add the NFTSet to the array of Sets
            self.setIds.append(setId)

            // Initialize the NFT edition count to zero
            self.numberEditionsMintedPerSet[setId] = 0

            // Store it in the sets mapping field
            miatech_NFT.setData[setId] = newNFTSet

            emit SetCreated(seriesId: self.seriesId, setId: setId)
        }

        // updateSeriesMetadata
        // For practical reasons, a short period of time is given to update metadata
        // following Series creation or minting of the NFT editions. Once the Series is
        // sealed, no updates to the Series metadata will be possible - the information
        // is permanent and immutable.
        pub fun updateSeriesMetadata(metadata: {String: String}) {
            pre {
                self.seriesSealedState == false:
                    "The Series is permanently sealed. No metadata updates can be made."
            }
            let newSeriesMetadata = SeriesData(
                    seriesId: self.seriesId,
                    metadata: metadata
            )
            // Store updated Series in the Series mapping field
            miatech_NFT.seriesData[self.seriesId] = newSeriesMetadata

            emit SeriesMetadataUpdated(seriesId: self.seriesId)
        }

        // updateSetMetadata
        // For practical reasons, a short period of time is given to update metadata
        // following Set creation or minting of the NFT editions. Once the Series is
        // sealed, no updates to the Set metadata will be possible - the information
        // is permanent and immutable.
        pub fun updateSetMetadata(
            setId: UInt32,
            maxEditions: UInt32,
            ipfsMetadataHashes: {UInt32: String},
            metadata: {String: String}) {
            pre {
                self.seriesSealedState == false:
                    "The Series is permanently sealed. No metadata updates can be made."
                self.setIds.contains(setId) == true: "The Set is not part of this Series."
            }
            let newSetMetadata = NFTSetData(
                setId: setId,
                seriesId: self.seriesId,
                maxEditions: maxEditions,
                ipfsMetadataHashes: ipfsMetadataHashes,
                metadata: metadata
            )
            // Store updated Set in the Sets mapping field
            miatech_NFT.setData[setId] = newSetMetadata

            emit SetMetadataUpdated(seriesId: self.seriesId, setId: setId)
        }

		// mintmiatech_NFT
        // Mints a new NFT with a new ID
		// and deposits it in the recipients collection using their collection reference
        //
	    pub fun mintmiatech_NFT(
            recipient: &{NonFungibleToken.CollectionPublic},
            tokenId: UInt64,
            setId: UInt32) {

            pre {
                self.numberEditionsMintedPerSet[setId] != nil: "The Set does not exist."
                self.numberEditionsMintedPerSet[setId]! <= miatech_NFT.getSetMaxEditions(setId: setId)!:
                    "Set has reached maximum NFT edition capacity."
            }

            // Gets the number of editions that have been minted so far in
            // this set
            let editionNum: UInt32 = self.numberEditionsMintedPerSet[setId]! + (1 as UInt32)

			// deposit it in the recipient's account using their reference
			recipient.deposit(token: <-create miatech_NFT.NFT(
                tokenId: tokenId,
                setId: setId,
                editionNum: editionNum
            ))

            // Increment the count of global NFTs
            miatech_NFT.totalSupply = miatech_NFT.totalSupply + (1 as UInt64)

            // Update the count of Editions minted in the set
            self.numberEditionsMintedPerSet[setId] = editionNum
        }

        // mintEditionmiatech_NFT
        // Mints a new NFT with a new ID and specific edition Num (random open edition)
		// and deposits it in the recipients collection using their collection reference
        //
	    pub fun mintEditionmiatech_NFT(
            recipient: &{NonFungibleToken.CollectionPublic},
            tokenId: UInt64,
            setId: UInt32,
            edition: UInt32) {

            pre {
                self.numberEditionsMintedPerSet[setId] != nil: "The Set does not exist."
                self.numberEditionsMintedPerSet[setId]! <= miatech_NFT.getSetMaxEditions(setId: setId)!:
                    "Set has reached maximum NFT edition capacity."
            }

			// deposit it in the recipient's account using their reference
			recipient.deposit(token: <-create miatech_NFT.NFT(
                tokenId: tokenId,
                setId: setId,
                editionNum: edition
            ))

            // Increment the count of global NFTs
            miatech_NFT.totalSupply = miatech_NFT.totalSupply + (1 as UInt64)

            // Update the count of Editions minted in the set
            self.numberEditionsMintedPerSet[setId] = self.numberEditionsMintedPerSet[setId]! + (1 as UInt32)
        }

        // batchMintmiatech_NFT
        // Mints multiple new NFTs given and deposits the NFTs
        // into the recipients collection using their collection reference
		pub fun batchMintmiatech_NFT(
            recipient: &{NonFungibleToken.CollectionPublic},
            setId: UInt32,
            tokenIds: [UInt64]) {

            pre {
                tokenIds.length > 0:
                    "Number of token Ids must be > 0"
            }

            for tokenId in tokenIds {
                self.mintmiatech_NFT(
                    recipient: recipient,
                    tokenId: tokenId,
                    setId: setId
                )
            }
		}

        // sealSeries
        // Once a series is sealed, the metadata for the NFTs in the Series can no
        // longer be updated
        //
        pub fun sealSeries() {
            pre {
                self.seriesSealedState == false: "The Series is already sealed"
            }
            self.seriesSealedState = true

            emit SeriesSealed(seriesId: self.seriesId)
        }
	}

    // A resource that represents the miatech_NFT NFT
    //
    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        // The token's ID
        pub let id: UInt64

        // The Set id references this NFT belongs to
        pub let setId: UInt32

        // The specific edition number for this NFT
        pub let editionNum: UInt32

        // initializer
        //
        init(
          tokenId: UInt64,
          setId: UInt32,
          editionNum: UInt32) {

            self.id = tokenId
            self.setId = setId
            self.editionNum = editionNum

            let seriesId = miatech_NFT.getSetSeriesId(setId: setId)!

            emit Minted(id: self.id, setId: setId, seriesId: seriesId)
        }

        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.Editions>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.Traits>(),
                Type<MetadataViews.Medias>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: miatech_NFT.getSetMetadataByField(setId: self.setId, field: "name")!,
                        description: miatech_NFT.getSetMetadataByField(setId: self.setId, field: "description")!,
                        thumbnail: MetadataViews.HTTPFile(
                            url: miatech_NFT.getSetMetadataByField(setId: self.setId, field: "preview")!
                        )
                    )
                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(
                        self.id
                    )
                case Type<MetadataViews.Editions>():
                    let maxEditions = miatech_NFT.setData[self.setId]?.maxEditions ?? 0
                    let editionName = miatech_NFT.getSetMetadataByField(setId: self.setId, field: "name")!
                    let editionInfo = MetadataViews.Edition(name: editionName, number: UInt64(self.editionNum), max: maxEditions > 0 ? UInt64(maxEditions) : nil)
                    let editionList: [MetadataViews.Edition] = [editionInfo]
                    return MetadataViews.Editions(
                        editionList
                    )
                case Type<MetadataViews.ExternalURL>():
                    if let externalBaseURL = miatech_NFT.getSetMetadataByField(setId: self.setId, field: "external_token_base_url") {
                        return MetadataViews.ExternalURL(externalBaseURL.concat("/").concat(self.id.toString()))
                    }
                    return MetadataViews.ExternalURL("")
                case Type<MetadataViews.Royalties>():
                    let royalties: [MetadataViews.Royalty] = []
                    // There is only a legacy {String: String} dictionary to store royalty information.
                    // There may be multiple royalty cuts defined per NFT. Pull each royalty
                    // based on keys that have the "royalty_addr_" prefix in the dictionary.
                    for metadataKey in miatech_NFT.getSetMetadata(setId: self.setId)!.keys {
                        // For efficiency, only check keys that are > 13 chars, which is the length of "royalty_addr_" key
                        if metadataKey.length >= 13 {
                            if metadataKey.slice(from: 0, upTo: 13) == "royalty_addr_" {
                                // A royalty has been found. Use the suffix from the key for the royalty name.
                                let royaltyName = metadataKey.slice(from: 13, upTo: metadataKey.length)
                                let royaltyAddress = miatech_NFT.convertStringToAddress(miatech_NFT.getSetMetadataByField(setId: self.setId, field: "royalty_addr_".concat(royaltyName))!)!
                                let royaltyReceiver: PublicPath = PublicPath(identifier: miatech_NFT.getSetMetadataByField(setId: self.setId, field: "royalty_rcv_".concat(royaltyName))!)!
                                let royaltyCut = miatech_NFT.getSetMetadataByField(setId: self.setId, field: "royalty_cut_".concat(royaltyName))!
                                let cutValue: UFix64 = miatech_NFT.royaltyCutStringToUFix64(royaltyCut)
                                if cutValue != 0.0 {
                                    royalties.append(MetadataViews.Royalty(
                                        receiver: getAccount(royaltyAddress).getCapability<&FungibleToken.Vault{FungibleToken.Receiver}>(royaltyReceiver),
                                        cut: cutValue,
                                        description: miatech_NFT.getSetMetadataByField(setId: self.setId, field: "royalty_desc_".concat(royaltyName))!
                                    )
                                    )
                                }
                            }
                        }
                    }
                    return MetadataViews.Royalties(cutInfos: royalties)
                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: miatech_NFT.CollectionStoragePath,
                        publicPath: miatech_NFT.CollectionPublicPath,
                        providerPath: /private/miatech_NFT,
                        publicCollection: Type<&miatech_NFT.Collection{miatech_NFT.miatech_NFTCollectionPublic,NonFungibleToken.CollectionPublic}>(),
                        publicLinkedType: Type<&miatech_NFT.Collection{miatech_NFT.miatech_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&miatech_NFT.Collection{miatech_NFT.miatech_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                            return <-miatech_NFT.createEmptyCollection()
                        })
                    )
                case Type<MetadataViews.NFTCollectionDisplay>():
                    let squareImage = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: "undefined/miatech/square.png"
                        ),
                        mediaType: "image/png"
                    )
                    let bannerImage = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: "undefined/miatech/banner.png"
                        ),
                        mediaType: "image/png"
                    )
                    var socials: {String: MetadataViews.ExternalURL} = {}
                    for metadataKey in miatech_NFT.getSetMetadata(setId: self.setId)!.keys {
                        // For efficiency, only check keys that are > 18 chars, which is the length of "collection_social_" key
                        if metadataKey.length >= 18 {
                            if metadataKey.slice(from: 0, upTo: 18) == "collection_social_" {
                                // A social URL has been found. Set the name to only the collection social key suffix.
                                socials.insert(key: metadataKey.slice(from: 18, upTo: metadataKey.length), MetadataViews.ExternalURL(miatech_NFT.getSetMetadataByField(setId: self.setId, field: metadataKey)!))
                            }
                        }
                    }
                    return MetadataViews.NFTCollectionDisplay(
                        name: miatech_NFT.getSetMetadataByField(setId: self.setId, field: "collection_name") ?? "",
                        description: miatech_NFT.getSetMetadataByField(setId: self.setId, field: "collection_description") ?? "",
                        externalURL: MetadataViews.ExternalURL(miatech_NFT.getSetMetadataByField(setId: self.setId, field: "external_url") ?? ""),
                        squareImage: squareImage,
                        bannerImage: bannerImage,
                        socials: socials
                    )
                case Type<MetadataViews.Traits>():
                    let traitDictionary: {String: AnyStruct} = {}
                    // There is only a legacy {String: String} dictionary to store trait information.
                    // There may be multiple traits defined per NFT. Pull trait information
                    // based on keys that have the "trait_" prefix in the dictionary.
                    for metadataKey in miatech_NFT.getSetMetadata(setId: self.setId)!.keys {
                        // For efficiency, only check keys that are > 6 chars, which is the length of "trait_" key
                        if metadataKey.length >= 6 {
                            if metadataKey.slice(from: 0, upTo: 6) == "trait_" {
                                // A trait has been found. Set the trait name to only the trait key suffix.
                                traitDictionary.insert(key: metadataKey.slice(from: 6, upTo: metadataKey.length), miatech_NFT.getSetMetadataByField(setId: self.setId, field: metadataKey)!)
                            }
                        }
                    }
                    return MetadataViews.dictToTraits(dict: traitDictionary, excludedNames: [])
                case Type<MetadataViews.Medias>():
                    return MetadataViews.Medias(
                        items: [
                            MetadataViews.Media(
                                file: MetadataViews.HTTPFile(
                                    url: miatech_NFT.getSetMetadataByField(setId: self.setId, field: "image")!
                                ),
                                mediaType: self.getMimeType()
                            )
                        ]
                    )
            }
            return nil
        }

        pub fun getMimeType(): String {
            var metadataFileType = miatech_NFT.getSetMetadataByField(setId: self.setId, field: "image_file_type")!.toLower()
            switch metadataFileType {
                case "mp4":
                    return "video/mp4"
                case "mov":
                    return "video/quicktime"
                case "webm":
                    return "video/webm"
                case "ogv":
                    return "video/ogg"
                case "png":
                    return "image/png"
                case "jpeg":
                    return "image/jpeg"
                case "jpg":
                    return "image/jpeg"
                case "gif":
                    return "image/gif"
                case "webp":
                    return "image/webp"
                case "svg":
                    return "image/svg+xml"
                case "glb":
                    return "model/gltf-binary"
                case "gltf":
                    return "model/gltf+json"
                case "obj":
                    return "model/obj"
                case "mtl":
                    return "model/mtl"
                case "mp3":
                    return "audio/mpeg"
                case "ogg":
                    return "audio/ogg"
                case "oga":
                    return "audio/ogg"
                case "wav":
                    return "audio/wav"
                case "html":
                    return "text/html"
            }
            return ""
        }

        // If the NFT is destroyed, emit an event
        destroy() {
            miatech_NFT.totalSupply = miatech_NFT.totalSupply - (1 as UInt64)
            emit NFTDestroyed(id: self.id)
        }
    }

    // Admin is a special authorization resource that
    // allows the owner to perform important NFT
    // functions
    //
    pub resource Admin {

        pub fun addSeries(seriesId: UInt32, metadata: {String: String}) {
            pre {
                miatech_NFT.series[seriesId] == nil:
                    "Cannot add Series: The Series already exists"
            }

            // Create the new Series
            var newSeries <- create Series(
                seriesId: seriesId,
                metadata: metadata
            )

            // Add the new Series resource to the Series dictionary in the contract
            miatech_NFT.series[seriesId] <-! newSeries
        }

        pub fun borrowSeries(seriesId: UInt32): &Series  {
            pre {
                miatech_NFT.series[seriesId] != nil:
                    "Cannot borrow Series: The Series does not exist"
            }

            // Get a reference to the Series and return it
            return (&miatech_NFT.series[seriesId] as &Series?)!
        }

        pub fun createNewAdmin(): @Admin {
            return <-create Admin()
        }

    }

    // This is the interface that users can cast their NFT Collection as
    // to allow others to deposit miatech_NFT into their Collection. It also allows for reading
    // the details of miatech_NFT in the Collection.
    pub resource interface miatech_NFTCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowmiatech_NFT(id: UInt64): &miatech_NFT.NFT? {
            // If the result isn't nil, the id of the returned reference
            // should be the same as the argument to the function
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow miatech_NFT reference: The ID of the returned reference is incorrect"
            }
        }
    }

    // Collection
    // A collection of miatech_NFT NFTs owned by an account
    //
    pub resource Collection: miatech_NFTCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with an UInt64 ID field
        //
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        // withdraw
        // Removes an NFT from the collection and moves it to the caller
        //
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        // batchWithdraw withdraws multiple NFTs and returns them as a Collection
        //
        // Parameters: ids: An array of IDs to withdraw
        //
        // Returns: @NonFungibleToken.Collection: The collection of withdrawn tokens
        //

        pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {
            // Create a new empty Collection
            var batchCollection <- create Collection()

            // Iterate through the ids and withdraw them from the Collection
            for id in ids {
                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))
            }

            // Return the withdrawn tokens
            return <-batchCollection
        }

        // deposit
        // Takes a NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        //
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @miatech_NFT.NFT

            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        // batchDeposit takes a Collection object as an argument
        // and deposits each contained NFT into this Collection
        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {

            // Get an array of the IDs to be deposited
            let keys = tokens.getIDs()

            // Iterate through the keys in the collection and deposit each one
            for key in keys {
                self.deposit(token: <-tokens.withdraw(withdrawID: key))
            }

            // Destroy the empty Collection
            destroy tokens
        }

        // getIDs
        // Returns an array of the IDs that are in the collection
        //
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT
        // Gets a reference to an NFT in the collection
        // so that the caller can read its metadata and call its methods
        //
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        // borrowmiatech_NFT
        // Gets a reference to an NFT in the collection as a miatech_NFT,
        // exposing all of its fields.
        // This is safe as there are no functions that can be called on the miatech_NFT.
        //
        pub fun borrowmiatech_NFT(id: UInt64): &miatech_NFT.NFT? {
            if (self.ownedNFTs[id] != nil) {
                let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT?
                return ref as! &miatech_NFT.NFT?
            } else {
                return nil
            }
        }

        // borrowViewResolver
        // Gets a reference to the MetadataViews resolver in the collection,
        // giving access to all metadata information made available.
        //
        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let miatech_NFTNft = nft as! &miatech_NFT.NFT
            return miatech_NFTNft as &AnyResource{MetadataViews.Resolver}
        }

        // destructor
        destroy() {
            destroy self.ownedNFTs
        }

        // initializer
        //
        init () {
            self.ownedNFTs <- {}
        }
    }

    // createEmptyCollection
    // public function that anyone can call to create a new empty collection
    //
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    // fetch
    // Get a reference to a miatech_NFT from an account's Collection, if available.
    // If an account does not have a miatech_NFT.Collection, panic.
    // If it has a collection but does not contain the Id, return nil.
    // If it has a collection and that collection contains the Id, return a reference to that.
    //
    pub fun fetch(_ from: Address, id: UInt64): &miatech_NFT.NFT? {
        let collection = getAccount(from)
            .getCapability(miatech_NFT.CollectionPublicPath)
            .borrow<&miatech_NFT.Collection{miatech_NFT.miatech_NFTCollectionPublic}>()
            ?? panic("Couldn't get collection")
        // We trust miatech_NFT.Collection.borrowmiatech_NFT to get the correct id
        // (it checks it before returning it).
        return collection.borrowmiatech_NFT(id: id)
    }

    // getAllSeries returns all the sets
    //
    // Returns: An array of all the series that have been created
    pub fun getAllSeries(): [miatech_NFT.SeriesData] {
        return miatech_NFT.seriesData.values
    }

    // getAllSets returns all the sets
    //
    // Returns: An array of all the sets that have been created
    pub fun getAllSets(): [miatech_NFT.NFTSetData] {
        return miatech_NFT.setData.values
    }

    // getSeriesMetadata returns the metadata that the specified Series
    //            is associated with.
    //
    // Parameters: seriesId: The id of the Series that is being searched
    //
    // Returns: The metadata as a String to String mapping optional
    pub fun getSeriesMetadata(seriesId: UInt32): {String: String}? {
        return miatech_NFT.seriesData[seriesId]?.getMetadata()
    }

    // getSetMaxEditions returns the the maximum number of NFT editions that can
    //        be minted in this Set.
    //
    // Parameters: setId: The id of the Set that is being searched
    //
    // Returns: The max number of NFT editions in this Set
    pub fun getSetMaxEditions(setId: UInt32): UInt32? {
        return miatech_NFT.setData[setId]?.maxEditions
    }

    // getSetMetadata returns all the metadata associated with a specific Set
    //
    // Parameters: setId: The id of the Set that is being searched
    //
    // Returns: The metadata as a String to String mapping optional
    pub fun getSetMetadata(setId: UInt32): {String: String}? {
        return miatech_NFT.setData[setId]?.getMetadata()
    }

    // getSetSeriesId returns the Series Id the Set belongs to
    //
    // Parameters: setId: The id of the Set that is being searched
    //
    // Returns: The Series Id
    pub fun getSetSeriesId(setId: UInt32): UInt32? {
        return miatech_NFT.setData[setId]?.seriesId
    }

    // getSetMetadata returns all the ipfs hashes for each nft
    //     edition in the Set.
    //
    // Parameters: setId: The id of the Set that is being searched
    //
    // Returns: The ipfs hashes of nft editions as a Array of Strings
    pub fun getIpfsMetadataHashByNftEdition(setId: UInt32, editionNum: UInt32): String? {
        // Don't force a revert if the setId or field is invalid
        if let set = miatech_NFT.setData[setId] {
            return set.getIpfsMetadataHash(editionNum: editionNum)
        } else {
            return nil
        }
    }

    // getSetMetadataByField returns the metadata associated with a
    //                        specific field of the metadata
    //
    // Parameters: setId: The id of the Set that is being searched
    //             field: The field to search for
    //
    // Returns: The metadata field as a String Optional
    pub fun getSetMetadataByField(setId: UInt32, field: String): String? {
        // Don't force a revert if the setId or field is invalid
        if let set = miatech_NFT.setData[setId] {
            return set.getMetadataField(field: field)
        } else {
            return nil
        }
    }

    // stringToAddress Converts a string to a Flow address
    //
    // Parameters: input: The address as a String
    //
    // Returns: The flow address as an Address Optional
	pub fun convertStringToAddress(_ input: String): Address? {
		var address=input
		if input.utf8[1] == 120 {
			address = input.slice(from: 2, upTo: input.length)
		}
		var r:UInt64 = 0
		var bytes = address.decodeHex()

		while bytes.length>0{
			r = r  + (UInt64(bytes.removeFirst()) << UInt64(bytes.length * 8 ))
		}

		return Address(r)
	}

    // royaltyCutStringToUFix64 Converts a royalty cut string
    //        to a UFix64
    //
    // Parameters: royaltyCut: The cut value 0.0 - 1.0 as a String
    //
    // Returns: The royalty cut as a UFix64
    pub fun royaltyCutStringToUFix64(_ royaltyCut: String): UFix64 {
        var decimalPos = 0
        if royaltyCut[0] == "." {
            decimalPos = 1
        } else if royaltyCut[1] == "." {
            if royaltyCut[0] == "1" {
                // "1" in the first postiion must be 1.0 i.e. 100% cut
                return 1.0
            } else if royaltyCut[0] == "0" {
                decimalPos = 2
            }
        } else {
            // Invalid royalty value
            return 0.0
        }

        var royaltyCutStrLen = royaltyCut.length
        if royaltyCut.length > (8 + decimalPos) {
            // UFix64 is capped at 8 digits after the decimal
            // so truncate excess decimal values from the string
            royaltyCutStrLen = (8 + decimalPos)
        }
        let royaltyCutPercentValue = royaltyCut.slice(from: decimalPos, upTo: royaltyCutStrLen)
        var bytes = royaltyCutPercentValue.utf8
        var i = 0
        var cutValueInteger: UInt64 = 0
        var cutValueDivisor: UFix64 = 1.0
        let zeroAsciiIntValue: UInt64 = 48
        // First convert the string to a non-decimal Integer
        while i < bytes.length {
            cutValueInteger = (cutValueInteger * 10) + UInt64(bytes[i]) - zeroAsciiIntValue
            cutValueDivisor = cutValueDivisor * 10.0
            i = i + 1
        }

        // Convert the resulting Integer to a decimal in the range 0.0 - 0.99999999
        return (UFix64(cutValueInteger) / cutValueDivisor)
    }

    // initializer
    //
	init() {
        // Set named paths
        self.CollectionStoragePath = /storage/miatech_NFTCollection
        self.CollectionPublicPath = /public/miatech_NFTCollection
        self.AdminStoragePath = /storage/miatech_NFTAdmin
        self.AdminPrivatePath = /private/miatech_NFTAdminUpgrade

        // Initialize the total supply
        self.totalSupply = 0

        self.setData = {}
        self.seriesData = {}
        self.series <- {}

        // Put Admin in storage
        self.account.save(<-create Admin(), to: self.AdminStoragePath)

        self.account.link<&miatech_NFT.Admin>(
            self.AdminPrivatePath,
            target: self.AdminStoragePath
        ) ?? panic("Could not get a capability to the admin")

        emit ContractInitialized()
	}
}
"
-------
"pub contract stakeTest{
  pub var stakers: [Address]
  pub fun append(_ x: Address){
    self.stakers.append(x)
  }
  init(){
    self.stakers =[]
  }


}













"
-------
"//import FungibleToken from 0xf233dcee88fe0abe
//import NonFungibleToken from 0x1d7e57aa55817448
//import FlowToken from 0x1654653399040a61
//import FlovatarComponentTemplate from 0x921ea449dffec68a
//import FlovatarComponent from 0x921ea449dffec68a
//import FlovatarPack from 0x921ea449dffec68a
//import FlovatarDustToken from 0x921ea449dffec68a
//import Flovatar from 0x921ea449dffec68a
import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import FlowToken from 0x1654653399040a61
import FlovatarComponentTemplate from 0x921ea449dffec68a
import FlovatarComponent from 0x921ea449dffec68a
import FlovatarPack from 0x921ea449dffec68a
import FlovatarDustToken from 0x921ea449dffec68a
import FlovatarInbox from 0x921ea449dffec68a
import Flovatar from 0x921ea449dffec68a

/*

 This contract provides the ability for users to upgrade their Flobits

 */

pub contract FlovatarComponentUpgrader {

    // The withdrawEnabled will allow to put all withdraws on hold while the distribution of new airdrops is happening
    // So that everyone will be then be able to access his rewards at the same time
    access(account) var upgradeEnabled: Bool


    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath

    // Event to notify about the Inbox creation
    pub event ContractInitialized()

    // Events to notify when Dust or Components are deposited or withdrawn
    pub event FlovatarComponentUpgraded(newId: UInt64, rarity: String, category: String, burnedIds: [UInt64])


    //Randomize code gently provided by @bluesign
    pub struct RandomInt{
        priv var value : UInt64?
        priv let maxValue: UInt64
        priv let minValue: UInt64
        priv let field: String
        priv let uuid: UInt64

        pub init(uuid: UInt64, field: String, minValue: UInt64, maxValue: UInt64){
                self.uuid = uuid
                self.field = field
                self.minValue = minValue
                self.maxValue = maxValue
                self.value = nil
        }

        pub fun getValue() : UInt64{
                if let value = self.value {
                    return value
                }
                let h: [UInt8] = HashAlgorithm.SHA3_256.hash(self.uuid.toBigEndianBytes())
                let f: [UInt8] = HashAlgorithm.SHA3_256.hash(self.field.utf8)

                var id =  getBlock(at: getCurrentBlock().height)!.id
                var random:UInt64 = 0
                var i = 0
                while i<8{
                    random = random + (UInt64(id[i]) ^ UInt64(h[i]) ^ UInt64(f[i]))
                    random = random << 8
                    i=i+1
                }
                self.value = self.minValue + random % (self.maxValue - self.minValue)
                return self.minValue + random % (self.maxValue - self.minValue)
        }
    }

    pub resource interface CollectionPublic {
        pub fun depositComponent(component: @FlovatarComponent.NFT)
    }



    // The main Collection that manages the Containers
    pub resource Collection: CollectionPublic {

        access(contract) let flovatarComponents: @{UInt64: FlovatarComponent.NFT}
        access(contract) let rarityLookup: {UInt32: {String: {String: {UInt64: UInt64}}}}


        init () {
            self.flovatarComponents <- {}
            self.rarityLookup = {}
        }

        pub fun depositComponent(component: @FlovatarComponent.NFT) {
            if(!self.rarityLookup.containsKey(component.getSeries())){
                self.rarityLookup.insert(key: component.getSeries(), {} as {String: {String: {UInt64: UInt64}}})
            }
            if(!self.rarityLookup[component.getSeries()]!.containsKey(component.getRarity())){
                self.rarityLookup[component.getSeries()]!.insert(key: component.getRarity(), {} as {String: {UInt64: UInt64}})
                self.rarityLookup[component.getSeries()]![component.getRarity()]!.insert(key: "all", {} as {UInt64: UInt64})
            }
            if(!self.rarityLookup[component.getSeries()]![component.getRarity()]!.containsKey(component.getCategory())){
                self.rarityLookup[component.getSeries()]![component.getRarity()]!.insert(key: component.getCategory(), {} as {UInt64: UInt64})
            }
            self.rarityLookup[component.getSeries()]![component.getRarity()]!["all"]!.insert(key: component.id, component.id)
            self.rarityLookup[component.getSeries()]![component.getRarity()]![component.getCategory()]!.insert(key: component.id, component.id)

            let oldComponent <- self.flovatarComponents[component.id] <- component
            destroy oldComponent
        }

        pub fun withdrawComponent(id: UInt64) : @FlovatarComponent.NFT {
            let component <- self.flovatarComponents.remove(key: id) ?? panic("missing NFT")

            self.rarityLookup[component.getSeries()]![component.getRarity()]!["all"]!.remove(key: component.id)
            self.rarityLookup[component.getSeries()]![component.getRarity()]![component.getCategory()]!.remove(key: component.id)

            return <- component
        }
        pub fun withdrawRandomComponent(series: UInt32, rarity: String, category: String?) : @FlovatarComponent.NFT {
            //FILTER BY SERIES AND RARITY AND THEN RANDOMIZE AND PICK ONE
            var components: [UInt64] = []
            if(self.rarityLookup[series] == nil){
                panic("No Components found for the provided Series")
            }
            if(self.rarityLookup[series]![rarity] == nil){
                panic("No Components found for the provided Rarity")
            }
            if(category != nil){
                if(self.rarityLookup[series]![rarity]![category!] == nil){
                    //panic("No Components found for the provided Category")
                    components = self.rarityLookup[series]![rarity]!["all"]!.keys
                } else {
                    components = self.rarityLookup[series]![rarity]![category!]!.keys
                }
            } else {
                components = self.rarityLookup[series]![rarity]!["all"]!.keys
            }

            if(components.length < 1){
                panic("No Components found!")
            }

            let randInt: UInt64 = unsafeRandom()
            var fieldString: String = series.toString().concat(rarity)
            if(category != nil){
                fieldString = fieldString.concat(category!)
            }

            if (components.length == Int(1)) {
                let component <- self.withdrawComponent(id: components[UInt64(0)])
                return <- component
            }

            let randomPos: RandomInt = RandomInt(uuid: unsafeRandom(), field: fieldString, minValue: UInt64(0), maxValue: UInt64(components.length - Int(1)))

            let component <- self.withdrawComponent(id: components[randomPos.getValue()])
            return <- component
        }

        pub fun getComponentIDs(): [UInt64] {
            return self.flovatarComponents.keys
        }

        destroy() {
            destroy self.flovatarComponents
        }
    }



    // This function can only be called by the account owner to create an empty Collection
    access(account) fun createEmptyCollection(): @FlovatarComponentUpgrader.Collection {
        return <- create Collection()
    }



    // This function withdraws all the Components assigned to a Flovatar and sends them to the Owner's address
    pub fun upgradeFlovatarComponent(components: @[FlovatarComponent.NFT], vault: @FungibleToken.Vault, address: Address) {
        pre {
        	self.upgradeEnabled : "Upgrade is not enabled!"
            vault.balance == 20.0 : "The amount of $DUST is not correct"
            vault.isInstance(Type<@FlovatarDustToken.Vault>()) : "Vault not of the right Token Type"
            components.length == 10 : "You need to provide exactly 10 Flobits for the upgrade"
        }
        if let upgraderCollection = self.account.borrow<&FlovatarComponentUpgrader.Collection>(from: self.CollectionStoragePath) {

            var componentSeries: UInt32 = 0
            var checkCategory: Bool = true
            var componentCategory: String? = nil
            var componentRarity: String = ""
            var outputRarity: String = ""

            var i: UInt32 = 0

            while (i < UInt32(components.length)) {

                let template = FlovatarComponentTemplate.getComponentTemplate(id: components[i].templateId)!

                if(i == UInt32(0)){
                    componentSeries = template.series
                    componentCategory = template.category
                    componentRarity = template.rarity
                }

                if(componentSeries != template.series){
                    panic("All the Flovatar Components need to be belong to the same Series")
                }
                if(componentRarity != template.rarity){
                    panic("All the Flovatar Components need to be belong to the same Rarity Level")
                }
                if(componentCategory != template.category){
                    checkCategory = false
                }

                i = i + UInt32(1)
            }

            if(componentRarity == "common"){
                outputRarity = "rare"
            } else if(componentRarity == "rare"){
                outputRarity = "epic"
            } else if(componentRarity == "epic"){
                outputRarity = "legendary"
            } else {
                panic("Rarity needs to be Common, Rare or Epic")
            }

            if(!checkCategory){
                componentCategory = nil
            }

            let component <- upgraderCollection.withdrawRandomComponent(series: componentSeries, rarity: outputRarity, category: componentCategory)

            destroy components
            destroy vault

            if let inboxCollection = self.account.borrow<&FlovatarInbox.Collection>(from: FlovatarInbox.CollectionStoragePath) {
                inboxCollection.depositComponentToWallet(address: address, component: <- component)
            } else {
                panic("Couldn't borrow Flovatar Inbox Collection")
            }

        } else {
            panic("Can't borrow the Upgrader Collection")
        }

    }

    // Admin function to temporarly enable or disable the airdrop and reward withdraw so that
    // we can distribute them to everyone at the same time
    access(account) fun setUpgradeEnable(enabled: Bool) {
        self.upgradeEnabled = enabled
    }

	init() {
	    self.upgradeEnabled = true

        self.CollectionPublicPath=/public/FlovatarComponentUpgraderCollection
        self.CollectionStoragePath=/storage/FlovatarComponentUpgraderCollection

        self.account.save<@FlovatarComponentUpgrader.Collection>(<- FlovatarComponentUpgrader.createEmptyCollection(), to: FlovatarComponentUpgrader.CollectionStoragePath)
        self.account.link<&{FlovatarComponentUpgrader.CollectionPublic}>(FlovatarComponentUpgrader.CollectionPublicPath, target: FlovatarComponentUpgrader.CollectionStoragePath)

        emit ContractInitialized()
	}
}
"
-------
"//import FungibleToken from 0xf233dcee88fe0abe
//import NonFungibleToken from 0x1d7e57aa55817448
//import FlowToken from 0x1654653399040a61
//import Flovatar from 0x921ea449dffec68a
//import FlovatarComponent from 0x921ea449dffec68a
import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import FlowToken from 0x1654653399040a61
import Flovatar from 0x921ea449dffec68a
import FlovatarComponent from 0x921ea449dffec68a

/*
 A standard marketplace contract with Royalties management and hardcoded against Flovatar and Components.

 This contract is based on the Versus Auction contract created by Bjartek and Alchemist
 https://github.com/versus-flow/auction-flow-contract

*/

pub contract FlovatarMarketplace {

    pub let CollectionPublicPath: PublicPath
    pub let CollectionStoragePath: StoragePath

    // The Vault of the Marketplace where it will receive the cuts on each sale
    pub let marketplaceWallet: Capability<&FlowToken.Vault{FungibleToken.Receiver}>

    // Event that is emitted when a new NFT is put up for sale
    pub event FlovatarForSale(id: UInt64, price: UFix64, address: Address)
    pub event FlovatarComponentForSale(id: UInt64, price: UFix64, address: Address, mint: UInt64)

    // Event that is emitted when the price of an NFT changes
    pub event FlovatarPriceChanged(id: UInt64, newPrice: UFix64, address: Address)
    pub event FlovatarComponentPriceChanged(id: UInt64, newPrice: UFix64, address: Address)

    // Event that is emitted when a token is purchased
    pub event FlovatarPurchased(id: UInt64, price: UFix64, from: Address, to: Address)
    pub event FlovatarComponentPurchased(id: UInt64, price: UFix64, from: Address, to: Address)

    // Event that is emitted when a royalty has been paid
    pub event RoyaltyPaid(id: UInt64, amount: UFix64, to: Address, name: String)

    // Event that is emitted when a seller withdraws their NFT from the sale
    pub event FlovatarSaleWithdrawn(tokenId: UInt64, address: Address)
    pub event FlovatarComponentSaleWithdrawn(tokenId: UInt64, address: Address)

    // Interface that users will publish for their Sale collection
    // that only exposes the methods that are supposed to be public
    pub resource interface SalePublic {
        pub fun purchaseFlovatar(tokenId: UInt64, recipientCap: Capability<&{Flovatar.CollectionPublic}>, buyTokens: @FungibleToken.Vault)
        pub fun purchaseFlovatarComponent(tokenId: UInt64, recipientCap: Capability<&{FlovatarComponent.CollectionPublic}>, buyTokens: @FungibleToken.Vault)
        pub fun getFlovatarPrice(tokenId: UInt64): UFix64?
        pub fun getFlovatarComponentPrice(tokenId: UInt64): UFix64?
        pub fun getFlovatarIDs(): [UInt64]
        pub fun getFlovatarComponentIDs(): [UInt64]
        pub fun getFlovatar(tokenId: UInt64): &{Flovatar.Public}?
        pub fun getFlovatarComponent(tokenId: UInt64): &{FlovatarComponent.Public}?
    }

    // NFT Collection object that allows a user to put their NFT up for sale
    // where others can send fungible tokens to purchase it
    pub resource SaleCollection: SalePublic {

        // Dictionary of the NFTs that the user is putting up for sale
        access(contract) let flovatarForSale: @{UInt64: Flovatar.NFT}
        access(contract) let flovatarComponentForSale: @{UInt64: FlovatarComponent.NFT}

        // Dictionary of the prices for each NFT by ID
        access(contract) let flovatarPrices: {UInt64: UFix64}
        access(contract) let flovatarComponentPrices: {UInt64: UFix64}

        // The fungible token vault of the owner of this sale.
        // When someone buys a token, this resource can deposit
        // tokens into their account.
        access(account) let ownerVault: Capability<&AnyResource{FungibleToken.Receiver}>

        init (vault: Capability<&AnyResource{FungibleToken.Receiver}>) {
            self.flovatarForSale <- {}
            self.flovatarComponentForSale <- {}
            self.ownerVault = vault
            self.flovatarPrices = {}
            self.flovatarComponentPrices = {}
        }

        // Gives the owner the opportunity to remove a Flovatar sale from the collection
        pub fun withdrawFlovatar(tokenId: UInt64): @Flovatar.NFT {
            // remove the price
            self.flovatarPrices.remove(key: tokenId)
            // remove and return the token
            let token <- self.flovatarForSale.remove(key: tokenId) ?? panic("missing NFT")

            let vaultRef = self.ownerVault.borrow()
                ?? panic("Could not borrow reference to owner token vault")
            emit FlovatarSaleWithdrawn(tokenId: tokenId, address: vaultRef.owner!.address)
            return <-token
        }

        // Gives the owner the opportunity to remove a Component sale from the collection
        pub fun withdrawFlovatarComponent(tokenId: UInt64): @FlovatarComponent.NFT {
            // remove the price
            self.flovatarComponentPrices.remove(key: tokenId)
            // remove and return the token
            let token <- self.flovatarComponentForSale.remove(key: tokenId) ?? panic("missing NFT")

            let vaultRef = self.ownerVault.borrow()
                ?? panic("Could not borrow reference to owner token vault")
            emit FlovatarComponentSaleWithdrawn(tokenId: tokenId, address: vaultRef.owner!.address)
            return <-token
        }

        // Lists a Flovatar NFT for sale in this collection
        pub fun listFlovatarForSale(token: @Flovatar.NFT, price: UFix64) {
            let id = token.id

            // store the price in the price array
            self.flovatarPrices[id] = price

            // put the NFT into the the forSale dictionary
            let oldToken <- self.flovatarForSale[id] <- token
            destroy oldToken

            let vaultRef = self.ownerVault.borrow()
                ?? panic("Could not borrow reference to owner token vault")
            emit FlovatarForSale(id: id, price: price, address: vaultRef.owner!.address)
        }

        // Lists a Component NFT for sale in this collection
        pub fun listFlovatarComponentForSale(token: @FlovatarComponent.NFT, price: UFix64) {
            let id = token.id
            let mint = token.mint

            // store the price in the price array
            self.flovatarComponentPrices[id] = price

            // put the NFT into the the forSale dictionary
            let oldToken <- self.flovatarComponentForSale[id] <- token
            destroy oldToken

            let vaultRef = self.ownerVault.borrow()
                ?? panic("Could not borrow reference to owner token vault")
            emit FlovatarComponentForSale(id: id, price: price, address: vaultRef.owner!.address, mint: mint)
        }

        // Changes the price of a Flovatar that is currently for sale
        pub fun changeFlovatarPrice(tokenId: UInt64, newPrice: UFix64) {
            self.flovatarPrices[tokenId] = newPrice

            let vaultRef = self.ownerVault.borrow()
                ?? panic("Could not borrow reference to owner token vault")
            emit FlovatarPriceChanged(id: tokenId, newPrice: newPrice, address: vaultRef.owner!.address)
        }
        // Changes the price of a Component that is currently for sale
        pub fun changeFlovatarComponentPrice(tokenId: UInt64, newPrice: UFix64) {
            self.flovatarComponentPrices[tokenId] = newPrice

            let vaultRef = self.ownerVault.borrow()
                ?? panic("Could not borrow reference to owner token vault")
            emit FlovatarComponentPriceChanged(id: tokenId, newPrice: newPrice, address: vaultRef.owner!.address)
        }

        // Lets a user send tokens to purchase a Flovatar that is for sale
        pub fun purchaseFlovatar(tokenId: UInt64, recipientCap: Capability<&{Flovatar.CollectionPublic}>, buyTokens: @FungibleToken.Vault) {
            pre {
                self.flovatarForSale[tokenId] != nil && self.flovatarPrices[tokenId] != nil:
                    "No token matching this ID for sale!"
                buyTokens.balance >= (self.flovatarPrices[tokenId] ?? 0.0):
                    "Not enough tokens to buy the NFT!"
            }

            let recipient = recipientCap.borrow()!

            // get the value out of the optional
            let price = self.flovatarPrices[tokenId]!

            self.flovatarPrices[tokenId] = nil

            let vaultRef = self.ownerVault.borrow() ?? panic("Could not borrow reference to owner token vault")

            let token <-self.withdrawFlovatar(tokenId: tokenId)

            if(!token.isInstance(Type<@Flovatar.NFT>())) {
                panic("The NFT is not from the correct Type")
            }

            let creatorAccount = getAccount(token.getMetadata().creatorAddress)
            let creatorWallet = creatorAccount.getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver).borrow()!
            let creatorAmount = price * Flovatar.getRoyaltyCut()
            let tempCreatorWallet <- buyTokens.withdraw(amount: creatorAmount)
            creatorWallet.deposit(from: <-tempCreatorWallet)


            let marketplaceWallet = FlovatarMarketplace.marketplaceWallet.borrow()!
            let marketplaceAmount = price * Flovatar.getMarketplaceCut()
            let tempMarketplaceWallet <- buyTokens.withdraw(amount: marketplaceAmount)
            marketplaceWallet.deposit(from: <-tempMarketplaceWallet)

            // deposit the purchasing tokens into the owners vault
            vaultRef.deposit(from: <-buyTokens)

            // deposit the NFT into the buyers collection
            recipient.deposit(token: <- token)

            emit FlovatarPurchased(id: tokenId, price: price, from: vaultRef.owner!.address, to: recipient.owner!.address)
        }

        // Lets a user send tokens to purchase a Component that is for sale
        pub fun purchaseFlovatarComponent(tokenId: UInt64, recipientCap: Capability<&{FlovatarComponent.CollectionPublic}>, buyTokens: @FungibleToken.Vault) {
            pre {
                self.flovatarComponentForSale[tokenId] != nil && self.flovatarComponentPrices[tokenId] != nil:
                    "No token matching this ID for sale!"
                buyTokens.balance >= (self.flovatarComponentPrices[tokenId] ?? 0.0):
                    "Not enough tokens to buy the NFT!"
            }

            let recipient = recipientCap.borrow()!

            // get the value out of the optional
            let price = self.flovatarComponentPrices[tokenId]!

            self.flovatarComponentPrices[tokenId] = nil

            let vaultRef = self.ownerVault.borrow() ?? panic("Could not borrow reference to owner token vault")

            let token <-self.withdrawFlovatarComponent(tokenId: tokenId)

            if(!token.isInstance(Type<@FlovatarComponent.NFT>())) {
                panic("The NFT is not from the correct Type")
            }


            let marketplaceWallet = FlovatarMarketplace.marketplaceWallet.borrow()!
            let marketplaceAmount = price * Flovatar.getMarketplaceCut()
            let tempMarketplaceWallet <- buyTokens.withdraw(amount: marketplaceAmount)
            marketplaceWallet.deposit(from: <-tempMarketplaceWallet)

            // deposit the purchasing tokens into the owners vault
            vaultRef.deposit(from: <-buyTokens)

            // deposit the NFT into the buyers collection
            recipient.deposit(token: <- token)

            emit FlovatarComponentPurchased(id: tokenId, price: price, from: vaultRef.owner!.address, to: recipient.owner!.address)
        }

        // Returns the price of a specific Flovatar in the sale
        pub fun getFlovatarPrice(tokenId: UInt64): UFix64? {
            return self.flovatarPrices[tokenId]
        }
        // Returns the price of a specific Component in the sale
        pub fun getFlovatarComponentPrice(tokenId: UInt64): UFix64? {
            return self.flovatarComponentPrices[tokenId]
        }

        // Returns an array of Flovatar IDs that are for sale
        pub fun getFlovatarIDs(): [UInt64] {
            return self.flovatarForSale.keys
        }
        // Returns an array of Component IDs that are for sale
        pub fun getFlovatarComponentIDs(): [UInt64] {
            return self.flovatarComponentForSale.keys
        }

        // Returns a borrowed reference to a Flovatar Sale
        // so that the caller can read data and call methods from it.
        pub fun getFlovatar(tokenId: UInt64): &{Flovatar.Public}? {
            if self.flovatarForSale[tokenId] != nil {
                let ref = (&self.flovatarForSale[tokenId] as auth &NonFungibleToken.NFT?)!
                return ref as! &Flovatar.NFT
            } else {
                return nil
            }
        }
        // Returns a borrowed reference to a Component Sale
        // so that the caller can read data and call methods from it.
        pub fun getFlovatarComponent(tokenId: UInt64): &{FlovatarComponent.Public}? {
            if self.flovatarComponentForSale[tokenId] != nil {
                let ref = (&self.flovatarComponentForSale[tokenId] as auth &NonFungibleToken.NFT?)!
                return ref as! &FlovatarComponent.NFT
            } else {
                return nil
            }
        }

        destroy() {
            destroy self.flovatarForSale
            destroy self.flovatarComponentForSale
        }
    }


    // This struct is used to send a data representation of the Flovatar Sales
    // when retrieved using the contract helper methods outside the collection.
    pub struct FlovatarSaleData {
        pub let id: UInt64
        pub let price: UFix64
        pub let metadata: Flovatar.Metadata
        pub let accessoryId: UInt64?
        pub let hatId: UInt64?
        pub let eyeglassesId: UInt64?
        pub let backgroundId: UInt64?

        init(
            id: UInt64,
            price: UFix64,
            metadata: Flovatar.Metadata,
            accessoryId: UInt64?,
            hatId: UInt64?,
            eyeglassesId: UInt64?,
            backgroundId: UInt64?
            ){

            self.id = id
            self.price = price
            self.metadata = metadata
            self.accessoryId = accessoryId
            self.hatId = hatId
            self.eyeglassesId = eyeglassesId
            self.backgroundId = backgroundId
        }
    }

    // This struct is used to send a data representation of the Component Sales
    // when retrieved using the contract helper methods outside the collection.
    pub struct FlovatarComponentSaleData {
        pub let id: UInt64
        pub let price: UFix64
        pub let metadata: FlovatarComponent.ComponentData

        init(
            id: UInt64,
            price: UFix64,
            metadata: FlovatarComponent.ComponentData){

            self.id = id
            self.price = price
            self.metadata = metadata
        }
    }

    // Get all the Flovatar Sale offers for a specific account
    pub fun getFlovatarSales(address: Address) : [FlovatarSaleData] {
        var saleData: [FlovatarSaleData] = []
        let account = getAccount(address)

        if let saleCollection = account.getCapability(self.CollectionPublicPath).borrow<&{FlovatarMarketplace.SalePublic}>()  {
            if(!saleCollection.isInstance(Type<@FlovatarMarketplace.SaleCollection>())) {
                panic("The Collection is not from the correct Type")
            }
            for id in saleCollection.getFlovatarIDs() {
                let price = saleCollection.getFlovatarPrice(tokenId: id)
                let flovatar = saleCollection.getFlovatar(tokenId: id)

                saleData.append(FlovatarSaleData(
                    id: id,
                    price: price!,
                    metadata: flovatar!.getMetadata(),
                    accessoryId: flovatar!.getAccessory(),
                    hatId: flovatar!.getHat(),
                    eyeglassesId: flovatar!.getEyeglasses(),
                    backgroundId: flovatar!.getBackground()
                    ))
            }
        }
        return saleData
    }

    // Get all the Component Sale offers for a specific account
    pub fun getFlovatarComponentSales(address: Address) : [FlovatarComponentSaleData] {
        var saleData: [FlovatarComponentSaleData] = []
        let account = getAccount(address)

        if let saleCollection = account.getCapability(self.CollectionPublicPath).borrow<&{FlovatarMarketplace.SalePublic}>()  {
            if(!saleCollection.isInstance(Type<@FlovatarMarketplace.SaleCollection>())) {
                panic("The Collection is not from the correct Type")
            }
            for id in saleCollection.getFlovatarComponentIDs() {
                let price = saleCollection.getFlovatarComponentPrice(tokenId: id)
                let flovatarComponent = saleCollection.getFlovatarComponent(tokenId: id)

                saleData.append(FlovatarComponentSaleData(
                    id: id,
                    price: price!,
                    metadata: FlovatarComponent.ComponentData(
                        id: id,
                        templateId: flovatarComponent!.templateId,
                        mint: flovatarComponent!.mint
                        )
                    ))
            }
        }
        return saleData
    }

    // Get a specific Flovatar Sale offers for an account
    pub fun getFlovatarSale(address: Address, id: UInt64) : FlovatarSaleData? {
        let account = getAccount(address)

        if let saleCollection = account.getCapability(self.CollectionPublicPath).borrow<&{FlovatarMarketplace.SalePublic}>()  {
            if(!saleCollection.isInstance(Type<@FlovatarMarketplace.SaleCollection>())) {
                panic("The Collection is not from the correct Type")
            }
            if let flovatar = saleCollection.getFlovatar(tokenId: id) {
                let price = saleCollection.getFlovatarPrice(tokenId: id)
                return FlovatarSaleData(
                           id: id,
                            price: price!,
                            metadata: flovatar.getMetadata(),
                            accessoryId: flovatar.getAccessory(),
                            hatId: flovatar.getHat(),
                            eyeglassesId: flovatar.getEyeglasses(),
                            backgroundId: flovatar!.getBackground()
                           )
            }
        }
        return nil
    }

    // Get a specific Component Sale offers for an account
    pub fun getFlovatarComponentSale(address: Address, id: UInt64) : FlovatarComponentSaleData? {

        let account = getAccount(address)

        if let saleCollection = account.getCapability(self.CollectionPublicPath).borrow<&{FlovatarMarketplace.SalePublic}>()  {
            if(!saleCollection.isInstance(Type<@FlovatarMarketplace.SaleCollection>())) {
                panic("The Collection is not from the correct Type")
            }
            if let flovatarComponent = saleCollection.getFlovatarComponent(tokenId: id) {
                let price = saleCollection.getFlovatarComponentPrice(tokenId: id)
                return FlovatarComponentSaleData(
                           id: id,
                            price: price!,
                            metadata: FlovatarComponent.ComponentData(
                                id: id,
                                templateId: flovatarComponent!.templateId,
                                mint: flovatarComponent!.mint
                                )
                           )
            }
        }
        return nil
    }



    // Returns a new collection resource to the caller
    pub fun createSaleCollection(ownerVault: Capability<&{FungibleToken.Receiver}>): @SaleCollection {
        return <- create SaleCollection(vault: ownerVault)
    }

    pub init() {
        self.CollectionPublicPath= /public/FlovatarMarketplace
        self.CollectionStoragePath= /storage/FlovatarMarketplace


        self.marketplaceWallet = self.account.getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver)

    }
}
"
-------
"// Description: Smart Contract for MLS Virtual Commemorative Tickets
// SPDX-License-Identifier: UNLICENSED


import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract MLS : NonFungibleToken{
    pub var totalSupply: UInt64

    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath

    pub resource NFT : NonFungibleToken.INFT, MetadataViews.Resolver {
        pub let id: UInt64
        pub var link: String
        pub var batch: UInt32
        pub var sequence: UInt16
        pub var limit: UInt16

        init(
            initID: UInt64,
            initlink: String,
            initbatch: UInt32,
            initsequence: UInt16,
            initlimit: UInt16
        ) {
            self.id = initID
            self.link = initlink
            self.batch = initbatch
            self.sequence=initsequence
            self.limit=initlimit
        }

        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.NFTCollectionData>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: MLS.CollectionStoragePath,
                        publicPath: MLS.CollectionPublicPath,
                        providerPath: /private/MLSCollection,
                        publicCollection: Type<&MLS.Collection{MLS.MLSCollectionPublic}>(),
                        publicLinkedType: Type<&MLS.Collection{MLS.MLSCollectionPublic,NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&MLS.Collection{MLS.MLSCollectionPublic,NonFungibleToken.CollectionPublic, NonFungibleToken.Provider, MetadataViews.ResolverCollection}>(),
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                            return <-MLS.createEmptyCollection()
                        })
                    )

            }
            return nil
        }
    }

    pub resource interface MLSCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowMLS(id: UInt64): &MLS.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow MLS reference: The ID of the returned reference is incorrect"
            }
        }
    }

    pub resource Collection: MLSCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID)!

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }


        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @MLS.NFT
            let id: UInt64 = token.id
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let mlsNFT = nft as! &MLS.NFT
            return mlsNFT as &AnyResource{MetadataViews.Resolver}
        }

        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        destroy() {
            destroy self.ownedNFTs
        }

        pub fun borrowMLS(id: UInt64): &MLS.NFT? {
            if self.ownedNFTs[id] == nil {
                return nil
            }
            else {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!

                return ref as! &MLS.NFT
            }
        }
    }

    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    pub resource NFTMinter {
        pub var minterID: UInt64

        init() {
            self.minterID = 0
        }

        pub fun mintNFT(
            glink: String,
            gbatch: UInt32,
            glimit: UInt16,
            gsequence: UInt16
        ): @NFT {
            let tokenID = (UInt64(gbatch) << 32) | (UInt64(glimit) << 16) | UInt64(gsequence)
            var newNFT <- create NFT(initID: tokenID, initlink: glink, initbatch: gbatch, initsequence: gsequence, initlimit: glimit)

            self.minterID= tokenID
            MLS.totalSupply = MLS.totalSupply + UInt64(1)
            return <-newNFT
        }
    }

	init() {
        self.CollectionStoragePath = /storage/MLSCollection
        self.CollectionPublicPath = /public/MLSCollection
        self.MinterStoragePath = /storage/MLSMinter

        self.totalSupply = 0
        self.account.save(<-self.createEmptyCollection(), to: self.CollectionStoragePath)

        self.account.link<&{MLS.MLSCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(
            self.CollectionPublicPath,
            target: self.CollectionStoragePath
        )
        self.account.save(<-create NFTMinter(), to: self.MinterStoragePath)
	}
}

 "
-------
"//import FungibleToken from 0xf233dcee88fe0abe
//import NonFungibleToken from 0x1d7e57aa55817448
//import FlowToken from 0x1654653399040a61
//import FlovatarComponentTemplate from 0x921ea449dffec68a
//import MetadataViews from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import FlowToken from 0x1654653399040a61
import FlovatarComponentTemplate from 0x921ea449dffec68a
import MetadataViews from 0x1d7e57aa55817448

/*

 This contract defines the Flovatar Component NFT and the Collection to manage them.
 Components are like the building blocks (lego bricks) of the final Flovatar (body, mouth, hair, eyes, etc.) and they can be traded as normal NFTs.
 Components are linked to a specific Template that will ultimately contain the SVG and all the other metadata

 */

pub contract FlovatarComponent: NonFungibleToken {

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath

    // Counter for all the Components ever minted
    pub var totalSupply: UInt64

    // Standard events that will be emitted
    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event Created(id: UInt64, templateId: UInt64, mint: UInt64)
    pub event Destroyed(id: UInt64, templateId: UInt64)

    // The public interface provides all the basic informations about
    // the Component and also the Template ID associated with it.
    pub resource interface Public {
        pub let id: UInt64
        pub let templateId: UInt64
        pub let mint: UInt64
        pub fun getTemplate(): FlovatarComponentTemplate.ComponentTemplateData
        pub fun getSvg(): String
        pub fun getCategory(): String
        pub fun getSeries(): UInt32
        pub fun getRarity(): String
        pub fun isBooster(rarity: String): Bool
        pub fun checkCategorySeries(category: String, series: UInt32): Bool

        //these three are added because I think they will be in the standard. At least Dieter thinks it will be needed
        pub let name: String
        pub let description: String
        pub let schema: String?
    }


    // The NFT resource that implements the Public interface as well
    pub resource NFT: NonFungibleToken.INFT, Public, MetadataViews.Resolver {
        pub let id: UInt64
        pub let templateId: UInt64
        pub let mint: UInt64
        pub let name: String
        pub let description: String
        pub let schema: String?

        // Initiates the NFT from a Template ID.
        init(templateId: UInt64) {

            FlovatarComponent.totalSupply = FlovatarComponent.totalSupply + UInt64(1)

            let componentTemplate = FlovatarComponentTemplate.getComponentTemplate(id: templateId)!

            self.id = FlovatarComponent.totalSupply
            self.templateId = templateId
            self.mint = FlovatarComponentTemplate.getTotalMintedComponents(id: templateId)! + UInt64(1)
            self.name = componentTemplate.name
            self.description = componentTemplate.description
            self.schema = nil

            // Increments the counter and stores the timestamp
            FlovatarComponentTemplate.setTotalMintedComponents(id: templateId, value: self.mint)
            FlovatarComponentTemplate.setLastComponentMintedAt(id: templateId, value: getCurrentBlock().timestamp)
        }

        pub fun getID(): UInt64 {
            return self.id
        }

        // Returns the Template associated to the current Component
        pub fun getTemplate(): FlovatarComponentTemplate.ComponentTemplateData {
            return FlovatarComponentTemplate.getComponentTemplate(id: self.templateId)!
        }

        // Gets the SVG from the parent Template
        pub fun getSvg(): String {
            return self.getTemplate().svg!
        }

        // Gets the category from the parent Template
        pub fun getCategory(): String {
            return self.getTemplate().category
        }

        // Gets the series number from the parent Template
        pub fun getSeries(): UInt32 {
            return self.getTemplate().series
        }

        // Gets the rarity from the parent Template
        pub fun getRarity(): String {
            return self.getTemplate().rarity
        }

        // Check the boost and rarity from the parent Template
        pub fun isBooster(rarity: String): Bool {
            let template = self.getTemplate()
            return template.category == "boost" && template.rarity == rarity
        }

        //Check the category and series from the parent Template
        pub fun checkCategorySeries(category: String, series: UInt32): Bool {
            let template = self.getTemplate()
            return template.category == category && template.series == series
        }

        // Emit a Destroyed event when it will be burned to create a Flovatar
        // This will help to keep track of how many Components are still
        // available on the market.
        destroy() {
            emit Destroyed(id: self.id, templateId: self.templateId)
        }

        pub fun getViews() : [Type] {
            var views : [Type]=[]
            views.append(Type<MetadataViews.NFTCollectionData>())
            views.append(Type<MetadataViews.NFTCollectionDisplay>())
            views.append(Type<MetadataViews.Display>())
            views.append(Type<MetadataViews.Royalties>())
            views.append(Type<MetadataViews.Edition>())
            views.append(Type<MetadataViews.ExternalURL>())
            views.append(Type<MetadataViews.Serial>())
            views.append(Type<MetadataViews.Traits>())
            return views
        }

        pub fun resolveView(_ type: Type): AnyStruct? {

            if type == Type<MetadataViews.ExternalURL>() {
                let address = self.owner?.address
                let url = (address == nil) ? "https://flovatar.com/builder/" : "https://flovatar.com/components/".concat(self.id.toString()).concat("/").concat(address!.toString())
                return MetadataViews.ExternalURL("https://flovatar.com/builder/")
            }

            if type == Type<MetadataViews.Royalties>() {
                let royalties : [MetadataViews.Royalty] = []
                royalties.append(MetadataViews.Royalty(receiver: FlovatarComponent.account.getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver), cut: 0.05, description: "Flovatar Royalty"))
                return MetadataViews.Royalties(cutInfos: royalties)
            }

            if type == Type<MetadataViews.Serial>() {
                return MetadataViews.Serial(self.id)
            }

            if type ==  Type<MetadataViews.Editions>() {
                let componentTemplate: FlovatarComponentTemplate.ComponentTemplateData = self.getTemplate()

                let editionInfo = MetadataViews.Edition(name: "Flovatar Component", number: self.mint, max: componentTemplate.maxMintableComponents)
                let editionList: [MetadataViews.Edition] = [editionInfo]
                return MetadataViews.Editions(
                    editionList
                )
            }

            if type == Type<MetadataViews.NFTCollectionDisplay>() {
                let mediaSquare = MetadataViews.Media(
                    file: MetadataViews.HTTPFile(
                        url: "https://images.flovatar.com/logo.svg"
                    ),
                    mediaType: "image/svg+xml"
                )
                let mediaBanner = MetadataViews.Media(
                    file: MetadataViews.HTTPFile(
                        url: "https://images.flovatar.com/logo-horizontal.svg"
                    ),
                    mediaType: "image/svg+xml"
                )
                return MetadataViews.NFTCollectionDisplay(
                    name: "Flovatar Component",
                    description: "Flovatar is pioneering a new way to unleash community creativity in Web3 by allowing users to be co-creators of their prized NFTs, instead of just being passive collectors.",
                    externalURL: MetadataViews.ExternalURL("https://flovatar.com"),
                    squareImage: mediaSquare,
                    bannerImage: mediaBanner,
                    socials: {
                        "discord": MetadataViews.ExternalURL("https://discord.gg/flovatar"),
                        "twitter": MetadataViews.ExternalURL("https://twitter.com/flovatar"),
                        "instagram": MetadataViews.ExternalURL("https://instagram.com/flovatar_nft"),
                        "tiktok": MetadataViews.ExternalURL("https://www.tiktok.com/@flovatar")
                    }
                )
            }


            if type == Type<MetadataViews.Display>() {
                return MetadataViews.Display(
                    name: self.name,
                    description: self.description,
                    thumbnail: MetadataViews.HTTPFile(
                        url: "https://flovatar.com/api/image/template/".concat(self.templateId.toString())
                    )
                )
            }

            if type == Type<MetadataViews.Traits>() {
                let traits: [MetadataViews.Trait] = []

                let template = self.getTemplate()
                let trait = MetadataViews.Trait(name: template.category, value: template.name, displayType:"String", rarity: MetadataViews.Rarity(score:nil, max:nil, description: template.rarity))
                traits.append(trait)

                let setTrait = MetadataViews.Trait(name: "set", value: template.category, displayType:"String", rarity: nil)
                traits.append(setTrait)

                return MetadataViews.Traits(traits)
            }

            if type == Type<MetadataViews.Rarity>() {
                let template = self.getTemplate()
                return MetadataViews.Rarity(score: nil, max: nil, description: template.rarity)
            }

            if type == Type<MetadataViews.NFTCollectionData>() {
                return MetadataViews.NFTCollectionData(
                storagePath: FlovatarComponent.CollectionStoragePath,
                publicPath: FlovatarComponent.CollectionPublicPath,
                providerPath: /private/FlovatarComponentCollection,
                publicCollection: Type<&FlovatarComponent.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, FlovatarComponent.CollectionPublic}>(),
                publicLinkedType: Type<&FlovatarComponent.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, FlovatarComponent.CollectionPublic}>(),
                providerLinkedType: Type<&FlovatarComponent.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, FlovatarComponent.CollectionPublic}>(),
                createEmptyCollectionFunction: fun(): @NonFungibleToken.Collection {return <- FlovatarComponent.createEmptyCollection()}
                )
            }

            return nil
        }
    }

    // Standard NFT collectionPublic interface that can also borrowComponent as the correct type
    pub resource interface CollectionPublic {

        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowComponent(id: UInt64): &FlovatarComponent.NFT? {
            // If the result isn't nil, the id of the returned reference
            // should be the same as the argument to the function
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow Component reference: The ID of the returned reference is incorrect"
            }
        }
    }

    // Main Collection to manage all the Components NFT
    pub resource Collection: CollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with an `UInt64` ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        // withdraw removes an NFT from the collection and moves it to the caller
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <- token
        }

        // deposit takes a NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @FlovatarComponent.NFT

            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        // getIDs returns an array of the IDs that are in the collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT gets a reference to an NFT in the collection
        // so that the caller can read its metadata and call its methods
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        // borrowComponent returns a borrowed reference to a FlovatarComponent
        // so that the caller can read data and call methods from it.
        pub fun borrowComponent(id: UInt64): &FlovatarComponent.NFT? {
            if self.ownedNFTs[id] != nil {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &FlovatarComponent.NFT
            } else {
                return nil
            }
        }

        destroy() {
            destroy self.ownedNFTs
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            pre {
                self.ownedNFTs[id] != nil : "NFT does not exist"
            }
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let componentNFT = nft as! &FlovatarComponent.NFT
            return componentNFT as &AnyResource{MetadataViews.Resolver}
        }
    }

    // public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    // This struct is used to send a data representation of the Components
    // when retrieved using the contract helper methods outside the collection.
    pub struct ComponentData {
        pub let id: UInt64
        pub let templateId: UInt64
        pub let mint: UInt64
        pub let name: String
        pub let description: String
        pub let category: String
        pub let rarity: String
        pub let color: String

        init(id: UInt64, templateId: UInt64, mint: UInt64) {
            self.id = id
            self.templateId = templateId
            self.mint = mint
            let componentTemplate = FlovatarComponentTemplate.getComponentTemplate(id: templateId)!
            self.name = componentTemplate.name
            self.description = componentTemplate.description
            self.category = componentTemplate.category
            self.rarity = componentTemplate.rarity
            self.color = componentTemplate.color
        }
    }

    // Get the SVG of a specific Component from an account and the ID
    pub fun getSvgForComponent(address: Address, componentId: UInt64) : String? {
        let account = getAccount(address)
        if let componentCollection = account.getCapability(self.CollectionPublicPath).borrow<&{FlovatarComponent.CollectionPublic}>()  {
            return componentCollection.borrowComponent(id: componentId)!.getSvg()
        }
        return nil
    }

    // Get a specific Component from an account and the ID as ComponentData
    pub fun getComponent(address: Address, componentId: UInt64) : ComponentData? {
        let account = getAccount(address)
        if let componentCollection = account.getCapability(self.CollectionPublicPath).borrow<&{FlovatarComponent.CollectionPublic}>()  {
            if(!componentCollection.isInstance(Type<@FlovatarComponent.Collection>())) {
                panic("The Collection is not from the correct Type")
            }
            if let component = componentCollection.borrowComponent(id: componentId) {

                return ComponentData(
                    id: componentId,
                    templateId: component!.templateId,
                    mint: component!.mint
                )
            }
        }
        return nil
    }

    // Get an array of all the components in a specific account as ComponentData
    pub fun getComponents(address: Address) : [ComponentData] {

        var componentData: [ComponentData] = []
        let account = getAccount(address)

        if let componentCollection = account.getCapability(self.CollectionPublicPath).borrow<&{FlovatarComponent.CollectionPublic}>()  {
            if(!componentCollection.isInstance(Type<@FlovatarComponent.Collection>())) {
                panic("The Collection is not from the correct Type")
            }
            for id in componentCollection.getIDs() {
                var component = componentCollection.borrowComponent(id: id)
                componentData.append(ComponentData(
                    id: id,
                    templateId: component!.templateId,
                    mint: component!.mint
                    ))
            }
        }
        return componentData
    }

    // This method can only be called from another contract in the same account.
    // In FlovatarComponent case it is called from the Flovatar Admin that is used
    // to administer the components.
    // The only parameter is the parent Template ID and it will return a Component NFT resource
    access(account) fun createComponent(templateId: UInt64) : @FlovatarComponent.NFT {

        let componentTemplate: FlovatarComponentTemplate.ComponentTemplateData = FlovatarComponentTemplate.getComponentTemplate(id: templateId)!
        let totalMintedComponents: UInt64 = FlovatarComponentTemplate.getTotalMintedComponents(id: templateId)!

        // Makes sure that the original minting limit set for each Template has not been reached
        if(totalMintedComponents >= componentTemplate.maxMintableComponents) {
            panic("Reached maximum mintable components for this type")
        }

        var newNFT <- create NFT(templateId: templateId)
        emit Created(id: newNFT.id, templateId: templateId, mint: newNFT.mint)

        return <- newNFT
    }

    // This function will batch create multiple Components and pass them back as a Collection
    access(account) fun batchCreateComponents(templateId: UInt64, quantity: UInt64): @Collection {
        let newCollection <- create Collection()

        var i: UInt64 = 0
        while i < quantity {
            newCollection.deposit(token: <-self.createComponent(templateId: templateId))
            i = i + UInt64(1)
        }

        return <-newCollection
    }

	init() {
        self.CollectionPublicPath = /public/FlovatarComponentCollection
        self.CollectionStoragePath = /storage/FlovatarComponentCollection

        // Initialize the total supply
        self.totalSupply = UInt64(0)

        self.account.save<@NonFungibleToken.Collection>(<- FlovatarComponent.createEmptyCollection(), to: FlovatarComponent.CollectionStoragePath)
        self.account.link<&{FlovatarComponent.CollectionPublic}>(FlovatarComponent.CollectionPublicPath, target: FlovatarComponent.CollectionStoragePath)

        emit ContractInitialized()
	}
}

"
-------
"
    import NonFungibleToken from 0x1d7e57aa55817448;
    import MetadataViews from 0x1d7e57aa55817448;

    access(all) contract Usher: NonFungibleToken {

      pub var totalSupply: UInt64

      pub event ContractInitialized()
      pub event Withdraw(id: UInt64, from: Address?)
      pub event Deposit(id: UInt64, to: Address?)

      pub let CollectionStoragePath: StoragePath
      pub let CollectionPublicPath: PublicPath
      pub let MinterStoragePath: StoragePath

      // Our NFT resource conforms to the INFT interface
      pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        pub let id: UInt64

        pub let name: String
        pub let description: String
        pub let thumbnail: String
        pub let metadata: {String: AnyStruct}

        init(
            id: UInt64,
            name: String,
            description: String,
            thumbnail: String,
            metadata: {String: AnyStruct},
        ) {
            self.id = id
            self.name = name
            self.description = description
            self.thumbnail = thumbnail
            self.metadata = metadata
        }

        pub fun getViews(): [Type] {
          return [
            Type<MetadataViews.Display>()
          ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
          switch view {
            case Type<MetadataViews.Display>():
              return MetadataViews.Display(
                name: self.name,
                description: self.description,
                thumbnail: MetadataViews.HTTPFile(
                  url: self.thumbnail
                )
              )
          }
          return nil
        }
      }

      pub resource interface UsherCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
      }

      // Same goes for our Collection, it conforms to multiple interfaces
      pub resource Collection: UsherCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic,  MetadataViews.ResolverCollection {
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
          self.ownedNFTs <- {}
        }

        pub fun deposit(token: @NonFungibleToken.NFT) {
          let token <- token as! @Usher.NFT

          let id: UInt64 = token.id

          let oldToken: @NonFungibleToken.NFT? <- self.ownedNFTs[id] <- token

          emit Deposit(id: id, to: self.owner?.address)

          destroy oldToken
        }

        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
          let token <- self.ownedNFTs.remove(key: withdrawID) ??
            panic("This collection doesn't contain an NFT with that ID")

          emit Withdraw(id: token.id, from: self.owner?.address)

          return <- token
        }

        // getIDs returns an array of the IDs that are in the collection
        pub fun getIDs(): [UInt64] {
          return self.ownedNFTs.keys
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
          let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
          let Usher = nft as! &Usher.NFT
          return Usher as &AnyResource{MetadataViews.Resolver}
        }

        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
          return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }



        destroy() {
          destroy self.ownedNFTs
        }
      }

      pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
      }
        pub resource NFTMinter {

      // Mints a new NFT with a new ID and deposits it
      // in the recipients collection using their collection reference
          pub fun mintNFT(
            recipient: &{NonFungibleToken.CollectionPublic},
            name: String,
            description: String,
            thumbnail: String,
            metadata: {String: AnyStruct},
          ) {
            // create a new NFT
            var newNFT <- create NFT(
                id: Usher.totalSupply,
                name: name,
                description: description,
                thumbnail: thumbnail,
                metadata: metadata,
            )


            // Deposit it in the recipient's account using their collection ref
            recipient.deposit(token: <-newNFT)

            Usher.totalSupply = Usher.totalSupply + 1
          }
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: Usher.CollectionStoragePath,
                        publicPath: Usher.CollectionPublicPath,
                        providerPath: /private/exampleNFTCollection,
                        publicCollection: Type<&Usher.Collection{Usher.UsherCollectionPublic}>(),
                        publicLinkedType: Type<&Usher.Collection{Usher.UsherCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&Usher.Collection{Usher.UsherCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(),
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                            return <-Usher.createEmptyCollection()
                        })
                    )
                    case Type<MetadataViews.NFTCollectionDisplay>():
                        let media = MetadataViews.Media(
                            file: MetadataViews.HTTPFile(
                                url: "ipfs://bafybeifbyccruwm2sp6mqvrxa4yybojurfbywhx2byzrpso4yab76diylm/Usher.jpg"
                            ),
                            mediaType: "image/svg+xml"
                        )
                    return MetadataViews.NFTCollectionDisplay(
                        name: "Usher",
                        description: "User Face Collection",
                        externalURL: MetadataViews.ExternalURL("www.google.com"),
                        squareImage: media,
                        bannerImage: media,
                        socials: {
 "Twitter":  MetadataViews.ExternalURL("Twitter")
                    }
                    )
            }
            return nil
        }

        /// Function that returns all the Metadata Views implemented by a Non Fungible Token
        ///
        /// @return An array of Types defining the implemented views. This value will be used by
        ///         developers to know which parameter to pass to the resolveView() method.
        ///
        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>()
            ]
        }


      init() {
        self.totalSupply = 0

        self.CollectionStoragePath = /storage/UsherCollection
        self.CollectionPublicPath = /public/UsherCollection
        self.MinterStoragePath = /storage/UsherMinter

        // Create a Collection for the deployer
        let collection <- create Collection()
        self.account.save(<-collection, to: self.CollectionStoragePath)

        // Create a public capability for the collection
        self.account.link<&Usher.Collection{NonFungibleToken.CollectionPublic, Usher.UsherCollectionPublic}>(
          self.CollectionPublicPath,
          target: self.CollectionStoragePath
        )

            // Create a Minter resource and save it to storage
            let minter <- create NFTMinter()
            self.account.save(<-minter, to: self.MinterStoragePath)

        emit ContractInitialized()
      }
    }
    "
-------
"// Basket Contract
//
// NonFungibleToken that holds any number of NonFungibleTokens and FungibleTokens

import NonFungibleToken from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe

import MetadataViews from 0x1d7e57aa55817448
import ViewResolver from 0x1d7e57aa55817448

pub contract Basket: NonFungibleToken, ViewResolver {

    // Total number of Basket's in existance
    pub var totalSupply: UInt64

    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath

    // Thought these could be added as useful way to retrieve correct paths that is backwards compatible across all contracts
    pub fun getDefaultCollectionStoragePath(): StoragePath { return self.CollectionStoragePath }
    pub fun getDefaultCollectionPublicPath(): PublicPath { return self.CollectionPublicPath }

    pub event DepositFungibleTokens(identifier: String, amount: UFix64)
    pub event WithdrawFungibleTokens(identifier: String, amount: UFix64)
    pub event DepositNonFungibleTokens(identifier: String, ids: [UInt64])
    pub event WithdrawNonFungibleTokens(identifier: String, ids: [UInt64])

    // BasketPublic
    //
    // allows access to read the metadata and ipfs pin of the nft
    pub resource interface BasketPublic {
        pub fun getBalances() : {String: UFix64}
        pub fun getNFTs() : {String: [UInt64]}
        pub fun depositNonFungibleTokens( from: @NonFungibleToken.Collection )
        pub fun depositFungibleTokens( from: @FungibleToken.Vault )
    }

    // BasketOwner Interface
    //
    // capability to access these functions can be given to other users by sharing a private capability
    pub resource interface BasketOwner {
        pub fun depositFungibleTokens( from: @FungibleToken.Vault )
        pub fun withdrawFungibleTokens( identifier: String, amount: UFix64 ) : @FungibleToken.Vault
        pub fun depositNonFungibleTokens( from: @NonFungibleToken.Collection )
        pub fun withdrawNonFungibleTokens( targetCollection: @NonFungibleToken.Collection, ids: [UInt64] ) : @NonFungibleToken.Collection
    }

    pub resource NFT: NonFungibleToken.INFT, BasketPublic, MetadataViews.Resolver, BasketOwner {
        pub let id: UInt64
        access(contract) let vaults: @{String: FungibleToken.Vault}
        access(contract) let collections: @{String: NonFungibleToken.Collection}
        access(contract) let metadata: {String: AnyStruct}
        access(self) let royalties: [MetadataViews.Royalty]

        init(initID: UInt64) {
            self.id = initID
            self.vaults <- {}
            self.collections <- {}
            self.metadata = {"mintedTime": getCurrentBlock().timestamp}
            self.royalties = []
        }

        destroy() {
            destroy self.vaults
            destroy self.collections
        }

        /// Function that returns all the Metadata Views implemented by a Non Fungible Token
        ///
        /// @return An array of Types defining the implemented views. This value will be used by
        ///         developers to know which parameter to pass to the resolveView() method.
        ///
        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.Editions>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.Traits>()
            ]
        }

        /// Function that resolves a metadata view for this token.
        ///
        /// @param view: The Type of the desired view.
        /// @return A structure representing the requested view.
        ///
        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: "Basket",
                        description: "Basket is a NonFungibleToken that holds any number of NonFungibleToken Collections and FungibleTokens Vaults",
                        thumbnail: MetadataViews.HTTPFile(
                            url: Basket.getThumbnailURL()
                        )
                    )
                case Type<MetadataViews.Editions>():
                    let editionInfo = MetadataViews.Edition(name: "Basket NFT Edition", number: self.id, max: nil)
                    let editionList: [MetadataViews.Edition] = [editionInfo]
                    return MetadataViews.Editions(
                        editionList
                    )
                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(
                        self.id
                    )
                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL("https://basket-sable.vercel.app/")
                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: Basket.CollectionStoragePath,
                        publicPath: Basket.CollectionPublicPath,
                        providerPath: /private/exampleNFTCollection,
                        publicCollection: Type<&Basket.Collection{Basket.BasketCollectionPublic}>(),
                        publicLinkedType: Type<&Basket.Collection{Basket.BasketCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&Basket.Collection{Basket.BasketCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(),
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                            return <-Basket.createEmptyCollection()
                        })
                    )
                case Type<MetadataViews.NFTCollectionDisplay>():
                    let media = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: "https://basket-sable.vercel.app/_app/immutable/assets/basket-icon.41a9e902.svg"
                        ),
                        mediaType: "image/svg+xml"
                    )
                    return MetadataViews.NFTCollectionDisplay(
                        name: "Basket Collection",
                        description: "Basket NFT Collection.",
                        externalURL: MetadataViews.ExternalURL("https://basket-sable.vercel.app/"),
                        squareImage: media,
                        bannerImage: media,
                        socials: {
                            "twitter": MetadataViews.ExternalURL("https://twitter.com/__basket__")
                        }
                    )
                case Type<MetadataViews.Traits>():
                    // exclude mintedTime and foo to show other uses of Traits
                    let balances = self.getBalances()
                    let nfts = self.getNFTs()
                    let traitsView = MetadataViews.dictToTraits(dict: {
                        "Fungible Tokens": balances.keys,
                        "Non-Fungible Token Collections": nfts.keys,
                        "Fungible Token Balances": balances,
                        "Non-Fungible Token with IDs": nfts
                    }, excludedNames: nil)

                    // mintedTime is a unix timestamp, we should mark it with a displayType so platforms know how to show it.
                    let mintedTimeTrait = MetadataViews.Trait(name: "mintedTime", value: self.metadata["mintedTime"]!, displayType: "Date", rarity: nil)
                    traitsView.addTrait(mintedTimeTrait)

                    return traitsView
                }
                return nil
            }


        pub fun getBalances() : {String : UFix64} {
            let balances: {String:UFix64} = {}
            for key in self.vaults.keys {
                balances.insert(key: key, self.vaults[key]?.balance!)
            }
            return balances
        }

        pub fun getNFTs() : {String : [UInt64]} {
            let nftIDs: {String:[UInt64]} = {}
            for key in self.collections.keys {
                nftIDs.insert(key: key, self.collections[key]?.getIDs()!)
            }
            return nftIDs
        }

        pub fun getCollectionViews(): AnyStruct {
            let collectionViews: {String: AnyStruct} = {}

            for key in self.collections.keys {
                let collectionRef = &self.collections[key] as &NonFungibleToken.Collection?
                let addr = Address.fromString("0x".concat(key.slice(from: 2, upTo: 18)))!
                let contractName = key.slice(from: 19, upTo: key.length - 11)
                let borrowedContract = getAccount(addr).contracts.borrow<&ViewResolver>(name: contractName) // ?? panic("contract could not be borrowed")

                if borrowedContract != nil {
                    collectionViews[key] = {"NFTCollectionData": borrowedContract?.resolveView(Type<MetadataViews.NFTCollectionData>())!, "NFTCollectionDisplay": borrowedContract?.resolveView(Type<MetadataViews.NFTCollectionDisplay>())!}
                }
            }
            return collectionViews
        }

        pub fun getNFTViews(key: String): AnyStruct {
            // get collection ref
            let collectionRef = &self.collections[key] as &NonFungibleToken.Collection?
            if (collectionRef == nil) {
                log("invalid collection ref returning" )
                return nil
            }

            let nftViews: {String: AnyStruct} = {}
            for id in collectionRef!.getIDs() {
                log("nft")
                log(id)

                let nftRef = collectionRef?.borrowNFT!(id: id) // as! auth &AnyResource{MetadataViews.Resolver}
                // let viewResolver = nftRef.borrowViewResolver(id: id)
                log(nftRef)

                log(nftRef.getType())
                let nftType = nftRef.getType()
                nftViews[id.toString()] =nftRef
            }
            return nftViews
        }

        // pub fun getVaultViews()

        pub fun depositFungibleTokens(from: @FungibleToken.Vault) {
            let identifier = from.getType().identifier
            let balance = from.balance
            if self.vaults[identifier] == nil {
                self.vaults[identifier] <-! from
            } else {
                let depositRef = &self.vaults[identifier] as &FungibleToken.Vault?
                depositRef!.deposit(from: <- from)
            }
            emit DepositFungibleTokens(identifier: identifier, amount: balance)
        }

        pub fun withdrawFungibleTokens( identifier: String, amount: UFix64 ) : @FungibleToken.Vault {
            pre {
                self.vaults.containsKey(identifier) : "Not tokens with that identifier stored in this VaultNFT"
                amount <= self.vaults[identifier]?.balance! : "Insufficient balance to withdraw requested amount"
            }
            return <- self.vaults[identifier]?.withdraw(amount: amount)!
        }

        pub fun depositNonFungibleTokens(from: @NonFungibleToken.Collection) {
            let identifier = from.getType().identifier
            let ids = from.getIDs()
            if self.collections[identifier] != nil {
                for id in ids {
                    self.collections[identifier]?.deposit(token: <- from.withdraw(withdrawID: id))
                }
                destroy from
            }  else {
                    self.collections[identifier] <-! from
            }
            emit DepositNonFungibleTokens(identifier: identifier, ids: ids)
        }

        // requires passing in a correctly typed targetCollection which receives the tokens and can be created in the transaction
        pub fun withdrawNonFungibleTokens( targetCollection: @NonFungibleToken.Collection, ids: [UInt64] ) : @NonFungibleToken.Collection {
            pre {
                self.collections.containsKey(targetCollection.getType().identifier) : "Not tokens with that identifier stored in this Basket"
            }
            for id in ids {
                targetCollection.deposit(token: <- self.collections[targetCollection.getType().identifier]?.withdraw( withdrawID: id )!)
            }
            return <- targetCollection
        }

    }

    pub resource interface BasketCollectionPublic {
        pub fun borrowBasket(id: UInt64): &Basket.NFT?
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
    }

    // standard implmentation for managing a collection of NFTs
    pub resource Collection: NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection, BasketCollectionPublic {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with an `UInt64` ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        // withdraw removes an NFT from the collection and moves it to the caller
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        // deposit takes a NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @Basket.NFT

            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        // getIDs returns an array of the IDs that are in the collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT gets a reference to an NFT in the collection
        // so that the caller can read its metadata and call its methods
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            let nftRef = &self.ownedNFTs[id] as &NonFungibleToken.NFT?
            return nftRef!
        }

        // borrowBasket gets a reference to an NFT in the collection
        // so that the caller can read its metadata and call its methods
        pub fun borrowBasket(id: UInt64): &Basket.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorized reference to allow downcasting
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &Basket.NFT
            }
            return nil
        }

        /// Gets a reference to the NFT only conforming to the `{MetadataViews.Resolver}`
        /// interface so that the caller can retrieve the views that the NFT
        /// is implementing and resolve them
        ///
        /// @param id: The ID of the wanted NFT
        /// @return The resource reference conforming to the Resolver interface
        ///
        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let vault = nft as! &Basket.NFT
            return vault as &AnyResource{MetadataViews.Resolver}
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    // public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    pub fun createEmptyBasket(): @NonFungibleToken.NFT {
        var newNFT <- create NFT(initID: Basket.totalSupply)
        Basket.totalSupply = Basket.totalSupply + 1
        return <- newNFT
    }

    /// Function that resolves a metadata view for this contract.
    ///
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    pub fun resolveView(_ view: Type): AnyStruct? {
        switch view {
            case Type<MetadataViews.NFTCollectionData>():
                return MetadataViews.NFTCollectionData(
                    storagePath: Basket.CollectionStoragePath,
                    publicPath: Basket.CollectionPublicPath,
                    providerPath: /private/BasketCollection,
                    publicCollection: Type<&Basket.Collection{Basket.BasketCollectionPublic}>(),
                    publicLinkedType: Type<&Basket.Collection{Basket.BasketCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
                    providerLinkedType: Type<&Basket.Collection{Basket.BasketCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(),
                    createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                        return <-Basket.createEmptyCollection()
                    })
                )
            case Type<MetadataViews.NFTCollectionDisplay>():
                let media = MetadataViews.Media(
                    file: MetadataViews.HTTPFile(
                        url: "https://basket-sable.vercel.app/_app/immutable/assets/basket-icon.41a9e902.svg"
                    ),
                    mediaType: "image/svg+xml"
                )
        }
        return nil
    }

    /// Function that returns all the Metadata Views implemented by a Non Fungible Token
    ///
    /// @return An array of Types defining the implemented views. This value will be used by
    ///         developers to know which parameter to pass to the resolveView() method.
    ///
    pub fun getViews(): [Type] {
        return [
            Type<MetadataViews.NFTCollectionData>(),
            Type<MetadataViews.NFTCollectionDisplay>()
        ]
    }

    pub fun getThumbnailURL(): String {
        return "https://basket-sable.vercel.app/_app/immutable/assets/basket-icon.41a9e902.svg"
    }

    init() {
        // Initialize the total supply
        self.totalSupply = 0

        // Initalize paths for scripts and transactions usage
        self.CollectionStoragePath = /storage/BasketNFTCollection
        self.CollectionPublicPath = /public/BasketCollection

        // Create a Collection resource and save it to storage
        let collection <- create Collection()
        self.account.save(<-collection, to: Basket.CollectionStoragePath)

        // create a public capability for the collection
        self.account.link<&{BasketCollectionPublic, NonFungibleToken.CollectionPublic}>(
            Basket.CollectionPublicPath,
            target: Basket.CollectionStoragePath
        )

        emit ContractInitialized()
    }
}
 "
-------
"import NonFungibleToken from 0x1d7e57aa55817448;
import MetadataViews from 0x1d7e57aa55817448;

pub contract CatchingUnicorns: NonFungibleToken {

  pub var totalSupply: UInt64

  pub event ContractInitialized()
  pub event Withdraw(id: UInt64, from: Address?)
  pub event Deposit(id: UInt64, to: Address?)

  pub let CollectionStoragePath: StoragePath
  pub let CollectionPublicPath: PublicPath

  pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
    pub let id: UInt64

    pub let name: String
    pub let description: String
    pub let thumbnail: String

    init(
      id: UInt64,
      name: String,
      description: String,
      thumbnail: String,
    ) {
      self.id = id
      self.name = name
      self.description = description
      self.thumbnail = thumbnail
    }

    pub fun getViews(): [Type] {
      return [
        Type<MetadataViews.Display>()
      ]
    }

    pub fun resolveView(_ view: Type): AnyStruct? {
      switch view {
        case Type<MetadataViews.Display>():
          return MetadataViews.Display(
            name: self.name,
            description: self.description,
            thumbnail: MetadataViews.HTTPFile(
              url: self.thumbnail
            )
          )
      }
      return nil
    }
  }

  pub resource interface CatchingUnicornsCollectionPublic {
    pub fun deposit(token: @NonFungibleToken.NFT)
    pub fun getIDs(): [UInt64]
    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
  }

  pub resource Collection: CatchingUnicornsCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
    pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

    init () {
      self.ownedNFTs <- {}
    }

    pub fun getIDs(): [UInt64] {
      return self.ownedNFTs.keys
    }

    pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
      let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

      emit Withdraw(id: token.id, from: self.owner?.address)

      return <-token
    }

    pub fun deposit(token: @NonFungibleToken.NFT) {
      let token <- token as! @CatchingUnicorns.NFT

      let id: UInt64 = token.id

      let oldToken <- self.ownedNFTs[id] <- token

      emit Deposit(id: id, to: self.owner?.address)

      destroy oldToken
    }

    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
      return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
    }

    pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
      let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let CatchingUnicorns = nft as! &CatchingUnicorns.NFT
      return CatchingUnicorns as &AnyResource{MetadataViews.Resolver}
    }

    destroy() {
      destroy self.ownedNFTs
    }
  }

  pub fun createEmptyCollection(): @NonFungibleToken.Collection {
    return <- create Collection()
  }

  pub fun mintNFT(
    recipient: &{NonFungibleToken.CollectionPublic},
    name: String,
    description: String,
    thumbnail: String,
  ) {
    var newNFT <- create NFT(
      id: CatchingUnicorns.totalSupply,
      name: name,
      description: description,
      thumbnail: thumbnail
    )

    recipient.deposit(token: <-newNFT)

    CatchingUnicorns.totalSupply = CatchingUnicorns.totalSupply + UInt64(1)
  }

  init() {
    self.totalSupply = 0

    self.CollectionStoragePath = /storage/CatchingUnicornsCollection
    self.CollectionPublicPath = /public/CatchingUnicornsCollection

    let collection <- create Collection()
    self.account.save(<-collection, to: self.CollectionStoragePath)

    self.account.link<&CatchingUnicorns.Collection{NonFungibleToken.CollectionPublic, CatchingUnicorns.CatchingUnicornsCollectionPublic, MetadataViews.ResolverCollection}>(
      self.CollectionPublicPath,
      target: self.CollectionStoragePath
    )

    emit ContractInitialized()
  }
}"
-------
"import Crypto
import NonFungibleToken from 0x1d7e57aa55817448
import FantastecNFT, IFantastecPackNFT from 0x4bbff461fa8f6192
import MetadataViews from 0x1d7e57aa55817448

pub contract FantastecPackNFT: NonFungibleToken, IFantastecPackNFT {

    pub var totalSupply: UInt64
    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let CollectionIFantastecPackNFTPublicPath: PublicPath
    pub let OperatorStoragePath: StoragePath
    pub let OperatorPrivPath: PrivatePath

    access(contract) let packs: @{UInt64: Pack}

    // from IFantastecPackNFT
    pub event Burned(id: UInt64)
    // from NonFungibleToken
    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    // contract specific
    pub event Minted(id: UInt64)

    pub resource FantastecPackNFTOperator: IFantastecPackNFT.IOperator {
        pub fun mint(packId: UInt64, productId: UInt64): @NFT{
            let packNFT <- create NFT(packId: packId, productId: productId)
            FantastecPackNFT.totalSupply = FantastecPackNFT.totalSupply + 1
            emit Minted(id: packNFT.id)
            let pack <- create Pack()
            FantastecPackNFT.packs[packNFT.id] <-! pack
            return <- packNFT
        }

        pub fun open(id: UInt64, recipient: Address) {
            let pack <- FantastecPackNFT.packs.remove(key: id) ?? panic("cannot find pack with ID ".concat(id.toString()))
            pack.open(recipient: recipient)
            FantastecPackNFT.packs[id] <-! pack
        }

        pub fun addFantastecNFT(id: UInt64, nft: @FantastecNFT.NFT) {
            let pack <- FantastecPackNFT.packs.remove(key: id) ?? panic("cannot find pack with ID ".concat(id.toString()))
            pack.addFantastecNFT(nft: <- nft)
            FantastecPackNFT.packs[id] <-! pack
        }

        init(){}
    }

    pub resource Pack: IFantastecPackNFT.IFantastecPack {
        pub var ownedNFTs: @{UInt64: FantastecNFT.NFT}

        pub fun open(recipient: Address) {
            let receiver = getAccount(recipient)
                .getCapability(FantastecNFT.CollectionPublicPath)
                .borrow<&{NonFungibleToken.CollectionPublic}>()
                ?? panic("Could not get receiver reference to the NFT Collection - ".concat(recipient.toString()))
            for key in self.ownedNFTs.keys {
                let nft <-! self.ownedNFTs.remove(key: key)
                receiver.deposit(token: <- nft!)
            }
        }

        pub fun addFantastecNFT(nft: @FantastecNFT.NFT){
            let id = nft.id
            self.ownedNFTs[id] <-! nft
        }

        init() {
            self.ownedNFTs <- {}
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        pub let id: UInt64
        pub let productId: UInt64

        destroy() {
            FantastecPackNFT.totalSupply = FantastecPackNFT.totalSupply - (1 as UInt64)
            let pack <- FantastecPackNFT.packs.remove(key: self.id)
                ?? panic("cannot find pack with ID ".concat(self.id.toString()))
            destroy pack
            emit Burned(id: self.id)
        }

        init(packId: UInt64, productId: UInt64) {
            self.id = packId
            self.productId = productId
        }

        // from MetadataViews.Resolver
        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>()
                // Type<MetadataViews.ExternalURL>(),
                // Type<MetadataViews.Medias>(),
                // Type<MetadataViews.NFTCollectionData>(),
                // Type<MetadataViews.NFTCollectionDisplay>(),
                // Type<MetadataViews.Royalties>(),
                // Type<MetadataViews.Serial>(),
                // Type<MetadataViews.Traits>()
            ]
        }

        // from MetadataViews.Resolver
        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: "Fantastec Pack",
                        description: "Reveals Fantstec NFTs when opened",
                        thumbnail: MetadataViews.HTTPFile(self.getThumbnailPath())
                    )
            }
            return nil
        }

        pub fun getThumbnailPath(): String {
            return "path/to/thumbnail/".concat(self.id.toString())
        }
    }

    pub resource Collection:
        NonFungibleToken.Provider,
        NonFungibleToken.Receiver,
        NonFungibleToken.CollectionPublic,
        IFantastecPackNFT.IFantastecPackNFTCollectionPublic
    {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with an `UInt64` ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        // withdraw removes an NFT from the collection and moves it to the caller
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")
            emit Withdraw(id: token.id, from: self.owner?.address)
            return <- token
        }

        // deposit takes a NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @FantastecPackNFT.NFT

            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token
            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        // getIDs returns an array of the IDs that are in the collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT gets a reference to an NFT in the collection
        // so that the caller can read its metadata and call its methods
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    init(){
        self.totalSupply = 0
        self.packs <- {}
        // Set our named paths
        self.CollectionStoragePath = /storage/FantastecPackNFTCollection
        self.CollectionPublicPath = /public/FantastecPackNFTCollection
        self.CollectionIFantastecPackNFTPublicPath = /public/FantastecPackNFTCollection
        self.OperatorStoragePath = /storage/FantastecPackNFTOperatorCollection
        self.OperatorPrivPath = /private/FantastecPackNFTOperatorCollection

        // Create a collection to receive Pack NFTs
        let collection <- create Collection()
        self.account.save(<-collection, to: self.CollectionStoragePath)
        self.account.link<&Collection{NonFungibleToken.CollectionPublic}>(self.CollectionPublicPath, target: self.CollectionStoragePath)
        self.account.link<&Collection{IFantastecPackNFT.IFantastecPackNFTCollectionPublic}>(self.CollectionIFantastecPackNFTPublicPath, target: self.CollectionStoragePath)

        // Create a operator to share mint capability with proxy
        let operator <- create FantastecPackNFTOperator()
        self.account.save(<-operator, to: self.OperatorStoragePath)
        self.account.link<&FantastecPackNFTOperator{IFantastecPackNFT.IOperator}>(self.OperatorPrivPath, target: self.OperatorStoragePath)
    }

}
"
-------
" /**

## The Flow Non-Fungible Token standard

Adapted for Capsule needs.

## `NonFungibleToken` contract interface

The interface that all non-fungible token contracts could conform to.
If a user wants to deploy a new nft contract, their contract would need
to implement this NonFungibleToken interface.

Their contract would have to follow all the rules and naming
that the interface specifies.

## `NFT` resource

The core resource type that represents an NFT in the smart contract.

## `Collection` Resource

The resource that stores a user's NFT collection.
It includes a few functions to allow the owner to easily
move tokens in and out of the collection.

## `Provider` and `Receiver` resource interfaces

These interfaces declare functions with some pre and post conditions
that require the Collection to follow certain naming and behavior standards.

They are separate because it gives the user the ability to share a reference
to their Collection that only exposes the fields and functions in one or more
of the interfaces. It also gives users the ability to make custom resources
that implement these interfaces to do various things with the tokens.

By using resources and interfaces, users of NFT smart contracts can send
and receive tokens peer-to-peer, without having to interact with a central ledger
smart contract.

To send an NFT to another user, a user would simply withdraw the NFT
from their Collection, then call the deposit function on another user's
Collection to complete the transfer.

*/

// The main NFT contract interface. Other NFT contracts will
// import and implement this interface
//
pub contract interface CapsuleNFT {

    // The total number of tokens of this type in existence
    pub var totalMinted: UInt64

    // Event that emitted when the NFT contract is initialized
    //
    pub event ContractInitialized()

    // Event that is emitted when a token is withdrawn,
    // indicating the:
    // - the ID of the NFT being withdrawn
    // - the size (bytes) of the NFT
    // - the owner of the collection that it was withdrawn from
    //
    // If the collection is not in an account's storage, `from` will be `nil`.
    //
    pub event Withdraw(id: String, size: UInt64, from: Address?)

    // Event that emitted when a token is deposited to a collection,
    // indicating the:
    // - the ID of the NFT being withdrawn
    // - the size (bytes) of the NFT
    // - the owner of the collection that it was deposited to
    //
    //
    pub event Deposit(id: String, size: UInt64, to: Address?)

    // Event that emits when a token is minted.
    //
    pub event Minted(id: String)

    // Interface that the NFTs have to conform to
    //
    pub resource interface INFT {
        // The Capsule UniqueID given to the NFT
        pub let id: String
    }

    // Requirement that all conforming NFT smart contracts have
    // to define a resource called NFT that conforms to INFT
    pub resource NFT: INFT {
        pub let id: String
    }

    // Interface to mediate withdraws from the Collection
    //
    pub resource interface Provider {
        // withdraw removes an NFT from the collection and moves it to the caller
        pub fun withdraw(id: String): @NFT {
            post {
                result.id == id: "The ID of the withdrawn token must be the same as the requested ID"
            }
        }
    }

    // Interface to mediate deposits to the Collection
    //
    pub resource interface Receiver {
        // deposit takes an NFT as an argument and adds it to the Collection
        //
		pub fun deposit(token: @NFT)
    }

    // Interface that an account would commonly
    // publish for their collection
    pub resource interface CollectionPublic {
        pub fun deposit(token: @NFT)
        pub fun getIDs(): [String]
        pub fun borrowNFT(id: String): &NFT
    }

    // Requirement for the the concrete resource type
    // to be declared in the implementing contract
    //
    pub resource Collection: Provider, Receiver, CollectionPublic {
        // Dictionary to hold the NFTs in the Collection
        pub var ownedNFTs: @{String: NFT}

        // withdraw removes an NFT from the collection and moves it to the caller
        pub fun withdraw(id: String): @NFT

        // deposit takes a NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun deposit(token: @NFT)

        // getIDs returns an array of the IDs that are in the collection
        pub fun getIDs(): [String]

        // Returns a borrowed reference to an NFT in the collection
        // so that the caller can read data and call methods from it
        pub fun borrowNFT(id: String): &NFT {
            pre {
                self.ownedNFTs[id] != nil: "NFT does not exist in the collection!"
            }
        }
    }

    // createEmptyCollection creates an empty Collection
    // and returns it to the caller so that they can own NFTs
    pub fun createEmptyCollection(): @Collection {
        post {
            result.getIDs().length == 0: "The created collection must be empty!"
        }
    }
}
 "
-------
"import CapsuleNFT from 0xd8f6dd312265bd2c

pub contract Merchandise: CapsuleNFT {
    pub var totalMinted: UInt64

    pub event ContractInitialized()
    pub event CollectionCreated()
    pub event CollectionDestroyed(length: Int)
    pub event Withdraw(id: String, size: UInt64, from: Address?)
    pub event Deposit(id: String, size: UInt64, to: Address?)
    pub event Minted(id: String)
    pub event MerchandiseMinted(
        id: String,
        item: String,
        collection: String,
        type: String,
        edition: String,
        description: String,
        retailPrice: UFix64,
        mediaUri: String,
        mintedTime: String,
        resourceId: UInt64
    )
    pub event MerchandiseDestroyed(id: String)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath

    /// NFT:
    /// A Merchandise as an NFT
    pub resource NFT: CapsuleNFT.INFT {
        pub let id: String
        pub let item: String
        pub let collection: String
        pub let type: String
        pub let edition: String
        pub let description: String
        pub let retailPrice: UFix64
        pub let mediaUri: String
        pub let mintedTime: String

        init(
            id: String,
            item: String,
            collection: String,
            type: String,
            edition: String,
            description: String,
            retailPrice: UFix64,
            mediaUri: String,
            mintedTime: String,
        ) {
            self.id = id
            self.item = item
            self.collection = collection
            self.type = type
            self.edition = edition
            self.description = description
            self.retailPrice = retailPrice
            self.mediaUri = mediaUri
            self.mintedTime = mintedTime
        }

        destroy() {
            emit MerchandiseDestroyed(id: self.id)
        }
    }

    /// MerchandiseCollectionPublic:
    /// This is the interface that users can cast their Merchandise Collection as,
    /// in order to allow others to deposit a Merchandise into their Collection.
    /// It also allows for reading the details of an Merchandise in the Collection.
    pub resource interface MerchandiseCollectionPublic {
        pub fun deposit(token: @CapsuleNFT.NFT)
        pub fun getIDs(): [String]
        pub fun borrowNFT(id: String): &CapsuleNFT.NFT
        pub fun borrowMerchandise(id: String): &Merchandise.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow Collectible reference: the ID of the returned reference is incorrect"
            }
        }
    }

    /// Collection:
    /// A collection of Merchandise NFTs owned by an account
    pub resource Collection: MerchandiseCollectionPublic, CapsuleNFT.Provider, CapsuleNFT.Receiver, CapsuleNFT.CollectionPublic {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with a `String` ID field
        pub var ownedNFTs: @{String: CapsuleNFT.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        /// Removes an NFT from the collection and moves it to the caller
        pub fun withdraw(id: String): @CapsuleNFT.NFT {
            let address: Address? = self.owner?.address
            let account: PublicAccount = getAccount(address!)
            let startUsed: UInt64 = account.storageUsed

            let token: @CapsuleNFT.NFT <- self.ownedNFTs.remove(key: id)
                ?? panic("Missing EventTicket NFT!")

            let endUsed: UInt64 = account.storageUsed
            let delta: UInt64 = endUsed - startUsed
            emit Withdraw(id: token.id, size: delta, from: address)

            return <-token
        }

        /// Takes an NFT, adds it to the Collection dictionary and adds the ID to the id array
        pub fun deposit(token: @CapsuleNFT.NFT) {
            let address: Address? = self.owner?.address
            let account: PublicAccount = getAccount(address!)
            let startUsed: UInt64 = account.storageUsed

            let token: @Merchandise.NFT <- token as! @Merchandise.NFT
            let id: String = token.id
            // Add the new token to the dictionary which removes the old one
            let oldToken: @CapsuleNFT.NFT? <- self.ownedNFTs[id] <- token

            let endUsed: UInt64 = account.storageUsed
            let delta: UInt64 = endUsed - startUsed
            emit Deposit(id: id, size: delta, to: address)

            destroy oldToken
        }

        /// Returns an array of the IDs that are in the collection
        pub fun getIDs(): [String] {
            return self.ownedNFTs.keys
        }

        /// Gets a reference to an NFT in the collection so that the caller can read its metadata and call its methods
        pub fun borrowNFT(id: String): &CapsuleNFT.NFT {
            return (&self.ownedNFTs[id] as &CapsuleNFT.NFT?)!
        }

        /// Gets a reference to a Merchandise in the Collection
        pub fun borrowMerchandise(id: String): &Merchandise.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorised reference to allow downcasting
                let ref: auth &CapsuleNFT.NFT = (&self.ownedNFTs[id] as auth &CapsuleNFT.NFT?)!
                return ref as! &Merchandise.NFT
            } else {
                return nil
            }
        }

        destroy() {
            let collectionLength = self.ownedNFTs.length
            destroy self.ownedNFTs
            emit CollectionDestroyed(length: collectionLength)
        }
    }

    /// Public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(): @CapsuleNFT.Collection {
        emit CollectionCreated()
        return <- create Collection()
    }

    /// Resource that an admin or similar would own to be able to mint new NFTs
    pub resource NFTMinter {
        /// Mints a new Merchandise.
        /// Deposits it in the recipients Collection using their PublicCollection reference.
        pub fun mintMerchandise(
            recipientCollection: &{CapsuleNFT.CollectionPublic},
            id: String,
            item: String,
            collection: String,
            type: String,
            edition: String,
            description: String,
            retailPrice: UFix64,
            mediaUri: String,
            mintedTime: String,
        ) {
            // Create a new Merchandise NFT
            var merchandise: @Merchandise.NFT <- create NFT(
                id: id,
                item: item,
                collection: collection,
                type: type,
                edition: edition,
                description: description,
                retailPrice: retailPrice,
                mediaUri: mediaUri,
                mintedTime: mintedTime
            )
            // Emit Events
            // emit Minted(id: id)
            emit MerchandiseMinted(
                id: id,
                item: item,
                collection: collection,
                type: type,
                edition: edition,
                description: description,
                retailPrice: retailPrice,
                mediaUri: mediaUri,
                mintedTime: mintedTime,
                resourceId: merchandise.uuid
            )
            // Increment the total of minted Merchandise
            Merchandise.totalMinted = Merchandise.totalMinted + 1

            // Deposit it in the recipient's account using their reference
            recipientCollection.deposit(token: <-merchandise)
        }
    }

    init() {
        // Initialize the total of minted Merchandise
        self.totalMinted = 0

        // Set the itemd paths
        self.CollectionStoragePath = /storage/CapsuleMerchandiseCollection
        self.CollectionPublicPath = /public/CapsuleMerchandiseCollection
        self.MinterStoragePath = /storage/CapsuleMerchandiseMinter

        // Create a Merchandise resource and save it to storage
        let collection: @Merchandise.Collection <- create Collection()
        self.account.save(<-collection, to: self.CollectionStoragePath)

        // Create a public capability for the collection
        self.account.link<&Merchandise.Collection{CapsuleNFT.CollectionPublic, Merchandise.MerchandiseCollectionPublic}>
            (self.CollectionPublicPath, target: self.CollectionStoragePath)

        // Create a Minter resource and save it to storage
        let minter: @Merchandise.NFTMinter <- create NFTMinter()
        self.account.save(<-minter, to: self.MinterStoragePath)

        emit ContractInitialized()
    }
}
 "
-------
"// CREATED BY: Touchstone (https://touchstone.city/), a platform crafted by your best friends at Emerald City DAO (https://ecdao.org/).
// STATEMENT: This contract promises to keep the 5% royalty off of primary sales and 2.5% off of secondary sales to Emerald City DAO or risk permanent suspension from participation in the DAO and its tools.

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import FlowToken from 0x1654653399040a61
import MintVerifiers from 0x7a696d6136e1dce2
import FUSD from 0x3c5959b568896393
import EmeraldPass from 0x6a07dbeb03167a13

pub contract TouchstoneTestGritIron: NonFungibleToken {

	// Collection Information
	access(self) let collectionInfo: {String: AnyStruct}

	// Contract Information
	pub var nextEditionId: UInt64
	pub var nextMetadataId: UInt64
	pub var totalSupply: UInt64

	// Events
	pub event ContractInitialized()
	pub event Withdraw(id: UInt64, from: Address?)
	pub event Deposit(id: UInt64, to: Address?)
	pub event TouchstonePurchase(id: UInt64, recipient: Address, metadataId: UInt64, name: String, description: String, image: MetadataViews.IPFSFile, price: UFix64)
	pub event Minted(id: UInt64, recipient: Address, metadataId: UInt64)
	pub event MintBatch(metadataIds: [UInt64], recipients: [Address])

	// Paths
	pub let CollectionStoragePath: StoragePath
	pub let CollectionPublicPath: PublicPath
	pub let CollectionPrivatePath: PrivatePath
	pub let AdministratorStoragePath: StoragePath

	// Maps metadataId of NFT to NFTMetadata
	access(account) let metadatas: {UInt64: NFTMetadata}

	// Maps the metadataId of an NFT to the primary buyer
	access(account) let primaryBuyers: {Address: {UInt64: [UInt64]}}

	access(account) let nftStorage: @{Address: {UInt64: NFT}}

	pub struct NFTMetadata {
		pub let metadataId: UInt64
		pub let name: String
		pub let description: String
		// The main image of the NFT
		pub let image: MetadataViews.IPFSFile
		// An optional thumbnail that can go along with it
		// for easier loading
		pub let thumbnail: MetadataViews.IPFSFile?
		// If price is nil, defaults to the collection price
		pub let price: UFix64?
		pub var extra: {String: AnyStruct}
		pub let supply: UInt64
		pub let purchasers: {UInt64: Address}

		access(account) fun purchased(serial: UInt64, buyer: Address) {
			self.purchasers[serial] = buyer
		}

		init(_name: String, _description: String, _image: MetadataViews.IPFSFile, _thumbnail: MetadataViews.IPFSFile?, _price: UFix64?, _extra: {String: AnyStruct}, _supply: UInt64) {
			self.metadataId = TouchstoneTestGritIron.nextMetadataId
			self.name = _name
			self.description = _description
			self.image = _image
			self.thumbnail = _thumbnail
			self.price = _price
			self.extra = _extra
			self.supply = _supply
			self.purchasers = {}
		}
	}

	pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
		// The 'id' is the same as the 'uuid'
		pub let id: UInt64
		// The 'metadataId' is what maps this NFT to its 'NFTMetadata'
		pub let metadataId: UInt64
		pub let serial: UInt64

		pub fun getMetadata(): NFTMetadata {
			return TouchstoneTestGritIron.getNFTMetadata(self.metadataId)!
		}

		pub fun getViews(): [Type] {
			return [
				Type<MetadataViews.Display>(),
				Type<MetadataViews.ExternalURL>(),
				Type<MetadataViews.NFTCollectionData>(),
				Type<MetadataViews.NFTCollectionDisplay>(),
				Type<MetadataViews.Royalties>(),
				Type<MetadataViews.Serial>(),
				Type<MetadataViews.Traits>(),
				Type<MetadataViews.NFTView>()
			]
		}

		pub fun resolveView(_ view: Type): AnyStruct? {
			switch view {
				case Type<MetadataViews.Display>():
					let metadata = self.getMetadata()
					return MetadataViews.Display(
						name: metadata.name,
						description: metadata.description,
						thumbnail: metadata.thumbnail ?? metadata.image
					)
				case Type<MetadataViews.NFTCollectionData>():
					return MetadataViews.NFTCollectionData(
						storagePath: TouchstoneTestGritIron.CollectionStoragePath,
						publicPath: TouchstoneTestGritIron.CollectionPublicPath,
						providerPath: TouchstoneTestGritIron.CollectionPrivatePath,
						publicCollection: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
						publicLinkedType: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
						providerLinkedType: Type<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection, NonFungibleToken.Provider}>(),
						createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
								return <- TouchstoneTestGritIron.createEmptyCollection()
						})
					)
				case Type<MetadataViews.ExternalURL>():
          return MetadataViews.ExternalURL("https://touchstone.city/discover/".concat(self.owner!.address.toString()).concat("/TouchstoneTestGritIron"))
				case Type<MetadataViews.NFTCollectionDisplay>():
					let squareMedia = MetadataViews.Media(
						file: TouchstoneTestGritIron.getCollectionAttribute(key: "image") as! MetadataViews.IPFSFile,
						mediaType: "image"
					)

					// If a banner image exists, use it
					// Otherwise, default to the main square image
					var bannerMedia: MetadataViews.Media? = nil
					if let bannerImage = TouchstoneTestGritIron.getOptionalCollectionAttribute(key: "bannerImage") as! MetadataViews.IPFSFile? {
						bannerMedia = MetadataViews.Media(
							file: bannerImage,
							mediaType: "image"
						)
					}
					return MetadataViews.NFTCollectionDisplay(
						name: TouchstoneTestGritIron.getCollectionAttribute(key: "name") as! String,
						description: TouchstoneTestGritIron.getCollectionAttribute(key: "description") as! String,
						externalURL: MetadataViews.ExternalURL("https://touchstone.city/discover/".concat(self.owner!.address.toString()).concat("/TouchstoneTestGritIron")),
						squareImage: squareMedia,
						bannerImage: bannerMedia ?? squareMedia,
						socials: TouchstoneTestGritIron.getCollectionAttribute(key: "socials") as! {String: MetadataViews.ExternalURL}
					)
				case Type<MetadataViews.Royalties>():
					return MetadataViews.Royalties([
						// This is for Emerald City in favor of producing Touchstone, a free platform for our users. Failure to keep this in the contract may result in permanent suspension from Emerald City.
						MetadataViews.Royalty(
							recepient: getAccount(0x5643fd47a29770e7).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),
							cut: 0.025, // 2.5% royalty on secondary sales
							description: "Emerald City DAO receives a 2.5% royalty from secondary sales because this collection was created using Touchstone (https://touchstone.city/), a tool for creating your own NFT collections, crafted by Emerald City DAO."
						)
					])
				case Type<MetadataViews.Serial>():
					return MetadataViews.Serial(
						self.serial
					)
				case Type<MetadataViews.Traits>():
					return MetadataViews.dictToTraits(dict: self.getMetadata().extra, excludedNames: nil)
				case Type<MetadataViews.NFTView>():
					return MetadataViews.NFTView(
						id: self.id,
						uuid: self.uuid,
						display: self.resolveView(Type<MetadataViews.Display>()) as! MetadataViews.Display?,
						externalURL: self.resolveView(Type<MetadataViews.ExternalURL>()) as! MetadataViews.ExternalURL?,
						collectionData: self.resolveView(Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?,
						collectionDisplay: self.resolveView(Type<MetadataViews.NFTCollectionDisplay>()) as! MetadataViews.NFTCollectionDisplay?,
						royalties: self.resolveView(Type<MetadataViews.Royalties>()) as! MetadataViews.Royalties?,
						traits: self.resolveView(Type<MetadataViews.Traits>()) as! MetadataViews.Traits?
					)
			}
			return nil
		}

		init(_metadataId: UInt64, _serial: UInt64, _recipient: Address) {
			pre {
				TouchstoneTestGritIron.metadatas[_metadataId] != nil:
					"This NFT does not exist yet."
				_serial < TouchstoneTestGritIron.getNFTMetadata(_metadataId)!.supply:
					"This serial does not exist for this metadataId."
				!TouchstoneTestGritIron.getNFTMetadata(_metadataId)!.purchasers.containsKey(_serial):
					"This serial has already been purchased."
			}
			self.id = self.uuid
			self.metadataId = _metadataId
			self.serial = _serial

			// Update the buyers list so we keep track of who is purchasing
			if let buyersRef = &TouchstoneTestGritIron.primaryBuyers[_recipient] as &{UInt64: [UInt64]}? {
				if let metadataIdMap = &buyersRef[_metadataId] as &[UInt64]? {
					metadataIdMap.append(_serial)
				} else {
					buyersRef[_metadataId] = [_serial]
				}
			} else {
				TouchstoneTestGritIron.primaryBuyers[_recipient] = {_metadataId: [_serial]}
			}

			// Update who bought this serial inside NFTMetadata so it cannot be purchased again.
			let metadataRef = (&TouchstoneTestGritIron.metadatas[_metadataId] as &NFTMetadata?)!
			metadataRef.purchased(serial: _serial, buyer: _recipient)

			TouchstoneTestGritIron.totalSupply = TouchstoneTestGritIron.totalSupply + 1
			emit Minted(id: self.id, recipient: _recipient, metadataId: _metadataId)
		}
	}

	pub resource Collection: NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
		// dictionary of NFT conforming tokens
		// NFT is a resource type with an 'UInt64' ID field
		pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

		// withdraw removes an NFT from the collection and moves it to the caller
		pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
			let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

			emit Withdraw(id: token.id, from: self.owner?.address)

			return <-token
		}

		// deposit takes a NFT and adds it to the collections dictionary
		// and adds the ID to the id array
		pub fun deposit(token: @NonFungibleToken.NFT) {
			let token <- token as! @NFT

			let id: UInt64 = token.id

			// add the new token to the dictionary
			self.ownedNFTs[id] <-! token

			emit Deposit(id: id, to: self.owner?.address)
		}

		// getIDs returns an array of the IDs that are in the collection
		pub fun getIDs(): [UInt64] {
			return self.ownedNFTs.keys
		}

		// borrowNFT gets a reference to an NFT in the collection
		// so that the caller can read its metadata and call its methods
		pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
			return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
		}

		pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
			let token = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
			let nft = token as! &NFT
			return nft as &AnyResource{MetadataViews.Resolver}
		}

		pub fun claim() {
			if let storage = &TouchstoneTestGritIron.nftStorage[self.owner!.address] as &{UInt64: NFT}? {
				for id in storage.keys {
					self.deposit(token: <- storage.remove(key: id)!)
				}
			}
		}

		init () {
			self.ownedNFTs <- {}
		}

		destroy() {
			destroy self.ownedNFTs
		}
	}

	// A function to mint NFTs.
	// You can only call this function if minting
	// is currently active.
	pub fun mintNFT(metadataId: UInt64, recipient: &{NonFungibleToken.Receiver}, payment: @FlowToken.Vault, serial: UInt64): UInt64 {
		pre {
			self.canMint(): "Minting is currently closed by the Administrator!"
			payment.balance == self.getPriceOfNFT(metadataId):
				"Payment does not match the price. You passed in ".concat(payment.balance.toString()).concat(" but this NFT costs ").concat(self.getPriceOfNFT(metadataId)!.toString())
		}
		let price: UFix64 = self.getPriceOfNFT(metadataId)!

		// Confirm recipient passes all verifiers
		for verifier in self.getMintVerifiers() {
			let params = {"minter": recipient.owner!.address}
			if let error = verifier.verify(params) {
				panic(error)
			}
		}

		// Handle Emerald City DAO royalty (5%)
		let EmeraldCityTreasury = getAccount(0x5643fd47a29770e7).getCapability(/public/flowTokenReceiver)
								.borrow<&FlowToken.Vault{FungibleToken.Receiver}>()!
		let emeraldCityCut: UFix64 = 0.05 * price

		// Handle royalty to user that was configured upon creation
		if let royalty = TouchstoneTestGritIron.getOptionalCollectionAttribute(key: "royalty") as! MetadataViews.Royalty? {
			royalty.receiver.borrow()!.deposit(from: <- payment.withdraw(amount: price * royalty.cut))
		}

		EmeraldCityTreasury.deposit(from: <- payment.withdraw(amount: emeraldCityCut))

		// Give the rest to the collection owner
		let paymentRecipient = self.account.getCapability(/public/flowTokenReceiver)
								.borrow<&FlowToken.Vault{FungibleToken.Receiver}>()!
		paymentRecipient.deposit(from: <- payment)

		// Mint the nft
		let nft <- create NFT(_metadataId: metadataId, _serial: serial, _recipient: recipient.owner!.address)
		let nftId: UInt64 = nft.id
		let metadata = self.getNFTMetadata(metadataId)!
		self.collectionInfo["profit"] = (self.getCollectionAttribute(key: "profit") as! UFix64) + price

		// Emit event
		emit TouchstonePurchase(id: nftId, recipient: recipient.owner!.address, metadataId: metadataId, name: metadata.name, description: metadata.description, image: metadata.image, price: price)

		// Deposit nft
		recipient.deposit(token: <- nft)

		return nftId
	}

	pub resource Administrator {
		pub fun createNFTMetadata(name: String, description: String, imagePath: String, thumbnailPath: String?, ipfsCID: String, price: UFix64?, extra: {String: AnyStruct}, supply: UInt64) {
			TouchstoneTestGritIron.metadatas[TouchstoneTestGritIron.nextMetadataId] = NFTMetadata(
				_name: name,
				_description: description,
				_image: MetadataViews.IPFSFile(
					cid: ipfsCID,
					path: imagePath
				),
				_thumbnail: thumbnailPath == nil ? nil : MetadataViews.IPFSFile(cid: ipfsCID, path: thumbnailPath),
				_price: price,
				_extra: extra,
				_supply: supply
			)
			TouchstoneTestGritIron.nextMetadataId = TouchstoneTestGritIron.nextMetadataId + 1
		}

		// mintNFT mints a new NFT and deposits
		// it in the recipients collection
		pub fun mintNFT(metadataId: UInt64, serial: UInt64, recipient: Address) {
			pre {
				EmeraldPass.isActive(user: TouchstoneTestGritIron.account.address): "You must have an active Emerald Pass subscription to airdrop NFTs. You can purchase Emerald Pass at https://pass.ecdao.org/"
			}
			let nft <- create NFT(_metadataId: metadataId, _serial: serial, _recipient: recipient)
			if let recipientCollection = getAccount(recipient).getCapability(TouchstoneTestGritIron.CollectionPublicPath).borrow<&TouchstoneTestGritIron.Collection{NonFungibleToken.CollectionPublic}>() {
				recipientCollection.deposit(token: <- nft)
			} else {
				if let storage = &TouchstoneTestGritIron.nftStorage[recipient] as &{UInt64: NFT}? {
					storage[nft.id] <-! nft
				} else {
					TouchstoneTestGritIron.nftStorage[recipient] <-! {nft.id: <- nft}
				}
			}
		}

		pub fun mintBatch(metadataIds: [UInt64], serials: [UInt64], recipients: [Address]) {
			pre {
				metadataIds.length == recipients.length: "You need to pass in an equal number of metadataIds and recipients."
			}
			var i = 0
			while i < metadataIds.length {
				self.mintNFT(metadataId: metadataIds[i], serial: serials[i], recipient: recipients[i])
				i = i + 1
			}

			emit MintBatch(metadataIds: metadataIds, recipients: recipients)
		}

		// create a new Administrator resource
		pub fun createAdmin(): @Administrator {
			return <- create Administrator()
		}

		// change piece of collection info
		pub fun changeField(key: String, value: AnyStruct) {
			TouchstoneTestGritIron.collectionInfo[key] = value
		}
	}

	// public function that anyone can call to create a new empty collection
	pub fun createEmptyCollection(): @NonFungibleToken.Collection {
		return <- create Collection()
	}

	// Get information about a NFTMetadata
	pub fun getNFTMetadata(_ metadataId: UInt64): NFTMetadata? {
		return self.metadatas[metadataId]
	}

	pub fun getNFTMetadatas(): {UInt64: NFTMetadata} {
		return self.metadatas
	}

	pub fun getPrimaryBuyers(): {Address: {UInt64: [UInt64]}} {
		return self.primaryBuyers
	}

	pub fun getCollectionInfo(): {String: AnyStruct} {
		let collectionInfo = self.collectionInfo
		collectionInfo["metadatas"] = self.metadatas
		collectionInfo["primaryBuyers"] = self.primaryBuyers
		collectionInfo["totalSupply"] = self.totalSupply
		collectionInfo["nextMetadataId"] = self.nextMetadataId
		collectionInfo["version"] = 1
		return collectionInfo
	}

	pub fun getCollectionAttribute(key: String): AnyStruct {
		return self.collectionInfo[key] ?? panic(key.concat(" is not an attribute in this collection."))
	}

	pub fun getOptionalCollectionAttribute(key: String): AnyStruct? {
		return self.collectionInfo[key]
	}

	pub fun getMintVerifiers(): [{MintVerifiers.IVerifier}] {
		return self.getCollectionAttribute(key: "mintVerifiers") as! [{MintVerifiers.IVerifier}]
	}

	pub fun canMint(): Bool {
		return self.getCollectionAttribute(key: "minting") as! Bool
	}

	// Returns nil if an NFT with this metadataId doesn't exist
	pub fun getPriceOfNFT(_ metadataId: UInt64): UFix64? {
		if let metadata: TouchstoneTestGritIron.NFTMetadata = self.getNFTMetadata(metadataId) {
			let defaultPrice: UFix64 = self.getCollectionAttribute(key: "price") as! UFix64
			if self.getCollectionAttribute(key: "lotteryBuying") as! Bool {
				return defaultPrice
			}
			return metadata.price ?? defaultPrice
		}
		// If the metadataId doesn't exist
		return nil
	}

	// Returns an mapping of `id` to NFTMetadata
	// for the NFTs a user can claim
	pub fun getClaimableNFTs(user: Address): {UInt64: NFTMetadata} {
		let answer: {UInt64: NFTMetadata} = {}
		if let storage = &TouchstoneTestGritIron.nftStorage[user] as &{UInt64: NFT}? {
			for id in storage.keys {
				let nftRef = (&storage[id] as &NFT?)!
				answer[id] = self.getNFTMetadata(nftRef.metadataId)
			}
		}
		return answer
	}

	init(
		_name: String,
		_description: String,
		_imagePath: String,
		_bannerImagePath: String?,
		_minting: Bool,
		_royalty: MetadataViews.Royalty?,
		_defaultPrice: UFix64,
		_paymentType: String,
		_ipfsCID: String,
		_lotteryBuying: Bool,
		_socials: {String: MetadataViews.ExternalURL},
		_mintVerifiers: [{MintVerifiers.IVerifier}]
	) {
		// Collection Info
		self.collectionInfo = {}
		self.collectionInfo["name"] = _name
		self.collectionInfo["description"] = _description
		self.collectionInfo["image"] = MetadataViews.IPFSFile(
			cid: _ipfsCID,
			path: _imagePath
		)
		if let bannerImagePath = _bannerImagePath {
			self.collectionInfo["bannerImage"] = MetadataViews.IPFSFile(
				cid: _ipfsCID,
				path: _bannerImagePath
			)
		}
		self.collectionInfo["ipfsCID"] = _ipfsCID
		self.collectionInfo["socials"] = _socials
		self.collectionInfo["minting"] = _minting
		self.collectionInfo["lotteryBuying"] = _lotteryBuying
		if let royalty = _royalty {
			assert(royalty.receiver.check(), message: "The passed in royalty receiver is not valid. The royalty account must set up the intended payment token.")
			assert(royalty.cut <= 0.95, message: "The royalty cut cannot be bigger than 95% because 5% goes to Emerald City treasury for primary sales.")
			self.collectionInfo["royalty"] = royalty
		}
		self.collectionInfo["price"] = _defaultPrice
		self.collectionInfo["paymentType"] = _paymentType
		self.collectionInfo["dateCreated"] = getCurrentBlock().timestamp
		self.collectionInfo["mintVerifiers"] = _mintVerifiers
		self.collectionInfo["profit"] = 0.0

		self.nextEditionId = 0
		self.nextMetadataId = 0
		self.totalSupply = 0
		self.metadatas = {}
		self.primaryBuyers = {}
		self.nftStorage <- {}

		// Set the named paths
		// We include the user's address in the paths.
		// This is to prevent clashing with existing
		// Collection paths in the ecosystem.
		self.CollectionStoragePath = /storage/TouchstoneTestGritIronCollection_0x84e5586a3fae8ff3
		self.CollectionPublicPath = /public/TouchstoneTestGritIronCollection_0x84e5586a3fae8ff3
		self.CollectionPrivatePath = /private/TouchstoneTestGritIronCollection_0x84e5586a3fae8ff3
		self.AdministratorStoragePath = /storage/TouchstoneTestGritIronAdministrator_0x84e5586a3fae8ff3

		// Create a Collection resource and save it to storage
		let collection <- create Collection()
		self.account.save(<- collection, to: self.CollectionStoragePath)

		// create a public capability for the collection
		self.account.link<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(
			self.CollectionPublicPath,
			target: self.CollectionStoragePath
		)

		// Create a Administrator resource and save it to storage
		let administrator <- create Administrator()
		self.account.save(<- administrator, to: self.AdministratorStoragePath)

		emit ContractInitialized()
	}
}
 "
-------
"import CapabilityFactory from 0xd8a7e05a7ac670c0
import FungibleToken from 0xf233dcee88fe0abe

pub contract FTProviderFactory {
    pub struct Factory: CapabilityFactory.Factory {
        pub fun getCapability(acct: &AuthAccount, path: CapabilityPath): Capability {
            return acct.getCapability<&{FungibleToken.Provider}>(path)
        }
    }
}"
-------
"// TODOs
// * check events have enough information to be useful
// * add FLOW balance checking
// * Refactor Post to a simpler set of attributes, and put Newsfeed fields in a metadata field
//      add pub let metadata: {String: [AnyStruct{FantastecSwapDataProperties.MetadataElement}]}
/*
TODO
    Use MetadataElement for all metadata properties [done]
    Reduce Post so that NewPost items are in metadata [done]
    Make Comment a resource, or have a nextCommentId on the post
    Add liker's address to commentLikes
    Should there be a limit to the number of comments? as Address will get more and more
    Should there be a limit to the number of likes? as Address will get more and more

    Check Events parameters are sufficient

    PostDetails to PostStruct, and use the same structure as with Post

*/

import FantastecSwapDataProperties from 0x4bbff461fa8f6192

pub contract SocialProfileV3 {

    pub event PostCreated           (owner: Address, postId: UInt64)
    pub event PostDestroyed         (owner: Address, postId: UInt64)
    pub event NewsFeedPostCreated   (owner: Address, postId: UInt64)
    pub event PostLiked             (owner: Address, postId: UInt64, liker: Address)
    pub event PostUnliked           (owner: Address, postId: UInt64, liker: Address)
    pub event CommentCreated        (owner: Address, postId: UInt64, commenter: Address, commentId: UInt64)
    pub event CommentDestroyed      (owner: Address, postId: UInt64, commenter: Address, commentId: UInt64)
    pub event CommentLiked          (owner: Address, postId: UInt64, commentId: UInt64, liker: Address)
    pub event CommentUnliked        (owner: Address, postId: UInt64, commentId: UInt64, liker: Address)

    pub event ProfileFollowed       (owner: Address, follower: Address)
    pub event ProfileUnfollowed     (owner: Address, follower: Address)
    pub event ProfileUpdated        (owner: Address, field: String)

    pub event Installed             (owner: Address)
    pub event Destroyed             (owner: Address)

    pub let SocialProfileStoragePath: StoragePath
    pub let SocialProfilePublicPath: PublicPath

//    access(contract) let maxCommentsPerPost: UInt64
//    access(contract) let maxPostsPerProfile: UInt64
//    access(contract) let maxFollowingPerProfile: UInt64
    access(contract) var nextCommentId: UInt64

    pub struct PostDetails {
        pub let id: UInt64
        pub let author: Address // If we don't add author here, can it be inferred in some way on chain? perhaps by event history?
        pub let content: String
        pub let image: FantastecSwapDataProperties.Media?
        pub let dateCreated: UFix64
        pub let likeCount: UInt
        pub let comments: {UInt64: Comment}
        pub var metadata: {String: [AnyStruct{FantastecSwapDataProperties.MetadataElement}]}
        // consider mirroring the minimal post and have the rest of the properties in metadata
        init(
            id: UInt64,
            author: Address,
            content: String,
            image: FantastecSwapDataProperties.Media?,
            dateCreated: UFix64,
            likeCount: UInt,
            comments: {UInt64: Comment},
            metadata: {String: [AnyStruct{FantastecSwapDataProperties.MetadataElement}]}
            ) {
            self.id = id
            self.author = author
            self.image = image
            self.content = content
            self.dateCreated = dateCreated
            self.likeCount = likeCount
            self.comments = comments
            self.metadata = metadata
        }
    }

    pub struct Comment {
        pub let id: UInt64
        pub let author: Address
        pub let content: String
        pub let dateCreated: UFix64
        pub var likeCount: Int
        pub var metadata: {String: [AnyStruct{FantastecSwapDataProperties.MetadataElement}]}

        init(id: UInt64, author: Address, content: String) {
            let dateCreated = getCurrentBlock().timestamp
            self.id = id
            self.author = author
            self.content = content
            self.dateCreated = dateCreated
            self.likeCount = 0
            self.metadata = {}
        }

        access(contract) fun incrementLike() {
            self.likeCount = self.likeCount + 1
        }

        access(contract) fun decrementLike() {
            if self.likeCount == 0 {
                panic("Cannot unlike as likeCount already 0")
            }
            self.likeCount = self.likeCount - 1
        }
    }

    pub struct Profile {
        pub let avatar: String
        pub let username: String
        pub let name: String
        pub let bio: String
        pub let coverMedia: FantastecSwapDataProperties.Media?
        pub let following: {Address: Bool}
        pub let followers : Int
        pub var metadata: {String: [AnyStruct{FantastecSwapDataProperties.MetadataElement}]}
        init(
            avatar: String,
            bio: String,
            name: String,
            username: String,
            coverMedia: FantastecSwapDataProperties.Media?,
            following: {Address: Bool},
            followers: Int,
            metadata: {String: [AnyStruct{FantastecSwapDataProperties.MetadataElement}]}
        ) {
            self.avatar = avatar
            self.bio = bio
            self.name = name
            self.username = username
            self.coverMedia = coverMedia
            self.following = following
            self.followers = followers
            self.metadata = metadata
        }
    }

    pub resource Post {
        pub let id: UInt64
        pub let author: Address
        pub let content: String
        pub let image: FantastecSwapDataProperties.Media?
        pub let dateCreated: UFix64
        pub var likeCount: Int // should this be access(contract)? Can someone else change this value?
        pub let comments: {UInt64: Comment}
        pub var metadata: {String: [AnyStruct{FantastecSwapDataProperties.MetadataElement}]} // should this be access(contract)? Can someone else change this value?

        init(content: String, author: Address, image: FantastecSwapDataProperties.Media?) {
            self.id = self.uuid
            self.image = image
            self.author = author
            self.content = content
            self.dateCreated = getCurrentBlock().timestamp
            self.likeCount = 0
            self.comments = {}
            self.metadata = {}
        }

        /* Post Likes */
        access(contract) fun incrementLike() {
            self.likeCount = self.likeCount + 1
        }

        access(contract) fun decrementLike() {
            if self.likeCount == 0 {
                panic("Cannot unlike as likeCount already 0")
            }
            self.likeCount = self.likeCount - 1
        }

        /* Comments */
        access(contract) fun getComment(_ commentId: UInt64): Comment? {
            let comment = self.comments[commentId]
            return comment
        }

       access(contract) fun addComment(comment: Comment) {
            let id = comment.id
            self.comments[id] = comment
        }

        access(contract) fun removeComment(comment: Comment) {
            let id = comment.id
            self.comments.remove(key: id)
        }

        /* Comment Likes */
        access(contract) fun likeComment(_ commentId: UInt64) {
            let comment = self.comments[commentId] ?? panic("Comment does not exist with that id")
            comment.incrementLike()
            self.comments[commentId] = comment
        }

        access(contract) fun unlikeComment(_ commentId: UInt64) {
            let comment = self.comments[commentId] ?? panic("Comment does not exist with that id")
            comment.decrementLike()
            self.comments[commentId] = comment
        }

        /* Metadata */
        access(contract) fun addMetadata(
        _ type: String,
        _ metadata: AnyStruct{FantastecSwapDataProperties.MetadataElement},
        ) {
            if (self.metadata[type] == nil) {
                self.metadata[type] = []
            }
            self.metadata[type] = FantastecSwapDataProperties.addToMetadata(type, self.metadata[type]!, metadata)
        }

        access(contract) fun removeMetadata(
        _ type: String,
        _ id: UInt64?,
        ) {
            if (self.metadata[type] == nil) {
                self.metadata[type] = []
            }
            self.metadata[type] = FantastecSwapDataProperties.removeFromMetadata(type, self.metadata[type]!, id)
        }
    }

    pub resource interface SocialProfilePublic {
        pub fun borrowPost(_ id: UInt64): &Post?
        pub fun getPostIds(): [UInt64]
        pub fun getLikedPosts(): [UInt64]
        pub fun getAvatar(): String
        pub fun getBio(): String
        pub fun getCoverMedia(): FantastecSwapDataProperties.Media?
        pub fun getUsername(): String
        pub fun getName(): String
        pub fun getFollowing(): {Address:Bool}
        pub fun getFollowersCount(): Int
        pub fun getMetadata(): {String: [AnyStruct{FantastecSwapDataProperties.MetadataElement}]} // pub let metadata: {String: [AnyStruct{FantastecSwapDataProperties.MetadataElement}]}
        access(contract) fun incrementFollower() // care to explain why it's like this? by access(contract) in public interface?
        access(contract) fun decrementFollower() // this permits another SP to call someone else's SP, but (contract) permits only the contract to call it
    }

    pub resource interface SocialProfilePrivate {
        pub fun addMetadata(_ type: String, _ metadata: AnyStruct{FantastecSwapDataProperties.MetadataElement})
        pub fun createComment(theirAddress: Address, postId: UInt64, content: String)
        pub fun createPost(content: String, image: FantastecSwapDataProperties.Media?)
        pub fun createNewsFeedPost(content: String, title: String, publishedDate: UFix64, image: FantastecSwapDataProperties.Media?, buttonUrl: String, buttonText: String)
        pub fun deleteComment(theirAddress: Address, postId: UInt64, commentId: UInt64)
        pub fun follow(theirAddress: Address)
        pub fun likeComment(theirAddress: Address, postId: UInt64, commentId: UInt64)
        pub fun likePost(theirAddress: Address, id: UInt64)
        pub fun removeMetadata(_ type: String, _ id: UInt64?)
        pub fun removePost(_ id: UInt64)
        pub fun setAvatar(avatar: String)
        pub fun setBio(bio: String)
        pub fun setName(name: String)
        pub fun setUsername(username: String)
        pub fun setCoverMedia(media: FantastecSwapDataProperties.Media?)
        pub fun unfollow(theirAddress: Address)
        pub fun unlikeComment(theirAddress: Address, postId: UInt64, commentId: UInt64)
        pub fun unlikePost(theirAddress: Address, id: UInt64)
    }

    pub resource SocialProfile: SocialProfilePrivate, SocialProfilePublic {
        access(self) var posts: @{UInt64: Post}
        access(self) var likedPosts: {UInt64:Bool}
        access(self) var likedComments: {UInt64: Bool}
        access(self) var avatar: String
        access(self) var bio: String
        access(self) var name: String
        access(self) var username: String
        access(self) var coverMedia: FantastecSwapDataProperties.Media?
        access(self) var followers: Int
        access(self) var following: {Address: Bool}
        access(self) var metadata: {String: [AnyStruct{FantastecSwapDataProperties.MetadataElement}]}

        /* Profile Getters */
        pub fun getAvatar(): String {
            return self.avatar
        }
        pub fun getBio(): String {
            return self.bio
        }
        pub fun getMetadata(): {String: [AnyStruct{FantastecSwapDataProperties.MetadataElement}]} {
            return self.metadata
        }
        pub fun getCoverMedia(): FantastecSwapDataProperties.Media? {
            return self.coverMedia
        }
        pub fun getUsername(): String {
            return self.username
        }
        pub fun getName(): String {
            return self.name
        }

        /* Profile Setters */
        access(contract) fun emitUpdateEvent(_ field: String) {
            emit ProfileUpdated(owner: self.owner!.address, field: field)
        }
        pub fun setAvatar(avatar: String) {
            self.avatar = avatar
            self.emitUpdateEvent("avatar")
        }
        pub fun setBio(bio: String) {
            self.bio = bio
            self.emitUpdateEvent("bio")
        }
        pub fun setUsername(username: String) {
            self.username = username
            self.emitUpdateEvent("username")
        }
        pub fun setCoverMedia(media: FantastecSwapDataProperties.Media?) {
            self.coverMedia = media
            self.emitUpdateEvent("coverMedia")
        }
        pub fun setName(name: String) {
            self.name = name
            self.emitUpdateEvent("name")
        }

        /* Follow */
        pub fun getFollowing(): {Address:Bool} {
            return self.following
        }
        pub fun getFollowersCount(): Int {
            return self.followers
        }
        pub fun follow(theirAddress: Address) {
            if self.following[theirAddress] == true  {
                panic("You already follow this profile")
            }

            if self.owner!.address == theirAddress {
                panic("You cannot follow your own profile")
            }

            let socialProfileRef = getAccount(theirAddress).getCapability<&SocialProfileV3.SocialProfile{SocialProfileV3.SocialProfilePublic}>(SocialProfileV3.SocialProfilePublicPath).borrow()!
            let theirAccount = socialProfileRef.incrementFollower()

            self.following[theirAddress] = true
            emit ProfileFollowed(owner: self.owner!.address, follower: theirAddress)
        }
        pub fun unfollow(theirAddress: Address) {
            if self.following[theirAddress] == nil {
                panic("You can not unfollow as you do not follow profile")
            }
            let socialProfileRef = getAccount(theirAddress).getCapability<&SocialProfileV3.SocialProfile{SocialProfileV3.SocialProfilePublic}>(SocialProfileV3.SocialProfilePublicPath).borrow()!
            let theirAccount = socialProfileRef.decrementFollower()

            self.following.remove(key: theirAddress)
            emit ProfileUnfollowed(owner: self.owner!.address, follower: theirAddress)
        }

        /* Posts */
        pub fun createPost(content: String, image: FantastecSwapDataProperties.Media?) {
            let post <- create Post(
                content: content,
                author: self.owner!.address,
                image: image
            )
            emit PostCreated(owner: self.owner!.address, postId: post.id)
            self.posts[post.id] <-! post
        }
        pub fun createNewsFeedPost(content: String, title: String, publishedDate: UFix64, image: FantastecSwapDataProperties.Media?, buttonUrl: String, buttonText: String) {
            let post <- create Post(
                content: content,
                author: self.owner!.address,
                image: image
            )
            let metadataItemId: UInt64 = 1
            let metadata = FantastecSwapDataProperties.NewsFeed(metadataItemId, title, publishedDate, buttonUrl, buttonText)
            post.addMetadata("NewsFeed", metadata)
            emit NewsFeedPostCreated(owner: self.owner!.address, postId: post.id)
            let oldPost <- self.posts[post.id] <-! post
            destroy oldPost
        }
        pub fun borrowPost(_ id: UInt64): &Post? {
            return (&self.posts[id] as &Post?)
        }
        pub fun removePost(_ id: UInt64) {
            let post <- self.posts.remove(key: id) ?? panic("Post with that id does not exist")
            emit PostDestroyed(owner: self.owner!.address, postId: post.id)
            destroy post
        }
        pub fun likePost(theirAddress: Address, id: UInt64) {
            if self.likedPosts[id] == true {
                panic("You already liked this post")
            }
            let socialProfileRef = getAccount(theirAddress).getCapability<&SocialProfileV3.SocialProfile{SocialProfileV3.SocialProfilePublic}>(SocialProfileV3.SocialProfilePublicPath).borrow()!
            let theirPost = socialProfileRef.borrowPost(id) ?? panic("Post does not exist with that id")
            theirPost.incrementLike()
            self.likedPosts[id] = true
            emit PostLiked(owner: theirAddress, postId: id, liker: self.owner!.address)
        }
        pub fun unlikePost(theirAddress: Address, id: UInt64) {
            if self.likedPosts[id] == false ||  self.likedPosts[id] == nil {
                panic("Post cannot be unliked as it was not previously liked")
            }
            let socialProfileRef = getAccount(theirAddress).getCapability<&SocialProfileV3.SocialProfile{SocialProfileV3.SocialProfilePublic}>(SocialProfileV3.SocialProfilePublicPath).borrow()!
            let theirPost = socialProfileRef.borrowPost(id) ?? panic("Post does not exist with that id")
            theirPost.decrementLike()
            self.likedPosts.remove(key:id)
            emit PostUnliked(owner: theirAddress, postId: id, liker: self.owner!.address)
        }
        pub fun getLikedPosts(): [UInt64] {
            return self.likedPosts.keys
        }
        pub fun getPostIds(): [UInt64] {
            return self.posts.keys
        }

        /* Comments */
        pub fun createComment(theirAddress: Address, postId: UInt64, content: String) {
            let socialProfileRef = getAccount(theirAddress).getCapability<&SocialProfileV3.SocialProfile{SocialProfileV3.SocialProfilePublic}>(SocialProfileV3.SocialProfilePublicPath).borrow()!
            let theirPost = socialProfileRef.borrowPost(postId) ?? panic("Post does not exist with that id")

            let commentId = SocialProfileV3.nextCommentId
            SocialProfileV3.nextCommentId = SocialProfileV3.nextCommentId + 1

            let comment = Comment(id: commentId, author: self.owner!.address, content: content)
            theirPost.addComment(comment: comment)

            emit CommentCreated(owner: theirAddress, postId: theirPost.id, commenter: self.owner!.address, commentId: commentId)
        }

        pub fun deleteComment(theirAddress: Address, postId: UInt64, commentId: UInt64){
            let socialProfileRef = getAccount(theirAddress).getCapability<&SocialProfileV3.SocialProfile{SocialProfileV3.SocialProfilePublic}>(SocialProfileV3.SocialProfilePublicPath).borrow()!
            let theirPost = socialProfileRef.borrowPost(postId) ?? panic("Post does not exist with that id")
            let _comment: Comment? = theirPost.getComment(commentId)
            // check comment exists
            if _comment == nil {
                log("comment not found")
                return
            }
            let comment: Comment = _comment!
            if comment.author != self.owner!.address {
                panic("Comment was not created by you")
            }
            theirPost.removeComment(comment: comment)
            emit CommentDestroyed(owner: theirAddress, postId: theirPost.id, commenter: self.owner!.address, commentId: commentId)
        }

        pub fun likeComment(theirAddress: Address, postId: UInt64, commentId: UInt64) {
            if self.likedComments[commentId] == true {
                panic("You already liked this comment")
            }
            let socialProfileRef = getAccount(theirAddress).getCapability<&SocialProfileV3.SocialProfile{SocialProfileV3.SocialProfilePublic}>(SocialProfileV3.SocialProfilePublicPath).borrow()!
            let theirPost: &Post = socialProfileRef.borrowPost(postId) ?? panic("Post does not exist with that id")
            // Call the method to like the comment within the post
            theirPost.likeComment(commentId)
            self.likedComments.insert(key: commentId, true)
            emit CommentLiked(owner: theirAddress, postId: postId, commentId: commentId, liker: self.owner!.address)
        }

        pub fun unlikeComment(theirAddress: Address, postId: UInt64, commentId: UInt64) {
             if self.likedComments[commentId] == nil {
                panic("You havent liked this comment so you can not unlike")
            }
            let socialProfileRef = getAccount(theirAddress).getCapability<&SocialProfileV3.SocialProfile{SocialProfileV3.SocialProfilePublic}>(SocialProfileV3.SocialProfilePublicPath).borrow()!
            let theirPost = socialProfileRef.borrowPost(postId) ?? panic("Post does not exist with that id")
            theirPost.unlikeComment(commentId)
            self.likedComments.remove(key: commentId)
            emit CommentUnliked(owner: theirAddress, postId: postId, commentId: commentId, liker: self.owner!.address)
        }

        /* Internal Contract Mutators */
        access(contract) fun incrementFollower() {
           self.followers = self.followers + 1
        }

        access(contract) fun decrementFollower() {
            if self.followers > 0 {
                self.followers = self.followers - 1
            } else {
                panic("Follower count cannot be less than zero")
            }
        }

        /* Metadata */
        pub fun addMetadata(
        _ type: String,
        _ metadata: AnyStruct{FantastecSwapDataProperties.MetadataElement},
        ) {
            if (self.metadata[type] == nil) {
                self.metadata[type] = []
            }
            self.metadata[type] = FantastecSwapDataProperties.addToMetadata(type, self.metadata[type]!, metadata)
            self.emitUpdateEvent("metadata add - ".concat(type))
        }

        pub fun removeMetadata(
        _ type: String,
        _ id: UInt64?,
        ) {
            if (self.metadata[type] == nil) {
                self.metadata[type] = []
            }
            self.metadata[type] = FantastecSwapDataProperties.removeFromMetadata(type, self.metadata[type]!, id)
            self.emitUpdateEvent("metadata remove - ".concat(type))
        }

        destroy() {
            let posts <- self.posts
            destroy posts
        }

        pub fun emitInstalledEvent() {
            emit Installed(owner: self.owner!.address)
        }

        pub fun emitDestroyedEvent(_ address: Address) {
            emit Destroyed(owner: address)
        }

        init() {
            self.posts <- {}
            self.likedPosts = {}
            self.likedComments = {}
            self.avatar = ""
            self.bio = ""
            self.followers = 0
            self.following = {}
            self.metadata = {}
            self.username = ""
            self.name = ""
            self.coverMedia = nil
        }
    }

    pub fun createSocialProfile(): @SocialProfile {
        return <-create SocialProfile()
    }

    init() {
        self.SocialProfileStoragePath = /storage/SocialProfile
        self.SocialProfilePublicPath = /public/SocialProfile
        self.nextCommentId = 1
    }
}
"
-------
"pub contract RoyaltEffects {

    pub resource NFT {
        pub var price: UFix64

        init(price: UFix64) { self.price = price }

        pub fun enableRoyalty(expectedTotalRoyalty: UFix64) {
            self.price = self.price - expectedTotalRoyalty
        }
    }

    pub fun createNFT(price: UFix64): @NFT {
        return <- create NFT(price: price)
    }
}
"
-------
"import MetadataViews from 0x1d7e57aa55817448
import NonFungibleToken from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import StringUtils from 0xe52522745adf5c34

access(all) contract Utils {

    /// StorableNFTCollectionData
    /// This struct copies MetadataViews.NFTCollectionData without the createEmptyCollection reference to be storable.
    access(all) struct StorableNFTCollectionData {
        pub let storagePath: StoragePath
        pub let publicPath: PublicPath
        pub let providerPath: PrivatePath
        pub let publicCollection: Type
        pub let publicLinkedType: Type
        pub let providerLinkedType: Type

        init(_ collectionData: MetadataViews.NFTCollectionData) {
            self.storagePath = collectionData.storagePath
            self.publicPath = collectionData.publicPath
            self.providerPath = collectionData.providerPath
            self.publicCollection = collectionData.publicCollection
            self.publicLinkedType = collectionData.publicLinkedType
            self.providerLinkedType = collectionData.providerLinkedType
        }
    }

    /// ContractMetadata
    /// This struct holds all relevant metadata for a given contract type.
    access(all) struct ContractMetadata {
        pub let type: Type
        pub let address: String
        pub let name: String
        pub let context: {String: String}?

        init(type: Type, context: {String: String}?) {
            let parts = StringUtils.split(type.identifier, ".")

            self.type = type
            self.address = "0x".concat(parts[1])
            self.name = parts[2]
            self.context = context
        }
    }

    /// getIdentifierContractMetadata
    /// This helper function returns the contract metadata for a given type identifier.
    access(all) fun getIdentifierContractMetadata(identifier: String): ContractMetadata {

    	return ContractMetadata(type: Utils.getIdentifierContractType(identifier: identifier), context: nil)
    }

    /// getIdentifierContractType
    /// This helper function returns the contract type for a given type identifier.
    access(all) fun getIdentifierContractType(identifier: String): Type {

        let parts = StringUtils.split(identifier, ".")

        assert(parts.length == 4, message: "invalid identifier")

        let contractIdentifier = StringUtils.join(parts.slice(from: 0, upTo: parts.length - 1), ".")

        return CompositeType(contractIdentifier)!
    }

    /// getCollectionPaths
    /// This function searches the specified account and returns a dictionary of NFTCollectionData structs by
    /// collectionIdentifier. If a collectionIdentifier is not found in the specified ownerAddress, or that collection
    /// does not provide a resolver for NFTCollectionData, the response value will be "nil".
    access(all) fun getNFTCollectionData(ownerAddress: Address, nftIdentifiers: [String]): {String: MetadataViews.NFTCollectionData} {

        let response: {String: MetadataViews.NFTCollectionData} = {}

        let account = getAccount(ownerAddress)

        account.forEachPublic(fun (path: PublicPath, type: Type): Bool {

            let collectionPublic = account.getCapability<&{NonFungibleToken.CollectionPublic}>(path).borrow()
    	    if (collectionPublic == nil) {

    		    return true
    	    }

            let contractType = Utils.getIdentifierContractType(identifier: collectionPublic!.getType().identifier)
            let nftIdentifier = contractType.identifier.concat(".NFT")

    		if (!nftIdentifiers.contains(nftIdentifier) || response.containsKey(nftIdentifier)) {

    		    return true
    	    }

            let nftIds = collectionPublic!.getIDs()
            if (nftIds.length < 1) {

                return true
            }

            let nftRef: &{NonFungibleToken.INFT} = collectionPublic!.borrowNFT(id: nftIds[0]) as &{NonFungibleToken.INFT}

            let collectionData = (nftRef.resolveView(Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?)
                ?? panic("collection lookup failed")

            response.insert(key: nftIdentifier, collectionData)

            return true
        })

    	return response
    }
}
"
-------
"/*
SwaychainToknd

This is the contract for SwaychainToknd NFTs!

This was implemented using Niftory interfaces. For full details on how this
contract functions, please see the Niftory and NFTRegistry contracts.

*/

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import ViewResolver from 0x1d7e57aa55817448

import MutableMetadata from 0x7ec1f607f0872a9e
import MutableMetadataTemplate from 0x7ec1f607f0872a9e
import MutableMetadataSet from 0x7ec1f607f0872a9e
import MutableMetadataSetManager from 0x7ec1f607f0872a9e
import MetadataViewsManager from 0x7ec1f607f0872a9e

import NiftoryNonFungibleToken from 0x7ec1f607f0872a9e
import NiftoryNFTRegistry from 0x7ec1f607f0872a9e

import NiftoryMetadataViewsResolvers from 0x7ec1f607f0872a9e
import NiftoryNonFungibleTokenProxy from 0x7ec1f607f0872a9e

pub contract SwaychainToknd: NonFungibleToken, ViewResolver {

  // ========================================================================
  // Constants
  // ========================================================================

  // Suggested paths where collection could be stored
  pub let COLLECTION_PRIVATE_PATH: PrivatePath
  pub let COLLECTION_PUBLIC_PATH: PublicPath
  pub let COLLECTION_STORAGE_PATH: StoragePath

  // Accessor token to be used with NiftoryNFTRegistry to retrieve
  // meta-information about this NFT project
  pub let REGISTRY_ADDRESS: Address
  pub let REGISTRY_BRAND: String

  // ========================================================================
  // Attributes
  // ========================================================================

  // Arbitrary metadata for this NFT contract
  pub var metadata: AnyStruct?

  // Number of NFTs created
  pub var totalSupply: UInt64

  // ========================================================================
  // Contract Events
  // ========================================================================

  // This contract was initialized
  pub event ContractInitialized()

  // A withdrawal of NFT `id` has occurred from the `from` Address
  pub event Withdraw(id: UInt64, from: Address?)

  // A deposit of an NFT `id` has occurred to the `to` Address
  pub event Deposit(id: UInt64, to: Address?)

  ///////////////////////////////////////////////////////////////////////////

  // Contract metadata was modified
  pub event ContractMetadataUpdated()

  // Metadata Views Manager was locked
  pub event MetadataViewsManagerLocked()

  // Metadata Views Resolver was added
  pub event MetadataViewsResolverAdded(type: Type)

  // Metadata Views Resolver was removed
  pub event MetadataViewsResolverRemoved(type: Type)

  // Set Manager Name or Description updated
  pub event SetManagerMetadataUpdated()

  // Set added to Set Manager
  pub event SetAddedToSetManager(setID: Int)

  ///////////////////////////////////////////////////////////////////////////

  // Set `setId` was locked (no new templates can be added)
  pub event SetLocked(setId: Int)

  // The metadata for Set `setId` was locked and cannot be modified
  pub event SetMetadataLocked(setId: Int)

  // Set `setId` was modified
  pub event SetMetadataModified(setId: Int)

  // A new Template `templateId` was added to Set `setId`
  pub event TemplateAddedToSet(setId: Int, templateId: Int)

  ///////////////////////////////////////////////////////////////////////////

  // Template `templateId` was locked in Set `setId`, which disables minting
  pub event TemplateLocked(setId: Int, templateId: Int)

  // Template `templateId` of Set `setId` had it's maxMint set to `maxMint`
  pub event TemplateMaxMintSet(setId: Int, templateId: Int, maxMint: UInt64)

  // Template `templateId` of Set `setId` has minted NFT with serial `serial`
  pub event NFTMinted(id: UInt64, setId: Int, templateId: Int, serial: UInt64)

  ///////////////////////////////////////////////////////////////////////////

  // The metadata for NFT/Template `templateId` of Set `setId` was locked
  pub event NFTMetadataLocked(setId: Int, templateId: Int)

  // The metadata for NFT/Template `templateId` of Set `setId` was modified
  pub event NFTMetadataModified(setId: Int, templateId: Int)

  ///////////////////////////////////////////////////////////////////////////

  // NFT `serial` from Template `templateId` of Set `setId` was burned
  pub event NFTBurned(setId: Int, templateId: Int, serial: UInt64)

  // ========================================================================
  // NFT
  // ========================================================================

  pub resource NFT:
    NonFungibleToken.INFT,
    MetadataViews.Resolver,
    NiftoryNonFungibleToken.NFTPublic
  {
    pub let id: UInt64
    pub let setId: Int
    pub let templateId: Int
    pub let serial: UInt64

    pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
      return SwaychainToknd.contract()
    }

    pub fun set(): &MutableMetadataSet.Set{MutableMetadataSet.Public} {
      return self
        .contract()
        .getSetManagerPublic()
        .getSet(self.setId)
    }

    pub fun metadata(): &MutableMetadata.Metadata{MutableMetadata.Public} {
      return self
        .set()
        .getTemplate(self.templateId)
        .metadata()
    }

    pub fun getViews(): [Type] {
      return self
        .contract()
        .getMetadataViewsManagerPublic()
        .getViews()
    }

    pub fun resolveView(_ view: Type): AnyStruct? {
      let nftRef = &self as &{NiftoryNonFungibleToken.NFTPublic}
      return self
        .contract()
        .getMetadataViewsManagerPublic()
        .resolveView(view: view, nftRef: nftRef)
    }

    init(setId: Int, templateId: Int, serial: UInt64) {
      self.id = SwaychainToknd.totalSupply
      SwaychainToknd.totalSupply =
        SwaychainToknd.totalSupply + 1
      self.setId = setId
      self.templateId = templateId
      self.serial = serial
    }

    destroy() {
      emit NFTBurned(
        setId: self.setId,
        templateId: self.templateId,
        serial: self.serial
      )
    }
  }

  // ========================================================================
  // Collection
  // ========================================================================

  pub resource Collection:
    NonFungibleToken.Provider,
    NonFungibleToken.Receiver,
    NonFungibleToken.CollectionPublic,
    MetadataViews.ResolverCollection,
    NiftoryNonFungibleToken.CollectionPublic,
    NiftoryNonFungibleToken.CollectionPrivate
  {
    pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

    pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
      return SwaychainToknd.contract()
    }

    pub fun getIDs(): [UInt64] {
      return self.ownedNFTs.keys
    }

    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
      pre {
        self.ownedNFTs[id] != nil : "NFT "
          .concat(id.toString())
          .concat(" does not exist in collection.")
      }
      return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
    }

    pub fun borrow(id: UInt64): &NFT{NiftoryNonFungibleToken.NFTPublic} {
      pre {
        self.ownedNFTs[id] != nil : "NFT does not exist in collection."
      }
      let nftRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let fullNft = nftRef as! &NFT
      return fullNft
    }

    pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {
      pre {
        self.ownedNFTs[id] != nil : "NFT does not exist in collection."
      }
      let nftRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let fullNft = nftRef as! &NFT
      return fullNft
    }

    pub fun deposit(token: @NonFungibleToken.NFT) {
      let token <- token as! @SwaychainToknd.NFT
      let id: UInt64 = token.id
      let oldToken <- self.ownedNFTs[id] <- token
      emit Deposit(id: id, to: self.owner?.address)
      destroy oldToken
    }

    pub fun depositBulk(tokens: @[NonFungibleToken.NFT]) {
      while tokens.length > 0 {
        let token <- tokens.removeLast() as! @SwaychainToknd.NFT
        self.deposit(token: <-token)
      }
      destroy tokens
    }

    pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
      pre {
        self.ownedNFTs[withdrawID] != nil
          : "NFT "
            .concat(withdrawID.toString())
            .concat(" does not exist in collection.")
      }
      let token <-self.ownedNFTs.remove(key: withdrawID)!
      emit Withdraw(id: token.id, from: self.owner?.address)
      return <-token
    }

    pub fun withdrawBulk(withdrawIDs: [UInt64]): @[NonFungibleToken.NFT] {
      let tokens: @[NonFungibleToken.NFT] <- []
      while withdrawIDs.length > 0 {
        tokens.append(<- self.withdraw(withdrawID: withdrawIDs.removeLast()))
      }
      return <-tokens
    }

    init() {
      self.ownedNFTs <- {}
    }

    destroy() {
      destroy self.ownedNFTs
    }
  }

  pub fun createEmptyCollection(): @Collection {
    return <-create Collection()
  }

  // ========================================================================
  // Manager
  // ========================================================================

  pub resource Manager:
    NiftoryNonFungibleToken.ManagerPublic,
    NiftoryNonFungibleToken.ManagerPrivate
  {
    // ========================================================================
    // Public
    // ========================================================================

    pub fun metadata(): AnyStruct? {
      return SwaychainToknd.metadata
    }

    pub fun getSetManagerPublic():
      &MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public}
    {
      return NiftoryNFTRegistry
        .getSetManagerPublic(
          SwaychainToknd.REGISTRY_ADDRESS,
          SwaychainToknd.REGISTRY_BRAND
        )
    }

    pub fun getMetadataViewsManagerPublic():
      &MetadataViewsManager.Manager{MetadataViewsManager.Public}
    {
      return NiftoryNFTRegistry
        .getMetadataViewsManagerPublic(
          SwaychainToknd.REGISTRY_ADDRESS,
          SwaychainToknd.REGISTRY_BRAND
        )
    }

    pub fun getNFTCollectionData(): MetadataViews.NFTCollectionData {
      return NiftoryNFTRegistry
        .buildNFTCollectionData(
          SwaychainToknd.REGISTRY_ADDRESS,
          SwaychainToknd.REGISTRY_BRAND,
          (fun (): @NonFungibleToken.Collection {
            return <-SwaychainToknd.createEmptyCollection()
          })
        )
    }

    // ========================================================================
    // Contract metadata
    // ========================================================================

    pub fun modifyContractMetadata(): auth &AnyStruct {
      emit ContractMetadataUpdated()
      let maybeMetadata = SwaychainToknd.metadata
      if maybeMetadata == nil {
        let blankMetadata: {String: String} = {}
        SwaychainToknd.metadata = blankMetadata
      }
      return (&SwaychainToknd.metadata as auth &AnyStruct?)!
    }

    pub fun replaceContractMetadata(_ metadata: AnyStruct?) {
      emit ContractMetadataUpdated()
      SwaychainToknd.metadata = metadata
    }

    // ========================================================================
    // Metadata Views Manager
    // ========================================================================

    access(self) fun _getMetadataViewsManagerPrivate():
      &MetadataViewsManager.Manager{MetadataViewsManager.Private}
    {
      let record =
        NiftoryNFTRegistry.getRegistryRecord(
          SwaychainToknd.REGISTRY_ADDRESS,
          SwaychainToknd.REGISTRY_BRAND
        )
      let manager =
        SwaychainToknd.account
          .getCapability<&MetadataViewsManager.Manager{MetadataViewsManager.Private}>(
            record.metadataViewsManager.paths.private
          ).borrow()!
      return manager
    }

    pub fun lockMetadataViewsManager() {
      self._getMetadataViewsManagerPrivate().lock()
      emit MetadataViewsManagerLocked()
    }

    pub fun setMetadataViewsResolver(
      _ resolver: AnyStruct{MetadataViewsManager.Resolver}
    ) {
      self._getMetadataViewsManagerPrivate().addResolver(resolver)
      emit MetadataViewsResolverAdded(type: resolver.type)
    }

    pub fun removeMetadataViewsResolver(_ type: Type) {
      self._getMetadataViewsManagerPrivate().removeResolver(type)
      emit MetadataViewsResolverRemoved(type: type)
    }

    // ========================================================================
    // Set Manager
    // ========================================================================

    access(self) fun _getSetManagerPrivate():
      &MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public, MutableMetadataSetManager.Private}
    {
      let record =
        NiftoryNFTRegistry.getRegistryRecord(
          SwaychainToknd.REGISTRY_ADDRESS,
          SwaychainToknd.REGISTRY_BRAND
        )
      let setManager =
        SwaychainToknd.account
          .getCapability<&MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public, MutableMetadataSetManager.Private}>(
            record.setManager.paths.private
          ).borrow()!
      return setManager
    }

    pub fun setMetadataManagerName(_ name: String) {
      self._getSetManagerPrivate().setName(name)
      emit SetManagerMetadataUpdated()
    }

    pub fun setMetadataManagerDescription(_ description: String) {
      self._getSetManagerPrivate().setDescription(description)
      emit SetManagerMetadataUpdated()
    }

    pub fun addSet(_ set: @MutableMetadataSet.Set) {
      let setManager = self._getSetManagerPrivate()
      let setId = setManager.numSets()
      setManager.addSet(<-set)
      emit SetAddedToSetManager(setID: setId)
    }

    // ========================================================================
    // Set
    // ========================================================================

    access(self) fun _getSetMutable(_ setId: Int):
      &MutableMetadataSet.Set{MutableMetadataSet.Private,
        MutableMetadataSet.Public} {
      return self._getSetManagerPrivate().getSetMutable(setId)
    }

    pub fun lockSet(setId: Int) {
      self._getSetMutable(setId).lock()
      emit SetLocked(setId: setId)
    }

    pub fun lockSetMetadata(setId: Int) {
      self._getSetMutable(setId).metadataMutable().lock()
      emit SetMetadataLocked(setId: setId)
    }

    pub fun modifySetMetadata(setId: Int): auth &AnyStruct {
      emit SetMetadataModified(setId: setId)
      return self._getSetMutable(setId).metadataMutable().getMutable()
    }

    pub fun replaceSetMetadata(setId: Int, new: AnyStruct) {
      self._getSetMutable(setId).metadataMutable().replace(new)
      emit SetMetadataModified(setId: setId)
    }

    pub fun addTemplate(
      setId: Int,
      template: @MutableMetadataTemplate.Template
    ) {
      let set = self._getSetMutable(setId)
      let templateId = set.numTemplates()
      set.addTemplate(<-template)
      emit TemplateAddedToSet(setId: setId, templateId: templateId)
    }

    // ========================================================================
    // Minting
    // ========================================================================

    access(self) fun _getTemplateMutable(_ setId: Int, _ templateId: Int):
      &MutableMetadataTemplate.Template{MutableMetadataTemplate.Public,
        MutableMetadataTemplate.Private} {
      return self._getSetMutable(setId).getTemplateMutable(templateId)
    }

    pub fun lockTemplate(setId: Int, templateId: Int) {
      self._getTemplateMutable(setId, templateId).lock()
      emit TemplateLocked(setId: setId, templateId: templateId)
    }

    pub fun setTemplateMaxMint(setId: Int, templateId: Int, max: UInt64) {
      self._getTemplateMutable(setId, templateId).setMaxMint(max)
      emit TemplateMaxMintSet(
        setId: setId,
        templateId: templateId,
        maxMint: max
      )
    }

    pub fun mint(setId: Int, templateId: Int): @NonFungibleToken.NFT {
      let template = self._getTemplateMutable(setId, templateId)
      template.registerMint()
      let serial = template.minted()
      let nft <-create NFT(
        setId: setId,
        templateId: templateId,
        serial: serial
      )
      emit NFTMinted(
        id: nft.id,
        setId: setId,
        templateId: templateId,
        serial: serial
      )
      return <-nft
    }

    pub fun mintBulk(
      setId: Int,
      templateId: Int,
      numToMint: UInt64,
    ): @[NonFungibleToken.NFT] {
      pre {
        numToMint > 0: "Must mint at least one NFT"
      }
      let template = self._getTemplateMutable(setId, templateId)
      let nfts: @[NonFungibleToken.NFT] <- []
      var leftToMint = numToMint
      while leftToMint > 0 {
        template.registerMint()
        let serial = template.minted()
        let nft <-create NFT(
          setId: setId,
          templateId: templateId,
          serial: serial
        )
        emit NFTMinted(
          id: nft.id,
          setId: setId,
          templateId: templateId,
          serial: serial
        )
        nfts.append(<-nft)
        leftToMint = leftToMint - 1
      }
      return <-nfts
    }

    // ========================================================================
    // NFT metadata
    // ========================================================================

    access(self) fun _getNFTMetadata(_ setId: Int, _ templateId: Int):
      &MutableMetadata.Metadata{MutableMetadata.Public,
        MutableMetadata.Private
      } {
        return self._getTemplateMutable(setId, templateId).metadataMutable()
    }

    pub fun lockNFTMetadata(setId: Int, templateId: Int) {
      self._getNFTMetadata(setId, templateId).lock()
      emit NFTMetadataLocked(setId: setId, templateId: templateId)
    }

    pub fun modifyNFTMetadata(setId: Int, templateId: Int): auth &AnyStruct {
      emit NFTMetadataModified(setId: setId, templateId: templateId)
      return self._getNFTMetadata(setId, templateId).getMutable()
    }

    pub fun replaceNFTMetadata(setId: Int, templateId: Int, new: AnyStruct) {
      self._getNFTMetadata(setId, templateId).replace(new)
      emit NFTMetadataModified(setId: setId, templateId: templateId)
    }
  }

  // ========================================================================
  // Contract functions
  // ========================================================================

  pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
    return NiftoryNFTRegistry
      .getNFTManagerPublic(
        SwaychainToknd.REGISTRY_ADDRESS,
        SwaychainToknd.REGISTRY_BRAND
      )
  }

  pub fun getViews(): [Type] {
    let possibleViews = [
      Type<MetadataViews.NFTCollectionDisplay>(),
      Type<MetadataViews.ExternalURL>()
    ]
    let views: [Type] = [Type<MetadataViews.NFTCollectionData>()]

    let viewManager = self.contract().getMetadataViewsManagerPublic()
    for view in possibleViews {
      if viewManager.inspectView(view: view) != nil {
        views.append(view)
      }
    }
    return views
  }

  pub fun resolveView(_ view: Type): AnyStruct? {
    let viewManager = self.contract().getMetadataViewsManagerPublic()
    switch view {

      case Type<MetadataViews.NFTCollectionData>():
        return self.contract().getNFTCollectionData()

      case Type<MetadataViews.NFTCollectionDisplay>():
        let maybeView = viewManager.inspectView(
          view: Type<MetadataViews.NFTCollectionDisplay>()
        )
        if maybeView == nil {
          return nil
        }
        let view = maybeView!

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver

          // External URL
          let externalURL = MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultExternalURLPrefix,
              uri: resolver.defaultExternalURL
            )
          )

          // Square image
          let squareImageURL = NiftoryMetadataViewsResolvers._prefixUri(
            allowedPrefixes:
              NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
            default: resolver.defaultSquareImagePrefix,
            uri: resolver.defaultSquareImage
          )
          let squareImageMediaType = resolver.defaultSquareImageMediaType
          let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: squareImageURL),
            mediaType: squareImageMediaType
          )

          // Banner image
          let bannerImageURL = NiftoryMetadataViewsResolvers._prefixUri(
            allowedPrefixes:
              NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
            default: resolver.defaultBannerImagePrefix,
            uri: resolver.defaultBannerImage
          )
          let bannerImageMediaType = resolver.defaultBannerImageMediaType
          let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
              url: bannerImageURL
            ),
            mediaType: bannerImageMediaType
          )

          return MetadataViews.NFTCollectionDisplay(
            name: resolver.defaultName,
            description: resolver.defaultDescription,
            externalURL: externalURL,
            squareImage: squareImage,
            bannerImage: bannerImage,
            socials: {}

          )
        }

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolverWithIpfsGateway>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolverWithIpfsGateway

          // External URL
          let externalURL = MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultExternalURLPrefix,
              uri: resolver.defaultExternalURL
            )
          )

          // Square image
          let squareImageURL = NiftoryMetadataViewsResolvers._useIpfsGateway(
            ipfsGateway: resolver.ipfsGateway,
            uri: NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultSquareImagePrefix,
              uri: resolver.defaultSquareImage
            )
        )
          let squareImageMediaType = resolver.defaultSquareImageMediaType
          let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: squareImageURL),
            mediaType: squareImageMediaType
          )

          // Banner image
          let bannerImageURL = NiftoryMetadataViewsResolvers._useIpfsGateway(
            ipfsGateway: resolver.ipfsGateway,
            uri: NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultBannerImagePrefix,
              uri: resolver.defaultBannerImage
            )
          )
          let bannerImageMediaType = resolver.defaultBannerImageMediaType
          let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
              url: bannerImageURL
            ),
            mediaType: bannerImageMediaType
          )

          return MetadataViews.NFTCollectionDisplay(
            name: resolver.defaultName,
            description: resolver.defaultDescription,
            externalURL: externalURL,
            squareImage: squareImage,
            bannerImage: bannerImage,
            socials: {}
          )
        }

        return nil

      case Type<MetadataViews.ExternalURL>():
        let maybeView = viewManager.inspectView(
          view: Type<MetadataViews.ExternalURL>()
        )
        if maybeView == nil {
          return nil
        }
        let view = maybeView!

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.ExternalURLResolver>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.ExternalURLResolver
          return MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultPrefix,
              uri: resolver.defaultURL
            )
          )
        }

        return nil
      }
      return nil

  }

  // ========================================================================
  // Init
  // ========================================================================

  init(
    nftManagerProxy: &{
      NiftoryNonFungibleTokenProxy.Public,
      NiftoryNonFungibleTokenProxy.Private
    }
  ) {

    let record = NiftoryNFTRegistry.generateRecord(
      account: self.account.address,
      project: "clbupdz6j0000mn0gk9fbr7yd_SwaychainToknd"
    )

    self.REGISTRY_ADDRESS = 0x32d62d5c43ad1038
    self.REGISTRY_BRAND = "clbupdz6j0000mn0gk9fbr7yd_SwaychainToknd"

    self.COLLECTION_PUBLIC_PATH = record.collectionPaths.public
    self.COLLECTION_PRIVATE_PATH = record.collectionPaths.private
    self.COLLECTION_STORAGE_PATH = record.collectionPaths.storage

    // No metadata to start with
    self.metadata = nil

    // Initialize the total supply to 0.
    self.totalSupply = 0

    // The Manager for this NFT
    //
    // NFT Manager storage
    let nftManager <- create Manager()

    // Save a MutableSetManager to this contract's storage, as the source of
    // this NFT contract's metadata.
    //
    // MutableMetadataSetManager storage
    self
      .account
      .save<@MutableMetadataSetManager.Manager>(
        <-MutableMetadataSetManager.create(
          name: "SwaychainToknd",
          description: "The set manager for SwaychainToknd."
        ),
        to: record.setManager.paths.storage
      )

    // MutableMetadataSetManager public
    self
      .account
      .link<&MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public}>(
        record.setManager.paths.public,
        target: record.setManager.paths.storage
      )

    // MutableMetadataSetManager private
    self
      .account
      .link<&
        MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public,
        MutableMetadataSetManager.Private
      }>(
        record.setManager.paths.private,
        target: record.setManager.paths.storage
      )

    // Save a MetadataViewsManager to this contract's storage, which will
    // allow observers to inspect standardized metadata through any of its
    // configured MetadataViews resolvers.
    //
    // MetadataViewsManager storage
    self
      .account
      .save<@MetadataViewsManager.Manager>(
        <-MetadataViewsManager.create(),
        to: record.metadataViewsManager.paths.storage
      )

    // MetadataViewsManager public
    self
      .account
      .link<&MetadataViewsManager.Manager{MetadataViewsManager.Public}>(
        record.metadataViewsManager.paths.public,
        target: record.metadataViewsManager.paths.storage
      )

    // MetadataViewsManager private
    self
      .account
      .link<&
        MetadataViewsManager.Manager{MetadataViewsManager.Private,
        MetadataViewsManager.Public
      }>(
        record.metadataViewsManager.paths.private,
        target: record.metadataViewsManager.paths.storage
      )

    let contractName = "SwaychainToknd"

    // Royalties
    let royaltiesResolver = NiftoryMetadataViewsResolvers.RoyaltiesResolver(
        royalties: MetadataViews.Royalties([])
    )
    nftManager.setMetadataViewsResolver(royaltiesResolver)

    // Collection Data
    let collectionDataResolver
        = NiftoryMetadataViewsResolvers.NFTCollectionDataResolver()
    nftManager.setMetadataViewsResolver(collectionDataResolver)

    // Display
    let displayResolver = NiftoryMetadataViewsResolvers.DisplayResolver(
        "title",
        contractName.concat("NFT"),
        "description",
        contractName.concat(" NFT"),
        "mediaUrl",
        "ipfs://",
        "ipfs://bafybeig6la3me5x3veull7jzxmwle4sfuaguou2is3o3z44ayhe7ihlqpa/NiftoryBanner.png"
    )
    nftManager.setMetadataViewsResolver(displayResolver)

    // Collection Display
    let collectionResolver = NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver(
        "title",
        contractName,
        "description",
        contractName.concat(" Collection"),
        "domainUrl",
        "https://",
        "https://niftory.com",
        "squareImage",
        "ipfs://",
        "ipfs://bafybeihc76uodw2at2xi2l5jydpvscj5ophfpqgblbrmsfpeffhcmgdtl4/squareImage.png",
        "squareImageMediaType",
        "image/png",
        "bannerImage",
        "ipfs://",
        "ipfs://bafybeig6la3me5x3veull7jzxmwle4sfuaguou2is3o3z44ayhe7ihlqpa/NiftoryBanner.png",
        "bannerImageMediaType",
        "image/png",
        []
    )
    nftManager.setMetadataViewsResolver(collectionResolver)

    // ExternalURL
    let externalURLResolver = NiftoryMetadataViewsResolvers.ExternalURLResolver(
        "domainUrl",
        "https://",
        "https://niftory.com"
    )
    nftManager.setMetadataViewsResolver(externalURLResolver)

    // Save NFT Manager
    self
      .account
      .save<@Manager>(
        <-nftManager,
        to: record.nftManager.paths.storage
      )

    // NFT Manager public
    self
      .account
      .link<&{NiftoryNonFungibleToken.ManagerPublic}>(
        record.nftManager.paths.public,
        target: record.nftManager.paths.storage
      )

    // NFT Manager private
    self
      .account
      .link<&
        Manager{NiftoryNonFungibleToken.ManagerPublic,
        NiftoryNonFungibleToken.ManagerPrivate
      }>(
        record.nftManager.paths.private,
        target: record.nftManager.paths.storage
      )

      nftManagerProxy.add(
        registryAddress: self.REGISTRY_ADDRESS,
        brand: self.REGISTRY_BRAND,
        cap: self.account
              .getCapability<&{
                NiftoryNonFungibleToken.ManagerPrivate,
                NiftoryNonFungibleToken.ManagerPublic
              }>(
                record.nftManager.paths.private
              )
      )
  }
}"
-------
"/*
FanxNFT

This is the contract for FanxNFT NFTs!

This was implemented using Niftory interfaces. For full details on how this
contract functions, please see the Niftory and NFTRegistry contracts.

*/

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import ViewResolver from 0x1d7e57aa55817448

import MutableMetadata from 0x7ec1f607f0872a9e
import MutableMetadataTemplate from 0x7ec1f607f0872a9e
import MutableMetadataSet from 0x7ec1f607f0872a9e
import MutableMetadataSetManager from 0x7ec1f607f0872a9e
import MetadataViewsManager from 0x7ec1f607f0872a9e

import NiftoryNonFungibleToken from 0x7ec1f607f0872a9e
import NiftoryNFTRegistry from 0x7ec1f607f0872a9e

import NiftoryMetadataViewsResolvers from 0x7ec1f607f0872a9e
import NiftoryNonFungibleTokenProxy from 0x7ec1f607f0872a9e

pub contract FanxNFT: NonFungibleToken, ViewResolver {

  // ========================================================================
  // Constants
  // ========================================================================

  // Suggested paths where collection could be stored
  pub let COLLECTION_PRIVATE_PATH: PrivatePath
  pub let COLLECTION_PUBLIC_PATH: PublicPath
  pub let COLLECTION_STORAGE_PATH: StoragePath

  // Accessor token to be used with NiftoryNFTRegistry to retrieve
  // meta-information about this NFT project
  pub let REGISTRY_ADDRESS: Address
  pub let REGISTRY_BRAND: String

  // ========================================================================
  // Attributes
  // ========================================================================

  // Arbitrary metadata for this NFT contract
  pub var metadata: AnyStruct?

  // Number of NFTs created
  pub var totalSupply: UInt64

  // ========================================================================
  // Contract Events
  // ========================================================================

  // This contract was initialized
  pub event ContractInitialized()

  // A withdrawal of NFT `id` has occurred from the `from` Address
  pub event Withdraw(id: UInt64, from: Address?)

  // A deposit of an NFT `id` has occurred to the `to` Address
  pub event Deposit(id: UInt64, to: Address?)

  ///////////////////////////////////////////////////////////////////////////

  // Contract metadata was modified
  pub event ContractMetadataUpdated()

  // Metadata Views Manager was locked
  pub event MetadataViewsManagerLocked()

  // Metadata Views Resolver was added
  pub event MetadataViewsResolverAdded(type: Type)

  // Metadata Views Resolver was removed
  pub event MetadataViewsResolverRemoved(type: Type)

  // Set Manager Name or Description updated
  pub event SetManagerMetadataUpdated()

  // Set added to Set Manager
  pub event SetAddedToSetManager(setID: Int)

  ///////////////////////////////////////////////////////////////////////////

  // Set `setId` was locked (no new templates can be added)
  pub event SetLocked(setId: Int)

  // The metadata for Set `setId` was locked and cannot be modified
  pub event SetMetadataLocked(setId: Int)

  // Set `setId` was modified
  pub event SetMetadataModified(setId: Int)

  // A new Template `templateId` was added to Set `setId`
  pub event TemplateAddedToSet(setId: Int, templateId: Int)

  ///////////////////////////////////////////////////////////////////////////

  // Template `templateId` was locked in Set `setId`, which disables minting
  pub event TemplateLocked(setId: Int, templateId: Int)

  // Template `templateId` of Set `setId` had it's maxMint set to `maxMint`
  pub event TemplateMaxMintSet(setId: Int, templateId: Int, maxMint: UInt64)

  // Template `templateId` of Set `setId` has minted NFT with serial `serial`
  pub event NFTMinted(id: UInt64, setId: Int, templateId: Int, serial: UInt64)

  ///////////////////////////////////////////////////////////////////////////

  // The metadata for NFT/Template `templateId` of Set `setId` was locked
  pub event NFTMetadataLocked(setId: Int, templateId: Int)

  // The metadata for NFT/Template `templateId` of Set `setId` was modified
  pub event NFTMetadataModified(setId: Int, templateId: Int)

  ///////////////////////////////////////////////////////////////////////////

  // NFT `serial` from Template `templateId` of Set `setId` was burned
  pub event NFTBurned(setId: Int, templateId: Int, serial: UInt64)

  // ========================================================================
  // NFT
  // ========================================================================

  pub resource NFT:
    NonFungibleToken.INFT,
    MetadataViews.Resolver,
    NiftoryNonFungibleToken.NFTPublic
  {
    pub let id: UInt64
    pub let setId: Int
    pub let templateId: Int
    pub let serial: UInt64

    pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
      return FanxNFT.contract()
    }

    pub fun set(): &MutableMetadataSet.Set{MutableMetadataSet.Public} {
      return self
        .contract()
        .getSetManagerPublic()
        .getSet(self.setId)
    }

    pub fun metadata(): &MutableMetadata.Metadata{MutableMetadata.Public} {
      return self
        .set()
        .getTemplate(self.templateId)
        .metadata()
    }

    pub fun getViews(): [Type] {
      return self
        .contract()
        .getMetadataViewsManagerPublic()
        .getViews()
    }

    pub fun resolveView(_ view: Type): AnyStruct? {
      let nftRef = &self as &{NiftoryNonFungibleToken.NFTPublic}
      return self
        .contract()
        .getMetadataViewsManagerPublic()
        .resolveView(view: view, nftRef: nftRef)
    }

    init(setId: Int, templateId: Int, serial: UInt64) {
      self.id = FanxNFT.totalSupply
      FanxNFT.totalSupply =
        FanxNFT.totalSupply + 1
      self.setId = setId
      self.templateId = templateId
      self.serial = serial
    }

    destroy() {
      emit NFTBurned(
        setId: self.setId,
        templateId: self.templateId,
        serial: self.serial
      )
    }
  }

  // ========================================================================
  // Collection
  // ========================================================================

  pub resource Collection:
    NonFungibleToken.Provider,
    NonFungibleToken.Receiver,
    NonFungibleToken.CollectionPublic,
    MetadataViews.ResolverCollection,
    NiftoryNonFungibleToken.CollectionPublic,
    NiftoryNonFungibleToken.CollectionPrivate
  {
    pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

    pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
      return FanxNFT.contract()
    }

    pub fun getIDs(): [UInt64] {
      return self.ownedNFTs.keys
    }

    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
      pre {
        self.ownedNFTs[id] != nil : "NFT "
          .concat(id.toString())
          .concat(" does not exist in collection.")
      }
      return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
    }

    pub fun borrow(id: UInt64): &NFT{NiftoryNonFungibleToken.NFTPublic} {
      pre {
        self.ownedNFTs[id] != nil : "NFT does not exist in collection."
      }
      let nftRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let fullNft = nftRef as! &NFT
      return fullNft
    }

    pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {
      pre {
        self.ownedNFTs[id] != nil : "NFT does not exist in collection."
      }
      let nftRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let fullNft = nftRef as! &NFT
      return fullNft
    }

    pub fun deposit(token: @NonFungibleToken.NFT) {
      let token <- token as! @FanxNFT.NFT
      let id: UInt64 = token.id
      let oldToken <- self.ownedNFTs[id] <- token
      emit Deposit(id: id, to: self.owner?.address)
      destroy oldToken
    }

    pub fun depositBulk(tokens: @[NonFungibleToken.NFT]) {
      while tokens.length > 0 {
        let token <- tokens.removeLast() as! @FanxNFT.NFT
        self.deposit(token: <-token)
      }
      destroy tokens
    }

    pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
      pre {
        self.ownedNFTs[withdrawID] != nil
          : "NFT "
            .concat(withdrawID.toString())
            .concat(" does not exist in collection.")
      }
      let token <-self.ownedNFTs.remove(key: withdrawID)!
      emit Withdraw(id: token.id, from: self.owner?.address)
      return <-token
    }

    pub fun withdrawBulk(withdrawIDs: [UInt64]): @[NonFungibleToken.NFT] {
      let tokens: @[NonFungibleToken.NFT] <- []
      while withdrawIDs.length > 0 {
        tokens.append(<- self.withdraw(withdrawID: withdrawIDs.removeLast()))
      }
      return <-tokens
    }

    init() {
      self.ownedNFTs <- {}
    }

    destroy() {
      destroy self.ownedNFTs
    }
  }

  pub fun createEmptyCollection(): @Collection {
    return <-create Collection()
  }

  // ========================================================================
  // Manager
  // ========================================================================

  pub resource Manager:
    NiftoryNonFungibleToken.ManagerPublic,
    NiftoryNonFungibleToken.ManagerPrivate
  {
    // ========================================================================
    // Public
    // ========================================================================

    pub fun metadata(): AnyStruct? {
      return FanxNFT.metadata
    }

    pub fun getSetManagerPublic():
      &MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public}
    {
      return NiftoryNFTRegistry
        .getSetManagerPublic(
          FanxNFT.REGISTRY_ADDRESS,
          FanxNFT.REGISTRY_BRAND
        )
    }

    pub fun getMetadataViewsManagerPublic():
      &MetadataViewsManager.Manager{MetadataViewsManager.Public}
    {
      return NiftoryNFTRegistry
        .getMetadataViewsManagerPublic(
          FanxNFT.REGISTRY_ADDRESS,
          FanxNFT.REGISTRY_BRAND
        )
    }

    pub fun getNFTCollectionData(): MetadataViews.NFTCollectionData {
      return NiftoryNFTRegistry
        .buildNFTCollectionData(
          FanxNFT.REGISTRY_ADDRESS,
          FanxNFT.REGISTRY_BRAND,
          (fun (): @NonFungibleToken.Collection {
            return <-FanxNFT.createEmptyCollection()
          })
        )
    }

    // ========================================================================
    // Contract metadata
    // ========================================================================

    pub fun modifyContractMetadata(): auth &AnyStruct {
      emit ContractMetadataUpdated()
      let maybeMetadata = FanxNFT.metadata
      if maybeMetadata == nil {
        let blankMetadata: {String: String} = {}
        FanxNFT.metadata = blankMetadata
      }
      return (&FanxNFT.metadata as auth &AnyStruct?)!
    }

    pub fun replaceContractMetadata(_ metadata: AnyStruct?) {
      emit ContractMetadataUpdated()
      FanxNFT.metadata = metadata
    }

    // ========================================================================
    // Metadata Views Manager
    // ========================================================================

    access(self) fun _getMetadataViewsManagerPrivate():
      &MetadataViewsManager.Manager{MetadataViewsManager.Private}
    {
      let record =
        NiftoryNFTRegistry.getRegistryRecord(
          FanxNFT.REGISTRY_ADDRESS,
          FanxNFT.REGISTRY_BRAND
        )
      let manager =
        FanxNFT.account
          .getCapability<&MetadataViewsManager.Manager{MetadataViewsManager.Private}>(
            record.metadataViewsManager.paths.private
          ).borrow()!
      return manager
    }

    pub fun lockMetadataViewsManager() {
      self._getMetadataViewsManagerPrivate().lock()
      emit MetadataViewsManagerLocked()
    }

    pub fun setMetadataViewsResolver(
      _ resolver: AnyStruct{MetadataViewsManager.Resolver}
    ) {
      self._getMetadataViewsManagerPrivate().addResolver(resolver)
      emit MetadataViewsResolverAdded(type: resolver.type)
    }

    pub fun removeMetadataViewsResolver(_ type: Type) {
      self._getMetadataViewsManagerPrivate().removeResolver(type)
      emit MetadataViewsResolverRemoved(type: type)
    }

    // ========================================================================
    // Set Manager
    // ========================================================================

    access(self) fun _getSetManagerPrivate():
      &MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public, MutableMetadataSetManager.Private}
    {
      let record =
        NiftoryNFTRegistry.getRegistryRecord(
          FanxNFT.REGISTRY_ADDRESS,
          FanxNFT.REGISTRY_BRAND
        )
      let setManager =
        FanxNFT.account
          .getCapability<&MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public, MutableMetadataSetManager.Private}>(
            record.setManager.paths.private
          ).borrow()!
      return setManager
    }

    pub fun setMetadataManagerName(_ name: String) {
      self._getSetManagerPrivate().setName(name)
      emit SetManagerMetadataUpdated()
    }

    pub fun setMetadataManagerDescription(_ description: String) {
      self._getSetManagerPrivate().setDescription(description)
      emit SetManagerMetadataUpdated()
    }

    pub fun addSet(_ set: @MutableMetadataSet.Set) {
      let setManager = self._getSetManagerPrivate()
      let setId = setManager.numSets()
      setManager.addSet(<-set)
      emit SetAddedToSetManager(setID: setId)
    }

    // ========================================================================
    // Set
    // ========================================================================

    access(self) fun _getSetMutable(_ setId: Int):
      &MutableMetadataSet.Set{MutableMetadataSet.Private,
        MutableMetadataSet.Public} {
      return self._getSetManagerPrivate().getSetMutable(setId)
    }

    pub fun lockSet(setId: Int) {
      self._getSetMutable(setId).lock()
      emit SetLocked(setId: setId)
    }

    pub fun lockSetMetadata(setId: Int) {
      self._getSetMutable(setId).metadataMutable().lock()
      emit SetMetadataLocked(setId: setId)
    }

    pub fun modifySetMetadata(setId: Int): auth &AnyStruct {
      emit SetMetadataModified(setId: setId)
      return self._getSetMutable(setId).metadataMutable().getMutable()
    }

    pub fun replaceSetMetadata(setId: Int, new: AnyStruct) {
      self._getSetMutable(setId).metadataMutable().replace(new)
      emit SetMetadataModified(setId: setId)
    }

    pub fun addTemplate(
      setId: Int,
      template: @MutableMetadataTemplate.Template
    ) {
      let set = self._getSetMutable(setId)
      let templateId = set.numTemplates()
      set.addTemplate(<-template)
      emit TemplateAddedToSet(setId: setId, templateId: templateId)
    }

    // ========================================================================
    // Minting
    // ========================================================================

    access(self) fun _getTemplateMutable(_ setId: Int, _ templateId: Int):
      &MutableMetadataTemplate.Template{MutableMetadataTemplate.Public,
        MutableMetadataTemplate.Private} {
      return self._getSetMutable(setId).getTemplateMutable(templateId)
    }

    pub fun lockTemplate(setId: Int, templateId: Int) {
      self._getTemplateMutable(setId, templateId).lock()
      emit TemplateLocked(setId: setId, templateId: templateId)
    }

    pub fun setTemplateMaxMint(setId: Int, templateId: Int, max: UInt64) {
      self._getTemplateMutable(setId, templateId).setMaxMint(max)
      emit TemplateMaxMintSet(
        setId: setId,
        templateId: templateId,
        maxMint: max
      )
    }

    pub fun mint(setId: Int, templateId: Int): @NonFungibleToken.NFT {
      let template = self._getTemplateMutable(setId, templateId)
      template.registerMint()
      let serial = template.minted()
      let nft <-create NFT(
        setId: setId,
        templateId: templateId,
        serial: serial
      )
      emit NFTMinted(
        id: nft.id,
        setId: setId,
        templateId: templateId,
        serial: serial
      )
      return <-nft
    }

    pub fun mintBulk(
      setId: Int,
      templateId: Int,
      numToMint: UInt64,
    ): @[NonFungibleToken.NFT] {
      pre {
        numToMint > 0: "Must mint at least one NFT"
      }
      let template = self._getTemplateMutable(setId, templateId)
      let nfts: @[NonFungibleToken.NFT] <- []
      var leftToMint = numToMint
      while leftToMint > 0 {
        template.registerMint()
        let serial = template.minted()
        let nft <-create NFT(
          setId: setId,
          templateId: templateId,
          serial: serial
        )
        emit NFTMinted(
          id: nft.id,
          setId: setId,
          templateId: templateId,
          serial: serial
        )
        nfts.append(<-nft)
        leftToMint = leftToMint - 1
      }
      return <-nfts
    }

    // ========================================================================
    // NFT metadata
    // ========================================================================

    access(self) fun _getNFTMetadata(_ setId: Int, _ templateId: Int):
      &MutableMetadata.Metadata{MutableMetadata.Public,
        MutableMetadata.Private
      } {
        return self._getTemplateMutable(setId, templateId).metadataMutable()
    }

    pub fun lockNFTMetadata(setId: Int, templateId: Int) {
      self._getNFTMetadata(setId, templateId).lock()
      emit NFTMetadataLocked(setId: setId, templateId: templateId)
    }

    pub fun modifyNFTMetadata(setId: Int, templateId: Int): auth &AnyStruct {
      emit NFTMetadataModified(setId: setId, templateId: templateId)
      return self._getNFTMetadata(setId, templateId).getMutable()
    }

    pub fun replaceNFTMetadata(setId: Int, templateId: Int, new: AnyStruct) {
      self._getNFTMetadata(setId, templateId).replace(new)
      emit NFTMetadataModified(setId: setId, templateId: templateId)
    }
  }

  // ========================================================================
  // Contract functions
  // ========================================================================

  pub fun contract(): &{NiftoryNonFungibleToken.ManagerPublic} {
    return NiftoryNFTRegistry
      .getNFTManagerPublic(
        FanxNFT.REGISTRY_ADDRESS,
        FanxNFT.REGISTRY_BRAND
      )
  }

  pub fun getViews(): [Type] {
    let possibleViews = [
      Type<MetadataViews.NFTCollectionDisplay>(),
      Type<MetadataViews.ExternalURL>()
    ]
    let views: [Type] = [Type<MetadataViews.NFTCollectionData>()]

    let viewManager = self.contract().getMetadataViewsManagerPublic()
    for view in possibleViews {
      if viewManager.inspectView(view: view) != nil {
        views.append(view)
      }
    }
    return views
  }

  pub fun resolveView(_ view: Type): AnyStruct? {
    let viewManager = self.contract().getMetadataViewsManagerPublic()
    switch view {

      case Type<MetadataViews.NFTCollectionData>():
        return self.contract().getNFTCollectionData()

      case Type<MetadataViews.NFTCollectionDisplay>():
        let maybeView = viewManager.inspectView(
          view: Type<MetadataViews.NFTCollectionDisplay>()
        )
        if maybeView == nil {
          return nil
        }
        let view = maybeView!

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver

          // External URL
          let externalURL = MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultExternalURLPrefix,
              uri: resolver.defaultExternalURL
            )
          )

          // Square image
          let squareImageURL = NiftoryMetadataViewsResolvers._prefixUri(
            allowedPrefixes:
              NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
            default: resolver.defaultSquareImagePrefix,
            uri: resolver.defaultSquareImage
          )
          let squareImageMediaType = resolver.defaultSquareImageMediaType
          let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: squareImageURL),
            mediaType: squareImageMediaType
          )

          // Banner image
          let bannerImageURL = NiftoryMetadataViewsResolvers._prefixUri(
            allowedPrefixes:
              NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
            default: resolver.defaultBannerImagePrefix,
            uri: resolver.defaultBannerImage
          )
          let bannerImageMediaType = resolver.defaultBannerImageMediaType
          let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
              url: bannerImageURL
            ),
            mediaType: bannerImageMediaType
          )

          return MetadataViews.NFTCollectionDisplay(
            name: resolver.defaultName,
            description: resolver.defaultDescription,
            externalURL: externalURL,
            squareImage: squareImage,
            bannerImage: bannerImage,
            socials: {}

          )
        }

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolverWithIpfsGateway>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolverWithIpfsGateway

          // External URL
          let externalURL = MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultExternalURLPrefix,
              uri: resolver.defaultExternalURL
            )
          )

          // Square image
          let squareImageURL = NiftoryMetadataViewsResolvers._useIpfsGateway(
            ipfsGateway: resolver.ipfsGateway,
            uri: NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultSquareImagePrefix,
              uri: resolver.defaultSquareImage
            )
        )
          let squareImageMediaType = resolver.defaultSquareImageMediaType
          let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: squareImageURL),
            mediaType: squareImageMediaType
          )

          // Banner image
          let bannerImageURL = NiftoryMetadataViewsResolvers._useIpfsGateway(
            ipfsGateway: resolver.ipfsGateway,
            uri: NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultBannerImagePrefix,
              uri: resolver.defaultBannerImage
            )
          )
          let bannerImageMediaType = resolver.defaultBannerImageMediaType
          let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
              url: bannerImageURL
            ),
            mediaType: bannerImageMediaType
          )

          return MetadataViews.NFTCollectionDisplay(
            name: resolver.defaultName,
            description: resolver.defaultDescription,
            externalURL: externalURL,
            squareImage: squareImage,
            bannerImage: bannerImage,
            socials: {}
          )
        }

        return nil

      case Type<MetadataViews.ExternalURL>():
        let maybeView = viewManager.inspectView(
          view: Type<MetadataViews.ExternalURL>()
        )
        if maybeView == nil {
          return nil
        }
        let view = maybeView!

        if view.isInstance(
          Type<NiftoryMetadataViewsResolvers.ExternalURLResolver>()
        ) {
          let resolver = view as! NiftoryMetadataViewsResolvers.ExternalURLResolver
          return MetadataViews.ExternalURL(url:
            NiftoryMetadataViewsResolvers._prefixUri(
              allowedPrefixes:
                NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
              default: resolver.defaultPrefix,
              uri: resolver.defaultURL
            )
          )
        }

        return nil
      }
      return nil

  }

  // ========================================================================
  // Init
  // ========================================================================

  init(
    nftManagerProxy: &{
      NiftoryNonFungibleTokenProxy.Public,
      NiftoryNonFungibleTokenProxy.Private
    }
  ) {

    let record = NiftoryNFTRegistry.generateRecord(
      account: self.account.address,
      project: "cleoapn1x0004jy0wkmmul4x7_FanxNFT"
    )

    self.REGISTRY_ADDRESS = 0x32d62d5c43ad1038
    self.REGISTRY_BRAND = "cleoapn1x0004jy0wkmmul4x7_FanxNFT"

    self.COLLECTION_PUBLIC_PATH = record.collectionPaths.public
    self.COLLECTION_PRIVATE_PATH = record.collectionPaths.private
    self.COLLECTION_STORAGE_PATH = record.collectionPaths.storage

    // No metadata to start with
    self.metadata = nil

    // Initialize the total supply to 0.
    self.totalSupply = 0

    // The Manager for this NFT
    //
    // NFT Manager storage
    let nftManager <- create Manager()

    // Save a MutableSetManager to this contract's storage, as the source of
    // this NFT contract's metadata.
    //
    // MutableMetadataSetManager storage
    self
      .account
      .save<@MutableMetadataSetManager.Manager>(
        <-MutableMetadataSetManager.create(
          name: "FanxNFT",
          description: "The set manager for FanxNFT."
        ),
        to: record.setManager.paths.storage
      )

    // MutableMetadataSetManager public
    self
      .account
      .link<&MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public}>(
        record.setManager.paths.public,
        target: record.setManager.paths.storage
      )

    // MutableMetadataSetManager private
    self
      .account
      .link<&
        MutableMetadataSetManager.Manager{MutableMetadataSetManager.Public,
        MutableMetadataSetManager.Private
      }>(
        record.setManager.paths.private,
        target: record.setManager.paths.storage
      )

    // Save a MetadataViewsManager to this contract's storage, which will
    // allow observers to inspect standardized metadata through any of its
    // configured MetadataViews resolvers.
    //
    // MetadataViewsManager storage
    self
      .account
      .save<@MetadataViewsManager.Manager>(
        <-MetadataViewsManager.create(),
        to: record.metadataViewsManager.paths.storage
      )

    // MetadataViewsManager public
    self
      .account
      .link<&MetadataViewsManager.Manager{MetadataViewsManager.Public}>(
        record.metadataViewsManager.paths.public,
        target: record.metadataViewsManager.paths.storage
      )

    // MetadataViewsManager private
    self
      .account
      .link<&
        MetadataViewsManager.Manager{MetadataViewsManager.Private,
        MetadataViewsManager.Public
      }>(
        record.metadataViewsManager.paths.private,
        target: record.metadataViewsManager.paths.storage
      )

    let contractName = "FanxNFT"

    // Royalties
    let royaltiesResolver = NiftoryMetadataViewsResolvers.RoyaltiesResolver(
        royalties: MetadataViews.Royalties([])
    )
    nftManager.setMetadataViewsResolver(royaltiesResolver)

    // Collection Data
    let collectionDataResolver
        = NiftoryMetadataViewsResolvers.NFTCollectionDataResolver()
    nftManager.setMetadataViewsResolver(collectionDataResolver)

    // Display
    let displayResolver = NiftoryMetadataViewsResolvers.DisplayResolver(
        "title",
        contractName.concat("NFT"),
        "description",
        contractName.concat(" NFT"),
        "mediaUrl",
        "ipfs://",
        "ipfs://bafybeig6la3me5x3veull7jzxmwle4sfuaguou2is3o3z44ayhe7ihlqpa/NiftoryBanner.png"
    )
    nftManager.setMetadataViewsResolver(displayResolver)

    // Collection Display
    let collectionResolver = NiftoryMetadataViewsResolvers.NFTCollectionDisplayResolver(
        "title",
        contractName,
        "description",
        contractName.concat(" Collection"),
        "domainUrl",
        "https://",
        "https://niftory.com",
        "squareImage",
        "ipfs://",
        "ipfs://bafybeihc76uodw2at2xi2l5jydpvscj5ophfpqgblbrmsfpeffhcmgdtl4/squareImage.png",
        "squareImageMediaType",
        "image/png",
        "bannerImage",
        "ipfs://",
        "ipfs://bafybeig6la3me5x3veull7jzxmwle4sfuaguou2is3o3z44ayhe7ihlqpa/NiftoryBanner.png",
        "bannerImageMediaType",
        "image/png",
        []
    )
    nftManager.setMetadataViewsResolver(collectionResolver)

    // ExternalURL
    let externalURLResolver = NiftoryMetadataViewsResolvers.ExternalURLResolver(
        "domainUrl",
        "https://",
        "https://niftory.com"
    )
    nftManager.setMetadataViewsResolver(externalURLResolver)

    // Save NFT Manager
    self
      .account
      .save<@Manager>(
        <-nftManager,
        to: record.nftManager.paths.storage
      )

    // NFT Manager public
    self
      .account
      .link<&{NiftoryNonFungibleToken.ManagerPublic}>(
        record.nftManager.paths.public,
        target: record.nftManager.paths.storage
      )

    // NFT Manager private
    self
      .account
      .link<&
        Manager{NiftoryNonFungibleToken.ManagerPublic,
        NiftoryNonFungibleToken.ManagerPrivate
      }>(
        record.nftManager.paths.private,
        target: record.nftManager.paths.storage
      )

      nftManagerProxy.add(
        registryAddress: self.REGISTRY_ADDRESS,
        brand: self.REGISTRY_BRAND,
        cap: self.account
              .getCapability<&{
                NiftoryNonFungibleToken.ManagerPrivate,
                NiftoryNonFungibleToken.ManagerPublic
              }>(
                record.nftManager.paths.private
              )
      )
  }
}"
-------
"pub contract WondermonFlovatarPromptTemplate {

    pub event ContractInitialized()

    pub event PromptTemplateSet(flovatarId: UInt64)
    pub event PromptTemplateRemoved(flovatarId: UInt64)
    pub event DefaultPromptTemplateSet()

    pub let AdminStoragePath: StoragePath
    pub let AdminPublicPath: PublicPath
    pub let AdminPrivatePath: PrivatePath

    pub let promptTemplates: {UInt64: String}
    pub var defaultPrompt: String

    pub resource Admin {

        pub fun setTemplate(flovatarId: UInt64, template: String) {
            WondermonFlovatarPromptTemplate.promptTemplates.insert(key: flovatarId, template)
            emit PromptTemplateSet(flovatarId: flovatarId)
        }

        pub fun removeTemplate(flovatarId: UInt64) {
            WondermonFlovatarPromptTemplate.promptTemplates.remove(key: flovatarId)
            emit PromptTemplateRemoved(flovatarId: flovatarId)
        }

        pub fun setDefaultTemplate(_ template: String) {
            WondermonFlovatarPromptTemplate.defaultPrompt = template
            emit DefaultPromptTemplateSet()
        }
    }

    pub fun getPromptTemplate(flovatarId: UInt64): String {
        return self.promptTemplates[flovatarId] ?? self.defaultPrompt
    }

    init() {
        self.promptTemplates = {}
        self.defaultPrompt = ""

        self.AdminStoragePath = /storage/WondermonFlovatarPromptTemplateAdmin
        self.AdminPublicPath = /public/WondermonFlovatarPromptTemplateAdmin
        self.AdminPrivatePath = /private/WondermonFlovatarPromptTemplateAdmin

        self.account.save(<- create Admin(), to: self.AdminStoragePath)

        emit ContractInitialized()
    }
}"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import FungibleTokenMetadataViews from 0xf233dcee88fe0abe
import MetadataViews from 0x1d7e57aa55817448
import Toucans from 0x577a3c409c5dcb5e
import ToucansTokens from 0x577a3c409c5dcb5e
import FlowToken from 0x1654653399040a61
import ViewResolver from 0x1d7e57aa55817448

pub contract HeartFirstAcademy: FungibleToken, ViewResolver {

    // The amount of tokens in existance
    pub var totalSupply: UFix64
    // nil if there is none
    pub let maxSupply: UFix64?

    // Paths
    pub let VaultStoragePath: StoragePath
    pub let ReceiverPublicPath: PublicPath
    pub let VaultPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath
    pub let AdministratorStoragePath: StoragePath

    // Events
    pub event TokensInitialized(initialSupply: UFix64)
    pub event TokensWithdrawn(amount: UFix64, from: Address?)
    pub event TokensDeposited(amount: UFix64, to: Address?)
    pub event TokensTransferred(amount: UFix64, from: Address, to: Address)
    pub event TokensMinted(amount: UFix64)
    pub event TokensBurned(amount: UFix64)

    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance, MetadataViews.Resolver {
        pub var balance: UFix64

        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)

            if let owner: Address = self.owner?.address {
                HeartFirstAcademy.setBalance(address: owner, balance: self.balance)
            }
            return <- create Vault(balance: amount)
        }

        pub fun deposit(from: @FungibleToken.Vault) {
            let vault: @Vault <- from as! @Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)

            // We set the balance to 0.0 here so that it doesn't
            // decrease the totalSupply in the `destroy` function.
            vault.balance = 0.0
            destroy vault

            if let owner: Address = self.owner?.address {
                HeartFirstAcademy.setBalance(address: owner, balance: self.balance)
            }
        }

        pub fun getViews(): [Type]{
            return [
                Type<FungibleTokenMetadataViews.FTView>(),
                Type<FungibleTokenMetadataViews.FTDisplay>(),
                Type<FungibleTokenMetadataViews.FTVaultData>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<FungibleTokenMetadataViews.FTView>():
                    return HeartFirstAcademy.resolveView(view)
                case Type<FungibleTokenMetadataViews.FTDisplay>():
                    return HeartFirstAcademy.resolveView(view)
                case Type<FungibleTokenMetadataViews.FTVaultData>():
                    return HeartFirstAcademy.resolveView(view)
            }
            return nil
        }

        init(balance: UFix64) {
            self.balance = balance
        }

        destroy() {
            if (self.balance > 0.0) {
                emit TokensBurned(amount: self.balance)
                HeartFirstAcademy.totalSupply = HeartFirstAcademy.totalSupply - self.balance
            }
        }
    }

    pub fun createEmptyVault(): @Vault {
        return <- create Vault(balance: 0.0)
    }

    pub resource Minter: Toucans.Minter {
        pub fun mint(amount: UFix64): @Vault {
            post {
                HeartFirstAcademy.maxSupply == nil || HeartFirstAcademy.totalSupply <= HeartFirstAcademy.maxSupply!:
                    "Exceeded the max supply of tokens allowd."
            }
            HeartFirstAcademy.totalSupply = HeartFirstAcademy.totalSupply + amount
            emit TokensMinted(amount: amount)
            return <- create Vault(balance: amount)
        }
    }

    // We follow this pattern of storage
    // so the (potentially) huge dictionary
    // isn't loaded when the contract is imported
    pub resource Administrator {
        // This is an experimental index and should
        // not be used for anything official
        // or monetary related
        access(self) let balances: {Address: UFix64}

        access(contract) fun setBalance(address: Address, balance: UFix64) {
            self.balances[address] = balance
        }

        pub fun getBalance(address: Address): UFix64 {
            return self.balances[address] ?? 0.0
        }

        pub fun getBalances(): {Address: UFix64} {
            return self.balances
        }

        init() {
            self.balances = {}
        }
    }

    access(contract) fun setBalance(address: Address, balance: UFix64) {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        admin.setBalance(address: address, balance: balance)
    }

    pub fun getBalance(address: Address): UFix64 {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalance(address: address)
    }

    pub fun getBalances(): {Address: UFix64} {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalances()
    }

    pub fun getViews(): [Type] {
        return [
            Type<FungibleTokenMetadataViews.FTView>(),
            Type<FungibleTokenMetadataViews.FTDisplay>(),
            Type<FungibleTokenMetadataViews.FTVaultData>()
        ]
    }

    pub fun resolveView(_ view: Type): AnyStruct? {
        switch view {
            case Type<FungibleTokenMetadataViews.FTView>():
                return FungibleTokenMetadataViews.FTView(
                    ftDisplay: self.resolveView(Type<FungibleTokenMetadataViews.FTDisplay>()) as! FungibleTokenMetadataViews.FTDisplay?,
                    ftVaultData: self.resolveView(Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
                )
            case Type<FungibleTokenMetadataViews.FTDisplay>():
                let media = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                        url: "undefined"
                    ),
                    mediaType: "image"
                )
                let bannerMedia = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                        url: "undefined"
                    ),
                    mediaType: "image"
                )
                let medias = MetadataViews.Medias([media, bannerMedia])
                return FungibleTokenMetadataViews.FTDisplay(
                    name: "Heart First Academy",
                    symbol: "HEART",
                    description: "A DAO created to empower medical professionals  in the web3 space and help govern the Heart First Academy educational platform. ",
                    externalURL: MetadataViews.ExternalURL(""),
                    logos: medias,
                    socials: {
                        "twitter": MetadataViews.ExternalURL("HeartFirst_NFT"),
                        "discord": MetadataViews.ExternalURL("https://discord.gg/ct2w5hmxHV")
                    }
                )
            case Type<FungibleTokenMetadataViews.FTVaultData>():
                return FungibleTokenMetadataViews.FTVaultData(
                    storagePath: HeartFirstAcademy.VaultStoragePath,
                    receiverPath: HeartFirstAcademy.ReceiverPublicPath,
                    metadataPath: HeartFirstAcademy.VaultPublicPath,
                    providerPath: /private/HeartFirstAcademyVault,
                    receiverLinkedType: Type<&Vault{FungibleToken.Receiver}>(),
                    metadataLinkedType: Type<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(),
                    providerLinkedType: Type<&Vault{FungibleToken.Provider}>(),
                    createEmptyVaultFunction: (fun (): @Vault {
                        return <- HeartFirstAcademy.createEmptyVault()
                    })
                )
        }
        return nil
    }

    init(
      _paymentTokenInfo: ToucansTokens.TokenInfo,
      _editDelay: UFix64,
      _minting: Bool,
      _initialTreasurySupply: UFix64,
      _maxSupply: UFix64?,
      _extra: {String: AnyStruct}
    ) {

      // Contract Variables
      self.totalSupply = 0.0
      self.maxSupply = _maxSupply

      // Paths
      self.VaultStoragePath = /storage/HeartFirstAcademyVault
      self.ReceiverPublicPath = /public/HeartFirstAcademyReceiver
      self.VaultPublicPath = /public/HeartFirstAcademyMetadata
      self.MinterStoragePath = /storage/HeartFirstAcademyMinter
      self.AdministratorStoragePath = /storage/HeartFirstAcademyAdmin

      // Admin Setup
      let vault <- create Vault(balance: self.totalSupply)
      self.account.save(<- vault, to: self.VaultStoragePath)

      self.account.link<&Vault{FungibleToken.Receiver}>(
          self.ReceiverPublicPath,
          target: self.VaultStoragePath
      )

      self.account.link<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(
          self.VaultPublicPath,
          target: self.VaultStoragePath
      )

      if self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath) == nil {
        self.account.save(<- Toucans.createCollection(), to: Toucans.CollectionStoragePath)
        self.account.link<&Toucans.Collection{Toucans.CollectionPublic}>(Toucans.CollectionPublicPath, target: Toucans.CollectionStoragePath)
      }

      let toucansProjectCollection = self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath)!
      toucansProjectCollection.createProject(
        projectTokenInfo: ToucansTokens.TokenInfo("HeartFirstAcademy", self.account.address, "HEART", self.ReceiverPublicPath, self.VaultPublicPath, self.VaultStoragePath),
        paymentTokenInfo: _paymentTokenInfo,
        minter: <- create Minter(),
        editDelay: _editDelay,
        minting: _minting,
        initialTreasurySupply: _initialTreasurySupply,
        extra: _extra
      )

      self.account.save(<- create Administrator(), to: self.AdministratorStoragePath)

      // Events
      emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
 "
-------
"import NFTCatalog from 0x49a7cda3a1eecc29

// NFTCatalogAdmin
//
// An admin contract that defines an    admin resource and
// a proxy resource to receive a capability that lets you make changes to the NFT Catalog
// and manage proposals

pub contract NFTCatalogAdmin {

    // AddProposalAccepted
    // Emitted when a proposal to add a new catalog item has been approved by an admin
    pub event AddProposalAccepted(
        proposer: Address,
        collectionIdentifier : String,
        contractName : String,
        contractAddress : Address,
        displayName : String
    )

    // UpdateProposalAccepted
    // Emitted when a proposal to update a catalog item has been approved by an admin
    pub event UpdateProposalAccepted(
        proposer: Address,
        collectionIdentifier : String,
        contractName : String,
        contractAddress : Address,
        displayName : String
    )

    // ProposalRejected
    // Emitted when a proposal to add or update a catalog item has been rejected.
    pub event ProposalRejected(
        proposer: Address,
        collectionIdentifier : String,
        contractName : String,
        contractAddress : Address,
        displayName : String
    )

    pub let AdminPrivatePath: PrivatePath
    pub let AdminStoragePath: StoragePath

    pub let AdminProxyPublicPath: PublicPath
    pub let AdminProxyStoragePath: StoragePath

    // Admin
    // Admin resource to manage NFT Catalog
    pub resource Admin {

        pub fun addCatalogEntry(collectionIdentifier: String, metadata : NFTCatalog.NFTCatalogMetadata) {
            NFTCatalog.addCatalogEntry(collectionIdentifier: collectionIdentifier, metadata : metadata)
        }

        pub fun updateCatalogEntry(collectionIdentifier : String , metadata : NFTCatalog.NFTCatalogMetadata) {
            NFTCatalog.updateCatalogEntry(collectionIdentifier: collectionIdentifier, metadata : metadata)
        }

        pub fun removeCatalogEntry(collectionIdentifier : String) {
            NFTCatalog.removeCatalogEntry(collectionIdentifier : collectionIdentifier)
        }

        pub fun removeCatalogEntryUnsafe(collectionIdentifier : String, nftTypeIdentifier: String) {
            NFTCatalog.removeCatalogEntryUnsafe(collectionIdentifier : collectionIdentifier, nftTypeIdentifier: nftTypeIdentifier)
        }

        pub fun approveCatalogProposal(proposalID : UInt64) {
            pre {
                NFTCatalog.getCatalogProposalEntry(proposalID : proposalID) != nil : "Invalid Proposal ID"
                NFTCatalog.getCatalogProposalEntry(proposalID : proposalID)!.status == "IN_REVIEW" : "Invalid Proposal"
            }
            let catalogProposalEntry = NFTCatalog.getCatalogProposalEntry(proposalID : proposalID)!
            let newCatalogProposalEntry = NFTCatalog.NFTCatalogProposal(collectionIdentifier : catalogProposalEntry.collectionIdentifier, metadata : catalogProposalEntry.metadata, message : catalogProposalEntry.message, status: "APPROVED", proposer: catalogProposalEntry.proposer)
            NFTCatalog.updateCatalogProposal(proposalID : proposalID, proposalMetadata : newCatalogProposalEntry)

            if NFTCatalog.getCatalogEntry(collectionIdentifier : NFTCatalog.getCatalogProposalEntry(proposalID : proposalID)!.collectionIdentifier) == nil {
                NFTCatalog.addCatalogEntry(collectionIdentifier: newCatalogProposalEntry.collectionIdentifier, metadata : newCatalogProposalEntry.metadata)
                emit AddProposalAccepted(
                    proposer: newCatalogProposalEntry.proposer,
                    collectionIdentifier : newCatalogProposalEntry.collectionIdentifier,
                    contractName : newCatalogProposalEntry.metadata.contractName,
                    contractAddress : newCatalogProposalEntry.metadata.contractAddress,
                    displayName : newCatalogProposalEntry.metadata.collectionDisplay.name
                )
            } else {
                NFTCatalog.updateCatalogEntry(collectionIdentifier: newCatalogProposalEntry.collectionIdentifier, metadata: newCatalogProposalEntry.metadata)
                emit UpdateProposalAccepted(
                    proposer: newCatalogProposalEntry.proposer,
                    collectionIdentifier : newCatalogProposalEntry.collectionIdentifier,
                    contractName : newCatalogProposalEntry.metadata.contractName,
                    contractAddress : newCatalogProposalEntry.metadata.contractAddress,
                    displayName : newCatalogProposalEntry.metadata.collectionDisplay.name
                )
            }
        }

        pub fun rejectCatalogProposal(proposalID : UInt64) {
            pre {
                NFTCatalog.getCatalogProposalEntry(proposalID : proposalID) != nil : "Invalid Proposal ID"
                NFTCatalog.getCatalogProposalEntry(proposalID : proposalID)!.status == "IN_REVIEW" : "Invalid Proposal"
            }
            let catalogProposalEntry = NFTCatalog.getCatalogProposalEntry(proposalID : proposalID)!
            let newCatalogProposalEntry = NFTCatalog.NFTCatalogProposal(collectionIdentifier : catalogProposalEntry.collectionIdentifier, metadata : catalogProposalEntry.metadata, message : catalogProposalEntry.message, status: "REJECTED", proposer: catalogProposalEntry.proposer)
            NFTCatalog.updateCatalogProposal(proposalID : proposalID, proposalMetadata : newCatalogProposalEntry)
            emit ProposalRejected(
                proposer: newCatalogProposalEntry.proposer,
                collectionIdentifier : newCatalogProposalEntry.collectionIdentifier,
                contractName : newCatalogProposalEntry.metadata.contractName,
                contractAddress : newCatalogProposalEntry.metadata.contractAddress,
                displayName : newCatalogProposalEntry.metadata.collectionDisplay.name
            )
        }

        pub fun removeCatalogProposal(proposalID : UInt64) {
            pre {
                NFTCatalog.getCatalogProposalEntry(proposalID : proposalID) != nil : "Invalid Proposal ID"
            }
            NFTCatalog.removeCatalogProposal(proposalID : proposalID)
        }

        init () {}

    }

    // AdminProxy
    // A proxy resource that can store
    // a capability to admin controls
    pub resource interface IAdminProxy {
        pub fun addCapability(capability : Capability<&Admin>)
        pub fun hasCapability() : Bool
    }

    pub resource AdminProxy : IAdminProxy {

        access(self) var capability : Capability<&Admin>?

        pub fun addCapability(capability : Capability<&Admin>) {
            pre {
                capability.check() : "Invalid Admin Capability"
                self.capability == nil : "Admin Proxy already set"
            }
            self.capability = capability
        }

        pub fun getCapability() : Capability<&Admin>? {
            return self.capability
        }

        pub fun hasCapability() : Bool {
            return self.capability != nil
        }

        init() {
            self.capability = nil
        }

    }

    pub fun createAdminProxy() : @AdminProxy {
        return <- create AdminProxy()
    }

    init () {
        self.AdminProxyPublicPath = /public/nftCatalogAdminProxy
        self.AdminProxyStoragePath = /storage/nftCatalogAdminProxy

        self.AdminPrivatePath = /private/nftCatalogAdmin
        self.AdminStoragePath = /storage/nftCatalogAdmin

        let admin    <- create Admin()

        self.account.save(<-admin, to: self.AdminStoragePath)
        self.account.link<&Admin>(self.AdminPrivatePath, target: self.AdminStoragePath)
    }
}"
-------
"
  import FungibleToken from 0xf233dcee88fe0abe

   access(all) contract MyToken: FungibleToken {
      pub var totalSupply: UFix64

      /// TokensInitialized
      ///
      /// The event that is emitted when the contract is created
      pub event TokensInitialized(initialSupply: UFix64)

      /// TokensWithdrawn
      ///
      /// The event that is emitted when tokens are withdrawn from a Vault
      pub event TokensWithdrawn(amount: UFix64, from: Address?)

      /// TokensDeposited
      ///
      /// The event that is emitted when tokens are deposited to a Vault
      pub event TokensDeposited(amount: UFix64, to: Address?)

      /// TokensMinted
      ///
      /// The event that is emitted when new tokens are minted
      pub event TokensMinted(amount: UFix64)

      pub let TokenVaultStoragePath: StoragePath
      pub let TokenVaultPublicPath: PublicPath
      pub let TokenMinterStoragePath: StoragePath

      pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {
          pub var balance: UFix64

          init(balance: UFix64) {
              self.balance = balance
          }

          pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
              self.balance = self.balance - amount
              emit TokensWithdrawn(amount: amount, from: self.owner?.address)
              return <- create Vault(balance: amount)
          }

          pub fun deposit(from: @FungibleToken.Vault) {
              let vault <- from as! @MyToken.Vault
              self.balance = self.balance + vault.balance
              emit TokensDeposited(amount: vault.balance, to: self.owner?.address)
              vault.balance = 0.0
              destroy vault // Make sure we get rid of the vault
          }

          destroy() {
              MyToken.totalSupply = MyToken.totalSupply - self.balance
          }
      }

      pub fun createEmptyVault(): @FungibleToken.Vault {
          return <- create Vault(balance: 0.0)
      }

      access(contract) fun initialMint(initialMintValue: UFix64): @FungibleToken.Vault {
          return <- create Vault(balance: initialMintValue)
      }

      pub resource Minter {
          pub fun mintTokens(amount: UFix64): @FungibleToken.Vault {
          pre {
                  amount > 0.0: "Amount minted must be greater than zero"
              }
              MyToken.totalSupply = MyToken.totalSupply + amount
              return <- create Vault(balance:amount)
          }

      }

      init() {
          self.totalSupply = 100.00
          self.TokenVaultStoragePath = /storage/MyTokenVault
          self.TokenVaultPublicPath = /public/MyTokenVault
          self.TokenMinterStoragePath = /storage/MyTokenMinter

          self.account.save(<- create Minter(), to: MyToken.TokenMinterStoragePath)

         //
         // Create an Empty Vault for the Minter
         //
          self.account.save(<- MyToken.initialMint(initialMintValue: self.totalSupply), to: MyToken.TokenVaultStoragePath)
          self.account.link<&MyToken.Vault{FungibleToken.Balance, FungibleToken.Receiver}>(MyToken.TokenVaultPublicPath, target: MyToken.TokenVaultStoragePath)
      }
   }

      "
-------
"//  SPDX-License-Identifier: UNLICENSED
//
//
import NonFungibleToken from 0x1d7e57aa55817448
import Anique from 0xe2e1689b53e92a82

pub contract oshiro_robots: NonFungibleToken, Anique {
    // -----------------------------------------------------------------------
    // oshiro_robots contract Events
    // -----------------------------------------------------------------------

    // Events for Contract-Related actions
    //
    // Emitted when the oshiro_robots contract is created
    pub event ContractInitialized()

    // Events for Item-Related actions
    //
    // Emitted when a new Item struct is created
    pub event ItemCreated(id: UInt32, metadata: {String:String})

    // Events for Collectible-Related actions
    //
    // Emitted when an CollectibleData NFT is minted
    pub event CollectibleMinted(collectibleID: UInt64, itemID: UInt32, serialNumber: UInt32)
    // Emitted when an CollectibleData NFT is destroyed
    pub event CollectibleDestroyed(collectibleID: UInt64)

    // events for Collection-related actions
    //
    // Emitted when an CollectibleData is withdrawn from a Collection
    pub event Withdraw(id: UInt64, from: Address?)
    // Emitted when an CollectibleData is deposited into a Collection
    pub event Deposit(id: UInt64, to: Address?)

    // paths
    pub let collectionStoragePath: StoragePath
    pub let collectionPublicPath: PublicPath
    pub let collectionPrivatePath: PrivatePath
    pub let adminStoragePath: StoragePath
    pub let saleCollectionStoragePath: StoragePath
    pub let saleCollectionPublicPath: PublicPath

    // -----------------------------------------------------------------------
    // oshiro_robots contract-level fields.
    // These contain actual values that are stored in the smart contract.
    // -----------------------------------------------------------------------

    // fields for Item-related
    //
    // variable size dictionary of Item resources
    access(self) var items: @{UInt32: Item}

    // The ID that is used to create Items.
    pub var nextItemID: UInt32

    // fields for Collectible-related
    //
    // Total number of CollectibleData NFTs that have been minted ever.
    pub var totalSupply: UInt64

    // -----------------------------------------------------------------------
    // oshiro_robots contract-level Composite Type definitions
    // -----------------------------------------------------------------------

    // The structure that represents Item
    // each digital content which oshiro_robots deal with on Flow
    //
    pub struct ItemData {

        pub let itemID: UInt32

        pub let metadata: {String: String}

        init(itemID: UInt32) {
            let item = (&oshiro_robots.items[itemID] as &Item?)!

            self.itemID = item.itemID
            self.metadata = item.metadata
        }
   }

    // Item is a resource type that contains the functions to mint Collectibles.
    //
    // It is stored in a private field in the contract so that
    // the admin resource can call its methods and that there can be
    // public getters for some of its fields
    //
    // The admin can mint Collectibles that refer from Item.
    pub resource Item {

        // unique ID for the Item
        pub let itemID: UInt32

        // Stores all the metadata about the item as a string mapping
        // This is not the long term way NFT metadata will be stored. It's a temporary
        // construct while we figure out a better way to do metadata.
        //
        pub let metadata: {String: String}

        // The number of Collectibles that have been minted per Item.
        access(contract) var numberMintedPerItem: UInt32

        init(metadata: {String: String}) {
            pre {
                metadata.length != 0: "New Item metadata cannot be empty"
            }
            self.itemID = oshiro_robots.nextItemID
            self.metadata = metadata
            self.numberMintedPerItem = 0

            // increment the nextItemID so that it isn't used again
            oshiro_robots.nextItemID = oshiro_robots.nextItemID + 1

            emit ItemCreated(id: self.itemID, metadata: metadata)
        }

        // mintCollectible mints a new Collectible and returns the newly minted Collectible
        //
        // Returns: The NFT that was minted
        //
        pub fun mintCollectible(): @NFT {
            // get the number of Collectibles that have been minted for this Item
            // to use as this Collectible's serial number
            let numInItem = self.numberMintedPerItem

            // mint the new Collectible
            let newCollectible: @NFT <- create NFT(serialNumber: numInItem + 1,
                                              itemID: self.itemID)

            // Increment the count of Collectibles minted for this Item
            self.numberMintedPerItem = numInItem + 1

            return <-newCollectible
        }

        // batchMintCollectible mints an arbitrary quantity of Collectibles
        // and returns them as a Collection
        //
        // Parameters: itemID: the ID of the Item that the Collectibles are minted for
        //             quantity: The quantity of Collectibles to be minted
        //
        // Returns: Collection object that contains all the Collectibles that were minted
        //
        pub fun batchMintCollectible(quantity: UInt64): @Collection {
            let newCollection <- create Collection()

            var i: UInt64 = 0
            while i < quantity {
                newCollection.deposit(token: <-self.mintCollectible())
                i = i + 1
            }

            return <-newCollection
        }

        // Returns: the number of Collectibles
        pub fun getNumberMinted(): UInt32 {
            return self.numberMintedPerItem
        }
    }

    // The structure holds metadata of an Collectible
    pub struct CollectibleData {
        // The ID of the Item that the Collectible references
        pub let itemID: UInt32

        // The place in the Item that this Collectible was minted
        pub let serialNumber: UInt32

        init(itemID: UInt32, serialNumber: UInt32) {
            self.itemID = itemID
            self.serialNumber = serialNumber
        }
    }

    // The resource that represents the CollectibleData NFTs
    //
    pub resource NFT: NonFungibleToken.INFT, Anique.INFT {

        // Global unique collectibleData ID
        pub let id: UInt64

        // Struct of Collectible metadata
        pub let data: CollectibleData

        init(serialNumber: UInt32, itemID: UInt32) {
            // Increment the global Collectible IDs
            oshiro_robots.totalSupply = oshiro_robots.totalSupply + 1

            // set id
            self.id = oshiro_robots.totalSupply

            // Set the metadata struct
            self.data = CollectibleData(itemID: itemID, serialNumber: serialNumber)

            emit CollectibleMinted(collectibleID: self.id, itemID: itemID, serialNumber: self.data.serialNumber)
        }

        destroy() {
            emit CollectibleDestroyed(collectibleID: self.id)
        }
    }

    // interface that represents oshiro_robots collections to public
    // extends of NonFungibleToken.CollectionPublic
    pub resource interface CollectionPublic {

        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT

        // deposit multi tokens
        pub fun batchDeposit(tokens: @Anique.Collection)

        // contains NFT
        pub fun contains(id: UInt64): Bool

        // borrow NFT as oshiro_robots token
        pub fun borrowoshiro_robotsCollectible(id: UInt64): auth &NFT
    }

    // Collection is a resource that every user who owns NFTs
    // will store in their account to manage their NFTs
    //
    pub resource Collection: CollectionPublic, NonFungibleToken.Receiver, NonFungibleToken.Provider, NonFungibleToken.CollectionPublic {
        // Dictionary of CollectibleData conforming tokens
        // NFT is a resource type with a UInt64 ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init() {
            self.ownedNFTs <- {}
        }

        // withdraw removes a Collectible from the Collection and moves it to the caller
        //
        // Parameters: withdrawID: The ID of the NFT
        // that is to be removed from the Collection
        //
        // returns: @NonFungibleToken.NFT the token that was withdrawn
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {

            // Remove the nft from the Collection
            let token <- self.ownedNFTs.remove(key: withdrawID)
                ?? panic("Cannot withdraw: Collectible does not exist in the collection")

            emit Withdraw(id: token.id, from: self.owner?.address)

            // Return the withdrawn token
            return <- token
        }

        // batchWithdraw withdraws multiple tokens and returns them as a Collection
        //
        // Parameters: collectibleIds: An array of IDs to withdraw
        //
        // Returns: @NonFungibleToken.Collection: A collection that contains
        //                                        the withdrawn collectibles
        //
        pub fun batchWithdraw(collectibleIds: [UInt64]): @Anique.Collection {
            // Create a new empty Collection
            var batchCollection <- create Collection()

            // Iterate through the collectibleIds and withdraw them from the Collection
            for collectibleID in collectibleIds {
                batchCollection.deposit(token: <-self.withdraw(withdrawID: collectibleID))
            }

            // Return the withdrawn tokens
            return <-batchCollection
        }

        // deposit takes a Collectible and adds it to the Collections dictionary
        //
        // Parameters: token: the NFT to be deposited in the collection
        //
        pub fun deposit(token: @NonFungibleToken.NFT) {

            // Cast the deposited token as an oshiro_robots NFT to make sure
            // it is the correct type
            let token <- token as! @oshiro_robots.NFT

            // Get the token's ID
            let id = token.id

            // Add the new token to the dictionary
            let oldToken <- self.ownedNFTs[id] <- token

            // Only emit a deposit event if the Collection
            // is in an account's storage
            if self.owner?.address != nil {
                emit Deposit(id: id, to: self.owner?.address)
            }

            // Destroy the empty old token that was "removed"
            destroy oldToken
        }

        // batchDeposit takes a Collection object as an argument
        // and deposits each contained NFT into this Collection
        pub fun batchDeposit(tokens: @Anique.Collection) {

            // Get an array of the IDs to be deposited
            let keys = tokens.getIDs()

            // Iterate through the keys in the collection and deposit each one
            for key in keys {
                self.deposit(token: <-tokens.withdraw(withdrawID: key))
            }

            // Destroy the empty Collection
            destroy tokens
        }

        // getIDs returns an array of the IDs that are in the Collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // contains returns whether ID is in the Collection
        pub fun contains(id: UInt64): Bool {
            return self.ownedNFTs[id] != nil
        }

        // borrowNFT Returns a borrowed reference to a Collectible in the Collection
        // so that the caller can read its ID
        //
        // Parameters: id: The ID of the NFT to get the reference for
        //
        // Returns: A reference to the NFT
        //
        // Note: This only allows the caller to read the ID of the NFT,
        // not any oshiro_robots specific data. Please use borrowCollectible to
        // read Collectible data.
        //
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowAniqueNFT(id: UInt64): auth &Anique.NFT {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            return nft as! auth &Anique.NFT
        }

        // borrowoshiro_robotsCollectible returns a borrowed reference
        // to an oshiro_robots Collectible
        pub fun borrowoshiro_robotsCollectible(id: UInt64): auth &NFT {
            pre {
                self.ownedNFTs[id] != nil: "NFT does not exist in the collection!"
            }
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            return nft as! auth &NFT
        }

        // If a transaction destroys the Collection object,
        // All the NFTs contained within are also destroyed!
        //
        destroy() {
            destroy self.ownedNFTs
        }
    }

    // Admin is a special authorization resource that
    // allows the owner to perform important functions to modify the
    // various aspects of the Items, CollectibleDatas, etc.
    //
    pub resource Admin {

        // createItem creates a new Item struct
        // and stores it in the Items dictionary field in the oshiro_robots smart contract
        //
        // Parameters: metadata: A dictionary mapping metadata titles to their data
        //                       example: {"Title": "Excellent Anime", "Author": "John Smith"}
        //
        // Returns: the ID of the new Item object
        //
        pub fun createItem(metadata: {String: String}): UInt32 {
            // Create the new Item
            var newItem <- create Item(metadata: metadata)
            let itemId = newItem.itemID

            // Store it in the contract storage
            oshiro_robots.items[newItem.itemID] <-! newItem

            return itemId
        }

        // borrowItem returns a reference to a Item in the oshiro_robots
        // contract so that the admin can call methods on it
        //
        // Parameters: itemID: The ID of the Item that you want to
        // get a reference to
        //
        // Returns: A reference to the Item with all of the fields
        // and methods exposed
        //
        pub fun borrowItem(itemID: UInt32): &Item {
            pre {
                oshiro_robots.items[itemID] != nil: "Cannot borrow Item: The Item doesn't exist"
            }

            return (&oshiro_robots.items[itemID] as &Item?)!
        }

        // createNewAdmin creates a new Admin resource
        //
        pub fun createNewAdmin(): @Admin {
            return <-create Admin()
        }
    }

    // -----------------------------------------------------------------------
    // oshiro_robots contract-level function definitions
    // -----------------------------------------------------------------------

    // createEmptyCollection creates a new, empty Collection object so that
    // a user can store it in their account storage.
    // Once they have a Collection in their storage, they are able to receive
    // Collectibles in transactions.
    //
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <-create oshiro_robots.Collection()
    }

    // getNumCollectiblesInItem return the number of Collectibles that have been
    //                        minted from a certain Item.
    //
    // Parameters: itemID: The id of the Item that is being searched
    //
    // Returns: The total number of Collectibles
    //          that have been minted from a Item
    pub fun getNumCollectiblesInItem(itemID: UInt32): UInt32 {
        let item = (&oshiro_robots.items[itemID] as &Item?)!
        return item.numberMintedPerItem
    }

    // -----------------------------------------------------------------------
    // oshiro_robots initialization function
    // -----------------------------------------------------------------------
    //
    init() {
        // Initialize contract fields
        self.items <- {}
        self.nextItemID = 1
        self.totalSupply = 0

        self.collectionStoragePath     = /storage/oshiro_robotsCollection
        self.collectionPublicPath      =  /public/oshiro_robotsCollection
        self.collectionPrivatePath     = /private/oshiro_robotsCollection
        self.adminStoragePath          = /storage/oshiro_robotsAdmin
        self.saleCollectionStoragePath = /storage/oshiro_robotsSaleCollection
        self.saleCollectionPublicPath  =  /public/oshiro_robotsSaleCollection

        // Put a new Collection in storage
        self.account.save<@Collection>(<- create Collection(), to: self.collectionStoragePath)

        // Create a public capability for the Collection
        self.account.link<&{CollectionPublic}>(self.collectionPublicPath, target: self.collectionStoragePath)

        // Put the Admin in storage
        self.account.save<@Admin>(<- create Admin(), to: self.adminStoragePath)

        emit ContractInitialized()
    }
}
"
-------
" pub contract BasicNFT{

    pub var totalSupply: UInt64

    init(){
        self.totalSupply = 0
    }

    pub resource interface NFTPublic{
        pub fun getID(): UInt64
        pub fun getURL(): String
    }

    pub resource NFT: NFTPublic{

        pub let id: UInt64
        pub var metadata: {String: String}

        init(InitURL: String){
            self.id = BasicNFT.totalSupply
            self.metadata = {"URL": InitURL}
            BasicNFT.totalSupply = BasicNFT.totalSupply + 1
        }

        pub fun getID(): UInt64{
            return self.id
        }

        pub fun getURL(): String{
            return self.metadata["URL"]!
        }

    }

    pub fun createNFT(url: String): @NFT{
        return <- create NFT(InitURL: url)
    }

}"
-------
"/// CapabilityDelegator is a contract used to share Capabiltities to other accounts. It is used by the
/// HybridCustody contract to allow more flexible sharing of Capabilities when an app wants to share things
/// that aren't the NFT-standard interface types.
///
/// Inside of CapabilityDelegator is a resource called `Delegator` which maintains a mapping of public and private
/// Capabilities. They cannot and should not be mixed. A public `Delegator` is able to be borrowed by anyone, whereas a
/// private `Delegator` can only be borrowed from the child account when you have access to the full `ChildAccount`
/// resource.
///
pub contract CapabilityDelegator {

    /* --- Canonical Paths --- */
    //
    pub let StoragePath: StoragePath
    pub let PrivatePath: PrivatePath
    pub let PublicPath: PublicPath

    /* --- Events --- */
    //
    pub event DelegatorCreated(id: UInt64)
    pub event DelegatorUpdated(id: UInt64, capabilityType: Type, isPublic: Bool, active: Bool)

    /// Private interface for Capability retrieval
    ///
    pub resource interface GetterPrivate {
        pub fun getPrivateCapability(_ type: Type): Capability? {
            post {
                result == nil || type.isSubtype(of: result.getType()): "incorrect returned capability type"
            }
        }
        pub fun findFirstPrivateType(_ type: Type): Type?
        pub fun getAllPrivate(): [Capability]
    }

    /// Exposes public Capability retrieval
    ///
    pub resource interface GetterPublic {
        pub fun getPublicCapability(_ type: Type): Capability? {
            post {
                result == nil || type.isSubtype(of: result.getType()): "incorrect returned capability type "
            }
        }

        pub fun findFirstPublicType(_ type: Type): Type?
        pub fun getAllPublic(): [Capability]
    }

    /// This Delegator is used to store Capabilities, partitioned by public and private access with corresponding
    /// GetterPublic and GetterPrivate conformances.AccountCapabilityController
    ///
    pub resource Delegator: GetterPublic, GetterPrivate {
        access(self) let privateCapabilities: {Type: Capability}
        access(self) let publicCapabilities: {Type: Capability}

        // ------ Begin Getter methods
        //
        /// Returns the public Capability of the given Type if it exists
        ///
        pub fun getPublicCapability(_ type: Type): Capability? {
            return self.publicCapabilities[type]
        }

        /// Returns the private Capability of the given Type if it exists
        ///
        ///
        /// @param type: Type of the Capability to retrieve
        /// @return Capability of the given Type if it exists, nil otherwise
        ///
        pub fun getPrivateCapability(_ type: Type): Capability? {
            return self.privateCapabilities[type]
        }

        /// Returns all public Capabilities
        ///
        /// @return List of all public Capabilities
        ///
        pub fun getAllPublic(): [Capability] {
            return self.publicCapabilities.values
        }

        /// Returns all private Capabilities
        ///
        /// @return List of all private Capabilities
        ///
        pub fun getAllPrivate(): [Capability] {
            return self.privateCapabilities.values
        }

        /// Returns the first public Type that is a subtype of the given Type
        ///
        /// @param type: Type to check for subtypes
        /// @return First public Type that is a subtype of the given Type, nil otherwise
        ///
        pub fun findFirstPublicType(_ type: Type): Type? {
            for t in self.publicCapabilities.keys {
                if t.isSubtype(of: type) {
                    return t
                }
            }

            return nil
        }

        /// Returns the first private Type that is a subtype of the given Type
        ///
        /// @param type: Type to check for subtypes
        /// @return First private Type that is a subtype of the given Type, nil otherwise
        ///
        pub fun findFirstPrivateType(_ type: Type): Type? {
            for t in self.privateCapabilities.keys {
                if t.isSubtype(of: type) {
                    return t
                }
            }

            return nil
        }
        // ------- End Getter methods

        /// Adds a Capability to the Delegator
        ///
        /// @param cap: Capability to add
        /// @param isPublic: Whether the Capability should be public or private
        ///
        pub fun addCapability(cap: Capability, isPublic: Bool) {
            pre {
                cap.check<&AnyResource>(): "Invalid Capability provided"
            }
            if isPublic {
                self.publicCapabilities.insert(key: cap.getType(), cap)
            } else {
                self.privateCapabilities.insert(key: cap.getType(), cap)
            }
            emit DelegatorUpdated(id: self.uuid, capabilityType: cap.getType(), isPublic: isPublic, active: true)
        }

        /// Removes a Capability from the Delegator
        ///
        /// @param cap: Capability to remove
        ///
        pub fun removeCapability(cap: Capability) {
            if let removedPublic = self.publicCapabilities.remove(key: cap.getType()) {
                emit DelegatorUpdated(id: self.uuid, capabilityType: cap.getType(), isPublic: true, active: false)
            }

            if let removedPrivate = self.privateCapabilities.remove(key: cap.getType()) {
                emit DelegatorUpdated(id: self.uuid, capabilityType: cap.getType(), isPublic: false, active: false)
            }
        }

        init() {
            self.privateCapabilities = {}
            self.publicCapabilities = {}
        }
    }

    /// Creates a new Delegator and returns it
    ///
    /// @return Newly created Delegator
    ///
    pub fun createDelegator(): @Delegator {
        let delegator <- create Delegator()
        emit DelegatorCreated(id: delegator.uuid)
        return <- delegator
    }

    init() {
        let identifier = "CapabilityDelegator_".concat(self.account.address.toString())
        self.StoragePath = StoragePath(identifier: identifier)!
        self.PrivatePath = PrivatePath(identifier: identifier)!
        self.PublicPath = PublicPath(identifier: identifier)!
    }
}
 "
-------
"import CapabilityFactory from 0xd8a7e05a7ac670c0
import FungibleToken from 0xf233dcee88fe0abe

pub contract FTReceiverFactory {
    pub struct Factory: CapabilityFactory.Factory {
        pub fun getCapability(acct: &AuthAccount, path: CapabilityPath): Capability {
            return acct.getCapability<&{FungibleToken.Receiver}>(path)
        }
    }
}"
-------
"pub contract StrikeNowData {

  //Should look like:
  // {
  //   "seriesId": "1",
  //   "seriesName": "UFC 292 Oezdemir vs. Smith",
  //   "seriesDescription": "UFC 292 Inaugral Launch",
  //   "eventId": "890",
  //   "season": "1",
  //   "eventTime": "1691694054.0",
  // }
  pub struct SeriesData {
    pub let seriesId: UInt32
    pub let seriesName: String
    pub let seriesDescription: String
    pub let eventId: UInt32
    pub let eventTime: UFix64
    pub let season: String
    pub let fights: {UInt32: FightData}
    pub let metadataRaw: {String: String}
    pub let fightsRaw: [{String: String}]?

    //NOTE $BS - If you are missing any of the required fields this fails silently and
    //nothing I can do in this init block propagates the error correctly (pre, panic, etc)
    init(seriesId: UInt32, metadata: {String: String}, fights: [{String: String}]?) {
      self.seriesId = seriesId
      self.seriesName = metadata["seriesName"]!
      self.seriesDescription = metadata["seriesDescription"]!
      self.eventId = UInt32.fromString(metadata["eventId"]!)!
      self.season = metadata["season"]!
      self.eventTime = UFix64.fromString(metadata["eventTime"]!)!
      self.metadataRaw = metadata
      self.fightsRaw = fights
      self.fights = {}

      if fights != nil && fights?.length! > 0 {
        for fight in fights! {
          let id = UInt32.fromString(fight["fightId"]!)!
          self.fights[id] = StrikeNowData.FightData(fightId: id, input: fight)
        }
      }
    }
  }

  // Should look like:
  // {
  //   "fightId": "7441",
  //   "fightName": "Oezdemir vs Smith",
  //   "cardSegment": "Main",
  //   "weightClass": "Featherweight",
  //   "weightClassDescription": "136-145",
  //   "city": "Moncton",
  //   "state": "New Brunswick",
  //   "country": "Canada",
  // }
  pub struct FightData {
    pub let fightId: UInt32
    pub let fightName: String
    pub let cardSegment: String
    pub let weightClass: String
    pub let weightClassDescription: String
    pub let city: String
    pub let state: String
    pub let country: String

    init(fightId: UInt32, input: {String: String})
    {
      self.fightId = fightId
      self.fightName = input["fightName"]!
      self.cardSegment = input["cardSegment"]!
      self.weightClass = input["weightClass"]!
      self.weightClassDescription = input["weightClassDescription"]!
      self.city = input["city"]!
      self.state = input["state"]!
      self.country = input["country"]!
    }
  }

  //Should look like this
  // {
  //   "setId": "1",
  //   "fightId": "7441",
  //   "fighterId": "5",
  //   "fighterName": "Test Oezdemir",
  //   "fightDescription": "Oezdemir faces Smith for the title",
  //   "thumbnail": "0",
  //   "mainAsset": "1",
  //   "opponentName": "Test Smith",
  //   "editionName": "Snapshot",
  //   "price": "5.75",
  //   "externalURL": "http://ufc292.oezdemir.strikenow.com"
  // }
  pub struct SetData {
    pub let setId: UInt32
    pub let seriesId: UInt32
    pub let editionName: String
    pub let price: UFix64
    pub let fightId: UInt32
    pub let thumbnail: UInt32
    pub let fighterName: String
    pub let fightDescription: String
    pub let opponentName: String
    pub let externalURL: String?
    pub let fightResult: FightResult?
    pub let assets: {UInt32: AssetData}?
    pub let fightResultRaw: {String: String}?
    pub let assetsRaw: [{String: String}]?
    pub let metadataRaw: {String: String}

    init(
      setId: UInt32,
      seriesId: UInt32,
      metadata: {String: String},
      assets: [{String: String}]?,
      result: {String: String}?) {

      self.setId = setId
      self.seriesId = seriesId
      self.fightResultRaw = result
      self.assetsRaw = assets
      self.metadataRaw = metadata
      self.fightId = UInt32.fromString(metadata["fightId"]!)!
      self.editionName = metadata["editionName"]!
      self.price = UFix64.fromString(metadata["price"]!)!
      self.thumbnail = UInt32.fromString(metadata["thumbnail"]!)!
      self.fighterName = metadata["fighterName"]!
      self.fightDescription = metadata["fightDescription"]!
      self.opponentName = metadata["opponentName"]!
      self.externalURL = metadata["externalURL"]

      if assets != nil && assets?.length! > 0 {
        let output: {UInt32: AssetData} = {}
        for asset in assets! {
          let id = UInt32.fromString(asset["assetId"]!)!
          output[id] = StrikeNowData.AssetData(id, asset)
        }
        self.assets = output
      } else {
        self.assets = nil
      }

      if result != nil && result?.length! > 0 {
        self.fightResult = StrikeNowData.FightResult(result!)
      } else {
        self.fightResult = nil
      }
    }
  }

  // Should look like
  // {
  //   "assetURI": "https://testasset.com/assetOne",
  //   "assetFileType": "mp4",
  //   "assetId": "0"
  // }
  pub struct AssetData {
    pub let assetId: UInt32
    pub let assetURI: String
    pub let assetFileType: String
    pub let rawData: {String: String}

    init(assetId: UInt32, rawData: {String: String}) {
      self.assetId = assetId
      self.rawData = rawData
      self.assetURI = rawData["assetURI"]!
      self.assetFileType = rawData["assetFileType"]!
    }
  }

  // Should look like this
  // {
  //   "outcome": "Win", //THIS MUST BE EITHER "Win" or "Lose"
  //   "grade": "Gold",
  //   "method": "Submission",
  //   "endingRound": "3",
  //   "endingTime": "1:24",
  //   "endingPosition":"From Back Control",
  //   "edingSubmission":"Rear Naked Choke",
  //   "wins": "32",
  //   "losses": "15",
  //   "draws": "0",
  //   "knockdowns": "0",
  //   "strikeAttempts": "45",
  //   "strikesLanded": "32",
  //   "significantStrikes": "3",
  //   "takedownAttempts": "5",
  //   "takedownsLanded": "2",
  //   "submissionAttempts": "3",
  // }
  pub struct FightResult {
    pub let outcome: String
    pub let won: Bool
    pub let grade: String
    pub let method: String
    pub let endingRound: UInt16
    pub let endingTime: String
    pub let endingStrike: String?
    pub let endingTarget: String?
    pub let endingPosition: String?
    pub let endingSubmission: String?
    pub let wins: UInt16
    pub let losses: UInt16
    pub let draws: UInt16
    pub let strikeAttempts: UInt16
    pub let strikesLanded: UInt16
    pub let significantStrikes: UInt16
    pub let takedownAttempts: UInt16
    pub let takedownsLanded: UInt16
    pub let submissionAttempts: UInt16
    pub let knockdowns: UInt16

    init(input: {String: String}) {
      self.outcome = input["outcome"]!
      self.won = self.outcome.toLower() == "win" || self.outcome.toLower() == "won"
        || self.outcome.toLower() == "victory"
      self.grade = input["grade"]!
      self.method = input["method"]!
      self.endingRound = UInt16.fromString(input["endingRound"]!)!
      self.endingTime = input["endingTime"]!
      self.endingStrike = input["endingStrike"]
      self.endingTarget = input["endingTarget"]
      self.endingPosition = input["endingPosition"]
      self.endingSubmission = input["endingSubmission"]
      self.wins = UInt16.fromString(input["wins"]!)!
      self.losses = UInt16.fromString(input["losses"]!)!
      self.draws = UInt16.fromString(input["draws"]!)!
      self.strikeAttempts = UInt16.fromString(input["strikeAttempts"]!)!
      self.strikesLanded = UInt16.fromString(input["strikesLanded"]!)!
      self.significantStrikes = UInt16.fromString(input["significantStrikes"]!)!
      self.takedownAttempts = UInt16.fromString(input["takedownAttempts"]!)!
      self.takedownsLanded = UInt16.fromString(input["takedownsLanded"]!)!
      self.submissionAttempts = UInt16.fromString(input["submissionAttempts"]!)!
      self.knockdowns = UInt16.fromString(input["knockdowns"]!)!
    }
  }

  //Should look like this
  // let input = {
  //   "collectionName": "UFC Strike Now",
  //   "collectionDescription": "UFC Strike Now: Commemorate The Fight. Win The Night.",
  //   "externalURL": "https://ufcstrike.com/now",
  //   "squareImageURL": "https://media.gigantik.io/ufc/square.png",
  //   "squareImageMediaType": "image/png",
  //   "bannerImageURL": "https://media.gigantik.io/ufc/banner.png",
  //   "bannerImageMediaType": "image/png"
  // }
  // let socials = {
  //   "instagram": "https://instagram.com/ufcstrike",
  //   "twitter": "https://twitter.com/UFCStrikeNFT",
  //   "discord": "https://discord.gg/UFCStrike"
  // }
  pub struct ConfigData {
    pub let collectionName: String
    pub let collectionDescription: String
    pub let externalURL: String
    pub let squareImageURL: String
    pub let squareImageMediaType: String
    pub let bannerImageURL: String
    pub let bannerImageMediaType: String
    pub let socials: { String: String }

    init(input: { String: String }, socials: { String: String }) {
      self.collectionName = input["collectionName"]!
      self.collectionDescription = input["collectionDescription"]!
      self.externalURL = input["externalURL"]!
      self.squareImageURL = input["squareImageURL"]!
      self.squareImageMediaType = input["squareImageMediaType"]!
      self.bannerImageURL = input["bannerImageURL"]!
      self.bannerImageMediaType = input["bannerImageMediaType"]!
      self.socials = socials
    }
  }
}"
-------
"/**
# Contract: FantastecSwapDataV2
# Description:

The purpose of this contract is to provide a central location to hold and maintain metadata about Fantastec Swap's Cards and Collections.

Collections represent a themed set of Cards, as indicated on their attributes.
Collections have 0 or more Cards associated with them.
Cards represent an individual item or moment of interest - a digital card of a player or stadium, a video moment, a VR scene, or access to other resources.
An NFT will be minted against individual Card.
*/

import FantastecSwapDataProperties from 0x4bbff461fa8f6192

pub contract FantastecSwapDataV2 {

  /** EVENTS **/
  // Contract Events
  pub event ContractInitialized()

  // Card Events
  pub event CardCreated(id: UInt64)
  pub event CardUpdated(id: UInt64)
  pub event CardDeleted(id: UInt64)

  // CardCollection Events
  pub event CardCollectionCreated(id: UInt64)
  pub event CardCollectionUpdated(id: UInt64)
  pub event CardCollectionDeleted(id: UInt64)

  pub let AdminStoragePath: StoragePath
  pub let DataStoragePath: StoragePath

  /** CONTRACT LEVEL STRUCTS */
  pub struct CardCollectionData {
    pub let id: UInt64;
    pub var title: String;
    pub var description: String;
    pub var type: String;
    pub var mintVolume: UInt64;
    pub var metadata: {String: [AnyStruct{FantastecSwapDataProperties.MetadataElement}]}

    access(contract) fun save(){
      FantastecSwapDataV2.getDataManager().setCardCollectionData(self)
    }

    init(
      _ id: UInt64,
      _ title: String,
      _ description: String,
      _ type: String,
      _ mintVolume: UInt64,
    ){
      self.id = id;
      self.title = title;
      self.description = description;
      self.type = type;
      self.mintVolume = mintVolume;
      self.metadata = {};
    }

    access(contract) fun addMetadata(
      _ type: String,
      _ metadata: AnyStruct{FantastecSwapDataProperties.MetadataElement},
    ) {
      if (self.metadata[type] == nil) {
        self.metadata[type] = []
      }
      self.metadata[type] = FantastecSwapDataV2.addToMetadata(type, self.metadata[type]!, metadata)
    }

    access(contract) fun removeMetadata(
      _ type: String,
      _ id: UInt64?,
    ) {
      if (self.metadata[type] == nil) {
        self.metadata[type] = []
      }
      self.metadata[type] = FantastecSwapDataV2.removeFromMetadata(type, self.metadata[type]!, id)
    }
  }

  pub struct CardData {
    pub let id: UInt64;
    pub var name: String;
    pub var type: String;
    pub var aspectRatio: String;
    pub var collectionOrder: UInt32;
    pub var collectionId: UInt64;
    pub var metadata: {String: [AnyStruct{FantastecSwapDataProperties.MetadataElement}]}

    access(contract) fun save(){
      FantastecSwapDataV2.getDataManager().setCardData(self)
    }

    init(
      _ id: UInt64,
      _ name: String,
      _ type: String,
      _ aspectRatio: String,
      _ collectionOrder: UInt32,
      _ collectionId: UInt64,
    ){
      pre {
        FantastecSwapDataV2.getDataManager().cardCollectionData[collectionId] != nil: "cannot create cardData when collection ID does not exist"
      }

      self.id = id;
      self.name = name;
      self.type = type;
      self.aspectRatio = aspectRatio;
      self.collectionOrder = collectionOrder;
      self.collectionId = collectionId;
      self.metadata = {};
    }

    access(contract) fun addMetadata(
      _ type: String,
      _ metadata: AnyStruct{FantastecSwapDataProperties.MetadataElement},
    ) {
      if (self.metadata[type] == nil) {
        self.metadata[type] = []
      }
      self.metadata[type] = FantastecSwapDataV2.addToMetadata(type, self.metadata[type]!, metadata)
    }

    access(contract) fun removeMetadata(
      _ type: String,
      _ id: UInt64?,
    ) {
      if (self.metadata[type] == nil) {
        self.metadata[type] = []
      }
      self.metadata[type] = FantastecSwapDataV2.removeFromMetadata(type, self.metadata[type]!, id)
    }
  }

  pub resource Admin {
    // ------------------------
    // CardCollection functions
    // ------------------------
    access(self) fun getCardCollection(id: UInt64): CardCollectionData {
      let cardCollection = FantastecSwapDataV2.getCardCollectionById(id: id)
        ?? panic("No CardCollection found with id: ".concat(id.toString()))
      return cardCollection
    }

    pub fun addCardCollection(
      id: UInt64,
      title: String,
      description: String,
      type: String,
      mintVolume: UInt64,
    ) {

      var newCardCollection = CardCollectionData(id, title, description, type, mintVolume)

      newCardCollection.save()

      emit CardCollectionCreated(id: newCardCollection.id)
    }

    pub fun removeCardCollection(id: UInt64) {
      FantastecSwapDataV2.getDataManager().removeCardCollectionData(id)
      emit CardCollectionDeleted(id: id)
    }

    pub fun addCardCollectionMetadata(
      collectionId: UInt64,
      metadataType: String,
      metadata: AnyStruct{FantastecSwapDataProperties.MetadataElement},
    ) {
      let cardCollection = self.getCardCollection(id: collectionId)
      cardCollection.addMetadata(metadataType, metadata)
      cardCollection.save()
    }

    pub fun removeCardCollectionMetadata(
      collectionId: UInt64,
      metadataType: String,
      metadataId: UInt64,
    ) {
      let cardCollection = self.getCardCollection(id: collectionId)
      cardCollection.removeMetadata(metadataType, metadataId)
      cardCollection.save()
    }

    pub fun emitCardCollectionUpdated(_ id: UInt64){
      emit CardCollectionUpdated(id: id)
    }

    // --------------
    // Card functions
    // --------------
    access(self) fun getCard(id: UInt64): FantastecSwapDataV2.CardData {
      let card = FantastecSwapDataV2.getCardById(id: id)
        ?? panic("No Card found with id: ".concat(id.toString()))
      return card
    }

    pub fun addCard(
      id: UInt64,
      name: String,
      type: String,
      aspectRatio: String,
      collectionOrder: UInt32,
      collectionId: UInt64,
    ) {
      var newCard: CardData = CardData(id, name, type, aspectRatio, collectionOrder, collectionId)

      newCard.save()

      emit CardCreated(id: newCard.id)
    }

    pub fun removeCard(id: UInt64) {
      FantastecSwapDataV2.getDataManager().removeCardData(id)
      emit CardDeleted(id: id)
    }

    pub fun addCardMetadata(
      cardId: UInt64,
      metadataType: String,
      metadata: AnyStruct{FantastecSwapDataProperties.MetadataElement},
    ) {
      let card = self.getCard(id: cardId)
      card.addMetadata(metadataType, metadata)
      card.save()
    }

    pub fun removeCardMetadata(
      cardId: UInt64,
      metadataType: String,
      metadataId: UInt64,
    ) {
      let card = self.getCard(id: cardId)
      card.removeMetadata(metadataType, metadataId)
      card.save()
    }
    pub fun emitCardUpdated(_ id: UInt64) {
      emit CardUpdated(id: id)
    }
  }

  pub resource DataManager {
    access(contract) var cardCollectionData: {UInt64: CardCollectionData}
    access(contract) var cardData: {UInt64: CardData}

    access(contract) fun setCardCollectionData(_ cardCollection: CardCollectionData) {
      self.cardCollectionData[cardCollection.id] = cardCollection
    }

    access(contract) fun removeCardCollectionData(_ cardCollectionId: UInt64) {
      self.cardCollectionData.remove(key: cardCollectionId)
    }

    access(contract) fun setCardData(_ card: CardData) {
      self.cardData[card.id] = card
    }

    access(contract) fun removeCardData(_ cardId: UInt64) {
      self.cardData.remove(key: cardId)
    }

    init(_ cardCollectionData: {UInt64: CardCollectionData}, _ cardData: {UInt64: CardData}) {
      self.cardCollectionData = cardCollectionData
      self.cardData = cardData
    }
  }

  /** PUBLIC GETTING FUNCTIONS */
  // ------------------------
  // CardCollection functions
  // ------------------------
  pub fun getCardCollectionById(id: UInt64): CardCollectionData? {
    return self.getDataManager().cardCollectionData[id]
  }

  pub fun getCardCollectionIds(): [UInt64] {
    var keys:[UInt64] = []
    for collection in self.getDataManager().cardCollectionData.values {
      keys.append(collection.id)
    }
    return keys;
  }

  // --------------
  // Card functions
  // --------------
  pub fun getAllCards(_ offset: Int?, _ pageSize: Int?): {UInt64: CardData} {
    let cardIds = self.getCardIds(offset, pageSize)
    let dataManager = self.getDataManager()
    let cardsDictionary: {UInt64: FantastecSwapDataV2.CardData} = {}
    for cardId in cardIds {
      cardsDictionary[cardId] = dataManager.cardData[cardId]!
    }
    return cardsDictionary
  }

  pub fun getCardById(id: UInt64): CardData? {
    return self.getDataManager().cardData[id]
  }

  pub fun getCardIds(_ offset: Int?, _ pageSize: Int?): [UInt64] {
    let cardIds = self.getDataManager().cardData.keys;
    return FantastecSwapDataV2.paginateIds(cardIds, offset, pageSize)
  }

  // -----------------
  // Utility functions
  // -----------------
  pub fun join(_ array: [String]): String {
    var res = ""
    for string in array {
      res = res.concat(" ").concat(string)
    }
    return res
  }

  pub fun paginateIds(_ ids: [UInt64], _ offset: Int?, _ pageSize: Int?): [UInt64] {
    let from = offset ?? 0
    if from >= ids.length {
      return []
    }
    var upTo = from + (pageSize ?? ids.length)
    if upTo > ids.length {
      upTo = ids.length
    }
    let slice = ids.slice(from: from, upTo: upTo)
    return slice
  }

  access(contract) fun addToMetadata(
    _ type: String,
    _ metadataArray: [AnyStruct{FantastecSwapDataProperties.MetadataElement}],
    _ metadata: AnyStruct{FantastecSwapDataProperties.MetadataElement},
  ): [AnyStruct{FantastecSwapDataProperties.MetadataElement}] {
    if (FantastecSwapDataProperties.IsArrayMetadataType(type)) {
      var updatedMetadataArray = FantastecSwapDataV2.removeMetadataElementById(metadataArray, metadata.id)
      updatedMetadataArray.append(metadata)
      return updatedMetadataArray
    } else {
      if metadataArray.length > 0 {
        metadataArray.removeFirst()
      }
      metadataArray.append(metadata)
      return metadataArray
    }
  }

  access(contract) fun removeFromMetadata(
    _ type: String,
    _ metadataArray: [AnyStruct{FantastecSwapDataProperties.MetadataElement}],
    _ id: UInt64?,
  ): [AnyStruct{FantastecSwapDataProperties.MetadataElement}] {
    if (FantastecSwapDataProperties.IsArrayMetadataType(type)) {
      let updatedMetadataArray = FantastecSwapDataV2.removeMetadataElementById(metadataArray, id!)
      return updatedMetadataArray
    } else {
      let metadataExists = metadataArray.length > 0
      if (metadataExists) {
        metadataArray.removeFirst()
      }
      return metadataArray
    }
  }

  pub fun removeMetadataElementById(
    _ array: [AnyStruct{FantastecSwapDataProperties.MetadataElement}],
    _ id: UInt64,
  ): [AnyStruct{FantastecSwapDataProperties.MetadataElement}] {
    if (array == nil) {
      return []
    }
    var indexToRemove: Int = -1
    for index, element in array {
      if (element.id == id) {
        indexToRemove = index
        break
      }
    }
    if (indexToRemove > -1) {
      array.remove(at: indexToRemove)
    }
    return array
  }

  access(contract) fun setAdmin(){
    let oldAdmin <- self.account.load<@Admin>(from: self.AdminStoragePath)
    self.account.save<@Admin>(<- create Admin(), to: self.AdminStoragePath)
    destroy oldAdmin
  }

  access(contract) fun setDataManager() {
    let oldDataManager <- self.account.load<@DataManager>(from: self.DataStoragePath)
    var oldCardCollectionData = oldDataManager?.cardCollectionData ?? {}
    var oldCardData = oldDataManager?.cardData ?? {}
    self.account.save<@DataManager>(<- create DataManager(oldCardCollectionData, oldCardData), to: self.DataStoragePath)
    destroy oldDataManager
  }

  access(contract) fun getDataManager(): &DataManager {
    return self.account.borrow<&DataManager>(from: self.DataStoragePath)!
  }

  init() {
    // set storage paths and Admin resource
    self.AdminStoragePath = /storage/FantastecSwapV2Admin
    self.DataStoragePath = /storage/FantastecSwapV2Data

    self.setAdmin()
    self.setDataManager()

    emit ContractInitialized()
  }
}"
-------
"/// CapabilityFilter defines `Filter`, an interface to sit on top of a ChildAccount's capabilities. Requested
/// capabilities will only return if the filter's `allowed` method returns true.
///
/// Along with the `Filter` interface are three implementations:
/// - `DenylistFilter`  - A filter which contains a mapping of denied Types
/// - `AllowlistFilter` - A filter which contains a mapping of allowed Types
/// - `AllowAllFilter`  - A passthrough, all requested capabilities are allowed
///
pub contract CapabilityFilter {

    /* --- Canonical Paths --- */
    //
    pub let StoragePath: StoragePath
    pub let PublicPath: PublicPath
    pub let PrivatePath: PrivatePath

    /* --- Events --- */
    //
    pub event FilterUpdated(id: UInt64, filterType: Type, type: Type, active: Bool)

    /// `Filter` is a simple interface with methods to determine if a Capability is allowed and retrieve details about
    /// the Filter itself
    ///
    pub resource interface Filter {
        pub fun allowed(cap: Capability): Bool
        pub fun getDetails(): AnyStruct
    }

    /// `DenylistFilter` is a `Filter` which contains a mapping of denied Types
    ///
    pub resource DenylistFilter: Filter {

        /// Represents the underlying types which should not ever be returned by a RestrictedChildAccount. The filter
        /// will borrow a requested capability, and make sure that the type it gets back is not in the list of denied
        /// types
        access(self) let deniedTypes: {Type: Bool}

        /// Adds a type to the mapping of denied types with a value of true
        ///
        /// @param type: The type to add to the denied types mapping
        ///
        pub fun addType(_ type: Type) {
            self.deniedTypes.insert(key: type, true)
            emit FilterUpdated(id: self.uuid, filterType: self.getType(), type: type, active: true)
        }

        /// Removes a type from the mapping of denied types
        ///
        /// @param type: The type to remove from the denied types mapping
        ///
        pub fun removeType(_ type: Type) {
            if let removed = self.deniedTypes.remove(key: type) {
                emit FilterUpdated(id: self.uuid, filterType: self.getType(), type: type, active: false)
            }
        }

        /// Removes all types from the mapping of denied types
        ///
        pub fun removeAllTypes() {
            for type in self.deniedTypes.keys {
                self.removeType(type)
            }
        }

        /// Determines if a requested capability is allowed by this `Filter`
        ///
        /// @param cap: The capability to check
        /// @return: true if the capability is allowed, false otherwise
        ///
        pub fun allowed(cap: Capability): Bool {
            if let item = cap.borrow<&AnyResource>() {
                return !self.deniedTypes.containsKey(item.getType())
            }

            return false
        }

        /// Returns details about this filter
        ///
        /// @return A struct containing details about this filter including this Filter's Type indexed on the `type`
        ///         key as well as types denied indexed on the `deniedTypes` key
        ///
        pub fun getDetails(): AnyStruct {
            return {
                "type": self.getType(),
                "deniedTypes": self.deniedTypes.keys
            }
        }

        init() {
            self.deniedTypes = {}
        }
    }

    /// `AllowlistFilter` is a `Filter` which contains a mapping of allowed Types
    ///
    pub resource AllowlistFilter: Filter {
        // allowedTypes
        // Represents the set of underlying types which are allowed to be
        // returned by a RestrictedChildAccount. The filter will borrow
        // a requested capability, and make sure that the type it gets back is
        // in the list of allowed types
        access(self) let allowedTypes: {Type: Bool}

        /// Adds a type to the mapping of allowed types with a value of true
        ///
        /// @param type: The type to add to the allowed types mapping
        ///
        pub fun addType(_ type: Type) {
            self.allowedTypes.insert(key: type, true)
            emit FilterUpdated(id: self.uuid, filterType: self.getType(), type: type, active: true)
        }

        /// Removes a type from the mapping of allowed types
        ///
        /// @param type: The type to remove from the denied types mapping
        ///
        pub fun removeType(_ type: Type) {
            if let removed = self.allowedTypes.remove(key: type) {
                emit FilterUpdated(id: self.uuid, filterType: self.getType(), type: type, active: false)
            }
        }

        /// Removes all types from the mapping of denied types
        ///
        pub fun removeAllTypes() {
            for type in self.allowedTypes.keys {
                self.removeType(type)
            }
        }

        /// Determines if a requested capability is allowed by this `Filter`
        ///
        /// @param cap: The capability to check
        /// @return: true if the capability is allowed, false otherwise
        ///
        pub fun allowed(cap: Capability): Bool {
            if let item = cap.borrow<&AnyResource>() {
                return self.allowedTypes.containsKey(item.getType())
            }

            return false
        }

        /// Returns details about this filter
        ///
        /// @return A struct containing details about this filter including this Filter's Type indexed on the `type`
        ///         key as well as types allowed indexed on the `allowedTypes` key
        ///
        pub fun getDetails(): AnyStruct {
            return {
                "type": self.getType(),
                "allowedTypes": self.allowedTypes.keys
            }
        }

        init() {
            self.allowedTypes = {}
        }
    }

    /// AllowAllFilter is a passthrough, all requested capabilities are allowed
    ///
    pub resource AllowAllFilter: Filter {
        /// Determines if a requested capability is allowed by this `Filter`
        ///
        /// @param cap: The capability to check
        /// @return: true since this filter is a passthrough
        ///
        pub fun allowed(cap: Capability): Bool {
            return true
        }

        /// Returns details about this filter
        ///
        /// @return A struct containing details about this filter including this Filter's Type indexed on the `type`
        ///         key
        ///
        pub fun getDetails(): AnyStruct {
            return {
                "type": self.getType()
            }
        }
    }

    /// Creates a new `Filter` of the given type
    ///
    /// @param t: The type of `Filter` to create
    /// @return: A new instance of the given `Filter` type
    ///
    pub fun create(_ t: Type): @AnyResource{Filter} {
        post {
            result.getType() == t
        }

        switch t {
            case Type<@AllowAllFilter>():
                return <- create AllowAllFilter()
            case Type<@AllowlistFilter>():
                return <- create AllowlistFilter()
            case Type<@DenylistFilter>():
                return <- create DenylistFilter()
        }

        panic("unsupported type requested: ".concat(t.identifier))
    }

    init() {
        let identifier = "CapabilityFilter_".concat(self.account.address.toString())

        self.StoragePath = StoragePath(identifier: identifier)!
        self.PublicPath = PublicPath(identifier: identifier)!
        self.PrivatePath = PrivatePath(identifier: identifier)!
    }
}
"
-------
"
  import NonFungibleToken from 0x1d7e57aa55817448;
  import MetadataViews from 0x1d7e57aa55817448;

  pub contract TestCollection: NonFungibleToken {

    pub var totalSupply: UInt64

    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath

    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
      pub let id: UInt64

      pub let name: String
      pub let description: String
      pub let thumbnail: String
      pub let metadata: {String: AnyStruct}

      init(
          id: UInt64,
          name: String,
          description: String,
          thumbnail: String,
          metadata: {String: AnyStruct},
      ) {
          self.id = id
          self.name = name
          self.description = description
          self.thumbnail = thumbnail
          self.metadata = metadata
      }

      pub fun getViews(): [Type] {
        return [
          Type<MetadataViews.Display>()
        ]
      }

      pub fun resolveView(_ view: Type): AnyStruct? {
        switch view {
          case Type<MetadataViews.Display>():
            return MetadataViews.Display(
              name: self.name,
              description: self.description,
              thumbnail: MetadataViews.HTTPFile(
                url: self.thumbnail
              )
            )
        }
        return nil
      }
    }

    pub resource interface TestCollectionCollectionPublic {
      pub fun deposit(token: @NonFungibleToken.NFT)
      pub fun getIDs(): [UInt64]
      pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
    }

    pub resource Collection: TestCollectionCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
      pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

      init () {
        self.ownedNFTs <- {}
      }

      pub fun getIDs(): [UInt64] {
        return self.ownedNFTs.keys
      }

      pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
        let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

        emit Withdraw(id: token.id, from: self.owner?.address)

        return <-token
      }

      pub fun deposit(token: @NonFungibleToken.NFT) {
        let token <- token as! @TestCollection.NFT

        let id: UInt64 = token.id

        let oldToken: @NonFungibleToken.NFT? <- self.ownedNFTs[id] <- token

        emit Deposit(id: id, to: self.owner?.address)

        destroy oldToken
      }

      pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
        return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
      }

      pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
        let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
        let TestCollection = nft as! &TestCollection.NFT
        return TestCollection as &AnyResource{MetadataViews.Resolver}
      }

      destroy() {
        destroy self.ownedNFTs
      }
    }

    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
      return <- create Collection()
    }
    pub resource NFTMinter {
    pub fun mintNFT(
      recipient: &{NonFungibleToken.CollectionPublic},
      name: String,
      description: String,
      thumbnail: String,
      metadata: {String: AnyStruct}
    ) {
      var newNFT <- create NFT(
        id: TestCollection.totalSupply,
        name: name,
        description: description,
        thumbnail: thumbnail,
        metadata: metadata,
      )

      recipient.deposit(token: <-newNFT)

      TestCollection.totalSupply = TestCollection.totalSupply + 1
    }
    pub fun resolveView(_ view: Type): AnyStruct? {
      switch view {
          case Type<MetadataViews.NFTCollectionData>():
              return MetadataViews.NFTCollectionData(
                  storagePath: TestCollection.CollectionStoragePath,
                  publicPath: TestCollection.CollectionPublicPath,
                  providerPath: /private/TestCollectionCollection,
                  publicCollection: Type<&TestCollection.Collection{TestCollection.TestCollectionCollectionPublic}>(),
                  publicLinkedType: Type<&TestCollection.Collection{TestCollection.TestCollectionCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
                  providerLinkedType: Type<&TestCollection.Collection{TestCollection.TestCollectionCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(),
                  createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                      return <-TestCollection.createEmptyCollection()
                  })
              )
      }
      return nil
  }
}
  /// Function that returns all the Metadata Views implemented by a Non Fungible Token
  ///
  /// @return An array of Types defining the implemented views. This value will be used by
  ///         developers to know which parameter to pass to the resolveView() method.
  ///
  pub fun getViews(): [Type] {
      return [
          Type<MetadataViews.NFTCollectionData>()
      ]
  }

    init() {
      self.totalSupply = 0

      self.CollectionStoragePath = /storage/TestCollectionCollection
      self.CollectionPublicPath = /public/TestCollectionCollection
      self.MinterStoragePath = /storage/TestCollectionMinter

      let collection <- create Collection()
      self.account.save(<-collection, to: self.CollectionStoragePath)

      self.account.link<&TestCollection.Collection{NonFungibleToken.CollectionPublic, TestCollection.TestCollectionCollectionPublic, MetadataViews.ResolverCollection}>(
        self.CollectionPublicPath,
        target: self.CollectionStoragePath
      )
      let minter <- create NFTMinter()
      self.account.save(<-minter, to: self.MinterStoragePath)

      emit ContractInitialized()
    }
  }"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import FungibleTokenMetadataViews from 0xf233dcee88fe0abe
import MetadataViews from 0x1d7e57aa55817448
import Toucans from 0x577a3c409c5dcb5e
import ToucansTokens from 0x577a3c409c5dcb5e
import FlowToken from 0x1654653399040a61
import ViewResolver from 0x1d7e57aa55817448

pub contract NCTRDAO: FungibleToken, ViewResolver {

    // The amount of tokens in existance
    pub var totalSupply: UFix64
    // nil if there is none
    pub let maxSupply: UFix64?

    // Paths
    pub let VaultStoragePath: StoragePath
    pub let ReceiverPublicPath: PublicPath
    pub let VaultPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath
    pub let AdministratorStoragePath: StoragePath

    // Events
    pub event TokensInitialized(initialSupply: UFix64)
    pub event TokensWithdrawn(amount: UFix64, from: Address?)
    pub event TokensDeposited(amount: UFix64, to: Address?)
    pub event TokensTransferred(amount: UFix64, from: Address, to: Address)
    pub event TokensMinted(amount: UFix64)
    pub event TokensBurned(amount: UFix64)

    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance, MetadataViews.Resolver {
        pub var balance: UFix64

        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)

            if let owner: Address = self.owner?.address {
                NCTRDAO.setBalance(address: owner, balance: self.balance)
            }
            return <- create Vault(balance: amount)
        }

        pub fun deposit(from: @FungibleToken.Vault) {
            let vault: @Vault <- from as! @Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)

            // We set the balance to 0.0 here so that it doesn't
            // decrease the totalSupply in the `destroy` function.
            vault.balance = 0.0
            destroy vault

            if let owner: Address = self.owner?.address {
                NCTRDAO.setBalance(address: owner, balance: self.balance)
            }
        }

        pub fun getViews(): [Type]{
            return [
                Type<FungibleTokenMetadataViews.FTView>(),
                Type<FungibleTokenMetadataViews.FTDisplay>(),
                Type<FungibleTokenMetadataViews.FTVaultData>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<FungibleTokenMetadataViews.FTView>():
                    return NCTRDAO.resolveView(view)
                case Type<FungibleTokenMetadataViews.FTDisplay>():
                    return NCTRDAO.resolveView(view)
                case Type<FungibleTokenMetadataViews.FTVaultData>():
                    return NCTRDAO.resolveView(view)
            }
            return nil
        }

        init(balance: UFix64) {
            self.balance = balance
        }

        destroy() {
            if (self.balance > 0.0) {
                emit TokensBurned(amount: self.balance)
                NCTRDAO.totalSupply = NCTRDAO.totalSupply - self.balance
            }
        }
    }

    pub fun createEmptyVault(): @Vault {
        return <- create Vault(balance: 0.0)
    }

    pub resource Minter: Toucans.Minter {
        pub fun mint(amount: UFix64): @Vault {
            post {
                NCTRDAO.maxSupply == nil || NCTRDAO.totalSupply <= NCTRDAO.maxSupply!:
                    "Exceeded the max supply of tokens allowd."
            }
            NCTRDAO.totalSupply = NCTRDAO.totalSupply + amount
            emit TokensMinted(amount: amount)
            return <- create Vault(balance: amount)
        }
    }

    // We follow this pattern of storage
    // so the (potentially) huge dictionary
    // isn't loaded when the contract is imported
    pub resource Administrator {
        // This is an experimental index and should
        // not be used for anything official
        // or monetary related
        access(self) let balances: {Address: UFix64}

        access(contract) fun setBalance(address: Address, balance: UFix64) {
            self.balances[address] = balance
        }

        pub fun getBalance(address: Address): UFix64 {
            return self.balances[address] ?? 0.0
        }

        pub fun getBalances(): {Address: UFix64} {
            return self.balances
        }

        init() {
            self.balances = {}
        }
    }

    access(contract) fun setBalance(address: Address, balance: UFix64) {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        admin.setBalance(address: address, balance: balance)
    }

    pub fun getBalance(address: Address): UFix64 {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalance(address: address)
    }

    pub fun getBalances(): {Address: UFix64} {
        let admin: &Administrator = self.account.borrow<&Administrator>(from: self.AdministratorStoragePath)!
        return admin.getBalances()
    }

    pub fun getViews(): [Type] {
        return [
            Type<FungibleTokenMetadataViews.FTView>(),
            Type<FungibleTokenMetadataViews.FTDisplay>(),
            Type<FungibleTokenMetadataViews.FTVaultData>()
        ]
    }

    pub fun resolveView(_ view: Type): AnyStruct? {
        switch view {
            case Type<FungibleTokenMetadataViews.FTView>():
                return FungibleTokenMetadataViews.FTView(
                    ftDisplay: self.resolveView(Type<FungibleTokenMetadataViews.FTDisplay>()) as! FungibleTokenMetadataViews.FTDisplay?,
                    ftVaultData: self.resolveView(Type<FungibleTokenMetadataViews.FTVaultData>()) as! FungibleTokenMetadataViews.FTVaultData?
                )
            case Type<FungibleTokenMetadataViews.FTDisplay>():
                let media = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                        url: "undefined"
                    ),
                    mediaType: "image"
                )
                let bannerMedia = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                        url: "undefined"
                    ),
                    mediaType: "image"
                )
                let medias = MetadataViews.Medias([media, bannerMedia])
                return FungibleTokenMetadataViews.FTDisplay(
                    name: "NCTR DAO",
                    symbol: "NCTR",
                    description: "The NCTR DAO is committed to support NCTR, the world's first global loyalty point.",
                    externalURL: MetadataViews.ExternalURL(""),
                    logos: medias,
                    socials: {
                        "twitter": MetadataViews.ExternalURL(""),
                        "discord": MetadataViews.ExternalURL("")
                    }
                )
            case Type<FungibleTokenMetadataViews.FTVaultData>():
                return FungibleTokenMetadataViews.FTVaultData(
                    storagePath: NCTRDAO.VaultStoragePath,
                    receiverPath: NCTRDAO.ReceiverPublicPath,
                    metadataPath: NCTRDAO.VaultPublicPath,
                    providerPath: /private/NCTRDAOVault,
                    receiverLinkedType: Type<&Vault{FungibleToken.Receiver}>(),
                    metadataLinkedType: Type<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(),
                    providerLinkedType: Type<&Vault{FungibleToken.Provider}>(),
                    createEmptyVaultFunction: (fun (): @Vault {
                        return <- NCTRDAO.createEmptyVault()
                    })
                )
        }
        return nil
    }

    init(
      _paymentTokenInfo: ToucansTokens.TokenInfo,
      _editDelay: UFix64,
      _minting: Bool,
      _initialTreasurySupply: UFix64,
      _maxSupply: UFix64?,
      _extra: {String: AnyStruct}
    ) {

      // Contract Variables
      self.totalSupply = 0.0
      self.maxSupply = _maxSupply

      // Paths
      self.VaultStoragePath = /storage/NCTRDAOVault
      self.ReceiverPublicPath = /public/NCTRDAOReceiver
      self.VaultPublicPath = /public/NCTRDAOMetadata
      self.MinterStoragePath = /storage/NCTRDAOMinter
      self.AdministratorStoragePath = /storage/NCTRDAOAdmin

      // Admin Setup
      let vault <- create Vault(balance: self.totalSupply)
      self.account.save(<- vault, to: self.VaultStoragePath)

      self.account.link<&Vault{FungibleToken.Receiver}>(
          self.ReceiverPublicPath,
          target: self.VaultStoragePath
      )

      self.account.link<&Vault{FungibleToken.Balance, MetadataViews.Resolver}>(
          self.VaultPublicPath,
          target: self.VaultStoragePath
      )

      if self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath) == nil {
        self.account.save(<- Toucans.createCollection(), to: Toucans.CollectionStoragePath)
        self.account.link<&Toucans.Collection{Toucans.CollectionPublic}>(Toucans.CollectionPublicPath, target: Toucans.CollectionStoragePath)
      }

      let toucansProjectCollection = self.account.borrow<&Toucans.Collection>(from: Toucans.CollectionStoragePath)!
      toucansProjectCollection.createProject(
        projectTokenInfo: ToucansTokens.TokenInfo("NCTRDAO", self.account.address, "NCTR", self.ReceiverPublicPath, self.VaultPublicPath, self.VaultStoragePath),
        paymentTokenInfo: _paymentTokenInfo,
        minter: <- create Minter(),
        editDelay: _editDelay,
        minting: _minting,
        initialTreasurySupply: _initialTreasurySupply,
        extra: _extra
      )

      self.account.save(<- create Administrator(), to: self.AdministratorStoragePath)

      // Events
      emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
 "
-------
" pub contract BasicNFT{

    pub var totalSupply: UInt64

    init(){
        self.totalSupply = 0
    }

    pub resource interface NFTPublic{
        pub fun getID(): UInt64
        pub fun getURL(): String
    }

    pub resource NFT: NFTPublic{

        pub let id: UInt64
        pub var metadata: {String: String}

        init(InitURL: String){
            self.id = BasicNFT.totalSupply
            self.metadata = {"URL": InitURL}
            BasicNFT.totalSupply = BasicNFT.totalSupply + 1
        }

        pub fun getID(): UInt64{
            return self.id
        }

        pub fun getURL(): String{
            return self.metadata["URL"]!
        }

    }

    pub fun createNFT(url: String): @NFT{
        return <- create NFT(InitURL: url)
    }

}"
-------
" /**

## The Flow Non-Fungible Token standard

Adapted for Capsule needs.

## `NonFungibleToken` contract interface

The interface that all non-fungible token contracts could conform to.
If a user wants to deploy a new nft contract, their contract would need
to implement this NonFungibleToken interface.

Their contract would have to follow all the rules and naming
that the interface specifies.

## `NFT` resource

The core resource type that represents an NFT in the smart contract.

## `Collection` Resource

The resource that stores a user's NFT collection.
It includes a few functions to allow the owner to easily
move tokens in and out of the collection.

## `Provider` and `Receiver` resource interfaces

These interfaces declare functions with some pre and post conditions
that require the Collection to follow certain naming and behavior standards.

They are separate because it gives the user the ability to share a reference
to their Collection that only exposes the fields and functions in one or more
of the interfaces. It also gives users the ability to make custom resources
that implement these interfaces to do various things with the tokens.

By using resources and interfaces, users of NFT smart contracts can send
and receive tokens peer-to-peer, without having to interact with a central ledger
smart contract.

To send an NFT to another user, a user would simply withdraw the NFT
from their Collection, then call the deposit function on another user's
Collection to complete the transfer.

*/

// The main NFT contract interface. Other NFT contracts will
// import and implement this interface
//
pub contract interface CapsuleNFT {

    // The total number of tokens of this type in existence
    pub var totalMinted: UInt64

    // Event that emitted when the NFT contract is initialized
    //
    pub event ContractInitialized()

    // Event that is emitted when a token is withdrawn,
    // indicating the:
    // - the ID of the NFT being withdrawn
    // - the size (bytes) of the NFT
    // - the owner of the collection that it was withdrawn from
    //
    // If the collection is not in an account's storage, `from` will be `nil`.
    //
    pub event Withdraw(id: String, size: UInt64, from: Address?)

    // Event that emitted when a token is deposited to a collection,
    // indicating the:
    // - the ID of the NFT being withdrawn
    // - the size (bytes) of the NFT
    // - the owner of the collection that it was deposited to
    //
    //
    pub event Deposit(id: String, size: UInt64, to: Address?)

    // Event that emits when a token is minted.
    //
    pub event Minted(id: String)

    // Interface that the NFTs have to conform to
    //
    pub resource interface INFT {
        // The Capsule UniqueID given to the NFT
        pub let id: String
    }

    // Requirement that all conforming NFT smart contracts have
    // to define a resource called NFT that conforms to INFT
    pub resource NFT: INFT {
        pub let id: String
    }

    // Interface to mediate withdraws from the Collection
    //
    pub resource interface Provider {
        // withdraw removes an NFT from the collection and moves it to the caller
        pub fun withdraw(id: String): @NFT {
            post {
                result.id == id: "The ID of the withdrawn token must be the same as the requested ID"
            }
        }
    }

    // Interface to mediate deposits to the Collection
    //
    pub resource interface Receiver {
        // deposit takes an NFT as an argument and adds it to the Collection
        //
		pub fun deposit(token: @NFT)
    }

    // Interface that an account would commonly
    // publish for their collection
    pub resource interface CollectionPublic {
        pub fun deposit(token: @NFT)
        pub fun getIDs(): [String]
        pub fun borrowNFT(id: String): &NFT
    }

    // Requirement for the the concrete resource type
    // to be declared in the implementing contract
    //
    pub resource Collection: Provider, Receiver, CollectionPublic {
        // Dictionary to hold the NFTs in the Collection
        pub var ownedNFTs: @{String: NFT}

        // withdraw removes an NFT from the collection and moves it to the caller
        pub fun withdraw(id: String): @NFT

        // deposit takes a NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun deposit(token: @NFT)

        // getIDs returns an array of the IDs that are in the collection
        pub fun getIDs(): [String]

        // Returns a borrowed reference to an NFT in the collection
        // so that the caller can read data and call methods from it
        pub fun borrowNFT(id: String): &NFT {
            pre {
                self.ownedNFTs[id] != nil: "NFT does not exist in the collection!"
            }
        }
    }

    // createEmptyCollection creates an empty Collection
    // and returns it to the caller so that they can own NFTs
    pub fun createEmptyCollection(): @Collection {
        post {
            result.getIDs().length == 0: "The created collection must be empty!"
        }
    }
}
 "
-------
"/**

# This contract provides public oracle data sourced from the multi-node PriceOracle contracts of Increment.

# Anyone can access price data directly with getLatestPrice() & getLatestBlockHeight(), no whitelist needed. Check example here: https://docs.increment.fi/protocols/decentralized-price-feed-oracle/using-price-feeds

# Admin controls what PriceOracles are exposed publicly.

# Author: Increment Labs

*/
import OracleInterface from 0xcec15c814971c1dc
import OracleConfig from 0xcec15c814971c1dc

pub contract PublicPriceOracle {
    /// {OracleAddr: PriceIdentifier}
    access(self) let oracleAddrToPriceIdentifier: {Address: String}

    /// The storage path for the Admin resource
    pub let OracleAdminStoragePath: StoragePath

    /// Reserved parameter fields: {ParamName: Value}
    access(self) let _reservedFields: {String: AnyStruct}

    /// Events
    pub event OracleAdded(oracleAddr: Address)
    pub event OracleRemoved(oracleAddr: Address)


    /// Get the price data from the most recent update.
    /// The data is updated whichever condition happens first:
    ///   1. The price deviation is beyond a threahold (by default 0.5%)
    ///   2. A fixed window of time has passed (by default 2000 blocks)
    /// Note: It is recommended to check the updated block height of this data with getLatestBlockHeight(), and handle the extreme condition if this data is too old.
    ///
    pub fun getLatestPrice(oracleAddr: Address): UFix64 {
        let oraclePublicInterface_ReaderRef = getAccount(oracleAddr).getCapability<&{OracleInterface.OraclePublicInterface_Reader}>(OracleConfig.OraclePublicInterface_ReaderPath).borrow()
                                                    ?? panic("Lost oracle public capability at ".concat(oracleAddr.toString()))
        let priceReaderSuggestedPath = oraclePublicInterface_ReaderRef.getPriceReaderStoragePath()
        let priceReaderRef = PublicPriceOracle.account.borrow<&OracleInterface.PriceReader>(from: priceReaderSuggestedPath)
                                ?? panic("Lost local price reader resource.")
        let medianPrice = priceReaderRef.getRawMedianPrice()
        return medianPrice
    }

    /// Get the block height at the time of the latest update.
    ///
    pub fun getLatestBlockHeight(oracleAddr: Address): UInt64 {
        let oraclePublicInterface_ReaderRef = getAccount(oracleAddr).getCapability<&{OracleInterface.OraclePublicInterface_Reader}>(OracleConfig.OraclePublicInterface_ReaderPath).borrow()
                                                    ?? panic("Lost oracle public capability at ".concat(oracleAddr.toString()))
        let priceReaderSuggestedPath = oraclePublicInterface_ReaderRef.getPriceReaderStoragePath()
        let priceReaderRef = PublicPriceOracle.account.borrow<&OracleInterface.PriceReader>(from: priceReaderSuggestedPath)
                                ?? panic("Lost local price reader resource.")

        let medianBlockHeight: UInt64 = priceReaderRef.getRawMedianBlockHeight()
        return medianBlockHeight
    }

    pub fun getAllSupportedOracles(): {Address: String} {
        return self.oracleAddrToPriceIdentifier
    }

    pub resource Admin {

        pub fun addOracle(oracleAddr: Address) {
            if (!PublicPriceOracle.oracleAddrToPriceIdentifier.containsKey(oracleAddr)) {
                /// Mint oracle reader
                let oraclePublicInterface_ReaderRef = getAccount(oracleAddr).getCapability<&{OracleInterface.OraclePublicInterface_Reader}>(OracleConfig.OraclePublicInterface_ReaderPath).borrow()
                                                        ?? panic("Lost oracle public capability at ".concat(oracleAddr.toString()))
                let priceReaderSuggestedPath = oraclePublicInterface_ReaderRef.getPriceReaderStoragePath()

                if (PublicPriceOracle.account.borrow<&OracleInterface.PriceReader>(from: priceReaderSuggestedPath) == nil) {
                    let priceReader <- oraclePublicInterface_ReaderRef.mintPriceReader()

                    destroy <- PublicPriceOracle.account.load<@AnyResource>(from: priceReaderSuggestedPath)

                    PublicPriceOracle.oracleAddrToPriceIdentifier[oracleAddr] = priceReader.getPriceIdentifier()
                    PublicPriceOracle.account.save(<- priceReader, to: priceReaderSuggestedPath)
                }

                emit OracleAdded(oracleAddr: oracleAddr)
            }
        }

        pub fun removeOracle(oracleAddr: Address) {
            PublicPriceOracle.oracleAddrToPriceIdentifier.remove(key: oracleAddr)
            /// Remove local oracle reader resource
            let oraclePublicInterface_ReaderRef = getAccount(oracleAddr).getCapability<&{OracleInterface.OraclePublicInterface_Reader}>(OracleConfig.OraclePublicInterface_ReaderPath).borrow()
                                                    ?? panic("Lost oracle public capability at ".concat(oracleAddr.toString()))
            let priceReaderSuggestedPath = oraclePublicInterface_ReaderRef.getPriceReaderStoragePath()
            destroy <- PublicPriceOracle.account.load<@AnyResource>(from: priceReaderSuggestedPath)

            emit OracleRemoved(oracleAddr: oracleAddr)
        }
    }

    init() {
        self.OracleAdminStoragePath = /storage/publicOracleAdmin
        self.oracleAddrToPriceIdentifier = {}
        self._reservedFields = {}

        destroy <-self.account.load<@AnyResource>(from: self.OracleAdminStoragePath)
        self.account.save(<-create Admin(), to: self.OracleAdminStoragePath)
    }
}
"
-------
"import CapsuleNFT from 0xd8f6dd312265bd2c

pub contract Collectibles: CapsuleNFT {
    pub var totalMinted: UInt64

    pub event ContractInitialized()
    pub event CollectionCreated()
    pub event CollectionDestroyed(length: Int)
    pub event Withdraw(id: String, size: UInt64, from: Address?)
    pub event Deposit(id: String, size: UInt64, to: Address?)
    pub event Minted(id: String)
    pub event CollectibleMinted(
        id: String,
        name: String,
        collection: String,
        type: String,
        rarity: String,
        edition: String,
        mediaUri: String,
        mintedTime: String,
        resourceId: UInt64
    )
    pub event CollectibleDestroyed(id: String)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath

    /// NFT:
    /// A Collectible as an NFT
    pub resource NFT: CapsuleNFT.INFT {
        pub let id: String
        pub let name: String
        pub let collection: String
        pub let type: String
        pub let rarity: String
        pub let edition: String
        pub let mediaUri: String
        pub let mintedTime: String

        init(
            id: String,
            name: String,
            collection: String,
            type: String,
            rarity: String,
            edition: String,
            mediaUri: String,
            mintedTime: String
        ) {
            self.id = id
            self.name = name
            self.collection = collection
            self.type = type
            self.rarity = rarity
            self.edition = edition
            self.mediaUri = mediaUri
            self.mintedTime = mintedTime
        }

        destroy() {
            emit CollectibleDestroyed(id: self.id)
        }
    }

    /// CollectiblesCollectionPublic:
    /// This is the interface that users can cast their Collectible Collection as,
    /// in order to allow others to deposit a Collectible into their Collection.
    /// It also allows for reading the details of an Collectible in the Collection.
    pub resource interface CollectiblesCollectionPublic {
        pub fun deposit(token: @CapsuleNFT.NFT)
        pub fun getIDs(): [String]
        pub fun borrowNFT(id: String): &CapsuleNFT.NFT
        pub fun borrowCollectible(id: String): &Collectibles.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow Collectible reference: the ID of the returned reference is incorrect"
            }
        }
    }

    /// Collection:
    /// A collection of Collectibles NFTs owned by an account
    pub resource Collection: CollectiblesCollectionPublic, CapsuleNFT.Provider, CapsuleNFT.Receiver, CapsuleNFT.CollectionPublic {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with a `String` ID field
        pub var ownedNFTs: @{String: CapsuleNFT.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        /// Removes an NFT from the collection and moves it to the caller
        pub fun withdraw(id: String): @CapsuleNFT.NFT {
            let address: Address? = self.owner?.address
            let account: PublicAccount = getAccount(address!)
            let startUsed: UInt64 = account.storageUsed

            let token: @CapsuleNFT.NFT <- self.ownedNFTs.remove(key: id)
                ?? panic("missing NFT")

            let endUsed: UInt64 = account.storageUsed
            let delta: UInt64 = endUsed - startUsed
            emit Withdraw(id: token.id, size: delta, from: address)

            return <-token
        }

        /// Takes an NFT, adds it to the Collection dictionary and adds the ID to the id array
        pub fun deposit(token: @CapsuleNFT.NFT) {
            let address: Address? = self.owner?.address
            let account: PublicAccount = getAccount(address!)
            let startUsed: UInt64 = account.storageUsed

            let token: @Collectibles.NFT <- token as! @Collectibles.NFT
            let id: String = token.id
            // Add the new token to the dictionary which removes the old one
            let oldToken: @CapsuleNFT.NFT? <- self.ownedNFTs[id] <- token

            let endUsed: UInt64 = account.storageUsed
            let delta: UInt64 = endUsed - startUsed
            emit Deposit(id: id, size: delta, to: address)

            destroy oldToken
        }

        /// Returns an array of the IDs that are in the collection
        pub fun getIDs(): [String] {
            return self.ownedNFTs.keys
        }

        /// Gets a reference to an NFT in the collection so that the caller can read its metadata and call its methods
        pub fun borrowNFT(id: String): &CapsuleNFT.NFT {
            return (&self.ownedNFTs[id] as &CapsuleNFT.NFT?)!
        }

        /// Gets a reference to a Collectible in the Collection
        pub fun borrowCollectible(id: String): &Collectibles.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorised reference to allow downcasting
                let ref: auth &CapsuleNFT.NFT = (&self.ownedNFTs[id] as auth &CapsuleNFT.NFT?)!
                return ref as! &Collectibles.NFT
            } else {
                return nil
            }
        }

        destroy() {
            let collectionLength = self.ownedNFTs.length
            destroy self.ownedNFTs
            emit CollectionDestroyed(length: collectionLength)
        }
    }

    /// Public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(): @CapsuleNFT.Collection {
        emit CollectionCreated()
        return <- create Collection()
    }

    /// Resource that an admin or similar would own to be able to mint new NFTs
    pub resource NFTMinter {
        /// Mints a new Collectible.
        /// Deposits it in the recipients Collection using their PublicCollection reference.
        pub fun mintCollectible(
            recipientCollection: &{CapsuleNFT.CollectionPublic},
            id: String,
            name: String,
            collection: String,
            type: String,
            rarity: String,
            edition: String,
            mediaUri: String,
            mintedTime: String,
        ) {
            // Create a new Collectible NFT
            var collectible: @Collectibles.NFT <- create NFT(
                id: id,
                name: name,
                collection: collection,
                type: type,
                rarity: rarity,
                edition: edition,
                mediaUri: mediaUri,
                mintedTime: mintedTime
            )
            // Emit Events
            emit CollectibleMinted(
                id: id,
                name: name,
                collection: collection,
                type: type,
                rarity: rarity,
                edition: edition,
                mediaUri: mediaUri,
                mintedTime: mintedTime,
                resourceId: collectible.uuid
            )
            // Increment the total of minted Collectibles
            Collectibles.totalMinted = Collectibles.totalMinted + 1

            // Deposit it in the recipient's account using their reference
            recipientCollection.deposit(token: <-collectible)
        }
    }

    init() {
        // Initialize the total of minted Collectibles
        self.totalMinted = 0

        // Set the named paths
        self.CollectionStoragePath = /storage/CapsuleCollectiblesCollection
        self.CollectionPublicPath = /public/CapsuleCollectiblesCollection
        self.MinterStoragePath = /storage/CapsuleCollectiblesMinter

        // Create a Collection resource and save it to storage
        let collection: @Collectibles.Collection <- create Collection()
        self.account.save(<-collection, to: self.CollectionStoragePath)

        // Create a public capability for the collection
        self.account.link<&Collectibles.Collection{CapsuleNFT.CollectionPublic, Collectibles.CollectiblesCollectionPublic}>
            (self.CollectionPublicPath, target: self.CollectionStoragePath)

        // Create a Minter resource and save it to storage
        let minter: @Collectibles.NFTMinter <- create NFTMinter()
        self.account.save(<-minter, to: self.MinterStoragePath)

        emit ContractInitialized()
    }
}
 "
-------
"/// CapabilityFilter defines `Filter`, an interface to sit on top of a ChildAccount's capabilities. Requested
/// capabilities will only return if the filter's `allowed` method returns true.
///
/// Along with the `Filter` interface are three implementations:
/// - `DenylistFilter`  - A filter which contains a mapping of denied Types
/// - `AllowlistFilter` - A filter which contains a mapping of allowed Types
/// - `AllowAllFilter`  - A passthrough, all requested capabilities are allowed
///
pub contract CapabilityFilter {

    /* --- Canonical Paths --- */
    //
    pub let StoragePath: StoragePath
    pub let PublicPath: PublicPath
    pub let PrivatePath: PrivatePath

    /* --- Events --- */
    //
    pub event FilterUpdated(id: UInt64, filterType: Type, type: Type, active: Bool)

    /// `Filter` is a simple interface with methods to determine if a Capability is allowed and retrieve details about
    /// the Filter itself
    ///
    pub resource interface Filter {
        pub fun allowed(cap: Capability): Bool
        pub fun getDetails(): AnyStruct
    }

    /// `DenylistFilter` is a `Filter` which contains a mapping of denied Types
    ///
    pub resource DenylistFilter: Filter {

        /// Represents the underlying types which should not ever be returned by a RestrictedChildAccount. The filter
        /// will borrow a requested capability, and make sure that the type it gets back is not in the list of denied
        /// types
        access(self) let deniedTypes: {Type: Bool}

        /// Adds a type to the mapping of denied types with a value of true
        ///
        /// @param type: The type to add to the denied types mapping
        ///
        pub fun addType(_ type: Type) {
            self.deniedTypes.insert(key: type, true)
            emit FilterUpdated(id: self.uuid, filterType: self.getType(), type: type, active: true)
        }

        /// Removes a type from the mapping of denied types
        ///
        /// @param type: The type to remove from the denied types mapping
        ///
        pub fun removeType(_ type: Type) {
            if let removed = self.deniedTypes.remove(key: type) {
                emit FilterUpdated(id: self.uuid, filterType: self.getType(), type: type, active: false)
            }
        }

        /// Determines if a requested capability is allowed by this `Filter`
        ///
        /// @param cap: The capability to check
        /// @return: true if the capability is allowed, false otherwise
        ///
        pub fun allowed(cap: Capability): Bool {
            if let item = cap.borrow<&AnyResource>() {
                return !self.deniedTypes.containsKey(item.getType())
            }

            return false
        }

        /// Returns details about this filter
        ///
        /// @return A struct containing details about this filter including this Filter's Type indexed on the `type`
        ///         key as well as types denied indexed on the `deniedTypes` key
        ///
        pub fun getDetails(): AnyStruct {
            return {
                "type": self.getType(),
                "deniedTypes": self.deniedTypes.keys
            }
        }

        init() {
            self.deniedTypes = {}
        }
    }

    /// `AllowlistFilter` is a `Filter` which contains a mapping of allowed Types
    ///
    pub resource AllowlistFilter: Filter {
        // allowedTypes
        // Represents the set of underlying types which are allowed to be
        // returned by a RestrictedChildAccount. The filter will borrow
        // a requested capability, and make sure that the type it gets back is
        // in the list of allowed types
        access(self) let allowedTypes: {Type: Bool}

        /// Adds a type to the mapping of allowed types with a value of true
        ///
        /// @param type: The type to add to the allowed types mapping
        ///
        pub fun addType(_ type: Type) {
            self.allowedTypes.insert(key: type, true)
            emit FilterUpdated(id: self.uuid, filterType: self.getType(), type: type, active: true)
        }

        /// Removes a type from the mapping of allowed types
        ///
        /// @param type: The type to remove from the denied types mapping
        ///
        pub fun removeType(_ type: Type) {
            if let removed = self.allowedTypes.remove(key: type) {
                emit FilterUpdated(id: self.uuid, filterType: self.getType(), type: type, active: false)
            }
        }

        /// Determines if a requested capability is allowed by this `Filter`
        ///
        /// @param cap: The capability to check
        /// @return: true if the capability is allowed, false otherwise
        ///
        pub fun allowed(cap: Capability): Bool {
            if let item = cap.borrow<&AnyResource>() {
                return self.allowedTypes.containsKey(item.getType())
            }

            return false
        }

        /// Returns details about this filter
        ///
        /// @return A struct containing details about this filter including this Filter's Type indexed on the `type`
        ///         key as well as types allowed indexed on the `allowedTypes` key
        ///
        pub fun getDetails(): AnyStruct {
            return {
                "type": self.getType(),
                "allowedTypes": self.allowedTypes.keys
            }
        }

        init() {
            self.allowedTypes = {}
        }
    }

    /// AllowAllFilter is a passthrough, all requested capabilities are allowed
    ///
    pub resource AllowAllFilter: Filter {
        /// Determines if a requested capability is allowed by this `Filter`
        ///
        /// @param cap: The capability to check
        /// @return: true since this filter is a passthrough
        ///
        pub fun allowed(cap: Capability): Bool {
            return true
        }

        /// Returns details about this filter
        ///
        /// @return A struct containing details about this filter including this Filter's Type indexed on the `type`
        ///         key
        ///
        pub fun getDetails(): AnyStruct {
            return {
                "type": self.getType()
            }
        }
    }

    /// Creates a new `Filter` of the given type
    ///
    /// @param t: The type of `Filter` to create
    /// @return: A new instance of the given `Filter` type
    ///
    pub fun create(_ t: Type): @AnyResource{Filter} {
        post {
            result.getType() == t
        }

        switch t {
            case Type<@AllowAllFilter>():
                return <- create AllowAllFilter()
            case Type<@AllowlistFilter>():
                return <- create AllowlistFilter()
            case Type<@DenylistFilter>():
                return <- create DenylistFilter()
        }

        panic("unsupported type requested: ".concat(t.identifier))
    }

    init() {
        let identifier = "CapabilityFilter_".concat(self.account.address.toString())

        self.StoragePath = StoragePath(identifier: identifier)!
        self.PublicPath = PublicPath(identifier: identifier)!
        self.PrivatePath = PrivatePath(identifier: identifier)!
    }
}
"
-------
"pub contract Utils {
  pub struct AddressNamePair {
    pub let address: Address
    pub let name: String

    init(address: Address, name: String) {
      self.address = address
      self.name = name
    }
  }

  pub fun convertStringToAddress(_ input: String): Address? {
    var address = input
    if input.utf8[1] == 120 {
      address = input.slice(from: 2, upTo: input.length)
    }
    var r: UInt64 = 0
    var bytes = address.decodeHex()

    while bytes.length > 0 {
      r = r + (UInt64(bytes.removeFirst()) << UInt64(bytes.length * 8))
    }

    return Address(r)
  }

  pub fun royaltyCutStringToUFix64(_ royaltyCut: String): UFix64 {
    var decimalPos = 0
    if royaltyCut[0] == "." {
      decimalPos = 1
    } else if royaltyCut[1] == "." {
      if royaltyCut[0] == "1" {
        // "1" in the first postiion must be 1.0 i.e. 100% cut
        return 1.0
      } else if royaltyCut[0] == "0" {
        decimalPos = 2
      }
    } else {
      // Invalid royalty value
      return 0.0
    }

    var royaltyCutStrLen = royaltyCut.length
    if royaltyCut.length > (8 + decimalPos) {
      // UFix64 is capped at 8 digits after the decimal
      // so truncate excess decimal values from the string
      royaltyCutStrLen = (8 + decimalPos)
    }
    let royaltyCutPercentValue = royaltyCut.slice(from: decimalPos, upTo: royaltyCutStrLen)
    var bytes = royaltyCutPercentValue.utf8
    var i = 0
    var cutValueInteger: UInt64 = 0
    var cutValueDivisor: UFix64 = 1.0
    let zeroAsciiIntValue: UInt64 = 48
    // First convert the string to a non-decimal Integer
    while i < bytes.length {
      cutValueInteger = (cutValueInteger * 10) + UInt64(bytes[i]) - zeroAsciiIntValue
      cutValueDivisor = cutValueDivisor * 10.0
      i = i + 1
    }

    // Convert the resulting Integer to a decimal in the range 0.0 - 0.99999999
    return (UFix64(cutValueInteger) / cutValueDivisor)
  }

  pub fun getMimeType(_ metadataFileType: String): String {
    switch metadataFileType {
      case "mp4":
      return "video/mp4"
      case "mov":
      return "video/quicktime"
      case "webm":
      return "video/webm"
      case "ogv":
      return "video/ogg"
      case "png":
      return "image/png"
      case "jpeg":
      return "image/jpeg"
      case "jpg":
      return "image/jpeg"
      case "gif":
      return "image/gif"
      case "webp":
      return "image/webp"
      case "svg":
      return "image/svg+xml"
      case "glb":
      return "model/gltf-binary"
      case "gltf":
      return "model/gltf+json"
      case "obj":
      return "model/obj"
      case "mtl":
      return "model/mtl"
      case "mp3":
      return "audio/mpeg"
      case "ogg":
      return "audio/ogg"
      case "oga":
      return "audio/ogg"
      case "wav":
      return "audio/wav"
      case "html":
      return "text/html"
    }
    return ""
  }
}"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import StrikeNowData from 0xe06a203a98ba7633
import DapperUtilityCoin from 0xead892083b3e2c6c
import Utils from 0xe06a203a98ba7633

pub contract StrikeNow: NonFungibleToken {
  pub event ContractInitialized()
  pub event Minted(id: UInt64, setId: UInt32, seriesId: UInt32)
  pub event SeriesCreated(seriesId: UInt32)
  pub event SeriesSealed(seriesId: UInt32)
  pub event SeriesEditionsSetToProceedSerially(seriesId: UInt32)
  pub event SeriesMetadataUpdated(seriesId: UInt32)
  pub event SetCreated(seriesId: UInt32, setId: UInt32)
  pub event SetMetadataUpdated(seriesId: UInt32, setId: UInt32)
  pub event Withdraw(id: UInt64, from: Address?)
  pub event Deposit(id: UInt64, to: Address?)
  pub event NFTDestroyed(id: UInt64)
  pub event SetSaleStateChanged(id: UInt32, onSale: Bool)
  pub event SetEditionShuffleActivated(id: UInt32)

  pub let CollectionStoragePath: StoragePath
  pub let CollectionPublicPath: PublicPath
  pub let AdminStoragePath: StoragePath
  pub let AdminPrivatePath: PrivatePath
  pub let MinterPublicPath: PublicPath
  pub let VaultPublicPath: PublicPath

  pub var totalSupply: UInt64
  pub var numberEditionsMintedPerSet: {UInt32: UInt64}

  access(self) var setData: {UInt32: StrikeNowData.SetData}
  access(self) var seriesData: {UInt32: StrikeNowData.SeriesData}
  access(self) var series: @{UInt32: Series}
  access(self) var config: StrikeNowData.ConfigData

  pub resource Series {
    pub let seriesId: UInt32
    pub var setIds: [UInt32]
    pub var sealed: Bool;
    //TODO $BS - Please come up with a better name for this
    pub var editionsProceedingSerially: Bool;
    pub let setEditionMap: {UInt32: {UInt32: UInt32}}
    pub let onSaleStateMap: {UInt32: Bool}

    init(
      seriesId: UInt32,
      metadata: {String: String},
      fights: [{String: String}]?) {

      self.seriesId = seriesId
      self.sealed = false
      self.setIds = []
      self.editionsProceedingSerially = false
      self.setEditionMap = {}
      self.onSaleStateMap = {}

      StrikeNow.seriesData[seriesId] = StrikeNowData.SeriesData(seriesId: seriesId, metadata: metadata, fights: fights)
      emit SeriesCreated(seriesId: seriesId)
    }

    pub fun updateSeriesMetadata(metadata: {String: String}, fights: [{String: String}]?) {
      pre {
        self.sealed == false: "The Series is permanently sealed. No metadata updates can be made."
      }
      let data = StrikeNowData.SeriesData(seriesId: self.seriesId, metadata: metadata, fights: fights)
      StrikeNow.seriesData[self.seriesId] = data
      emit SeriesMetadataUpdated(seriesId: self.seriesId)
    }

    pub fun addNftSet(
      setId: UInt32,
      metadata: {String: String},
      assets: [{String: String}]?,
      result: {String: String}?) {
      pre {
        self.setIds.contains(setId) == false: "The Set has already been added to the Series."
        self.sealed == false: "The Series is already sealed."
      }

      var newNFTSet = StrikeNowData.SetData(
        setId: setId,
        seriesId: self.seriesId,
        metadata: metadata,
        assets: assets,
        result: result
      )

      self.setIds.append(setId)
      self.setEditionMap[setId] = {}
      self.onSaleStateMap[setId] = false
      StrikeNow.numberEditionsMintedPerSet[setId] = 0
      StrikeNow.setData[setId] = newNFTSet

      emit SetCreated(seriesId: self.seriesId, setId: setId)
    }

    pub fun updateSetMetadata(
      setId: UInt32,
      metadata: {String: String},
      assets: [{String: String}]?,
      result: {String: String}?) {
      pre {
        self.sealed == false: "The Series is permanently sealed. No metadata updates can be made."
        self.setIds.contains(setId) == true: "The Set is not part of this Series."
      }

      let newSetMetadata = StrikeNowData.SetData(
        setId: setId,
        seriesId: self.seriesId,
        metadata: metadata,
        assets: assets,
        result: result
      )
      StrikeNow.setData[setId] = newSetMetadata

      emit SetMetadataUpdated(seriesId: self.seriesId, setId: setId)
    }

    pub fun mintStrikeNow(recipient: &{NonFungibleToken.CollectionPublic}, setId: UInt32) {
      pre {
        StrikeNow.numberEditionsMintedPerSet[setId] != nil: "The Set does not exist."
      }

      let index = StrikeNow.numberEditionsMintedPerSet[setId]! + 1
      let index32 = UInt32(index)
      recipient.deposit(token: <-create StrikeNow.NFT(setId: setId, tokenIndex: index32))

      let setMap = self.setEditionMap[setId]!
      setMap[index32] = self.editionsProceedingSerially ? index32 : 0
      self.setEditionMap[setId] = setMap
      StrikeNow.totalSupply = StrikeNow.totalSupply + 1
      StrikeNow.numberEditionsMintedPerSet[setId] = index
    }

    pub fun sealSeries() {
      pre {
        self.sealed == false: "The Series is already sealed"
      }
      self.sealed = true
      emit SeriesSealed(seriesId: self.seriesId)
    }

    pub fun setEditionsProceedingSerially() {
      pre {
        self.sealed == false: "The Series is sealed"
        self.editionsProceedingSerially == false: "Sets in this Series are already numbering editions serially"
      }
      self.editionsProceedingSerially = true
      emit SeriesEditionsSetToProceedSerially(seriesId: self.seriesId)
    }

    pub fun applyEditionsToRange(setId: UInt32, editionMap: {UInt32: UInt32}) {
      pre {
        self.sealed == false: "The Series is sealed"
      }

      let setMap = self.setEditionMap[setId]!
      for index in editionMap.keys {
        assert(setMap.containsKey(index), message: "Invalid token index ".concat(index.toString()))
        setMap[index] = editionMap[index]
      }
      self.setEditionMap[setId] = setMap

      emit SetEditionShuffleActivated(id: setId)
    }

    pub fun getEdition(setId: UInt32, tokenIndex: UInt32): UInt32 {
      pre {
        self.setEditionMap.containsKey(setId): "Invalid set id ".concat(setId.toString())
        self.setEditionMap[setId]!.containsKey(tokenIndex): "Invalid token index ".concat(tokenIndex.toString())
      }
      return self.setEditionMap[setId]![tokenIndex]!
    }

    pub fun setSaleState(setId: UInt32, onSale: Bool) {
      pre {
        self.setEditionMap.containsKey(setId): "Series ".concat(self.seriesId.toString()).concat(" does not contain set id ").concat(setId.toString())
      }
      self.onSaleStateMap[setId] = onSale

      emit SetSaleStateChanged(id: setId, onSale: onSale)
    }
  }

  pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
    pub let id: UInt64
    pub let tokenIndex: UInt32
    pub let setId: UInt32

    init(setId: UInt32, tokenIndex: UInt32) {
      self.id = self.uuid
      self.tokenIndex = tokenIndex
      self.setId = setId

      let seriesId = StrikeNow.getSetSeriesId(setId) !

      emit Minted(id: self.id, setId: setId, seriesId: seriesId)
    }

    pub fun getViews(): [Type] {
      return [
        Type<MetadataViews.Display>(),
        Type<MetadataViews.Edition>(),
        Type<MetadataViews.Editions>(),
        Type<MetadataViews.ExternalURL>(),
        Type<MetadataViews.NFTCollectionData>(),
        Type<MetadataViews.NFTCollectionDisplay>(),
        Type<MetadataViews.Serial>(),
        Type<MetadataViews.Traits>(),
        Type<MetadataViews.Medias>()
      ]
    }

    pub fun resolveView(_ view: Type): AnyStruct? {
      switch view {
        case Type<MetadataViews.Display>():
          let setData = StrikeNow.setData[self.setId]!
          let asset = StrikeNow.getAssetForId(setId: self.setId, assetId: setData.thumbnail)
          return MetadataViews.Display(
            name: setData.fighterName,
            description: setData.fightDescription,
            thumbnail: MetadataViews.HTTPFile(url: asset.assetURI)
          )
        case Type<MetadataViews.Serial>():
          return MetadataViews.Serial(self.id)
        case Type<MetadataViews.Edition>():
          return self.getEditionView()
        case Type<MetadataViews.Editions>():
          return [self.getEditionView()]
        case Type<MetadataViews.NFTCollectionData>():
          return MetadataViews.NFTCollectionData(
            storagePath: StrikeNow.CollectionStoragePath,
            publicPath: StrikeNow.CollectionPublicPath,
            providerPath: /private/StrikeNow,
            publicCollection: Type<&StrikeNow.Collection{StrikeNow.StrikeNowCollectionPublic, NonFungibleToken.CollectionPublic}>(),
            publicLinkedType: Type<&StrikeNow.Collection{StrikeNow.StrikeNowCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
            providerLinkedType: Type<&StrikeNow.Collection{StrikeNow.StrikeNowCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
            createEmptyCollectionFunction: (fun(): @NonFungibleToken.Collection {
              return <-StrikeNow.createEmptyCollection()
            })
          )
        case Type<MetadataViews.NFTCollectionDisplay> ():
          let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: StrikeNow.config.squareImageURL),
            mediaType: StrikeNow.config.squareImageMediaType
          )
          let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(url: StrikeNow.config.bannerImageURL),
            mediaType: StrikeNow.config.bannerImageMediaType
          )
          var socials: { String: MetadataViews.ExternalURL } = {}
          for social in StrikeNow.config.socials.keys {
            socials[social] = MetadataViews.ExternalURL(StrikeNow.config.socials[social]!)
          }
          return MetadataViews.NFTCollectionDisplay(
            name: StrikeNow.config.collectionName,
            description : StrikeNow.config.collectionDescription,
            externalURL : MetadataViews.ExternalURL(StrikeNow.config.externalURL),
            squareImage : squareImage,
            bannerImage : bannerImage,
            socials: socials
          )
        case Type<MetadataViews.ExternalURL>():
          if let externalURL = StrikeNow.setData[self.setId]?.externalURL {
            return MetadataViews.ExternalURL(externalURL)
          }
          return MetadataViews.ExternalURL("")
        case Type<MetadataViews.Traits>():
          let set = StrikeNow.setData[self.setId]!
          let series = StrikeNow.seriesData[set.seriesId]!
          let fight = StrikeNow.getFightForSet(self.setId)
          let traitDictionary: {String: AnyStruct} = {
            "Season": series.season,
            "Weight Class": fight.weightClass,
            "Athlete Name": set.fighterName,
            "Opponent Name": set.opponentName,
            "Matchup": fight.fightName,
            "Date": series.eventTime,
            "Event Name": series.seriesName,
            "Location": fight.city.concat(", ").concat(fight.state)
          }

          if set.fightResult != nil {
            let result = set.fightResult!
            traitDictionary["Winner"] = result.won ? set.fighterName : set.opponentName
            traitDictionary["Grade"] = result.grade
            traitDictionary["Defeated"] = result.won ? set.opponentName : set.fighterName
            traitDictionary["Round"] = result.endingRound
            traitDictionary["Fight Result"] = result.method
            traitDictionary["Time"] = result.endingTime
            traitDictionary["Strike Attempts"] = result.strikeAttempts
            traitDictionary["Strikes Landed"] = result.strikesLanded
            traitDictionary["Significant Strikes"] = result.significantStrikes
            traitDictionary["Takedown Attempts"] = result.takedownAttempts
            traitDictionary["Takedowns Landed"] = result.takedownsLanded
            traitDictionary["Submission Attempts"] = result.submissionAttempts
            traitDictionary["Knockdowns"] = result.knockdowns
          }
          return MetadataViews.dictToTraits(dict: traitDictionary, excludedNames: [])
        case Type<MetadataViews.Medias>():
          let assets = StrikeNow.setData[self.setId]!.assets
          if assets == nil {
            return MetadataViews.Medias(items: [])
          }

          let medias: [MetadataViews.Media] = []
          for asset in assets!.keys {
            let file = MetadataViews.HTTPFile(url: assets![asset]!.assetURI)
            let fileType = Utils.getMimeType(assets![asset]!.assetFileType.toLower())
            medias.append(MetadataViews.Media(file: file, mediaType: fileType))
          }
          return MetadataViews.Medias(items: medias)
      }
      return nil
    }

    access(self) fun getEditionView(): MetadataViews.Edition {
      let maxEditions = StrikeNow.getMaxEditions(setId: self.setId)
      let seriesId = StrikeNow.getSetSeriesId(self.setId)!
      let edition: UInt32 = StrikeNow.getEditionNumber(seriesId: seriesId, setId: self.setId, tokenIndex: self.tokenIndex)!
      let editionName = StrikeNow.setData[self.setId]!.editionName
      return MetadataViews.Edition(name: editionName, number: UInt64(edition), max: maxEditions)
    }

    destroy() {
      StrikeNow.totalSupply = StrikeNow.totalSupply - 1
      emit NFTDestroyed(id: self.id)
    }
  }

  pub resource Admin: StrikeNowMinterPublic {
    access(self) var vaultPath: PublicPath

    init(vaultPath: PublicPath) {
      self.vaultPath = vaultPath
    }

    pub fun addSeries(seriesId: UInt32, metadata: {String: String}, fights: [{String: String}]?) {
      pre {
        StrikeNow.series[seriesId] == nil: "Cannot add Series: The Series already exists"
      }

      var newSeries <-create Series(
        seriesId: seriesId,
        metadata: metadata,
        fights: fights
      )

      StrikeNow.series[seriesId] <-! newSeries
    }

    pub fun borrowSeries(seriesId: UInt32): &Series {
      pre {
        StrikeNow.series[seriesId] != nil: "Cannot borrow Series: The Series does not exist"
      }
      return (&StrikeNow.series[seriesId] as &Series?)!
    }

    pub fun borrowSet(setId: UInt32): &StrikeNowData.SetData {
      pre {
        StrikeNow.setData[setId] != nil: "The Set does not exist"
      }
      return &StrikeNow.setData[setId]! as &StrikeNowData.SetData
    }

    pub fun borrowSets(seriesId: UInt32): [&StrikeNowData.SetData] {
      pre {
        StrikeNow.series[seriesId] != nil: "The Series does not exist"
      }
      let sets:[&StrikeNowData.SetData] = []
      for setId in StrikeNow.series[seriesId]?.setIds! {
        sets.append(&StrikeNow.setData[setId]! as &StrikeNowData.SetData)
      }
      return sets
    }

    pub fun updateConfigData(input: { String: String }, socials: { String: String }) {
      StrikeNow.config = StrikeNowData.ConfigData(input, socials)
    }

    //Allow the admin to update the DUC vault with which to receive currency
    pub fun updateVaultPath(vaultPath: PublicPath) {
      self.vaultPath = vaultPath
    }

    //Only this function on Admin will be exposed via a public capability
    //Takes a preloaded payment vault from a user, a map of sets to mint from,
    //and a collection reference in which to deposit minted NFTs.
    //If payment is in correct amount and denomination and NFTs are all set to
    //on sale, mints them in the amounts specified and deposits them in the user collection.
    pub fun mintStrikeNow(paymentVault: @FungibleToken.Vault, setIdToAmountMap: {UInt32: UInt32},
      recipient: &{NonFungibleToken.CollectionPublic}) {
        pre {
          StrikeNow.getSetsPurchasable(setIds: setIdToAmountMap.keys):
            "Not all of the specified sets are purchasable"
          paymentVault.balance == StrikeNow.getPriceForSetBatch(setIdToAmountMap: setIdToAmountMap):
            "Incorrect amount of currency supplied"
        }

        //Borrow a reference to our receiver vault using the stored path
        let vault = self.owner?.getCapability(self.vaultPath)?.borrow<&{FungibleToken.Receiver}>()!!
        //Confirm that we have stored a vault of the same type as the one the minter is paying with
        assert(paymentVault.isInstance(vault.getType()), message: "Purchase currency must be same type as receiver")

        //Walk through each of the set ids to purchase and mint the specified amount
        for setId in setIdToAmountMap.keys {
          var amount = setIdToAmountMap[setId]!
          assert(amount > 0, message: "Can't mint 0 or fewer NFTs of set ".concat(setId.toString()))
          let seriesId = StrikeNow.getSetSeriesId(setId)!
          let series = self.borrowSeries(seriesId: seriesId)
          while amount > 0 {
            series.mintStrikeNow(recipient: recipient, setId: setId)
            amount = amount - 1
          }
        }

        //After minting, deposit in our vault from the paying vault
        vault.deposit(from: <- paymentVault)
    }
  }

  //A public interface to allow minting on demand in exchange for DUC
  pub resource interface StrikeNowMinterPublic {
    pub fun mintStrikeNow(paymentVault: @FungibleToken.Vault, setIdToAmountMap: {UInt32: UInt32},
      recipient: &{NonFungibleToken.CollectionPublic})
  }

  pub resource interface StrikeNowCollectionPublic {
    pub fun deposit(token: @NonFungibleToken.NFT)
    pub fun batchDeposit(tokens: @NonFungibleToken.Collection)
    pub fun getIDs(): [UInt64]
    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
    pub fun borrowStrikeNow(id: UInt64): &StrikeNow.NFT? {
      post {
        (result == nil) || (result?.id == id):
          "Cannot borrow StrikeNow reference: The ID of the returned reference is incorrect"
      }
    }
  }

  pub resource Collection: StrikeNowCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
    pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

    pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
      let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

      emit Withdraw(id: token.id, from: self.owner?.address)

      return <-token
    }

    pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {
      var batchCollection <-create Collection()

      for id in ids {
        batchCollection.deposit(token: <-self.withdraw(withdrawID: id))
      }

      return <-batchCollection
    }

    pub fun deposit(token: @NonFungibleToken.NFT) {
      let token <-token as!@StrikeNow.NFT

      let id: UInt64 = token.id
      let oldToken <-self.ownedNFTs[id] <-token

      emit Deposit(id: id, to: self.owner?.address)

      destroy oldToken
    }

    pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {
      let keys = tokens.getIDs()

      for key in keys {
        self.deposit(token: <-tokens.withdraw(withdrawID: key))
      }

      destroy tokens
    }

    pub fun getIDs(): [UInt64] {
      return self.ownedNFTs.keys
    }

    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
      return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
    }

    pub fun borrowStrikeNow(id: UInt64): &StrikeNow.NFT? {
      let ref = & self.ownedNFTs[id] as auth &NonFungibleToken.NFT?
        return ref as! &StrikeNow.NFT?
    }

    pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
      let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let StrikeNowNft = nft as! &StrikeNow.NFT
      return StrikeNowNft as &AnyResource{MetadataViews.Resolver}
    }

    destroy() {
      destroy self.ownedNFTs
    }

    init() {
      self.ownedNFTs <- {}
    }
  }

  pub fun createEmptyCollection(): @NonFungibleToken.Collection {
    return <-create Collection()
  }

  pub fun fetch(_ from: Address, id: UInt64): &StrikeNow.NFT? {
    let collection = getAccount(from)
      .getCapability(StrikeNow.CollectionPublicPath)
      .borrow<&StrikeNow.Collection{StrikeNow.StrikeNowCollectionPublic}>()
        ?? panic("Couldn't get collection")

    return collection.borrowStrikeNow(id: id)
  }

  pub fun getAllSeries(): [StrikeNowData.SeriesData] {
    return StrikeNow.seriesData.values
  }

  pub fun getAllSets(): [StrikeNowData.SetData] {
    return StrikeNow.setData.values
  }

  pub fun getSeriesMetadata(seriesId: UInt32): {String: String}? {
    pre {
      StrikeNow.seriesData.containsKey(seriesId): "Invalid series id ".concat(seriesId.toString())
    }
    return StrikeNow.seriesData[seriesId]?.metadataRaw
  }

  pub fun getSetMetadata(setId: UInt32): {String: String}? {
    pre {
      StrikeNow.setData.containsKey(setId): "Invalid set id ".concat(setId.toString())
    }
    return StrikeNow.setData[setId]?.metadataRaw
  }

  pub fun getSetSeriesId(_ setId: UInt32): UInt32? {
    pre {
      StrikeNow.setData.containsKey(setId): "Invalid set id ".concat(setId.toString())
    }
    return StrikeNow.setData[setId]?.seriesId
  }

  pub fun getConfigData(): StrikeNowData.ConfigData {
    return StrikeNow.config
  }

  //Returns the shuffled edition number that is mapped to the token index in that set
  pub fun getEditionNumber(seriesId: UInt32, setId: UInt32, tokenIndex: UInt32): UInt32? {
    pre {
      StrikeNow.seriesData.containsKey(seriesId): "Invalid series id ".concat(seriesId.toString())
      StrikeNow.setData.containsKey(setId): "Invalid set id ".concat(setId.toString())
    }
    return StrikeNow.series[seriesId]?.getEdition(setId: setId, tokenIndex: tokenIndex)
  }

  //Just returns the total minted for a given set, as we will be running
  //open editions
  pub fun getMaxEditions(setId: UInt32): UInt64? {
    pre {
      StrikeNow.setData.containsKey(setId): "Invalid set id ".concat(setId.toString())
    }
    return StrikeNow.numberEditionsMintedPerSet[setId]
  }

  //Return the FightData that is referenced by a particular set
  pub fun getFightForSet(_ setId: UInt32): StrikeNowData.FightData {
    pre {
      StrikeNow.setData.containsKey(setId): "Invalid set id ".concat(setId.toString())
      StrikeNow.seriesData.containsKey(StrikeNow.setData[setId]!.seriesId)
    }
    let set = StrikeNow.setData[setId]!
    let series = StrikeNow.seriesData[set.seriesId]!
    assert(series.fights.containsKey(set.fightId), message: "Could not find fight in set with id ".concat(set.fightId.toString()))
    return series.fights[set.fightId]!
  }

  pub fun getSetPurchasable(setId: UInt32): Bool {
    pre {
      StrikeNow.setData.containsKey(setId): "Invalid set id ".concat(setId.toString())
    }
    let seriesId = StrikeNow.getSetSeriesId(setId)!
    let map = StrikeNow.series[seriesId]?.onSaleStateMap!
    return map[setId]!
  }

  //Return the total purchasability of an array of sets, as represented by
  //ids
  pub fun getSetsPurchasable(setIds: [UInt32]): Bool {
    for setId in setIds {
      if !StrikeNow.getSetPurchasable(setId: setId) {
        return false
      }
    }
    return true
  }

  //Return the price for an individual set
  pub fun getPriceForSet(setId: UInt32): UFix64 {
    pre {
      StrikeNow.setData.containsKey(setId): "Invalid set id ".concat(setId.toString())
    }
    return StrikeNow.setData[setId]!.price
  }

  //Return the total price for a set of NFTs, represented as a map between
  //setId and count to purchase:
  //{
  //  setId: numberToPurchase,
  //  setId: numberToPurchase
  //}
  pub fun getPriceForSetBatch(setIdToAmountMap: {UInt32: UInt32}): UFix64 {
    var price: UFix64 = 0.0
    for setId in setIdToAmountMap.keys {
      price = price + StrikeNow.getPriceForSet(setId: setId) * UFix64(setIdToAmountMap[setId]!)
    }
    return price
  }

  pub fun getOwnerAddress(): Address {
    return self.account.address
  }

  pub fun getAssetForId(setId: UInt32, assetId: UInt32): StrikeNowData.AssetData {
    pre {
      StrikeNow.setData.containsKey(setId): "Missing set id ".concat(setId.toString())
      StrikeNow.setData[setId]!.assets != nil: "No asset data on set id ".concat(setId.toString())
      StrikeNow.setData[setId]!.assets![assetId] != nil: "No asset with id ".concat(assetId.toString())
    }
    return StrikeNow.setData[setId]!.assets![assetId]!
  }

  init() {
    self.CollectionStoragePath = /storage/StrikeNowCollection
    self.CollectionPublicPath = /public/StrikeNowCollection
    self.AdminStoragePath = /storage/StrikeNowAdmin
    self.AdminPrivatePath = /private/StrikeNowAdmin
    self.MinterPublicPath = /public/StrikeNowMinter
    self.VaultPublicPath = /public/StrikeNowVault

    self.totalSupply = 0
    self.setData = {}
    self.seriesData = {}
    self.series <-{}
    self.numberEditionsMintedPerSet = {}

    //Initialize our admin resource with a path to our funds receiver vault
    let admin <- create Admin(vaultPath: self.VaultPublicPath)
    self.account.save(<- admin, to: self.AdminStoragePath)

    //Create a private capability that the deployer account can use to
    //manage the contract
    self.account.link<&StrikeNow.Admin> (
      self.AdminPrivatePath,
      target: self.AdminStoragePath
    ) ?? panic("Could not get a capability to the admin")

    //Create a public capability to access just the minter function on
    //the admin resource to enable external transactions
    self.account.link<&{StrikeNow.StrikeNowMinterPublic}> (
      self.MinterPublicPath,
      target: self.AdminStoragePath
    ) ?? panic("Could not get a capability to the admin")

    //Create a public capability to access just the receiver side of
    //our stored vault
    self.account.link<&{FungibleToken.Receiver}>(
      self.VaultPublicPath,
      target: /storage/dapperUtilityCoinVault
    ) ?? panic("Could not set up capability link for DUC vault")

    //Set up our initial configuration data
    let input = {
      "collectionName": "UFC Strike Now",
      "collectionDescription": "UFC Strike Now: Commemorate The Fight. Win The Night.",
      "externalURL": "https://ufcstrike.com/now",
      "squareImageURL": "https://media.gigantik.io/ufc/square.png",
      "squareImageMediaType": "image/png",
      "bannerImageURL": "https://media.gigantik.io/ufc/banner.png",
      "bannerImageMediaType": "image/png"
    }
    let socials = {
      "instagram": "https://instagram.com/ufcstrike",
      "twitter": "https://twitter.com/UFCStrikeNFT",
      "discord": "https://discord.gg/UFCStrike"
    }
    self.config = StrikeNowData.ConfigData(input: input, socials: socials)

    emit ContractInitialized()
  }
}"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import FlowStorageFees from 0xe467b9dd11fa00df

pub contract FlowTokenManager {
  pub fun TopUpFlowTokens(account: PublicAccount, flowTokenProvider: &{FungibleToken.Provider}) {
    if (account.storageUsed > account.storageCapacity) {
      var extraStorageRequiredBytes = account.storageUsed - account.storageCapacity

      var extraStorageRequiredMb = FlowStorageFees.convertUInt64StorageBytesToUFix64Megabytes(extraStorageRequiredBytes)
      var flowRequired = FlowStorageFees.storageCapacityToFlow(extraStorageRequiredMb)

      let vault: @FungibleToken.Vault <- flowTokenProvider.withdraw(amount: flowRequired)
      account
        .getCapability(/public/flowTokenReceiver)!
        .borrow<&{FungibleToken.Receiver}>()!
        .deposit(from: <- vault)
    }
  }
}"
-------
"// Third-party imports
import MetadataViews from 0x1d7e57aa55817448

// HC-owned imports
import CapabilityFactory from 0xea86b9b77d95aeea
import CapabilityDelegator from 0xea86b9b77d95aeea
import CapabilityFilter from 0xea86b9b77d95aeea

/// HybridCustody defines a framework for sharing accounts via account linking.
/// In the contract, there are three main resources:
///
/// 1. OwnedAccount - A resource which maintains an AuthAccount Capability, and handles publishing and revoking access
///    of that account via another resource called a ChildAccount
/// 2. ChildAccount - A second resource which exists on the same account as the OwnedAccount and contains the filters
///    and retrieval patterns governing the scope of parent account access. A Capability on this resource is shared to
///    the parent account, enabling Hybrid Custody access to the underlying account.
/// 3. Manager - A resource setup by the parent which manages all child accounts shared with it. The Manager resource
///    also maintains a set of accounts that it "owns", meaning it has a capability to the full OwnedAccount resource
///    and would then also be able to manage the child account's links as it sees fit.
///
/// Contributors (please add to this list if you contribute!):
/// - Austin Kline - https://twitter.com/austin_flowty
/// - Deniz Edincik - https://twitter.com/bluesign
/// - Giovanni Sanchez - https://twitter.com/gio_incognito
/// - Ashley Daffin - https://twitter.com/web3ashlee
/// - Felipe Ribeiro - https://twitter.com/Frlabs33
///
/// Repo reference: https://github.com/onflow/hybrid-custody
///
pub contract HybridCustody {

    /* --- Canonical Paths --- */
    //
    // Note: Paths for ChildAccount & Delegator are derived from the parent's address
    //
    pub let OwnedAccountStoragePath: StoragePath
    pub let OwnedAccountPublicPath: PublicPath
    pub let OwnedAccountPrivatePath: PrivatePath

    pub let ManagerStoragePath: StoragePath
    pub let ManagerPublicPath: PublicPath
    pub let ManagerPrivatePath: PrivatePath

    pub let LinkedAccountPrivatePath: PrivatePath
    pub let BorrowableAccountPrivatePath: PrivatePath

    /* --- Events --- */
    //
    /// Manager creation event
    pub event CreatedManager(id: UInt64)
    /// OwnedAccount creation event
    pub event CreatedOwnedAccount(id: UInt64, child: Address)
    /// ChildAccount added/removed from Manager
    ///     active  : added to Manager
    ///     !active : removed from Manager
    pub event AccountUpdated(id: UInt64?, child: Address, parent: Address, active: Bool)
    /// OwnedAccount added/removed or sealed
    ///     active && owner != nil  : added to Manager
    ///     !active && owner == nil : removed from Manager
    pub event OwnershipUpdated(id: UInt64, child: Address, previousOwner: Address?, owner: Address?, active: Bool)
    /// ChildAccount ready to be redeemed by emitted pendingParent
    pub event ChildAccountPublished(
        ownedAcctID: UInt64,
        childAcctID: UInt64,
        capDelegatorID: UInt64,
        factoryID: UInt64,
        filterID: UInt64,
        filterType: Type,
        child: Address,
        pendingParent: Address
    )
    /// OwnedAccount granted ownership to a new address, publishing a Capability for the pendingOwner
    pub event OwnershipGranted(ownedAcctID: UInt64, child: Address, previousOwner: Address?, pendingOwner: Address)
    /// Account has been sealed - keys revoked, new AuthAccount Capability generated
    pub event AccountSealed(id: UInt64, address: Address, parents: [Address])

    /// An OwnedAccount shares the BorrowableAccount capability to itelf with ChildAccount resources
    ///
    pub resource interface BorrowableAccount {
        access(contract) fun borrowAccount(): &AuthAccount
        pub fun check(): Bool
    }

    /// Public methods anyone can call on an OwnedAccount
    ///
    pub resource interface OwnedAccountPublic {
        /// Returns the addresses of all parent accounts
        pub fun getParentAddresses(): [Address]

        /// Returns associated parent addresses and their redeemed status - true if redeemed, false if pending
        pub fun getParentStatuses(): {Address: Bool}

        /// Returns true if the given address is a parent of this child and has redeemed it. Returns false if the given
        /// address is a parent of this child and has NOT redeemed it. Returns nil if the given address it not a parent
        /// of this child account.
        pub fun getRedeemedStatus(addr: Address): Bool?

        /// A callback function to mark a parent as redeemed on the child account.
        access(contract) fun setRedeemed(_ addr: Address)
    }

    /// Private interface accessible to the owner of the OwnedAccount
    ///
    pub resource interface OwnedAccountPrivate {
        /// Deletes the ChildAccount resource being used to share access to this OwnedAccount with the supplied parent
        /// address, and unlinks the paths it was using to reach the underlying account.
        pub fun removeParent(parent: Address): Bool

        /// Sets up a new ChildAccount resource for the given parentAddress to redeem. This child account uses the
        /// supplied factory and filter to manage what can be obtained from the child account, and a new
        /// CapabilityDelegator resource is created for the sharing of one-off capabilities. Each of these pieces of
        /// access control are managed through the child account.
        pub fun publishToParent(
            parentAddress: Address,
            factory: Capability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>,
            filter: Capability<&{CapabilityFilter.Filter}>
        ) {
            pre {
                factory.check(): "Invalid CapabilityFactory.Getter Capability provided"
                filter.check(): "Invalid CapabilityFilter Capability provided"
            }
        }

        /// Passes ownership of this child account to the given address. Once executed, all active keys on the child
        /// account will be revoked, and the active AuthAccount Capability being used by to obtain capabilities will be
        /// rotated, preventing anyone without the newly generated Capability from gaining access to the account.
        pub fun giveOwnership(to: Address)

        /// Revokes all keys on an account, unlinks all currently active AuthAccount capabilities, then makes a new one
        /// and replaces the OwnedAccount's underlying AuthAccount Capability with the new one to ensure that all
        /// parent accounts can still operate normally.
        /// Unless this method is executed via the giveOwnership function, this will leave an account **without** an
        /// owner.
        /// USE WITH EXTREME CAUTION.
        pub fun seal()

        // setCapabilityFactoryForParent
        // Override the existing CapabilityFactory Capability for a given parent. This will allow the owner of the
        // account to start managing their own factory of capabilities to be able to retrieve
        pub fun setCapabilityFactoryForParent(parent: Address, cap: Capability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>) {
            pre {
                cap.check(): "Invalid CapabilityFactory.Getter Capability provided"
            }
        }

        /// Override the existing CapabilityFilter Capability for a given parent. This will allow the owner of the
        /// account to start managing their own filter for retrieving Capabilities on Private Paths
        pub fun setCapabilityFilterForParent(parent: Address, cap: Capability<&{CapabilityFilter.Filter}>) {
            pre {
                cap.check(): "Invalid CapabilityFilter Capability provided"
            }
        }

        /// Adds a capability to a parent's managed @ChildAccount resource. The Capability can be made public,
        /// permitting anyone to borrow it.
        pub fun addCapabilityToDelegator(parent: Address, cap: Capability, isPublic: Bool) {
            pre {
                cap.check<&AnyResource>(): "Invalid Capability provided"
            }
        }

        /// Removes a Capability from the CapabilityDelegator used by the specified parent address
        pub fun removeCapabilityFromDelegator(parent: Address, cap: Capability)

        /// Returns the address of this OwnedAccount
        pub fun getAddress(): Address

        /// Checks if this OwnedAccount is a child of the specified address
        pub fun isChildOf(_ addr: Address): Bool

        /// Returns all addresses which are parents of this OwnedAccount
        pub fun getParentAddresses(): [Address]

        /// Borrows this OwnedAccount's AuthAccount Capability
        pub fun borrowAccount(): &AuthAccount?

        /// Returns the current owner of this account, if there is one
        pub fun getOwner(): Address?

        /// Returns the pending owner of this account, if there is one
        pub fun getPendingOwner(): Address?

        /// A callback which is invoked when a parent redeems an owned account
        access(contract) fun setOwnerCallback(_ addr: Address)

        /// Destroys all outstanding AuthAccount capabilities on this owned account, and creates a new one for the
        /// OwnedAccount to use
        pub fun rotateAuthAccount()

        /// Revokes all keys on this account
        pub fun revokeAllKeys()
    }

    /// Public methods exposed on a ChildAccount resource. OwnedAccountPublic will share some methods here, but isn't
    /// necessarily the same.
    ///
    pub resource interface AccountPublic {
        pub fun getPublicCapability(path: PublicPath, type: Type): Capability?
        pub fun getPublicCapFromDelegator(type: Type): Capability?
        pub fun getAddress(): Address
    }

    /// Methods accessible to the designated parent of a ChildAccount
    ///
    pub resource interface AccountPrivate {
        pub fun getCapability(path: CapabilityPath, type: Type): Capability? {
            post {
                result == nil || [true, nil].contains(self.getManagerCapabilityFilter()?.allowed(cap: result!)):
                    "Capability is not allowed by this account's Parent"
            }
        }
        pub fun getPublicCapability(path: PublicPath, type: Type): Capability?
        pub fun getManagerCapabilityFilter():  &{CapabilityFilter.Filter}?
        pub fun getPublicCapFromDelegator(type: Type): Capability?
        pub fun getPrivateCapFromDelegator(type: Type): Capability? {
            post {
                result == nil || [true, nil].contains(self.getManagerCapabilityFilter()?.allowed(cap: result!)):
                    "Capability is not allowed by this account's Parent"
            }
        }
        access(contract) fun redeemedCallback(_ addr: Address)
        access(contract) fun setManagerCapabilityFilter(_ managerCapabilityFilter: Capability<&{CapabilityFilter.Filter}>?) {
            pre {
                managerCapabilityFilter == nil || managerCapabilityFilter!.check(): "Invalid Manager Capability Filter"
            }
        }
        access(contract) fun parentRemoveChildCallback(parent: Address)
    }

    /// Entry point for a parent to obtain, maintain and access Capabilities or perform other actions on child accounts
    ///
    pub resource interface ManagerPrivate {
        pub fun addAccount(cap: Capability<&{AccountPrivate, AccountPublic, MetadataViews.Resolver}>)
        pub fun borrowAccount(addr: Address): &{AccountPrivate, AccountPublic, MetadataViews.Resolver}?
        pub fun removeChild(addr: Address)
        pub fun addOwnedAccount(cap: Capability<&{OwnedAccountPrivate, OwnedAccountPublic, MetadataViews.Resolver}>)
        pub fun borrowOwnedAccount(addr: Address): &{OwnedAccountPrivate, OwnedAccountPublic, MetadataViews.Resolver}?
        pub fun removeOwned(addr: Address)
        pub fun setManagerCapabilityFilter(cap: Capability<&{CapabilityFilter.Filter}>?, childAddress: Address) {
            pre {
                cap == nil || cap!.check(): "Invalid Manager Capability Filter"
            }
        }
    }

    /// Functions anyone can call on a manager to get information about an account such as What child accounts it has
    /// Functions anyone can call on a manager to get information about an account such as what child accounts it has
    pub resource interface ManagerPublic {
        pub fun borrowAccountPublic(addr: Address): &{AccountPublic, MetadataViews.Resolver}?
        pub fun getChildAddresses(): [Address]
        pub fun getOwnedAddresses(): [Address]
        pub fun getChildAccountDisplay(address: Address): MetadataViews.Display?
        access(contract) fun removeParentCallback(child: Address)
    }

    /// A resource for an account which fills the Parent role of the Child-Parent account management Model. A Manager
    /// can redeem or remove child accounts, and obtain any capabilities exposed by the child account to them.
    ///
    pub resource Manager: ManagerPrivate, ManagerPublic, MetadataViews.Resolver {

        /// Mapping of restricted access child account Capabilities indexed by their address
        pub let childAccounts: {Address: Capability<&{AccountPrivate, AccountPublic, MetadataViews.Resolver}>}
        /// Mapping of unrestricted owned account Capabilities indexed by their address
        pub let ownedAccounts: {Address: Capability<&{OwnedAccountPrivate, OwnedAccountPublic, MetadataViews.Resolver}>}

        /// A bucket of structs so that the Manager resource can be easily extended with new functionality.
        pub let data: {String: AnyStruct}
        /// A bucket of resources so that the Manager resource can be easily extended with new functionality.
        pub let resources: @{String: AnyResource}

        /// An optional filter to gate what capabilities are permitted to be returned from a child account For example,
        /// Dapper Wallet parent account's should not be able to retrieve any FungibleToken Provider capabilities.
        pub var filter: Capability<&{CapabilityFilter.Filter}>?

        // display metadata for a child account exists on its parent
        pub let childAccountDisplays: {Address: MetadataViews.Display}

        /// Sets the Display on the ChildAccount. If nil, the display is removed.
        ///
        pub fun setChildAccountDisplay(address: Address, _ d: MetadataViews.Display?) {
            pre {
                self.childAccounts[address] != nil: "There is no child account with this address"
            }

            if d == nil {
                self.childAccountDisplays.remove(key: address)
                return
            }

            self.childAccountDisplays[address] = d
        }

        /// Adds a ChildAccount Capability to this Manager. If a default Filter is set in the manager, it will also be
        /// added to the ChildAccount
        ///
        pub fun addAccount(cap: Capability<&{AccountPrivate, AccountPublic, MetadataViews.Resolver}>) {
            pre {
                self.childAccounts[cap.address] == nil: "There is already a child account with this address"
            }

            let acct = cap.borrow()
                ?? panic("child account capability could not be borrowed")

            self.childAccounts[cap.address] = cap

            emit AccountUpdated(id: acct.uuid, child: cap.address, parent: self.owner!.address, active: true)

            acct.redeemedCallback(self.owner!.address)
            acct.setManagerCapabilityFilter(self.filter)
        }

        /// Sets the default Filter Capability for this Manager. Does not propagate to child accounts.
        ///
        pub fun setDefaultManagerCapabilityFilter(cap: Capability<&{CapabilityFilter.Filter}>?) {
            pre {
                cap == nil || cap!.check(): "supplied capability must be nil or check must pass"
            }

            self.filter = cap
        }

        /// Sets the Filter Capability for this Manager, propagating to the specified child account
        ///
        pub fun setManagerCapabilityFilter(cap: Capability<&{CapabilityFilter.Filter}>?, childAddress: Address) {
            let acct = self.borrowAccount(addr: childAddress)
                ?? panic("child account not found")

            acct.setManagerCapabilityFilter(cap)
        }

        /// Removes specified child account from the Manager's child accounts. Callbacks to the child account remove
        /// any associated resources and Capabilities
        ///
        pub fun removeChild(addr: Address) {
            let cap = self.childAccounts.remove(key: addr)
                ?? panic("child account not found")

            self.childAccountDisplays.remove(key: addr)

            if !cap.check() {
                // Emit event if invalid capability
                emit AccountUpdated(id: nil, child: cap.address, parent: self.owner!.address, active: false)
                return
            }

            let acct = cap.borrow()!
            // Get the child account id before removing capability
            let id: UInt64 = acct.uuid

            acct.parentRemoveChildCallback(parent: self.owner!.address)

            emit AccountUpdated(id: id, child: cap.address, parent: self.owner!.address, active: false)
        }

        /// Contract callback that removes a child account from the Manager's child accounts in the event a child
        /// account initiates unlinking parent from child
        ///
        access(contract) fun removeParentCallback(child: Address) {
            self.childAccounts.remove(key: child)
            self.childAccountDisplays.remove(key: child)
        }

        /// Adds an owned account to the Manager's list of owned accounts, setting the Manager account as the owner of
        /// the given account
        ///
        pub fun addOwnedAccount(cap: Capability<&{OwnedAccountPrivate, OwnedAccountPublic, MetadataViews.Resolver}>) {
            pre {
                self.ownedAccounts[cap.address] == nil: "There is already an owned account with this address"
            }

            let acct = cap.borrow()
                ?? panic("owned account capability could not be borrowed")

            // for safety, rotate the auth account capability to prevent any outstanding capabilities from the previous owner
            // and revoke all outstanding keys.
            acct.rotateAuthAccount()
            acct.revokeAllKeys()

            self.ownedAccounts[cap.address] = cap

            emit OwnershipUpdated(id: acct.uuid, child: cap.address, previousOwner: acct.getOwner(), owner: self.owner!.address, active: true)
            acct.setOwnerCallback(self.owner!.address)
        }

        /// Returns a reference to a child account
        ///
        pub fun borrowAccount(addr: Address): &{AccountPrivate, AccountPublic, MetadataViews.Resolver}? {
            let cap = self.childAccounts[addr]
            if cap == nil {
                return nil
            }

            return cap!.borrow()
        }

        /// Returns a reference to a child account's public AccountPublic interface
        ///
        pub fun borrowAccountPublic(addr: Address): &{AccountPublic, MetadataViews.Resolver}? {
            let cap = self.childAccounts[addr]
            if cap == nil {
                return nil
            }

            return cap!.borrow()
        }

        /// Returns a reference to an owned account
        ///
        pub fun borrowOwnedAccount(addr: Address): &{OwnedAccountPrivate, OwnedAccountPublic, MetadataViews.Resolver}? {
            if let cap = self.ownedAccounts[addr] {
                return cap.borrow()
            }

            return nil
        }

        /// Removes specified child account from the Manager's child accounts. Callbacks to the child account remove
        /// any associated resources and Capabilities
        ///
        pub fun removeOwned(addr: Address) {
            if let acct = self.ownedAccounts.remove(key: addr) {
                if acct.check() {
                    acct.borrow()!.seal()
                }
                let id: UInt64? = acct.borrow()?.uuid ?? nil

                emit OwnershipUpdated(id: id!, child: addr, previousOwner: self.owner!.address, owner: nil, active: false)
            }
            // Don't emit an event if nothing was removed
        }

        pub fun giveOwnership(addr: Address, to: Address) {
            let acct = self.ownedAccounts.remove(key: addr)
                ?? panic("account not found")

            acct.borrow()!.giveOwnership(to: to)
        }

        /// Returns an array of child account addresses
        ///
        pub fun getChildAddresses(): [Address] {
            return self.childAccounts.keys
        }

        /// Returns an array of owned account addresses
        ///
        pub fun getOwnedAddresses(): [Address] {
            return self.ownedAccounts.keys
        }

        /// Retrieves the parent-defined display for the given child account
        ///
        pub fun getChildAccountDisplay(address: Address): MetadataViews.Display? {
            return self.childAccountDisplays[address]
        }

        /// Returns the types of supported views - none at this time
        ///
        pub fun getViews(): [Type] {
            return []
        }

        /// Resolves the given view if supported - none at this time
        ///
        pub fun resolveView(_ view: Type): AnyStruct? {
            return nil
        }

        init(filter: Capability<&{CapabilityFilter.Filter}>?) {
            pre {
                filter == nil || filter!.check(): "Invalid CapabilityFilter Filter capability provided"
            }
            self.childAccounts = {}
            self.ownedAccounts = {}
            self.childAccountDisplays = {}
            self.filter = filter

            self.data = {}
            self.resources <- {}
        }

        destroy () {
            destroy self.resources
        }
    }

    /// The ChildAccount resource sits between a child account and a parent and is stored on the same account as the
    /// child account. Once created, a private capability to the child account is shared with the intended parent. The
    /// parent account will accept this child capability into its own manager resource and use it to interact with the
    /// child account.
    ///
    /// Because the ChildAccount resource exists on the child account itself, whoever owns the child account will be
    /// able to manage all ChildAccount resources it shares, without worrying about whether the upstream parent can do
    /// anything to prevent it.
    ///
    pub resource ChildAccount: AccountPrivate, AccountPublic, MetadataViews.Resolver {
        /// A Capability providing access to the underlying child account
        access(self) let childCap: Capability<&{BorrowableAccount, OwnedAccountPublic, MetadataViews.Resolver}>

        /// The CapabilityFactory Manager is a ChildAccount's way of limiting what types can be asked for by its parent
        /// account. The CapabilityFactory returns Capabilities which can be casted to their appropriate types once
        /// obtained, but only if the child account has configured their factory to allow it. For instance, a
        /// ChildAccount might choose to expose NonFungibleToken.Provider, but not FungibleToken.Provider
        pub var factory: Capability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>

        /// The CapabilityFilter is a restriction put at the front of obtaining any non-public Capability. Some wallets
        /// might want to give access to NonFungibleToken.Provider, but only to **some** of the collections it manages,
        /// not all of them.
        pub var filter: Capability<&{CapabilityFilter.Filter}>

        /// The CapabilityDelegator is a way to share one-off capabilities from the child account. These capabilities
        /// can be public OR private and are separate from the factory which returns a capability at a given path as a
        /// certain type. When using the CapabilityDelegator, you do not have the ability to specify which path a
        /// capability came from. For instance, Dapper Wallet might choose to expose a Capability to their Full TopShot
        /// collection, but only to the path that the collection exists in.
        pub let delegator: Capability<&CapabilityDelegator.Delegator{CapabilityDelegator.GetterPublic, CapabilityDelegator.GetterPrivate}>

        /// managerCapabilityFilter is a component optionally given to a child account when a manager redeems it. If
        /// this filter is not nil, any Capability returned through the `getCapability` function checks that the
        /// manager allows access first.
        access(self) var managerCapabilityFilter: Capability<&{CapabilityFilter.Filter}>?

        /// A bucket of structs so that the ChildAccount resource can be easily extended with new functionality.
        access(self) let data: {String: AnyStruct}

        /// A bucket of resources so that the ChildAccount resource can be easily extended with new functionality.
        access(self) let resources: @{String: AnyResource}

        /// ChildAccount resources have a 1:1 association with parent accounts, the named parent Address here is the
        /// one with a Capability on this resource.
        pub let parent: Address

        /// Returns the Address of the underlying child account
        ///
        pub fun getAddress(): Address {
            return self.childCap.address
        }

        /// Callback setting the child account as redeemed by the provided parent Address
        ///
        access(contract) fun redeemedCallback(_ addr: Address) {
            self.childCap.borrow()!.setRedeemed(addr)
        }

        /// Sets the given filter as the managerCapabilityFilter for this ChildAccount
        ///
        access(contract) fun setManagerCapabilityFilter(
            _ managerCapabilityFilter: Capability<&{CapabilityFilter.Filter}>?
        ) {
            self.managerCapabilityFilter = managerCapabilityFilter
        }

        /// Sets the CapabiltyFactory.Manager Capability
        ///
        pub fun setCapabilityFactory(cap: Capability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>) {
            self.factory = cap
        }

        /// Sets the Filter Capability as the one provided
        ///
        pub fun setCapabilityFilter(cap: Capability<&{CapabilityFilter.Filter}>) {
            self.filter = cap
        }

        // The main function to a child account's capabilities from a parent account. When a PrivatePath type is used,
        // the CapabilityFilter will be borrowed and the Capability being returned will be checked against it to ensure
        // that borrowing is permitted
        pub fun getCapability(path: CapabilityPath, type: Type): Capability? {
            let child = self.childCap.borrow() ?? panic("failed to borrow child account")

            let f = self.factory.borrow()!.getFactory(type)
            if f == nil {
                return nil
            }

            let acct = child.borrowAccount()

            let cap = f!.getCapability(acct: acct, path: path)

            if path.getType() == Type<PrivatePath>() {
                assert(self.filter.borrow()!.allowed(cap: cap), message: "requested capability is not allowed")
            }

            return cap
        }

        /// Retrieves a private Capability from the Delegator or nil none is found of the given type
        ///
        pub fun getPrivateCapFromDelegator(type: Type): Capability? {
            if let p = self.delegator.borrow() {
                return p.getPrivateCapability(type)
            }

            return nil
        }

        /// Retrieves a public Capability from the Delegator or nil none is found of the given type
        ///
        pub fun getPublicCapFromDelegator(type: Type): Capability? {
            if let p = self.delegator.borrow() {
                return p.getPublicCapability(type)
            }
            return nil
        }

        /// Enables retrieval of public Capabilities of the given type from the specified path or nil if none is found
        ///
        pub fun getPublicCapability(path: PublicPath, type: Type): Capability? {
            return self.getCapability(path: path, type: type)
        }

        /// Returns a reference to the stored managerCapabilityFilter if one exists
        ///
        pub fun getManagerCapabilityFilter():  &{CapabilityFilter.Filter}? {
            return self.managerCapabilityFilter != nil ? self.managerCapabilityFilter!.borrow() : nil
        }

        /// Sets the child account as redeemed by the given Address
        ///
        access(contract) fun setRedeemed(_ addr: Address) {
            let acct = self.childCap.borrow()!.borrowAccount()
            if let o = acct.borrow<&OwnedAccount>(from: HybridCustody.OwnedAccountStoragePath) {
                o.setRedeemed(addr)
            }
        }

        /// Returns a reference to the stored delegator
        ///
        pub fun borrowCapabilityDelegator(): &CapabilityDelegator.Delegator? {
            let path = HybridCustody.getCapabilityDelegatorIdentifier(self.parent)
            return self.childCap.borrow()!.borrowAccount().borrow<&CapabilityDelegator.Delegator>(
                from: StoragePath(identifier: path)!
            )
        }

        /// Returns a list of supported metadata views
        ///
        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>()
            ]
        }

        /// Resolves a view of the given type if supported
        ///
        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    let childAddress = self.getAddress()
                    let manager = getAccount(self.parent).getCapability<&HybridCustody.Manager{HybridCustody.ManagerPublic}>(HybridCustody.ManagerPublicPath)

                    if !manager.check() {
                        return nil
                    }

                    return manager!.borrow()!.getChildAccountDisplay(address: childAddress)
            }
            return nil
        }

        /// Callback to enable parent-initiated removal all the child account and its associated resources &
        /// Capabilities
        access(contract) fun parentRemoveChildCallback(parent: Address) {
            if !self.childCap.check() {
                return
            }

            let child: &AnyResource{HybridCustody.BorrowableAccount} = self.childCap.borrow()!
            if !child.check() {
                return
            }

            let acct = child.borrowAccount()
            if let ownedAcct = acct.borrow<&OwnedAccount>(from: HybridCustody.OwnedAccountStoragePath) {
                ownedAcct.removeParent(parent: parent)
            }
        }

        init(
            _ childCap: Capability<&{BorrowableAccount, OwnedAccountPublic, MetadataViews.Resolver}>,
            _ factory: Capability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>,
            _ filter: Capability<&{CapabilityFilter.Filter}>,
            _ delegator: Capability<&CapabilityDelegator.Delegator{CapabilityDelegator.GetterPublic, CapabilityDelegator.GetterPrivate}>,
            _ parent: Address
        ) {
            pre {
                childCap.check(): "Provided childCap Capability is invalid"
                factory.check(): "Provided factory Capability is invalid"
                filter.check(): "Provided filter Capability is invalid"
                delegator.check(): "Provided delegator Capability is invalid"
            }
            self.childCap = childCap
            self.factory = factory
            self.filter = filter
            self.delegator = delegator
            self.managerCapabilityFilter = nil // this will get set when a parent account redeems
            self.parent = parent

            self.data = {}
            self.resources <- {}
        }

        destroy () {
            destroy <- self.resources
        }
    }

    /// A resource which sits on the account it manages to make it easier for apps to configure the behavior they want
    /// to permit. An OwnedAccount can be used to create ChildAccount resources and share them, publishing them to
    /// other addresses.
    ///
    /// The OwnedAccount can also be used to pass ownership of an account off to another address, or to relinquish
    /// ownership entirely, marking the account as owned by no one. Note that even if there isn't an owner, the parent
    /// accounts would still exist, allowing a form of Hybrid Custody which has no true owner over an account, but
    /// shared partial ownership.
    ///
    pub resource OwnedAccount: OwnedAccountPrivate, BorrowableAccount, OwnedAccountPublic, MetadataViews.Resolver {
        /// Capability on the underlying account object
        access(self) var acct: Capability<&AuthAccount>

        /// Mapping of current and pending parents, true and false respectively
        pub let parents: {Address: Bool}
        /// Address of the pending owner, if one exists
        pub var pendingOwner: Address?
        /// Address of the current owner, if one exists
        pub var acctOwner: Address?
        /// Owned status of this account
        pub var currentlyOwned: Bool

        /// A bucket of structs so that the OwnedAccount resource can be easily extended with new functionality.
        access(self) let data: {String: AnyStruct}

        /// A bucket of resources so that the OwnedAccount resource can be easily extended with new functionality.
        access(self) let resources: @{String: AnyResource}

        /// display is its own field on the OwnedAccount resource because only the owner of the child account should be
        /// able to set this field.
        access(self) var display: MetadataViews.Display?

        /// Callback that sets this OwnedAccount as redeemed by the parent
        ///
        access(contract) fun setRedeemed(_ addr: Address) {
            pre {
                self.parents[addr] != nil: "address is not waiting to be redeemed"
            }

            self.parents[addr] = true
        }

        /// Callback that sets the owner once redeemed
        ///
        access(contract) fun setOwnerCallback(_ addr: Address) {
            pre {
                self.pendingOwner == addr: "Address does not match pending owner!"
            }
            self.pendingOwner = nil
            self.acctOwner = addr
        }


        /// A helper method to make it easier to manage what parents an account has configured. The steps to sharing this
        /// OwnedAccount with a new parent are:
        ///
        /// 1. Create a new CapabilityDelegator for the ChildAccount resource being created. We make a new one here because
        ///    CapabilityDelegator types are meant to be shared explicitly. Making one shared base-line of capabilities might
        ///    introduce unforseen behavior where an app accidentally shared something to all accounts when it only meant
        ///    to go to one of them. It is better for parent accounts to have less access than they might have anticipated,
        ///    than for a child to have given out access it did not intend to.
        /// 2. Create a new Capability<&{BorrowableAccount}> which has its own unique path for the parent to share this
        ///    child account with. We make new ones each time so that you can revoke access from one parent, without
        ///    destroying them all. A new link is made each time based on the address being shared to allow this
        ///    fine-grained control, but it is all managed by the OwnedAccount resource itself.
        /// 3. A new @ChildAccount resource is created and saved, using the CapabilityDelegator made in step one, and our
        ///    CapabilityFactory and CapabilityFilter Capabilities. Once saved, public and private links are configured for
        ///    the ChildAccount.
        /// 4. Publish the newly made private link to the designated parent's inbox for them to claim on their @Manager
        ///    resource.
        ///
        pub fun publishToParent(
            parentAddress: Address,
            factory: Capability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>,
            filter: Capability<&{CapabilityFilter.Filter}>
        ) {
            pre{
                self.parents[parentAddress] == nil: "Address pending or already redeemed as parent"
            }
            let capDelegatorIdentifier = HybridCustody.getCapabilityDelegatorIdentifier(parentAddress)

            let identifier = HybridCustody.getChildAccountIdentifier(parentAddress)
            let childAccountStorage = StoragePath(identifier: identifier)!

            let capDelegatorStorage = StoragePath(identifier: capDelegatorIdentifier)!
            let acct = self.borrowAccount()

            assert(acct.borrow<&AnyResource>(from: capDelegatorStorage) == nil, message: "conflicting resource found in capability delegator storage slot for parentAddress")
            assert(acct.borrow<&AnyResource>(from: childAccountStorage) == nil, message: "conflicting resource found in child account storage slot for parentAddress")

            if acct.borrow<&CapabilityDelegator.Delegator>(from: capDelegatorStorage) == nil {
                let delegator <- CapabilityDelegator.createDelegator()
                acct.save(<-delegator, to: capDelegatorStorage)
            }

            let capDelegatorPublic = PublicPath(identifier: capDelegatorIdentifier)!
            let capDelegatorPrivate = PrivatePath(identifier: capDelegatorIdentifier)!

            acct.link<&CapabilityDelegator.Delegator{CapabilityDelegator.GetterPublic}>(
                capDelegatorPublic,
                target: capDelegatorStorage
            )
            acct.link<&CapabilityDelegator.Delegator{CapabilityDelegator.GetterPublic, CapabilityDelegator.GetterPrivate}>(
                capDelegatorPrivate,
                target: capDelegatorStorage
            )
            let delegator = acct.getCapability<&CapabilityDelegator.Delegator{CapabilityDelegator.GetterPublic, CapabilityDelegator.GetterPrivate}>(
                capDelegatorPrivate
            )
            assert(delegator.check(), message: "failed to setup capability delegator for parent address")

            let borrowableCap = self.borrowAccount().getCapability<&{BorrowableAccount, OwnedAccountPublic, MetadataViews.Resolver}>(
                HybridCustody.OwnedAccountPrivatePath
            )
            let childAcct <- create ChildAccount(borrowableCap, factory, filter, delegator, parentAddress)

            let childAccountPrivatePath = PrivatePath(identifier: identifier)!

            acct.save(<-childAcct, to: childAccountStorage)
            acct.link<&ChildAccount{AccountPrivate, AccountPublic, MetadataViews.Resolver}>(childAccountPrivatePath, target: childAccountStorage)

            let delegatorCap = acct.getCapability<&ChildAccount{AccountPrivate, AccountPublic, MetadataViews.Resolver}>(childAccountPrivatePath)
            assert(delegatorCap.check(), message: "Delegator capability check failed")

            acct.inbox.publish(delegatorCap, name: identifier, recipient: parentAddress)
            self.parents[parentAddress] = false

            emit ChildAccountPublished(
                ownedAcctID: self.uuid,
                childAcctID: delegatorCap.borrow()!.uuid,
                capDelegatorID: delegator.borrow()!.uuid,
                factoryID: factory.borrow()!.uuid,
                filterID: filter.borrow()!.uuid,
                filterType: filter.borrow()!.getType(),
                child: self.getAddress(),
                pendingParent: parentAddress
            )
        }

        /// Checks the validity of the encapsulated account Capability
        ///
        pub fun check(): Bool {
            return self.acct.check()
        }

        /// Returns a reference to the encapsulated account object
        ///
        pub fun borrowAccount(): &AuthAccount {
            return self.acct.borrow()!
        }

        /// Returns the addresses of all associated parents pending and active
        ///
        pub fun getParentAddresses(): [Address] {
            return self.parents.keys
        }

        /// Returns whether the given address is a parent of this account
        ///
        pub fun isChildOf(_ addr: Address): Bool {
            return self.parents[addr] != nil
        }

        /// Returns nil if the given address is not a parent, false if the parent has not redeemed the child account
        /// yet, and true if they have
        ///
        pub fun getRedeemedStatus(addr: Address): Bool? {
            return self.parents[addr]
        }

        /// Returns associated parent addresses and their redeemed status
        ///
        pub fun getParentStatuses(): {Address: Bool} {
            return self.parents
        }

        /// Unlinks all paths configured when publishing an account, and destroy's the @ChildAccount resource
        /// configured for the provided parent address. Once done, the parent will not have any valid capabilities with
        /// which to access the child account.
        ///
        pub fun removeParent(parent: Address): Bool {
            if self.parents[parent] == nil {
                return false
            }
            let identifier = HybridCustody.getChildAccountIdentifier(parent)
            let capDelegatorIdentifier = HybridCustody.getCapabilityDelegatorIdentifier(parent)

            let acct = self.borrowAccount()
            acct.unlink(PrivatePath(identifier: identifier)!)
            acct.unlink(PublicPath(identifier: identifier)!)

            acct.unlink(PrivatePath(identifier: capDelegatorIdentifier)!)
            acct.unlink(PublicPath(identifier: capDelegatorIdentifier)!)

            destroy <- acct.load<@AnyResource>(from: StoragePath(identifier: identifier)!)
            destroy <- acct.load<@AnyResource>(from: StoragePath(identifier: capDelegatorIdentifier)!)

            self.parents.remove(key: parent)
            emit AccountUpdated(id: self.uuid, child: self.acct.address, parent: parent, active: false)

            let parentManager = getAccount(parent).getCapability<&Manager{ManagerPublic}>(HybridCustody.ManagerPublicPath)
            if parentManager.check() {
                parentManager.borrow()?.removeParentCallback(child: self.owner!.address)
            }

            return true
        }

        /// Returns the address of the encapsulated account
        ///
        pub fun getAddress(): Address {
            return self.acct.address
        }

        /// Returns the address of the pending owner if one is assigned. Pending owners are assigned when ownership has
        /// been granted, but has not yet been redeemed.
        ///
        pub fun getPendingOwner(): Address? {
            return self.pendingOwner
        }

        /// Returns the address of the current owner if one is assigned. Current owners are assigned when ownership has
        /// been redeemed.
        ///
        pub fun getOwner(): Address? {
            if !self.currentlyOwned {
                return nil
            }
            return self.acctOwner != nil ? self.acctOwner! : self.owner!.address
        }

        /// This method is used to transfer ownership of the child account to a new address.
        /// Ownership here means that one has unrestricted access on this OwnedAccount resource, giving them full
        /// access to the account.
        ///
        /// **NOTE:** The existence of this method does not imply that it is the only way to receive access to a
        /// OwnedAccount Capability or that only the labeled 'acctOwner' has said access. Rather, this is a convenient
        /// mechanism intended to easily transfer 'root' access on this account to another account and an attempt to
        /// minimize access vectors.
        ///
        pub fun giveOwnership(to: Address) {
            self.seal()

            let acct = self.borrowAccount()
            // Unlink existing owner's Capability if owner exists
            if self.acctOwner != nil {
                acct.unlink(
                    PrivatePath(identifier: HybridCustody.getOwnerIdentifier(self.acctOwner!))!
                )
            }
            // Link a Capability for the new owner, retrieve & publish
            let identifier =  HybridCustody.getOwnerIdentifier(to)
            let cap = acct.link<&{OwnedAccountPrivate, OwnedAccountPublic, MetadataViews.Resolver}>(
                    PrivatePath(identifier: identifier)!,
                    target: HybridCustody.OwnedAccountStoragePath
                ) ?? panic("failed to link child account capability")

            acct.inbox.publish(cap, name: identifier, recipient: to)

            self.pendingOwner = to
            self.currentlyOwned = true

            emit OwnershipGranted(ownedAcctID: self.uuid, child: self.acct.address, previousOwner: self.getOwner(), pendingOwner: to)
        }

        pub fun revokeAllKeys() {
            let acct = self.borrowAccount()

            // Revoke all keys
            acct.keys.forEach(fun (key: AccountKey): Bool {
                if !key.isRevoked {
                    acct.keys.revoke(keyIndex: key.keyIndex)
                }
                return true
            })
        }

        /// Cancels all existing AuthAccount capabilities, and creates a new one. The newly created capability will
        /// then be used by the child account for accessing its AuthAccount going forward.
        ///
        /// This is used when altering ownership of an account, and can also be used as a safeguard for anyone who
        /// assumes ownership of an account to guarantee that the previous owner doesn't maintain admin access to the
        /// account via other AuthAccount Capabilities.
        ///
        pub fun rotateAuthAccount() {
            let acct = self.borrowAccount()

            // Find all active AuthAccount capabilities so they can be removed after we make the new auth account cap
            let pathsToUnlink: [PrivatePath] = []
            acct.forEachPrivate(fun (path: PrivatePath, type: Type): Bool {
                if type.identifier == "Capability<&AuthAccount>" {
                    pathsToUnlink.append(path)
                }
                return true
            })

            // Link a new AuthAccount Capability
            // NOTE: This path cannot be sufficiently randomly generated, an app calling this function could build a
            // capability to this path before it is made, thus maintaining ownership despite making it look like they
            // gave it away. Until capability controllers, this method should not be fully trusted.
            let authAcctPath = "HybridCustodyRelinquished".concat(HybridCustody.account.address.toString()).concat(getCurrentBlock().height.toString())
            let acctCap = acct.linkAccount(PrivatePath(identifier: authAcctPath)!)!

            self.acct = acctCap
            let newAcct = self.acct.borrow()!

            // cleanup, remove all previously found paths. We had to do it in this order because we will be unlinking
            // the existing path which will cause a deference issue with the originally borrowed auth account
            for  p in pathsToUnlink {
                newAcct.unlink(p)
            }
        }

        /// Revokes all keys on an account, unlinks all currently active AuthAccount capabilities, then makes a new one
        /// and replaces the @OwnedAccount's underlying AuthAccount Capability with the new one to ensure that all parent
        /// accounts can still operate normally.
        /// Unless this method is executed via the giveOwnership function, this will leave an account **without** an owner.
        ///
        /// USE WITH EXTREME CAUTION.
        ///
        pub fun seal() {
            self.rotateAuthAccount()
            self.revokeAllKeys() // There needs to be a path to giving ownership that doesn't revoke keys
            emit AccountSealed(id: self.uuid, address: self.acct.address, parents: self.parents.keys)
            self.currentlyOwned = false
        }

        /// Retrieves a reference to the ChildAccount associated with the given parent account if one exists.
        ///
        pub fun borrowChildAccount(parent: Address): &ChildAccount? {
            let identifier = HybridCustody.getChildAccountIdentifier(parent)
            return self.borrowAccount().borrow<&ChildAccount>(from: StoragePath(identifier: identifier)!)
        }

        /// Sets the CapabilityFactory Manager for the specified parent in the associated ChildAccount.
        ///
        pub fun setCapabilityFactoryForParent(
            parent: Address,
            cap: Capability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>
        ) {
            let p = self.borrowChildAccount(parent: parent) ?? panic("could not find parent address")
            p.setCapabilityFactory(cap: cap)
        }

        /// Sets the Filter for the specified parent in the associated ChildAccount.
        ///
        pub fun setCapabilityFilterForParent(parent: Address, cap: Capability<&{CapabilityFilter.Filter}>) {
            let p = self.borrowChildAccount(parent: parent) ?? panic("could not find parent address")
            p.setCapabilityFilter(cap: cap)
        }

        /// Retrieves a reference to the Delegator associated with the given parent account if one exists.
        ///
        pub fun borrowCapabilityDelegatorForParent(parent: Address): &CapabilityDelegator.Delegator? {
            let identifier = HybridCustody.getCapabilityDelegatorIdentifier(parent)
            return self.borrowAccount().borrow<&CapabilityDelegator.Delegator>(from: StoragePath(identifier: identifier)!)
        }

        /// Adds the provided Capability to the Delegator associated with the given parent account.
        ///
        pub fun addCapabilityToDelegator(parent: Address, cap: Capability, isPublic: Bool) {
            let p = self.borrowChildAccount(parent: parent) ?? panic("could not find parent address")
            let delegator = self.borrowCapabilityDelegatorForParent(parent: parent)
                ?? panic("could not borrow capability delegator resource for parent address")
            delegator.addCapability(cap: cap, isPublic: isPublic)
        }

        /// Removes the provided Capability from the Delegator associated with the given parent account.
        ///
        pub fun removeCapabilityFromDelegator(parent: Address, cap: Capability) {
            let p = self.borrowChildAccount(parent: parent) ?? panic("could not find parent address")
            let delegator = self.borrowCapabilityDelegatorForParent(parent: parent)
                ?? panic("could not borrow capability delegator resource for parent address")
            delegator.removeCapability(cap: cap)
        }

        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return self.display
            }
            return nil
        }

        /// Sets this OwnedAccount's display to the one provided
        ///
        pub fun setDisplay(_ d: MetadataViews.Display) {
            self.display = d
        }

        init(
            _ acct: Capability<&AuthAccount>
        ) {
            self.acct = acct

            self.parents = {}
            self.pendingOwner = nil
            self.acctOwner = nil
            self.currentlyOwned = true

            self.data = {}
            self.resources <- {}
            self.display = nil
        }

        destroy () {
            destroy <- self.resources
        }
    }

    /// Utility function to get the path identifier for a parent address when interacting with a ChildAccount and its
    /// parents
    ///
    pub fun getChildAccountIdentifier(_ addr: Address): String {
        return "ChildAccount_".concat(addr.toString())
    }

    /// Utility function to get the path identifier for a parent address when interacting with a Delegator and its
    /// parents
    ///
    pub fun getCapabilityDelegatorIdentifier(_ addr: Address): String {
        return "ChildCapabilityDelegator_".concat(addr.toString())
    }

    /// Utility function to get the path identifier for a parent address when interacting with an OwnedAccount and its
    /// owners
    ///
    pub fun getOwnerIdentifier(_ addr: Address): String {
        return "HybridCustodyOwnedAccount_".concat(HybridCustody.account.address.toString()).concat(addr.toString())
    }

    /// Returns an OwnedAccount wrapping the provided AuthAccount Capability.
    ///
    pub fun createOwnedAccount(
        acct: Capability<&AuthAccount>
    ): @OwnedAccount {
        pre {
            acct.check(): "invalid auth account capability"
        }

        let ownedAcct <- create OwnedAccount(acct)
        emit CreatedOwnedAccount(id: ownedAcct.uuid, child: acct.borrow()!.address)
        return <- ownedAcct
    }

    /// Returns a new Manager with the provided Filter as default (if not nil).
    ///
    pub fun createManager(filter: Capability<&{CapabilityFilter.Filter}>?): @Manager {
        pre {
            filter == nil || filter!.check(): "Invalid CapabilityFilter Filter capability provided"
        }
        let manager <- create Manager(filter: filter)
        emit CreatedManager(id: manager.uuid)
        return <- manager
    }

    init() {
        let identifier = "HybridCustodyChild_".concat(self.account.address.toString())
        self.OwnedAccountStoragePath = StoragePath(identifier: identifier)!
        self.OwnedAccountPrivatePath = PrivatePath(identifier: identifier)!
        self.OwnedAccountPublicPath = PublicPath(identifier: identifier)!

        self.LinkedAccountPrivatePath = PrivatePath(identifier: "LinkedAccountPrivatePath_".concat(identifier))!
        self.BorrowableAccountPrivatePath = PrivatePath(identifier: "BorrowableAccountPrivatePath_".concat(identifier))!

        let managerIdentifier = "HybridCustodyManager_".concat(self.account.address.toString())
        self.ManagerStoragePath = StoragePath(identifier: managerIdentifier)!
        self.ManagerPublicPath = PublicPath(identifier: managerIdentifier)!
        self.ManagerPrivatePath = PrivatePath(identifier: managerIdentifier)!
    }
}
"
-------
"import Crypto
import NonFungibleToken from 0x1d7e57aa55817448
import FantastecNFT from 0x4bbff461fa8f6192

pub contract interface IFantastecPackNFT {
    /// StoragePath for Collection Resource
    pub let CollectionStoragePath: StoragePath

    /// PublicPath expected for deposit
    pub let CollectionPublicPath: PublicPath

    /// PublicPath for receiving NFT
    pub let CollectionIFantastecPackNFTPublicPath: PublicPath

    /// StoragePath for the NFT Operator Resource (issuer owns this)
    pub let OperatorStoragePath: StoragePath

    /// PrivatePath to share IOperator interfaces with Operator (typically with PDS account)
    pub let OperatorPrivPath: PrivatePath

    /// Burned
    /// Emitted when a NFT has been burned
    pub event Burned(id: UInt64 )

    pub resource interface IOperator {
        pub fun mint(packId: UInt64, productId: UInt64): @NFT
        pub fun addFantastecNFT(id: UInt64, nft: @FantastecNFT.NFT)
        pub fun open(id: UInt64, recipient: Address)
    }

    pub resource FantastecPackNFTOperator: IOperator {
        pub fun mint(packId: UInt64, productId: UInt64): @NFT
        pub fun addFantastecNFT(id: UInt64, nft: @FantastecNFT.NFT)
        pub fun open(id: UInt64, recipient: Address)
    }

    pub resource interface IFantastecPack {
        pub var ownedNFTs: @{UInt64: FantastecNFT.NFT}

        pub fun addFantastecNFT(nft: @FantastecNFT.NFT)
        pub fun open(recipient: Address)
    }

    pub resource NFT: NonFungibleToken.INFT {
        pub let id: UInt64
    }

    pub resource interface IFantastecPackNFTCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
    }
}"
-------
"import FantastecSwapDataProperties from 0x4bbff461fa8f6192

pub contract StoreManagerV3 {
    pub event SectionAdded(id: UInt64)
    pub event SectionRemoved(id: UInt64)

    pub event ProductAdded(id: UInt64)
    pub event ProductRemoved(id: UInt64)
    pub event ProductUpdated(id: UInt64)
    pub event ProductVolumeForSaleDecremented(id: UInt64, newVolumeForSale: UInt64)

    pub event SectionItemAdded(id: UInt64, sectionId: UInt64, productId: UInt64)
    pub event SectionItemRemoved(id: UInt64, sectionId: UInt64)

    pub let StoreManagerDataPath: StoragePath

    access(contract) var nextSectionItemId: UInt64
    access(contract) var nextSectionId: UInt64

    pub struct Product {
        pub let id: UInt64
        pub let description: String
        pub let level: FantastecSwapDataProperties.Level?
        pub let numberOfOptionalNfts: UInt64
        pub let numberOfPacks: UInt64
        pub let numberOfRegularNfts: UInt64
        pub let partner: FantastecSwapDataProperties.Partner?
        pub let season: FantastecSwapDataProperties.Season?
        pub let shortTitle: String
        pub let sku: FantastecSwapDataProperties.Sku?
        pub let sport: FantastecSwapDataProperties.Sport?
        pub let team: FantastecSwapDataProperties.Team?
        pub let themeType: String
        pub let title: String
        pub let releaseDate: UFix64
        pub var volumeForSale: UInt64
        pub let productImageUrl: String
        pub let productVideoUrl: String
        pub let backgroundImageSmallUrl: String
        pub let backgroundImageLargeUrl: String
        pub let featuredImageUrl: String
        pub let featuredVideoUrl: String

        init(
            id: UInt64,
            description: String,
            level: FantastecSwapDataProperties.Level?,
            numberOfOptionalNfts: UInt64,
            numberOfPacks: UInt64,
            numberOfRegularNfts: UInt64,
            partner: FantastecSwapDataProperties.Partner?,
            season: FantastecSwapDataProperties.Season?,
            shortTitle: String,
            sku: FantastecSwapDataProperties.Sku?,
            sport: FantastecSwapDataProperties.Sport?,
            team: FantastecSwapDataProperties.Team?,
            themeType: String,
            title: String,
            releaseDate: UFix64,
            volumeForSale: UInt64,
            productImageUrl: String,
            productVideoUrl: String,
            backgroundImageSmallUrl: String,
            backgroundImageLargeUrl: String,
            featuredImageUrl: String,
            featuredVideoUrl: String
        ) {
            self.id = id
            self.description = description
            self.level = level
            self.numberOfOptionalNfts = numberOfOptionalNfts
            self.numberOfPacks = numberOfPacks
            self.numberOfRegularNfts = numberOfRegularNfts
            self.partner = partner
            self.season = season
            self.shortTitle = shortTitle
            self.sku = sku
            self.sport = sport
            self.team = team
            self.themeType = themeType
            self.title = title
            self.releaseDate = releaseDate
            self.volumeForSale = volumeForSale
            self.productImageUrl = productImageUrl
            self.productVideoUrl = productVideoUrl
            self.backgroundImageSmallUrl = backgroundImageSmallUrl
            self.backgroundImageLargeUrl = backgroundImageLargeUrl
            self.featuredImageUrl = featuredImageUrl
            self.featuredVideoUrl = featuredVideoUrl
        }

        access(contract) fun decrementProductVolumeForSale(): UInt64 {
            if self.volumeForSale == 0 {
                panic("cannot decrement product for sale as volume for sale is zero - product ID: ".concat(self.id.toString()))
            }
            self.volumeForSale = self.volumeForSale - 1
            return self.volumeForSale
        }
    }

    pub struct SectionItem {
        pub let id: UInt64
        pub let position: UInt64
        pub var product: Product?
        pub let productId: UInt64

        init(id: UInt64, position: UInt64, productId: UInt64) {
            self.id = id
            self.position = position
            self.product = nil
            self.productId = productId
        }

        pub fun addProduct(product: Product) {
            self.product = product
        }
    }

    pub struct Section {
        pub let id: UInt64
        pub let sectionItems: {UInt64: SectionItem}
        pub let position: UInt64
        pub let title: String
        pub let type: String

        init(id: UInt64, position: UInt64, title: String, type: String) {
            self.id = id
            self.sectionItems = {}
            self.position = position
            self.title = title
            self.type = type
        }

        pub fun addSectionItem(position: UInt64, productId: UInt64): SectionItem {
            let id = StoreManagerV3.nextSectionItemId

            let sectionItem = SectionItem(id: id, position: position, productId: productId)
            self.sectionItems.insert(key: id, sectionItem)

            StoreManagerV3.nextSectionItemId = StoreManagerV3.nextSectionItemId + 1

            return sectionItem
        }

        pub fun addProductToSectionItem(sectionItemId: UInt64, product: Product): SectionItem? {
            if let sectionItem = self.sectionItems[sectionItemId] {
                sectionItem.addProduct(product: product)
                self.sectionItems[sectionItemId] = sectionItem
                return sectionItem
            }
            return nil
        }

        pub fun removeSectionItem(id: UInt64): SectionItem? {
            return self.sectionItems.remove(key: id)
        }
    }

    //-------------------------
    // Contract level functions
    //-------------------------
    pub fun getStore(): {UInt64: Section} {
        return self.getDataManager().getStore()
    }

    pub fun getProduct(productId: UInt64): Product? {
        return self.getDataManager().getProduct(productId: productId)
    }

    pub fun getProducts(productIds: [UInt64]): [Product] {
        return self.getDataManager().getProducts(productIds: productIds)
    }

    pub fun getAllProducts(): {UInt64: Product} {
        return self.getDataManager().getAllProducts()
    }

    pub resource DataManager {
        access(contract) let products: {UInt64: Product}
        access(contract) let store: {UInt64: Section}

        pub fun getStore(): {UInt64: Section} {
            let products = self.products
            let store = self.store
            let currentBlock = getCurrentBlock()

            store.forEachKey(fun (sectionId: UInt64): Bool {
                if let section = store[sectionId] {
                    section.sectionItems.forEachKey(fun (sectionItemId: UInt64): Bool {
                        if let sectionItem = section.sectionItems[sectionItemId] {
                            if let product = products[sectionItem.productId] {
                                if product.releaseDate <= currentBlock.timestamp {
                                    section.addProductToSectionItem(sectionItemId: sectionItem.id, product: product)
                                }
                            }
                        }

                        return true
                    })

                    store[sectionId] = section
                }

                return true
            })

            return store
        }

        pub fun addProduct(
            id: UInt64,
            description: String,
            level: FantastecSwapDataProperties.Level?,
            numberOfOptionalNfts: UInt64,
            numberOfPacks: UInt64,
            numberOfRegularNfts: UInt64,
            partner: FantastecSwapDataProperties.Partner?,
            season: FantastecSwapDataProperties.Season?,
            shortTitle: String,
            sku: FantastecSwapDataProperties.Sku?,
            sport: FantastecSwapDataProperties.Sport?,
            team: FantastecSwapDataProperties.Team?,
            themeType: String,
            title: String,
            releaseDate: UFix64,
            volumeForSale: UInt64,
            productImageUrl: String,
            productVideoUrl: String,
            backgroundImageSmallUrl: String,
            backgroundImageLargeUrl: String,
            featuredImageUrl: String,
            featuredVideoUrl: String
        ) {
            let product = Product(
                id: id,
                description: description,
                level: level,
                numberOfOptionalNfts: numberOfOptionalNfts,
                numberOfPacks: numberOfPacks,
                numberOfRegularNfts: numberOfRegularNfts,
                partner: partner,
                season: season,
                shortTitle: shortTitle,
                sku: sku,
                sport: sport,
                team: team,
                themeType: themeType,
                title: title,
                releaseDate: releaseDate,
                volumeForSale: volumeForSale,
                productImageUrl: productImageUrl,
                productVideoUrl: productVideoUrl,
                backgroundImageSmallUrl: backgroundImageSmallUrl,
                backgroundImageLargeUrl: backgroundImageLargeUrl,
                featuredImageUrl: featuredImageUrl,
                featuredVideoUrl: featuredVideoUrl
            )
            self.products[product.id] = product
            emit ProductAdded(id: product.id)
        }

        pub fun decrementProductVolumeForSale(productId: UInt64) {
            let newVolumeForSale = self.products[productId]?.decrementProductVolumeForSale()
            if (newVolumeForSale != nil) {
                emit ProductVolumeForSaleDecremented(id: productId, newVolumeForSale: newVolumeForSale!)
            }
        }

        pub fun getProduct(productId: UInt64): Product? {
            return self.products[productId]
        }

        pub fun getProducts(productIds: [UInt64]): [Product] {
            let products: [Product] = []
            for productId in productIds {
                let product = self.getProduct(productId: productId)
                if (product != nil) {
                    products.append(product!)
                }
            }
            return products
        }

        pub fun getAllProducts(): {UInt64: Product} {
            return self.products
        }

        pub fun removeProduct(productId: UInt64) {
            let store = self.store
            let sectionItemsToRemove: {UInt64: UInt64} = {}
            store.forEachKey(fun (sectionId: UInt64): Bool {
                if let section = store[sectionId] {
                    section.sectionItems.forEachKey(fun (sectionItemId: UInt64): Bool {
                        if let sectionItem = section.sectionItems[sectionItemId] {
                            if sectionItem.productId == productId {
                                sectionItemsToRemove[section.id] = sectionItem.id
                            }
                        }

                        return true
                    })
                }

                return true
            })

            // Remove all section items that are associated with a removed product
            for sectionId in sectionItemsToRemove.keys {
                let sectionItemId = sectionItemsToRemove[sectionId]
                self.removeSectionItemFromSection(sectionId: sectionId, sectionItemId: sectionItemId!)
                // if the section is now empty, remove it
                let updatedSection = store[sectionId]
                if (updatedSection!.sectionItems.length == 0) {
                    self.removeSection(sectionId: sectionId)
                }
            }

            self.products.remove(key: productId)
            emit ProductUpdated(id: productId)
        }

        pub fun addSection(position: UInt64, title: String, type: String): UInt64 {
            let id = StoreManagerV3.nextSectionId
            let section = Section(id: id, position: position, title: title, type: type)

            self.store[section.id] = section

            emit SectionAdded(id: id)
            StoreManagerV3.nextSectionId = StoreManagerV3.nextSectionId + 1

            return id
        }

        pub fun getSection(sectionId: UInt64): Section? {
            return self.store[sectionId]
        }

        pub fun removeSection(sectionId: UInt64) {
            self.store.remove(key: sectionId)
            emit SectionRemoved(id: sectionId)
        }

        pub fun addSectionItemToSection(sectionId: UInt64, position: UInt64, productId: UInt64): UInt64 {
            let sectionItem = self.store[sectionId]?.addSectionItem(position: position, productId: productId)
            sectionItem ?? panic("no section found with ID ".concat(sectionId.toString()))
            emit SectionItemAdded(id: sectionItem!.id, sectionId: sectionId, productId: productId)

            return sectionItem!.id
        }

        pub fun removeSectionItemFromSection(sectionId: UInt64, sectionItemId: UInt64) {
            let sectionItem = self.store[sectionId]?.removeSectionItem(id: sectionItemId)
            sectionItem ?? panic("no section found with ID ".concat(sectionId.toString()))
            emit SectionItemRemoved(id: sectionItemId, sectionId: sectionId)
        }

        init(_ products: {UInt64: Product}, _ sections: {UInt64: Section}) {
            self.products = products
            self.store = sections
        }
    }

    access(contract) fun setDataManager() {
        let oldDataManager <- self.account.load<@DataManager>(from: self.StoreManagerDataPath)
        var oldProducts = oldDataManager?.products ?? {}
        var oldStore = oldDataManager?.store ?? {}
        self.account.save<@DataManager>(<- create DataManager(oldProducts, oldStore), to: self.StoreManagerDataPath)
        destroy oldDataManager
    }

    access(contract) fun getDataManager(): &DataManager {
        return self.account.borrow<&DataManager>(from: self.StoreManagerDataPath)!
    }

    init() {
        self.nextSectionItemId = 1
        self.nextSectionId = 1

        self.StoreManagerDataPath = /storage/StoreManagerV3Data

        self.setDataManager()
    }
}
"
-------
"/**
# Contract: FantastecSwapDataProperties
# Description:

The purpose of this contract is to define the metadata objects that are properties of cards and collections
(as defined in the fantastecSwapDataV2 contract)
*/

pub contract FantastecSwapDataProperties {
  access(contract) var arrayTypes: [String]

  pub struct interface MetadataElement {
    pub let id: UInt64
  }

  pub struct ProductCollectionChance {
    pub let collectionId : UInt64
    pub let chance: UFix64
    init (
      _ collectionId: UInt64,
      _ chance: UFix64
    ) {
      self.collectionId = collectionId
      self.chance = chance
    }
  }

  pub struct ProductContent: MetadataElement {
    pub let id: UInt64;
    pub let content: [ProductCollectionChance];
    init (
      _ id: UInt64
    ){
      self.id = id;
      self.content = [];
    }
    pub fun add(_ collectionId: UInt64, _ chance: UFix64){
      let productCollectionChance = ProductCollectionChance(collectionId, chance)
      self.content.append(productCollectionChance)
    }
  }

  pub struct Media: MetadataElement {
    pub let id: UInt64;
    pub let url: String;
    pub let type: String;
    pub let mediaType: String;
    pub let ipfsCid: String;
    pub let hash: String;

    init(
      _ id: UInt64,
      _ url: String,
      _ type: String,
      _ mediaType: String,
      _ ipfsCid: String,
      _ hash: String,
    ){
      self.id = id;
      self.url = url;
      self.type = type;
      self.mediaType = mediaType;
      self.ipfsCid = ipfsCid;
      self.hash = hash;
    }
  }

  pub struct Social: MetadataElement {
    pub let id: UInt64;
    pub let url: String;
    pub let type: String;

    init(
      _ id: UInt64,
      _ url: String,
      _ type: String,
    ){
      self.id = id;
      self.url = url;
      self.type = type;
    }
  }

  pub struct Partner: MetadataElement {
    pub let id: UInt64;
    pub let name: String;

    init(
      _ id: UInt64,
      _ name: String,
    ){
      self.id = id;
      self.name = name;
    }
  }

  pub struct Team: MetadataElement {
    pub let id: UInt64;
    pub let name: String;
    pub let gender: String;

    init(
      _ id: UInt64,
      _ name: String,
      _ gender: String,
    ){
      self.id = id;
      self.name = name;
      self.gender = gender;
    }
  }

  pub struct Sport: MetadataElement {
    pub let id: UInt64;
    pub let name: String;

    init(
      _ id: UInt64,
      _ name: String,
    ){
      self.id = id;
      self.name = name;
    }
  }

  pub struct Sku: MetadataElement {
    pub let id: UInt64;
    pub let name: String;

    init(
      _ id: UInt64,
      _ name: String,
    ){
      self.id = id;
      self.name = name;
    }
  }

  pub struct Season: MetadataElement {
    pub let id: UInt64;
    pub let name: String;
    pub let startDate: String;
    pub let endDate: String;

    init(
      _ id: UInt64,
      _ name: String,
      _ startDate: String,
      _ endDate: String,
    ){
      self.id = id;
      self.name = name;
      self.startDate = startDate;
      self.endDate = endDate;
    }
  }

  pub struct Level: MetadataElement {
    pub let id: UInt64;
    pub let name: String;
    pub let scarcity: String;

    init(
      _ id: UInt64,
      _ name: String,
      _ scarcity: String,
    ){
      self.id = id;
      self.name = name;
      self.scarcity = scarcity;
    }
  }

  pub struct Player: MetadataElement {
    pub let id: UInt64;
    pub let name: String;
    pub let gender: String;
    pub let position: String?;
    pub let shirtNumber: String?;
    init(
      _ id: UInt64,
      _ name: String,
      _ gender: String,
      _ position: String?,
      _ shirtNumber: String?,
    ){
      self.id = id;
      self.name = name;
      self.gender = gender;
      self.position = position;
      self.shirtNumber = shirtNumber;
    }
  }

  pub struct Royalty: MetadataElement {
    pub let id: UInt64;
    pub let address: Address;
    pub let percentage: UFix64;
    init(
      _ id: UInt64,
      _ address: Address,
      _ percentage: UFix64,
    ){
      pre {
        percentage <= 100.0: "percentage cannot be higher than 100"
      }
      self.id = id;
      self.address = address;
      self.percentage = percentage;
    }
  }

  pub struct License: MetadataElement {
    pub let id: UInt64;
    pub let name: String;
    pub let url: String;
    pub let dateAwarded: String;
    init(
      _ id: UInt64,
      _ name: String,
      _ url: String,
      _ dateAwarded: String,
    ){
      self.id = id;
      self.name = name;
      self.url = url;
      self.dateAwarded = dateAwarded;
    }
  }

  pub struct CardId: MetadataElement {
    pub let id: UInt64;
    init(
      _ id: UInt64,
    ){
      self.id = id;
    }
  }

  pub struct MintVolume: MetadataElement {
    pub let id: UInt64;
    pub let value: UInt64;
    init(
      _ id: UInt64,
      _ value: UInt64,
    ){
      self.id = id;
      self.value = value;
    }
  }

  pub struct RedeemInfo: MetadataElement {
    pub let id: UInt64;
    pub let retailerName: String;
    pub let retailerPinHash: String;
    pub let retailerAddress: Address;
    pub let validFrom: UFix64?;
    pub let validTo: UFix64?;
    init(
      _ id: UInt64,
      _ retailerName: String,
      _ retailerPinHash: String,
      _ retailerAddress: Address,
      _ validFrom: UFix64?,
      _ validTo: UFix64?,
    ){
      self.id = id;
      self.retailerName = retailerName;
      self.retailerPinHash = retailerPinHash;
      self.retailerAddress = retailerAddress;
      self.validFrom = validFrom;
      self.validTo = validTo;
    }
  }

  pub struct RedeemInfoV2: MetadataElement {
    pub let id: UInt64;
    pub let retailerName: String;
    pub let retailerPinHash: String;
    pub let retailerAddress: Address;
    pub let validFrom: UFix64?;
    pub let validTo: UFix64?;
    pub let type: String;
    pub let t_and_cs: String;
    pub let description: String;

    init(
      _ id: UInt64,
      _ retailerName: String,
      _ retailerPinHash: String,
      _ retailerAddress: Address,
      _ validFrom: UFix64?,
      _ validTo: UFix64?,
      _ type: String,
      _ t_and_cs: String,
      _ description: String,
    ){
      self.id = id;
      self.retailerName = retailerName;
      self.retailerPinHash = retailerPinHash;
      self.retailerAddress = retailerAddress;
      self.validFrom = validFrom;
      self.validTo = validTo;
      self.type = type;
      self.t_and_cs = t_and_cs;
      self.description = description;
    }
  }

  pub struct NewsFeed: MetadataElement {
    pub let id: UInt64
    pub let title: String
    pub let publishedDate: UFix64
    pub let buttonUrl: String
    pub let buttonText: String
    init(
      _ id: UInt64,
      _ title: String,
      _ publishedDate: UFix64,
      _ buttonUrl: String,
      _ buttonText: String,
    ){
      self.id = id
      self.title = title
      self.publishedDate = publishedDate
      self.buttonUrl = buttonUrl
      self.buttonText = buttonText
    }
  }

    pub struct BlockedUsers: MetadataElement {
    pub let id: UInt64;
    pub let blockedAddresses: [Address];
    init(
      _ id: UInt64,
      _ blockedAddresses: [Address]
    ){
      self.id = id;
      self.blockedAddresses = blockedAddresses;
    }
  }

  pub fun IsArrayMetadataType(_ type: String): Bool {
    return self.arrayTypes.contains(type);
  }

  pub fun parseUInt64(_ string: String?): UInt64? {
    if (string == nil) {
      return nil
    }
    return UInt64.fromString(string!)
  }

  pub fun parseUFix64(_ string: String?): UFix64? {
    if (string == nil) {
      return nil
    }
    return UFix64.fromString(string!)
  }

  pub fun parseAddress(_ string: String?): Address? {
    if (string == nil) {
      return nil
    }
    var addressString = string!
    if (addressString.slice(from: 0, upTo: 2) == "0x") {
      addressString = addressString.slice(from: 2, upTo: addressString.length)
    }
    let bytes = addressString.decodeHex()
    let numberOfBytes: UInt64 = UInt64(bytes.length)
    var i: UInt64 = 0
    var addressAsInt: UInt64 = 0
    var multiplier: UInt64 = 1
    while i < numberOfBytes {
      let index: UInt64 = numberOfBytes - 1 - i
      let intPart = UInt64(bytes[index]) * multiplier
      addressAsInt = addressAsInt + intPart
      i = i + 1
      multiplier = multiplier.saturatingMultiply(256)
    }
    let address = Address(addressAsInt)
    return address
  }

  pub fun addToMetadata(
    _ type: String,
    _ metadataArray: [AnyStruct{MetadataElement}],
    _ metadata: AnyStruct{MetadataElement},
  ): [AnyStruct{MetadataElement}] {
    if (self.IsArrayMetadataType(type)) {
      var updatedMetadataArray = self.removeMetadataElementById(metadataArray, metadata.id)
      updatedMetadataArray.append(metadata)
      return updatedMetadataArray
    } else {
      if metadataArray.length > 0 {
        metadataArray.removeFirst()
      }
      metadataArray.append(metadata)
      return metadataArray
    }
  }

  pub fun removeFromMetadata(
    _ type: String,
    _ metadataArray: [AnyStruct{MetadataElement}],
    _ id: UInt64?,
  ): [AnyStruct{MetadataElement}] {
    if (self.IsArrayMetadataType(type)) {
      let updatedMetadataArray = self.removeMetadataElementById(metadataArray, id!)
      return updatedMetadataArray
    } else {
      let metadataExists = metadataArray.length > 0
      if (metadataExists) {
        metadataArray.removeFirst()
      }
      return metadataArray
    }
  }

  pub fun removeMetadataElementById(
    _ array: [AnyStruct{MetadataElement}],
    _ id: UInt64,
  ): [AnyStruct{MetadataElement}] {
    if (array == nil) {
      return []
    }
    var indexToRemove: Int = -1
    for index, element in array {
      if (element.id == id) {
        indexToRemove = index
        break
      }
    }
    if (indexToRemove > -1) {
      array.remove(at: indexToRemove)
    }
    return array
  }

  init() {
    self.arrayTypes = ["media", "socials", "royalties", "licenses", "cardIds"]
  }
}"
-------
"/*
*
*   An NFT contract for redeeming/minting tokens by series
*
*
*/

import NonFungibleToken from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import MetadataViews from 0x1d7e57aa55817448

pub contract HWGarageTokenV2: NonFungibleToken {

    /*
    *   NonFungibleToken Standard Events
    */
    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)

    /*
    *   Project Events
    */
    pub event Mint(id: UInt64)
    pub event Burn(id: UInt64)
    pub event DepositEvent(
        uuid: UInt64
        , id: UInt64
        , seriesId: UInt64
        , editionId: UInt64
        , to: Address?
        )

    /*
    *   Named Paths
    */
    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath

    /*
    *   NonFungibleToken Standard Fields
    */
    pub var totalSupply: UInt64

    /*
    *   Token State Variables
    */
    access(account) var name: String
    access(account) var currentTokenEditionIdByPackSeriesId: {UInt64: UInt64}

    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        pub let id: UInt64
        // the pack series this Token came from
        pub let packSeriesID: UInt64
        pub let tokenEditionID: UInt64
        pub let metadata: {String: String}

        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.Traits>(),
                Type<MetadataViews.Rarity>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    var ipfsImage = MetadataViews.IPFSFile(
                        cid: self.metadata["thumbnailCID"] ?? "ThumbnailCID not set"
                        , path: self.metadata["thumbnailPath"] ?? ""
                        )
                    return MetadataViews.Display(
                        name: self.metadata["tokenName"] ?? "Hot Wheels Garage Token Series ".concat(self.packSeriesID.toString()).concat(" #").concat(self.tokenEditionID.toString()),
                        description: self.metadata["tokenDescription"] ?? "Digital Redeemable Token Collectable from Hot Wheels Garage" ,
                        thumbnail: ipfsImage
                    )

                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL(
                    url: self.metadata["url"] ?? ""
                    )

                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: HWGarageTokenV2.CollectionStoragePath,
                        publicPath: HWGarageTokenV2.CollectionPublicPath,
                        providedPath: /private/HWGarageTokenV2Collection,
                        publicCollection: Type<&HWGarageTokenV2.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, HWGarageTokenV2.TokenCollectionPublic, MetadataViews.ResolverCollection}>(),
                        publicLinkedType: Type<&HWGarageTokenV2.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, HWGarageTokenV2.TokenCollectionPublic, MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&HWGarageTokenV2.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, HWGarageTokenV2.TokenCollectionPublic, MetadataViews.ResolverCollection}>(),
                        createEmptyCollection: fun(): @NonFungibleToken.Collection {return <- HWGarageTokenV2.createEmptyCollection()}
                    )

                case Type<MetadataViews.NFTCollectionDisplay>():
                    let externalURL = MetadataViews.ExternalURL(
                        url: ""
                        )

                    let squareImage = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: ""
                            ),
                        mediaType: "image/png")

                    let bannerImage = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: ""
                            ),
                        mediaType: "image/png")

                    let socialMap: {String: MetadataViews.ExternalURL} = {
                        "facebook": MetadataViews.ExternalURL(
                            url: "https://www.facebook.com/hotwheels"
                            ),
                        "instagram": MetadataViews.ExternalURL(
                            url: "https://www.instagram.com/hotwheelsofficial/"
                            ),
                        "twitter": MetadataViews.ExternalURL(
                            url: "https://twitter.com/Hot_Wheels"
                            ),
                        "discord": MetadataViews.ExternalURL(
                            url: "https://discord.gg/mattel"
                            )
                    }
                    return MetadataViews.NFTCollectionDisplay(
                        name: self.metadata["collectionName"] ?? "Hot Wheels Garage Redeemable Token",
                        description: self.metadata["collectionDescription"] ?? "Digital Collectable from Hot Wheels Garage",
                        externalURL: externalURL,
                        squareImage: squareImage,
                        bannerImage: bannerImage,
                        socials: socialMap
                        )
                case Type<MetadataViews.Traits>():
                    let exludedTraits = [
                                "thumbnailPath"
                                , "thumbnailCID"
                                , "collectionName"
                                , "collectionDescription"
                                , "tokenDescription"
                                , "url"
                            ]
                    let traitsView = MetadataViews.dictToTraits(
                        dict: self.metadata,
                        excludedNames: exludedTraits
                    )
                    return traitsView
                case Type<MetadataViews.Royalties>():
                    let flowReciever = getAccount(0xf86e2f015cd692be).getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)
                return MetadataViews.Royalties([
                    MetadataViews.Royalty(
                        recipient:flowReciever
                        , cut: 0.05
                        , description: "Mattel 5% Royalty")
                    ]
                )
                case Type<MetadataViews.Rarity>():
                    let rarityDescription = self.metadata["rarity"]
                    return MetadataViews.Rarity(
                    score: nil
                    , max: nil
                    ,description: rarityDescription
                )
            }
            return nil
        }

        init(
            id: UInt64
            , packSeriesID: UInt64
            , tokenEditionID: UInt64
            , metadata: {String: String}
            ) {
            self.id = id
            self.packSeriesID = packSeriesID
            self.tokenEditionID = tokenEditionID
            self.metadata = metadata
            emit Mint(id: self.id)
        }

        destroy() {
            emit Burn(id: self.id)
        }
    }

    pub resource interface TokenCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowToken(id: UInt64): &HWGarageTokenV2.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow HWGarageTokenV2Pack reference: The ID of the returned reference is incorrect"
            }
        }
    }


    pub resource Collection: TokenCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init() {
            self.ownedNFTs <- {}
        }


        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(
                id: token.id,
                from: self.owner?.address
                )

            return <-token
        }


        pub fun deposit(
            token: @NonFungibleToken.NFT
            ) {
            let HWGarageTokenV2 <- token as! @HWGarageTokenV2.NFT
            let HWGarageTokenV2UUID = HWGarageTokenV2.uuid
            let HWGarageTokenV2SeriesID: UInt64 = HWGarageTokenV2.packSeriesID
            let HWGarageTokenV2ID: UInt64 = HWGarageTokenV2.id
            let HWGarageTokenV2tokenEditionID: UInt64 = HWGarageTokenV2.tokenEditionID

            self.ownedNFTs[HWGarageTokenV2ID] <-! HWGarageTokenV2

            emit Deposit(
                id: HWGarageTokenV2ID,
                to: self.owner?.address
                )
            emit DepositEvent(
                uuid: HWGarageTokenV2UUID,
                id: HWGarageTokenV2ID,
                seriesId: HWGarageTokenV2SeriesID,
                editionId: HWGarageTokenV2tokenEditionID,
                to: self.owner?.address
                )
        }


        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }


        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }


        pub fun borrowToken(id: UInt64): &HWGarageTokenV2.NFT? {
            if self.ownedNFTs[id] != nil {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &HWGarageTokenV2.NFT
            } else {
                return nil
            }
        }


        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let token = nft as! &HWGarageTokenV2.NFT
            return token as &AnyResource{MetadataViews.Resolver}
        }


        destroy () {
            destroy self.ownedNFTs
        }
    }


    /*
    *   Admin Functions
    */
    access(account) fun addNewSeries(newTokenSeriesID: UInt64){
        self.currentTokenEditionIdByPackSeriesId.insert(key: newTokenSeriesID, 0)
    }


    access(account) fun updateCurrentEditionIdByPackSeriesId(packSeriesID: UInt64, tokenSeriesEdition: UInt64){
        self.currentTokenEditionIdByPackSeriesId[packSeriesID] = tokenSeriesEdition
    }


    access(account) fun mint(
        nftID: UInt64
        , packSeriesID: UInt64
        , metadata: {String: String}
        ): @NonFungibleToken.NFT {

        self.totalSupply = self.getTotalSupply() + 1

        self.currentTokenEditionIdByPackSeriesId[packSeriesID] = self.currentTokenEditionIdByPackSeriesId[packSeriesID]! + 1

        return <- create NFT(
            id: nftID
            , packSeriesID: packSeriesID
            , tokenEditionID: self.currentTokenEditionIdByPackSeriesId[packSeriesID]!
            , metadata: metadata
            )
    }


    /*
    *   Public Functions
    */
    pub fun getTotalSupply(): UInt64 {
        return self.totalSupply
    }


    pub fun getName(): String {
        return self.name
    }


    /*
    *   NonFungibleToken Standard Functions
    */
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }


    // initialize contract state variables
    init(){
        self.name = "Hot Wheels Garage Token v2"
        self.totalSupply = 0
        self.currentTokenEditionIdByPackSeriesId = {1 : 0}

        // set the named paths
        self.CollectionStoragePath = /storage/HWGarageTokenV2Collection
        self.CollectionPublicPath = /public/HWGarageTokenV2Collection

        emit ContractInitialized()
    }

}
 "
-------
"import CapsuleNFT from 0xecb0408a4ab2329d

pub contract EventTickets: CapsuleNFT {
    pub var totalMinted: UInt64

    pub event ContractInitialized()
    pub event CollectionCreated()
    pub event CollectionDestroyed(length: Int)
    pub event Withdraw(id: String, size: UInt64, from: Address?)
    pub event Deposit(id: String, size: UInt64, to: Address?)
    pub event Minted(id: String)
    pub event TicketMinted(
        id: String,
        ticketId: UInt64,
        ticketCategory: String,
        eventName: String,
        retailPrice: UFix64,
        mintedTime: String,
        rarity: String,
        edition: String,
        mediaUri: String,
        resourceId: UInt64
    )
    pub event TicketDestroyed(id: String)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath

    /// NFT:
    /// An EventTicket as an NFT
    pub resource NFT: CapsuleNFT.INFT {
        pub let id: String
        pub let ticketId: UInt64
        pub let ticketCategory: String
        pub let eventName: String
        pub let retailPrice: UFix64
        pub let mintedTime: String
        pub let rarity: String
        pub let edition: String
        pub let mediaUri: String

        init(
            id: String,
            ticketId: UInt64,
            ticketCategory: String,
            eventName: String,
            retailPrice: UFix64,
            mintedTime: String,
            rarity: String,
            edition: String,
            mediaUri: String,
        ) {
            self.id = id
            self.ticketId = ticketId
            self.ticketCategory = ticketCategory
            self.eventName = eventName
            self.retailPrice = retailPrice
            self.mintedTime = mintedTime
            self.rarity = rarity
            self.edition = edition
            self.mediaUri = mediaUri
        }

        destroy() {
            emit TicketDestroyed(id: self.id)
        }
    }

    /// EventTicketsCollectionPublic:
    /// This is the interface that users can cast their EventTicket Collection as,
    /// in order to allow others to deposit an EventTicket into their Collection.
    /// It also allows for reading the details of an EventTicket in the Collection.
    pub resource interface EventTicketsCollectionPublic {
        pub fun deposit(token: @CapsuleNFT.NFT)
        pub fun getIDs(): [String]
        pub fun borrowNFT(id: String): &CapsuleNFT.NFT
        pub fun borrowTicket(id: String): &EventTickets.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow EventTicket reference: the ID of the returned reference is incorrect"
            }
        }
    }

    /// Collection:
    /// A collection of EventTicket NFTs owned by an account
    pub resource Collection: EventTicketsCollectionPublic, CapsuleNFT.Provider, CapsuleNFT.Receiver, CapsuleNFT.CollectionPublic {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with a `String` ID field
        pub var ownedNFTs: @{String: CapsuleNFT.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        /// Removes an NFT from the collection and moves it to the caller
        pub fun withdraw(id: String): @CapsuleNFT.NFT {
            let address: Address? = self.owner?.address
            let account: PublicAccount = getAccount(address!)
            let startUsed: UInt64 = account.storageUsed

            let token: @CapsuleNFT.NFT <- self.ownedNFTs.remove(key: id)
                ?? panic("Missing EventTicket NFT!")

            let endUsed: UInt64 = account.storageUsed
            let delta: UInt64 = startUsed - endUsed
            emit Withdraw(id: token.id, size: delta, from: address)

            return <-token
        }

        /// Takes an NFT, adds it to the Collections dictionary, and adds the ID to the id array
        pub fun deposit(token: @CapsuleNFT.NFT) {
            let address: Address? = self.owner?.address
            let account: PublicAccount = getAccount(address!)
            let startUsed: UInt64 = account.storageUsed

            let token: @EventTickets.NFT <- token as! @EventTickets.NFT
            let id: String = token.id
            // Add the new token to the dictionary which removes the old one
            let oldToken: @CapsuleNFT.NFT? <- self.ownedNFTs[id] <- token

            let endUsed: UInt64 = account.storageUsed
            let delta: UInt64 = endUsed - startUsed
            emit Deposit(id: id, size: delta, to: address)

            destroy oldToken
        }

        /// Returns an array of the IDs that are in the collection
        pub fun getIDs(): [String] {
            return self.ownedNFTs.keys
        }

        /// Gets a reference to an NFT in the Collection so that the caller can read its metadata and call its methods
        pub fun borrowNFT(id: String): &CapsuleNFT.NFT {
            return (&self.ownedNFTs[id] as &CapsuleNFT.NFT?)!
        }

        // Safe way to borrow a reference to an NFT that does not panic
        // Also now part of the CapsuleNFT.PublicCollection interface
        //
        // Parameters: id: The ID of the NFT to get the reference for
        //
        // Returns: An optional reference to the desired NFT, will be nil if the passed ID does not exist
        pub fun borrowNFTSafe(id: String): &CapsuleNFT.NFT? {
            if let nftRef = &self.ownedNFTs[id] as &CapsuleNFT.NFT? {
                return nftRef
            }
            return nil
        }

        pub fun borrowTicket(id: String): &EventTickets.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorised reference to allow downcasting
                let ref = (&self.ownedNFTs[id] as auth &CapsuleNFT.NFT?)!
                return ref as! &EventTickets.NFT
            } else {
                return nil
            }
        }

        // If a transaction destroys the Collection resource,
        // All the NFTs contained within are also destroyed.
        //
        destroy() {
            let collectionLength = self.ownedNFTs.length
            destroy self.ownedNFTs
            emit CollectionDestroyed(length: collectionLength)
        }
    }

    /// Public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(): @CapsuleNFT.Collection {
        emit CollectionCreated()
        return <- create Collection()
    }

    /// Minter:
    /// Resource that an Admin (or similar) would own to be able to mint new EventTicket NFTs.
    pub resource NFTMinter {
        /// Mints a new EventTicket NFT with a new ID and deposits it in the recipients Collection.
        pub fun mintTicket(
            recipient: &{CapsuleNFT.CollectionPublic},
            id: String,
            ticketId: UInt64,
            ticketCategory: String,
            eventName: String,
            retailPrice: UFix64,
            mintedTime: String,
            rarity: String,
            edition: String,
            mediaUri: String,
        ) {
            // Create a new EventTicket
            var ticket: @EventTickets.NFT <- create NFT(
                id: id,
                ticketId: ticketId,
                ticketCategory: ticketCategory,
                eventName: eventName,
                retailPrice: retailPrice,
                mintedTime: mintedTime,
                rarity: rarity,
                edition: edition,
                mediaUri: mediaUri,
            )
            // Emit Events
            // emit Minted(id: id)
            emit TicketMinted(
                id: id,
                ticketId: ticketId,
                ticketCategory: ticketCategory,
                eventName: eventName,
                retailPrice: retailPrice,
                mintedTime: mintedTime,
                rarity: rarity,
                edition: edition,
                mediaUri: mediaUri,
                resourceId: ticket.uuid
            )
            // Increment the total of minted EventTickets
            EventTickets.totalMinted = EventTickets.totalMinted + 1

            // Deposit it in the recipient's account using their reference
            recipient.deposit(token: <-ticket)
        }
    }

    init() {
        // Initialize the total minted number of EventTickets
        self.totalMinted = 0

        // Set the named paths
        self.CollectionStoragePath = /storage/CapsuleTicketsCollection
        self.CollectionPublicPath = /public/CapsuleTicketsCollection
        self.MinterStoragePath = /storage/CapsuleTicketsMinter

        // Create a Collection resource and save it to storage
        let collection: @EventTickets.Collection <- create Collection()
        self.account.save(<-collection, to: self.CollectionStoragePath)

        // Create a public capability for the Collection
        self.account.link<&EventTickets.Collection{CapsuleNFT.CollectionPublic, EventTickets.EventTicketsCollectionPublic}>
            (self.CollectionPublicPath, target: self.CollectionStoragePath)

        // Create a Minter resource and save it to storage
        let minter: @EventTickets.NFTMinter <- create NFTMinter()
        self.account.save(<-minter, to: self.MinterStoragePath)

        emit ContractInitialized()
    }
}
 "
-------
"import CapsuleNFT from 0xecb0408a4ab2329d

pub contract Collectibles: CapsuleNFT {
    pub var totalMinted: UInt64

    pub event ContractInitialized()
    pub event CollectionCreated()
    pub event CollectionDestroyed(length: Int)
    pub event Withdraw(id: String, size: UInt64, from: Address?)
    pub event Deposit(id: String, size: UInt64, to: Address?)
    pub event Minted(id: String)
    pub event CollectibleMinted(
        id: String,
        name: String,
        collection: String,
        type: String,
        rarity: String,
        edition: String,
        mediaUri: String,
        mintedTime: String,
        resourceId: UInt64
    )
    pub event CollectibleDestroyed(id: String)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath

    /// NFT:
    /// A Collectible as an NFT
    pub resource NFT: CapsuleNFT.INFT {
        pub let id: String
        pub let name: String
        pub let collection: String
        pub let type: String
        pub let rarity: String
        pub let edition: String
        pub let mediaUri: String
        pub let mintedTime: String

        init(
            id: String,
            name: String,
            collection: String,
            type: String,
            rarity: String,
            edition: String,
            mediaUri: String,
            mintedTime: String
        ) {
            self.id = id
            self.name = name
            self.collection = collection
            self.type = type
            self.rarity = rarity
            self.edition = edition
            self.mediaUri = mediaUri
            self.mintedTime = mintedTime
        }

        destroy() {
            emit CollectibleDestroyed(id: self.id)
        }
    }

    /// CollectiblesCollectionPublic:
    /// This is the interface that users can cast their Collectible Collection as,
    /// in order to allow others to deposit a Collectible into their Collection.
    /// It also allows for reading the details of an Collectible in the Collection.
    pub resource interface CollectiblesCollectionPublic {
        pub fun deposit(token: @CapsuleNFT.NFT)
        pub fun getIDs(): [String]
        pub fun borrowNFT(id: String): &CapsuleNFT.NFT
        pub fun borrowCollectible(id: String): &Collectibles.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow Collectible reference: the ID of the returned reference is incorrect"
            }
        }
    }

    /// Collection:
    /// A collection of Collectibles NFTs owned by an account
    pub resource Collection: CollectiblesCollectionPublic, CapsuleNFT.Provider, CapsuleNFT.Receiver, CapsuleNFT.CollectionPublic {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with a `String` ID field
        pub var ownedNFTs: @{String: CapsuleNFT.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        /// Removes an NFT from the collection and moves it to the caller
        pub fun withdraw(id: String): @CapsuleNFT.NFT {
            let address: Address? = self.owner?.address
            let account: PublicAccount = getAccount(address!)
            let startUsed: UInt64 = account.storageUsed

            let token: @CapsuleNFT.NFT <- self.ownedNFTs.remove(key: id)
                ?? panic("missing NFT")

            let endUsed: UInt64 = account.storageUsed
            let delta: UInt64 = endUsed - startUsed
            emit Withdraw(id: token.id, size: delta, from: address)

            return <-token
        }

        /// Takes an NFT, adds it to the Collection dictionary and adds the ID to the id array
        pub fun deposit(token: @CapsuleNFT.NFT) {
            let address: Address? = self.owner?.address
            let account: PublicAccount = getAccount(address!)
            let startUsed: UInt64 = account.storageUsed

            let token: @Collectibles.NFT <- token as! @Collectibles.NFT
            let id: String = token.id
            // Add the new token to the dictionary which removes the old one
            let oldToken: @CapsuleNFT.NFT? <- self.ownedNFTs[id] <- token

            let endUsed: UInt64 = account.storageUsed
            let delta: UInt64 = endUsed - startUsed
            emit Deposit(id: id, size: delta, to: address)

            destroy oldToken
        }

        /// Returns an array of the IDs that are in the collection
        pub fun getIDs(): [String] {
            return self.ownedNFTs.keys
        }

        /// Gets a reference to an NFT in the collection so that the caller can read its metadata and call its methods
        pub fun borrowNFT(id: String): &CapsuleNFT.NFT {
            return (&self.ownedNFTs[id] as &CapsuleNFT.NFT?)!
        }

        /// Gets a reference to a Collectible in the Collection
        pub fun borrowCollectible(id: String): &Collectibles.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorised reference to allow downcasting
                let ref: auth &CapsuleNFT.NFT = (&self.ownedNFTs[id] as auth &CapsuleNFT.NFT?)!
                return ref as! &Collectibles.NFT
            } else {
                return nil
            }
        }

        destroy() {
            let collectionLength = self.ownedNFTs.length
            destroy self.ownedNFTs
            emit CollectionDestroyed(length: collectionLength)
        }
    }

    /// Public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(): @CapsuleNFT.Collection {
        emit CollectionCreated()
        return <- create Collection()
    }

    /// Resource that an admin or similar would own to be able to mint new NFTs
    pub resource NFTMinter {
        /// Mints a new Collectible.
        /// Deposits it in the recipients Collection using their PublicCollection reference.
        pub fun mintCollectible(
            recipientCollection: &{CapsuleNFT.CollectionPublic},
            id: String,
            name: String,
            collection: String,
            type: String,
            rarity: String,
            edition: String,
            mediaUri: String,
            mintedTime: String,
        ) {
            // Create a new Collectible NFT
            var collectible: @Collectibles.NFT <- create NFT(
                id: id,
                name: name,
                collection: collection,
                type: type,
                rarity: rarity,
                edition: edition,
                mediaUri: mediaUri,
                mintedTime: mintedTime
            )
            // Emit Events
            emit CollectibleMinted(
                id: id,
                name: name,
                collection: collection,
                type: type,
                rarity: rarity,
                edition: edition,
                mediaUri: mediaUri,
                mintedTime: mintedTime,
                resourceId: collectible.uuid
            )
            // Increment the total of minted Collectibles
            Collectibles.totalMinted = Collectibles.totalMinted + 1

            // Deposit it in the recipient's account using their reference
            recipientCollection.deposit(token: <-collectible)
        }
    }

    init() {
        // Initialize the total of minted Collectibles
        self.totalMinted = 0

        // Set the named paths
        self.CollectionStoragePath = /storage/CapsuleCollectiblesCollection
        self.CollectionPublicPath = /public/CapsuleCollectiblesCollection
        self.MinterStoragePath = /storage/CapsuleCollectiblesMinter

        // Create a Collection resource and save it to storage
        let collection: @Collectibles.Collection <- create Collection()
        self.account.save(<-collection, to: self.CollectionStoragePath)

        // Create a public capability for the collection
        self.account.link<&Collectibles.Collection{CapsuleNFT.CollectionPublic, Collectibles.CollectiblesCollectionPublic}>
            (self.CollectionPublicPath, target: self.CollectionStoragePath)

        // Create a Minter resource and save it to storage
        let minter: @Collectibles.NFTMinter <- create NFTMinter()
        self.account.save(<-minter, to: self.MinterStoragePath)

        emit ContractInitialized()
    }
}
 "
-------
"/*
NiftoryMetadataViewsResolvers

Below are implementations of resolvers that will be common amongst Niftory NFTs.
However, NFTs do not have to be limited to these by any means. Please see
details about the actual Metadata themselves from the MetadataViews contract

In order to create a custom resolver, follow one of the examples below. The NFT
contract will pass an AnyStruct when calling resolveView. The custom resolver
will receive this AnyStruct and can cast it to whatever the NFT contract
provided the AnyStruct as.

*/

import MetadataViews from 0x1d7e57aa55817448

import MetadataViewsManager from 0x7ec1f607f0872a9e

import NiftoryNonFungibleToken from 0x7ec1f607f0872a9e

pub contract NiftoryMetadataViewsResolvers {

  // ========================================================================
  // Constants
  // ========================================================================

  // All URIs are expected to have one of these prefixes.
  pub fun DEFAULT_ALLOWED_URI_PREFIXES(): [String] {
    return [
      "https://",
      "http://",
      "ipfs://"
    ]
  }

  // ========================================================================
  // Royalties
  // ========================================================================

  pub struct RoyaltiesResolver: MetadataViewsManager.Resolver {

    // Royalties
    pub let type: Type

    // Stored straightforwardly
    pub let royalties: MetadataViews.Royalties

    // Royalties are stored directly as a value in this resource
    pub fun resolve(_ nftRef: AnyStruct): AnyStruct? {
      return self.royalties
    }

    init(royalties: MetadataViews.Royalties) {
      self.type = Type<MetadataViews.Royalties>()
      self.royalties = royalties
    }
  }

  // ========================================================================
  // NFTCollectionData
  // ========================================================================

  pub struct NFTCollectionDataResolver: MetadataViewsManager.Resolver {

    // NFTCollectionData
    pub let type: Type

    // All Niftory NFTs should have an NFTPublic interface, which points to
    // its contracts NFTCollectionData info
    pub fun resolve(_ nftRef: AnyStruct): AnyStruct? {
      let nft = nftRef as! &{NiftoryNonFungibleToken.NFTPublic}
      return nft.contract().getNFTCollectionData()
    }

    init() {
      self.type = Type<MetadataViews.NFTCollectionData>()
    }
  }

  // ========================================================================
  // Display
  // ========================================================================

  pub struct DisplayResolver: MetadataViewsManager.Resolver {

    // Display
    pub let type: Type

    // name
    pub let nameField: String
    pub let defaultName: String

    // description
    pub let descriptionField: String
    pub let defaultDescription: String

    // image
    pub let imageField: String
    pub let defaultImagePrefix: String
    pub let defaultImage: String

    // Niftory NFTs are assumed to have metadata implemented as a
    // {String: String} map. In order to create a Display, we need to know
    // the Display's name, description, and URI pointing to the Display media
    // image. In this case, the resolver will try to fill those fields in
    // based on the provided field keys, or use a default value if that key
    // does not exist in the NFT metadata.
    pub fun resolve(_ nftRef: AnyStruct): AnyStruct? {
      let metadata = NiftoryMetadataViewsResolvers._extractMetadata(
        nftRef: nftRef
      )

      // name
      let name = metadata[self.nameField] ?? self.defaultName

      // description
      let description = metadata[self.descriptionField]
        ?? self.defaultDescription

      // image
      let url = NiftoryMetadataViewsResolvers._prefixUri(
        allowedPrefixes:
          NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
        default: self.defaultImagePrefix,
        uri: metadata[self.imageField] ?? self.defaultImage
      )

      return MetadataViews.Display(
        name: name,
        description: description,
        thumbnail: MetadataViews.HTTPFile(url: url)
      )
    }

    init(
      nameField: String,
      defaultName: String,
      descriptionField: String,
      defaultDescription: String,
      imageField: String,
      defaultImagePrefix: String,
      defaultImage: String,
    ) {
      self.type = Type<MetadataViews.Display>()
      self.nameField = nameField
      self.defaultName = defaultName
      self.descriptionField = descriptionField
      self.defaultDescription = defaultDescription
      self.imageField = imageField
      self.defaultImagePrefix = defaultImagePrefix
      self.defaultImage = defaultImage
    }
  }

  // IPFS URLs used for displays will be converted to URLs using IPFS gateways
  pub struct DisplayResolverWithIpfsGateway: MetadataViewsManager.Resolver {

    // Display
    pub let type: Type

    // name
    pub let nameFields: [String]
    pub let defaultName: String

    // description
    pub let descriptionFields: [String]
    pub let defaultDescription: String

    // image
    pub let imageFields: [String]
    pub let defaultImagePrefix: String
    pub let defaultImage: String

    // ipfs gateway
    pub let ipfsGateway: String

    // Niftory NFTs are assumed to have metadata implemented as a
    // {String: String} map. In order to create a Display, we need to know
    // the Display's name, description, and URI pointing to the Display media
    // image. In this case, the resolver will try to fill those fields in
    // based on the provided field keys, or use a default value if that key
    // does not exist in the NFT metadata.
    pub fun resolve(_ nftRef: AnyStruct): AnyStruct? {
      let metadata = NiftoryMetadataViewsResolvers._extractMetadata(
        nftRef: nftRef
      )

      // name
      let name = NiftoryMetadataViewsResolvers._firstValueOrElse(
        metadata: &metadata as &{String: String},
        fields: self.nameFields,
        default: self.defaultName
      )

      // description
      let description = NiftoryMetadataViewsResolvers._firstValueOrElse(
        metadata: &metadata as &{String: String},
        fields: self.descriptionFields,
        default: self.defaultDescription
      )

      // image
      let uri = NiftoryMetadataViewsResolvers._firstValueOrElse(
        metadata: &metadata as &{String: String},
        fields: self.imageFields,
        default: self.defaultImage
      )
      let url = NiftoryMetadataViewsResolvers._useIpfsGateway(
        ipfsGateway: self.ipfsGateway,
        uri: NiftoryMetadataViewsResolvers._prefixUri(
          allowedPrefixes:
            NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
          default: self.defaultImagePrefix,
          uri: uri
        )
      )

      return MetadataViews.Display(
        name: name,
        description: description,
        thumbnail: MetadataViews.HTTPFile(url: url)
      )
    }

    init(
      nameFields: [String],
      defaultName: String,
      descriptionFields: [String],
      defaultDescription: String,
      imageFields: [String],
      defaultImagePrefix: String,
      defaultImage: String,
      ipfsGateway: String
    ) {
      self.type = Type<MetadataViews.Display>()
      self.nameFields = nameFields
      self.defaultName = defaultName
      self.descriptionFields = descriptionFields
      self.defaultDescription = defaultDescription
      self.imageFields = imageFields
      self.defaultImagePrefix = defaultImagePrefix
      self.defaultImage = defaultImage
      self.ipfsGateway = ipfsGateway
    }
  }

  // ========================================================================
  // NFTCollectionDisplay
  // ========================================================================

  pub struct NFTCollectionDisplayResolver: MetadataViewsManager.Resolver {

    // NFTCollectionDisplay
    pub let type: Type

    // name
    pub let nameField: String
    pub let defaultName: String

    // description
    pub let descriptionField: String
    pub let defaultDescription: String

    // external URL
    pub let externalUrlField: String
    pub let defaultExternalURLPrefix: String
    pub let defaultExternalURL: String

    // square image
    pub let squareImageField: String
    pub let defaultSquareImagePrefix: String
    pub let defaultSquareImage: String
    pub let squareImageMediaTypeField: String
    pub let defaultSquareImageMediaType: String

    // banner image
    pub let bannerImageField: String
    pub let defaultBannerImagePrefix: String
    pub let defaultBannerImage: String
    pub let bannerImageMediaTypeField: String
    pub let defaultBannerImageMediaType: String

    // socials
    pub let socialsFields: [String]

    // Niftory NFTs are assumed to have metadata implemented as a
    // {String: String} map. In order to create a Display, we need to know
    // the Display's title, description, and URI pointing to the Display media
    // image. In this case, the resolver will try to fill those fields in
    // based on the provided field keys, or use a default value if that key
    // does not exist in the NFT metadata.
    pub fun resolve(_ nftRef: AnyStruct): AnyStruct? {
      let metadata = NiftoryMetadataViewsResolvers._extractMetadata(
        nftRef: nftRef
      )

      // name
      let name = metadata[self.nameField] ?? self.defaultName

      // description
      let description = metadata[self.descriptionField]
        ?? self.defaultDescription

      // external URL
      let externalURL = MetadataViews.ExternalURL(url:
        NiftoryMetadataViewsResolvers._prefixUri(
          allowedPrefixes:
            NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
          default: self.defaultExternalURLPrefix,
          uri: metadata[self.externalUrlField] ?? self.defaultExternalURL
        )
      )

      // square image
      let squareImageURL = NiftoryMetadataViewsResolvers._prefixUri(
        allowedPrefixes:
          NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
        default: self.defaultSquareImagePrefix,
        uri: metadata[self.squareImageField] ?? self.defaultSquareImage
      )
      let squareImageMediaType = metadata[self.squareImageMediaTypeField]
        ?? self.defaultSquareImageMediaType
      let squareImage = MetadataViews.Media(
        file: MetadataViews.HTTPFile(
          url: squareImageURL
        ),
        mediaType: squareImageMediaType
      )

      // banner image
      let bannerImageURL = NiftoryMetadataViewsResolvers._prefixUri(
        allowedPrefixes:
          NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
        default: self.defaultBannerImagePrefix,
        uri: metadata[self.bannerImageField] ?? self.defaultBannerImage
      )
      let bannerImageMediaType = metadata[self.bannerImageMediaTypeField]
        ?? self.defaultBannerImageMediaType
      let bannerImage = MetadataViews.Media(
        file: MetadataViews.HTTPFile(
          url: bannerImageURL
        ),
        mediaType: bannerImageMediaType
      )

      // socials
      let socials = NiftoryMetadataViewsResolvers._parseUrls(
        metadata: metadata,
        socialsFields: self.socialsFields
      )

      return MetadataViews.NFTCollectionDisplay(
        name: name,
        description: description,
        externalURL: externalURL,
        squareImage: squareImage,
        bannerImage: bannerImage,
        socials: socials
      )
    }

    init(
      nameField: String,
      defaultName: String,
      descriptionField: String,
      defaultDescription: String,
      externalUrlField: String,
      defaultExternalURLPrefix: String,
      defaultExternalURL: String,
      squareImageField: String,
      defaultSquareImagePrefix: String,
      defaultSquareImage: String,
      squareImageMediaTypeField: String,
      defaultSquareImageMediaType: String,
      bannerImageField: String,
      defaultBannerImagePrefix: String,
      defaultBannerImage: String,
      bannerImageMediaTypeField: String,
      defaultBannerImageMediaType: String,
      socialsFields: [String],
    ) {
      self.type = Type<MetadataViews.NFTCollectionDisplay>()
      self.nameField = nameField
      self.defaultName = defaultName
      self.descriptionField = descriptionField
      self.defaultDescription = defaultDescription
      self.externalUrlField = externalUrlField
      self.defaultExternalURLPrefix = defaultExternalURLPrefix
      self.defaultExternalURL = defaultExternalURL
      self.squareImageField = squareImageField
      self.defaultSquareImagePrefix = defaultSquareImagePrefix
      self.defaultSquareImage = defaultSquareImage
      self.squareImageMediaTypeField = squareImageMediaTypeField
      self.defaultSquareImageMediaType = defaultSquareImageMediaType
      self.bannerImageField = bannerImageField
      self.defaultBannerImagePrefix = defaultBannerImagePrefix
      self.defaultBannerImage = defaultBannerImage
      self.bannerImageMediaTypeField = bannerImageMediaTypeField
      self.defaultBannerImageMediaType = defaultBannerImageMediaType
      self.socialsFields = socialsFields
    }
  }

  // IPFS URLs used for displays will be converted to URLs using IPFS gateways
  pub struct NFTCollectionDisplayResolverWithIpfsGateway:
    MetadataViewsManager.Resolver
  {

    // NFTCollectionDisplay
    pub let type: Type

    // name
    pub let nameFields: [String]
    pub let defaultName: String

    // description
    pub let descriptionFields: [String]
    pub let defaultDescription: String

    // external URL
    pub let externalUrlFields: [String]
    pub let defaultExternalURLPrefix: String
    pub let defaultExternalURL: String

    // square image
    pub let squareImageFields: [String]
    pub let defaultSquareImagePrefix: String
    pub let defaultSquareImage: String
    pub let squareImageMediaTypeField: String
    pub let defaultSquareImageMediaType: String

    // banner image
    pub let bannerImageFields: [String]
    pub let defaultBannerImagePrefix: String
    pub let defaultBannerImage: String
    pub let bannerImageMediaTypeField: String
    pub let defaultBannerImageMediaType: String

    // socials
    pub let socialsFields: [String]

    // ipfs gateway
    pub let ipfsGateway: String

    // Niftory NFTs are assumed to have metadata implemented as a
    // {String: String} map. In order to create a Display, we need to know
    // the Display's title, description, and URI pointing to the Display media
    // image. In this case, the resolver will try to fill those fields in
    // based on the provided field keys, or use a default value if that key
    // does not exist in the NFT metadata.
    pub fun resolve(_ nftRef: AnyStruct): AnyStruct? {
      let metadata = NiftoryMetadataViewsResolvers._extractMetadata(
        nftRef: nftRef
      )

      // name
      let name = NiftoryMetadataViewsResolvers._firstValueOrElse(
        metadata: &metadata as &{String: String},
        fields: self.nameFields,
        default: self.defaultName
      )

      // description
      let description = NiftoryMetadataViewsResolvers._firstValueOrElse(
        metadata: &metadata as &{String: String},
        fields: self.descriptionFields,
        default: self.defaultDescription
      )

      // external URL
      let externalUri = NiftoryMetadataViewsResolvers._firstValueOrElse(
        metadata: &metadata as &{String: String},
        fields: self.externalUrlFields,
        default: self.defaultExternalURL
      )
      let externalURL = MetadataViews.ExternalURL(url:
        NiftoryMetadataViewsResolvers._prefixUri(
          allowedPrefixes:
            NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
          default: self.defaultExternalURLPrefix,
          uri: externalUri
        )
      )

      // square image
      let squareImageUri = NiftoryMetadataViewsResolvers._firstValueOrElse(
        metadata: &metadata as &{String: String},
        fields: self.squareImageFields,
        default: self.defaultSquareImage
      )
      let squareImageURL = NiftoryMetadataViewsResolvers._useIpfsGateway(
        ipfsGateway: self.ipfsGateway,
        uri: NiftoryMetadataViewsResolvers._prefixUri(
          allowedPrefixes:
            NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
          default: self.defaultSquareImagePrefix,
          uri: squareImageUri
        )
      )
      let squareImageMediaType = metadata[self.squareImageMediaTypeField]
        ?? self.defaultSquareImageMediaType
      let squareImage = MetadataViews.Media(
        file: MetadataViews.HTTPFile(
          url: squareImageURL
        ),
        mediaType: squareImageMediaType
      )

      // banner image
      let bannerImageUri = NiftoryMetadataViewsResolvers._firstValueOrElse(
        metadata: &metadata as &{String: String},
        fields: self.bannerImageFields,
        default: self.defaultBannerImage
      )
      let bannerImageURL = NiftoryMetadataViewsResolvers._useIpfsGateway(
        ipfsGateway: self.ipfsGateway,
        uri: NiftoryMetadataViewsResolvers._prefixUri(
          allowedPrefixes:
            NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
          default: self.defaultBannerImagePrefix,
          uri: bannerImageUri
        )
      )
      let bannerImageMediaType = metadata[self.bannerImageMediaTypeField]
        ?? self.defaultBannerImageMediaType
      let bannerImage = MetadataViews.Media(
        file: MetadataViews.HTTPFile(
          url: bannerImageURL
        ),
        mediaType: bannerImageMediaType
      )

      // socials
      let socials = NiftoryMetadataViewsResolvers._parseUrls(
        metadata: metadata,
        socialsFields: self.socialsFields
      )

      return MetadataViews.NFTCollectionDisplay(
        name: name,
        description: description,
        externalURL: externalURL,
        squareImage: squareImage,
        bannerImage: bannerImage,
        socials: socials
      )
    }

    init(
      nameFields: [String],
      defaultName: String,
      descriptionFields: [String],
      defaultDescription: String,
      externalUrlFields: [String],
      defaultExternalURLPrefix: String,
      defaultExternalURL: String,
      squareImageFields: [String],
      defaultSquareImagePrefix: String,
      defaultSquareImage: String,
      squareImageMediaTypeField: String,
      defaultSquareImageMediaType: String,
      bannerImageFields: [String],
      defaultBannerImagePrefix: String,
      defaultBannerImage: String,
      bannerImageMediaTypeField: String,
      defaultBannerImageMediaType: String,
      socialsFields: [String],
      ipfsGateway: String
    ) {
      self.type = Type<MetadataViews.NFTCollectionDisplay>()
      self.nameFields = nameFields
      self.defaultName = defaultName
      self.descriptionFields = descriptionFields
      self.defaultDescription = defaultDescription
      self.externalUrlFields = externalUrlFields
      self.defaultExternalURLPrefix = defaultExternalURLPrefix
      self.defaultExternalURL = defaultExternalURL
      self.squareImageFields = squareImageFields
      self.defaultSquareImagePrefix = defaultSquareImagePrefix
      self.defaultSquareImage = defaultSquareImage
      self.squareImageMediaTypeField = squareImageMediaTypeField
      self.defaultSquareImageMediaType = defaultSquareImageMediaType
      self.bannerImageFields = bannerImageFields
      self.defaultBannerImagePrefix = defaultBannerImagePrefix
      self.defaultBannerImage = defaultBannerImage
      self.bannerImageMediaTypeField = bannerImageMediaTypeField
      self.defaultBannerImageMediaType = defaultBannerImageMediaType
      self.socialsFields = socialsFields
      self.ipfsGateway = ipfsGateway
    }
  }

  // ========================================================================
  // ExternalURL
  // ========================================================================

  pub struct ExternalURLResolver: MetadataViewsManager.Resolver {

    // ExternalURL
    pub let type: Type

    // url
    pub let field: String
    pub let defaultPrefix: String
    pub let defaultURL: String

    // Niftory NFTs are assumed to have metadata implemented as a
    // {String: String} map. In order to create an ExternalURL, we need to know
    // the Display's name, description, and URI pointing to the Display media
    // image. In this case, the resolver will try to fill those fields in
    // based on the provided field keys, or use a default value if that key
    // does not exist in the NFT metadata.
    pub fun resolve(_ nftRef: AnyStruct): AnyStruct? {
      let metadata = NiftoryMetadataViewsResolvers._extractMetadata(
        nftRef: nftRef
      )

      // url
      let url = NiftoryMetadataViewsResolvers._prefixUri(
        allowedPrefixes:
          NiftoryMetadataViewsResolvers.DEFAULT_ALLOWED_URI_PREFIXES(),
        default: self.defaultPrefix,
        uri: metadata[self.field] ?? self.defaultURL
      )

      return MetadataViews.ExternalURL(url: url)
    }

    init(
      field: String,
      defaultPrefix: String,
      defaultURL: String,
    ) {
      self.type = Type<MetadataViews.ExternalURL>()
      self.field = field
      self.defaultPrefix = defaultPrefix
      self.defaultURL = defaultURL
    }
  }

  // ========================================================================
  // Traits
  // ========================================================================

  pub struct SimpleTraitAccessor {
    pub let traitField:  String
    pub let rarityField: String?
    init(traitField: String, rarityField: String?) {
      self.traitField = traitField
      self.rarityField = rarityField
    }
  }

  pub struct TraitsResolver: MetadataViewsManager.Resolver {

    // Traits
    pub let type: Type

    // trait accessors
    pub let accessors: [SimpleTraitAccessor]

    // A very simple Traits implementation that assumes the NFT metadata is
    // implemented as a {String: String} map. Along with a trait key, it's
    // possible to provide a rarity key.
    pub fun resolve(_ nftRef: AnyStruct): AnyStruct? {
      let metadata = NiftoryMetadataViewsResolvers._extractMetadata(
        nftRef: nftRef
      )

      return NiftoryMetadataViewsResolvers._parseTraits(
        metadata: metadata,
        accessors: self.accessors
      )
    }

    init(
      accessors: [SimpleTraitAccessor],
    ) {
      self.type = Type<MetadataViews.Traits>()
      self.accessors = accessors
    }
  }

  // ========================================================================
  // Serial
  // ========================================================================

  pub struct SerialResolver: MetadataViewsManager.Resolver {

    // Serial
    pub let type: Type

    // Niftory NFTs are assumed to have metadata implemented as a
    // {String: String} map. In order to create a Serial, we need to know
    // the Display's name, description, and URI pointing to the Display media
    // image. In this case, the resolver will try to fill those fields in
    // based on the provided field keys, or use a default value if that key
    // does not exist in the NFT metadata.
    pub fun resolve(_ nftRef: AnyStruct): AnyStruct? {
      let nft = nftRef as! &{NiftoryNonFungibleToken.NFTPublic}

      // serial
      let serial = nft.serial

      return MetadataViews.Serial(serial: serial)
    }

    init() {
      self.type = Type<MetadataViews.Serial>()
    }
  }

  // ========================================================================
  // Contract functions
  // ========================================================================

  access(self) fun _extractMetadata(nftRef: AnyStruct): {String: String} {
    let nft = nftRef as! &{NiftoryNonFungibleToken.NFTPublic}
    var metadata: {String: String} = {}

    let contractMetadata = nft.contract().metadata() as! {String: String}?
    if contractMetadata != nil {
      metadata = contractMetadata!
    }

    let setMetadata = nft.set().metadata().get() as! {String: String}
    for key in setMetadata.keys {
      metadata[key] = setMetadata[key]!
    }

    let nftMetadata = nft.metadata().get() as! {String: String}
    for key in nftMetadata.keys {
      metadata[key] = nftMetadata[key]!
    }

    return metadata
  }

  // Check if a string begins with a substring
  access(self) fun _startsWith(string: String, substring: String): Bool {
    return substring.length <= string.length
      && string.slice(from: 0, upTo: substring.length) == substring
  }

  // Prefix a uri with a default prefix if it does not start with any of the
  // allowed prefixes
  pub fun _prefixUri(
    allowedPrefixes: [String],
    default: String,
    uri: String
  ): String {
    for allowedPrefix in allowedPrefixes {
      if self._startsWith(string: uri, substring: allowedPrefix) {
        return uri
      }
    }
    return default.concat(uri)
  }

  // Use the provided IPFS gateway if the uri starts with the IPFS prefix
  pub fun _useIpfsGateway(
    ipfsGateway: String,
    uri: String
  ): String {
    if self._startsWith(string: uri, substring: "ipfs://") {
      return ipfsGateway.concat(uri.slice(from: 7, upTo: uri.length))
    }
    return uri
  }

  // socialsFields can contain metadata keys for URL based socials. This
  // returns a dictionary of {String: MetadataViews.ExternalURL} where the
  // key is the social field name and the value is the ExternalURL struct
  // constructed from the corresponding metadata value
  access(self) fun _parseUrls(
    metadata: {String: String},
    socialsFields: [String],
  ): {String: MetadataViews.ExternalURL} {
    let socials: {String: MetadataViews.ExternalURL} = {}
    for field in socialsFields {
      if metadata.containsKey(field) {
        socials[field] = MetadataViews.ExternalURL(url: metadata[field]!)
      }
    }
    return socials
  }

  // The full spec of a Trait can be viewed in MetadataViews. In this case,
  // a "trait" is assumed to be a simple string field that describes the NFT.
  // The "rarity" is optional and also another string field. Given these fields
  // and a {String: String} metadata dictionary, this function will form proper
  // Trait structs based on the values from the corresponding fields in the
  // metadata
  access(self) fun _parseTraits(
    metadata: {String: String},
    accessors: [SimpleTraitAccessor],
  ): MetadataViews.Traits {
    let traits: [MetadataViews.Trait] = []
    for accessor in accessors {
      let traitField = accessor.traitField
      let rarityField = accessor.rarityField
      if metadata.containsKey(traitField) {
        let trait = metadata[traitField]!
        var rarity: MetadataViews.Rarity? = nil
        if rarityField != nil && metadata.containsKey(rarityField!) {
          rarity = MetadataViews.Rarity(
            score: nil,
            max: nil,
            description: metadata[rarityField!]!
          )
        }
        traits.append(MetadataViews.Trait(
          name: traitField,
          value: trait,
          displayType: nil,
          rarity: rarity,
        ))
      }
    }
    return MetadataViews.Traits(traits: traits)
  }

  // Return the first value from metadata that exists given a list of possible
  // fields and a default if none is found
  access(self) fun _firstValueOrElse(
    metadata: &{String: String},
    fields: [String],
    default: String,
  ): String {
    for field in fields {
      if let value = metadata[field] {
        if value != "" {
          return value
        }
      }
    }
    return default
  }
}
"
-------
"import CapabilityFactory from 0xd8a7e05a7ac670c0
import NonFungibleToken from 0x1d7e57aa55817448

pub contract NFTProviderAndCollectionFactory {
    pub struct Factory: CapabilityFactory.Factory {
        pub fun getCapability(acct: &AuthAccount, path: CapabilityPath): Capability {
            return acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(path)
        }
    }
}"
-------
"pub contract PrimalRaveVariantMintLimits {

    // -----------------------------------------------------------------------
    // Paths
    // -----------------------------------------------------------------------

    pub let PrimalRaveVariantMintLimitsAdminStoragePath: StoragePath

    // -----------------------------------------------------------------------
    // Contract Events
    // -----------------------------------------------------------------------

    pub event AdminSetVariantMintLimit(
        variantId: UInt64,
        variantMintLimit: UInt64
    )

    pub event AdminResourceCreated(
        uuid: UInt64,
        adminAddress: Address
    )

    pub event AddressVariantMintsIncremented(
        address: Address,
        variantId: UInt64,
        oldValue: UInt64?,
        newValue: UInt64
    )

    // -----------------------------------------------------------------------
    // Contract State
    // -----------------------------------------------------------------------

    // The maximum number of mints an address can mint for a given variant
    // If maxMints is nil, unlimited mints allowed for variant
    // {variantId: maxMints}
    access(contract) var variantMintLimits: {UInt64: UInt64}

    // The number of mints an address has minted for a given variant
    // {userAddress: {variantId: mints}}
    access(contract) var addressVariantMints: {Address: {UInt64: UInt64}}

    // The total number of variants
    access(contract) var numberOfVariants: UInt64

    // -----------------------------------------------------------------------
    // Admin Resource
    // -----------------------------------------------------------------------

    pub resource Admin {
        pub fun setVariantMintLimits(variantMintLimitsDict: {UInt64: UInt64}) {

            let keys = variantMintLimitsDict.keys
            let values = variantMintLimitsDict.values

            while keys.length > 0 {
                let key = keys.removeFirst()
                let value = values.removeFirst()
                PrimalRaveVariantMintLimits.variantMintLimits[key] = value

                emit AdminSetVariantMintLimit(
                    variantId: key,
                    variantMintLimit: value
                )
            }
        }

        pub fun setVariantMintsForAddress(address: Address, variantId: UInt64, numberOfMints: UInt64) {
            if let variantMintsByAddress: {UInt64: UInt64} = PrimalRaveVariantMintLimits.addressVariantMints[address] {
                variantMintsByAddress[variantId] = numberOfMints
                PrimalRaveVariantMintLimits.addressVariantMints[address] = variantMintsByAddress
            } else {
                // If variantMintsByAddress is nil, then address hasn't minted any variants yet, create a new entry
                PrimalRaveVariantMintLimits.addressVariantMints[address] = {variantId: numberOfMints}
                return
            }
        }

        pub fun setNumberOfVariants(numberOfVariants: UInt64) {
            PrimalRaveVariantMintLimits.numberOfVariants = numberOfVariants
        }

        init(adminAddress: Address) {

            emit AdminResourceCreated(
                uuid: self.uuid,
                adminAddress: adminAddress
            )
        }
    }

    // -----------------------------------------------------------------------
    // Helpers
    // -----------------------------------------------------------------------

    // Checks if an address can mint a variant
    pub fun checkAddressCanMintVariant(address: Address, variantId: UInt64): Bool {
        pre {
            variantId <= self.numberOfVariants: "Variant ID must be less than or equal to the number of variants"
        }
        let variantMintLimit: UInt64? = self.variantMintLimits[variantId]
        if variantMintLimit == nil {
            return true
        }

        let variantMintsByAddress: {UInt64: UInt64}? = self.addressVariantMints[address]
        if variantMintsByAddress == nil {
            return true
        }

        if let variantMintsByAddress: {UInt64: UInt64} = variantMintsByAddress {
            let mints = variantMintsByAddress[variantId]
            if mints == nil {
                return true
            }
            return mints! < variantMintLimit!
        }

        return false
    }

    // Increments the number of mints an address has minted for a given variant
    pub fun incrementVariantMintsForAddress(address: Address, variantId: UInt64) {
        if let variantMintsByAddress: {UInt64: UInt64} = self.addressVariantMints[address] {
            // Get the number of mints for the variant
            let mints = variantMintsByAddress[variantId]
            // If the address hasn't minted the variant yet, create a new entry
            if mints == nil {
                variantMintsByAddress[variantId] = 1
                self.addressVariantMints[address] = variantMintsByAddress
            } else {
                // Increment the number of mints for the variant
                let newMintsValue = mints! + 1
                variantMintsByAddress[variantId] = newMintsValue
                self.addressVariantMints[address] = variantMintsByAddress
            }
        } else {
            // If variantMintsByAddress is nil, then address hasn't minted any variants yet, create a new entry
            self.addressVariantMints[address] = {variantId: 1}
            return
        }
    }

    // -----------------------------------------------------------------------
    // Public Utility Functions
    // -----------------------------------------------------------------------

    pub fun getVariantMintLimits(): {UInt64: UInt64} {
        return self.variantMintLimits
    }

    pub fun getAllVariantMints(): {Address: {UInt64: UInt64}} {
        return self.addressVariantMints
    }

    pub fun getAllVariantMintsForAddress(address: Address): {UInt64: UInt64}? {
        return self.addressVariantMints[address]
    }

    pub fun getVariantMintsForAddress(address: Address, variantId: UInt64): {UInt64: UInt64}? {
        if let variantMintsByAddress: {UInt64: UInt64} = self.addressVariantMints[address] {
            let mints = variantMintsByAddress[variantId]
            if mints == nil {
                return nil
            }
            return {variantId: mints!}
        }
        return nil
    }

    // returns {variantId: {mints | limit: value}}
    pub fun getVariantMintsAndLimitsForAddress(address: Address): {UInt64: {String: UInt64?}} {

        var i: UInt64 = 0
        let ret: {UInt64: {String: UInt64?}} = {}
        while i < self.numberOfVariants {
            i = i + 1
            // Set the mint limit for the variant
            let variantMintLimits = self.variantMintLimits
            let limit = variantMintLimits[i]
            ret[i] = {
                "limit": limit
            }

            // Get variant mints dictionary
            let variantMintsForAddress = self.getAllVariantMintsForAddress(address: address)

            // If the address hasn't minted any variants yet, mints is 0 for this variant
            if variantMintsForAddress == nil {
                ret[i] = {
                    "mints": 0,
                    "limit": limit
                }
                continue
            }

            // Get the number of mints for this variant
            let variantMints = variantMintsForAddress![i]

            if variantMints == nil {
                ret[i] = {
                    "mints": 0,
                    "limit": limit
                }
                continue
            } else {
                ret[i] = {
                    "mints": variantMints,
                    "limit": limit
                }
            }
        }
        return ret
    }

    // -----------------------------------------------------------------------
    // Contract Init
    // -----------------------------------------------------------------------

    init() {

        self.PrimalRaveVariantMintLimitsAdminStoragePath = /storage/PrimalRaveVariantMintLimitsAdminStoragePath

        self.variantMintLimits = {}
        self.addressVariantMints = {}
        self.numberOfVariants = 8

        self.account.save(<- create Admin(adminAddress: self.account.address), to: self.PrimalRaveVariantMintLimitsAdminStoragePath)
    }
}"
-------
"import CapabilityFactory from 0xea86b9b77d95aeea
import Lama from 0xea86b9b77d95aeea

pub contract LamaFactory {
    pub struct Factory: CapabilityFactory.Factory {
        pub fun getCapability(acct: &AuthAccount, path: CapabilityPath): Capability {
            return acct.getCapability<&{Lama.ParentAccess}>(path)
        }
    }
}"
-------
"/**

# Fungible Token Forwarding Contract

This contract shows how an account could set up a custom FungibleToken Receiver
to allow them to forward tokens to a different account whenever they receive tokens.

They can publish this Forwarder resource as a Receiver capability just like a Vault,
and the sender doesn't even need to know it is different.

When an account wants to create a Forwarder, they call the createNewForwarder
function and provide it with the Receiver reference that they want to forward
their tokens to.

*/

import FungibleToken from 0xf233dcee88fe0abe

pub contract TokenForwarding {

    // Event that is emitted when tokens are deposited to the target receiver
    pub event ForwardedDeposit(amount: UFix64, symbol: String, from: Address?)

    pub resource interface ForwarderPublic {

        /// Helper function to check whether set `recipient` capability
        /// is not latent or the capability tied to a type is valid.
        pub fun check(): Bool

        /// Gets the receiver assigned to a recipient capability.
        /// This is necessary because without it, it is not possible to look under the hood and see if a capability
        /// is of an expected type or not. This helps guard against infinitely chained TokenForwarding or other invalid
        /// malicious kinds of updates that could prevent listings from being made that are valid on storefronts.
        ///
        /// @return an optional receiver capability for consumers of the TokenForwarding to check/validate on their own
        pub fun safeBorrow(): &{FungibleToken.Receiver}?
    }

    pub resource Forwarder: FungibleToken.Receiver, ForwarderPublic {

        // This is where the deposited tokens will be sent.
        // The type indicates that it is a reference to a receiver
        //
        access(self) var recipient: Capability

        access(all) var symbol: String

        // deposit
        //
        // Function that takes a Vault object as an argument and forwards
        // it to the recipient's Vault using the stored reference
        //
        pub fun deposit(from: @FungibleToken.Vault) {
            let receiverRef = self.recipient.borrow<&{FungibleToken.Receiver}>()!

            let balance = from.balance

            receiverRef.deposit(from: <-from)

            emit ForwardedDeposit(amount: balance, symbol: self.symbol, from: self.owner?.address)
        }

        /// Helper function to check whether set `recipient` capability
        /// is not latent or the capability tied to a type is valid.
        pub fun check(): Bool {
            return self.recipient.check<&{FungibleToken.Receiver}>()
        }

        /// Gets the receiver assigned to a recipient capability.
        /// This is necessary because without it, it is not possible to look under the hood and see if a capability
        /// is of an expected type or not. This helps guard against infinitely chained TokenForwarding or other invalid
        /// malicious kinds of updates that could prevent listings from being made that are valid on storefronts.
        ///
        /// @return an optional receiver capability for consumers of the TokenForwarding to check/validate on their own
        pub fun safeBorrow(): &{FungibleToken.Receiver}? {
            return self.recipient.borrow<&{FungibleToken.Receiver}>()
        }

        // changeRecipient changes the recipient of the forwarder to the provided recipient
        //
        pub fun changeRecipient(_ newRecipient: Capability) {
            pre {
                newRecipient.borrow<&{FungibleToken.Receiver}>() != nil: "Could not borrow Receiver reference from the Capability"
            }
            self.recipient = newRecipient
        }

        /// A getter function that returns the token types supported by this resource,
        /// which can be deposited using the 'deposit' function.
        ///
        /// @return Array of FT types that can be deposited.
        pub fun getSupportedVaultTypes(): {Type: Bool} {
            if !self.recipient.check<&{FungibleToken.Receiver}>() {
                return {}
            }
            let vaultRef = self.recipient.borrow<&{FungibleToken.Receiver}>()!
            let supportedVaults: {Type: Bool} = {}
            supportedVaults[vaultRef.getType()] = true
            return supportedVaults
        }

        init(recipient: Capability, symbol: String) {
            pre {
                recipient.borrow<&{FungibleToken.Receiver}>() != nil: "Could not borrow Receiver reference from the Capability"
            }
            self.recipient = recipient
            self.symbol = symbol
        }
    }

    // createNewForwarder creates a new Forwarder reference with the provided recipient
    //
    pub fun createNewForwarder(recipient: Capability, symbol: String): @Forwarder {
        return <-create Forwarder(recipient: recipient, symbol: symbol)
    }
}"
-------
"// Third-party imports
import MetadataViews from 0x1d7e57aa55817448

// HC-owned imports
import CapabilityFactory from 0xea86b9b77d95aeea
import CapabilityDelegator from 0xea86b9b77d95aeea
import CapabilityFilter from 0xea86b9b77d95aeea

/// HybridCustody defines a framework for sharing accounts via account linking.
/// In the contract, there are three main resources:
///
/// 1. OwnedAccount - A resource which maintains an AuthAccount Capability, and handles publishing and revoking access
///    of that account via another resource called a ChildAccount
/// 2. ChildAccount - A second resource which exists on the same account as the OwnedAccount and contains the filters
///    and retrieval patterns governing the scope of parent account access. A Capability on this resource is shared to
///    the parent account, enabling Hybrid Custody access to the underlying account.
/// 3. Manager - A resource setup by the parent which manages all child accounts shared with it. The Manager resource
///    also maintains a set of accounts that it "owns", meaning it has a capability to the full OwnedAccount resource
///    and would then also be able to manage the child account's links as it sees fit.
///
/// Contributors (please add to this list if you contribute!):
/// - Austin Kline - https://twitter.com/austin_flowty
/// - Deniz Edincik - https://twitter.com/bluesign
/// - Giovanni Sanchez - https://twitter.com/gio_incognito
/// - Ashley Daffin - https://twitter.com/web3ashlee
/// - Felipe Ribeiro - https://twitter.com/Frlabs33
///
/// Repo reference: https://github.com/onflow/hybrid-custody
///
pub contract HybridCustody {

    /* --- Canonical Paths --- */
    //
    // Note: Paths for ChildAccount & Delegator are derived from the parent's address
    //
    pub let OwnedAccountStoragePath: StoragePath
    pub let OwnedAccountPublicPath: PublicPath
    pub let OwnedAccountPrivatePath: PrivatePath

    pub let ManagerStoragePath: StoragePath
    pub let ManagerPublicPath: PublicPath
    pub let ManagerPrivatePath: PrivatePath

    pub let LinkedAccountPrivatePath: PrivatePath
    pub let BorrowableAccountPrivatePath: PrivatePath

    /* --- Events --- */
    //
    /// Manager creation event
    pub event CreatedManager(id: UInt64)
    /// OwnedAccount creation event
    pub event CreatedOwnedAccount(id: UInt64, child: Address)
    /// ChildAccount added/removed from Manager
    ///     active  : added to Manager
    ///     !active : removed from Manager
    pub event AccountUpdated(id: UInt64?, child: Address, parent: Address, active: Bool)
    /// OwnedAccount added/removed or sealed
    ///     active && owner != nil  : added to Manager
    ///     !active && owner == nil : removed from Manager
    pub event OwnershipUpdated(id: UInt64, child: Address, previousOwner: Address?, owner: Address?, active: Bool)
    /// ChildAccount ready to be redeemed by emitted pendingParent
    pub event ChildAccountPublished(
        ownedAcctID: UInt64,
        childAcctID: UInt64,
        capDelegatorID: UInt64,
        factoryID: UInt64,
        filterID: UInt64,
        filterType: Type,
        child: Address,
        pendingParent: Address
    )
    /// OwnedAccount granted ownership to a new address, publishing a Capability for the pendingOwner
    pub event OwnershipGranted(ownedAcctID: UInt64, child: Address, previousOwner: Address?, pendingOwner: Address)
    /// Account has been sealed - keys revoked, new AuthAccount Capability generated
    pub event AccountSealed(id: UInt64, address: Address, parents: [Address])

    /// An OwnedAccount shares the BorrowableAccount capability to itelf with ChildAccount resources
    ///
    pub resource interface BorrowableAccount {
        access(contract) fun borrowAccount(): &AuthAccount
        pub fun check(): Bool
    }

    /// Public methods anyone can call on an OwnedAccount
    ///
    pub resource interface OwnedAccountPublic {
        /// Returns the addresses of all parent accounts
        pub fun getParentAddresses(): [Address]

        /// Returns associated parent addresses and their redeemed status - true if redeemed, false if pending
        pub fun getParentStatuses(): {Address: Bool}

        /// Returns true if the given address is a parent of this child and has redeemed it. Returns false if the given
        /// address is a parent of this child and has NOT redeemed it. Returns nil if the given address it not a parent
        /// of this child account.
        pub fun getRedeemedStatus(addr: Address): Bool?

        /// A callback function to mark a parent as redeemed on the child account.
        access(contract) fun setRedeemed(_ addr: Address)
    }

    /// Private interface accessible to the owner of the OwnedAccount
    ///
    pub resource interface OwnedAccountPrivate {
        /// Deletes the ChildAccount resource being used to share access to this OwnedAccount with the supplied parent
        /// address, and unlinks the paths it was using to reach the underlying account.
        pub fun removeParent(parent: Address): Bool

        /// Sets up a new ChildAccount resource for the given parentAddress to redeem. This child account uses the
        /// supplied factory and filter to manage what can be obtained from the child account, and a new
        /// CapabilityDelegator resource is created for the sharing of one-off capabilities. Each of these pieces of
        /// access control are managed through the child account.
        pub fun publishToParent(
            parentAddress: Address,
            factory: Capability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>,
            filter: Capability<&{CapabilityFilter.Filter}>
        ) {
            pre {
                factory.check(): "Invalid CapabilityFactory.Getter Capability provided"
                filter.check(): "Invalid CapabilityFilter Capability provided"
            }
        }

        /// Passes ownership of this child account to the given address. Once executed, all active keys on the child
        /// account will be revoked, and the active AuthAccount Capability being used by to obtain capabilities will be
        /// rotated, preventing anyone without the newly generated Capability from gaining access to the account.
        pub fun giveOwnership(to: Address)

        /// Revokes all keys on an account, unlinks all currently active AuthAccount capabilities, then makes a new one
        /// and replaces the OwnedAccount's underlying AuthAccount Capability with the new one to ensure that all
        /// parent accounts can still operate normally.
        /// Unless this method is executed via the giveOwnership function, this will leave an account **without** an
        /// owner.
        /// USE WITH EXTREME CAUTION.
        pub fun seal()

        // setCapabilityFactoryForParent
        // Override the existing CapabilityFactory Capability for a given parent. This will allow the owner of the
        // account to start managing their own factory of capabilities to be able to retrieve
        pub fun setCapabilityFactoryForParent(parent: Address, cap: Capability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>) {
            pre {
                cap.check(): "Invalid CapabilityFactory.Getter Capability provided"
            }
        }

        /// Override the existing CapabilityFilter Capability for a given parent. This will allow the owner of the
        /// account to start managing their own filter for retrieving Capabilities on Private Paths
        pub fun setCapabilityFilterForParent(parent: Address, cap: Capability<&{CapabilityFilter.Filter}>) {
            pre {
                cap.check(): "Invalid CapabilityFilter Capability provided"
            }
        }

        /// Adds a capability to a parent's managed @ChildAccount resource. The Capability can be made public,
        /// permitting anyone to borrow it.
        pub fun addCapabilityToDelegator(parent: Address, cap: Capability, isPublic: Bool) {
            pre {
                cap.check<&AnyResource>(): "Invalid Capability provided"
            }
        }

        /// Removes a Capability from the CapabilityDelegator used by the specified parent address
        pub fun removeCapabilityFromDelegator(parent: Address, cap: Capability)

        /// Returns the address of this OwnedAccount
        pub fun getAddress(): Address

        /// Checks if this OwnedAccount is a child of the specified address
        pub fun isChildOf(_ addr: Address): Bool

        /// Returns all addresses which are parents of this OwnedAccount
        pub fun getParentAddresses(): [Address]

        /// Borrows this OwnedAccount's AuthAccount Capability
        pub fun borrowAccount(): &AuthAccount?

        /// Returns the current owner of this account, if there is one
        pub fun getOwner(): Address?

        /// Returns the pending owner of this account, if there is one
        pub fun getPendingOwner(): Address?

        /// A callback which is invoked when a parent redeems an owned account
        access(contract) fun setOwnerCallback(_ addr: Address)

        /// Destroys all outstanding AuthAccount capabilities on this owned account, and creates a new one for the
        /// OwnedAccount to use
        pub fun rotateAuthAccount()

        /// Revokes all keys on this account
        pub fun revokeAllKeys()
    }

    /// Public methods exposed on a ChildAccount resource. OwnedAccountPublic will share some methods here, but isn't
    /// necessarily the same.
    ///
    pub resource interface AccountPublic {
        pub fun getPublicCapability(path: PublicPath, type: Type): Capability?
        pub fun getPublicCapFromDelegator(type: Type): Capability?
        pub fun getAddress(): Address
    }

    /// Methods accessible to the designated parent of a ChildAccount
    ///
    pub resource interface AccountPrivate {
        pub fun getCapability(path: CapabilityPath, type: Type): Capability? {
            post {
                result == nil || [true, nil].contains(self.getManagerCapabilityFilter()?.allowed(cap: result!)):
                    "Capability is not allowed by this account's Parent"
            }
        }
        pub fun getPublicCapability(path: PublicPath, type: Type): Capability?
        pub fun getManagerCapabilityFilter():  &{CapabilityFilter.Filter}?
        pub fun getPublicCapFromDelegator(type: Type): Capability?
        pub fun getPrivateCapFromDelegator(type: Type): Capability? {
            post {
                result == nil || [true, nil].contains(self.getManagerCapabilityFilter()?.allowed(cap: result!)):
                    "Capability is not allowed by this account's Parent"
            }
        }
        access(contract) fun redeemedCallback(_ addr: Address)
        access(contract) fun setManagerCapabilityFilter(_ managerCapabilityFilter: Capability<&{CapabilityFilter.Filter}>?) {
            pre {
                managerCapabilityFilter == nil || managerCapabilityFilter!.check(): "Invalid Manager Capability Filter"
            }
        }
        access(contract) fun parentRemoveChildCallback(parent: Address)
    }

    /// Entry point for a parent to obtain, maintain and access Capabilities or perform other actions on child accounts
    ///
    pub resource interface ManagerPrivate {
        pub fun addAccount(cap: Capability<&{AccountPrivate, AccountPublic, MetadataViews.Resolver}>)
        pub fun borrowAccount(addr: Address): &{AccountPrivate, AccountPublic, MetadataViews.Resolver}?
        pub fun removeChild(addr: Address)
        pub fun addOwnedAccount(cap: Capability<&{OwnedAccountPrivate, OwnedAccountPublic, MetadataViews.Resolver}>)
        pub fun borrowOwnedAccount(addr: Address): &{OwnedAccountPrivate, OwnedAccountPublic, MetadataViews.Resolver}?
        pub fun removeOwned(addr: Address)
        pub fun setManagerCapabilityFilter(cap: Capability<&{CapabilityFilter.Filter}>?, childAddress: Address) {
            pre {
                cap == nil || cap!.check(): "Invalid Manager Capability Filter"
            }
        }
    }

    /// Functions anyone can call on a manager to get information about an account such as What child accounts it has
    /// Functions anyone can call on a manager to get information about an account such as what child accounts it has
    pub resource interface ManagerPublic {
        pub fun borrowAccountPublic(addr: Address): &{AccountPublic, MetadataViews.Resolver}?
        pub fun getChildAddresses(): [Address]
        pub fun getOwnedAddresses(): [Address]
        pub fun getChildAccountDisplay(address: Address): MetadataViews.Display?
        access(contract) fun removeParentCallback(child: Address)
    }

    /// A resource for an account which fills the Parent role of the Child-Parent account management Model. A Manager
    /// can redeem or remove child accounts, and obtain any capabilities exposed by the child account to them.
    ///
    pub resource Manager: ManagerPrivate, ManagerPublic, MetadataViews.Resolver {

        /// Mapping of restricted access child account Capabilities indexed by their address
        pub let childAccounts: {Address: Capability<&{AccountPrivate, AccountPublic, MetadataViews.Resolver}>}
        /// Mapping of unrestricted owned account Capabilities indexed by their address
        pub let ownedAccounts: {Address: Capability<&{OwnedAccountPrivate, OwnedAccountPublic, MetadataViews.Resolver}>}

        /// A bucket of structs so that the Manager resource can be easily extended with new functionality.
        pub let data: {String: AnyStruct}
        /// A bucket of resources so that the Manager resource can be easily extended with new functionality.
        pub let resources: @{String: AnyResource}

        /// An optional filter to gate what capabilities are permitted to be returned from a child account For example,
        /// Dapper Wallet parent account's should not be able to retrieve any FungibleToken Provider capabilities.
        pub var filter: Capability<&{CapabilityFilter.Filter}>?

        // display metadata for a child account exists on its parent
        pub let childAccountDisplays: {Address: MetadataViews.Display}

        /// Sets the Display on the ChildAccount. If nil, the display is removed.
        ///
        pub fun setChildAccountDisplay(address: Address, _ d: MetadataViews.Display?) {
            pre {
                self.childAccounts[address] != nil: "There is no child account with this address"
            }

            if d == nil {
                self.childAccountDisplays.remove(key: address)
                return
            }

            self.childAccountDisplays[address] = d
        }

        /// Adds a ChildAccount Capability to this Manager. If a default Filter is set in the manager, it will also be
        /// added to the ChildAccount
        ///
        pub fun addAccount(cap: Capability<&{AccountPrivate, AccountPublic, MetadataViews.Resolver}>) {
            pre {
                self.childAccounts[cap.address] == nil: "There is already a child account with this address"
            }

            let acct = cap.borrow()
                ?? panic("child account capability could not be borrowed")

            self.childAccounts[cap.address] = cap

            emit AccountUpdated(id: acct.uuid, child: cap.address, parent: self.owner!.address, active: true)

            acct.redeemedCallback(self.owner!.address)
            acct.setManagerCapabilityFilter(self.filter)
        }

        /// Sets the default Filter Capability for this Manager. Does not propagate to child accounts.
        ///
        pub fun setDefaultManagerCapabilityFilter(cap: Capability<&{CapabilityFilter.Filter}>?) {
            pre {
                cap == nil || cap!.check(): "supplied capability must be nil or check must pass"
            }

            self.filter = cap
        }

        /// Sets the Filter Capability for this Manager, propagating to the specified child account
        ///
        pub fun setManagerCapabilityFilter(cap: Capability<&{CapabilityFilter.Filter}>?, childAddress: Address) {
            let acct = self.borrowAccount(addr: childAddress)
                ?? panic("child account not found")

            acct.setManagerCapabilityFilter(cap)
        }

        /// Removes specified child account from the Manager's child accounts. Callbacks to the child account remove
        /// any associated resources and Capabilities
        ///
        pub fun removeChild(addr: Address) {
            let cap = self.childAccounts.remove(key: addr)
                ?? panic("child account not found")

            self.childAccountDisplays.remove(key: addr)

            if !cap.check() {
                // Emit event if invalid capability
                emit AccountUpdated(id: nil, child: cap.address, parent: self.owner!.address, active: false)
                return
            }

            let acct = cap.borrow()!
            // Get the child account id before removing capability
            let id: UInt64 = acct.uuid

            acct.parentRemoveChildCallback(parent: self.owner!.address)

            emit AccountUpdated(id: id, child: cap.address, parent: self.owner!.address, active: false)
        }

        /// Contract callback that removes a child account from the Manager's child accounts in the event a child
        /// account initiates unlinking parent from child
        ///
        access(contract) fun removeParentCallback(child: Address) {
            self.childAccounts.remove(key: child)
            self.childAccountDisplays.remove(key: child)
        }

        /// Adds an owned account to the Manager's list of owned accounts, setting the Manager account as the owner of
        /// the given account
        ///
        pub fun addOwnedAccount(cap: Capability<&{OwnedAccountPrivate, OwnedAccountPublic, MetadataViews.Resolver}>) {
            pre {
                self.ownedAccounts[cap.address] == nil: "There is already an owned account with this address"
            }

            let acct = cap.borrow()
                ?? panic("owned account capability could not be borrowed")

            // for safety, rotate the auth account capability to prevent any outstanding capabilities from the previous owner
            // and revoke all outstanding keys.
            acct.rotateAuthAccount()
            acct.revokeAllKeys()

            self.ownedAccounts[cap.address] = cap

            emit OwnershipUpdated(id: acct.uuid, child: cap.address, previousOwner: acct.getOwner(), owner: self.owner!.address, active: true)
            acct.setOwnerCallback(self.owner!.address)
        }

        /// Returns a reference to a child account
        ///
        pub fun borrowAccount(addr: Address): &{AccountPrivate, AccountPublic, MetadataViews.Resolver}? {
            let cap = self.childAccounts[addr]
            if cap == nil {
                return nil
            }

            return cap!.borrow()
        }

        /// Returns a reference to a child account's public AccountPublic interface
        ///
        pub fun borrowAccountPublic(addr: Address): &{AccountPublic, MetadataViews.Resolver}? {
            let cap = self.childAccounts[addr]
            if cap == nil {
                return nil
            }

            return cap!.borrow()
        }

        /// Returns a reference to an owned account
        ///
        pub fun borrowOwnedAccount(addr: Address): &{OwnedAccountPrivate, OwnedAccountPublic, MetadataViews.Resolver}? {
            if let cap = self.ownedAccounts[addr] {
                return cap.borrow()
            }

            return nil
        }

        /// Removes specified child account from the Manager's child accounts. Callbacks to the child account remove
        /// any associated resources and Capabilities
        ///
        pub fun removeOwned(addr: Address) {
            if let acct = self.ownedAccounts.remove(key: addr) {
                if acct.check() {
                    acct.borrow()!.seal()
                }
                let id: UInt64? = acct.borrow()?.uuid ?? nil

                emit OwnershipUpdated(id: id!, child: addr, previousOwner: self.owner!.address, owner: nil, active: false)
            }
            // Don't emit an event if nothing was removed
        }

        pub fun giveOwnership(addr: Address, to: Address) {
            let acct = self.ownedAccounts.remove(key: addr)
                ?? panic("account not found")

            acct.borrow()!.giveOwnership(to: to)
        }

        /// Returns an array of child account addresses
        ///
        pub fun getChildAddresses(): [Address] {
            return self.childAccounts.keys
        }

        /// Returns an array of owned account addresses
        ///
        pub fun getOwnedAddresses(): [Address] {
            return self.ownedAccounts.keys
        }

        /// Retrieves the parent-defined display for the given child account
        ///
        pub fun getChildAccountDisplay(address: Address): MetadataViews.Display? {
            return self.childAccountDisplays[address]
        }

        /// Returns the types of supported views - none at this time
        ///
        pub fun getViews(): [Type] {
            return []
        }

        /// Resolves the given view if supported - none at this time
        ///
        pub fun resolveView(_ view: Type): AnyStruct? {
            return nil
        }

        init(filter: Capability<&{CapabilityFilter.Filter}>?) {
            pre {
                filter == nil || filter!.check(): "Invalid CapabilityFilter Filter capability provided"
            }
            self.childAccounts = {}
            self.ownedAccounts = {}
            self.childAccountDisplays = {}
            self.filter = filter

            self.data = {}
            self.resources <- {}
        }

        destroy () {
            destroy self.resources
        }
    }

    /// The ChildAccount resource sits between a child account and a parent and is stored on the same account as the
    /// child account. Once created, a private capability to the child account is shared with the intended parent. The
    /// parent account will accept this child capability into its own manager resource and use it to interact with the
    /// child account.
    ///
    /// Because the ChildAccount resource exists on the child account itself, whoever owns the child account will be
    /// able to manage all ChildAccount resources it shares, without worrying about whether the upstream parent can do
    /// anything to prevent it.
    ///
    pub resource ChildAccount: AccountPrivate, AccountPublic, MetadataViews.Resolver {
        /// A Capability providing access to the underlying child account
        access(self) let childCap: Capability<&{BorrowableAccount, OwnedAccountPublic, MetadataViews.Resolver}>

        /// The CapabilityFactory Manager is a ChildAccount's way of limiting what types can be asked for by its parent
        /// account. The CapabilityFactory returns Capabilities which can be casted to their appropriate types once
        /// obtained, but only if the child account has configured their factory to allow it. For instance, a
        /// ChildAccount might choose to expose NonFungibleToken.Provider, but not FungibleToken.Provider
        pub var factory: Capability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>

        /// The CapabilityFilter is a restriction put at the front of obtaining any non-public Capability. Some wallets
        /// might want to give access to NonFungibleToken.Provider, but only to **some** of the collections it manages,
        /// not all of them.
        pub var filter: Capability<&{CapabilityFilter.Filter}>

        /// The CapabilityDelegator is a way to share one-off capabilities from the child account. These capabilities
        /// can be public OR private and are separate from the factory which returns a capability at a given path as a
        /// certain type. When using the CapabilityDelegator, you do not have the ability to specify which path a
        /// capability came from. For instance, Dapper Wallet might choose to expose a Capability to their Full TopShot
        /// collection, but only to the path that the collection exists in.
        pub let delegator: Capability<&CapabilityDelegator.Delegator{CapabilityDelegator.GetterPublic, CapabilityDelegator.GetterPrivate}>

        /// managerCapabilityFilter is a component optionally given to a child account when a manager redeems it. If
        /// this filter is not nil, any Capability returned through the `getCapability` function checks that the
        /// manager allows access first.
        access(self) var managerCapabilityFilter: Capability<&{CapabilityFilter.Filter}>?

        /// A bucket of structs so that the ChildAccount resource can be easily extended with new functionality.
        access(self) let data: {String: AnyStruct}

        /// A bucket of resources so that the ChildAccount resource can be easily extended with new functionality.
        access(self) let resources: @{String: AnyResource}

        /// ChildAccount resources have a 1:1 association with parent accounts, the named parent Address here is the
        /// one with a Capability on this resource.
        pub let parent: Address

        /// Returns the Address of the underlying child account
        ///
        pub fun getAddress(): Address {
            return self.childCap.address
        }

        /// Callback setting the child account as redeemed by the provided parent Address
        ///
        access(contract) fun redeemedCallback(_ addr: Address) {
            self.childCap.borrow()!.setRedeemed(addr)
        }

        /// Sets the given filter as the managerCapabilityFilter for this ChildAccount
        ///
        access(contract) fun setManagerCapabilityFilter(
            _ managerCapabilityFilter: Capability<&{CapabilityFilter.Filter}>?
        ) {
            self.managerCapabilityFilter = managerCapabilityFilter
        }

        /// Sets the CapabiltyFactory.Manager Capability
        ///
        pub fun setCapabilityFactory(cap: Capability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>) {
            self.factory = cap
        }

        /// Sets the Filter Capability as the one provided
        ///
        pub fun setCapabilityFilter(cap: Capability<&{CapabilityFilter.Filter}>) {
            self.filter = cap
        }

        // The main function to a child account's capabilities from a parent account. When a PrivatePath type is used,
        // the CapabilityFilter will be borrowed and the Capability being returned will be checked against it to ensure
        // that borrowing is permitted
        pub fun getCapability(path: CapabilityPath, type: Type): Capability? {
            let child = self.childCap.borrow() ?? panic("failed to borrow child account")

            let f = self.factory.borrow()!.getFactory(type)
            if f == nil {
                return nil
            }

            let acct = child.borrowAccount()

            let cap = f!.getCapability(acct: acct, path: path)

            if path.getType() == Type<PrivatePath>() {
                assert(self.filter.borrow()!.allowed(cap: cap), message: "requested capability is not allowed")
            }

            return cap
        }

        /// Retrieves a private Capability from the Delegator or nil none is found of the given type
        ///
        pub fun getPrivateCapFromDelegator(type: Type): Capability? {
            if let p = self.delegator.borrow() {
                return p.getPrivateCapability(type)
            }

            return nil
        }

        /// Retrieves a public Capability from the Delegator or nil none is found of the given type
        ///
        pub fun getPublicCapFromDelegator(type: Type): Capability? {
            if let p = self.delegator.borrow() {
                return p.getPublicCapability(type)
            }
            return nil
        }

        /// Enables retrieval of public Capabilities of the given type from the specified path or nil if none is found
        ///
        pub fun getPublicCapability(path: PublicPath, type: Type): Capability? {
            return self.getCapability(path: path, type: type)
        }

        /// Returns a reference to the stored managerCapabilityFilter if one exists
        ///
        pub fun getManagerCapabilityFilter():  &{CapabilityFilter.Filter}? {
            return self.managerCapabilityFilter != nil ? self.managerCapabilityFilter!.borrow() : nil
        }

        /// Sets the child account as redeemed by the given Address
        ///
        access(contract) fun setRedeemed(_ addr: Address) {
            let acct = self.childCap.borrow()!.borrowAccount()
            if let o = acct.borrow<&OwnedAccount>(from: HybridCustody.OwnedAccountStoragePath) {
                o.setRedeemed(addr)
            }
        }

        /// Returns a reference to the stored delegator
        ///
        pub fun borrowCapabilityDelegator(): &CapabilityDelegator.Delegator? {
            let path = HybridCustody.getCapabilityDelegatorIdentifier(self.parent)
            return self.childCap.borrow()!.borrowAccount().borrow<&CapabilityDelegator.Delegator>(
                from: StoragePath(identifier: path)!
            )
        }

        /// Returns a list of supported metadata views
        ///
        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>()
            ]
        }

        /// Resolves a view of the given type if supported
        ///
        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    let childAddress = self.getAddress()
                    let manager = getAccount(self.parent).getCapability<&HybridCustody.Manager{HybridCustody.ManagerPublic}>(HybridCustody.ManagerPublicPath)

                    if !manager.check() {
                        return nil
                    }

                    return manager!.borrow()!.getChildAccountDisplay(address: childAddress)
            }
            return nil
        }

        /// Callback to enable parent-initiated removal all the child account and its associated resources &
        /// Capabilities
        access(contract) fun parentRemoveChildCallback(parent: Address) {
            if !self.childCap.check() {
                return
            }

            let child: &AnyResource{HybridCustody.BorrowableAccount} = self.childCap.borrow()!
            if !child.check() {
                return
            }

            let acct = child.borrowAccount()
            if let ownedAcct = acct.borrow<&OwnedAccount>(from: HybridCustody.OwnedAccountStoragePath) {
                ownedAcct.removeParent(parent: parent)
            }
        }

        init(
            _ childCap: Capability<&{BorrowableAccount, OwnedAccountPublic, MetadataViews.Resolver}>,
            _ factory: Capability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>,
            _ filter: Capability<&{CapabilityFilter.Filter}>,
            _ delegator: Capability<&CapabilityDelegator.Delegator{CapabilityDelegator.GetterPublic, CapabilityDelegator.GetterPrivate}>,
            _ parent: Address
        ) {
            pre {
                childCap.check(): "Provided childCap Capability is invalid"
                factory.check(): "Provided factory Capability is invalid"
                filter.check(): "Provided filter Capability is invalid"
                delegator.check(): "Provided delegator Capability is invalid"
            }
            self.childCap = childCap
            self.factory = factory
            self.filter = filter
            self.delegator = delegator
            self.managerCapabilityFilter = nil // this will get set when a parent account redeems
            self.parent = parent

            self.data = {}
            self.resources <- {}
        }

        destroy () {
            destroy <- self.resources
        }
    }

    /// A resource which sits on the account it manages to make it easier for apps to configure the behavior they want
    /// to permit. An OwnedAccount can be used to create ChildAccount resources and share them, publishing them to
    /// other addresses.
    ///
    /// The OwnedAccount can also be used to pass ownership of an account off to another address, or to relinquish
    /// ownership entirely, marking the account as owned by no one. Note that even if there isn't an owner, the parent
    /// accounts would still exist, allowing a form of Hybrid Custody which has no true owner over an account, but
    /// shared partial ownership.
    ///
    pub resource OwnedAccount: OwnedAccountPrivate, BorrowableAccount, OwnedAccountPublic, MetadataViews.Resolver {
        /// Capability on the underlying account object
        access(self) var acct: Capability<&AuthAccount>

        /// Mapping of current and pending parents, true and false respectively
        pub let parents: {Address: Bool}
        /// Address of the pending owner, if one exists
        pub var pendingOwner: Address?
        /// Address of the current owner, if one exists
        pub var acctOwner: Address?
        /// Owned status of this account
        pub var currentlyOwned: Bool

        /// A bucket of structs so that the OwnedAccount resource can be easily extended with new functionality.
        access(self) let data: {String: AnyStruct}

        /// A bucket of resources so that the OwnedAccount resource can be easily extended with new functionality.
        access(self) let resources: @{String: AnyResource}

        /// display is its own field on the OwnedAccount resource because only the owner of the child account should be
        /// able to set this field.
        access(self) var display: MetadataViews.Display?

        /// Callback that sets this OwnedAccount as redeemed by the parent
        ///
        access(contract) fun setRedeemed(_ addr: Address) {
            pre {
                self.parents[addr] != nil: "address is not waiting to be redeemed"
            }

            self.parents[addr] = true
        }

        /// Callback that sets the owner once redeemed
        ///
        access(contract) fun setOwnerCallback(_ addr: Address) {
            pre {
                self.pendingOwner == addr: "Address does not match pending owner!"
            }
            self.pendingOwner = nil
            self.acctOwner = addr
        }


        /// A helper method to make it easier to manage what parents an account has configured. The steps to sharing this
        /// OwnedAccount with a new parent are:
        ///
        /// 1. Create a new CapabilityDelegator for the ChildAccount resource being created. We make a new one here because
        ///    CapabilityDelegator types are meant to be shared explicitly. Making one shared base-line of capabilities might
        ///    introduce unforseen behavior where an app accidentally shared something to all accounts when it only meant
        ///    to go to one of them. It is better for parent accounts to have less access than they might have anticipated,
        ///    than for a child to have given out access it did not intend to.
        /// 2. Create a new Capability<&{BorrowableAccount}> which has its own unique path for the parent to share this
        ///    child account with. We make new ones each time so that you can revoke access from one parent, without
        ///    destroying them all. A new link is made each time based on the address being shared to allow this
        ///    fine-grained control, but it is all managed by the OwnedAccount resource itself.
        /// 3. A new @ChildAccount resource is created and saved, using the CapabilityDelegator made in step one, and our
        ///    CapabilityFactory and CapabilityFilter Capabilities. Once saved, public and private links are configured for
        ///    the ChildAccount.
        /// 4. Publish the newly made private link to the designated parent's inbox for them to claim on their @Manager
        ///    resource.
        ///
        pub fun publishToParent(
            parentAddress: Address,
            factory: Capability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>,
            filter: Capability<&{CapabilityFilter.Filter}>
        ) {
            pre{
                self.parents[parentAddress] == nil: "Address pending or already redeemed as parent"
            }
            let capDelegatorIdentifier = HybridCustody.getCapabilityDelegatorIdentifier(parentAddress)

            let identifier = HybridCustody.getChildAccountIdentifier(parentAddress)
            let childAccountStorage = StoragePath(identifier: identifier)!

            let capDelegatorStorage = StoragePath(identifier: capDelegatorIdentifier)!
            let acct = self.borrowAccount()

            assert(acct.borrow<&AnyResource>(from: capDelegatorStorage) == nil, message: "conflicting resource found in capability delegator storage slot for parentAddress")
            assert(acct.borrow<&AnyResource>(from: childAccountStorage) == nil, message: "conflicting resource found in child account storage slot for parentAddress")

            if acct.borrow<&CapabilityDelegator.Delegator>(from: capDelegatorStorage) == nil {
                let delegator <- CapabilityDelegator.createDelegator()
                acct.save(<-delegator, to: capDelegatorStorage)
            }

            let capDelegatorPublic = PublicPath(identifier: capDelegatorIdentifier)!
            let capDelegatorPrivate = PrivatePath(identifier: capDelegatorIdentifier)!

            acct.link<&CapabilityDelegator.Delegator{CapabilityDelegator.GetterPublic}>(
                capDelegatorPublic,
                target: capDelegatorStorage
            )
            acct.link<&CapabilityDelegator.Delegator{CapabilityDelegator.GetterPublic, CapabilityDelegator.GetterPrivate}>(
                capDelegatorPrivate,
                target: capDelegatorStorage
            )
            let delegator = acct.getCapability<&CapabilityDelegator.Delegator{CapabilityDelegator.GetterPublic, CapabilityDelegator.GetterPrivate}>(
                capDelegatorPrivate
            )
            assert(delegator.check(), message: "failed to setup capability delegator for parent address")

            let borrowableCap = self.borrowAccount().getCapability<&{BorrowableAccount, OwnedAccountPublic, MetadataViews.Resolver}>(
                HybridCustody.OwnedAccountPrivatePath
            )
            let childAcct <- create ChildAccount(borrowableCap, factory, filter, delegator, parentAddress)

            let childAccountPrivatePath = PrivatePath(identifier: identifier)!

            acct.save(<-childAcct, to: childAccountStorage)
            acct.link<&ChildAccount{AccountPrivate, AccountPublic, MetadataViews.Resolver}>(childAccountPrivatePath, target: childAccountStorage)

            let delegatorCap = acct.getCapability<&ChildAccount{AccountPrivate, AccountPublic, MetadataViews.Resolver}>(childAccountPrivatePath)
            assert(delegatorCap.check(), message: "Delegator capability check failed")

            acct.inbox.publish(delegatorCap, name: identifier, recipient: parentAddress)
            self.parents[parentAddress] = false

            emit ChildAccountPublished(
                ownedAcctID: self.uuid,
                childAcctID: delegatorCap.borrow()!.uuid,
                capDelegatorID: delegator.borrow()!.uuid,
                factoryID: factory.borrow()!.uuid,
                filterID: filter.borrow()!.uuid,
                filterType: filter.borrow()!.getType(),
                child: self.getAddress(),
                pendingParent: parentAddress
            )
        }

        /// Checks the validity of the encapsulated account Capability
        ///
        pub fun check(): Bool {
            return self.acct.check()
        }

        /// Returns a reference to the encapsulated account object
        ///
        pub fun borrowAccount(): &AuthAccount {
            return self.acct.borrow()!
        }

        /// Returns the addresses of all associated parents pending and active
        ///
        pub fun getParentAddresses(): [Address] {
            return self.parents.keys
        }

        /// Returns whether the given address is a parent of this account
        ///
        pub fun isChildOf(_ addr: Address): Bool {
            return self.parents[addr] != nil
        }

        /// Returns nil if the given address is not a parent, false if the parent has not redeemed the child account
        /// yet, and true if they have
        ///
        pub fun getRedeemedStatus(addr: Address): Bool? {
            return self.parents[addr]
        }

        /// Returns associated parent addresses and their redeemed status
        ///
        pub fun getParentStatuses(): {Address: Bool} {
            return self.parents
        }

        /// Unlinks all paths configured when publishing an account, and destroy's the @ChildAccount resource
        /// configured for the provided parent address. Once done, the parent will not have any valid capabilities with
        /// which to access the child account.
        ///
        pub fun removeParent(parent: Address): Bool {
            if self.parents[parent] == nil {
                return false
            }
            let identifier = HybridCustody.getChildAccountIdentifier(parent)
            let capDelegatorIdentifier = HybridCustody.getCapabilityDelegatorIdentifier(parent)

            let acct = self.borrowAccount()
            acct.unlink(PrivatePath(identifier: identifier)!)
            acct.unlink(PublicPath(identifier: identifier)!)

            acct.unlink(PrivatePath(identifier: capDelegatorIdentifier)!)
            acct.unlink(PublicPath(identifier: capDelegatorIdentifier)!)

            destroy <- acct.load<@AnyResource>(from: StoragePath(identifier: identifier)!)
            destroy <- acct.load<@AnyResource>(from: StoragePath(identifier: capDelegatorIdentifier)!)

            self.parents.remove(key: parent)
            emit AccountUpdated(id: self.uuid, child: self.acct.address, parent: parent, active: false)

            let parentManager = getAccount(parent).getCapability<&Manager{ManagerPublic}>(HybridCustody.ManagerPublicPath)
            if parentManager.check() {
                parentManager.borrow()?.removeParentCallback(child: self.owner!.address)
            }

            return true
        }

        /// Returns the address of the encapsulated account
        ///
        pub fun getAddress(): Address {
            return self.acct.address
        }

        /// Returns the address of the pending owner if one is assigned. Pending owners are assigned when ownership has
        /// been granted, but has not yet been redeemed.
        ///
        pub fun getPendingOwner(): Address? {
            return self.pendingOwner
        }

        /// Returns the address of the current owner if one is assigned. Current owners are assigned when ownership has
        /// been redeemed.
        ///
        pub fun getOwner(): Address? {
            if !self.currentlyOwned {
                return nil
            }
            return self.acctOwner != nil ? self.acctOwner! : self.owner!.address
        }

        /// This method is used to transfer ownership of the child account to a new address.
        /// Ownership here means that one has unrestricted access on this OwnedAccount resource, giving them full
        /// access to the account.
        ///
        /// **NOTE:** The existence of this method does not imply that it is the only way to receive access to a
        /// OwnedAccount Capability or that only the labeled 'acctOwner' has said access. Rather, this is a convenient
        /// mechanism intended to easily transfer 'root' access on this account to another account and an attempt to
        /// minimize access vectors.
        ///
        pub fun giveOwnership(to: Address) {
            self.seal()

            let acct = self.borrowAccount()
            // Unlink existing owner's Capability if owner exists
            if self.acctOwner != nil {
                acct.unlink(
                    PrivatePath(identifier: HybridCustody.getOwnerIdentifier(self.acctOwner!))!
                )
            }
            // Link a Capability for the new owner, retrieve & publish
            let identifier =  HybridCustody.getOwnerIdentifier(to)
            let cap = acct.link<&{OwnedAccountPrivate, OwnedAccountPublic, MetadataViews.Resolver}>(
                    PrivatePath(identifier: identifier)!,
                    target: HybridCustody.OwnedAccountStoragePath
                ) ?? panic("failed to link child account capability")

            acct.inbox.publish(cap, name: identifier, recipient: to)

            self.pendingOwner = to
            self.currentlyOwned = true

            emit OwnershipGranted(ownedAcctID: self.uuid, child: self.acct.address, previousOwner: self.getOwner(), pendingOwner: to)
        }

        pub fun revokeAllKeys() {
            let acct = self.borrowAccount()

            // Revoke all keys
            acct.keys.forEach(fun (key: AccountKey): Bool {
                if !key.isRevoked {
                    acct.keys.revoke(keyIndex: key.keyIndex)
                }
                return true
            })
        }

        /// Cancels all existing AuthAccount capabilities, and creates a new one. The newly created capability will
        /// then be used by the child account for accessing its AuthAccount going forward.
        ///
        /// This is used when altering ownership of an account, and can also be used as a safeguard for anyone who
        /// assumes ownership of an account to guarantee that the previous owner doesn't maintain admin access to the
        /// account via other AuthAccount Capabilities.
        ///
        pub fun rotateAuthAccount() {
            let acct = self.borrowAccount()

            // Find all active AuthAccount capabilities so they can be removed after we make the new auth account cap
            let pathsToUnlink: [PrivatePath] = []
            acct.forEachPrivate(fun (path: PrivatePath, type: Type): Bool {
                if type.identifier == "Capability<&AuthAccount>" {
                    pathsToUnlink.append(path)
                }
                return true
            })

            // Link a new AuthAccount Capability
            // NOTE: This path cannot be sufficiently randomly generated, an app calling this function could build a
            // capability to this path before it is made, thus maintaining ownership despite making it look like they
            // gave it away. Until capability controllers, this method should not be fully trusted.
            let authAcctPath = "HybridCustodyRelinquished".concat(HybridCustody.account.address.toString()).concat(getCurrentBlock().height.toString())
            let acctCap = acct.linkAccount(PrivatePath(identifier: authAcctPath)!)!

            self.acct = acctCap
            let newAcct = self.acct.borrow()!

            // cleanup, remove all previously found paths. We had to do it in this order because we will be unlinking
            // the existing path which will cause a deference issue with the originally borrowed auth account
            for  p in pathsToUnlink {
                newAcct.unlink(p)
            }
        }

        /// Revokes all keys on an account, unlinks all currently active AuthAccount capabilities, then makes a new one
        /// and replaces the @OwnedAccount's underlying AuthAccount Capability with the new one to ensure that all parent
        /// accounts can still operate normally.
        /// Unless this method is executed via the giveOwnership function, this will leave an account **without** an owner.
        ///
        /// USE WITH EXTREME CAUTION.
        ///
        pub fun seal() {
            self.rotateAuthAccount()
            self.revokeAllKeys() // There needs to be a path to giving ownership that doesn't revoke keys
            emit AccountSealed(id: self.uuid, address: self.acct.address, parents: self.parents.keys)
            self.currentlyOwned = false
        }

        /// Retrieves a reference to the ChildAccount associated with the given parent account if one exists.
        ///
        pub fun borrowChildAccount(parent: Address): &ChildAccount? {
            let identifier = HybridCustody.getChildAccountIdentifier(parent)
            return self.borrowAccount().borrow<&ChildAccount>(from: StoragePath(identifier: identifier)!)
        }

        /// Sets the CapabilityFactory Manager for the specified parent in the associated ChildAccount.
        ///
        pub fun setCapabilityFactoryForParent(
            parent: Address,
            cap: Capability<&CapabilityFactory.Manager{CapabilityFactory.Getter}>
        ) {
            let p = self.borrowChildAccount(parent: parent) ?? panic("could not find parent address")
            p.setCapabilityFactory(cap: cap)
        }

        /// Sets the Filter for the specified parent in the associated ChildAccount.
        ///
        pub fun setCapabilityFilterForParent(parent: Address, cap: Capability<&{CapabilityFilter.Filter}>) {
            let p = self.borrowChildAccount(parent: parent) ?? panic("could not find parent address")
            p.setCapabilityFilter(cap: cap)
        }

        /// Retrieves a reference to the Delegator associated with the given parent account if one exists.
        ///
        pub fun borrowCapabilityDelegatorForParent(parent: Address): &CapabilityDelegator.Delegator? {
            let identifier = HybridCustody.getCapabilityDelegatorIdentifier(parent)
            return self.borrowAccount().borrow<&CapabilityDelegator.Delegator>(from: StoragePath(identifier: identifier)!)
        }

        /// Adds the provided Capability to the Delegator associated with the given parent account.
        ///
        pub fun addCapabilityToDelegator(parent: Address, cap: Capability, isPublic: Bool) {
            let p = self.borrowChildAccount(parent: parent) ?? panic("could not find parent address")
            let delegator = self.borrowCapabilityDelegatorForParent(parent: parent)
                ?? panic("could not borrow capability delegator resource for parent address")
            delegator.addCapability(cap: cap, isPublic: isPublic)
        }

        /// Removes the provided Capability from the Delegator associated with the given parent account.
        ///
        pub fun removeCapabilityFromDelegator(parent: Address, cap: Capability) {
            let p = self.borrowChildAccount(parent: parent) ?? panic("could not find parent address")
            let delegator = self.borrowCapabilityDelegatorForParent(parent: parent)
                ?? panic("could not borrow capability delegator resource for parent address")
            delegator.removeCapability(cap: cap)
        }

        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return self.display
            }
            return nil
        }

        /// Sets this OwnedAccount's display to the one provided
        ///
        pub fun setDisplay(_ d: MetadataViews.Display) {
            self.display = d
        }

        init(
            _ acct: Capability<&AuthAccount>
        ) {
            self.acct = acct

            self.parents = {}
            self.pendingOwner = nil
            self.acctOwner = nil
            self.currentlyOwned = true

            self.data = {}
            self.resources <- {}
            self.display = nil
        }

        destroy () {
            destroy <- self.resources
        }
    }

    /// Utility function to get the path identifier for a parent address when interacting with a ChildAccount and its
    /// parents
    ///
    pub fun getChildAccountIdentifier(_ addr: Address): String {
        return "ChildAccount_".concat(addr.toString())
    }

    /// Utility function to get the path identifier for a parent address when interacting with a Delegator and its
    /// parents
    ///
    pub fun getCapabilityDelegatorIdentifier(_ addr: Address): String {
        return "ChildCapabilityDelegator_".concat(addr.toString())
    }

    /// Utility function to get the path identifier for a parent address when interacting with an OwnedAccount and its
    /// owners
    ///
    pub fun getOwnerIdentifier(_ addr: Address): String {
        return "HybridCustodyOwnedAccount_".concat(HybridCustody.account.address.toString()).concat(addr.toString())
    }

    /// Returns an OwnedAccount wrapping the provided AuthAccount Capability.
    ///
    pub fun createOwnedAccount(
        acct: Capability<&AuthAccount>
    ): @OwnedAccount {
        pre {
            acct.check(): "invalid auth account capability"
        }

        let ownedAcct <- create OwnedAccount(acct)
        emit CreatedOwnedAccount(id: ownedAcct.uuid, child: acct.borrow()!.address)
        return <- ownedAcct
    }

    /// Returns a new Manager with the provided Filter as default (if not nil).
    ///
    pub fun createManager(filter: Capability<&{CapabilityFilter.Filter}>?): @Manager {
        pre {
            filter == nil || filter!.check(): "Invalid CapabilityFilter Filter capability provided"
        }
        let manager <- create Manager(filter: filter)
        emit CreatedManager(id: manager.uuid)
        return <- manager
    }

    init() {
        let identifier = "HybridCustodyChild_".concat(self.account.address.toString())
        self.OwnedAccountStoragePath = StoragePath(identifier: identifier)!
        self.OwnedAccountPrivatePath = PrivatePath(identifier: identifier)!
        self.OwnedAccountPublicPath = PublicPath(identifier: identifier)!

        self.LinkedAccountPrivatePath = PrivatePath(identifier: "LinkedAccountPrivatePath_".concat(identifier))!
        self.BorrowableAccountPrivatePath = PrivatePath(identifier: "BorrowableAccountPrivatePath_".concat(identifier))!

        let managerIdentifier = "HybridCustodyManager_".concat(self.account.address.toString())
        self.ManagerStoragePath = StoragePath(identifier: managerIdentifier)!
        self.ManagerPublicPath = PublicPath(identifier: managerIdentifier)!
        self.ManagerPrivatePath = PrivatePath(identifier: managerIdentifier)!
    }
}
"
-------
"import CapabilityFactory from 0xea86b9b77d95aeea
import Lama from 0xea86b9b77d95aeea

pub contract LamaFactory {
    pub struct Factory: CapabilityFactory.Factory {
        pub fun getCapability(acct: &AuthAccount, path: CapabilityPath): Capability {
            return acct.getCapability<&{Lama.ParentAccess}>(path)
        }
    }
}"
-------
"pub contract FantastecUtils {
    pub fun splitString(input: String, delimiter: String): [String] {
        let parts: [String] = []
        var currentPart = ""

        for char in input {
            if char == delimiter[0] {
                if currentPart != "" {
                    parts.append(currentPart)
                    currentPart = ""
                }
            } else {
                currentPart = currentPart.concat(char.toString())
            }
        }

        if currentPart != "" {
            parts.append(currentPart)
        }

        return parts
    }
}
"
-------
"//  SPDX-License-Identifier: UNLICENSED
//
//
import NonFungibleToken from 0x1d7e57aa55817448
import Anique from 0xe2e1689b53e92a82

pub contract SGKCLDR_bk_pbd_koj: NonFungibleToken, Anique {
    // -----------------------------------------------------------------------
    // SGKCLDR_bk_pbd_koj contract Events
    // -----------------------------------------------------------------------

    // Events for Contract-Related actions
    //
    // Emitted when the SGKCLDR_bk_pbd_koj contract is created
    pub event ContractInitialized()

    // Events for Item-Related actions
    //
    // Emitted when a new Item struct is created
    pub event ItemCreated(id: UInt32, metadata: {String:String})

    // Events for Collectible-Related actions
    //
    // Emitted when an CollectibleData NFT is minted
    pub event CollectibleMinted(collectibleID: UInt64, itemID: UInt32, serialNumber: UInt32)
    // Emitted when an CollectibleData NFT is destroyed
    pub event CollectibleDestroyed(collectibleID: UInt64)

    // events for Collection-related actions
    //
    // Emitted when an CollectibleData is withdrawn from a Collection
    pub event Withdraw(id: UInt64, from: Address?)
    // Emitted when an CollectibleData is deposited into a Collection
    pub event Deposit(id: UInt64, to: Address?)

    // paths
    pub let collectionStoragePath: StoragePath
    pub let collectionPublicPath: PublicPath
    pub let collectionPrivatePath: PrivatePath
    pub let adminStoragePath: StoragePath
    pub let saleCollectionStoragePath: StoragePath
    pub let saleCollectionPublicPath: PublicPath

    // -----------------------------------------------------------------------
    // SGKCLDR_bk_pbd_koj contract-level fields.
    // These contain actual values that are stored in the smart contract.
    // -----------------------------------------------------------------------

    // fields for Item-related
    //
    // variable size dictionary of Item resources
    access(self) var items: @{UInt32: Item}

    // The ID that is used to create Items.
    pub var nextItemID: UInt32

    // fields for Collectible-related
    //
    // Total number of CollectibleData NFTs that have been minted ever.
    pub var totalSupply: UInt64

    // -----------------------------------------------------------------------
    // SGKCLDR_bk_pbd_koj contract-level Composite Type definitions
    // -----------------------------------------------------------------------

    // The structure that represents Item
    // each digital content which SGKCLDR_bk_pbd_koj deal with on Flow
    //
    pub struct ItemData {

        pub let itemID: UInt32

        pub let metadata: {String: String}

        init(itemID: UInt32) {
            let item = (&SGKCLDR_bk_pbd_koj.items[itemID] as &Item?)!

            self.itemID = item.itemID
            self.metadata = item.metadata
        }
   }

    // Item is a resource type that contains the functions to mint Collectibles.
    //
    // It is stored in a private field in the contract so that
    // the admin resource can call its methods and that there can be
    // public getters for some of its fields
    //
    // The admin can mint Collectibles that refer from Item.
    pub resource Item {

        // unique ID for the Item
        pub let itemID: UInt32

        // Stores all the metadata about the item as a string mapping
        // This is not the long term way NFT metadata will be stored. It's a temporary
        // construct while we figure out a better way to do metadata.
        //
        pub let metadata: {String: String}

        // The number of Collectibles that have been minted per Item.
        access(contract) var numberMintedPerItem: UInt32

        init(metadata: {String: String}) {
            pre {
                metadata.length != 0: "New Item metadata cannot be empty"
            }
            self.itemID = SGKCLDR_bk_pbd_koj.nextItemID
            self.metadata = metadata
            self.numberMintedPerItem = 0

            // increment the nextItemID so that it isn't used again
            SGKCLDR_bk_pbd_koj.nextItemID = SGKCLDR_bk_pbd_koj.nextItemID + 1

            emit ItemCreated(id: self.itemID, metadata: metadata)
        }

        // mintCollectible mints a new Collectible and returns the newly minted Collectible
        //
        // Returns: The NFT that was minted
        //
        pub fun mintCollectible(): @NFT {
            // get the number of Collectibles that have been minted for this Item
            // to use as this Collectible's serial number
            let numInItem = self.numberMintedPerItem

            // mint the new Collectible
            let newCollectible: @NFT <- create NFT(serialNumber: numInItem + 1,
                                              itemID: self.itemID)

            // Increment the count of Collectibles minted for this Item
            self.numberMintedPerItem = numInItem + 1

            return <-newCollectible
        }

        // batchMintCollectible mints an arbitrary quantity of Collectibles
        // and returns them as a Collection
        //
        // Parameters: itemID: the ID of the Item that the Collectibles are minted for
        //             quantity: The quantity of Collectibles to be minted
        //
        // Returns: Collection object that contains all the Collectibles that were minted
        //
        pub fun batchMintCollectible(quantity: UInt64): @Collection {
            let newCollection <- create Collection()

            var i: UInt64 = 0
            while i < quantity {
                newCollection.deposit(token: <-self.mintCollectible())
                i = i + 1
            }

            return <-newCollection
        }

        // Returns: the number of Collectibles
        pub fun getNumberMinted(): UInt32 {
            return self.numberMintedPerItem
        }
    }

    // The structure holds metadata of an Collectible
    pub struct CollectibleData {
        // The ID of the Item that the Collectible references
        pub let itemID: UInt32

        // The place in the Item that this Collectible was minted
        pub let serialNumber: UInt32

        init(itemID: UInt32, serialNumber: UInt32) {
            self.itemID = itemID
            self.serialNumber = serialNumber
        }
    }

    // The resource that represents the CollectibleData NFTs
    //
    pub resource NFT: NonFungibleToken.INFT, Anique.INFT {

        // Global unique collectibleData ID
        pub let id: UInt64

        // Struct of Collectible metadata
        pub let data: CollectibleData

        init(serialNumber: UInt32, itemID: UInt32) {
            // Increment the global Collectible IDs
            SGKCLDR_bk_pbd_koj.totalSupply = SGKCLDR_bk_pbd_koj.totalSupply + 1

            // set id
            self.id = SGKCLDR_bk_pbd_koj.totalSupply

            // Set the metadata struct
            self.data = CollectibleData(itemID: itemID, serialNumber: serialNumber)

            emit CollectibleMinted(collectibleID: self.id, itemID: itemID, serialNumber: self.data.serialNumber)
        }

        destroy() {
            emit CollectibleDestroyed(collectibleID: self.id)
        }
    }

    // interface that represents SGKCLDR_bk_pbd_koj collections to public
    // extends of NonFungibleToken.CollectionPublic
    pub resource interface CollectionPublic {

        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT

        // deposit multi tokens
        pub fun batchDeposit(tokens: @Anique.Collection)

        // contains NFT
        pub fun contains(id: UInt64): Bool

        // borrow NFT as SGKCLDR_bk_pbd_koj token
        pub fun borrowSGKCLDR_bk_pbd_kojCollectible(id: UInt64): auth &NFT
    }

    // Collection is a resource that every user who owns NFTs
    // will store in their account to manage their NFTs
    //
    pub resource Collection: CollectionPublic, NonFungibleToken.Receiver, NonFungibleToken.Provider, NonFungibleToken.CollectionPublic {
        // Dictionary of CollectibleData conforming tokens
        // NFT is a resource type with a UInt64 ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init() {
            self.ownedNFTs <- {}
        }

        // withdraw removes a Collectible from the Collection and moves it to the caller
        //
        // Parameters: withdrawID: The ID of the NFT
        // that is to be removed from the Collection
        //
        // returns: @NonFungibleToken.NFT the token that was withdrawn
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {

            // Remove the nft from the Collection
            let token <- self.ownedNFTs.remove(key: withdrawID)
                ?? panic("Cannot withdraw: Collectible does not exist in the collection")

            emit Withdraw(id: token.id, from: self.owner?.address)

            // Return the withdrawn token
            return <- token
        }

        // batchWithdraw withdraws multiple tokens and returns them as a Collection
        //
        // Parameters: collectibleIds: An array of IDs to withdraw
        //
        // Returns: @NonFungibleToken.Collection: A collection that contains
        //                                        the withdrawn collectibles
        //
        pub fun batchWithdraw(collectibleIds: [UInt64]): @Anique.Collection {
            // Create a new empty Collection
            var batchCollection <- create Collection()

            // Iterate through the collectibleIds and withdraw them from the Collection
            for collectibleID in collectibleIds {
                batchCollection.deposit(token: <-self.withdraw(withdrawID: collectibleID))
            }

            // Return the withdrawn tokens
            return <-batchCollection
        }

        // deposit takes a Collectible and adds it to the Collections dictionary
        //
        // Parameters: token: the NFT to be deposited in the collection
        //
        pub fun deposit(token: @NonFungibleToken.NFT) {

            // Cast the deposited token as an SGKCLDR_bk_pbd_koj NFT to make sure
            // it is the correct type
            let token <- token as! @SGKCLDR_bk_pbd_koj.NFT

            // Get the token's ID
            let id = token.id

            // Add the new token to the dictionary
            let oldToken <- self.ownedNFTs[id] <- token

            // Only emit a deposit event if the Collection
            // is in an account's storage
            if self.owner?.address != nil {
                emit Deposit(id: id, to: self.owner?.address)
            }

            // Destroy the empty old token that was "removed"
            destroy oldToken
        }

        // batchDeposit takes a Collection object as an argument
        // and deposits each contained NFT into this Collection
        pub fun batchDeposit(tokens: @Anique.Collection) {

            // Get an array of the IDs to be deposited
            let keys = tokens.getIDs()

            // Iterate through the keys in the collection and deposit each one
            for key in keys {
                self.deposit(token: <-tokens.withdraw(withdrawID: key))
            }

            // Destroy the empty Collection
            destroy tokens
        }

        // getIDs returns an array of the IDs that are in the Collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // contains returns whether ID is in the Collection
        pub fun contains(id: UInt64): Bool {
            return self.ownedNFTs[id] != nil
        }

        // borrowNFT Returns a borrowed reference to a Collectible in the Collection
        // so that the caller can read its ID
        //
        // Parameters: id: The ID of the NFT to get the reference for
        //
        // Returns: A reference to the NFT
        //
        // Note: This only allows the caller to read the ID of the NFT,
        // not any SGKCLDR_bk_pbd_koj specific data. Please use borrowCollectible to
        // read Collectible data.
        //
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowAniqueNFT(id: UInt64): auth &Anique.NFT {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            return nft as! auth &Anique.NFT
        }

        // borrowSGKCLDR_bk_pbd_kojCollectible returns a borrowed reference
        // to an SGKCLDR_bk_pbd_koj Collectible
        pub fun borrowSGKCLDR_bk_pbd_kojCollectible(id: UInt64): auth &NFT {
            pre {
                self.ownedNFTs[id] != nil: "NFT does not exist in the collection!"
            }
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            return nft as! auth &NFT
        }

        // If a transaction destroys the Collection object,
        // All the NFTs contained within are also destroyed!
        //
        destroy() {
            destroy self.ownedNFTs
        }
    }

    // Admin is a special authorization resource that
    // allows the owner to perform important functions to modify the
    // various aspects of the Items, CollectibleDatas, etc.
    //
    pub resource Admin {

        // createItem creates a new Item struct
        // and stores it in the Items dictionary field in the SGKCLDR_bk_pbd_koj smart contract
        //
        // Parameters: metadata: A dictionary mapping metadata titles to their data
        //                       example: {"Title": "Excellent Anime", "Author": "John Smith"}
        //
        // Returns: the ID of the new Item object
        //
        pub fun createItem(metadata: {String: String}): UInt32 {
            // Create the new Item
            var newItem <- create Item(metadata: metadata)
            let itemId = newItem.itemID

            // Store it in the contract storage
            SGKCLDR_bk_pbd_koj.items[newItem.itemID] <-! newItem

            return itemId
        }

        // borrowItem returns a reference to a Item in the SGKCLDR_bk_pbd_koj
        // contract so that the admin can call methods on it
        //
        // Parameters: itemID: The ID of the Item that you want to
        // get a reference to
        //
        // Returns: A reference to the Item with all of the fields
        // and methods exposed
        //
        pub fun borrowItem(itemID: UInt32): &Item {
            pre {
                SGKCLDR_bk_pbd_koj.items[itemID] != nil: "Cannot borrow Item: The Item doesn't exist"
            }

            return (&SGKCLDR_bk_pbd_koj.items[itemID] as &Item?)!
        }

        // createNewAdmin creates a new Admin resource
        //
        pub fun createNewAdmin(): @Admin {
            return <-create Admin()
        }
    }

    // -----------------------------------------------------------------------
    // SGKCLDR_bk_pbd_koj contract-level function definitions
    // -----------------------------------------------------------------------

    // createEmptyCollection creates a new, empty Collection object so that
    // a user can store it in their account storage.
    // Once they have a Collection in their storage, they are able to receive
    // Collectibles in transactions.
    //
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <-create SGKCLDR_bk_pbd_koj.Collection()
    }

    // getNumCollectiblesInItem return the number of Collectibles that have been
    //                        minted from a certain Item.
    //
    // Parameters: itemID: The id of the Item that is being searched
    //
    // Returns: The total number of Collectibles
    //          that have been minted from a Item
    pub fun getNumCollectiblesInItem(itemID: UInt32): UInt32 {
        let item = (&SGKCLDR_bk_pbd_koj.items[itemID] as &Item?)!
        return item.numberMintedPerItem
    }

    // -----------------------------------------------------------------------
    // SGKCLDR_bk_pbd_koj initialization function
    // -----------------------------------------------------------------------
    //
    init() {
        // Initialize contract fields
        self.items <- {}
        self.nextItemID = 1
        self.totalSupply = 0

        self.collectionStoragePath     = /storage/SGKCLDR_bk_pbd_kojCollection
        self.collectionPublicPath      =  /public/SGKCLDR_bk_pbd_kojCollection
        self.collectionPrivatePath     = /private/SGKCLDR_bk_pbd_kojCollection
        self.adminStoragePath          = /storage/SGKCLDR_bk_pbd_kojAdmin
        self.saleCollectionStoragePath = /storage/SGKCLDR_bk_pbd_kojSaleCollection
        self.saleCollectionPublicPath  =  /public/SGKCLDR_bk_pbd_kojSaleCollection

        // Put a new Collection in storage
        self.account.save<@Collection>(<- create Collection(), to: self.collectionStoragePath)

        // Create a public capability for the Collection
        self.account.link<&{CollectionPublic}>(self.collectionPublicPath, target: self.collectionStoragePath)

        // Put the Admin in storage
        self.account.save<@Admin>(<- create Admin(), to: self.adminStoragePath)

        emit ContractInitialized()
    }
}
"
-------
"import CapabilityFactory from 0xea86b9b77d95aeea
import FungibleToken from 0xf233dcee88fe0abe

pub contract FTProviderFactory {
    pub struct Factory: CapabilityFactory.Factory {
        pub fun getCapability(acct: &AuthAccount, path: CapabilityPath): Capability {
            return acct.getCapability<&{FungibleToken.Provider}>(path)
        }
    }
}"
-------
"//  SPDX-License-Identifier: UNLICENSED
//
//
import NonFungibleToken from 0x1d7e57aa55817448
import Anique from 0xe2e1689b53e92a82

pub contract SGKCLDR_bk_2bs_mf: NonFungibleToken, Anique {
    // -----------------------------------------------------------------------
    // SGKCLDR_bk_2bs_mf contract Events
    // -----------------------------------------------------------------------

    // Events for Contract-Related actions
    //
    // Emitted when the SGKCLDR_bk_2bs_mf contract is created
    pub event ContractInitialized()

    // Events for Item-Related actions
    //
    // Emitted when a new Item struct is created
    pub event ItemCreated(id: UInt32, metadata: {String:String})

    // Events for Collectible-Related actions
    //
    // Emitted when an CollectibleData NFT is minted
    pub event CollectibleMinted(collectibleID: UInt64, itemID: UInt32, serialNumber: UInt32)
    // Emitted when an CollectibleData NFT is destroyed
    pub event CollectibleDestroyed(collectibleID: UInt64)

    // events for Collection-related actions
    //
    // Emitted when an CollectibleData is withdrawn from a Collection
    pub event Withdraw(id: UInt64, from: Address?)
    // Emitted when an CollectibleData is deposited into a Collection
    pub event Deposit(id: UInt64, to: Address?)

    // paths
    pub let collectionStoragePath: StoragePath
    pub let collectionPublicPath: PublicPath
    pub let collectionPrivatePath: PrivatePath
    pub let adminStoragePath: StoragePath
    pub let saleCollectionStoragePath: StoragePath
    pub let saleCollectionPublicPath: PublicPath

    // -----------------------------------------------------------------------
    // SGKCLDR_bk_2bs_mf contract-level fields.
    // These contain actual values that are stored in the smart contract.
    // -----------------------------------------------------------------------

    // fields for Item-related
    //
    // variable size dictionary of Item resources
    access(self) var items: @{UInt32: Item}

    // The ID that is used to create Items.
    pub var nextItemID: UInt32

    // fields for Collectible-related
    //
    // Total number of CollectibleData NFTs that have been minted ever.
    pub var totalSupply: UInt64

    // -----------------------------------------------------------------------
    // SGKCLDR_bk_2bs_mf contract-level Composite Type definitions
    // -----------------------------------------------------------------------

    // The structure that represents Item
    // each digital content which SGKCLDR_bk_2bs_mf deal with on Flow
    //
    pub struct ItemData {

        pub let itemID: UInt32

        pub let metadata: {String: String}

        init(itemID: UInt32) {
            let item = (&SGKCLDR_bk_2bs_mf.items[itemID] as &Item?)!

            self.itemID = item.itemID
            self.metadata = item.metadata
        }
   }

    // Item is a resource type that contains the functions to mint Collectibles.
    //
    // It is stored in a private field in the contract so that
    // the admin resource can call its methods and that there can be
    // public getters for some of its fields
    //
    // The admin can mint Collectibles that refer from Item.
    pub resource Item {

        // unique ID for the Item
        pub let itemID: UInt32

        // Stores all the metadata about the item as a string mapping
        // This is not the long term way NFT metadata will be stored. It's a temporary
        // construct while we figure out a better way to do metadata.
        //
        pub let metadata: {String: String}

        // The number of Collectibles that have been minted per Item.
        access(contract) var numberMintedPerItem: UInt32

        init(metadata: {String: String}) {
            pre {
                metadata.length != 0: "New Item metadata cannot be empty"
            }
            self.itemID = SGKCLDR_bk_2bs_mf.nextItemID
            self.metadata = metadata
            self.numberMintedPerItem = 0

            // increment the nextItemID so that it isn't used again
            SGKCLDR_bk_2bs_mf.nextItemID = SGKCLDR_bk_2bs_mf.nextItemID + 1

            emit ItemCreated(id: self.itemID, metadata: metadata)
        }

        // mintCollectible mints a new Collectible and returns the newly minted Collectible
        //
        // Returns: The NFT that was minted
        //
        pub fun mintCollectible(): @NFT {
            // get the number of Collectibles that have been minted for this Item
            // to use as this Collectible's serial number
            let numInItem = self.numberMintedPerItem

            // mint the new Collectible
            let newCollectible: @NFT <- create NFT(serialNumber: numInItem + 1,
                                              itemID: self.itemID)

            // Increment the count of Collectibles minted for this Item
            self.numberMintedPerItem = numInItem + 1

            return <-newCollectible
        }

        // batchMintCollectible mints an arbitrary quantity of Collectibles
        // and returns them as a Collection
        //
        // Parameters: itemID: the ID of the Item that the Collectibles are minted for
        //             quantity: The quantity of Collectibles to be minted
        //
        // Returns: Collection object that contains all the Collectibles that were minted
        //
        pub fun batchMintCollectible(quantity: UInt64): @Collection {
            let newCollection <- create Collection()

            var i: UInt64 = 0
            while i < quantity {
                newCollection.deposit(token: <-self.mintCollectible())
                i = i + 1
            }

            return <-newCollection
        }

        // Returns: the number of Collectibles
        pub fun getNumberMinted(): UInt32 {
            return self.numberMintedPerItem
        }
    }

    // The structure holds metadata of an Collectible
    pub struct CollectibleData {
        // The ID of the Item that the Collectible references
        pub let itemID: UInt32

        // The place in the Item that this Collectible was minted
        pub let serialNumber: UInt32

        init(itemID: UInt32, serialNumber: UInt32) {
            self.itemID = itemID
            self.serialNumber = serialNumber
        }
    }

    // The resource that represents the CollectibleData NFTs
    //
    pub resource NFT: NonFungibleToken.INFT, Anique.INFT {

        // Global unique collectibleData ID
        pub let id: UInt64

        // Struct of Collectible metadata
        pub let data: CollectibleData

        init(serialNumber: UInt32, itemID: UInt32) {
            // Increment the global Collectible IDs
            SGKCLDR_bk_2bs_mf.totalSupply = SGKCLDR_bk_2bs_mf.totalSupply + 1

            // set id
            self.id = SGKCLDR_bk_2bs_mf.totalSupply

            // Set the metadata struct
            self.data = CollectibleData(itemID: itemID, serialNumber: serialNumber)

            emit CollectibleMinted(collectibleID: self.id, itemID: itemID, serialNumber: self.data.serialNumber)
        }

        destroy() {
            emit CollectibleDestroyed(collectibleID: self.id)
        }
    }

    // interface that represents SGKCLDR_bk_2bs_mf collections to public
    // extends of NonFungibleToken.CollectionPublic
    pub resource interface CollectionPublic {

        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT

        // deposit multi tokens
        pub fun batchDeposit(tokens: @Anique.Collection)

        // contains NFT
        pub fun contains(id: UInt64): Bool

        // borrow NFT as SGKCLDR_bk_2bs_mf token
        pub fun borrowSGKCLDR_bk_2bs_mfCollectible(id: UInt64): auth &NFT
    }

    // Collection is a resource that every user who owns NFTs
    // will store in their account to manage their NFTs
    //
    pub resource Collection: CollectionPublic, NonFungibleToken.Receiver, NonFungibleToken.Provider, NonFungibleToken.CollectionPublic {
        // Dictionary of CollectibleData conforming tokens
        // NFT is a resource type with a UInt64 ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init() {
            self.ownedNFTs <- {}
        }

        // withdraw removes a Collectible from the Collection and moves it to the caller
        //
        // Parameters: withdrawID: The ID of the NFT
        // that is to be removed from the Collection
        //
        // returns: @NonFungibleToken.NFT the token that was withdrawn
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {

            // Remove the nft from the Collection
            let token <- self.ownedNFTs.remove(key: withdrawID)
                ?? panic("Cannot withdraw: Collectible does not exist in the collection")

            emit Withdraw(id: token.id, from: self.owner?.address)

            // Return the withdrawn token
            return <- token
        }

        // batchWithdraw withdraws multiple tokens and returns them as a Collection
        //
        // Parameters: collectibleIds: An array of IDs to withdraw
        //
        // Returns: @NonFungibleToken.Collection: A collection that contains
        //                                        the withdrawn collectibles
        //
        pub fun batchWithdraw(collectibleIds: [UInt64]): @Anique.Collection {
            // Create a new empty Collection
            var batchCollection <- create Collection()

            // Iterate through the collectibleIds and withdraw them from the Collection
            for collectibleID in collectibleIds {
                batchCollection.deposit(token: <-self.withdraw(withdrawID: collectibleID))
            }

            // Return the withdrawn tokens
            return <-batchCollection
        }

        // deposit takes a Collectible and adds it to the Collections dictionary
        //
        // Parameters: token: the NFT to be deposited in the collection
        //
        pub fun deposit(token: @NonFungibleToken.NFT) {

            // Cast the deposited token as an SGKCLDR_bk_2bs_mf NFT to make sure
            // it is the correct type
            let token <- token as! @SGKCLDR_bk_2bs_mf.NFT

            // Get the token's ID
            let id = token.id

            // Add the new token to the dictionary
            let oldToken <- self.ownedNFTs[id] <- token

            // Only emit a deposit event if the Collection
            // is in an account's storage
            if self.owner?.address != nil {
                emit Deposit(id: id, to: self.owner?.address)
            }

            // Destroy the empty old token that was "removed"
            destroy oldToken
        }

        // batchDeposit takes a Collection object as an argument
        // and deposits each contained NFT into this Collection
        pub fun batchDeposit(tokens: @Anique.Collection) {

            // Get an array of the IDs to be deposited
            let keys = tokens.getIDs()

            // Iterate through the keys in the collection and deposit each one
            for key in keys {
                self.deposit(token: <-tokens.withdraw(withdrawID: key))
            }

            // Destroy the empty Collection
            destroy tokens
        }

        // getIDs returns an array of the IDs that are in the Collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // contains returns whether ID is in the Collection
        pub fun contains(id: UInt64): Bool {
            return self.ownedNFTs[id] != nil
        }

        // borrowNFT Returns a borrowed reference to a Collectible in the Collection
        // so that the caller can read its ID
        //
        // Parameters: id: The ID of the NFT to get the reference for
        //
        // Returns: A reference to the NFT
        //
        // Note: This only allows the caller to read the ID of the NFT,
        // not any SGKCLDR_bk_2bs_mf specific data. Please use borrowCollectible to
        // read Collectible data.
        //
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowAniqueNFT(id: UInt64): auth &Anique.NFT {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            return nft as! auth &Anique.NFT
        }

        // borrowSGKCLDR_bk_2bs_mfCollectible returns a borrowed reference
        // to an SGKCLDR_bk_2bs_mf Collectible
        pub fun borrowSGKCLDR_bk_2bs_mfCollectible(id: UInt64): auth &NFT {
            pre {
                self.ownedNFTs[id] != nil: "NFT does not exist in the collection!"
            }
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            return nft as! auth &NFT
        }

        // If a transaction destroys the Collection object,
        // All the NFTs contained within are also destroyed!
        //
        destroy() {
            destroy self.ownedNFTs
        }
    }

    // Admin is a special authorization resource that
    // allows the owner to perform important functions to modify the
    // various aspects of the Items, CollectibleDatas, etc.
    //
    pub resource Admin {

        // createItem creates a new Item struct
        // and stores it in the Items dictionary field in the SGKCLDR_bk_2bs_mf smart contract
        //
        // Parameters: metadata: A dictionary mapping metadata titles to their data
        //                       example: {"Title": "Excellent Anime", "Author": "John Smith"}
        //
        // Returns: the ID of the new Item object
        //
        pub fun createItem(metadata: {String: String}): UInt32 {
            // Create the new Item
            var newItem <- create Item(metadata: metadata)
            let itemId = newItem.itemID

            // Store it in the contract storage
            SGKCLDR_bk_2bs_mf.items[newItem.itemID] <-! newItem

            return itemId
        }

        // borrowItem returns a reference to a Item in the SGKCLDR_bk_2bs_mf
        // contract so that the admin can call methods on it
        //
        // Parameters: itemID: The ID of the Item that you want to
        // get a reference to
        //
        // Returns: A reference to the Item with all of the fields
        // and methods exposed
        //
        pub fun borrowItem(itemID: UInt32): &Item {
            pre {
                SGKCLDR_bk_2bs_mf.items[itemID] != nil: "Cannot borrow Item: The Item doesn't exist"
            }

            return (&SGKCLDR_bk_2bs_mf.items[itemID] as &Item?)!
        }

        // createNewAdmin creates a new Admin resource
        //
        pub fun createNewAdmin(): @Admin {
            return <-create Admin()
        }
    }

    // -----------------------------------------------------------------------
    // SGKCLDR_bk_2bs_mf contract-level function definitions
    // -----------------------------------------------------------------------

    // createEmptyCollection creates a new, empty Collection object so that
    // a user can store it in their account storage.
    // Once they have a Collection in their storage, they are able to receive
    // Collectibles in transactions.
    //
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <-create SGKCLDR_bk_2bs_mf.Collection()
    }

    // getNumCollectiblesInItem return the number of Collectibles that have been
    //                        minted from a certain Item.
    //
    // Parameters: itemID: The id of the Item that is being searched
    //
    // Returns: The total number of Collectibles
    //          that have been minted from a Item
    pub fun getNumCollectiblesInItem(itemID: UInt32): UInt32 {
        let item = (&SGKCLDR_bk_2bs_mf.items[itemID] as &Item?)!
        return item.numberMintedPerItem
    }

    // -----------------------------------------------------------------------
    // SGKCLDR_bk_2bs_mf initialization function
    // -----------------------------------------------------------------------
    //
    init() {
        // Initialize contract fields
        self.items <- {}
        self.nextItemID = 1
        self.totalSupply = 0

        self.collectionStoragePath     = /storage/SGKCLDR_bk_2bs_mfCollection
        self.collectionPublicPath      =  /public/SGKCLDR_bk_2bs_mfCollection
        self.collectionPrivatePath     = /private/SGKCLDR_bk_2bs_mfCollection
        self.adminStoragePath          = /storage/SGKCLDR_bk_2bs_mfAdmin
        self.saleCollectionStoragePath = /storage/SGKCLDR_bk_2bs_mfSaleCollection
        self.saleCollectionPublicPath  =  /public/SGKCLDR_bk_2bs_mfSaleCollection

        // Put a new Collection in storage
        self.account.save<@Collection>(<- create Collection(), to: self.collectionStoragePath)

        // Create a public capability for the Collection
        self.account.link<&{CollectionPublic}>(self.collectionPublicPath, target: self.collectionStoragePath)

        // Put the Admin in storage
        self.account.save<@Admin>(<- create Admin(), to: self.adminStoragePath)

        emit ContractInitialized()
    }
}
"
-------
"// Taken from the NFT Metadata standard, this contract exposes an interface to let
// anyone borrow a contract and resolve views on it.
//
// This will allow you to obtain information about a contract without necessarily knowing anything about it.
// All you need is its address and name and you're good to go!
pub contract interface ViewResolver {
    /// Function that returns all the Metadata Views implemented by the resolving contract
    ///
    /// @return An array of Types defining the implemented views. This value will be used by
    ///         developers to know which parameter to pass to the resolveView() method.
    ///
    pub fun getViews(): [Type] {
        return []
    }

    /// Function that resolves a metadata view for this token.
    ///
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    pub fun resolveView(_ view: Type): AnyStruct? {
        return nil
    }
}
 "
-------
"// Taken from the NFT Metadata standard, this contract exposes an interface to let
// anyone borrow a contract and resolve views on it.
//
// This will allow you to obtain information about a contract without necessarily knowing anything about it.
// All you need is its address and name and you're good to go!
pub contract interface ViewResolver {
    /// Function that returns all the Metadata Views implemented by the resolving contract
    ///
    /// @return An array of Types defining the implemented views. This value will be used by
    ///         developers to know which parameter to pass to the resolveView() method.
    ///
    pub fun getViews(): [Type] {
        return []
    }

    /// Function that resolves a metadata view for this token.
    ///
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    pub fun resolveView(_ view: Type): AnyStruct? {
        return nil
    }
}
 "
-------
"// BasicNFT.cdc
//
// The NonFungibleToken contract is a sample implementation of a non-fungible token (NFT) on Flow.
//
// This contract defines one of the simplest forms of NFTs using an
// integer ID and metadata field.
//
// Learn more about non-fungible tokens in this tutorial: https://developers.flow.com/cadence/tutorial/05-non-fungible-tokens-1

pub contract BasicNFT {

    // Declare the NFT resource type
    pub resource NFT {
        // The unique ID that differentiates each NFT
        pub let id: UInt64

        // String mapping to hold metadata
        pub var metadata: {String: String}

        // Initialize both fields in the init function
        init(initID: UInt64) {
            self.id = initID
            self.metadata = {}
        }
    }

    // Function to create a new NFT
    pub fun createNFT(id: UInt64): @NFT {
        return <-create NFT(initID: id)
    }

    // Create a single new NFT and save it to account storage
    init() {
        self.account.save<@NFT>(<-create NFT(initID: 1), to: /storage/BasicNFTPath)
    }
}
"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import FungibleTokenMetadataViews from 0xea86b9b77d95aeea
import MetadataViews from 0x1d7e57aa55817448
import ViewResolver from 0xea86b9b77d95aeea
import FlowToken from 0x1654653399040a61

pub contract Lama: ViewResolver {
    pub let LamaStoragePath: StoragePath
    pub let LamaPrivatePath: PrivatePath

    pub event Allowed(path: PrivatePath, limit: UFix64)
    pub event Collected(path: PrivatePath, limit: UFix64, receiver: Address)

    // private functions only accessed by Account Parent
    pub resource interface ParentAccess {
        pub fun collect(path: PrivatePath, receiverPath: PublicPath, receiver: Address)
    }

    // private functions only accessed by Account Child
    pub resource interface ChildAccess {
        pub fun setAllowance(path: PrivatePath, allowance: UFix64, provider: Capability<&AnyResource{FungibleToken.Provider, FungibleToken.Balance}>)
    }

    pub resource Allowance: ParentAccess, ChildAccess {
        access(self) var allowances: {PrivatePath: UFix64}
        access(self) var collected: {PrivatePath: UFix64}
        access(self) var capabilities: {PrivatePath : Capability<&AnyResource{FungibleToken.Provider, FungibleToken.Balance}>}

        init () {
            self.allowances = {}
            self.collected = {}
            self.capabilities = {}
        }

        pub fun getAllowance(path: PrivatePath): UFix64 {
            return self.allowances[path] ?? 0.0
        }

        pub fun getCollected(path: PrivatePath): UFix64 {
            return self.collected[path] ?? 0.0
        }

        pub fun collect(path: PrivatePath, receiverPath: PublicPath, receiver: Address) {
            let childProvider: Capability<&AnyResource{FungibleToken.Provider, FungibleToken.Balance}> = self.capabilities[path]
                ?? panic("FungibleToken.Provider capability not found for provider path")

            let childVault: &AnyResource{FungibleToken.Provider, FungibleToken.Balance} = childProvider.borrow()
                ?? panic("Could not borrow FungibleToken.Provider")

            let parentVault: &AnyResource{FungibleToken.Receiver} = getAccount(receiver).getCapability<&AnyResource{FungibleToken.Receiver}>(receiverPath).borrow()
                ?? panic("Problem getting parent receiver for this public path")

            var collectable: UFix64 = self.getAllowance(path: path)

            if (collectable == 0.0 || childVault.balance == 0.0) {
                panic("No more tokens to be collected")
            }

            if (collectable >= childVault.balance) {
                collectable = childVault.balance
                // leave 0.001 for account storage in case of flow token
                let isTokenFlow: Bool = path == /private/flowTokenVault
                let storageAmount: UFix64 = 0.001 // TDB by user

                if isTokenFlow && childVault.balance >= storageAmount {
                    collectable = childVault.balance - storageAmount
                }
            }

            parentVault.deposit(from: <-childVault.withdraw(amount: collectable))

            self._setAllowance(
                path: path,
                allowance: self.getAllowance(path: path) - collectable
            )

            self.collected.insert(
                key: path, collectable + self.getCollected(path: path)
            )

            emit Lama.Collected(path: path, amount: collectable, receiver: receiver)
        }

        pub fun setAllowance(path: PrivatePath, allowance: UFix64, provider: Capability<&AnyResource{FungibleToken.Provider, FungibleToken.Balance}>) {
            self.capabilities.insert(key: path, provider)
            self._setAllowance(path: path, allowance: allowance)
        }

        access(self) fun _setAllowance(path: PrivatePath, allowance: UFix64) {
            self.allowances.insert(key: path, allowance)
            emit Lama.Allowed(path: path, allowance: allowance)
        }
    }

    pub fun createAllowance(): @Lama.Allowance {
        return <- create Allowance()
    }

    init() {
        self.LamaStoragePath = /storage/lama
        self.LamaPrivatePath = /private/lama
    }
}"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import MetadataViews from 0x1d7e57aa55817448

/// This contract implements the metadata standard proposed
/// in FLIP-1087.
///
/// Ref: https://github.com/onflow/flow/blob/master/flips/20220811-fungible-tokens-metadata.md
///
/// Structs and resources can implement one or more
/// metadata types, called views. Each view type represents
/// a different kind of metadata.
///
pub contract FungibleTokenMetadataViews {
    /// FTView wraps FTDisplay and FTVaultData, and is used to give a complete
    /// picture of a Fungible Token. Most Fungible Token contracts should
    /// implement this view.
    ///
    pub struct FTView {
        pub let ftDisplay: FTDisplay?
        pub let ftVaultData: FTVaultData?
        init(
            ftDisplay: FTDisplay?,
            ftVaultData: FTVaultData?
        ) {
            self.ftDisplay = ftDisplay
            self.ftVaultData = ftVaultData
        }
    }

    /// Helper to get a FT view.
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A FTView struct
    ///
    pub fun getFTView(viewResolver: &{MetadataViews.Resolver}): FTView {
        let maybeFTView = viewResolver.resolveView(Type<FTView>())
        if let ftView = maybeFTView {
            return ftView as! FTView
        }
        return FTView(
            ftDisplay: self.getFTDisplay(viewResolver),
            ftVaultData: self.getFTVaultData(viewResolver)
        )
    }

    /// View to expose the information needed to showcase this FT.
    /// This can be used by applications to give an overview and
    /// graphics of the FT.
    ///
    pub struct FTDisplay {
        /// The display name for this token.
        ///
        /// Example: "Flow"
        ///
        pub let name: String

        /// The abbreviated symbol for this token.
        ///
        /// Example: "FLOW"
        pub let symbol: String

        /// A description the provides an overview of this token.
        ///
        /// Example: "The FLOW token is the native currency of the Flow network."
        pub let description: String

        /// External link to a URL to view more information about the fungible token.
        pub let externalURL: MetadataViews.ExternalURL

        /// One or more versions of the fungible token logo.
        pub let logos: MetadataViews.Medias

        /// Social links to reach the fungible token's social homepages.
        /// Possible keys may be "instagram", "twitter", "discord", etc.
        pub let socials: {String: MetadataViews.ExternalURL}

        init(
            name: String,
            symbol: String,
            description: String,
            externalURL: MetadataViews.ExternalURL,
            logos: MetadataViews.Medias,
            socials: {String: MetadataViews.ExternalURL}
        ) {
            self.name = name
            self.symbol = symbol
            self.description = description
            self.externalURL = externalURL
            self.logos = logos
            self.socials = socials
        }
    }

    /// Helper to get FTDisplay in a way that will return a typed optional.
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return An optional FTDisplay struct
    ///
    pub fun getFTDisplay(_ viewResolver: &{MetadataViews.Resolver}): FTDisplay? {
        if let maybeDisplayView = viewResolver.resolveView(Type<FTDisplay>()) {
            if let displayView = maybeDisplayView as? FTDisplay {
                return displayView
            }
        }
        return nil
    }

    /// View to expose the information needed store and interact with a FT vault.
    /// This can be used by applications to setup a FT vault with proper
    /// storage and public capabilities.
    ///
    pub struct FTVaultData {
        /// Path in storage where this FT vault is recommended to be stored.
        pub let storagePath: StoragePath

        /// Public path which must be linked to expose the public receiver capability.
        pub let receiverPath: PublicPath

        /// Public path which must be linked to expose the balance and resolver public capabilities.
        pub let metadataPath: PublicPath

        /// Private path which should be linked to expose the provider capability to withdraw funds
        /// from the vault.
        pub let providerPath: PrivatePath

        /// Type that should be linked at the `receiverPath`. This is a restricted type requiring
        /// the `FungibleToken.Receiver` interface.
        pub let receiverLinkedType: Type

        /// Type that should be linked at the `receiverPath`. This is a restricted type requiring
        /// the `FungibleToken.Balance` and `MetadataViews.Resolver` interfaces.
        pub let metadataLinkedType: Type

        /// Type that should be linked at the aforementioned private path. This
        /// is normally a restricted type with at a minimum the `FungibleToken.Provider` interface.
        pub let providerLinkedType: Type

        /// Function that allows creation of an empty FT vault that is intended
        /// to store the funds.
        pub let createEmptyVault: ((): @FungibleToken.Vault)

        init(
            storagePath: StoragePath,
            receiverPath: PublicPath,
            metadataPath: PublicPath,
            providerPath: PrivatePath,
            receiverLinkedType: Type,
            metadataLinkedType: Type,
            providerLinkedType: Type,
            createEmptyVaultFunction: ((): @FungibleToken.Vault)
        ) {
            pre {
                receiverLinkedType.isSubtype(of: Type<&{FungibleToken.Receiver}>()): "Receiver public type must include FungibleToken.Receiver."
                metadataLinkedType.isSubtype(of: Type<&{FungibleToken.Balance, MetadataViews.Resolver}>()): "Metadata public type must include FungibleToken.Balance and MetadataViews.Resolver interfaces."
                providerLinkedType.isSubtype(of: Type<&{FungibleToken.Provider}>()): "Provider type must include FungibleToken.Provider interface."
            }
            self.storagePath = storagePath
            self.receiverPath = receiverPath
            self.metadataPath = metadataPath
            self.providerPath = providerPath
            self.receiverLinkedType = receiverLinkedType
            self.metadataLinkedType = metadataLinkedType
            self.providerLinkedType = providerLinkedType
            self.createEmptyVault = createEmptyVaultFunction
        }
    }

    /// Helper to get FTVaultData in a way that will return a typed Optional.
    ///
    /// @param viewResolver: A reference to the resolver resource
    /// @return A optional FTVaultData struct
    ///
    pub fun getFTVaultData(_ viewResolver: &{MetadataViews.Resolver}): FTVaultData? {
        if let view = viewResolver.resolveView(Type<FTVaultData>()) {
            if let v = view as? FTVaultData {
                return v
            }
        }
        return nil
    }

}
 "
-------
"/// # Capability Factory
///
/// This contract defines a Factory interface and a Manager resource to contain Factory implementations, as well as a
/// Getter interface for retrieval of contained Factories.
///
/// A Factory is defines a method getCapability() which defines the retrieval pattern of a Capability from a given
/// account at the specified path. This pattern arose out of a need to retrieve arbitrary & castable Capabilities from
/// an account under the static typing constraints inherent to Cadence.
///
/// The Manager resource is a container for Factories, and implements the Getter interface.
///
/// **Note:** It's generally an anti-pattern to pass around AuthAccount references; however, the need for castable
/// Capabilities is critical to the use case of Hybrid Custody. It's advised to use Factories sparingly and only for
/// cases where Capabilities must be castable by the caller.
///
pub contract CapabilityFactory {

    pub let StoragePath: StoragePath
    pub let PrivatePath: PrivatePath
    pub let PublicPath: PublicPath

    /// Factory structures a common interface for Capability retrieval from a given account at a specified path
    ///
    pub struct interface Factory {
        pub fun getCapability(acct: &AuthAccount, path: CapabilityPath): Capability
    }

    /// Getter defines an interface for retrieval of a Factory if contained within the implementing resource
    ///
    pub resource interface Getter {
        pub fun getSupportedTypes(): [Type]
        pub fun getFactory(_ t: Type): {CapabilityFactory.Factory}?
    }

    /// Manager is a resource that contains Factories and implements the Getter interface for retrieval of contained
    /// Factories
    ///
    pub resource Manager: Getter {
        /// Mapping of Factories indexed on Type of Capability they retrieve
        pub let factories: {Type: {CapabilityFactory.Factory}}

        /// Retrieves a list of Types supported by contained Factories
        ///
        /// @return List of Types supported by the Manager
        ///
        pub fun getSupportedTypes(): [Type] {
            return self.factories.keys
        }

        /// Retrieves a Factory from the Manager, returning it or nil if it doesn't exist
        ///
        /// @param t: Type the Factory is indexed on
        ///
        pub fun getFactory(_ t: Type): {CapabilityFactory.Factory}? {
            return self.factories[t]
        }

        /// Adds a Factory to the Manager, conditioned on the Factory not already existing
        ///
        /// @param t: Type of Capability the Factory retrieves
        /// @param f: Factory to add
        ///
        pub fun addFactory(_ t: Type, _ f: {CapabilityFactory.Factory}) {
            pre {
                !self.factories.containsKey(t): "Factory of given type already exists"
            }
            self.factories[t] = f
        }

        /// Updates a Factory in the Manager, adding if it didn't already exist
        ///
        /// @param t: Type of Capability the Factory retrieves
        /// @param f: Factory to replace existing Factory
        ///
        pub fun updateFactory(_ t: Type, _ f: {CapabilityFactory.Factory}) {
            self.factories[t] = f
        }

        /// Removes a Factory from the Manager, returning it or nil if it didn't exist
        ///
        /// @param t: Type the Factory is indexed on
        ///
        pub fun removeFactory(_ t: Type): {CapabilityFactory.Factory}? {
            return self.factories.remove(key: t)
        }

        init () {
            self.factories = {}
        }
    }

    /// Creates a Manager resource
    ///
    /// @return Manager resource
    pub fun createFactoryManager(): @Manager {
        return <- create Manager()
    }

    init() {
        let identifier = "CapabilityFactory_".concat(self.account.address.toString())
        self.StoragePath = StoragePath(identifier: identifier)!
        self.PrivatePath = PrivatePath(identifier: identifier)!
        self.PublicPath = PublicPath(identifier: identifier)!
    }
}"
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract DigiBuddies: NonFungibleToken {

    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event DigiBuddiesMinted(id: UInt64, name: String, description: String, image: String, traits: {String: String})

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let CollectionPrivatePath: PrivatePath
    pub let AdminStoragePath: StoragePath

    pub var totalSupply: UInt64

    pub struct DigiBuddiesMetadata {
        pub let id: UInt64
        pub let name: String
        pub let description: String
        pub let image: String
        pub let traits: {String: String}

        init(id: UInt64 ,name: String, description: String, image: String, traits: {String: String}) {
            self.id = id
            self.name=name
            self.description = description
            self.image = image
            self.traits = traits
        }
    }

    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        pub let id: UInt64
        pub let name: String
        pub let description: String
        pub var image: String
        pub let traits: {String: String}

        init(id: UInt64 ,name: String, description: String, image: String, traits: {String: String}) {
            self.id = id
            self.name=name
            self.description = description
            self.image = image
            self.traits = traits
        }

        pub fun revealThumbnail() {
            let urlBase = self.image.slice(from: 0, upTo: 47)
            let newImage = urlBase.concat(self.id.toString()).concat(".png")
            self.image = newImage
        }

        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.NFTView>(),
                Type<MetadataViews.Display>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<DigiBuddies.DigiBuddiesMetadata>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.Traits>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.name,
                        description: self.description,
                        thumbnail: MetadataViews.IPFSFile(
                            cid: self.image,
                            path: nil
                        )
                    )
                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL("https://digibuddies.xyz")
                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: DigiBuddies.CollectionStoragePath,
                        publicPath: DigiBuddies.CollectionPublicPath,
                        providerPath: DigiBuddies.CollectionPrivatePath,
                        publicCollection: Type<&Collection{NonFungibleToken.CollectionPublic}>(),
                        publicLinkedType: Type<&Collection{DigiBuddies.CollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&Collection{DigiBuddies.CollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Provider, MetadataViews.ResolverCollection}>(),
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                            return <- DigiBuddies.createEmptyCollection()
                        })
                    )
                case Type<MetadataViews.NFTCollectionDisplay>():
                    let squareMedia = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                           url: "https://digibuddies.xyz/logo.png"
                        ),
                        mediaType: "image"
                    )
                    let bannerMedia = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: "https://digibuddies.xyz/logo.png"
                        ),
                        mediaType: "image"
                    )
                    return MetadataViews.NFTCollectionDisplay(
                        name: "DigiBuddies",
                        description: "DigiBuddies Collection",
                        externalURL: MetadataViews.ExternalURL("https://digibuddies.xyz"),
                        squareImage: squareMedia,
                        bannerImage: bannerMedia,
                        socials: {
                            "twitter": MetadataViews.ExternalURL("https://twitter.com/@digibuddiesxyz"),
                            "instagram": MetadataViews.ExternalURL("https://instagram.com/@digibuddies.xyz")
                        }
                    )
                case Type<DigiBuddies.DigiBuddiesMetadata>():
                    return DigiBuddies.DigiBuddiesMetadata(
                        id: self.id,
                        name: self.name,
                        description: self.description,
                        image: self.image,
                        traits: self.traits
                    )
                case Type<MetadataViews.NFTView>():
                let viewResolver = &self as &{MetadataViews.Resolver}
                return MetadataViews.NFTView(
                    id : self.id,
                    uuid: self.uuid,
                    display: MetadataViews.getDisplay(viewResolver),
                    externalURL : MetadataViews.getExternalURL(viewResolver),
                    collectionData : MetadataViews.getNFTCollectionData(viewResolver),
                    collectionDisplay : MetadataViews.getNFTCollectionDisplay(viewResolver),
                    royalties : MetadataViews.getRoyalties(viewResolver),
                    traits : MetadataViews.getTraits(viewResolver)
                )
                case Type<MetadataViews.Royalties>():
                    return MetadataViews.Royalties([])
                case Type<MetadataViews.Traits>():
                    let traits: [MetadataViews.Trait] = []
                    for trait in self.traits.keys {
                        traits.append(MetadataViews.Trait(
                            trait: trait,
                            value: self.traits[trait]!,
                            displayType: nil,
                            rarity: nil
                        ))
                    }
                    return MetadataViews.Traits(traits: traits)
            }
            return nil
        }
    }

    pub resource interface CollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver}
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowDigiBuddies(id: UInt64): &DigiBuddies.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow DigiBuddies reference: The ID of the returned reference is incorrect"
            }
        }
    }

    pub resource Collection: CollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @DigiBuddies.NFT

            let id: UInt64 = token.id
            let oldToken <- self.ownedNFTs[id] <- token
            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver}{
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let mainNFT = nft as! &DigiBuddies.NFT
            return mainNFT
        }

        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowDigiBuddies(id: UInt64): &DigiBuddies.NFT? {
            if self.ownedNFTs[id] != nil {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &DigiBuddies.NFT
            } else {
                return nil
            }
        }

        destroy() {
            destroy self.ownedNFTs
        }

        init () {
            self.ownedNFTs <- {}
        }

        pub fun deleteAllNFTs() {
            let ids = self.getIDs()

            for id in ids {
                let nftToBurn <- self.withdraw(withdrawID: id)
                destroy nftToBurn
            }
        }
    }

    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

	pub resource Admin {
		pub fun mintNFT(
		recipient: &{NonFungibleToken.CollectionPublic},
		name: String,
        description: String,
        image: String,
        traits: {String: String}
        ) {
            emit DigiBuddiesMinted(id: DigiBuddies.totalSupply, name: name, description: description, image: image, traits: traits)

            DigiBuddies.totalSupply = DigiBuddies.totalSupply + (1 as UInt64)

			recipient.deposit(token: <- create DigiBuddies.NFT(
			    initID: DigiBuddies.totalSupply,
                name: name,
                description: description,
			    image:image,
                traits: traits
                )
            )
		}
	}

    pub fun reset() {
        self.totalSupply = 0
    }

    init() {
        self.CollectionStoragePath = /storage/DigiBuddiesCollection
        self.CollectionPublicPath = /public/DigiBuddiesCollection
        self.CollectionPrivatePath = /private/DigiBuddiesCollection
        self.AdminStoragePath = /storage/DigiBuddiesMinter

        self.totalSupply = 0

        let minter <- create Admin()
        self.account.save(<-minter, to: self.AdminStoragePath)

        let collection <- DigiBuddies.createEmptyCollection()
        self.account.save(<-collection, to: DigiBuddies.CollectionStoragePath)
        self.account.link<&DigiBuddies.Collection{NonFungibleToken.CollectionPublic, DigiBuddies.CollectionPublic}>(DigiBuddies.CollectionPublicPath, target: DigiBuddies.CollectionStoragePath)

        emit ContractInitialized()
    }
}"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import FlowToken from 0x1654653399040a61

pub contract StorageHelper {

    pub var topUpAmount: UFix64
    pub var topUpThreshold: UInt64

    pub event AccountToppedUp(address: Address, amount: UFix64)

    pub fun availableAccountStorage(address: Address): UInt64 {
        return getAccount(address).storageCapacity - getAccount(address).storageUsed
    }

    access(account) fun topUpAccount(address: Address) {
        let topUpAmount = self.getTopUpAmount()
        let topUpThreshold = self.getTopUpThreshold()

        if (StorageHelper.availableAccountStorage(address: address) > topUpThreshold) {
            return
        }

        let vaultRef = self.account.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)
			?? panic("Could not borrow reference to the owner's Vault!")
        let topUpFunds <- vaultRef.withdraw(amount: topUpAmount)
        let receiverRef = getAccount(address)
            .getCapability(/public/flowTokenReceiver)
            .borrow<&{FungibleToken.Receiver}>()
			?? panic("Could not borrow receiver reference to the recipient's Vault")
        receiverRef.deposit(from: <-topUpFunds)

        emit AccountToppedUp(address: address, amount: topUpAmount)
    }

    access(account) fun updateTopUpAmount(amount: UFix64) {
        self.topUpAmount = amount
    }

    access(account) fun updateTopUpThreshold(threshold: UInt64) {
        self.topUpThreshold = threshold
    }

    access(account) fun getTopUpAmount(): UFix64 {
        return 0.000012 // self.topUpAmount //
    }

    access(account) fun getTopUpThreshold(): UInt64 {
        return 1200 // self.topUpThreshold
    }

    init() {
        self.topUpAmount = 0.000012
        self.topUpThreshold = 1200
    }
 }"
-------
"pub contract TraditionalTetrisPieces {

  // This map is a map of piece names to a map of rotations to a 4x4 matrix of 1s and 0s
  access(contract) let pieceMap: {String: {Int: [[Int]]}}

  pub fun getRandomPiece(): String {
    let rand = unsafeRandom()
    let length = self.pieceMap.keys.length
    let randPiece: Int = Int((rand % UInt64(length)))
    let pieceName = self.pieceMap.keys[randPiece]!
    return pieceName
  }

  pub fun getNextShape(_ curShape: String): String {
    var i = 0
    while (i < self.pieceMap.keys.length) {
      if (self.pieceMap.keys[i] == curShape) {
        break
      }
      i = i + 1
    }
    let nextShapeIndex = (i + 1) % self.pieceMap.keys.length
    return self.pieceMap.keys[nextShapeIndex]!
  }

  pub fun getColorForShape(_ shape: String): String {
    if (shape == "S") {
      return "#00ff00"
    }
    if (shape == "L") {
      return "#ffa500"
    }
    if (shape == "I") {
      return "#00ffff"
    }
    if (shape == "O") {
      return "#ffff00"
    }
    if (shape == "J") {
      return "#0000ff"
    }
    if (shape == "T") {
      return "#800080"
    }
    if (shape == "Z") {
      return "#ff0000"
    }
    return "#ff0000"
  }

  pub fun getPiece(_ name: String, _ rotation: Int): [[Int]] {
    return self.pieceMap[name]![rotation]!
  }

  pub fun getPieces(): {String: {Int: [[Int]]}} {
    return self.pieceMap
  }

  init() {
    self.pieceMap = {
      "Z": {
        0: [
          [0,1,1],
          [1,1,0]
        ],
        1: [
          [1,0],
          [1,1],
          [0,1]
        ],
        2: [
          [0,1,1],
          [1,1,0]
        ],
        3: [
          [1,0],
          [1,1],
          [0,1]
        ]
      },
      "I": {
        0: [
          [1,1,1,1]
        ],
        1: [
          [1],
          [1],
          [1],
          [1]
        ],
        2: [
          [1,1,1,1]
        ],
        3: [
          [1],
          [1],
          [1],
          [1]
        ]
      },
      "J": {
        0: [
          [1,1,1],
          [0,0,1]
        ],
        1: [
          [0,1],
          [0,1],
          [1,1]
        ],
        2: [
          [1,0,0],
          [1,1,1]
        ],
        3: [
          [1,1],
          [1,0],
          [1,0]
        ]
      },
      "O": {
        0: [
          [1,1],
          [1,1]
        ],
        1: [
          [1,1],
          [1,1]
        ],
        2: [
          [1,1],
          [1,1]
        ],
        3: [
          [1,1],
          [1,1]
        ]
      },
      "T": {
        0: [
          [1,1,1],
          [0,1,0]
        ],
        1: [
          [0,1],
          [1,1],
          [0,1]
        ],
        2: [
          [0,1,0],
          [1,1,1]
        ],
        3: [
          [1,0],
          [1,1],
          [1,0]
        ]
      },
      "S": {
        0: [
          [1,1,0],
          [0,1,1]
        ],
        1: [
          [0,1],
          [1,1],
          [1,0]
        ],
        2: [
          [0,1,1],
          [1,1,0]
        ],
        3: [
          [1,0],
          [1,1],
          [0,1]
        ]
      },
      "L": {
        0: [
          [0,0,1],
          [1,1,1]
        ],
        1: [
          [1,1],
          [0,1],
          [0,1]
        ],
        2: [
          [1,1,1],
          [1,0,0]
        ],
        3: [
          [1,0],
          [1,0],
          [1,1]
        ]
      }
    }
  }
}"
-------
"pub contract GameCatalog {
  pub struct Game {
    pub let levelType: Type
    pub let gameEngineType: Type
    pub let name: String
    pub let description: String
    pub let image: String

    init(levelType: Type, gameEngineType: Type, name: String, description: String, image: String) {
      self.levelType = levelType
      self.gameEngineType = gameEngineType
      self.name = ""
      self.description = ""
      self.image = ""
    }
  }

  pub let games: [Game]

  pub fun addGame(game: Game) {
    self.games.append(game)
  }

  init() {
    self.games = []
  }
}"
-------
"// Copied from https://github.com/bluesign/flow-utils/blob/dnz/cadence/contracts/ArrayUtils.cdc with minor adjustments

pub contract ArrayUtils {

    pub fun rangeFunc(_ start: Int, _ end: Int, _ f : ((Int):Void) ) {
        var current = start
        while current < end{
            f(current)
            current = current + 1
        }
    }

    pub fun range(_ start: Int, _ end: Int): [Int]{
        var res:[Int] = []
        self.rangeFunc(start, end, fun (i:Int){
            res.append(i)
        })
        return res
    }

    pub fun transform(_ array: &[AnyStruct], _ f : ((AnyStruct): AnyStruct)){
        for i in self.range(0, array.length){
            array[i] = f(array[i])
        }
    }

    pub fun iterate(_ array: [AnyStruct], _ f : ((AnyStruct): Bool)){
        for item in array{
            if !f(item){
                break
            }
        }
    }

    pub fun map(_ array: [AnyStruct], _ f : ((AnyStruct): AnyStruct)) : [AnyStruct] {
        var res : [AnyStruct] = []
        for item in array{
            res.append(f(item))
        }
        return res
    }

    pub fun mapStrings(_ array: [String], _ f: ((String) : String) ) : [String] {
        var res : [String] = []
        for item in array{
            res.append(f(item))
        }
        return res
    }

    pub fun reduce(_ array: [AnyStruct], _ initial: AnyStruct, _ f : ((AnyStruct, AnyStruct): AnyStruct)) : AnyStruct{
        var res: AnyStruct = f(initial, array[0])
        for i in self.range(1, array.length){
            res =  f(res, array[i])
        }
        return res
    }

}"
-------
"// Copied from https://github.com/bluesign/flow-utils/blob/dnz/cadence/contracts/StringUtils.cdc with minor adjustments

import ArrayUtils from 0x9d041d36947924c0

pub contract StringUtils {

    pub fun explode(_ s: String): [String]{
        var chars : [String] =  []
        for i in ArrayUtils.range(0, s.length){
            chars.append(s[i].toString())
        }
        return chars
    }

    pub fun trimLeft(_ s: String): String{
        for i in ArrayUtils.range(0, s.length){
            if s[i] != " "{
                return s.slice(from: i, upTo: s.length)
            }
        }
        return ""
    }

    pub fun trim(_ s: String): String{
        return self.trimLeft(s)
    }

    pub fun replaceAll(_ s: String, _ search: String, _ replace: String): String{
        return self.join(self.split(s, search), replace)
    }

    pub fun hasPrefix(_ s: String, _ prefix: String) : Bool{
        return s.length >= prefix.length && s.slice(from:0, upTo: prefix.length)==prefix
    }

    pub fun hasSuffix(_ s: String, _ suffix: String) : Bool{
        return s.length >= suffix.length && s.slice(from:s.length-suffix.length, upTo: s.length)==suffix
    }

    pub fun index(_ s : String, _ substr : String, _ startIndex: Int): Int?{
        for i in ArrayUtils.range(startIndex,s.length-substr.length+1){
            if s[i]==substr[0] && s.slice(from:i, upTo:i+substr.length) == substr{
                return i
            }
        }
        return nil
    }

    pub fun count(_ s: String, _ substr: String): Int{
        var pos = [self.index(s, substr, 0)]
        while pos[0]!=nil {
            pos.insert(at:0, self.index(s, substr, pos[0]!+pos.length*substr.length+1))
        }
        return pos.length-1
    }

    pub fun contains(_ s: String, _ substr: String): Bool {
        if let index =  self.index(s, substr, 0) {
            return true
        }
        return false
    }

    pub fun substringUntil(_ s: String, _ until: String, _ startIndex: Int): String{
        if let index = self.index( s, until, startIndex){
            return s.slice(from:startIndex, upTo: index)
        }
        return s.slice(from:startIndex, upTo:s.length)
    }

    pub fun split(_ s: String, _ delimiter: String): [String] {
        let segments: [String] = []
        var p = 0
        while p<=s.length{
            var preDelimiter = self.substringUntil(s, delimiter, p)
            segments.append(preDelimiter)
            p = p + preDelimiter.length + delimiter.length
        }
        return segments
    }

    pub fun join(_ strs: [String], _ separator: String): String {
        var joinedStr = ""
        for s in strs {
            joinedStr = joinedStr.concat(s).concat(separator)
        }
        return joinedStr.slice(from: 0, upTo: joinedStr.length - separator.length)
    }

    pub fun joinInts(_ ints: [Int], _ separator: String): String {
        var joinedStr = ""
        for s in ints {
            joinedStr = joinedStr.concat(s.toString()).concat(separator)
        }
        return joinedStr.slice(from: 0, upTo: joinedStr.length - separator.length)
    }


}"
-------
"import GameLevels from 0x9d041d36947924c0
import GameEngine from 0x9d041d36947924c0
import TraditionalTetrisPieces from 0x7963a4eb8583241f
import TetrisObjects from 0x7963a4eb8583241f

pub contract Tetris: GameLevels {

  pub struct StandardLevel: GameEngine.Level {
    pub var gameboard: GameEngine.GameBoard
    pub var objects: { UInt64: {GameEngine.GameObject} }

    pub var state: {String: String}

    pub let tickRate: UInt64

    pub let boardWidth: Int
    pub let boardHeight: Int

    pub let extras: {String: AnyStruct}

    pub fun createNewTetrisPiece(): TetrisObjects.TetrisPiece {
      let tetrisPiece = TetrisObjects.TetrisPiece()
      if (self.state["lastShape"] == nil) {
        self.state["lastShape"] = "L"
      }
      let shape = TraditionalTetrisPieces.getNextShape(self.state["lastShape"]!)
      // Make the active piece slightly transparent.
      let color = TraditionalTetrisPieces.getColorForShape(shape).concat("99")
      self.state["lastShape"] = shape

      tetrisPiece.fromMap(
        {
          "id": "1",
          "type": "TetrisPiece",
          "doesTick": "true",
          "x": "0",
          "y": "4",
          "shape": shape,
          "rotation": "0",
          "color": color,
          "dropRate": "5",
          "lastDropTick": "0"
        }
      )
      return tetrisPiece
    }

    pub fun createInitialGameObjects(): [{GameEngine.GameObject}?] {
      let tetrisPiece = self.createNewTetrisPiece()
      let lockedInTetrisPiece = TetrisObjects.LockedInTetrisPiece()
      var fullRow: [Int] = []
      var i = 0
      var emptyRow: [Int] = []
      while (i < self.boardWidth) {
        emptyRow.append(0)
        fullRow.append(1)
        i = i + 1
      }
      var j = 0
      var lockedInitialPositions: [[Int]] = []
      while (j < self.boardHeight - 1) {
        lockedInitialPositions.append(emptyRow)
        j = j + 1
      }
      lockedInitialPositions.append(fullRow)
      lockedInTetrisPiece.setRelativePositions(lockedInitialPositions)
      lockedInTetrisPiece.setReferencePoint([0, 0])

      return [
        tetrisPiece,
        lockedInTetrisPiece
      ]
    }

    pub fun parseGameObjectsFromMaps(_ map: [{String: String}]): [{GameEngine.GameObject}?] {
      let objects: [{GameEngine.GameObject}?] = []
      for objectMap in map {
        var object: {GameEngine.GameObject}? = nil
        if (objectMap["type"] == "TetrisPiece") {
          object = TetrisObjects.TetrisPiece()
        }
        if (objectMap["type"] == "LockedInTetrisPiece") {
          object = TetrisObjects.LockedInTetrisPiece()
        }
        object!.fromMap(objectMap)
        objects.append(object!)
      }
      return objects
    }

    pub fun tick(tickCount: UInt64, events: [GameEngine.PlayerEvent]) {
      var keys = self.objects.keys
      for key in keys {
        if (self.objects[key] == nil) {
          continue
        }
        let object = self.objects[key]!
        if (self.objects[key]!.doesTick) {
          // When passed as a parameter, level is readonly because the param copies the level.
          // For any actions that might be required that need to affect the actual level,
          // we provide the callbacks object.
          let redraw = fun (_ object: AnyStruct?): AnyStruct? {
            let map = object! as! {String: {GameEngine.GameObject}}
            let prevObject = map["prev"]!
            let gameObject = map["new"]!
            self.gameboard.remove(prevObject)
            self.gameboard.add(gameObject)
            return nil
          }
          let remove = fun (_ object: AnyStruct?): AnyStruct? {
            let gameObject = object! as! {GameEngine.GameObject}
            self.gameboard.remove(gameObject)
            self.objects.remove(key: gameObject.id)
            return nil
          }
          let spawn = fun (_ object: AnyStruct?): AnyStruct? {
            let newTetrisPiece = self.createNewTetrisPiece()
            self.objects[newTetrisPiece.id] = newTetrisPiece
            self.gameboard.add(newTetrisPiece)
            return nil
          }
          let expandLockedIn = fun (_ object: AnyStruct?): AnyStruct? {
            let gameObject = object! as! TetrisObjects.TetrisPiece

            var color = gameObject.color.slice(from:0, upTo:7) // Remove the opacity

            var newRows: {Int: Bool} = {}
            // loop through all of the relative positions of the tetris piece
            // and create a new individual locked in piece for each one
            // with the same reference point and color as the tetris piece
            var i = 0
            while (i < gameObject.relativePositions.length) {
              var j = 0
              while (j < gameObject.relativePositions[i].length) {
                if (gameObject.relativePositions[i][j] == 1) {
                  let newLockedInPiece = TetrisObjects.LockedInTetrisPiece()
                  newLockedInPiece.setID(UInt64.fromString(self.state["lastID"]!)!)
                  self.state["lastID"] = (UInt64.fromString(self.state["lastID"]!)! + 1).toString()
                  newLockedInPiece.setRelativePositions([[1]])
                  newLockedInPiece.setReferencePoint([gameObject.referencePoint[0] + i, gameObject.referencePoint[1] + j])
                  newRows[gameObject.referencePoint[0] + i] = true
                  newLockedInPiece.setColor(color)
                  self.gameboard.add(newLockedInPiece)
                  self.objects[newLockedInPiece.id] = newLockedInPiece
                }
                j = j + 1
              }
              i = i + 1
            }

            // check if any of the `newRows` are full
            // if they are, remove them and shift all of the locked in pieces above them down
            // also increment the score state
            var rowsToRemove: [Int] = []
            for row in newRows.keys {
              if (self.gameboard.board[row]!.keys.length == self.boardWidth) {
                self.state["score"] = (UInt64.fromString(self.state["score"]!)! + 1).toString()
                let values = self.gameboard.board[row]!.values
                for lockedInPiece in values {
                  self.objects.remove(key: lockedInPiece!.id)
                  self.gameboard.remove(lockedInPiece!)
                }

                // Shift all game objects above the row down
                var i = row
                while (i > 0) {
                  if (self.gameboard.board[i] == nil) {
                    i = i - 1
                    continue
                  }
                  for j in self.gameboard.board[i]!.keys {
                    let obj: TetrisObjects.LockedInTetrisPiece?? = self.gameboard.board[i]![j]! as? TetrisObjects.LockedInTetrisPiece?
                    if (obj == nil || obj! == nil) {
                      continue
                    }
                    let prev = obj!!
                    self.objects[prev.id]!.setReferencePoint([i+1, j])
                    let params: {String: {GameEngine.GameObject}} = {
                      "prev": prev,
                      "new": self.objects[prev.id]!
                    }
                    redraw(params)
                  }
                  i = i - 1
                }
              }
            }


            return nil
          }
          let callbacks: {String: ((AnyStruct?): AnyStruct?)} = {
            "redraw": redraw,
            "remove": remove,
            "spawn": spawn,
            "expandLockedIn": expandLockedIn
          }
          self.objects[key]!.tick(
            tickCount: tickCount,
            events: events,
            level: self,
            callbacks: callbacks
          )
        }
      }
    }

    pub fun postTick(tickCount: UInt64, events: [GameEngine.PlayerEvent]) {
      // do nothing
    }

    init() {
      self.boardWidth = 10
      self.boardHeight = 20
      self.tickRate = 10 // ideal ticks per second from the client
      self.state = {
        "score": "0",
        "lastID": "2"
      }
      self.extras = {
        "boardWidth": self.boardWidth,
        "boardHeight": self.boardHeight,
        "description": "A traditional tetris level w/ some bugs."
      }
      self.objects = {}
      self.gameboard = GameEngine.GameBoard(
        width: self.boardWidth,
        height: self.boardHeight
      )
    }
  }

  pub fun createLevel(_ name: String): AnyStruct? {
    return StandardLevel()
  }

  pub fun getAvailableLevels(): [String] {
    return [
      "StandardLevel"
    ]
  }

}"
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract HouseBadge: NonFungibleToken {

    pub var totalSupply: UInt64

    /***********************************************/
    /******************** PATHS ********************/
    /***********************************************/
    pub var collectionPublicPath: PublicPath
    pub var collectionStoragePath: StoragePath
    // pub var minterPublicPath: PublicPath
    pub var minterStoragePath: StoragePath

    /************************************************/
    /******************** EVENTS ********************/
    /************************************************/
    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)

    pub event Mint(id: UInt64, creator: Address, metadata: {String:String}, totalSupply: UInt64)
    pub event Destroy(id: UInt64)

    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        pub let id: UInt64
        pub let creator: Address
        access(self) let metadata: {String:String}

        init(id: UInt64, creator: Address, metadata: {String:String}) {
            self.id = id
            self.creator = creator
            self.metadata = metadata
        }

        pub fun getViews(): [Type] {
            return [Type<MetadataViews.Display>()]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.metadata["name"] ?? "",
                        description: self.metadata["description"] ?? "",
                        thumbnail: MetadataViews.HTTPFile(url: self.metadata["metaURI"] ?? ""),
                    )
            }
            return nil
        }

        pub fun getMetadata(): {String:String} {
            return self.metadata
        }

        pub fun rename(newName: String) {
            self.metadata["name"] = newName
        }

        destroy() {
            emit Destroy(id: self.id)
        }
    }

    pub resource interface CollectionPublic {
        pub fun borrow(id: UInt64): &NFT?
    }

    pub resource interface Renameable {
        pub fun rename(id: UInt64, newName: String)
    }

    pub resource Collection: NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection, CollectionPublic, Renameable {
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init() {
            self.ownedNFTs <- {}
        }

        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("Missing NFT")
            emit Withdraw(id: token.id, from: self.owner?.address)
            return <- token
        }

        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @HouseBadge.NFT
            let id: UInt64 = token.id
            let dummy <- self.ownedNFTs[id] <- token
            destroy dummy
            // emit Deposit(id: id, to: self.owner?.address)
        }

        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {
            let authRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let ref = authRef as! &NFT
            return ref as! &{MetadataViews.Resolver}
        }

        pub fun borrow(id: UInt64): &NFT? {
            let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            return ref as! &NFT
        }

        pub fun getMetadata(id: UInt64): {String:String} {
            let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            return (ref as! &HouseBadge.NFT).getMetadata()
        }

        pub fun rename(id: UInt64, newName: String) {
            let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            (ref as! &HouseBadge.NFT).rename(newName: newName)
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    pub resource Minter {
        pub fun mintTo(creator: Capability<&{NonFungibleToken.Receiver}>, metadata: {String:String}): &NonFungibleToken.NFT {
            let id = HouseBadge.totalSupply.toString()
            let meta = {
                "name": metadata["name"] ?? "",
                "description": metadata["description"] ?? "",
                "metaURI": "https://nft.tobiratory.com/housebadge/metadata/".concat(id)
            };
            let token <- create NFT(
                id: HouseBadge.totalSupply,
                creator: creator.address,
                metadata: meta
            )
            HouseBadge.totalSupply = HouseBadge.totalSupply + 1
            let tokenRef = &token as &NonFungibleToken.NFT
            emit Mint(id: token.id, creator: creator.address, metadata: meta, totalSupply: HouseBadge.totalSupply)
            creator.borrow()!.deposit(token: <- token)
            return tokenRef
        }
    }

    // pub fun minter(): Capability<&Minter> {
    //     return self.account.getCapability<&Minter>(self.minterPublicPath)
    // }

    init() {
        self.totalSupply = 0
        self.collectionPublicPath = /public/HouseBadgeCollection
        self.collectionStoragePath = /storage/HouseBadgeCollection
        // self.minterPublicPath = /public/HouseBadgeMinter
        self.minterStoragePath = /storage/HouseBadgeMinter

        if self.account.borrow<&Minter>(from: self.minterStoragePath) == nil {
            let minter <- create Minter()
            self.account.save(<- minter, to: self.minterStoragePath)
        }

        if self.account.borrow<&HouseBadge.Collection>(from: HouseBadge.collectionStoragePath) == nil {
            let collection <- self.createEmptyCollection()
            self.account.save(<- collection, to: self.collectionStoragePath)
            self.account.link<&{NonFungibleToken.CollectionPublic,HouseBadge.CollectionPublic,HouseBadge.Renameable,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(self.collectionPublicPath, target: self.collectionStoragePath)
        }
        emit ContractInitialized()
    }
}"
-------
"/**

# Fungible Token Forwarding Contract

This contract shows how an account could set up a custom FungibleToken Receiver
to allow them to forward tokens to a different account whenever they receive tokens.

They can publish this Forwarder resource as a Receiver capability just like a Vault,
and the sender doesn't even need to know it is different.

When an account wants to create a Forwarder, they call the createNewForwarder
function and provide it with the Receiver reference that they want to forward
their tokens to.

*/

import FungibleToken from 0xf233dcee88fe0abe

pub contract TokenForwarding {

    // Event that is emitted when tokens are deposited to the target receiver
    pub event ForwardedDeposit(amount: UFix64, symbol: String, from: Address?)

    pub resource interface ForwarderPublic {

        /// Helper function to check whether set `recipient` capability
        /// is not latent or the capability tied to a type is valid.
        pub fun check(): Bool

        /// Gets the receiver assigned to a recipient capability.
        /// This is necessary because without it, it is not possible to look under the hood and see if a capability
        /// is of an expected type or not. This helps guard against infinitely chained TokenForwarding or other invalid
        /// malicious kinds of updates that could prevent listings from being made that are valid on storefronts.
        ///
        /// @return an optional receiver capability for consumers of the TokenForwarding to check/validate on their own
        pub fun safeBorrow(): &{FungibleToken.Receiver}?
    }

    pub resource Forwarder: FungibleToken.Receiver, ForwarderPublic {

        // This is where the deposited tokens will be sent.
        // The type indicates that it is a reference to a receiver
        //
        access(self) var recipient: Capability

        access(all) var symbol: String

        // deposit
        //
        // Function that takes a Vault object as an argument and forwards
        // it to the recipient's Vault using the stored reference
        //
        pub fun deposit(from: @FungibleToken.Vault) {
            let receiverRef = self.recipient.borrow<&{FungibleToken.Receiver}>()!

            let balance = from.balance

            receiverRef.deposit(from: <-from)

            emit ForwardedDeposit(amount: balance, symbol: self.symbol, from: self.owner?.address)
        }

        /// Helper function to check whether set `recipient` capability
        /// is not latent or the capability tied to a type is valid.
        pub fun check(): Bool {
            return self.recipient.check<&{FungibleToken.Receiver}>()
        }

        /// Gets the receiver assigned to a recipient capability.
        /// This is necessary because without it, it is not possible to look under the hood and see if a capability
        /// is of an expected type or not. This helps guard against infinitely chained TokenForwarding or other invalid
        /// malicious kinds of updates that could prevent listings from being made that are valid on storefronts.
        ///
        /// @return an optional receiver capability for consumers of the TokenForwarding to check/validate on their own
        pub fun safeBorrow(): &{FungibleToken.Receiver}? {
            return self.recipient.borrow<&{FungibleToken.Receiver}>()
        }

        // changeRecipient changes the recipient of the forwarder to the provided recipient
        //
        pub fun changeRecipient(_ newRecipient: Capability) {
            pre {
                newRecipient.borrow<&{FungibleToken.Receiver}>() != nil: "Could not borrow Receiver reference from the Capability"
            }
            self.recipient = newRecipient
        }

        /// A getter function that returns the token types supported by this resource,
        /// which can be deposited using the 'deposit' function.
        ///
        /// @return Array of FT types that can be deposited.
        pub fun getSupportedVaultTypes(): {Type: Bool} {
            if !self.recipient.check<&{FungibleToken.Receiver}>() {
                return {}
            }
            let vaultRef = self.recipient.borrow<&{FungibleToken.Receiver}>()!
            let supportedVaults: {Type: Bool} = {}
            supportedVaults[vaultRef.getType()] = true
            return supportedVaults
        }

        init(recipient: Capability, symbol: String) {
            pre {
                recipient.borrow<&{FungibleToken.Receiver}>() != nil: "Could not borrow Receiver reference from the Capability"
            }
            self.recipient = recipient
            self.symbol = symbol
        }
    }

    // createNewForwarder creates a new Forwarder reference with the provided recipient
    //
    pub fun createNewForwarder(recipient: Capability, symbol: String): @Forwarder {
        return <-create Forwarder(recipient: recipient, symbol: symbol)
    }
}"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448

pub contract ShadowExchange {

    // Fee amount
    pub fun Fee(): UFix64 {
        return 0.0
    }

    // Fee receiver address
    pub fun FeeAddress(): Address {
        return 0x902092dad89d1736
    }

    // An order has been created
    pub event OrderCreated(
        orderID: UInt64,
        address: Address,
        nftType: Type,
        nftUUID: UInt64,
        nftID: UInt64,
        currency: Type,
        price: UFix64,
        expiry: UInt64
    )

    // An order has been canceled
    pub event OrderCanceled(
        orderID: UInt64,
        nftType: Type,
        nftUUID: UInt64,
        nftID: UInt64,
        currency: Type,
        price: UFix64,
        expiry: UInt64
    )

    // An order has been filled
    pub event OrderFilled(
        orderID: UInt64,
        nftType: Type,
        nftUUID: UInt64,
        nftID: UInt64,
        currency: Type,
        price: UFix64,
        expiry: UInt64
    )

    // The storage location of the resource
    pub let ShadowExchangeStoragePath: StoragePath

    // The public location of the link
    pub let ShadowExchangePublicPath: PublicPath

    // A struct representing a payment that must be sent when an order is executed
    pub struct Payment {
        // The receiver for the payment of a sell order
        pub let receiver: Capability<&{FungibleToken.Receiver}>

        // The amount of the FungibleToken that will be paid
        pub let amount: UFix64

        init(receiver: Capability<&{FungibleToken.Receiver}>, amount: UFix64) {
            self.receiver = receiver
            self.amount = amount
        }
    }

    // A struct containing an order's data
    pub struct OrderDetails {
        // Whether this order has been filled or not
        pub var filled: Bool
        // The Type of the NonFungibleToken.NFT
        pub let nftType: Type
        // The Resource ID of the NFT
        pub let nftUUID: UInt64
        // The unique identifier of the NFT in the contract
        pub let nftID: UInt64
        // The Type of the FungibleToken that payments must be made in
        pub let currency: Type
        // The amount that must be paid in the specified FungibleToken
        pub let price: UFix64
        // This specifies the division of payment between recipients
        pub let payments: [Payment]
        // This specifies the division of royalties between recipients
        pub let royalties: [Payment]
        // This specifies the division of fees between recipients
        pub let fees: [Payment]
        // Time when order expires
        pub let expiry: UInt64

        // Set an order to filled so it can't be executed again
        access(contract) fun setToFilled() {
            self.filled = true
        }

        init (
            nftType: Type,
            nftUUID: UInt64,
            nftID: UInt64,
            currency: Type,
            payments: [Payment],
            royalties: [Payment],
            fees: [Payment],
            expiry: UInt64
        ) {

            pre {
                // Validate the UUID and ID when sell order
                nftUUID != nil && nftID != nil: "sell orders require the UUID and ID of the NFT"

                // Validate the expiry timestamp
                expiry > UInt64(getCurrentBlock().timestamp) : "expiry should be in the future"

                // Validate the existance of at least one payment recipient when sell order
                payments.length > 0: "sell orders must have at least one payment recipient"
            }

            self.filled = false
            self.nftType = nftType
            self.nftUUID = nftUUID
            self.nftID = nftID
            self.currency = currency
            self.payments = payments
            self.royalties = royalties
            self.fees = fees
            self.expiry = expiry

            var price = 0.0
            for payment in self.payments {
                payment.receiver.borrow() ?? panic("cannot borrow payment receiver")
                price = price + payment.amount
            }
            assert(price > 0.0, message: "item price must not be 0")

            for royalty in self.royalties {
                royalty.receiver.borrow() ?? panic("cannot borrow royalty receiver")
                price = price + royalty.amount
            }

            var totalFeeAmount = 0.0
            for fee in self.fees {
                totalFeeAmount = totalFeeAmount + fee.amount
                price = price + fee.amount
            }
            assert(totalFeeAmount >= ShadowExchange.Fee(), message: "fee is lower than required fee")

            self.price = price
        }
    }

    // An interface providing a public interface to an Order.
    pub resource interface OrderPublic {

        pub fun borrowNFT(): &NonFungibleToken.NFT?

        // Get the token in exchange of the currency vault
        pub fun fill(
            payment: @FungibleToken.Vault,
        ): @NonFungibleToken.NFT

        // Get the details of an Order
        pub fun getDetails(): OrderDetails

        // For a sell Order, checks whether the NFT is present in provided capability
        // `false` means the NFT was transfered out of the account
        pub fun isValid(): Bool
    }

    // A resource that allows an NFT to be sold for an amount of a given FungibleToken,
    // and for the proceeds of that sale to be split between several recipients.
    pub resource Order: OrderPublic {
        // The details of the Order
        access(self) let details: OrderDetails

        // A capability allowing this resource to withdraw any NFT with the given ID from its collection.
        access(contract) let nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>

        // Return the reference of the NFT that is for sale.
        // If the NFT is absent, it will return nil.
        pub fun borrowNFT(): &NonFungibleToken.NFT? {
            // Sell orders require the NFT type and ID
            let ref = self.nftProviderCapability.borrow()!.borrowNFT(id: self.details.nftID)
            if ref.isInstance(self.details.nftType) && ref.id == self.details.nftID {
                return ref as! &NonFungibleToken.NFT
            }
            return nil
        }

        // Get the details of an order.
        pub fun getDetails(): OrderDetails {
            return self.details
        }

        // For a sell Order, checks whether the NFT is present in provided capability
        // `false` means the NFT was transfered out of the account
        pub fun isValid(): Bool {
            if let providerRef = self.nftProviderCapability.borrow() {
                let availableIDs = providerRef.getIDs()
                return availableIDs.contains(self.details.nftID)
            }
            return false
        }

        // Fill the order
        // Send payments and returns the token to the buyer
        pub fun fill(
            payment: @FungibleToken.Vault,
        ): @NonFungibleToken.NFT {

            pre {
                self.details.filled == false: "order has already been filled"
                payment.isInstance(self.details.currency): "payment is not in required currency"
                payment.balance == self.details.price: "payment price is different"
                self.details.expiry > UInt64(getCurrentBlock().timestamp): "order is expired"
                self.owner != nil : "resource doesn't have the assigned owner"
            }

            // Make sure the order cannot be filled again
            self.details.setToFilled()

            // Fetch the token to return to the buyer
            let nft <-self.nftProviderCapability.borrow()!.withdraw(withdrawID: self.details.nftID)

            // Check if the withdrawn NFT has the specified Type and ID
            assert(nft.isInstance(self.details.nftType), message: "withdrawn NFT is not of specified type")
            assert(nft.id == self.details.nftID, message: "withdrawn NFT does not have specified ID")

            // Rather than aborting the transaction if any receiver is absent when we try to pay it,
            // we send the payment to the first valid receiver, which should be the seller.
            var residualReceiver: &{FungibleToken.Receiver}? = nil

            // Pay each beneficiary their amount of the payment
            // Set the first valid receiver as the residual receiver
            for p in self.details.payments {
                if let receiver = p.receiver.borrow() {
                   let vault <- payment.withdraw(amount: p.amount)
                    receiver.deposit(from: <-vault)
                    if (residualReceiver == nil) {
                        residualReceiver = receiver
                    }
                }
            }

            // Pay royalties
            for r in self.details.royalties {
                if let receiver = r.receiver.borrow() {
                   let vault <- payment.withdraw(amount: r.amount)
                    receiver.deposit(from: <-vault)
                }
            }

            // Pay fees to the fee receiver defined in the contract
            let feeAddress = ShadowExchange.FeeAddress()
            var receiverPath = /public/flowTokenReceiver
            let usdcTokenVaultType: Type = CompositeType("A.b19436aae4d94622.FiatToken.Vault")!
            if payment.isInstance(usdcTokenVaultType) {
                receiverPath = /public/USDCVaultReceiver
            }

            let feeReceiver = getAccount(feeAddress).getCapability<&AnyResource{FungibleToken.Receiver}>(receiverPath)
            for f in self.details.fees {
                if let receiver = feeReceiver.borrow() {
                   let vault <- payment.withdraw(amount: f.amount)
                    receiver.deposit(from: <-vault)
                }
            }

            // At least one receiver was valid and paid
            assert(residualReceiver != nil, message: "no valid payment receivers")

            // At this point, if all receivers were valid, then the payment Vault will have
            // zero tokens left, and this will be a no-op that consumes the empty vault
            // otherwise the remaining payment will be deposited to the residual receiver
            residualReceiver!.deposit(from: <-payment)

            emit OrderFilled(
                orderID: self.uuid,
                nftType: self.details.nftType,
                nftUUID: self.details.nftUUID,
                nftID: self.details.nftID,
                currency: self.details.currency,
                price: self.details.price,
                expiry: self.details.expiry
            )

            return <-nft
        }

        destroy () {
            if !self.details.filled {
                emit OrderCanceled(
                    orderID: self.uuid,
                    nftType: self.details.nftType,
                    nftUUID: self.details.nftUUID,
                    nftID: self.details.nftID,
                    currency: self.details.currency,
                    price: self.details.price,
                    expiry: self.details.expiry
                )
            }
        }

        init (
            nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,
            nftType: Type,
            nftUUID: UInt64,
            nftID: UInt64,
            currency: Type,
            payments: [Payment],
            royalties: [Payment],
            fees: [Payment],
            expiry: UInt64
        ) {
            // Store the order instructions
            self.details = OrderDetails(
                nftType: nftType,
                nftUUID: nftUUID,
                nftID: nftID,
                currency: currency,
                payments: payments,
                royalties: royalties,
                fees: fees,
                expiry: expiry
            )

            // Store the NFT provider
            self.nftProviderCapability = nftProviderCapability


            // Check that the provider has the NFT
            let provider = self.nftProviderCapability.borrow()
            assert(provider != nil, message: "cannot borrow nftProviderCapability")

            let nft = provider!.borrowNFT(id: self.details.nftID)
            assert(nft.isInstance(self.details.nftType), message: "token is not of specified type")
            assert(nft.id == self.details.nftID, message: "token does not have specified ID")
        }
    }

    // An interface for adding and removing orders
    pub resource interface PortfolioManager {

        // Allows the portfolio owner to create a sell order
        pub fun createSellOrder(
            nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,
            nftType: Type,
            nftID: UInt64,
            currency: Type,
            payments: [Payment],
            royalties: [Payment],
            fees: [Payment],
            expiry: UInt64
        ): UInt64

        // Allows the portfolio owner to cancel any orders, filled or not
        pub fun cancelOrder(orderID: UInt64)
    }


    // An interface to allow order filling
    pub resource interface PortfolioPublic {
        pub fun getOrderIDs(): [UInt64]
        pub fun getSellOrderIDs(nftType: Type, nftID: UInt64): [UInt64]
        pub fun borrowOrder(orderID: UInt64): &Order{OrderPublic}?
        pub fun clean(orderID: UInt64)
   }

    // A resource that allows its owner to manage a portfolio, and anyone to interact with them
    // in order to query their details and fill the NFTs that they represent.
    pub resource Portfolio : PortfolioManager, PortfolioPublic {
        // The dictionary of orders uuids to order resources.
        access(contract) var orders: @{UInt64: Order}
        // Dictionary to keep track of sell order ids for an NFT
        // nftType.identifier -> nftID -> orderID
        access(contract) var sellOrders: {String: {UInt64 : UInt64}}
        // Create and publish a sell order for an NFT
         pub fun createSellOrder(
            nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,
            nftType: Type,
            nftID: UInt64,
            currency: Type,
            payments: [Payment],
            royalties: [Payment],
            fees: [Payment],
            expiry: UInt64
         ): UInt64 {

            // Check that the seller does indeed hold the NFT
            let collectionRef = nftProviderCapability.borrow()
                ?? panic("Could not borrow reference to collection")
            let nftRef = collectionRef.borrowNFT(id: nftID)

            let uuid = nftRef.uuid
            let order <- create Order(
                nftProviderCapability: nftProviderCapability,
                nftType: nftType,
                nftUUID: uuid,
                nftID: nftID,
                currency: currency,
                payments: payments,
                royalties: royalties,
                fees: fees,
                expiry: expiry
            )

            let orderID = order.uuid
            let price = order.getDetails().price

            // Add the new order to the dictionary.
            let oldOrder <- self.orders[orderID] <- order

            // Note that oldOrder will always be nil, but we have to handle it.
            destroy oldOrder

            // Add the `orderID` in the tracked sell orders and remove any previous sell order for the same nft
            if self.sellOrders.containsKey(nftType.identifier) {
                if self.sellOrders[nftType.identifier]!.containsKey(nftID) {
                    let previousOrderID = self.sellOrders[nftType.identifier]![nftID]!
                    self.cancelOrder(orderID: previousOrderID)
                }
            }
            self.addSellOrder(nftIdentifier: nftType.identifier, nftID: nftID, orderID: orderID)

            emit OrderCreated(
                orderID: orderID,
                address: self.owner?.address!,
                nftType: nftType,
                nftUUID: uuid,
                nftID: nftID,
                currency: currency,
                price: price,
                expiry: expiry
            )

            return orderID
        }

        // Helper function that allows to add a sell order for a given nft in a map
        access(contract) fun addSellOrder(nftIdentifier: String, nftID: UInt64, orderID: UInt64) {
             if !self.sellOrders.containsKey(nftIdentifier) {
                self.sellOrders.insert(key: nftIdentifier, {nftID: orderID})
            } else {
                if !self.sellOrders[nftIdentifier]!.containsKey(nftID) {
                    self.sellOrders[nftIdentifier]!.insert(key: nftID, orderID)
                } else {
                    self.sellOrders[nftIdentifier]!.remove(key: nftID)
                    self.sellOrders[nftIdentifier]!.insert(key: nftID, orderID)
                }
            }
        }

        // Helper function that allows to remove existing sell orders of given nft from a map
        access(contract) fun removeSellOrder(nftIdentifier: String, nftID: UInt64, orderID: UInt64) {
            if self.sellOrders.containsKey(nftIdentifier) {
                if self.sellOrders[nftIdentifier]!.containsKey(nftID) {
                    if self.sellOrders[nftIdentifier]![nftID]! == orderID {
                        self.sellOrders[nftIdentifier]!.remove(key: nftID)
                    }
                }
            }
        }

        // Remove an order that has not yet been filled and destroy it.
        // It can only be executed by the PortfolioManager resource owner.
        pub fun cancelOrder(orderID: UInt64) {
            let order <- self.orders.remove(key: orderID)
                ?? panic("missing Order")

            let details = order.getDetails()
            self.removeSellOrder(nftIdentifier: details.nftType.identifier, nftID: details.nftID, orderID: orderID)

            // This will emit an OrderCanceled event.
            destroy order
        }

        // Returns an array of all the orderIDs that are in the collection
        pub fun getOrderIDs(): [UInt64] {
            return self.orders.keys
        }

        // Returns the sell orderID of the given `nftType` and `nftID`
        pub fun getSellOrderIDs(nftType: Type, nftID: UInt64): [UInt64] {
            if self.sellOrders.containsKey(nftType.identifier) {
                if self.sellOrders[nftType.identifier]!.containsKey(nftID) {
                    return [self.sellOrders[nftType.identifier]![nftID]!]
                }
            }
            return []
        }

        // Allows anyone to clean filled or invalid orders
        pub fun clean(orderID: UInt64) {
            pre {
                self.orders[orderID] != nil: "could not find order with given id"
                (self.borrowOrder(orderID: orderID)!.getDetails().filled == true || self.borrowOrder(orderID: orderID)!.getDetails().expiry <= UInt64(getCurrentBlock().timestamp)): "order not filled or expired"
            }

            let orderRef = self.borrowOrder(orderID: orderID)!
            let details = orderRef.getDetails()

            var shouldClean = false
            if details.expiry <= UInt64(getCurrentBlock().timestamp) {
                // Order is expired and should be cleaned
                shouldClean = true
            } else {
                if details.filled == true {
                    // Order was filled and should be cleaned
                     shouldClean = true
                } else {
                    if !orderRef.isValid() {
                        // Order does not have NFT and should be cleaned
                        shouldClean = true
                    }
                }
            }

            assert(shouldClean, message: "given order is valid")

            let order <- self.orders.remove(key: orderID)!
            self.removeSellOrder(nftIdentifier: details.nftType.identifier, nftID: details.nftID, orderID: orderID)

            destroy order
        }

        // Returns a read-only view of the order
        pub fun borrowOrder(orderID: UInt64): &Order{OrderPublic}? {
             if self.orders[orderID] != nil {
                return &self.orders[orderID] as &Order{OrderPublic}?
            } else {
                return nil
            }
        }

        destroy () {
            destroy self.orders
        }

        init () {
            self.orders <- {}
            self.sellOrders = {}
        }
    }

    // Make creating a Portfolio publicly accessible
    pub fun createPortfolio(): @Portfolio {
        return <-create Portfolio()
    }

    init () {
        self.ShadowExchangeStoragePath = /storage/ShadowExchange
        self.ShadowExchangePublicPath = /public/ShadowExchange
    }
}
 "
-------
"/// # Capability Factory
///
/// This contract defines a Factory interface and a Manager resource to contain Factory implementations, as well as a
/// Getter interface for retrieval of contained Factories.
///
/// A Factory is defines a method getCapability() which defines the retrieval pattern of a Capability from a given
/// account at the specified path. This pattern arose out of a need to retrieve arbitrary & castable Capabilities from
/// an account under the static typing constraints inherent to Cadence.
///
/// The Manager resource is a container for Factories, and implements the Getter interface.
///
/// **Note:** It's generally an anti-pattern to pass around AuthAccount references; however, the need for castable
/// Capabilities is critical to the use case of Hybrid Custody. It's advised to use Factories sparingly and only for
/// cases where Capabilities must be castable by the caller.
///
pub contract CapabilityFactory {

    pub let StoragePath: StoragePath
    pub let PrivatePath: PrivatePath
    pub let PublicPath: PublicPath

    /// Factory structures a common interface for Capability retrieval from a given account at a specified path
    ///
    pub struct interface Factory {
        pub fun getCapability(acct: &AuthAccount, path: CapabilityPath): Capability
    }

    /// Getter defines an interface for retrieval of a Factory if contained within the implementing resource
    ///
    pub resource interface Getter {
        pub fun getSupportedTypes(): [Type]
        pub fun getFactory(_ t: Type): {CapabilityFactory.Factory}?
    }

    /// Manager is a resource that contains Factories and implements the Getter interface for retrieval of contained
    /// Factories
    ///
    pub resource Manager: Getter {
        /// Mapping of Factories indexed on Type of Capability they retrieve
        pub let factories: {Type: {CapabilityFactory.Factory}}

        /// Retrieves a list of Types supported by contained Factories
        ///
        /// @return List of Types supported by the Manager
        ///
        pub fun getSupportedTypes(): [Type] {
            return self.factories.keys
        }

        /// Retrieves a Factory from the Manager, returning it or nil if it doesn't exist
        ///
        /// @param t: Type the Factory is indexed on
        ///
        pub fun getFactory(_ t: Type): {CapabilityFactory.Factory}? {
            return self.factories[t]
        }

        /// Adds a Factory to the Manager, conditioned on the Factory not already existing
        ///
        /// @param t: Type of Capability the Factory retrieves
        /// @param f: Factory to add
        ///
        pub fun addFactory(_ t: Type, _ f: {CapabilityFactory.Factory}) {
            pre {
                !self.factories.containsKey(t): "Factory of given type already exists"
            }
            self.factories[t] = f
        }

        /// Updates a Factory in the Manager, adding if it didn't already exist
        ///
        /// @param t: Type of Capability the Factory retrieves
        /// @param f: Factory to replace existing Factory
        ///
        pub fun updateFactory(_ t: Type, _ f: {CapabilityFactory.Factory}) {
            self.factories[t] = f
        }

        /// Removes a Factory from the Manager, returning it or nil if it didn't exist
        ///
        /// @param t: Type the Factory is indexed on
        ///
        pub fun removeFactory(_ t: Type): {CapabilityFactory.Factory}? {
            return self.factories.remove(key: t)
        }

        init () {
            self.factories = {}
        }
    }

    /// Creates a Manager resource
    ///
    /// @return Manager resource
    pub fun createFactoryManager(): @Manager {
        return <- create Manager()
    }

    init() {
        let identifier = "CapabilityFactory_".concat(self.account.address.toString())
        self.StoragePath = StoragePath(identifier: identifier)!
        self.PrivatePath = PrivatePath(identifier: identifier)!
        self.PublicPath = PublicPath(identifier: identifier)!
    }
}"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import FungibleTokenMetadataViews from 0xea86b9b77d95aeea
import MetadataViews from 0x1d7e57aa55817448
import ViewResolver from 0xea86b9b77d95aeea
import FlowToken from 0x1654653399040a61

pub contract Lama: ViewResolver {
    pub let LamaStoragePath: StoragePath
    pub let LamaPrivatePath: PrivatePath

    pub event Allowed(path: PrivatePath, limit: UFix64)
    pub event Collected(path: PrivatePath, limit: UFix64, receiver: Address)

    // private functions only accessed by Account Parent
    pub resource interface ParentAccess {
        pub fun collect(path: PrivatePath, receiverPath: PublicPath, receiver: Address)
    }

    // private functions only accessed by Account Child
    pub resource interface ChildAccess {
        pub fun setAllowance(path: PrivatePath, allowance: UFix64, provider: Capability<&AnyResource{FungibleToken.Provider, FungibleToken.Balance}>)
    }

    pub resource Allowance: ParentAccess, ChildAccess {
        access(self) var allowances: {PrivatePath: UFix64}
        access(self) var collected: {PrivatePath: UFix64}
        access(self) var capabilities: {PrivatePath : Capability<&AnyResource{FungibleToken.Provider, FungibleToken.Balance}>}

        init () {
            self.allowances = {}
            self.collected = {}
            self.capabilities = {}
        }

        pub fun getAllowance(path: PrivatePath): UFix64 {
            return self.allowances[path] ?? 0.0
        }

        pub fun getCollected(path: PrivatePath): UFix64 {
            return self.collected[path] ?? 0.0
        }

        pub fun collect(path: PrivatePath, receiverPath: PublicPath, receiver: Address) {
            let childProvider: Capability<&AnyResource{FungibleToken.Provider, FungibleToken.Balance}> = self.capabilities[path]
                ?? panic("FungibleToken.Provider capability not found for provider path")

            let childVault: &AnyResource{FungibleToken.Provider, FungibleToken.Balance} = childProvider.borrow()
                ?? panic("Could not borrow FungibleToken.Provider")

            let parentVault: &AnyResource{FungibleToken.Receiver} = getAccount(receiver).getCapability<&AnyResource{FungibleToken.Receiver}>(receiverPath).borrow()
                ?? panic("Problem getting parent receiver for this public path")

            var collectable: UFix64 = self.getAllowance(path: path)

            if (collectable == 0.0 || childVault.balance == 0.0) {
                panic("No more tokens to be collected")
            }

            if (collectable >= childVault.balance) {
                collectable = childVault.balance
                // leave 0.001 for account storage in case of flow token
                let isTokenFlow: Bool = path == /private/flowTokenVault
                let storageAmount: UFix64 = 0.001 // TDB by user

                if isTokenFlow && childVault.balance >= storageAmount {
                    collectable = childVault.balance - storageAmount
                }
            }

            parentVault.deposit(from: <-childVault.withdraw(amount: collectable))

            self._setAllowance(
                path: path,
                allowance: self.getAllowance(path: path) - collectable
            )

            self.collected.insert(
                key: path, collectable + self.getCollected(path: path)
            )

            emit Lama.Collected(path: path, amount: collectable, receiver: receiver)
        }

        pub fun setAllowance(path: PrivatePath, allowance: UFix64, provider: Capability<&AnyResource{FungibleToken.Provider, FungibleToken.Balance}>) {
            self.capabilities.insert(key: path, provider)
            self._setAllowance(path: path, allowance: allowance)
        }

        access(self) fun _setAllowance(path: PrivatePath, allowance: UFix64) {
            self.allowances.insert(key: path, allowance)
            emit Lama.Allowed(path: path, allowance: allowance)
        }
    }

    pub fun createAllowance(): @Lama.Allowance {
        return <- create Allowance()
    }

    init() {
        self.LamaStoragePath = /storage/lama
        self.LamaPrivatePath = /private/lama
    }
}"
-------
"import LendingConfig from 0x2df970b6cdee5735
import LendingError from 0x2df970b6cdee5735
import LendingInterfaces from 0x2df970b6cdee5735

pub contract LendingAprSnapshot {
    pub let AdminStoragePath: StoragePath
    /// { marketAddr => perMarketAprData}
    access(self) let _markets: {Address: AprSnapshot}

    /// Reserved parameter fields: {ParamName: Value}
    access(self) let _reservedFields: {String: AnyStruct}

    pub event MarketDataTracked(market: Address, marketType: String, startTrackingFrom: UFix64)
    pub event MarketDataErased(market: Address, erasedFrom: UFix64)
    pub event AprSampled(market: Address, truncatedTimestamp: UInt64, supplyApr: UFix64, borrowApr: UFix64)

    /// Per-snapshot data point
    pub struct Observation {
        // Unix timestamp
        pub let timestamp: UFix64
        // supplyApr in ufix64
        pub let supplyApr: UFix64
        // borrowApr in ufix64 (e.g. 0.12345678 => 12.35%)
        pub let borrowApr: UFix64

        init (t: UFix64, supplyApr: UFix64, borrowApr: UFix64) {
            self.timestamp = t
            self.supplyApr = supplyApr
            self.borrowApr = borrowApr
        }
    }

    /// Per-market snapshot configurations and data points
    pub struct AprSnapshot {
        /// Contains functions to query public market data
        pub let poolPublicCap: Capability<&{LendingInterfaces.PoolPublic}>
        /// Each sample covers a 6-hour window: i.e. sampleLength = 21600s
        pub let sampleLength: UInt64
        /// We store 1 year of apr data in maximum: i.e. numSamples = 1460
        pub let numSamples: UInt64
        /// A circular buffer storing apr samples
        access(self) let aprObservations: [Observation]
        /// Reserved parameter fields: {ParamName: Value}
        access(self) let _reservedFields: {String: AnyStruct}

        /// Returns the index into the circular buffer of the given timestamp
        pub fun observationIndexOf(timestamp: UFix64): UInt64 {
            return UInt64(timestamp) / self.sampleLength % self.numSamples
        }

        pub fun sample(): Bool {
            let now = getCurrentBlock().timestamp
            let idx = self.observationIndexOf(timestamp: now)
            let ob = self.aprObservations[idx]
            let timeElapsed = now - ob.timestamp

            if (UInt64(timeElapsed) > self.sampleLength) {
                let poolRef = self.poolPublicCap.borrow()
                    ?? panic("cannot borrow reference to lendingPool")
                let newSupplyApr: UFix64 = LendingConfig.ScaledUInt256ToUFix64(poolRef.getPoolSupplyAprScaled())
                let newBorrowApr: UFix64 = LendingConfig.ScaledUInt256ToUFix64(poolRef.getPoolBorrowAprScaled())
                // Truncate timestamp for better plotting in frontend
                let samplePeriodStart: UInt64 = UInt64(now) / self.sampleLength * self.sampleLength
                self.aprObservations[idx] = Observation(t: UFix64(samplePeriodStart), supplyApr: newSupplyApr, borrowApr: newBorrowApr)
                emit AprSampled(market: poolRef.getPoolAddress(), truncatedTimestamp: samplePeriodStart, supplyApr: newSupplyApr, borrowApr: newBorrowApr)
                return true
            }
            return false
        }

        pub fun queryHistoricalAprData(scale: UInt8, plotPoints: UInt64): [Observation] {
            let now = getCurrentBlock().timestamp
            let idxNow: UInt64 = self.observationIndexOf(timestamp: now)
            var idxPrev: UInt64 = 0
            switch scale {
                case 0:
                    // idx for timestamp 1 month ago
                    idxPrev = self.observationIndexOf(timestamp: now - 30.0 * 86400.0)
                case 1:
                    // idx for timestamp 6 month ago
                    idxPrev = self.observationIndexOf(timestamp: now - 180.0 * 86400.0)
                case 2:
                    // idx for timestamp 1 year ago. (Use 360 instead of 365 for the purpose of exact-division)
                    idxPrev = self.observationIndexOf(timestamp: now - 360.0 * 86400.0)
                default:
                    panic("invalid spanning param")
            }
            let numSampledPoints = idxPrev < idxNow ? (idxNow - idxPrev + 1) : (self.numSamples + idxNow - idxPrev + 1)
            assert(
                plotPoints <= numSampledPoints,
                message: "invalid plotPoints param: cannot plot due to insufficient samples"
            )
            let step: UInt64 = numSampledPoints / plotPoints
            var res: [Observation] = []
            var i: UInt64 = 0
            while i < plotPoints {
                let ob = self.aprObservations[idxPrev]
                // Filtering non-meaningful data
                if (ob.timestamp > 0.0) {
                    res.append(
                        Observation(
                            t: ob.timestamp,
                            supplyApr: ob.supplyApr,
                            borrowApr: ob.borrowApr
                        )
                    )
                }
                idxPrev = idxPrev + step
                if idxPrev >= self.numSamples {
                    idxPrev = idxPrev - self.numSamples
                }
                i = i + 1
            }
            return res
        }

        pub fun getLatestData(): Observation {
            let now = getCurrentBlock().timestamp
            let idx = self.observationIndexOf(timestamp: now)
            return self.aprObservations[idx]
        }

        /// Proposed params: sampleLength = 21600 (6h) && numSamples = 1460 (store 1 year's data)
        init(poolPublicCap: Capability<&{LendingInterfaces.PoolPublic}>) {
            self.poolPublicCap = poolPublicCap
            // 6h
            self.sampleLength = 21600
            // stores 1 year's data
            self.numSamples = 1460
            self.aprObservations = []
            var i: UInt64 = 0
            // Init circular buffer
            while (i < self.numSamples) {
                self.aprObservations.append(Observation(t: 0.0, supplyApr: 0.0, borrowApr: 0.0))
                i = i + 1
            }
            self._reservedFields = {}
        }
    }

    /// sample() is made public so everyone can sample the given market's apr data, as long as it's expired.
    /// @Returns sampled or not
    pub fun sample(poolAddr: Address): Bool {
        pre {
            self._markets.containsKey(poolAddr) == true:
                LendingError.ErrorEncode(
                        msg: "Market not tracked yet",
                        err: LendingError.ErrorCode.MARKET_NOT_OPEN
                )
        }
        return self._markets[poolAddr]!.sample()
    }

/////////////// TODO: Check if it's ok to pull 120 x (3 UFix64) in 1 script?
    /// A getter function for frontend to query stored samples and plot data.
    /// @scale: Spanning of time the drawing should cover - 0 (1 month), 1 (6 months), 2 (1 year).
    /// @plotPoints: Maximum data points the drawing needs, e.g. 120 points in maximum
    /// @Returns historical apy data in a timestamp-ascending order. Note: only meaningful data is returned, so the length is not guaranteed to be equal to `plotPoints`.
    pub fun queryHistoricalAprData(poolAddr: Address, scale: UInt8, plotPoints: UInt64): [Observation] {
        pre {
            self._markets.containsKey(poolAddr) == true:
                LendingError.ErrorEncode(
                        msg: "Market not tracked yet",
                        err: LendingError.ErrorCode.MARKET_NOT_OPEN
                )
        }
        return self._markets[poolAddr]!.queryHistoricalAprData(scale: scale, plotPoints: plotPoints)
    }

    pub fun getLatestData(poolAddr: Address): Observation {
        return self._markets[poolAddr]!.getLatestData()
    }

    access(contract) fun trackMarketData(poolAddr: Address) {
        pre {
            self._markets.containsKey(poolAddr) == false:
                LendingError.ErrorEncode(
                        msg: "Market has already been tracked",
                        err: LendingError.ErrorCode.ADD_MARKET_DUPLICATED
                )
        }
        // Start tracking a new market
        let poolPublicCap = getAccount(poolAddr).getCapability<&{LendingInterfaces.PoolPublic}>(LendingConfig.PoolPublicPublicPath)
        assert(poolPublicCap.check() == true, message:
            LendingError.ErrorEncode(
                msg: "Cannot borrow reference to PoolPublic resource",
                err: LendingError.ErrorCode.CANNOT_ACCESS_POOL_PUBLIC_CAPABILITY
            )
        )

        self._markets[poolAddr] = AprSnapshot(poolPublicCap: poolPublicCap)
        emit MarketDataTracked(
            market: poolAddr,
            marketType: poolPublicCap.borrow()!.getUnderlyingTypeString(),
            startTrackingFrom: getCurrentBlock().timestamp
        )
    }

    access(contract) fun eraseMarketData(poolAddr: Address) {
        pre {
            self._markets.containsKey(poolAddr) == true:
                LendingError.ErrorEncode(
                        msg: "Market not tracked yet",
                        err: LendingError.ErrorCode.MARKET_NOT_OPEN
                )
        }
        self._markets.remove(key: poolAddr)
        emit MarketDataErased(
            market: poolAddr,
            erasedFrom: getCurrentBlock().timestamp
        )
    }

    pub resource Admin {
        pub fun trackMarketData(poolAddr: Address) {
            LendingAprSnapshot.trackMarketData(poolAddr: poolAddr)
        }
        pub fun eraseMarketData(poolAddr: Address) {
            LendingAprSnapshot.eraseMarketData(poolAddr: poolAddr)
        }
    }

    init() {
        self.AdminStoragePath = /storage/lendingAprSnapshotAdmin
        self._markets = {}
        self._reservedFields = {}

        destroy <-self.account.load<@AnyResource>(from: self.AdminStoragePath)
        self.account.save(<-create Admin(), to: self.AdminStoragePath)
    }
}
"
-------
"//  SPDX-License-Identifier: UNLICENSED
//
//
import NonFungibleToken from 0x1d7e57aa55817448
import Anique from 0xe2e1689b53e92a82

pub contract SGKCLDR_gnms: NonFungibleToken, Anique {
    // -----------------------------------------------------------------------
    // SGKCLDR_gnms contract Events
    // -----------------------------------------------------------------------

    // Events for Contract-Related actions
    //
    // Emitted when the SGKCLDR_gnms contract is created
    pub event ContractInitialized()

    // Events for Item-Related actions
    //
    // Emitted when a new Item struct is created
    pub event ItemCreated(id: UInt32, metadata: {String:String})

    // Events for Collectible-Related actions
    //
    // Emitted when an CollectibleData NFT is minted
    pub event CollectibleMinted(collectibleID: UInt64, itemID: UInt32, serialNumber: UInt32)
    // Emitted when an CollectibleData NFT is destroyed
    pub event CollectibleDestroyed(collectibleID: UInt64)

    // events for Collection-related actions
    //
    // Emitted when an CollectibleData is withdrawn from a Collection
    pub event Withdraw(id: UInt64, from: Address?)
    // Emitted when an CollectibleData is deposited into a Collection
    pub event Deposit(id: UInt64, to: Address?)

    // paths
    pub let collectionStoragePath: StoragePath
    pub let collectionPublicPath: PublicPath
    pub let collectionPrivatePath: PrivatePath
    pub let adminStoragePath: StoragePath
    pub let saleCollectionStoragePath: StoragePath
    pub let saleCollectionPublicPath: PublicPath

    // -----------------------------------------------------------------------
    // SGKCLDR_gnms contract-level fields.
    // These contain actual values that are stored in the smart contract.
    // -----------------------------------------------------------------------

    // fields for Item-related
    //
    // variable size dictionary of Item resources
    access(self) var items: @{UInt32: Item}

    // The ID that is used to create Items.
    pub var nextItemID: UInt32

    // fields for Collectible-related
    //
    // Total number of CollectibleData NFTs that have been minted ever.
    pub var totalSupply: UInt64

    // -----------------------------------------------------------------------
    // SGKCLDR_gnms contract-level Composite Type definitions
    // -----------------------------------------------------------------------

    // The structure that represents Item
    // each digital content which SGKCLDR_gnms deal with on Flow
    //
    pub struct ItemData {

        pub let itemID: UInt32

        pub let metadata: {String: String}

        init(itemID: UInt32) {
            let item = (&SGKCLDR_gnms.items[itemID] as &Item?)!

            self.itemID = item.itemID
            self.metadata = item.metadata
        }
   }

    // Item is a resource type that contains the functions to mint Collectibles.
    //
    // It is stored in a private field in the contract so that
    // the admin resource can call its methods and that there can be
    // public getters for some of its fields
    //
    // The admin can mint Collectibles that refer from Item.
    pub resource Item {

        // unique ID for the Item
        pub let itemID: UInt32

        // Stores all the metadata about the item as a string mapping
        // This is not the long term way NFT metadata will be stored. It's a temporary
        // construct while we figure out a better way to do metadata.
        //
        pub let metadata: {String: String}

        // The number of Collectibles that have been minted per Item.
        access(contract) var numberMintedPerItem: UInt32

        init(metadata: {String: String}) {
            pre {
                metadata.length != 0: "New Item metadata cannot be empty"
            }
            self.itemID = SGKCLDR_gnms.nextItemID
            self.metadata = metadata
            self.numberMintedPerItem = 0

            // increment the nextItemID so that it isn't used again
            SGKCLDR_gnms.nextItemID = SGKCLDR_gnms.nextItemID + 1

            emit ItemCreated(id: self.itemID, metadata: metadata)
        }

        // mintCollectible mints a new Collectible and returns the newly minted Collectible
        //
        // Returns: The NFT that was minted
        //
        pub fun mintCollectible(): @NFT {
            // get the number of Collectibles that have been minted for this Item
            // to use as this Collectible's serial number
            let numInItem = self.numberMintedPerItem

            // mint the new Collectible
            let newCollectible: @NFT <- create NFT(serialNumber: numInItem + 1,
                                              itemID: self.itemID)

            // Increment the count of Collectibles minted for this Item
            self.numberMintedPerItem = numInItem + 1

            return <-newCollectible
        }

        // batchMintCollectible mints an arbitrary quantity of Collectibles
        // and returns them as a Collection
        //
        // Parameters: itemID: the ID of the Item that the Collectibles are minted for
        //             quantity: The quantity of Collectibles to be minted
        //
        // Returns: Collection object that contains all the Collectibles that were minted
        //
        pub fun batchMintCollectible(quantity: UInt64): @Collection {
            let newCollection <- create Collection()

            var i: UInt64 = 0
            while i < quantity {
                newCollection.deposit(token: <-self.mintCollectible())
                i = i + 1
            }

            return <-newCollection
        }

        // Returns: the number of Collectibles
        pub fun getNumberMinted(): UInt32 {
            return self.numberMintedPerItem
        }
    }

    // The structure holds metadata of an Collectible
    pub struct CollectibleData {
        // The ID of the Item that the Collectible references
        pub let itemID: UInt32

        // The place in the Item that this Collectible was minted
        pub let serialNumber: UInt32

        init(itemID: UInt32, serialNumber: UInt32) {
            self.itemID = itemID
            self.serialNumber = serialNumber
        }
    }

    // The resource that represents the CollectibleData NFTs
    //
    pub resource NFT: NonFungibleToken.INFT, Anique.INFT {

        // Global unique collectibleData ID
        pub let id: UInt64

        // Struct of Collectible metadata
        pub let data: CollectibleData

        init(serialNumber: UInt32, itemID: UInt32) {
            // Increment the global Collectible IDs
            SGKCLDR_gnms.totalSupply = SGKCLDR_gnms.totalSupply + 1

            // set id
            self.id = SGKCLDR_gnms.totalSupply

            // Set the metadata struct
            self.data = CollectibleData(itemID: itemID, serialNumber: serialNumber)

            emit CollectibleMinted(collectibleID: self.id, itemID: itemID, serialNumber: self.data.serialNumber)
        }

        destroy() {
            emit CollectibleDestroyed(collectibleID: self.id)
        }
    }

    // interface that represents SGKCLDR_gnms collections to public
    // extends of NonFungibleToken.CollectionPublic
    pub resource interface CollectionPublic {

        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT

        // deposit multi tokens
        pub fun batchDeposit(tokens: @Anique.Collection)

        // contains NFT
        pub fun contains(id: UInt64): Bool

        // borrow NFT as SGKCLDR_gnms token
        pub fun borrowSGKCLDR_gnmsCollectible(id: UInt64): auth &NFT
    }

    // Collection is a resource that every user who owns NFTs
    // will store in their account to manage their NFTs
    //
    pub resource Collection: CollectionPublic, NonFungibleToken.Receiver, NonFungibleToken.Provider, NonFungibleToken.CollectionPublic {
        // Dictionary of CollectibleData conforming tokens
        // NFT is a resource type with a UInt64 ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init() {
            self.ownedNFTs <- {}
        }

        // withdraw removes a Collectible from the Collection and moves it to the caller
        //
        // Parameters: withdrawID: The ID of the NFT
        // that is to be removed from the Collection
        //
        // returns: @NonFungibleToken.NFT the token that was withdrawn
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {

            // Remove the nft from the Collection
            let token <- self.ownedNFTs.remove(key: withdrawID)
                ?? panic("Cannot withdraw: Collectible does not exist in the collection")

            emit Withdraw(id: token.id, from: self.owner?.address)

            // Return the withdrawn token
            return <- token
        }

        // batchWithdraw withdraws multiple tokens and returns them as a Collection
        //
        // Parameters: collectibleIds: An array of IDs to withdraw
        //
        // Returns: @NonFungibleToken.Collection: A collection that contains
        //                                        the withdrawn collectibles
        //
        pub fun batchWithdraw(collectibleIds: [UInt64]): @Anique.Collection {
            // Create a new empty Collection
            var batchCollection <- create Collection()

            // Iterate through the collectibleIds and withdraw them from the Collection
            for collectibleID in collectibleIds {
                batchCollection.deposit(token: <-self.withdraw(withdrawID: collectibleID))
            }

            // Return the withdrawn tokens
            return <-batchCollection
        }

        // deposit takes a Collectible and adds it to the Collections dictionary
        //
        // Parameters: token: the NFT to be deposited in the collection
        //
        pub fun deposit(token: @NonFungibleToken.NFT) {

            // Cast the deposited token as an SGKCLDR_gnms NFT to make sure
            // it is the correct type
            let token <- token as! @SGKCLDR_gnms.NFT

            // Get the token's ID
            let id = token.id

            // Add the new token to the dictionary
            let oldToken <- self.ownedNFTs[id] <- token

            // Only emit a deposit event if the Collection
            // is in an account's storage
            if self.owner?.address != nil {
                emit Deposit(id: id, to: self.owner?.address)
            }

            // Destroy the empty old token that was "removed"
            destroy oldToken
        }

        // batchDeposit takes a Collection object as an argument
        // and deposits each contained NFT into this Collection
        pub fun batchDeposit(tokens: @Anique.Collection) {

            // Get an array of the IDs to be deposited
            let keys = tokens.getIDs()

            // Iterate through the keys in the collection and deposit each one
            for key in keys {
                self.deposit(token: <-tokens.withdraw(withdrawID: key))
            }

            // Destroy the empty Collection
            destroy tokens
        }

        // getIDs returns an array of the IDs that are in the Collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // contains returns whether ID is in the Collection
        pub fun contains(id: UInt64): Bool {
            return self.ownedNFTs[id] != nil
        }

        // borrowNFT Returns a borrowed reference to a Collectible in the Collection
        // so that the caller can read its ID
        //
        // Parameters: id: The ID of the NFT to get the reference for
        //
        // Returns: A reference to the NFT
        //
        // Note: This only allows the caller to read the ID of the NFT,
        // not any SGKCLDR_gnms specific data. Please use borrowCollectible to
        // read Collectible data.
        //
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowAniqueNFT(id: UInt64): auth &Anique.NFT {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            return nft as! auth &Anique.NFT
        }

        // borrowSGKCLDR_gnmsCollectible returns a borrowed reference
        // to an SGKCLDR_gnms Collectible
        pub fun borrowSGKCLDR_gnmsCollectible(id: UInt64): auth &NFT {
            pre {
                self.ownedNFTs[id] != nil: "NFT does not exist in the collection!"
            }
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            return nft as! auth &NFT
        }

        // If a transaction destroys the Collection object,
        // All the NFTs contained within are also destroyed!
        //
        destroy() {
            destroy self.ownedNFTs
        }
    }

    // Admin is a special authorization resource that
    // allows the owner to perform important functions to modify the
    // various aspects of the Items, CollectibleDatas, etc.
    //
    pub resource Admin {

        // createItem creates a new Item struct
        // and stores it in the Items dictionary field in the SGKCLDR_gnms smart contract
        //
        // Parameters: metadata: A dictionary mapping metadata titles to their data
        //                       example: {"Title": "Excellent Anime", "Author": "John Smith"}
        //
        // Returns: the ID of the new Item object
        //
        pub fun createItem(metadata: {String: String}): UInt32 {
            // Create the new Item
            var newItem <- create Item(metadata: metadata)
            let itemId = newItem.itemID

            // Store it in the contract storage
            SGKCLDR_gnms.items[newItem.itemID] <-! newItem

            return itemId
        }

        // borrowItem returns a reference to a Item in the SGKCLDR_gnms
        // contract so that the admin can call methods on it
        //
        // Parameters: itemID: The ID of the Item that you want to
        // get a reference to
        //
        // Returns: A reference to the Item with all of the fields
        // and methods exposed
        //
        pub fun borrowItem(itemID: UInt32): &Item {
            pre {
                SGKCLDR_gnms.items[itemID] != nil: "Cannot borrow Item: The Item doesn't exist"
            }

            return (&SGKCLDR_gnms.items[itemID] as &Item?)!
        }

        // createNewAdmin creates a new Admin resource
        //
        pub fun createNewAdmin(): @Admin {
            return <-create Admin()
        }
    }

    // -----------------------------------------------------------------------
    // SGKCLDR_gnms contract-level function definitions
    // -----------------------------------------------------------------------

    // createEmptyCollection creates a new, empty Collection object so that
    // a user can store it in their account storage.
    // Once they have a Collection in their storage, they are able to receive
    // Collectibles in transactions.
    //
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <-create SGKCLDR_gnms.Collection()
    }

    // getNumCollectiblesInItem return the number of Collectibles that have been
    //                        minted from a certain Item.
    //
    // Parameters: itemID: The id of the Item that is being searched
    //
    // Returns: The total number of Collectibles
    //          that have been minted from a Item
    pub fun getNumCollectiblesInItem(itemID: UInt32): UInt32 {
        let item = (&SGKCLDR_gnms.items[itemID] as &Item?)!
        return item.numberMintedPerItem
    }

    // -----------------------------------------------------------------------
    // SGKCLDR_gnms initialization function
    // -----------------------------------------------------------------------
    //
    init() {
        // Initialize contract fields
        self.items <- {}
        self.nextItemID = 1
        self.totalSupply = 0

        self.collectionStoragePath     = /storage/SGKCLDR_gnmsCollection
        self.collectionPublicPath      =  /public/SGKCLDR_gnmsCollection
        self.collectionPrivatePath     = /private/SGKCLDR_gnmsCollection
        self.adminStoragePath          = /storage/SGKCLDR_gnmsAdmin
        self.saleCollectionStoragePath = /storage/SGKCLDR_gnmsSaleCollection
        self.saleCollectionPublicPath  =  /public/SGKCLDR_gnmsSaleCollection

        // Put a new Collection in storage
        self.account.save<@Collection>(<- create Collection(), to: self.collectionStoragePath)

        // Create a public capability for the Collection
        self.account.link<&{CollectionPublic}>(self.collectionPublicPath, target: self.collectionStoragePath)

        // Put the Admin in storage
        self.account.save<@Admin>(<- create Admin(), to: self.adminStoragePath)

        emit ContractInitialized()
    }
}
"
-------
"// BasicToken.cdc
//
// The BasicToken contract is a sample implementation of a fungible token on Flow.
//
// Fungible tokens behave like everyday currencies -- they can be minted, transferred or
// traded for digital goods.
//
// Follow the fungible tokens tutorial to learn more: https://developers.flow.com/cadence/tutorial/06-fungible-tokens
//
// This is a basic implementation of a Fungible Token and is NOT meant to be used in production
// See the Flow Fungible Token standard for real examples: https://github.com/onflow/flow-ft

pub contract BasicToken {

    // Vault
    //
    // Each user stores an instance of only the Vault in their storage
    // The functions in the Vault and governed by the pre and post conditions
    // in the interfaces when they are called.
    // The checks happen at runtime whenever a function is called.
    //
    // Resources can only be created in the context of the contract that they
    // are defined in, so there is no way for a malicious user to create Vaults
    // out of thin air. A special Minter resource or constructor function needs to be defined to mint
    // new tokens.
    //
    pub resource Vault {

		// keeps track of the total balance of the account's tokens
        pub var balance: UFix64

        // initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        // withdraw
        //
        // Function that takes an integer amount as an argument
        // and withdraws that amount from the Vault.
        //
        // It creates a new temporary Vault that is used to hold
        // the money that is being transferred. It returns the newly
        // created Vault to the context that called so it can be deposited
        // elsewhere.
        //
        pub fun withdraw(amount: UFix64): @Vault {
            self.balance = self.balance - amount
            return <-create Vault(balance: amount)
        }

        // deposit
        //
        // Function that takes a Vault object as an argument and adds
        // its balance to the balance of the owners Vault.
        //
        // It is allowed to destroy the sent Vault because the Vault
        // was a temporary holder of the tokens. The Vault's balance has
        // been consumed and therefore can be destroyed.
        pub fun deposit(from: @Vault) {
            self.balance = self.balance + from.balance
            destroy from
        }
    }

    // createVault
    //
    // Function that creates a new Vault with an initial balance
    // and returns it to the calling context. A user must call this function
    // and store the returned Vault in their storage in order to allow their
    // account to be able to receive deposits of this token type.
    //
    pub fun createVault(): @Vault {
        return <-create Vault(balance: 30.0)
    }

    // The init function for the contract. All fields in the contract must
    // be initialized at deployment. This is just an example of what
    // an implementation could do in the init function. The numbers are arbitrary.
    init() {
        // create the Vault with the initial balance and put it in storage
        // account.save saves an object to the specified `to` path
        // The path is a literal path that consists of a domain and identifier
        // The domain must be `storage`, `private`, or `public`
        // the identifier can be any name
        let vault <- self.createVault()
        self.account.save(<-vault, to: /storage/CadenceFungibleTokenTutorialVault)
    }
}

"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import FUSD from 0x3c5959b568896393

import FlowtyUtils from 0x5c57f79c6694797f

// Flowty
//
// A smart contract responsible for the main lending flows.
// It is facilitating the lending deal, allowing borrowers and lenders
// to be sure that the deal would be executed on their agreed terms.
//
// Each account that wants to list a loan installs a Storefront,
// and lists individual loan within that Storefront as Listings.
// There is one Storefront per account, it handles loans of all NFT types
// for that account.
//
// Each Listing can have one or more "cut"s of the requested loan amount that
// goes to one or more addresses. Cuts are used to pay listing fees
// or other considerations.
// Each NFT may be listed in one or more Listings, the validity of each
// Listing can easily be checked.
//
// Lenders can watch for Listing events and check the NFT type and
// ID to see if they wish to fund the listed loan.
//
pub contract Flowty {
    // FlowtyInitialized
    // This contract has been deployed.
    // Event consumers can now expect events from this contract.
    //
    pub event FlowtyInitialized()

    // FlowtyStorefrontInitialized
    // A FlowtyStorefront resource has been created.
    // Event consumers can now expect events from this FlowtyStorefront.
    // Note that we do not specify an address: we cannot and should not.
    // Created resources do not have an owner address, and may be moved
    // after creation in ways we cannot check.
    // ListingAvailable events can be used to determine the address
    // of the owner of the FlowtyStorefront (...its location) at the time of
    // the listing but only at that precise moment in that precise transaction.
    // If the seller moves the FlowtyStorefront while the listing is valid,
    // that is on them.
    //
    pub event FlowtyStorefrontInitialized(flowtyStorefrontResourceID: UInt64)

    // FlowtyMarketplaceInitialized
    // A FlowtyMarketplace resource has been created.
    // Event consumers can now expect events from this FlowtyStorefront.
    // Note that we do not specify an address: we cannot and should not.
    // Created resources do not have an owner address, and may be moved
    // after creation in ways we cannot check.
    // ListingAvailable events can be used to determine the address
    // of the owner of the FlowtyStorefront (...its location) at the time of
    // the listing but only at that precise moment in that precise transaction.
    // If the seller moves the FlowtyStorefront while the listing is valid,
    // that is on them.
    //
    pub event FlowtyMarketplaceInitialized(flowtyMarketplaceResourceID: UInt64)

    // FlowtyStorefrontDestroyed
    // A FlowtyStorefront has been destroyed.
    // Event consumers can now stop processing events from this FlowtyStorefront.
    // Note that we do not specify an address.
    //
    pub event FlowtyStorefrontDestroyed(flowtyStorefrontResourceID: UInt64)

    // FlowtyMarketplaceDestroyed
    // A FlowtyMarketplace has been destroyed.
    // Event consumers can now stop processing events from this FlowtyMarketplace.
    // Note that we do not specify an address.
    //
    pub event FlowtyMarketplaceDestroyed(flowtyStorefrontResourceID: UInt64)

    // ListingAvailable
    // A listing has been created and added to a FlowtyStorefront resource.
    // The Address values here are valid when the event is emitted, but
    // the state of the accounts they refer to may be changed outside of the
    // FlowtyMarketplace workflow, so be careful to check when using them.
    //
    pub event ListingAvailable(
        flowtyStorefrontAddress: Address,
        flowtyStorefrontID: UInt64,
        listingResourceID: UInt64,
        nftType: String,
        nftID: UInt64,
        amount: UFix64,
        interestRate: UFix64,
        term: UFix64,
        enabledAutoRepayment: Bool,
        royaltyRate: UFix64,
        expiresAfter: UFix64,
        paymentTokenType: String,
        repaymentAddress: Address?
    )

    // ListingCompleted
    // The listing has been resolved. It has either been funded, or removed and destroyed.
    //
    pub event ListingCompleted(
        listingResourceID: UInt64,
        flowtyStorefrontID: UInt64,
        funded: Bool,
        nftID: UInt64,
        nftType: String,
        flowtyStorefrontAddress: Address
    )

    // FundingAvailable
    // A funding has been created and added to a FlowtyStorefront resource.
    // The Address values here are valid when the event is emitted, but
    // the state of the accounts they refer to may be changed outside of the
    // FlowtyMarketplace workflow, so be careful to check when using them.
    //
    pub event FundingAvailable(
        fundingResourceID: UInt64,
        listingResourceID: UInt64,
        borrower: Address,
        lender: Address,
        nftID: UInt64,
        nftType: String,
        repaymentAmount: UFix64,
        enabledAutoRepayment: Bool,
        repaymentAddress: Address?
    )

    // FundingRepaid
    // A funding has been repaid.
    //
    pub event FundingRepaid(
        fundingResourceID: UInt64,
        listingResourceID: UInt64,
        borrower: Address,
        lender: Address,
        nftID: UInt64,
        nftType: String,
        repaymentAmount: UFix64,
        repaymentAddress: Address?
    )

    // FundingSettled
    // A funding has been settled.
    //
    pub event FundingSettled(
        fundingResourceID: UInt64,
        listingResourceID: UInt64,
        borrower: Address,
        lender: Address,
        nftID: UInt64,
        nftType: String,
        repaymentAmount: UFix64,
        repaymentAddress: Address?
    )

    pub event CollectionSupportChanged(
        collectionIdentifier: String,
        state: Bool
    )

    pub event RoyaltyAdded(
        collectionIdentifier: String,
        rate: UFix64
    )

    pub event RoyaltyEscrow(
        fundingResourceID: UInt64,
        listingResourceID: UInt64,
        lender: Address,
        amount: UFix64
    )

    // FlowtyStorefrontStoragePath
    // The location in storage that a FlowtyStorefront resource should be located.
    pub let FlowtyStorefrontStoragePath: StoragePath

    // FlowtyMarketplaceStoragePath
    // The location in storage that a FlowtyMarketplace resource should be located.
    pub let FlowtyMarketplaceStoragePath: StoragePath

    // FlowtyStorefrontPublicPath
    // The public location for a FlowtyStorefront link.
    pub let FlowtyStorefrontPublicPath: PublicPath

    // FlowtyMarketplacePublicPath
    // The public location for a FlowtyMarketplace link.
    pub let FlowtyMarketplacePublicPath: PublicPath

    // FlowtyAdminStoragePath
    // The location in storage that an FlowtyAdmin resource should be located.
    pub let FlowtyAdminStoragePath: StoragePath

    // FusdVaultStoragePath
    // The location in storage that an FUSD Vault resource should be located.
    pub let FusdVaultStoragePath: StoragePath

    // FusdReceiverPublicPath
    // The public location for a FUSD Receiver link.
    pub let FusdReceiverPublicPath: PublicPath

    // FusdBalancePublicPath
    // The public location for a FUSD Balance link.
    pub let FusdBalancePublicPath: PublicPath

    // ListingFee
    // The fixed fee in FUSD for a listing.
    pub var ListingFee: UFix64

    // FundingFee
    // The percentage fee on funding, a number between 0 and 1.
    pub var FundingFee: UFix64

    // SuspendedFundingPeriod
    // The suspended funding period in seconds(started on listing).
    // So that the borrower has some time to delist it.
    pub var SuspendedFundingPeriod: UFix64

    // A dictionary for the Collection to royalty configuration.
    access(account) var Royalties: {String:Royalty}
    access(account) var TokenPaths: {String:PublicPath}

    // The collections which are allowed to be used as collateral
    access(account) var SupportedCollections: {String:Bool}

    // PaymentCut
    // A struct representing a recipient that must be sent a certain amount
    // of the payment when a tx is executed.
    //
    pub struct PaymentCut {
        // The receiver for the payment.
        // Note that we do not store an address to find the Vault that this represents,
        // as the link or resource that we fetch in this way may be manipulated,
        // so to find the address that a cut goes to you must get this struct and then
        // call receiver.borrow().owner.address on it.
        // This can be done efficiently in a script.
        pub let receiver: Capability<&{FungibleToken.Receiver}>

        // The amount of the payment FungibleToken that will be paid to the receiver.
        pub let amount: UFix64

        // initializer
        //
        init(receiver: Capability<&{FungibleToken.Receiver}>, amount: UFix64) {
            self.receiver = receiver
            self.amount = amount
        }
    }

    pub struct Royalty {
        // The percentage points that should go to the collection owner
        // In the event of a loan default
        pub let Rate: UFix64
        pub let Address: Address
        pub let ReceiverPaths: {String: PublicPath}

        init(rate: UFix64, address: Address) {
            self.Rate = rate
            self.Address = address
            self.ReceiverPaths = {}
        }

        access(account) fun addVault(path: PublicPath, vaultType: Type) {
            self.ReceiverPaths[vaultType.identifier] = path
        }
    }

    // ListingDetails
    // A struct containing a Listing's data.
    //
    pub struct ListingDetails {
        // The FlowtyStorefront that the Listing is stored in.
        // Note that this resource cannot be moved to a different FlowtyStorefront
        pub var flowtyStorefrontID: UInt64
        // Whether this listing has been funded or not.
        pub var funded: Bool
        // The Type of the NonFungibleToken.NFT that is being listed.
        pub let nftType: Type
        // The ID of the NFT within that type.
        pub let nftID: UInt64
        // The amount of the requested loan.
        pub let amount: UFix64
        // The interest rate in %, a number between 0 and 1.
        pub let interestRate: UFix64
        //The term in seconds for this listing.
        pub var term: UFix64
        // The Type of the FungibleToken that fundings must be made in.
        pub let paymentVaultType: Type
        // This specifies the division of payment between recipients.
        access(self) let paymentCuts: [PaymentCut]
        //The time the funding start at
        pub var listedTime: UFix64
        // The royalty rate needed as a deposit for this loan to be funded
        pub var royaltyRate: UFix64
        // The number of seconds this listing is valid for
        pub var expiresAfter: UFix64

        // getPaymentCuts
        // Returns payment cuts
        pub fun getPaymentCuts(): [PaymentCut] {
            return self.paymentCuts
        }

        pub fun getTotalPayment(): UFix64 {
            return self.amount * (1.0 + (self.interestRate * Flowty.FundingFee) + self.royaltyRate)
        }

        // setToFunded
        // Irreversibly set this listing as funded.
        //
        access(contract) fun setToFunded() {
            self.funded = true
        }

        // initializer
        //
        init (
            nftType: Type,
            nftID: UInt64,
            amount: UFix64,
            interestRate: UFix64,
            term: UFix64,
            paymentVaultType: Type,
            paymentCuts: [PaymentCut],
            flowtyStorefrontID: UInt64,
            expiresAfter: UFix64,
            royaltyRate: UFix64
        ) {
            self.flowtyStorefrontID = flowtyStorefrontID
            self.funded = false
            self.nftType = nftType
            self.nftID = nftID
            self.amount = amount
            self.interestRate = interestRate
            self.term = term
            self.paymentVaultType = paymentVaultType
            self.listedTime = getCurrentBlock().timestamp
            self.expiresAfter = expiresAfter
            self.royaltyRate = royaltyRate

            assert(paymentCuts.length > 0, message: "Listing must have at least one payment cut recipient")
            self.paymentCuts = paymentCuts

            // Calculate the total price from the cuts
            var cutsAmount = 0.0
            // Perform initial check on capabilities, and calculate payment price from cut amounts.
            for cut in self.paymentCuts {
                // make sure we can borrow the receiver
                cut.receiver.borrow()!
                // Add the cut amount to the total price
                cutsAmount = cutsAmount + cut.amount
            }

            assert(cutsAmount > 0.0, message: "Listing must have non-zero requested amount")
        }
    }

    // ListingPublic
    // An interface providing a useful public interface to a Listing.
    //
    pub resource interface ListingPublic {
        // borrowNFT
        // This will assert in the same way as the NFT standard borrowNFT()
        // if the NFT is absent, for example if it has been sold via another listing.
        //
        pub fun borrowNFT(): &NonFungibleToken.NFT

        // fund
        // Fund the listing.
        // This pays the beneficiaries and returns the token to the buyer.
        //
        pub fun fund(payment: @FungibleToken.Vault,
            lenderFungibleTokenReceiver: Capability<&{FungibleToken.Receiver}>,
            lenderNFTCollection: Capability<&AnyResource{NonFungibleToken.CollectionPublic}>)

        // getDetails
        //
        pub fun getDetails(): ListingDetails

        // suspensionTimeRemaining
        //
        pub fun suspensionTimeRemaining() : Fix64

        // remainingTimeToFund
        //
        pub fun remainingTimeToFund(): Fix64

        // isFundingEnabled
        //
        pub fun isFundingEnabled(): Bool
    }


    // Listing
    // A resource that allows an NFT to be fund for an amount of a given FungibleToken,
    // and for the proceeds of that payment to be split between several recipients.
    //
    pub resource Listing: ListingPublic {
        // The simple (non-Capability, non-complex) details of the listing
        access(self) let details: ListingDetails

        // A capability allowing this resource to withdraw the NFT with the given ID from its collection.
        // This capability allows the resource to withdraw *any* NFT, so you should be careful when giving
        // such a capability to a resource and always check its code to make sure it will use it in the
        // way that it claims.
        access(contract) let nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>

        // A capability allowing this resource to access the owner's NFT public collection
        access(contract) let nftPublicCollectionCapability: Capability<&AnyResource{NonFungibleToken.CollectionPublic}>


        // A capability allowing this resource to withdraw `FungibleToken`s from borrower account.
        // This capability allows loan repayment if there is system downtime, which will prevent NFT losing.
        // NOTE: This variable cannot be renamed but it can allow any FungibleToken.
        access(contract) let fusdProviderCapability: Capability<&{FungibleToken.Provider}>?

        // borrowNFT
        // This will assert in the same way as the NFT standard borrowNFT()
        // if the NFT is absent, for example if it has been sold via another listing.
        //
        pub fun borrowNFT(): &NonFungibleToken.NFT {
            let ref = self.nftProviderCapability.borrow()!.borrowNFT(id: self.getDetails().nftID)
            assert(ref.getType() == self.getDetails().nftType, message: "token has wrong type")
            assert(ref.id == self.getDetails().nftID, message: "token has wrong ID")
            return ref
        }

        // getDetails
        // Get the details of the current state of the Listing as a struct.
        // This avoids having more public variables and getter methods for them, and plays
        // nicely with scripts (which cannot return resources).
        //
        pub fun getDetails(): ListingDetails {
            return self.details
        }

        // fund
        // Fund the listing.
        // This pays the beneficiaries and move the NFT to the funding resource stored in the marketplace account.
        //
        pub fun fund(payment: @FungibleToken.Vault,
            lenderFungibleTokenReceiver: Capability<&{FungibleToken.Receiver}>,
            lenderNFTCollection: Capability<&AnyResource{NonFungibleToken.CollectionPublic}>) {
            pre {
                self.isFundingEnabled(): "Funding is not enabled or this listing has expired"
                self.details.funded == false: "listing has already been funded"
                payment.isInstance(self.details.paymentVaultType): "payment vault is not requested fungible token"
                payment.balance == self.details.getTotalPayment(): "payment vault does not contain requested amount"
                self.nftProviderCapability.check(): "nftProviderCapability failed check"
            }

            // Make sure the listing cannot be funded again.
            self.details.setToFunded()

            // Fetch the token to return to the purchaser.
            let nft <-self.nftProviderCapability.borrow()!.withdraw(withdrawID: self.details.nftID)
            let ref = &nft as &NonFungibleToken.NFT
            assert(FlowtyUtils.isSupported(ref), message: "nft type is not supported")

            // Neither receivers nor providers are trustworthy, they must implement the correct
            // interface but beyond complying with its pre/post conditions they are not gauranteed
            // to implement the functionality behind the interface in any given way.
            // Therefore we cannot trust the Collection resource behind the interface,
            // and we must check the NFT resource it gives us to make sure that it is the correct one.
            assert(nft.isInstance(self.details.nftType), message: "withdrawn NFT is not of specified type")
            assert(nft.id == self.details.nftID, message: "withdrawn NFT does not have specified ID")

            // Rather than aborting the transaction if any receiver is absent when we try to pay it,
            // we send the cut to the first valid receiver.
            // The first receiver should therefore either be the borrower, or an agreed recipient for
            // any unpaid cuts.
            var residualReceiver: &{FungibleToken.Receiver}? = nil

            // Pay each beneficiary their amount of the payment.
            for cut in self.details.getPaymentCuts() {
                if cut.receiver.check() {
                    let receiver = cut.receiver.borrow()!
                    let paymentCut <- payment.withdraw(amount: cut.amount)
                    receiver.deposit(from: <-paymentCut)
                    if (residualReceiver == nil) {
                        residualReceiver = receiver
                    }
                }
            }

            // Funding fee
            let fundingFeeAmount = self.details.amount * self.details.interestRate * Flowty.FundingFee
            let fundingFee <- payment.withdraw(amount: fundingFeeAmount)
            let feeTokenPath = Flowty.TokenPaths[self.details.paymentVaultType.identifier]!
            let flowtyFeeReceiver = Flowty.account.getCapability<&AnyResource{FungibleToken.Receiver}>(feeTokenPath)!.borrow()!
            flowtyFeeReceiver.deposit(from: <-fundingFee)

            // Royalty
            // Deposit royalty amount
            let royalty = self.details.royaltyRate

            var royaltyVault: @FungibleToken.Vault? <- nil
            if self.details.royaltyRate > 0.0 {
                let tmp <- royaltyVault <- payment.withdraw(amount: self.details.amount * royalty)
                destroy tmp
            }

            assert(residualReceiver != nil, message: "No valid payment receivers")

            // At this point, if all recievers were active and availabile, then the payment Vault will have
            // zero tokens left, and this will functionally be a no-op that consumes the empty vault
            residualReceiver!.deposit(from: <-payment)

            let listingResourceID = self.uuid

            // If the listing is funded, we regard it as completed here.
            // Otherwise we regard it as completed in the destructor.
            emit ListingCompleted(
                listingResourceID: listingResourceID,
                flowtyStorefrontID: self.details.flowtyStorefrontID,
                funded: self.details.funded,
                nftID: self.details.nftID,
                nftType: self.details.nftType.identifier,
                flowtyStorefrontAddress: self.nftPublicCollectionCapability.address
            )

            let repaymentAmount = self.details.amount + self.details.amount * self.details.interestRate

            let marketplace = Flowty.borrowMarketplace()
            marketplace.createFunding(
                flowtyStorefrontID: self.details.flowtyStorefrontID,
                listingResourceID: listingResourceID,
                ownerNFTCollection: self.nftPublicCollectionCapability,
                lenderNFTCollection: lenderNFTCollection,
                NFT: <-nft,
                paymentVaultType: self.details.paymentVaultType,
                lenderFungibleTokenReceiver: lenderFungibleTokenReceiver,
                repaymentAmount: repaymentAmount,
                term: self.details.term,
                fusdProviderCapability: self.fusdProviderCapability,
                royaltyVault: <-royaltyVault,
                listingDetails: self.getDetails()
            )
        }

        // suspensionTimeRemaining
        // The remaining time. This can be negative if is expired
        pub fun suspensionTimeRemaining() : Fix64 {
            let listedTime = self.details.listedTime
            let currentTime = getCurrentBlock().timestamp

            let remaining = Fix64(listedTime+Flowty.SuspendedFundingPeriod) - Fix64(currentTime)

            return remaining
        }

        // remainingTimeToFund
        // The time in seconds left until this listing is no longer valid
        pub fun remainingTimeToFund(): Fix64 {
            let listedTime = self.details.listedTime
            let currentTime = getCurrentBlock().timestamp
            let remaining = Fix64(listedTime + self.details.expiresAfter) - Fix64(currentTime)
            return remaining
        }

        // isFundingEnabled
        pub fun isFundingEnabled(): Bool {
            let timeRemaining = self.suspensionTimeRemaining()
            let listingTimeRemaining = self.remainingTimeToFund()
            return timeRemaining < Fix64(0.0) && listingTimeRemaining > Fix64(0.0)
        }

        // initializer
        //
        init (
            nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,
            nftPublicCollectionCapability: Capability<&AnyResource{NonFungibleToken.CollectionPublic}>,
            fusdProviderCapability: Capability<&{FungibleToken.Provider}>?,
            nftType: Type,
            nftID: UInt64,
            amount: UFix64,
            interestRate: UFix64,
            term: UFix64,
            paymentVaultType: Type,
            paymentCuts: [PaymentCut],
            flowtyStorefrontID: UInt64,
            expiresAfter: UFix64,
            royaltyRate: UFix64
        ) {
            // Store the sale information
            self.details = ListingDetails(
                nftType: nftType,
                nftID: nftID,
                amount: amount,
                interestRate: interestRate,
                term: term,
                paymentVaultType: paymentVaultType,
                paymentCuts: paymentCuts,
                flowtyStorefrontID: flowtyStorefrontID,
                expiresAfter: expiresAfter,
                royaltyRate: royaltyRate
            )

            // Store the NFT provider
            self.nftProviderCapability = nftProviderCapability

            self.fusdProviderCapability = fusdProviderCapability

            self.nftPublicCollectionCapability = nftPublicCollectionCapability

            // Check that the provider contains the NFT.
            // We will check it again when the token is funded.
            // We cannot move this into a function because initializers cannot call member functions.
            let provider = self.nftProviderCapability.borrow()!

            // This will precondition assert if the token is not available.
            let nft = provider.borrowNFT(id: self.details.nftID)
            assert(nft.isInstance(self.details.nftType), message: "token is not of specified type")
            assert(nft.id == self.details.nftID, message: "token does not have specified ID")
        }

        // destructor
        //
        destroy () {
            // We regard the listing as completed here.
            emit ListingCompleted(
                listingResourceID: self.uuid,
                flowtyStorefrontID: self.details.flowtyStorefrontID,
                funded: self.details.funded,
                nftID: self.details.nftID,
                nftType: self.details.nftType.identifier,
                flowtyStorefrontAddress: self.nftPublicCollectionCapability.address
            )
        }
    }

    // FundingDetails
    // A struct containing a Fundings's data.
    //
    pub struct FundingDetails {
        // The FlowtyStorefront that the Funding is stored in.
        // Note that this resource cannot be moved to a different FlowtyStorefront
        pub var flowtyStorefrontID: UInt64
        pub var listingResourceID: UInt64

        // Whether this funding has been repaid or not.
        pub var repaid: Bool

        // Whether this funding has been settled or not.
        pub var settled: Bool

        // The Type of the FungibleToken that fundings must be repaid.
        pub let paymentVaultType: Type

        // The amount that must be repaid in the specified FungibleToken.
        pub let repaymentAmount: UFix64

        // the time the funding start at
        pub var startTime: UFix64

        // The length in seconds for this funding
        pub var term: UFix64

        // setToRepaid
        // Irreversibly set this funding as repaid.
        //
        access(contract) fun setToRepaid() {
            self.repaid = true
        }

        // setToSettled
        // Irreversibly set this funding as settled.
        //
        access(contract) fun setToSettled() {
            self.settled = true
        }

        // initializer
        //
        init (
            flowtyStorefrontID: UInt64,
            listingResourceID: UInt64,
            paymentVaultType: Type,
            repaymentAmount: UFix64,
            term: UFix64
        ) {
            self.flowtyStorefrontID = flowtyStorefrontID
            self.listingResourceID = listingResourceID
            self.paymentVaultType = paymentVaultType
            self.repaid = false
            self.settled = false
            self.repaymentAmount = repaymentAmount
            self.term = term
            self.startTime = getCurrentBlock().timestamp
        }
    }

    // FundingPublic
    // An interface providing a useful public interface to a Funding.
    //
    pub resource interface FundingPublic {

        // repay
        //
        pub fun repay(payment: @FungibleToken.Vault)

        // getDetails
        //
        pub fun getDetails(): FundingDetails

        // get the listing details for this loan
        //
        pub fun getListingDetails(): Flowty.ListingDetails

        // timeRemaining
        //
        pub fun timeRemaining() : Fix64

        // isFundingExpired
        //
        pub fun isFundingExpired(): Bool

        // get the amount stored in a vault for royalty payouts
        //
        pub fun getRoyaltyAmount(): UFix64?

        pub fun settleFunding()
    }

    // Funding
    //
    pub resource Funding: FundingPublic {
        // The simple (non-Capability, non-complex) details of the listing
        access(self) let details: FundingDetails
        access(self) let listingDetails: ListingDetails

        // A capability allowing this resource to access the owner's NFT public collection
        access(contract) let ownerNFTCollection: Capability<&AnyResource{NonFungibleToken.CollectionPublic}>

        // A capability allowing this resource to access the lender's NFT public collection
        access(contract) let lenderNFTCollection: Capability<&AnyResource{NonFungibleToken.CollectionPublic}>

        // The receiver for the repayment.
        access(contract) let lenderFungibleTokenReceiver: Capability<&{FungibleToken.Receiver}>

        // NFT escrow
        access(contract) var NFT: @NonFungibleToken.NFT?

        // FUSD Allowance
        access(contract) let fusdProviderCapability: Capability<&{FungibleToken.Provider}>?

        // royalty payment vault to be deposited to the specified desination on repayment or default
        access(contract) var royaltyVault: @FungibleToken.Vault?

        // getDetails
        // Get the details of the current state of the Listing as a struct.
        // This avoids having more public variables and getter methods for them, and plays
        // nicely with scripts (which cannot return resources).
        //
        pub fun getDetails(): FundingDetails {
            return self.details
        }

        pub fun getListingDetails(): ListingDetails {
            return self.listingDetails
        }

        pub fun getRoyaltyAmount(): UFix64? {
            return self.royaltyVault?.balance
        }

        // repay
        // Repay the funding.
        // This pays the lender and returns the NFT to the owner.
        //
        pub fun repay(payment: @FungibleToken.Vault) {
            pre {
                !self.isFundingExpired(): "the loan has expired"
                self.details.repaid == false: "funding has already been repaid"
                payment.isInstance(self.details.paymentVaultType): "payment vault is not requested fungible token"
                payment.balance == self.details.repaymentAmount: "payment vault does not contain requested price"
            }

            self.details.setToRepaid()
            let royaltyAmount = self.royaltyVault != nil ? self.royaltyVault?.balance! : 0.0

            let NFT <- self.NFT <- nil
            let nftID = NFT?.id
            let nftType = NFT?.getType()!

            FlowtyUtils.trySendNFT(nft: <-NFT!, receiver: self.ownerNFTCollection)

            let royaltyVault <- self.royaltyVault <- nil
            if royaltyVault != nil {
                let vault <-! royaltyVault!
                vault.deposit(from: <-payment.withdraw(amount: self.details.repaymentAmount))
                destroy payment
                assert(vault.balance == self.details.repaymentAmount + royaltyAmount, message: "insufficient balance to send to lender" )

                FlowtyUtils.trySendFungibleTokenVault(vault: <-vault, receiver: self.lenderFungibleTokenReceiver)
            } else {
                FlowtyUtils.trySendFungibleTokenVault(vault: <-payment, receiver: self.lenderFungibleTokenReceiver)
                destroy royaltyVault
            }

            let borrower = self.ownerNFTCollection.address
            let lender = self.lenderFungibleTokenReceiver.address
            emit FundingRepaid(
                fundingResourceID: self.uuid,
                listingResourceID: self.details.listingResourceID,
                borrower: borrower,
                lender: lender,
                nftID: nftID!,
                nftType: nftType.identifier,
                repaymentAmount: self.details.repaymentAmount,
                repaymentAddress: self.fusdProviderCapability?.address
            )
        }

        // repay
        // Repay the funding with borrower permit.
        // This pays the lender and returns the NFT to the owner using FUSD allowance from borrower account.
        //
        pub fun repayWithPermit() {
            pre {
                self.details.repaid == false: "funding has already been repaid"
                self.details.settled == false: "funding has already been settled"
                self.fusdProviderCapability!.check(): "listing is created without FUSD allowance"
            }

            self.details.setToRepaid()
            let royaltyAmount = self.royaltyVault != nil ? self.royaltyVault?.balance! : 0.0

            let NFT <- self.NFT <- nil
            let nftID = NFT?.id
            let nftType = NFT?.getType()!

            let borrowerVault = self.fusdProviderCapability!.borrow()!
            let payment <- borrowerVault.withdraw(amount: self.details.repaymentAmount)

            FlowtyUtils.trySendNFT(nft: <-NFT!, receiver: self.ownerNFTCollection)

            let royaltyVault <- self.royaltyVault <- nil
            let vault <-! royaltyVault!
            vault.deposit(from: <-payment.withdraw(amount: self.details.repaymentAmount))
            destroy payment
            assert(vault.balance == self.details.repaymentAmount + royaltyAmount, message: "insufficient balance to send to lender" )

            FlowtyUtils.trySendFungibleTokenVault(vault: <-vault, receiver: self.lenderFungibleTokenReceiver)

            let borrower = self.ownerNFTCollection.address
            let lender = self.lenderFungibleTokenReceiver.address
            emit FundingRepaid(
                fundingResourceID: self.uuid,
                listingResourceID: self.details.listingResourceID,
                borrower: borrower,
                lender: lender,
                nftID: nftID!,
                nftType: nftType.identifier,
                repaymentAmount: self.details.repaymentAmount,
                repaymentAddress: self.fusdProviderCapability?.address
            )
        }

        // settleFunding
        // Settle the different statuses responsible for the repayment and claiming processes.
        // NFT is moved to the lender, because the borrower hasn't repaid the loan.
        //
        pub fun settleFunding() {
            pre {
                self.isFundingExpired(): "the loan hasn't expired"
                self.details.repaid == false: "funding has already been repaid"
                self.details.settled == false: "funding has already been settled"
            }

            let lender = self.lenderNFTCollection.address
            let borrower = self.ownerNFTCollection.address

            let repayer = self.fusdProviderCapability?.address ?? nil
            let borrowerTokenBalance = repayer != nil ? FlowtyUtils.getTokenBalance(address: repayer!, vaultType: self.details.paymentVaultType) : 0.0

            let ref = &self.NFT as &NonFungibleToken.NFT?
            let royalties = ref!.resolveView(Type<MetadataViews.Royalties>()) as! MetadataViews.Royalties?

            let NFT <- self.NFT <- nil
            let nftID = NFT?.id
            let nftType = NFT?.getType()!

            if borrowerTokenBalance >= self.details.repaymentAmount && self.fusdProviderCapability?.check() == true {
                // borrower has funds to repay loan
                // repay lender
                // return NFT to owner
                self.details.setToRepaid()

                let borrowerVault = self.fusdProviderCapability!.borrow()!
                let payment <- borrowerVault.withdraw(amount: self.details.repaymentAmount)

                FlowtyUtils.trySendNFT(nft: <-NFT!, receiver: self.ownerNFTCollection)

                let repaymentVault <- payment
                let royaltyVault <- self.royaltyVault <- nil
                if royaltyVault != nil {
                    repaymentVault.deposit(from: <-royaltyVault!)
                } else {
                    destroy royaltyVault
                }

                FlowtyUtils.trySendFungibleTokenVault(vault: <-repaymentVault, receiver: self.lenderFungibleTokenReceiver)

                emit FundingRepaid(
                    fundingResourceID: self.uuid,
                    listingResourceID: self.details.listingResourceID,
                    borrower: borrower,
                    lender: lender,
                    nftID: nftID!,
                    nftType: nftType.identifier,
                    repaymentAmount: self.details.repaymentAmount,
                    repaymentAddress: self.fusdProviderCapability?.address
                )

                return
            }

            // loan defaults; move NFT to lender as payment
            self.details.setToSettled()
            assert(NFT != nil, message: "NFT is already moved")
            FlowtyUtils.trySendNFT(nft: <-NFT!, receiver: self.lenderNFTCollection)

            emit FundingSettled(
                fundingResourceID: self.uuid,
                listingResourceID: self.details.listingResourceID,
                borrower: borrower,
                lender: lender,
                nftID: nftID!,
                nftType: nftType.identifier,
                repaymentAmount: self.details.repaymentAmount,
                repaymentAddress: self.fusdProviderCapability?.address
            )

            let royaltyVault <- self.royaltyVault <- nil
            if royaltyVault == nil {
                destroy royaltyVault
                return
            }

            let v <- royaltyVault!
            let originalBalance = v.balance
            if v.balance == 0.0 {
                destroy v
                return
            }

            if royalties == nil {
                // no defined royalties on this NFT, return is back to the lender
                FlowtyUtils.trySendFungibleTokenVault(vault: <-v, receiver: self.lenderFungibleTokenReceiver)
                return
            }

            // distribute royalties!
            let royaltyTokenPath = Flowty.TokenPaths[self.details.paymentVaultType.identifier]!
            let cuts = royalties!.getRoyalties()
            FlowtyUtils.distributeRoyalties(v: <-v, cuts: cuts, path: royaltyTokenPath)
        }

        // timeRemaining
        // The remaining time. This can be negative if is expired
        pub fun timeRemaining() : Fix64 {
            let fundingTerm = self.details.term

            let startTime = self.details.startTime
            let currentTime = getCurrentBlock().timestamp

            let remaining = Fix64(startTime+fundingTerm) - Fix64(currentTime)

            return remaining
        }

        // isFundingExpired
        pub fun isFundingExpired(): Bool {
            let timeRemaining= self.timeRemaining()
            return timeRemaining < Fix64(0.0)
        }

        // initializer
        //
        init (
            flowtyStorefrontID: UInt64,
            listingResourceID: UInt64,
            ownerNFTCollection: Capability<&AnyResource{NonFungibleToken.CollectionPublic}>,
            lenderNFTCollection: Capability<&AnyResource{NonFungibleToken.CollectionPublic}>,
            NFT: @NonFungibleToken.NFT,
            paymentVaultType: Type,
            repaymentAmount: UFix64,
            lenderFungibleTokenReceiver: Capability<&{FungibleToken.Receiver}>,
            term: UFix64,
            fusdProviderCapability: Capability<&{FungibleToken.Provider}>?,
            royaltyVault: @FungibleToken.Vault?,
            listingDetails: ListingDetails
        ) {
            self.ownerNFTCollection = ownerNFTCollection
            self.lenderNFTCollection = lenderNFTCollection
            self.lenderFungibleTokenReceiver = lenderFungibleTokenReceiver
            self.fusdProviderCapability = fusdProviderCapability
            self.listingDetails = listingDetails
            self.NFT <-NFT
            self.royaltyVault <-royaltyVault

            // Store the detailed information
            self.details = FundingDetails(
                flowtyStorefrontID: flowtyStorefrontID,
                listingResourceID: listingResourceID,
                paymentVaultType: paymentVaultType,
                repaymentAmount: repaymentAmount,
                term: term
            )
        }

        destroy() {
            // send the NFT back to the owner
            if self.NFT != nil {
                let NFT <- self.NFT <- nil
                self.ownerNFTCollection.borrow()!.deposit(token: <-NFT!)
            }
            destroy self.NFT

            if self.royaltyVault != nil {
                let royaltyVault <- self.royaltyVault <- nil
                self.lenderFungibleTokenReceiver.borrow()!.deposit(from: <-royaltyVault!)
            }
            destroy self.royaltyVault
        }
    }

    // FlowtyMarketplaceManager
    // An interface for adding and removing Fundings within a FlowtyMarketplace,
    // intended for use by the FlowtyStorefront's own
    //
    pub resource interface FlowtyMarketplaceManager {
        // createFunding
        // Allows the FlowtyMarketplace owner to create and insert Fundings.
        //
        access(contract) fun createFunding(
            flowtyStorefrontID: UInt64,
            listingResourceID: UInt64,
            ownerNFTCollection: Capability<&AnyResource{NonFungibleToken.CollectionPublic}>,
            lenderNFTCollection: Capability<&AnyResource{NonFungibleToken.CollectionPublic}>,
            NFT: @NonFungibleToken.NFT,
            paymentVaultType: Type,
            lenderFungibleTokenReceiver: Capability<&{FungibleToken.Receiver}>,
            repaymentAmount: UFix64,
            term: UFix64,
            fusdProviderCapability: Capability<&{FungibleToken.Provider}>?,
            royaltyVault: @FungibleToken.Vault?,
            listingDetails: ListingDetails
        ): UInt64
        // removeFunding
        // Allows the FlowtyMarketplace owner to remove any funding.
        //
        pub fun removeFunding(fundingResourceID: UInt64)

        pub fun borrowPrivateFunding(fundingResourceID: UInt64): &Funding?
    }

    // FlowtyMarketplacePublic
    // An interface to allow listing and borrowing Listings, and funding loans via Listings
    // in a FlowtyStorefront.
    //
    pub resource interface FlowtyMarketplacePublic {
        pub fun getFundingIDs(): [UInt64]
        pub fun borrowFunding(fundingResourceID: UInt64): &Funding{FundingPublic}?
        pub fun getAllowedCollections(): [String]
    }

    // FlowtyStorefront
    // A resource that allows its owner to manage a list of Listings, and anyone to interact with them
    // in order to query their details and fund the loans that they represent.
    //
    pub resource FlowtyMarketplace : FlowtyMarketplaceManager, FlowtyMarketplacePublic {
        // The dictionary of Fundings uuids to Funding resources.
        access(self) var fundings: @{UInt64: Funding}

        // insert
        // Create and publish a funding for an NFT.
        //
        access(contract) fun createFunding(
            flowtyStorefrontID: UInt64,
            listingResourceID: UInt64,
            ownerNFTCollection: Capability<&AnyResource{NonFungibleToken.CollectionPublic}>,
            lenderNFTCollection: Capability<&AnyResource{NonFungibleToken.CollectionPublic}>,
            NFT: @NonFungibleToken.NFT,
            paymentVaultType: Type,
            lenderFungibleTokenReceiver: Capability<&{FungibleToken.Receiver}>,
            repaymentAmount: UFix64,
            term: UFix64,
            fusdProviderCapability: Capability<&{FungibleToken.Provider}>?,
            royaltyVault: @FungibleToken.Vault?,
            listingDetails: ListingDetails
         ): UInt64 {
            // FundingAvailable event fields
            let nftID = NFT.id
            let nftType = NFT.getType()

            let lenderVaultCap = lenderFungibleTokenReceiver.borrow()!
            let lender = lenderVaultCap.owner!.address

            let borrowerNFTCollectionCap = ownerNFTCollection.borrow()!
            let borrower = borrowerNFTCollectionCap.owner!.address

            // Create funding resource
            let funding <- create Funding(
                flowtyStorefrontID: flowtyStorefrontID,
                listingResourceID: listingResourceID,
                ownerNFTCollection: ownerNFTCollection,
                lenderNFTCollection: lenderNFTCollection,
                NFT: <-NFT,
                paymentVaultType: paymentVaultType,
                repaymentAmount: repaymentAmount,
                lenderFungibleTokenReceiver: lenderFungibleTokenReceiver,
                term: term,
                fusdProviderCapability: fusdProviderCapability,
                royaltyVault: <-royaltyVault,
                listingDetails: listingDetails
            )

            let fundingResourceID = funding.uuid

            // Add the new Funding to the dictionary.
            let oldFunding <- self.fundings[fundingResourceID] <- funding
            // Note that oldFunding will always be nil, but we have to handle it.
            destroy oldFunding

            let enabledAutoRepayment = fusdProviderCapability != nil

            emit FundingAvailable(
                fundingResourceID: fundingResourceID,
                listingResourceID: listingResourceID,
                borrower: borrower,
                lender: lender,
                nftID: nftID,
                nftType: nftType.identifier,
                repaymentAmount: repaymentAmount,
                enabledAutoRepayment: enabledAutoRepayment,
                repaymentAddress: fusdProviderCapability?.address
            )

            return fundingResourceID
        }

        // removeFunding
        // Remove a Funding.
        //
        pub fun removeFunding(fundingResourceID: UInt64) {
            let funding <- self.fundings.remove(key: fundingResourceID)
                ?? panic("missing Funding")

            assert(funding.getDetails().repaid == true || funding.getDetails().settled == true, message: "funding is not repaid or settled")

            // This will emit a FundingCompleted event.
            destroy funding
        }

        // getFundingIDs
        // Returns an array of the Funding resource IDs that are in the collection
        //
        pub fun getFundingIDs(): [UInt64] {
            return self.fundings.keys
        }

        // borrowFunding
        // Returns a read-only view of the Funding for the given fundingID if it is contained by this collection.
        //
        pub fun borrowFunding(fundingResourceID: UInt64): &Funding{FundingPublic}? {
            if self.fundings[fundingResourceID] != nil {
                return &self.fundings[fundingResourceID] as! &Funding{FundingPublic}?
            } else {
                return nil
            }
        }

        // borrowPrivateFunding
        // Returns a private view of the Funding for the given fundingID if it is contained by this collection.
        //
        pub fun borrowPrivateFunding(fundingResourceID: UInt64): &Funding? {
            if self.fundings[fundingResourceID] != nil {
                return &self.fundings[fundingResourceID] as! &Funding?
            } else {
                return nil
            }
        }

        pub fun getAllowedCollections(): [String] {
            return Flowty.SupportedCollections.keys
        }

        // destructor
        //
        destroy () {
            destroy self.fundings

            // Let event consumers know that this marketplace will no longer exist
            emit FlowtyMarketplaceDestroyed(flowtyStorefrontResourceID: self.uuid)
        }

        // constructor
        //
        init () {
            self.fundings <- {}

            // Let event consumers know that this storefront exists
            emit FlowtyMarketplaceInitialized(flowtyMarketplaceResourceID: self.uuid)
        }
    }

    // FlowtyStorefrontManager
    // An interface for adding and removing Listings within a FlowtyStorefront,
    // intended for use by the FlowtyStorefront's own
    pub resource interface FlowtyStorefrontManager {
        // createListing
        // Allows the FlowtyStorefront owner to create and insert Listings.
        //
        pub fun createListing(
            payment: @FungibleToken.Vault,
            nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,
            nftPublicCollectionCapability: Capability<&AnyResource{NonFungibleToken.CollectionPublic}>,
            fusdProviderCapability: Capability<&{FungibleToken.Provider}>?,
            nftType: Type,
            nftID: UInt64,
            amount: UFix64,
            interestRate: UFix64,
            term: UFix64,
            paymentVaultType: Type,
            paymentCuts: [PaymentCut],
            expiresAfter: UFix64
        ): UInt64
        // removeListing
        // Allows the FlowtyStorefront owner to remove any sale listing, accepted or not.
        //
        pub fun removeListing(listingResourceID: UInt64)
    }

    // FlowtyStorefrontPublic
    // An interface to allow listing and borrowing Listings, and funding loans via Listings
    // in a FlowtyStorefront.
    //
    pub resource interface FlowtyStorefrontPublic {
        pub fun getListingIDs(): [UInt64]
        pub fun borrowListing(listingResourceID: UInt64): &Listing{ListingPublic}?
        pub fun cleanup(listingResourceID: UInt64)
        pub fun getRoyalties(): {String:Flowty.Royalty}
   }

    // FlowtyStorefront
    // A resource that allows its owner to manage a list of Listings, and anyone to interact with them
    // in order to query their details and fund the loans that they represent.
    //
    pub resource FlowtyStorefront : FlowtyStorefrontManager, FlowtyStorefrontPublic {
        // The dictionary of Listing uuids to Listing resources.
        access(self) var listings: @{UInt64: Listing}

        // insert
        // Create and publish a Listing for an NFT.
        //
         pub fun createListing(
            payment: @FungibleToken.Vault,
            nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,
            nftPublicCollectionCapability: Capability<&AnyResource{NonFungibleToken.CollectionPublic}>,
            fusdProviderCapability: Capability<&{FungibleToken.Provider}>?,
            nftType: Type,
            nftID: UInt64,
            amount: UFix64,
            interestRate: UFix64,
            term: UFix64,
            paymentVaultType: Type,
            paymentCuts: [PaymentCut],
            expiresAfter: UFix64
         ): UInt64 {
             pre {
                // We don't allow all tokens to be used as payment. Check that the provided one is supported.
                FlowtyUtils.isTokenSupported(type: paymentVaultType): "provided payment type is not supported"
                // make sure that the FUSD vault has at least the listing fee
                payment.balance == Flowty.ListingFee: "payment vault does not contain requested listing fee amount"
                // check that the repayment token type is the same as the payment token if repayment is not nil
                fusdProviderCapability == nil || fusdProviderCapability!.check() && fusdProviderCapability!.borrow()!.getType() == paymentVaultType: "repayment vault type and payment vault type do not match"
                // There are no listing fees right now so this will ensure that no one attempts to send any
                payment.balance == 0.0: "no listing fee required"
                // make sure the payment type is the same as paymentVaultType
                payment.getType() == paymentVaultType: "payment type and paymentVaultType do not match"
                nftProviderCapability.check(): "invalid nft provider"
            }

            let nft = nftProviderCapability.borrow()!.borrowNFT(id: nftID)
            assert(nft.getType() == nftType, message: "incorrect nft type")
            assert(FlowtyUtils.isSupported(nft), message: "nft type is not supported")

            let royaltyRate = FlowtyUtils.getRoyaltyRate(nft)

            let listing <- create Listing(
                nftProviderCapability: nftProviderCapability,
                nftPublicCollectionCapability: nftPublicCollectionCapability,
                fusdProviderCapability: fusdProviderCapability,
                nftType: nftType,
                nftID: nftID,
                amount: amount,
                interestRate: interestRate,
                term: term,
                paymentVaultType: paymentVaultType,
                paymentCuts: paymentCuts,
                flowtyStorefrontID: self.uuid,
                expiresAfter: expiresAfter,
                royaltyRate: royaltyRate
            )

            let listingResourceID = listing.uuid
            let expiration = listing.getDetails().expiresAfter

            // Add the new listing to the dictionary.
            let oldListing <- self.listings[listingResourceID] <- listing
            // Note that oldListing will always be nil, but we have to handle it.
            destroy oldListing

            // Listing fee
            // let listingFee <- payment.withdraw(amount: Flowty.ListingFee)
            // let flowtyFusdReceiver = Flowty.account.borrow<&FUSD.Vault{FungibleToken.Receiver}>(from: Flowty.FusdVaultStoragePath)
            //     ?? panic("Missing or mis-typed FUSD Reveiver")
            // flowtyFusdReceiver.deposit(from: <-listingFee)
            destroy payment

            let enabledAutoRepayment = fusdProviderCapability != nil

            emit ListingAvailable(
                flowtyStorefrontAddress: self.owner?.address!,
                flowtyStorefrontID: self.uuid,
                listingResourceID: listingResourceID,
                nftType: nftType.identifier,
                nftID: nftID,
                amount: amount,
                interestRate: interestRate,
                term: term,
                enabledAutoRepayment: enabledAutoRepayment,
                royaltyRate: royaltyRate,
                expiresAfter: expiration,
                paymentTokenType: paymentVaultType.identifier,
                repaymentAddress: fusdProviderCapability?.address
            )

            return listingResourceID
        }

        // removeListing
        // Remove a Listing that has not yet been funded from the collection and destroy it.
        //
        pub fun removeListing(listingResourceID: UInt64) {
            let listing <- self.listings.remove(key: listingResourceID)
                ?? panic("missing Listing")

            // This will emit a ListingCompleted event.
            destroy listing
        }

        // getListingIDs
        // Returns an array of the Listing resource IDs that are in the collection
        //
        pub fun getListingIDs(): [UInt64] {
            return self.listings.keys
        }

        // borrowListing
        // Returns a read-only view of the Listing for the given listingID if it is contained by this collection.
        //
        pub fun borrowListing(listingResourceID: UInt64): &Listing{ListingPublic}? {
            if self.listings[listingResourceID] != nil {
                return &self.listings[listingResourceID] as! &Listing{ListingPublic}?
            } else {
                return nil
            }
        }

        // cleanup
        // Remove an listing *if* it has been funded and expired.
        // Anyone can call, but at present it only benefits the account owner to do so.
        // Kind purchasers can however call it if they like.
        //
        pub fun cleanup(listingResourceID: UInt64) {
            pre {
                self.listings[listingResourceID] != nil: "could not find listing with given id"
            }

            let listing <- self.listings.remove(key: listingResourceID)!
            assert(listing.getDetails().funded == true, message: "listing is not funded, only admin can remove")
            destroy listing
        }

        pub fun getRoyalties(): {String:Flowty.Royalty} {
            return Flowty.Royalties
        }

        // destructor
        //
        destroy () {
            destroy self.listings

            // Let event consumers know that this storefront will no longer exist
            emit FlowtyStorefrontDestroyed(flowtyStorefrontResourceID: self.uuid)
        }

        // constructor
        //
        init () {
            self.listings <- {}

            // Let event consumers know that this storefront exists
            emit FlowtyStorefrontInitialized(flowtyStorefrontResourceID: self.uuid)
        }
    }

    // createStorefront
    // Make creating a FlowtyStorefront publicly accessible.
    //
    pub fun createStorefront(): @FlowtyStorefront {
        return <-create FlowtyStorefront()
    }

    access(account) fun borrowMarketplace(): &Flowty.FlowtyMarketplace {
        return self.account.borrow<&Flowty.FlowtyMarketplace>(from: Flowty.FlowtyMarketplaceStoragePath)!
    }

    pub fun borrowMarketplacePublic(): &Flowty.FlowtyMarketplace{FlowtyMarketplacePublic} {
        let mp = self.account.getCapability<&Flowty.FlowtyMarketplace{Flowty.FlowtyMarketplacePublic}>(Flowty.FlowtyMarketplacePublicPath).borrow()
            ?? panic("marketplac does not exist")
        return mp
    }

    pub fun getRoyaltySafe(nftTypeIdentifier: String): Royalty? {
        return Flowty.Royalties[nftTypeIdentifier]
    }

    pub fun getRoyalty(nftTypeIdentifier: String): Royalty {
        return Flowty.Royalties[nftTypeIdentifier]!
    }

    pub fun getTokenPaths(): {String:PublicPath} {
        return self.TokenPaths
    }

    pub fun settleFunding(fundingResourceID: UInt64) {
       let marketplace = Flowty.borrowMarketplace()
       let funding = marketplace.borrowFunding(fundingResourceID: fundingResourceID)
       funding!.settleFunding()
    }

    // FlowtyAdmin
    // Allows the adminitrator to set the amount of fees, set the suspended funding period
    //
    pub resource FlowtyAdmin {
        pub fun setFees(listingFixedFee: UFix64, fundingPercentageFee: UFix64) {
            pre {
                // The UFix64 type covers a negative numbers
                fundingPercentageFee <= 1.0: "Funding fee should be a percentage"
            }

            Flowty.ListingFee = listingFixedFee
            Flowty.FundingFee = fundingPercentageFee
        }

        pub fun setSuspendedFundingPeriod(period: UFix64) {
            Flowty.SuspendedFundingPeriod = period
        }

        pub fun setSupportedCollection(collection: String, state: Bool) {
            Flowty.SupportedCollections[collection] = state
            emit CollectionSupportChanged(collectionIdentifier: collection, state: state)
        }

        pub fun setCollectionRoyalty(collection: String, royalty: Royalty) {
            pre {
                royalty.Rate <= 1.0: "Royalty rate must be a percentage"
            }

            Flowty.Royalties[collection] = royalty
            emit RoyaltyAdded(collectionIdentifier: collection, rate: royalty.Rate)
        }

        pub fun registerFungibleTokenPath(vaultType: Type, path: PublicPath) {
            Flowty.TokenPaths[vaultType.identifier] = path
        }
    }

    init () {
        self.FlowtyStorefrontStoragePath = /storage/FlowtyStorefront
        self.FlowtyStorefrontPublicPath = /public/FlowtyStorefront
        self.FlowtyMarketplaceStoragePath = /storage/FlowtyMarketplace
        self.FlowtyMarketplacePublicPath = /public/FlowtyMarketplace
        self.FlowtyAdminStoragePath = /storage/FlowtyAdmin
        self.FusdVaultStoragePath = /storage/fusdVault
        self.FusdReceiverPublicPath = /public/fusdReceiver
        self.FusdBalancePublicPath = /public/fusdBalance

        self.ListingFee = 0.0 // Fixed FUSD
        self.FundingFee = 0.1 // Percentage of the interest, a number between 0 and 1.
        self.SuspendedFundingPeriod = 300.0 // Period in seconds
        self.Royalties = {}
        self.SupportedCollections = {}
        self.TokenPaths = {}

        let marketplace <- create FlowtyMarketplace()

        self.account.save(<-marketplace, to: self.FlowtyMarketplaceStoragePath)
        // create a public capability for the .Marketplace
        self.account.link<&Flowty.FlowtyMarketplace{Flowty.FlowtyMarketplacePublic}>(Flowty.FlowtyMarketplacePublicPath, target: Flowty.FlowtyMarketplaceStoragePath)

        // FlowtyAdmin
        let flowtyAdmin <- create FlowtyAdmin()
        self.account.save(<-flowtyAdmin, to: self.FlowtyAdminStoragePath)

        emit FlowtyInitialized()
    }
}
 "
-------
"
import NonFungibleToken from 0x1d7e57aa55817448

pub contract TenantService: NonFungibleToken {

    // basic data about the tenant
    pub let id: String
    pub let name: String
    pub let description: String
    pub var closed: Bool

    // NFT
    pub var totalSupply: UInt64

    // paths
    access(all) let ADMIN_OBJECT_PATH: StoragePath
    access(all) let PRIVATE_NFT_COLLECTION_PATH: StoragePath
    access(all) let PUBLIC_NFT_COLLECTION_PATH: PublicPath
    access(all) let PUBLIC_NFT_COLLECTION_PATH_CUSTOM: PublicPath

    // archetypes
    access(self) let archetypes: {UInt64: Archetype}
    access(self) let archetypeAdmins: @{UInt64: ArchetypeAdmin}
    access(self) var archetypeSeq: UInt64
    access(self) let artifactsByArchetype: {UInt64: {UInt64: Bool}} // archetypeId -> {artifactId: true}

    // artifacts
    access(self) let artifacts: {UInt64: Artifact}
    access(self) let artifactAdmins: @{UInt64: ArtifactAdmin}
    access(self) var artifactSeq: UInt64
    access(self) var nextNftSerialNumber: {UInt64: UInt64}
    access(self) let setsByArtifact: {UInt64: {UInt64: Bool}} // artifactId -> {setId: true}
    access(self) let faucetsByArtifact: {UInt64: {UInt64: Bool}} // artifactId -> {faucetId: true}

    // sets
    access(self) let sets: {UInt64: Set}
    access(self) let setAdmins: @{UInt64: SetAdmin}
    access(self) var setSeq: UInt64
    access(self) let artifactsBySet: {UInt64: {UInt64: Bool}} // setId -> {artifactId: true}
    access(self) let faucetsBySet: {UInt64: {UInt64: Bool}} // setId -> {faucetId: true}

    // prints
    access(self) let prints: {UInt64: Print}
    access(self) let printAdmins: @{UInt64: PrintAdmin}
    access(self) var printSeq: UInt64

    // faucets
    access(self) let faucets: {UInt64: Faucet}
    access(self) let faucetAdmins: @{UInt64: FaucetAdmin}
    access(self) var faucetSeq: UInt64

    // tenant events
    pub event TenantClosed()

    // NFT events
    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)

    init(
        tenantId: String,
        tenantName: String,
        tenantDescription: String,
        ADMIN_OBJECT_PATH: StoragePath,
        PRIVATE_NFT_COLLECTION_PATH: StoragePath,
        PUBLIC_NFT_COLLECTION_PATH: PublicPath,
        PUBLIC_NFT_COLLECTION_PATH_CUSTOM: PublicPath
    ) {
        self.id = tenantId
        self.name = tenantName
        self.description = tenantDescription
        self.closed = false

        self.archetypes = {}
        self.archetypeAdmins <- {}
        self.archetypeSeq = 1
        self.artifactsByArchetype = {}

        self.artifacts = {}
        self.artifactAdmins <- {}
        self.artifactSeq = 1
        self.nextNftSerialNumber = {}
        self.setsByArtifact = {}
        self.faucetsByArtifact = {}

        self.sets = {}
        self.setAdmins <- {}
        self.setSeq = 1
        self.artifactsBySet = {}
        self.faucetsBySet = {}

        self.prints = {}
        self.printAdmins <- {}
        self.printSeq = 1

        self.faucets = {}
        self.faucetAdmins <- {}
        self.faucetSeq = 1

        self.totalSupply = 0

        self.OBJECT_TYPE_MASK = UInt64.max << 55
        self.SEQUENCE_MASK = (UInt64.max << UInt64(9)) >> UInt64(9)

        self.ADMIN_OBJECT_PATH = ADMIN_OBJECT_PATH
        self.PRIVATE_NFT_COLLECTION_PATH = PRIVATE_NFT_COLLECTION_PATH
        self.PUBLIC_NFT_COLLECTION_PATH = PUBLIC_NFT_COLLECTION_PATH
        self.PUBLIC_NFT_COLLECTION_PATH_CUSTOM = PUBLIC_NFT_COLLECTION_PATH_CUSTOM

        // create a collection for the admin
        self.account.save<@ShardedCollection>(<- TenantService.createEmptyShardedCollection(numBuckets: 32), to: TenantService.PRIVATE_NFT_COLLECTION_PATH)

        // Create a public capability for the Collection
        self.account.link<&{NonFungibleToken.CollectionPublic}>(TenantService.PUBLIC_NFT_COLLECTION_PATH, target: TenantService.PRIVATE_NFT_COLLECTION_PATH)
        self.account.link<&{CollectionPublic}>(TenantService.PUBLIC_NFT_COLLECTION_PATH_CUSTOM, target: TenantService.PRIVATE_NFT_COLLECTION_PATH)

        // put the admin in storage
        self.account.save<@TenantAdmin>(<- create TenantAdmin(), to: TenantService.ADMIN_OBJECT_PATH)

        emit ContractInitialized()
    }

    pub enum ObjectType: UInt8 {
        pub case UNKNOWN

        // An Archetype is a high level organizational unit for a type of NFT. For instance, in the
        // case that the Tenant is a company dealing with professional sports they might have an Archetype
        // for each of the sports that they support, ie: Basketball, Baseball, Football, etc.
        //
        pub case ARCHETYPE

        // An Artifact is the actual object that is minted as an NFT. It contains all of the meta data data
        // and a reference to the Archetype that it belongs to.
        //
        pub case ARTIFACT

        // NFTs can be minted into a Set. A set could be something along the lines of "Greatest Pitchers",
        // "Slam Dunk Artists", or "Running Backs" (continuing with the sports theme from above). NFT do
        // not have to be minted into a set. Also, an NFT could be minted from an Artifact by itself, and
        // in another instance as part of a set - so that the NFT references the same Artifact, but only
        // one of them belongs to the Set.
        //
        pub case SET

        // A Print reserves a block of serial numbers for minting at a later time. It is associated with
        // a single Artifact and when the Print is minted it reserves the next serial number through however
        // many serial numbers are to be reserved. NFTs can then later be minted from the Print and will
        // be given the reserved serial numbers.
        //
        pub case PRINT

        // A Faucet is similar to a Print except that it doesn't reserve a block of serial numbers, it merely
        // mints NFTs from a given Artifact on demand. A Faucet can have a maxMintCount or be unbound and
        // mint infinitely (or however many NFTs are allowed to be minted for the Artifact that it is bound to).
        //
        pub case FAUCET

        // An NFT holds metadata, a reference to it's Artifact (and therefore Archetype), a reference to
        // it's Set (if it belongs to one), a reference to it's Print (if it was minted by one), a reference
        // to it's Faucet (if it was minted by one) and has a unique serial number.
        pub case NFT
    }

    pub let OBJECT_TYPE_MASK: UInt64
    pub let SEQUENCE_MASK: UInt64

    // Generates an ID for the given object type and sequence. We generate IDs this way
    // so that they are unique across the various types of objects supported by this
    // contract.
    //
    pub fun generateId(_ objectType: ObjectType, _ sequence: UInt64): UInt64 {
        if (sequence > 36028797018963967) {
            panic("sequence may only have 55 bits and must be less than 36028797018963967")
        }
        var ret: UInt64 = UInt64(objectType.rawValue)
        ret = ret << UInt64(55)
        ret = ret | ((sequence << UInt64(9)) >> UInt64(9))
        return ret
    }

    // Extracts the ObjectType from an id
    //
    pub fun getObjectType(_ id: UInt64): ObjectType {
        return ObjectType(rawValue: UInt8(id >> UInt64(55)))!
    }

    // Extracts the sequence from an id
    //
    pub fun getSequence(_ id: UInt64): UInt64 {
        return id & TenantService.SEQUENCE_MASK
    }

    // Indicates whether or not the given id is for a given ObjectType.
    //
    pub fun isObjectType(_ id: UInt64, _ objectType: ObjectType): Bool {
        return (TenantService.getObjectType(id) == objectType)
    }

    // Returns the tenant id that was supplied when the contract was created
    //
    pub fun getTenantId(): String {
        return self.id
    }

    // Returns the version of this contract
    //
    pub fun getVersion(): UInt32 {
        return 2
    }

    // TenantAdmin is used for administering the Tenant
    //
    pub resource TenantAdmin {

        // Closes the Tenant, rendering any write access impossible
        //
        pub fun close() {
            if !TenantService.closed {
                TenantService.closed = true
                emit TenantClosed()
            }
        }

        // Creates a new Archetype returning it's id.
        //
        pub fun createArchetype(
            name: String,
            description: String,
            metadata: {String: TenantService.MetadataField}
        ): UInt64 {
            pre {
                TenantService.closed != true: "The Tenant is closed"
            }
            var archetype = Archetype(name: name, description: description, metadata: metadata)
            TenantService.archetypes[archetype.id] = archetype
            TenantService.archetypeAdmins[archetype.id] <-! create ArchetypeAdmin(archetype.id)
            return archetype.id
        }

        // Grants admin access to the given Archetype
        //
        pub fun borrowArchetypeAdmin(_ id: UInt64): &ArchetypeAdmin? {
            pre {
                TenantService.closed != true: "The Tenant is closed"
                TenantService.archetypeAdmins[id] != nil: "Archetype not found"
                TenantService.isObjectType(id, ObjectType.ARCHETYPE): "ObjectType is not an Archetype"
            }
            return &TenantService.archetypeAdmins[id] as &ArchetypeAdmin?
        }

        // Creates a new Artifact returning it's id.
        //
        pub fun createArtifact(
            archetypeId: UInt64,
            name: String,
            description: String,
            maxMintCount: UInt64,
            metadata: {String: TenantService.MetadataField}
        ): UInt64 {
            pre {
                TenantService.closed != true: "The Tenant is closed"
                TenantService.archetypes[archetypeId] != nil: "The Archetype wasn't found"
                self.borrowArchetypeAdmin(archetypeId)?.closed != true: "The Archetype is closed"
            }
            var artifact = Artifact(archetypeId: archetypeId, name: name, description: description, maxMintCount: maxMintCount, metadata: metadata)
            TenantService.artifacts[artifact.id] = artifact
            TenantService.artifactAdmins[artifact.id] <-! create ArtifactAdmin(id: artifact.id)
            TenantService.nextNftSerialNumber[artifact.id] = 1
            return artifact.id
        }

        // Grants admin access to the given Artifact
        //
        pub fun borrowArtifactAdmin(_ id: UInt64): &ArtifactAdmin? {
            pre {
                TenantService.closed != true: "The Tenant is closed"
                TenantService.artifactAdmins[id] != nil: "Artifact not found"
                TenantService.isObjectType(id, ObjectType.ARTIFACT): "ObjectType is not an Artifact"
            }
            return &TenantService.artifactAdmins[id] as &ArtifactAdmin?
        }

        // Creates a new Set returning it's id.
        //
        pub fun createSet(name: String, description: String, metadata: {String: TenantService.MetadataField}): UInt64 {
            pre {
                TenantService.closed != true: "The Tenant is closed"
            }
            var set = Set(name: name, description: description, metadata: metadata)
            TenantService.sets[set.id] = set
            TenantService.setAdmins[set.id] <-! create SetAdmin(set.id)
            return set.id
        }

        // Grants admin access to the given Set
        //
        pub fun borrowSetAdmin(_ id: UInt64): &SetAdmin? {
            pre {
                TenantService.closed != true: "The Tenant is closed"
                TenantService.setAdmins[id] != nil: "Set not found"
                TenantService.isObjectType(id, ObjectType.SET): "ObjectType is not a Set"
            }
            return &TenantService.setAdmins[id] as &SetAdmin?
        }

        // Creates a new Print returning it's id.
        //
        pub fun createPrint(
           artifactId: UInt64,
           setId: UInt64?,
           name: String,
           description: String,
           maxMintCount: UInt64,
           metadata: {String: TenantService.MetadataField}
       ): UInt64 {
            pre {
                TenantService.closed != true: "The Tenant is closed"
                self.borrowArtifactAdmin(artifactId)?.closed != true: "The Artifact is closed"
                setId == nil || self.borrowSetAdmin(setId!)?.closed != true: "The Set is closed"
            }
            var print = Print(artifactId: artifactId, setId: setId, name: name, description: description, maxMintCount: maxMintCount, metadata: metadata)
            TenantService.prints[print.id] = print
            TenantService.printAdmins[print.id] <-! create PrintAdmin(print.id, print.serialNumberStart)
            return print.id
        }

        // Grants admin access to the given Print
        //
        pub fun borrowPrintAdmin(_ id: UInt64): &PrintAdmin? {
            pre {
                TenantService.closed != true: "The Tenant is closed"
                TenantService.printAdmins[id] != nil: "Print not found"
                TenantService.isObjectType(id, ObjectType.PRINT): "ObjectType is not a print"
            }
            return &TenantService.printAdmins[id] as &PrintAdmin?
        }

        // Creates a new Faucet returning it's id.
        //
        pub fun createFaucet(
           artifactId: UInt64,
           setId: UInt64?,
           name: String,
           description: String,
           maxMintCount: UInt64,
           metadata: {String: TenantService.MetadataField}
       ): UInt64 {
            pre {
                TenantService.closed != true: "The Tenant is closed"
                self.borrowArtifactAdmin(artifactId)?.closed != true: "The Artifact is closed"
                setId == nil || self.borrowSetAdmin(setId!)?.closed != true: "The Set is closed"
            }
            var faucet = Faucet(artifactId: artifactId, setId: setId, name: name, description: description, maxMintCount: maxMintCount, metadata: metadata)
            TenantService.faucets[faucet.id] = faucet
            TenantService.faucetAdmins[faucet.id] <-! create FaucetAdmin(id: faucet.id)
            return faucet.id
        }

        // Grants admin access to the given Faucet
        //
        pub fun borrowFaucetAdmin(_ id: UInt64): &FaucetAdmin? {
            pre {
                TenantService.closed != true: "The Tenant is closed"
                TenantService.faucetAdmins[id] != nil: "Faucet not found"
                TenantService.isObjectType(id, ObjectType.FAUCET): "ObjectType is not a faucet"
            }
            return &TenantService.faucetAdmins[id] as &FaucetAdmin?
        }

        // Mints an NFT
        //
        pub fun mintNFT(artifactId: UInt64, printId: UInt64?, faucetId: UInt64?, setId: UInt64?, metadata: {String: TenantService.MetadataField}): @NFT {
            pre {
                TenantService.artifacts[artifactId] != nil: "Cannot mint the NFT: The Artifact wasn't found"
                self.borrowArtifactAdmin(artifactId)?.closed != true: "The Artifact is closed"

                printId == nil || TenantService.isObjectType(printId!, ObjectType.PRINT): "Id supplied for printId is not an ObjectType of print"
                faucetId == nil || TenantService.isObjectType(faucetId!, ObjectType.FAUCET): "Id supplied for faucetId is not an ObjectType of faucet"
                setId == nil || TenantService.isObjectType(setId!, ObjectType.SET): "Id supplied for setId is not an ObjectType of set"

                printId == nil || TenantService.prints[printId!] != nil: "Cannot mint the NFT: The Print wasn't found"
                faucetId == nil || TenantService.faucets[faucetId!] != nil: "Cannot mint the NFT: The Faucet wasn't found"
                setId == nil || TenantService.sets[setId!] != nil: "Cannot mint the NFT: The Set wasn't found"

                printId == nil || self.borrowPrintAdmin(printId!)?.closed != true: "The Print is closed"
                faucetId == nil || self.borrowFaucetAdmin(faucetId!)?.closed != true: "The Faucet is closed"
                setId == nil || self.borrowSetAdmin(setId!)?.closed != true: "The Set is closed"

                faucetId == nil || TenantService.faucets[faucetId!]!.artifactId == artifactId: "The artifactId doesn't match the Faucet's artifactId"
                printId == nil || TenantService.prints[printId!]!.artifactId == artifactId: "The artifactId doesn't match the Print's artifactId"

                faucetId == nil || TenantService.faucets[faucetId!]!.setId == setId: "The setId doesn't match the Faucet's setId"
                printId == nil || TenantService.prints[printId!]!.setId == setId: "The setId doesn't match the Print's setId"

                !(faucetId != nil && printId != nil): "Can only mint from one of a faucet or print"
            }

            let artifact: Artifact = TenantService.artifacts[artifactId]!
            let artifactAdmin = self.borrowArtifactAdmin(artifactId)!
            artifactAdmin.logMint(1)
            if printId != nil {
                artifactAdmin.logPrint(1)
            }

            let archetype: Archetype = TenantService.archetypes[artifact.archetypeId]!
            let archetypeAdmin = self.borrowArchetypeAdmin(artifact.archetypeId)!
            if archetypeAdmin != nil {
                archetypeAdmin.logMint(1)
                if printId != nil {
                    archetypeAdmin.logPrint(1)
                }
            }

            if faucetId != nil {
                let faucetAdmin = self.borrowFaucetAdmin(faucetId!)!
                faucetAdmin.logMint(1)
            }

            if setId != nil {
                let setAdmin = self.borrowSetAdmin(setId!)!
                setAdmin.logMint(1)
                if printId != nil {
                    setAdmin.logPrint(1)
                }
            }

            if printId != nil {
                let printAdmin = self.borrowPrintAdmin(printId!)!
                printAdmin.logMint(1)
            }

            let newNFT: @NFT <- create NFT(
                archetypeId: artifact.archetypeId,
                artifactId: artifact.id,
                printId: printId,
                faucetId: faucetId,
                setId: setId,
                metadata: metadata)

            return <- newNFT
        }

        // Mints many NFTs
        //
        pub fun batchMintNFTs(
            count: UInt64,
            artifactId: UInt64,
            printId: UInt64?,
            faucetId: UInt64?,
            setId: UInt64?,
            metadata: {String: TenantService.MetadataField}
        ): @Collection {
            let newCollection <- create Collection()
            var i: UInt64 = 0
            while i < count {
                newCollection.deposit(token: <-self.mintNFT(
                    artifactId: artifactId,
                    printId: printId,
                    faucetId: faucetId,
                    setId: setId,
                    metadata: metadata
                ))
                i = i + (1 as UInt64)
            }
            return <- newCollection
        }

        // Creates a new TenantAdmin that allows for another account
        // to administer the Tenant
        //
        pub fun createNewTenantAdmin(): @TenantAdmin {
            return <- create TenantAdmin()
        }
    }

    // =====================================
    // Archetype
    // =====================================

    pub event ArchetypeCreated(_ id: UInt64)
    pub event ArchetypeDestroyed(_ id: UInt64)
    pub event ArchetypeClosed(_ id: UInt64)

    pub fun getArchetype(_ id: UInt64): Archetype? {
        pre {
            TenantService.isObjectType(id, ObjectType.ARCHETYPE): "Id supplied is not for an archetype"
        }
        return TenantService.archetypes[id]
    }

    pub fun getArchetypeView(_ id: UInt64): ArchetypeView? {
        pre {
            TenantService.isObjectType(id, ObjectType.ARCHETYPE): "Id supplied is not for an archetype"
        }
        if TenantService.archetypes[id] == nil {
            return nil
        }
        let archetype = TenantService.archetypes[id]!
        let archetypeAdmin = (&TenantService.archetypeAdmins[id] as &ArchetypeAdmin?)!
        return ArchetypeView(
            id: archetype.id,
            name: archetype.name,
            description: archetype.description,
            metadata: archetype.metadata,
            mintCount: archetypeAdmin.mintCount,
            printCount: archetypeAdmin.printCount,
            closed: archetypeAdmin.closed
        )
    }

    pub fun getArchetypeViews(_ archetypes: [UInt64]): [ArchetypeView] {
        let ret: [ArchetypeView] = []
        for archetype in archetypes {
            let element = self.getArchetypeView(archetype)
            if element != nil {
                ret.append(element!)
            }
        }
        return ret
    }

    pub fun getAllArchetypes(): [Archetype] {
        return TenantService.archetypes.values
    }

    // The immutable data for an Archetype
    //
    pub struct Archetype {
        pub let id: UInt64
        pub let name: String
        pub let description: String
        pub let metadata: {String: TenantService.MetadataField}

        init(name: String, description: String, metadata: {String: TenantService.MetadataField}) {
            self.id = TenantService.generateId(ObjectType.ARCHETYPE, TenantService.archetypeSeq)
            self.name = name
            self.description = description
            self.metadata = metadata
            TenantService.archetypeSeq = TenantService.archetypeSeq + 1 as UInt64
            emit ArchetypeCreated(self.id)
        }
    }

    // The mutable data for an Archetype
    //
    pub resource ArchetypeAdmin {

        pub let id: UInt64
        pub var mintCount: UInt64
        pub var printCount: UInt64
        pub var closed: Bool

        init(_ id: UInt64) {
            self.id = id
            self.mintCount = 0
            self.printCount = 0
            self.closed = false
        }

        pub fun close() {
            if !self.closed {
                self.closed = true
                emit ArchetypeClosed(self.id)
            }
        }

        pub fun logMint(_ count: UInt64) {
            pre {
                TenantService.closed != true: "The Tenant is closed"
                self.closed != true: "The Archetype is closed"
            }
            self.mintCount = self.mintCount + count
        }

        pub fun logPrint(_ count: UInt64) {
            pre {
                TenantService.closed != true: "The Tenant is closed"
                self.closed != true: "The Archetype is closed"
            }
            self.printCount = self.printCount + count
        }

        destroy() {
            emit ArchetypeDestroyed(self.id)
        }
    }

    // An immutable view for an Archetype and all of it's data
    //
    pub struct ArchetypeView {
        pub let id: UInt64
        pub let name: String
        pub let description: String
        pub let metadata: {String: TenantService.MetadataField}
        pub let mintCount: UInt64
        pub let printCount: UInt64
        pub let closed: Bool

        init(
            id: UInt64,
            name: String,
            description: String,
            metadata: {String: TenantService.MetadataField},
            mintCount: UInt64,
            printCount: UInt64,
            closed: Bool
        ) {
            self.id = id
            self.name = name
            self.description = description
            self.metadata = metadata
            self.mintCount = mintCount
            self.printCount = printCount
            self.closed = closed
        }
    }

    // =====================================
    // Artifact
    // =====================================

    pub event ArtifactCreated(_ id: UInt64)
    pub event ArtifactMaxMintCountChanged(_ id: UInt64, _ oldMaxMintCount: UInt64, _ newMaxMintCount: UInt64)
    pub event ArtifactDestroyed(_ id: UInt64)
    pub event ArtifactClosed(_ id: UInt64)

    pub fun getArtifact(_ id: UInt64): Artifact? {
        pre {
            TenantService.isObjectType(id, ObjectType.ARTIFACT): "Id supplied is not for an artifact"
        }
        return TenantService.artifacts[id]
    }

    pub fun getArtifactView(_ id: UInt64): ArtifactView? {
        pre {
            TenantService.isObjectType(id, ObjectType.ARTIFACT): "Id supplied is not for an artifact"
        }
        if TenantService.artifacts[id] == nil {
            return nil
        }
        let artifact = TenantService.artifacts[id]!
        let artifactAdmin = (&TenantService.artifactAdmins[id] as &ArtifactAdmin?)!
        return ArtifactView(
            id: artifact.id,
            archetypeId: artifact.archetypeId,
            name: artifact.name,
            description: artifact.description,
            metadata: artifact.metadata,
            maxMintCount: artifact.maxMintCount,
            mintCount: artifactAdmin.mintCount,
            printCount: artifactAdmin.printCount,
            closed: artifactAdmin.closed
        )
    }

    pub fun getArtifactViews(_ artifacts: [UInt64]): [ArtifactView] {
        let ret: [ArtifactView] = []
        for artifact in artifacts {
            let element = self.getArtifactView(artifact)
            if element != nil {
                ret.append(element!)
            }
        }
        return ret
    }

    pub fun getAllArtifacts(): [Artifact] {
        return TenantService.artifacts.values
    }

    pub fun getArtifactsBySet(_ setId: UInt64): [UInt64] {
        let map = TenantService.artifactsBySet[setId]
        if map != nil {
            return map!.keys
        }
        return []
    }

    pub fun getFaucetsBySet(_ setId: UInt64): [UInt64] {
        let map = TenantService.faucetsBySet[setId]
        if map != nil {
            return map!.keys
        }
        return []
    }

    pub fun getSetsByArtifact(_ artifactId: UInt64): [UInt64] {
        let map = TenantService.setsByArtifact[artifactId]
        if map != nil {
            return map!.keys
        }
        return []
    }

    pub fun getFaucetsByArtifact(_ artifactId: UInt64): [UInt64] {
        let map = TenantService.faucetsByArtifact[artifactId]
        if map != nil {
            return map!.keys
        }
        return []
    }

    pub fun getArtifactsByArchetype(_ archetypeId: UInt64): [UInt64] {
        let map = TenantService.artifactsByArchetype[archetypeId]
        if map != nil {
            return map!.keys
        }
        return []
    }

    // The immutable data for an Artifact
    //
    pub struct Artifact {
        pub let id: UInt64
        pub let archetypeId: UInt64
        pub let name: String
        pub let description: String
        pub let maxMintCount: UInt64
        pub let metadata: {String: TenantService.MetadataField}

        init(archetypeId: UInt64, name: String, description: String, maxMintCount: UInt64, metadata: {String: TenantService.MetadataField}) {
            self.id = TenantService.generateId(ObjectType.ARTIFACT, TenantService.artifactSeq)
            self.archetypeId = archetypeId
            self.name = name
            self.description = description
            self.maxMintCount = maxMintCount
            self.metadata = metadata
            TenantService.artifactSeq = TenantService.artifactSeq + 1 as UInt64
            emit ArtifactCreated(self.id)
        }
    }

    // The mutable data for an Artifact
    //
    pub resource ArtifactAdmin {

        pub let id: UInt64
        pub var mintCount: UInt64
        pub var printCount: UInt64
        pub var closed: Bool

        init(id: UInt64) {
            self.id = id
            self.mintCount = 0
            self.printCount = 0
            self.closed = false
        }

        pub fun close() {
            if !self.closed {
                self.closed = true
                emit ArtifactClosed(self.id)
            }
        }

        pub fun logMint(_ count: UInt64) {
            pre {
                TenantService.closed != true: "The Tenant is closed"
                self.closed != true: "The Artifact is closed"
                ((TenantService.artifacts[self.id]!.maxMintCount == (0 as UInt64))
                    || (TenantService.artifacts[self.id]!.maxMintCount >= (self.mintCount + count))): "The Artifact would exceed it's maxMintCount"
            }
            self.mintCount = self.mintCount + count
        }

        pub fun logPrint(_ count: UInt64) {
            pre {
                TenantService.closed != true: "The Tenant is closed"
                self.closed != true: "The Artifact is closed"
            }
            self.printCount = self.printCount + count
        }

        destroy() {
            emit ArtifactDestroyed(self.id)
        }
    }

    // An immutable view for an Artifact and all of it's data
    //
    pub struct ArtifactView {
        pub let id: UInt64
        pub let archetypeId: UInt64
        pub let name: String
        pub let description: String
        pub let metadata: {String: TenantService.MetadataField}
        pub let maxMintCount: UInt64
        pub let mintCount: UInt64
        pub let printCount: UInt64
        pub let closed: Bool

        init(
            id: UInt64,
            archetypeId: UInt64,
            name: String,
            description: String,
            metadata: {String: TenantService.MetadataField},
            maxMintCount: UInt64,
            mintCount: UInt64,
            printCount: UInt64,
            closed: Bool
        ) {
            self.id = id
            self.archetypeId = archetypeId
            self.name = name
            self.description = description
            self.metadata = metadata
            self.maxMintCount = maxMintCount
            self.mintCount = mintCount
            self.printCount = printCount
            self.closed = closed
        }
    }

    // =====================================
    // Set
    // =====================================

    pub event SetCreated(_ id: UInt64)
    pub event SetDestroyed(_ id: UInt64)
    pub event SetClosed(_ id: UInt64)

    pub fun getSet(_ id: UInt64): Set? {
        pre {
            TenantService.isObjectType(id, ObjectType.SET): "Id supplied is not for an set"
        }
        return TenantService.sets[id]
    }

    pub fun getSetView(_ id: UInt64): SetView? {
        pre {
            TenantService.isObjectType(id, ObjectType.SET): "Id supplied is not for an set"
        }
        if TenantService.sets[id] == nil {
            return nil
        }
        let set = TenantService.sets[id]!
        let setAdmin = (&TenantService.setAdmins[id] as &SetAdmin?)!
        return SetView(
            id: set.id,
            name: set.name,
            description: set.description,
            metadata: set.metadata,
            mintCount: setAdmin.mintCount,
            printCount: setAdmin.printCount,
            closed: setAdmin.closed
        )
    }

    pub fun getSetViews(_ sets: [UInt64]): [SetView] {
        let ret: [SetView] = []
        for set in sets {
            let element = self.getSetView(set)
            if element != nil {
                ret.append(element!)
            }
        }
        return ret
    }

    pub fun getAllSets(): [Set] {
        return TenantService.sets.values
    }

    // The immutable data for an Set
    //
    pub struct Set {
        pub let id: UInt64
        pub let name: String
        pub let description: String
        pub let metadata: {String: TenantService.MetadataField}

        init(
            name: String,
            description: String,
            metadata: {String: TenantService.MetadataField}
        ) {
            self.id = TenantService.generateId(ObjectType.SET, TenantService.setSeq)
            self.name = name
            self.description = description
            self.metadata = metadata
            TenantService.setSeq = TenantService.setSeq + 1 as UInt64
            TenantService.faucetsBySet[self.id] = {}
            emit SetCreated(self.id)
        }
    }

    // The mutable data for an Set
    //
    pub resource SetAdmin {
        pub let id: UInt64
        pub var mintCount: UInt64
        pub var printCount: UInt64
        pub var closed: Bool

        init(_ id: UInt64) {
            self.id = id
            self.mintCount = 0
            self.printCount = 0
            self.closed = false
        }

        pub fun close() {
            if !self.closed {
                self.closed = true
                emit SetClosed(self.id)
            }
        }

        pub fun logMint(_ count: UInt64) {
            pre {
                TenantService.closed != true: "The Tenant is closed"
                self.closed != true: "The Set is closed"
            }
            self.mintCount = self.mintCount + count
        }

        pub fun logPrint(_ count: UInt64) {
            pre {
                TenantService.closed != true: "The Tenant is closed"
                self.closed != true: "The Set is closed"
            }
            self.printCount = self.printCount + count
        }

        destroy() {
            emit SetDestroyed(self.id)
        }
    }

    // An immutable view for an Set and all of it's data
    //
    pub struct SetView {
        pub let id: UInt64
        pub let name: String
        pub let description: String
        pub let metadata: {String: TenantService.MetadataField}
        pub let mintCount: UInt64
        pub let printCount: UInt64
        pub let closed: Bool

        init(
            id: UInt64,
            name: String,
            description: String,
            metadata: {String: TenantService.MetadataField},
            mintCount: UInt64,
            printCount: UInt64,
            closed: Bool
        ) {
            self.id = id
            self.name = name
            self.description = description
            self.metadata = metadata
            self.mintCount = mintCount
            self.printCount = printCount
            self.closed = closed
        }
    }

    // =====================================
    // Print
    // =====================================

    pub event PrintCreated(_ id: UInt64)
    pub event PrintDestroyed(_ id: UInt64)
    pub event PrintClosed(_ id: UInt64)

    pub fun getPrint(_ id: UInt64): Print? {
        pre {
            TenantService.isObjectType(id, ObjectType.PRINT): "Id supplied is not for a print"
        }
        return TenantService.prints[id]
    }

    pub fun getPrintView(_ id: UInt64): PrintView? {
        pre {
            TenantService.isObjectType(id, ObjectType.PRINT): "Id supplied is not for a print"
        }
        if TenantService.prints[id] == nil {
            return nil
        }
        let print = TenantService.prints[id]!
        let printAdmin = (&TenantService.printAdmins[id] as &PrintAdmin?)!
        return PrintView(
            id: print.id,
            artifactId: print.artifactId,
            setId: print.setId,
            name: print.name,
            description: print.description,
            maxMintCount: print.maxMintCount,
            metadata: print.metadata,
            serialNumberStart: print.serialNumberStart,
            nextNftSerialNumber: printAdmin.nextNftSerialNumber,
            mintCount: printAdmin.mintCount,
            closed: printAdmin.closed
        )
    }

    pub fun getPrintViews(_ prints: [UInt64]): [PrintView] {
        let ret: [PrintView] = []
        for print in prints {
            let element = self.getPrintView(print)
            if element != nil {
                ret.append(element!)
            }
        }
        return ret
    }

    pub fun getAllPrints(): [Print] {
        return TenantService.prints.values
    }

    // The immutable data for an Print
    //
    pub struct Print {
        pub let id: UInt64
        pub let artifactId: UInt64
        pub let setId: UInt64?
        pub let name: String
        pub let description: String
        pub let maxMintCount: UInt64
        pub let metadata: {String: TenantService.MetadataField}
        pub let serialNumberStart: UInt64

        init(
            artifactId: UInt64,
            setId: UInt64?,
            name: String,
            description: String,
            maxMintCount: UInt64,
            metadata: {String: TenantService.MetadataField}
        ) {
            pre {
                maxMintCount > 0 : "maxMintCount must be greater than 0"
            }
            self.id = TenantService.generateId(ObjectType.PRINT, TenantService.printSeq)
            self.artifactId = artifactId
            self.setId = setId
            self.name = name
            self.description = description
            self.maxMintCount = maxMintCount
            self.metadata = metadata
            self.serialNumberStart = TenantService.nextNftSerialNumber[artifactId]!
            TenantService.nextNftSerialNumber[artifactId] = self.serialNumberStart + maxMintCount
            TenantService.printSeq = TenantService.printSeq + 1 as UInt64
            emit PrintCreated(self.id)
        }
    }

    // The mutable data for an Print
    //
    pub resource PrintAdmin {

        pub let id: UInt64
        pub var nextNftSerialNumber: UInt64
        pub var mintCount: UInt64
        pub var closed: Bool

        init(_ id: UInt64, _ serialNumberStart: UInt64) {
            self.id = id
            self.mintCount = 0
            self.closed = false
            self.nextNftSerialNumber = serialNumberStart
        }

        pub fun close() {
            if !self.closed {
                self.closed = true
                emit PrintClosed(self.id)
            }
        }

        pub fun getAndIncrementSerialNumber(): UInt64 {
            let ret: UInt64 = self.nextNftSerialNumber
            self.nextNftSerialNumber = ret + (1 as UInt64)
            return ret
        }

        pub fun logMint(_ count: UInt64) {
            pre {
                TenantService.closed != true: "The Tenant is closed"
                self.closed != true: "The Print is closed"
                TenantService.prints[self.id]!.maxMintCount >= (self.mintCount + count): "The Print would exceed it's maxMintCount"
            }
            self.mintCount = self.mintCount + count
        }

        destroy() {
            emit PrintDestroyed(self.id)
        }
    }

    // An immutable view for an Print and all of it's data
    //
    pub struct PrintView {
        pub let id: UInt64
        pub let artifactId: UInt64
        pub let setId: UInt64?
        pub let name: String
        pub let description: String
        pub let maxMintCount: UInt64
        pub let metadata: {String: TenantService.MetadataField}
        pub let serialNumberStart: UInt64
        pub let nextNftSerialNumber: UInt64
        pub let mintCount: UInt64
        pub let closed: Bool

        init(
            id: UInt64,
            artifactId: UInt64,
            setId: UInt64?,
            name: String,
            description: String,
            maxMintCount: UInt64,
            metadata: {String: TenantService.MetadataField},
            serialNumberStart: UInt64,
            nextNftSerialNumber: UInt64,
            mintCount: UInt64,
            closed: Bool
        ) {
            self.id = id
            self.artifactId = artifactId
            self.setId = setId
            self.name = name
            self.description = description
            self.maxMintCount = maxMintCount
            self.metadata = metadata
            self.serialNumberStart = serialNumberStart
            self.nextNftSerialNumber = nextNftSerialNumber
            self.mintCount = mintCount
            self.closed = closed
        }
    }

    // =====================================
    // Faucet
    // =====================================

    pub event FaucetCreated(_ id: UInt64)
    pub event FaucetMaxMintCountChanged(_ id: UInt64, _ oldMaxMintCount: UInt64, _ newMaxMintCount: UInt64)
    pub event FaucetDestroyed(_ id: UInt64)
    pub event FaucetClosed(_ id: UInt64)

    pub fun getFaucet(_ id: UInt64): Faucet? {
        pre {
            TenantService.isObjectType(id, ObjectType.FAUCET): "Id supplied is not for a faucet"
        }
        return TenantService.faucets[id]
    }

    pub fun getFaucetView(_ id: UInt64): FaucetView? {
        pre {
            TenantService.isObjectType(id, ObjectType.FAUCET): "Id supplied is not for a faucet"
        }
        if TenantService.faucets[id] == nil {
            return nil
        }
        let faucet = TenantService.faucets[id]!
        let faucetAdmin = (&TenantService.faucetAdmins[id] as &FaucetAdmin?)!
        return FaucetView(
            id: faucet.id,
            artifactId: faucet.artifactId,
            setId: faucet.setId,
            name: faucet.name,
            description: faucet.description,
            maxMintCount: faucet.maxMintCount,
            metadata: faucet.metadata,
            mintCount: faucetAdmin.mintCount,
            closed: faucetAdmin.closed
        )
    }

    pub fun getFaucetViews(_ faucets: [UInt64]): [FaucetView] {
        let ret: [FaucetView] = []
        for faucet in faucets {
            let element = self.getFaucetView(faucet)
            if element != nil {
                ret.append(element!)
            }
        }
        return ret
    }

    pub fun getAllFaucets(): [Faucet] {
        return TenantService.faucets.values
    }

    // The immutable data for an Faucet
    //
    pub struct Faucet {
        pub let id: UInt64
        pub let artifactId: UInt64
        pub let setId: UInt64?
        pub let name: String
        pub let description: String
        pub let maxMintCount: UInt64
        pub let metadata: {String: TenantService.MetadataField}

        init(
            artifactId: UInt64,
            setId: UInt64?,
            name: String,
            description: String,
            maxMintCount: UInt64,
            metadata: {String: TenantService.MetadataField}
        ) {
            self.id = TenantService.generateId(ObjectType.FAUCET, TenantService.faucetSeq)
            self.artifactId = artifactId
            self.setId = setId
            self.name = name
            self.description = description
            self.maxMintCount = maxMintCount
            self.metadata = metadata
            TenantService.faucetSeq = TenantService.faucetSeq + 1 as UInt64

            if self.setId != nil {
                let faucetsBySet = TenantService.faucetsBySet[self.setId!]!
                faucetsBySet[self.id] = true
            }

            emit FaucetCreated(self.id)
        }
    }

    // The mutable data for an Faucet
    //
    pub resource FaucetAdmin {

        pub let id: UInt64
        pub var mintCount: UInt64
        pub var closed: Bool

        init(id: UInt64) {
            self.id = id
            self.mintCount = 0
            self.closed = false
        }

        pub fun close() {
            if !self.closed {
                self.closed = true
                emit FaucetClosed(self.id)
            }
        }

        pub fun logMint(_ count: UInt64) {
            pre {
                TenantService.closed != true: "The Tenant is closed"
                self.closed != true: "The Faucet is closed"
                ((TenantService.faucets[self.id]!.maxMintCount == (0 as UInt64))
                    || (TenantService.faucets[self.id]!.maxMintCount >= (self.mintCount + count))): "The Faucet would exceed it's maxMintCount"
            }
            self.mintCount = self.mintCount + count
        }

        destroy() {
            emit FaucetDestroyed(self.id)
        }
    }

    // An immutable view for an Faucet and all of it's data
    //
    pub struct FaucetView {
        pub let id: UInt64
        pub let artifactId: UInt64
        pub let setId: UInt64?
        pub let name: String
        pub let description: String
        pub let maxMintCount: UInt64
        pub let metadata: {String: TenantService.MetadataField}
        pub let mintCount: UInt64
        pub let closed: Bool

        init(
            id: UInt64,
            artifactId: UInt64,
            setId: UInt64?,
            name: String,
            description: String,
            maxMintCount: UInt64,
            metadata: {String: TenantService.MetadataField},
            mintCount: UInt64,
            closed: Bool
        ) {
            self.id = id
            self.artifactId = artifactId
            self.setId = setId
            self.name = name
            self.description = description
            self.maxMintCount = maxMintCount
            self.metadata = metadata
            self.mintCount = mintCount
            self.closed = closed
        }
    }

    // =====================================
    // NFT
    // =====================================

    pub event NFTCreated(_ id: UInt64)
    pub event NFTDestroyed(_ id: UInt64)

    pub fun getNFTView(_ nft: &NFT): NFTView {
        let archetype = self.getArchetypeView(nft.archetypeId)!
        let artifact = self.getArtifactView(nft.artifactId)!

        var set: SetView? = nil
        if nft.setId != nil {
            set = self.getSetView(nft.setId!)!
        }

        var print: PrintView? = nil
        if nft.printId != nil {
            print = self.getPrintView(nft.printId!)!
        }

        var faucet: FaucetView? = nil
        if nft.faucetId != nil {
            faucet = self.getFaucetView(nft.faucetId!)!
        }

        return NFTView(
            id: nft.id,
            archetype: archetype,
            artifact: artifact,
            print: print,
            faucet: faucet,
            set: set,
            serialNumber: nft.serialNumber,
            metadata: nft.getMetadata()
        )
    }

    pub fun getNFTViews(_ nfts: [&NFT]): [NFTView] {
        let ret: [NFTView] = []
        for nft in nfts {
            ret.append(self.getNFTView(nft))
        }
        return ret
    }

    // The immutable data for an NFT, this is the actual NFT
    //
    pub resource NFT: NonFungibleToken.INFT {
        pub let id: UInt64
        pub let archetypeId: UInt64
        pub let artifactId: UInt64
        pub let printId: UInt64?
        pub let faucetId: UInt64?
        pub let setId: UInt64?
        pub let serialNumber: UInt64
        access(self) let metadata: {String: TenantService.MetadataField}

        init(
            archetypeId: UInt64,
            artifactId: UInt64,
            printId: UInt64?,
            faucetId: UInt64?,
            setId: UInt64?,
            metadata: {String: TenantService.MetadataField}
        ) {
            self.id = TenantService.generateId(ObjectType.NFT, TenantService.totalSupply)
            self.archetypeId = archetypeId
            self.artifactId = artifactId
            self.printId = printId
            self.faucetId = faucetId
            self.setId = setId
            self.metadata = metadata

            if self.printId != nil {
                let printAdmin = (&TenantService.printAdmins[self.printId!!] as &PrintAdmin?)!
                self.serialNumber = printAdmin.getAndIncrementSerialNumber()

            } else {
                self.serialNumber = TenantService.nextNftSerialNumber[self.artifactId]!
                TenantService.nextNftSerialNumber[self.artifactId] = self.serialNumber + (1 as UInt64)

            }

            TenantService.totalSupply = TenantService.totalSupply + (1 as UInt64)

            if self.setId != nil {
                if TenantService.setsByArtifact[self.artifactId] == nil {
                    TenantService.setsByArtifact[self.artifactId] = {}
                }
                let setsByArtifact = TenantService.setsByArtifact[self.artifactId]!
                setsByArtifact[self.setId!] = true

                if TenantService.artifactsBySet[self.setId!] == nil {
                    TenantService.artifactsBySet[self.setId!] = {}
                }
                let artifactsBySet = TenantService.artifactsBySet[self.setId!]!
                artifactsBySet[self.artifactId] = true
            }

            if self.faucetId != nil {
                if TenantService.faucetsByArtifact[self.artifactId] == nil {
                    TenantService.faucetsByArtifact[self.artifactId] = {}
                }
                let faucetsByArtifact = TenantService.faucetsByArtifact[self.artifactId]!
                faucetsByArtifact[self.faucetId!] = true
            }

            if TenantService.artifactsByArchetype[self.archetypeId] == nil {
                TenantService.artifactsByArchetype[self.archetypeId] = {}
            }
            let artifactsByArchetype = TenantService.artifactsByArchetype[self.archetypeId]!
            artifactsByArchetype[self.artifactId] = true

            emit NFTCreated(self.id)
        }

        pub fun getMetadata(): {String: TenantService.MetadataField} {
            return self.metadata
        }

        destroy() {
            emit NFTDestroyed(self.id)
        }
    }

    // An immutable view for an NFT and all of it's data
    //
    pub struct NFTView {
        pub let id: UInt64
        pub let archetype: ArchetypeView
        pub let artifact: ArtifactView
        pub let print: PrintView?
        pub let faucet: FaucetView?
        pub let set: SetView?
        pub let serialNumber: UInt64
        pub let metadata: {String: TenantService.MetadataField}

        init(
            id: UInt64,
            archetype: ArchetypeView,
            artifact: ArtifactView,
            print: PrintView?,
            faucet: FaucetView?,
            set: SetView?,
            serialNumber: UInt64,
            metadata: {String: TenantService.MetadataField}
        ) {
            self.id = id
            self.archetype = archetype
            self.artifact = artifact
            self.print = print
            self.faucet = faucet
            self.set = set
            self.serialNumber = serialNumber
            self.metadata = metadata
        }
    }

    // The public version of the collection that accounts can use
    // to deposit NFTs into other accounts
    //
    pub resource interface CollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowNFTData(id: UInt64): &TenantService.NFT?
        pub fun borrowNFTDatas(ids: [UInt64]): [&TenantService.NFT]
    }

    // The collection where NFTs are stored
    //
    pub resource Collection: CollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic {
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init() {
            self.ownedNFTs <- {}
        }

        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID)
                ?? panic("Cannot withdraw: NFT does not exist in the collection")
            emit Withdraw(id: token.id, from: self.owner?.address)
            return <-token
        }

        pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {
            var batchCollection <- create Collection()
            for id in ids {
                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))
            }
            return <-batchCollection
        }

        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @TenantService.NFT
            let id = token.id
            let oldToken <- self.ownedNFTs[id] <- token
            if self.owner?.address != nil {
                emit Deposit(id: id, to: self.owner?.address)
            }
            destroy oldToken
        }

        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {
            let keys = tokens.getIDs()
            for key in keys {
                self.deposit(token: <-tokens.withdraw(withdrawID: key))
            }
            destroy tokens
        }

        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            pre {
                TenantService.isObjectType(id, ObjectType.NFT): "Id supplied is not for an nft"
            }
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowNFTData(id: UInt64): &TenantService.NFT? {
            pre {
                TenantService.isObjectType(id, ObjectType.NFT): "Id supplied is not for an nft"
            }
            if self.ownedNFTs[id] != nil {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &TenantService.NFT
            } else {
                return nil
            }
        }

        pub fun borrowNFTDatas(ids: [UInt64]): [&TenantService.NFT] {
            let nfts: [&TenantService.NFT] = []
            for id in ids {
                let nft = self.borrowNFTData(id: id)
                if nft != nil {
                    nfts.append(nft!)
                }
            }
            return nfts
        }

        pub fun getNFTView(id: UInt64): NFTView? {
            pre {
                TenantService.isObjectType(id, ObjectType.NFT): "Id supplied is not for an nft"
            }
            let nft = self.borrowNFTData(id: id)
            if nft == nil {
                return nil
            }
            return TenantService.getNFTView(nft!)
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <-create TenantService.Collection()
    }

    // ShardedCollection stores a dictionary of TenantService Collections
    // An NFT is stored in the field that corresponds to its id % numBuckets
    //
    pub resource ShardedCollection: CollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic {

        pub var collections: @{UInt64: Collection}
        pub let numBuckets: UInt64

        init(numBuckets: UInt64) {
            self.collections <- {}
            self.numBuckets = numBuckets
            var i: UInt64 = 0
            while i < numBuckets {
                self.collections[i] <-! TenantService.createEmptyCollection() as! @Collection
                i = i + UInt64(1)
            }
        }

        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            post {
                result.id == withdrawID: "The ID of the withdrawn NFT is incorrect"
            }
            let bucket = withdrawID % self.numBuckets
            let token <- self.collections[bucket]?.withdraw(withdrawID: withdrawID)!
            return <-token
        }

        pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {
            var batchCollection <- TenantService.createEmptyCollection()
            for id in ids {
                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))
            }
            return <-batchCollection
        }

        pub fun deposit(token: @NonFungibleToken.NFT) {
            let bucket = token.id % self.numBuckets
            let collection <- self.collections.remove(key: bucket)!
            collection.deposit(token: <-token)
            self.collections[bucket] <-! collection
        }

        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {
            let keys = tokens.getIDs()
            for key in keys {
                self.deposit(token: <-tokens.withdraw(withdrawID: key))
            }
            destroy tokens
        }

        pub fun getIDs(): [UInt64] {
            var ids: [UInt64] = []
            for key in self.collections.keys {
                for id in self.collections[key]?.getIDs() ?? [] {
                    ids.append(id)
                }
            }
            return ids
        }

        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            let bucket = id % self.numBuckets
            return self.collections[bucket]?.borrowNFT(id: id)!
        }

        pub fun borrowNFTData(id: UInt64): &TenantService.NFT? {
            let bucket = id % self.numBuckets
            return self.collections[bucket]?.borrowNFTData(id: id) ?? nil
        }

        pub fun borrowNFTDatas(ids: [UInt64]): [&TenantService.NFT] {
            let nfts: [&TenantService.NFT] = []
            for id in ids {
                let nft = self.borrowNFTData(id: id)
                if nft != nil {
                    nfts.append(nft!)
                }
            }
            return nfts
        }

        pub fun getNFTView(id: UInt64): NFTView? {
            let bucket = id % self.numBuckets
            return self.collections[bucket]?.getNFTView(id: id) ?? nil
        }

        destroy() {
            destroy self.collections
        }
    }

    pub fun createEmptyShardedCollection(numBuckets: UInt64): @ShardedCollection {
        return <-create ShardedCollection(numBuckets: numBuckets)
    }

    // =====================================
    // Metadata
    // =====================================

    // The type of a meta data field
    //
    pub enum MetadataFieldType: UInt8 {
        pub case STRING
        pub case MIME
        pub case NUMBER
        pub case BOOLEAN
        pub case DATE
        pub case DATE_TIME
        pub case URL
        pub case URL_WITH_HASH
        pub case GEO_POINT
    }

    // a meta data field of variable type
    //
    pub struct MetadataField {
        pub let type: MetadataFieldType
        pub let value: AnyStruct

        init(_ type: MetadataFieldType, _ value: AnyStruct) {
            self.type = type
            self.value = value
        }

        pub fun getMimeValue(): Mime? {
            if self.type != MetadataFieldType.MIME {
                return nil
            }
            return self.value as? Mime
        }

        pub fun getStringValue(): String? {
            if self.type != MetadataFieldType.STRING {
                return nil
            }
            return self.value as? String
        }

        pub fun getNumberValue(): String? {
            if self.type != MetadataFieldType.NUMBER {
                return nil
            }
            return self.value as? String
        }

        pub fun getBooleanValue(): Bool? {
            if self.type != MetadataFieldType.BOOLEAN {
                return nil
            }
            return self.value as? Bool
        }

        pub fun getURLValue(): String? {
            if self.type != MetadataFieldType.URL {
                return nil
            }
            return self.value as? String
        }

        pub fun getDateValue(): String? {
            if self.type != MetadataFieldType.DATE {
                return nil
            }
            return self.value as? String
        }

        pub fun getDateTimeValue(): String? {
            if self.type != MetadataFieldType.DATE_TIME {
                return nil
            }
            return self.value as? String
        }

        pub fun getURLWithHashValue(): URLWithHash? {
            if self.type != MetadataFieldType.URL_WITH_HASH {
                return nil
            }
            return self.value as? URLWithHash
        }

        pub fun getGeoPointValue(): GeoPoint? {
            if self.type != MetadataFieldType.GEO_POINT {
                return nil
            }
            return self.value as? GeoPoint
        }
    }

    // A url with a hash of the contents found at the url
    //
    pub struct URLWithHash {
        pub let url: String
        pub let hash: String?
        pub let hashAlgo: String?
        init(_ url: String, _ hash: String, _ hashAlgo: String?) {
            self.url = url
            self.hash = hash
            self.hashAlgo = hashAlgo
        }
    }

    // A geo point without any specific projection
    //
    pub struct GeoPoint {
        pub let lat: UFix64
        pub let lng: UFix64
        init(_ lat: UFix64, _ lng: UFix64) {
            self.lat = lat
            self.lng = lng
        }
    }

    // A piece of Mime content
    //
    pub struct Mime {
        pub let type: String
        pub let bytes: [UInt8]
        init(_ type: String, _ bytes: [UInt8]) {
            self.type = type
            self.bytes = bytes
        }
    }
}
"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import REVV from 0xd01e482eb680ec9f

/// BattlesV2
///
/// A REVV-bound contract for FEHV Battle Mode
///
pub contract BattlesV2 {

    /// TournamentCreated
    /// A tournament struct has been created for a racing event.
    ///
    pub event TournamentCreated(tournamentId: String, amount: UFix64)

    /// LobbyEnded
    /// A lobby has ended with refunds or rewards.
    ///
    pub event LobbyEnded(tournamentId: String, lobbyId: String, isSuccessful: Bool)

    /// UnpaidPlayer
    /// An entitled player has not been paid.
    ///
    pub event UnpaidPlayer(tournamentId: String, player: Address, amount: UFix64)

    /// TransferCompleted
    /// A player paid the participation fee for a tournament.
    ///
    pub event TransferCompleted(
        tournamentId: String,
        from: Address,
        amount: UFix64,
        paymentId: String
    )

    /// Player
    /// A struct representing a player's payment with its current state.
    ///
    pub struct Player {
        pub let paymentId: String
        pub var isFinished: Bool
        pub var prizeAmount: UFix64?
        pub var lobbyId: String?

        init(paymentId: String) {
            self.paymentId = paymentId
            self.isFinished = false
            self.prizeAmount = nil
            self.lobbyId = nil
        }

        access(contract) fun finish(lobbyId: String, prizeAmount: UFix64) {
            pre {
                !self.isFinished
                self.prizeAmount == nil
                self.lobbyId == nil
            }
            self.isFinished = true
            self.prizeAmount = prizeAmount
            self.lobbyId = lobbyId
        }
    }

    /// Tournament
    /// A struct representing a Race Event containing multiple virtual lobbies.
    ///
    pub struct Tournament {
        access(contract) let amount: UFix64
        access(contract) let players: {Address: Player}
        access(contract) var finishedPlayers: Int

        init(amount: UFix64) {
            self.amount = amount
            self.players = {}
            self.finishedPlayers = 0
        }

        access(contract) fun addPlayer(from: Address, paymentId: String) {
            self.players.insert(key: from, Player(paymentId: paymentId))
        }

        access(contract) fun incrementFinishedPlayers() {
            self.finishedPlayers = self.finishedPlayers + 1
        }
    }

    /// TournamentView
    /// A struct representing the external readable state of a Race Event.
    ///
    pub struct TournamentView {
        pub let amount: UFix64
        pub let totalPlayers: Int
        pub let finishedPlayers: Int
        pub let rewardDistribution: [UFix64]
        pub let publicKey: String

        init(
            amount: UFix64,
            totalPlayers: Int,
            finishedPlayers: Int,
            rewardDistribution: [UFix64],
            publicKey: String
        ) {
            self.amount = amount
            self.totalPlayers = totalPlayers
            self.finishedPlayers = finishedPlayers
            self.rewardDistribution = rewardDistribution
            self.publicKey = publicKey
        }
    }

    /// AdminStoragePath
    /// The storage location for the Admin resource.
    pub let AdminStoragePath: StoragePath

    /// publicKey
    /// The public key for decrypting game signatures.
    pub var publicKey: String

    /// tournaments
    /// The dictionary storage that stores all the Tournaments.
    priv let tournaments: {String: Tournament}

    /// rewards
    /// The percentages for each reward category.
    priv var rewards: [UFix64]

    /// revvVault
    /// The REVV contract vault used to safeguard payments.
    priv let revvVault: @REVV.Vault

    /// feeReceiver
    /// The REVV fee account capability.
    priv var feeReceiver: Capability<&REVV.Vault{FungibleToken.Receiver}>?

    /// isValidSignature
    /// Internal function used to check if a message matches its signature.
    ///
    priv fun isValidSignature(message: String, signature: String): Bool {
        let key = PublicKey(
            publicKey: self.publicKey.decodeHex(),
            signatureAlgorithm: SignatureAlgorithm.ECDSA_P256
        )
        return key.verify(
            signature: signature.decodeHex(),
            signedData: message.utf8,
            domainSeparationTag: "",
            hashAlgorithm: HashAlgorithm.SHA3_256
        )
    }

    /// getRevvReceiver
    /// Internal function to get the REVV receiver of an account address.
    ///
    priv fun getRevvReceiver(addr: Address): &{FungibleToken.Receiver}? {
        let recipient = getAccount(addr)
        let receiverCap = recipient.getCapability(REVV.RevvReceiverPublicPath)
        return receiverCap.borrow<&{FungibleToken.Receiver}>()
    }

    /// finishPlayer
    /// Internal function to set the player's payment as processed.
    ///
    priv fun finishPlayer(tournamentId: String, player: Address, lobbyId: String, amount: UFix64) {
        pre {
            self.tournaments.containsKey(tournamentId): "invalid tournament id"
            self.tournaments[tournamentId]!.players.containsKey(player): "player not in tournament"
            !self.tournaments[tournamentId]!.players[player]!.isFinished: "player already processed"
        }
        self.tournaments[tournamentId]!.players[player]!.finish(
            lobbyId: lobbyId,
            prizeAmount: amount
        )
        self.tournaments[tournamentId]!.incrementFinishedPlayers()
    }

    /// getPlayerPayment
    /// Retrieves the payment state of a player.
    ///
    pub fun getPlayerPayment(tournamentId: String, from: Address): Player? {
        if !self.tournaments.containsKey(tournamentId) {
            return nil
        }
        return self.tournaments[tournamentId]!.players[from]
    }

    /// getTournamentView
    /// Retrieves the battle details of a race slot.
    ///
    pub fun getTournamentView(tournamentId: String): TournamentView? {
        if !self.tournaments.containsKey(tournamentId) {
            return nil
        }
        let tournament = self.tournaments[tournamentId]!
        return TournamentView(
            amount: tournament.amount,
            totalPlayers: tournament.players.length,
            finishedPlayers: tournament.finishedPlayers,
            rewardDistribution: self.rewards,
            publicKey: self.publicKey
        )
    }

    /// joinTournament
    /// Allows anyone with a valid signature to join a Race Event.
    ///
    pub fun joinTournament(
        tournamentId: String,
        amount: UFix64,
        from: Address,
        paymentId: String,
        sigValidUntil: UFix64,
        signature: String,
        payment: @REVV.Vault,
    ) {
        pre {
            self.feeReceiver != nil: "fee receiver not set"
            self.publicKey.length > 0: "public key not set"
            self.rewards.length > 0: "rewards array not set"
            amount == payment.balance: "invalid amount"
            getCurrentBlock().timestamp < sigValidUntil: "expired signature"
        }

        let message = tournamentId
            .concat(amount.toString())
            .concat(from.toString())
            .concat(paymentId)
            .concat(sigValidUntil.toString())

        let isValid = self.isValidSignature(message: message, signature: signature)
        assert(isValid, message: "invalid signature")

        if !self.tournaments.containsKey(tournamentId) {
            self.tournaments.insert(key: tournamentId, Tournament(amount: amount))
            emit TournamentCreated(tournamentId: tournamentId, amount: amount)
        } else {
            assert(amount == self.tournaments[tournamentId]!.amount, message: "unequal amount")
            assert(
                !self.tournaments[tournamentId]!.players.containsKey(from),
                message: "entry fee already paid"
            )
        }

        self.revvVault.deposit(from: <-payment)
        self.tournaments[tournamentId]!.addPlayer(from: from, paymentId: paymentId)

        emit TransferCompleted(
            tournamentId: tournamentId,
            from: from,
            amount: amount,
            paymentId: paymentId
        )
    }

    /// refundLobby
    /// Allows anyone with a valid signature to refund a lobby.
    ///
    pub fun refundLobby(tournamentId: String, lobbyId: String, players: [Address], signature: String) {
        pre {
            self.publicKey.length > 0: "public key not set"
            self.tournaments.containsKey(tournamentId): "invalid tournament id"
            players.length > 0: "empty player list"
        }

        var message = "refund-lobby".concat(tournamentId).concat(lobbyId)
        for address in players {
            message = message.concat(address.toString())
        }
        let isValid = self.isValidSignature(message: message, signature: signature)
        assert(isValid, message: "invalid signature")

        let amount = self.tournaments[tournamentId]!.amount
        for address in players {
            self.finishPlayer(
                tournamentId: tournamentId,
                player: address,
                lobbyId: lobbyId,
                amount: amount
            )
            let receiverRef = self.getRevvReceiver(addr: address)
            if receiverRef == nil {
                emit UnpaidPlayer(tournamentId: tournamentId, player: address, amount: amount)
                continue
            }
            let revv <- self.revvVault.withdraw(amount: amount)
            receiverRef!.deposit(from: <-revv)
        }

        emit LobbyEnded(tournamentId: tournamentId, lobbyId: lobbyId, isSuccessful: false)
    }

    /// rewardLobby
    /// Allows anyone with a valid result to reward a lobby.
    ///
    pub fun rewardLobby(tournamentId: String, lobbyId: String, players: [Address], signature: String) {
        pre {
            self.feeReceiver != nil: "fee receiver not set"
            self.publicKey.length > 0: "public key not set"
            self.rewards.length > 0: "rewards array not set"
            self.tournaments.containsKey(tournamentId): "invalid tournament id"
            players.length >= self.rewards.length: "invalid lobby size"
        }

        var message = "reward-lobby".concat(tournamentId).concat(lobbyId)
        for address in players {
            message = message.concat(address.toString())
        }
        let isValid = self.isValidSignature(message: message, signature: signature)
        assert(isValid, message: "invalid signature")

        let totalLobbyPrize = self.tournaments[tournamentId]!.amount * UFix64(players.length)
        var prizeLeft = totalLobbyPrize
        var count = 0

        while count < self.rewards.length {
            let amount = totalLobbyPrize * self.rewards[count]
            self.finishPlayer(
                tournamentId: tournamentId,
                player: players[count],
                lobbyId: lobbyId,
                amount: amount
            )
            let receiverRef = self.getRevvReceiver(addr: players[count])
            if receiverRef == nil {
                emit UnpaidPlayer(tournamentId: tournamentId, player: players[count], amount: amount)
                count = count + 1
                continue
            }
            let revv <- self.revvVault.withdraw(amount: amount)
            receiverRef!.deposit(from: <-revv)
            prizeLeft = prizeLeft - amount
            count = count + 1
        }

        if prizeLeft > 0.0 {
            let receiver = self.feeReceiver!.borrow()
                ?? panic("cannot borrow fee receiver")
            let revv <- self.revvVault.withdraw(amount: prizeLeft)
            receiver.deposit(from: <-revv)
        }

        while count < players.length {
            self.finishPlayer(
                tournamentId: tournamentId,
                player: players[count],
                lobbyId: lobbyId,
                amount: 0.0
            )
            count = count + 1
        }

        emit LobbyEnded(tournamentId: tournamentId, lobbyId: lobbyId, isSuccessful: true)
    }

    /// Admin
    /// A token resource that allows its holder to change the settings.
    pub resource Admin {}

    /// setFeeReceiver
    /// Allows the admin token holder to set the fee receiver.
    ///
    pub fun setFeeReceiver(admin: &Admin, feeReceiver: Capability<&REVV.Vault{FungibleToken.Receiver}>) {
        pre {
            admin != nil: "invalid admin token"
            feeReceiver.borrow() != nil: "invalid receiver"
        }
        self.feeReceiver = feeReceiver
    }

    /// setPublicKey
    /// Allows the admin token holder to set the public key.
    ///
    pub fun setPublicKey(admin: &Admin, publicKey: String) {
        pre {
            admin != nil: "invalid admin token"
        }
        self.publicKey = publicKey
    }

    /// setRewards
    /// Allows the admin token holder to set the reward percentages.
    ///
    pub fun setRewards(admin: &Admin, rewards: [UFix64]) {
        pre {
            admin != nil: "invalid admin token"
        }
        var totalCuts = 0.0
        for r in rewards {
            totalCuts = totalCuts + r
        }
        assert(totalCuts <= 1.0, message: "unexpected reward distribution")
        self.rewards = rewards
    }

    init () {
        self.AdminStoragePath = /storage/AdminFEHVBattlesV2
        let admin <- create Admin()
        self.account.save(<-admin, to: self.AdminStoragePath)
        self.feeReceiver = nil
        self.tournaments = {}
        self.rewards = []
        self.publicKey = ""
        self.revvVault <- REVV.createEmptyVault() as! @REVV.Vault;
    }
}
"
-------
"import MetadataViews from 0x1d7e57aa55817448
import NonFungibleToken from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import FlowToken from 0x1654653399040a61
import ViewResolver from 0x1d7e57aa55817448

pub contract Piece: NonFungibleToken, ViewResolver {

	// Collection Information
	access(self) let collectionInfo: {String: AnyStruct}

	// Contract Information
	pub var totalSupply: UInt64

    // Events
    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
	pub event Deposit(id: UInt64, to: Address?)
	pub event Minted(id: UInt64, recipient: Address, creatorID: UInt64)
	pub event MetadataSuccess(creatorID: UInt64, textContent: String)
	pub event MetadataError(error: String)

	// Paths
	pub let CollectionStoragePath: StoragePath
	pub let CollectionPublicPath: PublicPath
	pub let CollectionPrivatePath: PrivatePath
	pub let AdministratorStoragePath: StoragePath

	// Maps metadataId of NFT to NFTMetadata
	pub let creatorIDs: {UInt64: [NFTMetadata]}

	// You can get a list of purchased NFTs
	// by doing `buyersList.keys`
	access(account) let buyersList: {Address: {UInt64: [UInt64]}}

	access(account) let nftStorage: @{Address: {UInt64: NFT}}

	pub struct NFTMetadata {
		pub let creatorID: UInt64
		pub let creatorAddress: Address
		pub let description: String
		pub let image: MetadataViews.HTTPFile
		pub let purchasers: {UInt64: Address}
		pub let metadataId: UInt64
		pub var minted: UInt64
		pub var extra: {String: AnyStruct}
		pub var timer: UInt64
		pub let creationTime: UFix64
		pub let embededHTML: String

		access(account) fun purchased(serial: UInt64, buyer: Address) {
			self.purchasers[serial] = buyer
		}

		access(account) fun updateMinted() {
			self.minted = self.minted + 1
		}

		init(
			_creatorID: UInt64,
			_creatorAddress: Address,
			_description: String,
			_image: MetadataViews.HTTPFile,
			_extra: {String: AnyStruct},
			_currentTime: UFix64,
			_embededHTML: String,
			) {

			self.metadataId = _creatorID
			self.creatorID = _creatorID
			self.creatorAddress = _creatorAddress
			self.description = _description
			self.image = _image
			self.extra = _extra
			self.minted = 0
			self.purchasers = {}
			self.timer = 0
			self.creationTime = _currentTime
			self.embededHTML = _embededHTML
		}
	}

	pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
		pub let id: UInt64
		// The 'metadataId' is what maps this NFT to its 'NFTMetadata'
		pub let creatorID: UInt64
		pub let serial: UInt64
		pub let indexNumber: Int
		pub let originalMinter: Address

		pub fun getMetadata(): NFTMetadata {
			return Piece.getNFTMetadata(self.creatorID, self.indexNumber )!
		}

		pub fun getViews(): [Type] {
			return [
				Type<MetadataViews.Display>(),
				Type<MetadataViews.ExternalURL>(),
				Type<MetadataViews.NFTCollectionData>(),
				Type<MetadataViews.NFTCollectionDisplay>(),
				Type<MetadataViews.Royalties>(),
				Type<MetadataViews.Serial>(),
				Type<MetadataViews.NFTView>()
			]
		}

		pub fun resolveView(_ view: Type): AnyStruct? {
			let metadata = self.getMetadata()
			switch view {
				case Type<MetadataViews.Display>():
					return MetadataViews.Display(
						creatorID: metadata.creatorID.toString(),
						description: metadata.description,
						thumbnail: metadata.image
					)
				case Type<MetadataViews.Traits>():
					return MetadataViews.dictToTraits(dict: self.getMetadata().extra, excludedNames: nil)

				case Type<MetadataViews.NFTView>():
					return MetadataViews.NFTView(
						id: self.id,
						uuid: self.uuid,
						display: self.resolveView(Type<MetadataViews.Display>()) as! MetadataViews.Display?,
						externalURL: self.resolveView(Type<MetadataViews.ExternalURL>()) as! MetadataViews.ExternalURL?,
						collectionData: self.resolveView(Type<MetadataViews.NFTCollectionData>()) as! MetadataViews.NFTCollectionData?,
						collectionDisplay: self.resolveView(Type<MetadataViews.NFTCollectionDisplay>()) as! MetadataViews.NFTCollectionDisplay?,
						royalties: self.resolveView(Type<MetadataViews.Royalties>()) as! MetadataViews.Royalties?,
						traits: self.resolveView(Type<MetadataViews.Traits>()) as! MetadataViews.Traits?
					)
				case Type<MetadataViews.NFTCollectionData>():
					return Piece.resolveView(view)
        		case Type<MetadataViews.ExternalURL>():
        			return Piece.getCollectionAttribute(key: "website") as! MetadataViews.ExternalURL
		        case Type<MetadataViews.NFTCollectionDisplay>():
					return Piece.resolveView(view)
				case Type<MetadataViews.Medias>():
					if metadata.embededHTML != nil {
						return MetadataViews.Medias(
							items: [
								MetadataViews.Media(
									file: MetadataViews.HTTPFile(
										url: metadata.embededHTML!
									),
									mediaType: "html"
								)
							]
						)
					}
        		case Type<MetadataViews.Royalties>():
          			return MetadataViews.Royalties([
            			MetadataViews.Royalty(
              				recepient: getAccount(metadata.creatorAddress).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver),
              				cut: 0.10, // 10% royalty on secondary sales
              				description: "The creator of the original content get's 10% of every secondary sale."
            			)
          			])
				case Type<MetadataViews.Serial>():
					return MetadataViews.Serial(
						self.serial
					)

			}
			return nil
		}

		init(_creatorID: UInt64, _indexNumber: Int, _recipient: Address) {
			pre {
				Piece.creatorIDs[_creatorID] != nil:
					"This NFT does not exist in this collection."
			}
			// Assign serial number to the NFT based on the number of minted NFTs
			let _serial = Piece.getNFTMetadata(_creatorID, _indexNumber)!.minted
			self.id = self.uuid
			self.creatorID = _creatorID
			self.serial = _serial
			self.indexNumber = _indexNumber
			self.originalMinter = _recipient

			// Update the buyers list so we keep track of who is purchasing
			if let buyersRef = &Piece.buyersList[_recipient] as &{UInt64: [UInt64]}? {
				if let metadataIdMap = &buyersRef[_creatorID] as &[UInt64]? {
					metadataIdMap.append(_serial)
				} else {
					buyersRef[_creatorID] = [_serial]
				}
			} else {
				Piece.buyersList[_recipient] = {_creatorID: [_serial]}
			}

			let metadataRef = (&Piece.creatorIDs[_creatorID]![_indexNumber] as &NFTMetadata)
			// Update who bought this serial inside NFTMetadata
			metadataRef.purchased(serial: _serial, buyer: _recipient)
			// Update the total supply of this MetadataId by 1
			metadataRef.updateMinted()
			// Update Piece collection NFTs count
			Piece.totalSupply = Piece.totalSupply + 1

			emit Minted(id: self.id, recipient: _recipient, creatorID: _creatorID)
		}
	}

    /// Defines the methods that are particular to this NFT contract collection
    ///
    pub resource interface PieceCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowPiece(id: UInt64): &Piece.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow Piece NFT reference: the ID of the returned reference is incorrect"
            }
        }
    }

	pub resource Collection: PieceCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {

		pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

		// Withdraw removes an NFT from the collection and moves it to the caller(for Trading)
		pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
			let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

			emit Withdraw(id: token.id, from: self.owner?.address)

			return <-token
		}
		// Deposit takes a NFT and adds it to the collections dictionary
		// and adds the ID to the id array
		pub fun deposit(token: @NonFungibleToken.NFT) {
			let token <- token as! @NFT

			let id: UInt64 = token.id

			// Add the new token to the dictionary
			self.ownedNFTs[id] <-! token

			emit Deposit(id: id, to: self.owner?.address)
		}

		// GetIDs returns an array of the IDs that are in the collection
		pub fun getIDs(): [UInt64] {
			return self.ownedNFTs.keys
		}

		// BorrowNFT gets a reference to an NFT in the collection
		pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
			return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
		}

        /// Gets a reference to an NFT in the collection so that
        /// the caller can read its metadata and call its methods
        ///
        /// @param id: The ID of the wanted NFT
        /// @return A reference to the wanted NFT resource
        ///
        pub fun borrowPiece(id: UInt64): &Piece.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorized reference to allow downcasting
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &Piece.NFT
            }

            return nil
        }

		pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
			let token = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
			let nft = token as! &NFT
			return nft as &AnyResource{MetadataViews.Resolver}
		}

		pub fun claim() {
			if let storage = &Piece.nftStorage[self.owner!.address] as &{UInt64: NFT}? {
				for id in storage.keys {
					self.deposit(token: <- storage.remove(key: id)!)
				}
			}
		}

		init () {
			self.ownedNFTs <- {}
		}

		destroy() {
			destroy self.ownedNFTs
		}
	}

	pub resource Administrator {

		// Function to upload the Metadata to the contract.
		pub fun createNFTMetadata(
			channel: String,
			creatorID: UInt64,
			creatorAddress: Address,
			sourceURL: String,
			textContent: String,
			pieceCreationDate: String,
			contentCreationDate: String,
			imgUrl: String,
			embededHTML: String,
		) {
			// Check if a record for this ID Exist, if not
			// create am empty one for it
			if Piece.creatorIDs[creatorID] == nil {
				Piece.creatorIDs[creatorID] = []
			}

			// Check if that creatorID has uploaded any NFTs
			// If not, then stop and return error Event
			if let account_NFTs = &Piece.creatorIDs[creatorID] as &[Piece.NFTMetadata]? {
				if (self.isMetadataUploaded(_metadatasArray: account_NFTs, _textContent: textContent)) {
					emit MetadataError(error: "A Metadata for this Event already exist")
				} else {
					Piece.creatorIDs[creatorID]?.append(NFTMetadata(
						_creatorID: creatorID,
						_creatorAddress: creatorAddress,
						_description: textContent,
						_image: MetadataViews.HTTPFile(
							url: imgUrl,
						),
						_extra: {
							"Channel": channel,
							"Creator": creatorID,
							"Source": sourceURL,
							"Text content": textContent,
							"Piece creation date": pieceCreationDate,
							"Content creation date": contentCreationDate
							},
						_currentTime: getCurrentBlock().timestamp,
						_embededHTML: embededHTML,
					))

					emit MetadataSuccess(creatorID: creatorID, textContent: textContent)
				}


  			}
		}

		// mintNFT mints a new NFT and deposits
		// it in the recipients collection
		pub fun mintNFT(creatorID: UInt64, indexNumber: Int, recipient: Address) {
			pre {
				self.isMintingAvailable(_creatorID: creatorID, _indexNumber: indexNumber): "Minting for this NFT has ended."
			}

			let nft <- create NFT(_creatorID: creatorID, _indexNumber: indexNumber, _recipient: recipient)

			if let recipientCollection = getAccount(recipient).getCapability(Piece.CollectionPublicPath).borrow<&Piece.Collection{NonFungibleToken.CollectionPublic}>() {
				recipientCollection.deposit(token: <- nft)
			} else {
				if let storage = &Piece.nftStorage[recipient] as &{UInt64: NFT}? {
					storage[nft.id] <-! nft
				} else {
					Piece.nftStorage[recipient] <-! {nft.id: <- nft}
				}
			}
		}

		// create a new Administrator resource
		pub fun createAdmin(): @Administrator {
			return <- create Administrator()
		}

		// change piece of collection info
		pub fun changeField(key: String, value: AnyStruct) {
			Piece.collectionInfo[key] = value
		}

		access(account) fun isMintingAvailable(_creatorID: UInt64, _indexNumber: Int): Bool {
			let metadata = Piece.getNFTMetadata(_creatorID, _indexNumber)!
			let answer = getCurrentBlock().timestamp <= (metadata.creationTime + 86400.0)

			return answer
		}

		access(account) fun isMetadataUploaded(_metadatasArray: &[Piece.NFTMetadata], _textContent: String): Bool {
			var i = 0
    		while i < _metadatasArray.length {
			    if (_metadatasArray[i].description == _textContent) {
					return true
				 }
    		i = i + 1
    		}
			return false
		}
	}


	// public function that anyone can call to create a new empty collection
	pub fun createEmptyCollection(): @NonFungibleToken.Collection {
		return <- create Collection()
	}

    /// Function that resolves a metadata view for this contract.
    ///
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    pub fun resolveView(_ view: Type): AnyStruct? {
        switch view {
            case Type<MetadataViews.NFTCollectionData>():
                return MetadataViews.NFTCollectionData(
                    storagePath: Piece.CollectionStoragePath,
                    publicPath: Piece.CollectionPublicPath,
                    providerPath: Piece.CollectionPrivatePath,
                    publicCollection: Type<&Piece.Collection{Piece.PieceCollectionPublic}>(),
                    publicLinkedType: Type<&Piece.Collection{Piece.PieceCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
                    providerLinkedType: Type<&Piece.Collection{Piece.PieceCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(),
                    createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                        return <-Piece.createEmptyCollection()
                    })
                )
            case Type<MetadataViews.NFTCollectionDisplay>():
				let media = Piece.getCollectionAttribute(key: "image") as! MetadataViews.Media
                return MetadataViews.NFTCollectionDisplay(
                        name: "Piece",
                        description: "Sell Pieces of any Tweet in seconds.",
                        externalURL: MetadataViews.ExternalURL("https://piece.gg/"),
                        squareImage: media,
                        bannerImage: media,
                        socials: {
                            "twitter": MetadataViews.ExternalURL("https://twitter.com/CreateAPiece")
                        }
                    )
        }
        return nil
    }

	//Get all the recorded creatorIDs
	pub fun getAllcreatorIDs():[UInt64] {
		return self.creatorIDs.keys
	}

	// Get information about a NFTMetadata
	pub fun getNFTMetadata(_ creatorID: UInt64,_ indexNumber: Int): NFTMetadata? {
		return self.creatorIDs[creatorID]![indexNumber]
	}

	pub fun getOnecreatorIdMetadatas(creatorID: UInt64): [NFTMetadata]? {
		return self.creatorIDs[creatorID]
	}

	pub fun getTimeRemaining(_creatorID: UInt64,_indexNumber: Int): UFix64? {
		let metadata = Piece.getNFTMetadata(_creatorID, _indexNumber)!
		let answer = (metadata.creationTime + 86400.0) - getCurrentBlock().timestamp
		return answer
	}

	pub fun getbuyersList(): {Address: {UInt64: [UInt64]}} {
		return self.buyersList
	}

	pub fun getCollectionInfo(): {String: AnyStruct} {
		let collectionInfo = self.collectionInfo
		collectionInfo["creatorIDs"] = self.creatorIDs
		collectionInfo["buyersList"] = self.buyersList
		collectionInfo["totalSupply"] = self.totalSupply
		collectionInfo["version"] = 1
		return collectionInfo
	}

	pub fun getCollectionAttribute(key: String): AnyStruct {
		return self.collectionInfo[key] ?? panic(key.concat(" is not an attribute in this collection."))
	}

	init() {
		// Collection Info
		self.collectionInfo = {}
		self.collectionInfo["name"] = "Piece"
		self.collectionInfo["description"] = "Sell Pieces of any Tweet in seconds."
		self.collectionInfo["image"] = MetadataViews.Media(
            			file: MetadataViews.HTTPFile(
            				url: "https://media.discordapp.net/attachments/1075564743152107530/1149417271597473913/Piece_collection_image.png?width=1422&height=1422"
            			),
            			mediaType: "image/jpeg"
          			)
    	self.collectionInfo["dateCreated"] = getCurrentBlock().timestamp
    	self.collectionInfo["website"] = MetadataViews.ExternalURL("https://www.piece.gg/")
		self.collectionInfo["socials"] = {"Twitter": MetadataViews.ExternalURL("https://frontend-react-git-testing-piece.vercel.app/")}
		self.totalSupply = 0
		self.creatorIDs = {}
		self.buyersList = {}
		self.nftStorage <- {}

		// Set the named paths
		self.CollectionStoragePath = /storage/PieceCollection
		self.CollectionPublicPath = /public/PieceCollection
		self.CollectionPrivatePath = /private/PieceCollection
		self.AdministratorStoragePath = /storage/PieceAdministrator

		// Create a Collection resource and save it to storage
		let collection <- create Collection()
		self.account.save(<- collection, to: self.CollectionStoragePath)

		// Create a public capability for the collection
		self.account.link<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(
			self.CollectionPublicPath,
			target: self.CollectionStoragePath
		)

		// Create a Administrator resource and save it to storage
		let administrator <- create Administrator()
		self.account.save(<- administrator, to: self.AdministratorStoragePath)

		emit ContractInitialized()
	}
}
"
-------
"pub contract EffectiveLifeTime {

    pub let timeBorn: UFix64
    pub var timeLived: UFix64

    pub event Beat(actualLifeTime: UFix64, effectiveLifeTime: UFix64)

    init() {
        self.timeBorn = getCurrentBlock().timestamp
        self.timeLived = 0.0
    }

    pub fun beat() {
        let block = getCurrentBlock()
        let prevBlock = getBlock(at: block.height - 1)!
        self.timeLived = self.timeLived + (block.timestamp - prevBlock.timestamp)

        emit Beat(
            actualLifeTime: block.timestamp - self.timeBorn,
            effectiveLifeTime: self.timeLived
        )
    }
}
"
-------
"pub contract TransactionTypes {
    /*
    pub fun createListing(
        nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,
        paymentReceiver: Capability<&{FungibleToken.Receiver}>,
        nftType: Type,
        nftID: UInt64,
        salePaymentVaultType: Type,
        price: UFix64,
        customID: String?,
        expiry: UInt64,
        buyer: Address?
    ): UInt64
    */
    pub struct StorefrontListingRequest {
        pub let nftProviderAddress: Address
        pub let nftProviderPath: PrivatePath
        pub let nftStoragePath: StoragePath
        pub let nftTypeIdentifier: String
        pub let nftID: UInt64
        pub let price: UFix64
        pub let customID: String?
        pub let expiry: UInt64
        pub let buyerAddress: Address?
        pub let catalogCollection: Bool

        init(
            nftProviderAddress: Address,
            nftProviderPath: PrivatePath,
            nftStoragePath: StoragePath,
            nftTypeIdentifier: String,
            nftID: UInt64,
            price: UFix64,
            customID: String?,
            expiry: UInt64,
            buyerAddress: Address?,
            catalogCollection: Bool
        ) {
            self.nftProviderAddress = nftProviderAddress
            self.nftProviderPath = nftProviderPath
            self.nftTypeIdentifier = nftTypeIdentifier
            self.nftID = nftID
            self.price = price
            self.customID = customID
            self.expiry = expiry
            self.buyerAddress = buyerAddress
            self.catalogCollection = catalogCollection
            self.nftStoragePath = nftStoragePath
        }
    }
}"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import FlowToken from 0x1654653399040a61
import NonFungibleToken from 0x1d7e57aa55817448

pub contract BridgeManager {
    // Mapping with LockUp recipients as keys and LockUp
    // holders as values.
    pub let lockUpsMapping: {Address: [Address]}

    // Constants for all the available paths
    pub let LockUpStoragePath: StoragePath
    pub let LockUpPrivatePath: PrivatePath
    pub let LockUpPublicPath: PublicPath
    pub let AdminStoragePath: StoragePath
    pub let AdminPrivatePath: PrivatePath

    // Events emitted from the contract
    pub event LockUpCreated(holder: Address, recipient: Address)
    pub event LockUpDestroyed(holder: Address?, recipient: Address)
    pub event LockUpRecipientChanged(holder: Address, recipient: Address)
    pub event LockUpReleasedAtChanged(holder: Address, releasedAt: UInt64)
    pub event LockUpNameChanged(holder: Address, name: String)
    pub event LockUpDescriptionChanged(holder: Address, description: String)

    init() {
        self.lockUpsMapping = {}

        self.LockUpStoragePath = /storage/bridge
        self.LockUpPrivatePath = /private/bridge
        self.LockUpPublicPath = /public/bridge
        self.AdminStoragePath = /storage/admin
        self.AdminPrivatePath = /private/admin

        let admin <- create Admin()
        self.account.save<@Admin>(<- admin, to: self.AdminStoragePath)

        self.account.link<&Admin>(
            self.AdminPrivatePath,
            target: self.AdminStoragePath
        )
    }

    pub struct FungibleTokenInfo {
        pub let name: String
        pub let receiverPath: PublicPath
        pub let balancePath: PublicPath
        pub let privatePath: PrivatePath
        pub let storagePath: StoragePath

        init(
            name: String,
            receiverPath: PublicPath,
            balancePath: PublicPath,
            privatePath: PrivatePath,
            storagePath: StoragePath
        ) {
            self.name = name
            self.receiverPath = receiverPath
            self.balancePath = balancePath
            self.privatePath = privatePath
            self.storagePath = storagePath
        }
    }

    pub struct NonFungibleTokenInfo {
        pub let name: String
        pub let publicPath: PublicPath
        pub let privatePath: PrivatePath
        pub let storagePath: StoragePath
        pub let publicType: Type
        pub let privateType: Type

        init(
            name: String,
            publicPath: PublicPath,
            privatePath: PrivatePath,
            storagePath: StoragePath,
            publicType: Type,
            privateType: Type
        ) {
            self.name = name
            self.publicPath = publicPath
            self.privatePath = privatePath
            self.storagePath = storagePath
            self.publicType = publicType
            self.privateType = privateType
        }
    }

    pub struct FTLockUpInfo {
        pub let identifier: String
        pub let balance: UFix64?

        init(identifier: String, balance: UFix64?) {
            self.identifier = identifier
            self.balance = balance
        }
    }

    pub struct NFTLockUpInfo {
        pub let identifier: String
        pub let nftIDs: [UInt64]?

        init(identifier: String, nftIDs: [UInt64]?) {
            self.identifier = identifier
            self.nftIDs = nftIDs
        }
    }

    pub struct LockUpInfo {
        pub let holder: Address
        pub let releasedAt: UInt64
        pub let createdAt: UInt64
        pub let name: String
        pub let description: String
        pub let recipient: Address
        pub let fungibleTokens: [FTLockUpInfo]
        pub let nonFungibleTokens: [NFTLockUpInfo]

        init(
            holder: Address,
            releasedAt: UInt64,
            createdAt: UInt64,
            name: String,
            description: String,
            recipient: Address,
            fungibleTokens: [FTLockUpInfo],
            nonFungibleTokens: [NFTLockUpInfo]
        ) {
            self.holder = holder
            self.releasedAt = releasedAt
            self.createdAt = createdAt
            self.name = name
            self.description = description
            self.recipient = recipient
            self.fungibleTokens = fungibleTokens
            self.nonFungibleTokens = nonFungibleTokens
        }
    }

    pub resource interface LockUpPublic {
        pub fun getInfo(): LockUpInfo

        // E.g Type<FlowToken>().identifier => A.7e60df042a9c0868.FlowToken
        pub fun withdrawFT(
            identifier: String,
            amount: UFix64,
            receiver: Capability<&{FungibleToken.Receiver}>,
            feeTokens: @FungibleToken.Vault
        )

        // E.g Type<Domains>().identifier => A.9a0766d93b6608b7.Domains
        pub fun withdrawNFT(
            identifier: String,
            receiver: Capability<&{NonFungibleToken.Receiver}>,
            feeTokens: @FungibleToken.Vault,
            nftIDs: [UInt64]?
        )
    }

    pub resource interface LockUpPrivate {
        pub fun lockFT(
            identifier: String,
            vault: Capability<&FungibleToken.Vault>,
            balance: UFix64?
        )

        pub fun lockFTs(_ ftsMapping: {String: FTLockUp})

        pub fun lockNFT(
            identifier: String,
            collection: Capability<&NonFungibleToken.Collection>,
            nftIDs: [UInt64]?
        )

        pub fun setReleasedAt(releasedAt: UInt64)
        pub fun setName(name: String)
        pub fun setDescription(description: String)
        pub fun setRecipient(recipient: Address)
        pub fun setBalance(identifier: String, balance: UFix64)
        pub fun setNFTIDs(identifier: String, nftIDs: [UInt64])
    }

    pub struct FTLockUp {
        pub let vault: Capability<&FungibleToken.Vault>
        pub var balance: UFix64?

        init(
            vault: Capability<&FungibleToken.Vault>,
            balance: UFix64?
        ) {
            self.vault = vault
            self.balance = balance
        }

        pub fun updateBalance(balance: UFix64) {
            self.balance = balance
        }
    }

    pub struct NFTLockUp {
        pub let collection: Capability<&NonFungibleToken.Collection>
        pub var nftIDs: [UInt64]?

        init(
            collection: Capability<&NonFungibleToken.Collection>,
            nftIDs: [UInt64]?
        ) {
            self.collection = collection
            self.nftIDs = nftIDs
        }

        pub fun updateNFTIDs(nftIDs: [UInt64]) {
            self.nftIDs = nftIDs
        }
    }

    pub resource LockUp: LockUpPublic, LockUpPrivate {
        access(self) let holder: Address
        access(self) var releasedAt: UInt64
        access(self) var createdAt: UInt64
        access(self) var name: String
        access(self) var description: String
        access(self) var recipient: Address
        access(self) let ftLockUps: {String: FTLockUp}
        access(self) let nftLockUps: {String: NFTLockUp}

        init(
            holder: Address,
            releasedAt: UInt64,
            name: String,
            description: String,
            recipient: Address,
        ) {
            self.holder = holder
            self.releasedAt = releasedAt
            self.createdAt = UInt64(getCurrentBlock().timestamp)
            self.name = name
            self.description = description
            self.recipient = recipient
            self.ftLockUps = {}
            self.nftLockUps = {}
        }

        pub fun getInfo(): LockUpInfo {
            let fungibleTokens: [FTLockUpInfo] = []
            let nonFungibleTokens: [NFTLockUpInfo] = []

            for key in self.ftLockUps.keys {
                let ftLockUpInfo = FTLockUpInfo(
                    identifier: key,
                    balance: self.ftLockUps[key]!.balance
                )
                fungibleTokens.append(ftLockUpInfo)
            }

            for key in self.nftLockUps.keys {
                let nftLockUpInfo = NFTLockUpInfo(
                    identifier: key,
                    nftIDs: self.nftLockUps[key]!.nftIDs
                )
                nonFungibleTokens.append(nftLockUpInfo)
            }

            return LockUpInfo(
                holder: self.holder,
                releasedAt: self.releasedAt,
                createdAt: self.createdAt,
                name: self.name,
                description: self.description,
                recipient: self.recipient,
                fungibleTokens: fungibleTokens,
                nonFungibleTokens: nonFungibleTokens
            )
        }

        pub fun withdrawFT(
            identifier: String,
            amount: UFix64,
            receiver: Capability<&{FungibleToken.Receiver}>,
            feeTokens: @FungibleToken.Vault
        ) {
            let currentTime = UInt64(getCurrentBlock().timestamp)
            // if self.releasedAt > currentTime {
            //     panic("The assets are still in lock-up period.")
            // }

            if self.recipient != receiver.address {
                panic("Non-authorized recipient.")
            }

            let ftLockUp = self.ftLockUps[identifier]
                ?? panic("Non-supported FungibleToken.")

            if ftLockUp.balance != nil && amount > ftLockUp.balance! {
                panic(
                    "You cannot withdraw more than the remaining balance of: "
                    .concat(ftLockUp.balance!.toString())
                )
            }

            let ownerVault = ftLockUp.vault.borrow()
                ?? panic("Could not borrow FungibleToken.Vault reference.")
            let recipientvault = receiver.borrow()
                ?? panic("Could not borrow FungibleToken.Receiver reference.")

            let admin = BridgeManager.getAdmin()
            let feeSent = feeTokens.balance

            if feeSent < admin.lockUpWithdrawFees {
                panic(
                    "You did not send enough FLOW tokens. Expected: "
                    .concat(admin.lockUpWithdrawFees.toString())
                )
            }

            // Withdraws the requested amount from the owner's vault
            // and deposits it to the recipient's vault
            recipientvault.deposit(from: <- ownerVault.withdraw(amount: amount))

            if ftLockUp.balance != nil {
                self.ftLockUps[identifier]!.updateBalance(balance: ftLockUp.balance! - amount)
            }

            admin.deposit(feeTokens: <- feeTokens)
        }

        pub fun withdrawNFT(
            identifier: String,
            receiver: Capability<&{NonFungibleToken.Receiver}>,
            feeTokens: @FungibleToken.Vault,
            nftIDs: [UInt64]?
        ) {
            let currentTime = UInt64(getCurrentBlock().timestamp)
            // if self.releasedAt > currentTime {
            //     panic("The assets are still in lock-up period!")
            // }

            if self.recipient != receiver.address {
                panic("Non authorized recipient!")
            }

            let nftLockUp = self.nftLockUps[identifier]
                ?? panic("Non-supported FungibleToken.")

            let receiverRef = receiver.borrow()
                ?? panic("Could not borrow NonFungibleToken.Receiver reference.")
            let collectionRef = nftLockUp.collection.borrow()
                ?? panic("Could not borrow NonFungibleToken.Collection reference.")

            let admin = BridgeManager.getAdmin()
            let feeSent = feeTokens.balance

            if feeSent < admin.lockUpWithdrawFees {
                panic(
                    "You did not send enough FLOW tokens. Expected: "
                    .concat(admin.lockUpWithdrawFees.toString())
                )
            }

            let currentCollectionIDs = collectionRef.getIDs()
            var IDs: [UInt64] = []
            var remainingNFTIDs: [UInt64] = nftLockUp.nftIDs!

            if let ids = nftIDs {
                IDs.appendAll(ids)
            } else {
                IDs = nftLockUp.nftIDs!
            }

            for id in IDs {
                if !currentCollectionIDs.contains(id) {
                    continue
                }
                if let index = remainingNFTIDs.firstIndex(of: id) {
                    let nft <- collectionRef.withdraw(withdrawID: id)
                    receiverRef.deposit(token: <- nft)
                    remainingNFTIDs.remove(at: index)
                }
            }

            self.nftLockUps[identifier]!.updateNFTIDs(nftIDs: remainingNFTIDs)
            admin.deposit(feeTokens: <- feeTokens)
        }

        pub fun lockFT(
            identifier: String,
            vault: Capability<&FungibleToken.Vault>,
            balance: UFix64?
        ) {
            self.ftLockUps[identifier] = FTLockUp(
                vault: vault,
                balance: balance
            )
        }

        pub fun lockFTs(_ ftMapping: {String: FTLockUp}) {
            for identifier in self.ftLockUps.keys {
                if !ftMapping.containsKey(identifier) {
                    self.ftLockUps.remove(key: identifier)
                }
            }

            for identifier in ftMapping.keys {
                self.ftLockUps.insert(key: identifier, ftMapping[identifier]!)
            }
        }

        pub fun lockNFT(
            identifier: String,
            collection: Capability<&NonFungibleToken.Collection>,
            nftIDs: [UInt64]?
        ) {
            var IDs: [UInt64] = []
            if let ids = nftIDs {
                self.checkNFTExistence(
                    collection: collection,
                    nftIDs: nftIDs!
                )
                IDs.appendAll(ids)
            } else {
                IDs.appendAll(collection.borrow()!.getIDs())
            }

            if let nftLockUp = self.nftLockUps[identifier] {
                for id in IDs {
                    if  !nftLockUp.nftIDs!.contains(id) {
                        nftLockUp.nftIDs!.append(id)
                    }
                }
                self.nftLockUps.insert(key: identifier, nftLockUp)
            } else {
                self.nftLockUps[identifier] = NFTLockUp(
                    collection: collection,
                    nftIDs: IDs
                )
            }
        }

        pub fun setReleasedAt(releasedAt: UInt64) {
            self.releasedAt = releasedAt
            emit LockUpReleasedAtChanged(holder: self.holder, releasedAt: releasedAt)
        }

        pub fun setName(name: String) {
            self.name = name
            emit LockUpNameChanged(holder: self.holder, name: name)
        }

        pub fun setDescription(description: String) {
            self.description = description
            emit LockUpDescriptionChanged(holder: self.holder, description: description)
        }

        pub fun setRecipient(recipient: Address) {
            BridgeManager.removeFromLockUpsMapping(holder: self.holder, recipient: self.recipient)
            self.recipient = recipient
            BridgeManager.addToLockUpsMapping(holder: self.holder, recipient: self.recipient)
            emit LockUpRecipientChanged(holder: self.holder, recipient: recipient)
        }

        pub fun setBalance(identifier: String, balance: UFix64) {
            if !self.ftLockUps.containsKey(identifier) {
                panic("Non-supported FungibleToken.")
            }
            self.ftLockUps[identifier]!.updateBalance(balance: balance)
        }

        pub fun setNFTIDs(identifier: String, nftIDs: [UInt64]) {
            if !self.nftLockUps.containsKey(identifier) {
                panic("Non-supported NonFungibleToken.")
            }

            if nftIDs.length > 0 {
                self.checkNFTExistence(
                    collection: self.nftLockUps[identifier]!.collection,
                    nftIDs: nftIDs
                )
            }

            self.nftLockUps[identifier]!.updateNFTIDs(nftIDs: nftIDs)
        }

        priv fun checkNFTExistence(
            collection: Capability<&NonFungibleToken.Collection>,
            nftIDs: [UInt64]
        ) {
            let collectionRef = collection.borrow()
                ?? panic("Could not borrow NonFungibleToken.Collection reference.")

            for nftID in nftIDs {
                let nft = collectionRef.borrowNFT(id: nftID)
            }
        }

        destroy() {
            BridgeManager.removeFromLockUpsMapping(holder: self.holder, recipient: self.recipient)
            emit LockUpDestroyed(holder: self.holder, recipient: self.recipient)
        }
    }

    pub resource Admin {
        access(contract) var lockUpCreationFees: UFix64
        access(contract) var lockUpWithdrawFees: UFix64
        access(contract) let feesVault: @FungibleToken.Vault
        access(contract) let fungibleTokenInfoMapping: {String: FungibleTokenInfo}
        access(contract) let nonFungibleTokenInfoMapping: {String: NonFungibleTokenInfo}

        init() {
            self.lockUpCreationFees = 0.0
            self.lockUpWithdrawFees = 0.0
            self.feesVault <- FlowToken.createEmptyVault()
            self.fungibleTokenInfoMapping = {}
            self.nonFungibleTokenInfoMapping = {}
        }

        pub fun addFungibleTokenInfo(identifier: String, tokenInfo: FungibleTokenInfo) {
            self.fungibleTokenInfoMapping[identifier] = tokenInfo
        }

        pub fun addNonFungibleTokenInfo(identifier: String, tokenInfo: NonFungibleTokenInfo) {
            self.nonFungibleTokenInfoMapping[identifier] = tokenInfo
        }

        pub fun updateCreationFees(fees: UFix64) {
            self.lockUpCreationFees = fees
        }

        pub fun updateWithdrawFees(fees: UFix64) {
            self.lockUpWithdrawFees = fees
        }

        pub fun deposit(feeTokens: @FungibleToken.Vault) {
            self.feesVault.deposit(from: <- feeTokens)
        }

        destroy() {
            destroy self.feesVault
        }
    }

    pub fun createLockUp(
        holder: Address,
        releasedAt: UInt64,
        name: String,
        description: String,
        recipient: Address,
        feeTokens: @FungibleToken.Vault
    ): @LockUp {
        // pre {
        //     releasedAt > UInt64(getCurrentBlock().timestamp) : "releasedAt should be a future date timestamp"
        // }

        let admin = self.getAdmin()
        let feeSent = feeTokens.balance

        // if feeSent < admin.lockUpCreationFees {
        //     panic(
        //         "You did not send enough FLOW tokens. Expected: "
        //         .concat(admin.lockUpCreationFees.toString())
        //     )
        // }

        let lockUp <- create LockUp(
            holder: holder,
            releasedAt: releasedAt,
            name: name,
            description: description,
            recipient: recipient
        )

        BridgeManager.addToLockUpsMapping(holder: holder, recipient: recipient)

        emit LockUpCreated(holder: holder, recipient: recipient)

        admin.deposit(feeTokens: <- feeTokens)

        return <- lockUp
    }

    pub fun getFungibleTokenInfoMapping(): {String: FungibleTokenInfo} {
        let admin = self.getAdmin()

        return admin.fungibleTokenInfoMapping
    }

    pub fun getNonFungibleTokenInfoMapping(): {String: NonFungibleTokenInfo} {
        let admin = self.getAdmin()

        return admin.nonFungibleTokenInfoMapping
    }

    pub fun getCreationFees(): UFix64 {
        let admin = self.getAdmin()

        return admin.lockUpCreationFees
    }

    pub fun getWithdrawFees(): UFix64 {
        let admin = self.getAdmin()

        return admin.lockUpWithdrawFees
    }

    access(contract) fun addToLockUpsMapping(holder: Address, recipient: Address) {
        if self.lockUpsMapping.containsKey(recipient) {
            self.lockUpsMapping[recipient]!.append(holder)
        } else {
            self.lockUpsMapping[recipient] = [holder]
        }
    }

    access(contract) fun removeFromLockUpsMapping(holder: Address, recipient: Address) {
        if !self.lockUpsMapping.containsKey(recipient) {
            return
        }

        let holders = self.lockUpsMapping[recipient]!
        var index: Int = 0

        for h in holders {
            if h == holder {
                break
            }
            index = index + 1
        }

        holders.remove(at: index)

        self.lockUpsMapping[recipient] = holders
    }

    access(contract) fun getAdmin(): &Admin {
        let admin = self.account.getCapability(
            self.AdminPrivatePath
        ).borrow<&Admin>()
        ?? panic("Could not borrow BridgeManager.Admin reference.")

        return admin
    }
}
"
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

// The Crash contract containing sub-types and their specification:
//
// - Events
// - The Crash NFT Resource
// - MetadataViews that it supports, and their content
// - The Collection Resource
// - Minter Resource
// - init() function
pub contract Crash: NonFungibleToken {

    // totalSupply
    // The total number of Crash that have been minted
    //
    pub var totalSupply: UInt64

    // Events
    //
    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event Minted(id: UInt64, component: CrashComponent)

    // Named Paths
    //
    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath

    pub struct CrashComponent {
        pub var background: String
        pub var longHair: String
        pub var backAccessory: String
        pub var outfitBack: String
        pub var headgearBack: String
        pub var neck: String
        pub var outfitFront: String
        pub var head: String
        pub var cheekMarkings: String
        pub var forehead: String
        pub var implants: String
        pub var piercings: String
        pub var sideHeadMarkings: String
        pub var mouth: String
        pub var eyes: String
        pub var mohawks: String
        pub var hair: String
        pub var eyegear: String
        pub var headgearFront: String

        init(background: String, longHair: String, backAccessory: String, outfitBack: String, headgearBack: String, neck: String, outfitFront: String,
            head: String, cheekMarkings: String, forehead: String, implants: String, piercings: String, sideHeadMarkings: String, mouth: String, eyes: String,
            mohawks: String, hair: String, eyegear: String, headgearFront: String) {
            self.background = background
            self.longHair = longHair
            self.backAccessory = backAccessory
            self.outfitBack = outfitBack
            self.headgearBack = headgearBack
            self.neck = neck
            self.outfitFront = outfitFront
            self.head = head
            self.cheekMarkings = cheekMarkings
            self.forehead = forehead
            self.implants = implants
            self.piercings = piercings
            self.sideHeadMarkings = sideHeadMarkings
            self.mouth = mouth
            self.eyes = eyes
            self.mohawks = mohawks
            self.hair = hair
            self.eyegear = eyegear
            self.headgearFront = headgearFront
        }
    }

    // pub fun componentToString(_ component: CrashComponent): String {
    //     return component.background.toString()
    //     .concat("-")
    //     .concat(component.head.toString())
    //     .concat("-")
    //     .concat(component.torso.toString())
    //     .concat("-")
    //     .concat(component.legs.toString())
    // }

    // A Crash Item as an NFT
    //
    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        pub let id: UInt64

        pub fun name(): String {
            return "Crash"
                .concat(" #")
                .concat(self.id.toString())
        }

        pub fun description(): String {
            return "Crash "
                .concat(" with serial number ")
                .concat(self.id.toString())
        }


        pub fun thumbnail(): MetadataViews.HTTPFile {
          return MetadataViews.HTTPFile(url: "https://ipfs.io/ipfs/Qmb84UcaMr1MUwNbYBnXWHM3kEaDcYrKuPWwyRLVTNKELC/".concat(self.id.toString()).concat(".png"))
        }

        access(self) let royalties: [MetadataViews.Royalty]
        access(self) let metadata: {String: AnyStruct}


        pub let component: Crash.CrashComponent

        init(
            id: UInt64,
            royalties: [MetadataViews.Royalty],
            metadata: {String: AnyStruct},
            component: Crash.CrashComponent,
        ){
            self.id = id
            self.royalties = royalties
            self.metadata = metadata
            self.component = component
        }

        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.Editions>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.Traits>(),
                Type<MetadataViews.Royalties>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.name(),
                        description: self.description(),
                        thumbnail: self.thumbnail()
                    )
                case Type<MetadataViews.Editions>():
                    // There is no max number of NFTs that can be minted from this contract
                    // so the max edition field value is set to nil
                    let editionInfo = MetadataViews.Edition(name: "Crash NFT Edition", number: self.id, max: nil)
                    let editionList: [MetadataViews.Edition] = [editionInfo]
                    return MetadataViews.Editions(
                        editionList
                    )
                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(
                        self.id
                    )
                case Type<MetadataViews.Royalties>():
                    return MetadataViews.Royalties(
                        self.royalties
                    )
                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL("https://nftbridges.xyz/".concat(self.id.toString()))
                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: Crash.CollectionStoragePath,
                        publicPath: Crash.CollectionPublicPath,
                        providerPath: /private/CrashCollection,
                        publicCollection: Type<&Crash.Collection{Crash.CrashCollectionPublic}>(),
                        publicLinkedType: Type<&Crash.Collection{Crash.CrashCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&Crash.Collection{Crash.CrashCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(),
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                            return <-Crash.createEmptyCollection()
                        })
                    )
                case Type<MetadataViews.NFTCollectionDisplay>():
                    let media = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: "https://nftbridges.xyz/wp-content/uploads/2023/02/NFT_1.png"
                        ),
                        mediaType: "image/png"
                    )

                    let bannerMedia = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: "https://nftbridges.xyz/wp-content/uploads/2023/02/NFT_1.png"
                        ),
                        mediaType: "image/png"
                    )
                    return MetadataViews.NFTCollectionDisplay(
                        name: "The Crash Collection",
                        description: "This collection is used as an example for the NFT bridge",
                        externalURL: MetadataViews.ExternalURL("https://nftbridges.xyz/"),
                        squareImage: media,
                        bannerImage: bannerMedia,
                        socials: {}
                    )
                case Type<MetadataViews.Traits>():
                    // exclude mintedTime and foo to show other uses of Traits
                    let excludedTraits = ["mintedTime", "foo"]
                    let traitsView = MetadataViews.dictToTraits(dict: self.metadata, excludedNames: excludedTraits)

                    return traitsView
            }
            return nil
        }
    }

    // This is the interface that users can cast their Crash Collection as
    // to allow others to deposit Crash into their Collection. It also allows for reading
    // the details of Crash in the Collection.
    pub resource interface CrashCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowCrash(id: UInt64): &Crash.NFT? {
            // If the result isn't nil, the id of the returned reference
            // should be the same as the argument to the function
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow Crash reference: The ID of the returned reference is incorrect"
            }
        }
    }

    // Collection
    // A collection of Crash NFTs owned by an account
    //
    pub resource Collection: CrashCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with an `UInt64` ID field
        //
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        // initializer
        //
        init () {
            self.ownedNFTs <- {}
        }

        // withdraw
        // removes an NFT from the collection and moves it to the caller
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        // deposit
        // takes a NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @Crash.NFT

            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        // getIDs
        // returns an array of the IDs that are in the collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT
        // gets a reference to an NFT in the collection
        // so that the caller can read its metadata and call its methods
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        // borrowCrash
        // Gets a reference to an NFT in the collection as a Crash,
        // exposing all of its fields (including the typeID & rarityID).
        // This is safe as there are no functions that can be called on the Crash.
        //
        pub fun borrowCrash(id: UInt64): &Crash.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorized reference to allow downcasting
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &Crash.NFT
            } else {
                return nil
            }
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let Crash = nft as! &Crash.NFT
            return Crash as &AnyResource{MetadataViews.Resolver}
        }

        // destructor
        destroy() {
            destroy self.ownedNFTs
        }
    }

    // createEmptyCollection
    // public function that anyone can call to create a new empty collection
    //
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    // NFTMinter
    // Resource that an admin or something similar would own to be
    // able to mint new NFTs
    //
    pub resource NFTMinter {

        // mintNFT
        // Mints a new NFT with a new ID
        // and deposit it in the recipients collection using their collection reference
        //
        pub fun mintNFT(
            recipient: &{NonFungibleToken.CollectionPublic},
            component: Crash.CrashComponent,
            royalties: [MetadataViews.Royalty],
            id: UInt64
        ) {
            let metadata: {String: AnyStruct} = {}
            let currentBlock = getCurrentBlock()
            metadata["mintedBlock"] = currentBlock.height
            metadata["mintedTime"] = currentBlock.timestamp
            metadata["minter"] = recipient.owner!.address
            metadata["background"] = component.background
            metadata["longHair"] = component.longHair
            metadata["backAccessory"] = component.backAccessory
            metadata["outfitBack"] = component.outfitBack
            metadata["headgearBack"] = component.headgearBack
            metadata["neck"] = component.neck
            metadata["outfitFront"] = component.outfitFront
            metadata["head"] = component.head
            metadata["cheekMarkings"] = component.cheekMarkings
            metadata["forehead"] = component.forehead
            metadata["implants"] = component.implants
            metadata["piercings"] = component.piercings
            metadata["sideHeadMarkings"] = component.sideHeadMarkings
            metadata["mouth"] = component.mouth
            metadata["eyes"] = component.eyes
            metadata["mohawks"] = component.mohawks
            metadata["hair"] = component.hair
            metadata["eyegear"] = component.eyegear
            metadata["headgearFront"] = component.headgearFront

            // this piece of metadata will be used to show embedding rarity into a trait
            // metadata["foo"] = "bar"

            emit Minted(
                id: id,
                component: component,
            )

            Crash.totalSupply = Crash.totalSupply + UInt64(1)

            // create a new NFT
            var newNFT <- create Crash.NFT(
                id: id,
                royalties: royalties,
                metadata: metadata,
                component: component,
            )

            // deposit it in the recipient's account using their reference
            recipient.deposit(token: <-newNFT)
        }
    }

    // fetch
    // Get a reference to a Crash from an account's Collection, if available.
    // If an account does not have a Crash.Collection, panic.
    // If it has a collection but does not contain the itemID, return nil.
    // If it has a collection and that collection contains the itemID, return a reference to that.
    //
    pub fun fetch(_ from: Address, itemID: UInt64): &Crash.NFT? {
        let collection = getAccount(from)
            .getCapability(Crash.CollectionPublicPath)!
            .borrow<&Crash.Collection{Crash.CrashCollectionPublic}>()
            ?? panic("Couldn't get collection")
        // We trust Crash.Collection.borowCrash to get the correct itemID
        // (it checks it before returning it).
        return collection.borrowCrash(id: itemID)
    }

    // initializer
    //
    init() {

        // Initialize the total supply
        self.totalSupply = 0

        // Set our named paths
        self.CollectionStoragePath = /storage/CrashCollection
        self.CollectionPublicPath = /public/CrashCollection
        self.MinterStoragePath = /storage/CrashMinter

        // Create a Collection resource and save it to storage
        let collection <- create Collection()
        self.account.save(<-collection, to: self.CollectionStoragePath)

        // Create a public capability for the collection
        self.account.link<&Crash.Collection{NonFungibleToken.CollectionPublic, Crash.CrashCollectionPublic, MetadataViews.ResolverCollection}>(
            self.CollectionPublicPath,
            target: self.CollectionStoragePath
        )

        // Create a Minter resource and save it to storage
        let minter <- create NFTMinter()
        self.account.save(<-minter, to: self.MinterStoragePath)

        emit ContractInitialized()
    }
}
 "
-------
"import FantastecSwapDataProperties from 0x4bbff461fa8f6192
import StoreManagerV3 from 0x4bbff461fa8f6192

pub contract StoreManagerV5 {
    pub event SectionAdded(id: UInt64)
    pub event SectionRemoved(id: UInt64)

    pub event ProductAdded(id: UInt64)
    pub event ProductRemoved(id: UInt64)
    pub event ProductUpdated(id: UInt64)
    pub event ProductVolumeForSaleDecremented(id: UInt64, newVolumeForSale: UInt64)

    pub event SectionItemAdded(id: UInt64, sectionId: UInt64, productId: UInt64)
    pub event SectionItemRemoved(id: UInt64, sectionId: UInt64)

    pub event ContractInitiliazed()

    pub let StoreManagerDataPath: StoragePath

    access(contract) var nextSectionItemId: UInt64
    access(contract) var nextSectionId: UInt64

    pub struct Product {
        pub let id: UInt64
        pub let description: String
        pub let level: FantastecSwapDataProperties.Level?
        pub let numberOfOptionalNfts: UInt64
        pub let numberOfPacks: UInt64
        pub let numberOfRegularNfts: UInt64
        pub let partner: FantastecSwapDataProperties.Partner?
        pub let season: FantastecSwapDataProperties.Season?
        pub let shortTitle: String
        pub let sku: FantastecSwapDataProperties.Sku?
        pub let sport: FantastecSwapDataProperties.Sport?
        pub let team: FantastecSwapDataProperties.Team?
        pub let themeType: String
        pub let title: String
        pub let releaseDate: UFix64
        pub var volumeForSale: UInt64
        pub let productImageUrl: String
        pub let productVideoUrl: String
        pub let backgroundImageSmallUrl: String
        pub let backgroundImageLargeUrl: String
        pub let featuredImageUrl: String
        pub let featuredVideoUrl: String
        pub var metadata: {String: [AnyStruct{FantastecSwapDataProperties.MetadataElement}]}

        init(
            id: UInt64,
            description: String,
            level: FantastecSwapDataProperties.Level?,
            numberOfOptionalNfts: UInt64,
            numberOfPacks: UInt64,
            numberOfRegularNfts: UInt64,
            partner: FantastecSwapDataProperties.Partner?,
            season: FantastecSwapDataProperties.Season?,
            shortTitle: String,
            sku: FantastecSwapDataProperties.Sku?,
            sport: FantastecSwapDataProperties.Sport?,
            team: FantastecSwapDataProperties.Team?,
            themeType: String,
            title: String,
            releaseDate: UFix64,
            volumeForSale: UInt64,
            productImageUrl: String,
            productVideoUrl: String,
            backgroundImageSmallUrl: String,
            backgroundImageLargeUrl: String,
            featuredImageUrl: String,
            featuredVideoUrl: String,
            metadata: {String: [AnyStruct{FantastecSwapDataProperties.MetadataElement}]}
        ){
            self.id = id
            self.description = description
            self.level = level
            self.numberOfOptionalNfts = numberOfOptionalNfts
            self.numberOfPacks = numberOfPacks
            self.numberOfRegularNfts = numberOfRegularNfts
            self.partner = partner
            self.season = season
            self.shortTitle = shortTitle
            self.sku = sku
            self.sport = sport
            self.team = team
            self.themeType = themeType
            self.title = title
            self.releaseDate = releaseDate
            self.volumeForSale = volumeForSale
            self.productImageUrl = productImageUrl
            self.productVideoUrl = productVideoUrl
            self.backgroundImageSmallUrl = backgroundImageSmallUrl
            self.backgroundImageLargeUrl = backgroundImageLargeUrl
            self.featuredImageUrl = featuredImageUrl
            self.featuredVideoUrl = featuredVideoUrl
            self.metadata = metadata
        }

        access(contract) fun decrementProductVolumeForSale(): UInt64 {
            if self.volumeForSale == 0 {
                panic("cannot decrement product for sale as volume for sale is zero - product ID: ".concat(self.id.toString()))
            }
            self.volumeForSale = self.volumeForSale - 1
            return self.volumeForSale
        }
    }

    pub struct SectionItem {
        pub let id: UInt64
        pub let position: UInt64
        pub var product: Product?
        pub let productId: UInt64

        init(id: UInt64, position: UInt64, productId: UInt64) {
            self.id = id
            self.position = position
            self.product = nil
            self.productId = productId
        }

        pub fun addProduct(product: Product) {
            self.product = product
        }
    }

    pub struct Section {
        pub let id: UInt64
        pub let sectionItems: {UInt64: SectionItem}
        pub let position: UInt64
        pub let title: String
        pub let type: String

        init(id: UInt64, position: UInt64, title: String, type: String) {
            self.id = id
            self.sectionItems = {}
            self.position = position
            self.title = title
            self.type = type
        }

        pub fun addSectionItem(position: UInt64, productId: UInt64): SectionItem {
            let id = StoreManagerV5.nextSectionItemId

            let sectionItem = SectionItem(id: id, position: position, productId: productId)
            self.sectionItems.insert(key: id, sectionItem)

            StoreManagerV5.nextSectionItemId = StoreManagerV5.nextSectionItemId + 1

            return sectionItem
        }

        pub fun addProductToSectionItem(sectionItemId: UInt64, product: Product): SectionItem? {
            if let sectionItem = self.sectionItems[sectionItemId] {
                sectionItem.addProduct(product: product)
                self.sectionItems[sectionItemId] = sectionItem
                return sectionItem
            }
            return nil
        }

        pub fun removeSectionItem(id: UInt64): SectionItem? {
            return self.sectionItems.remove(key: id)
        }
    }

    //-------------------------
    // Contract level functions
    //-------------------------
    pub fun getStore(): {UInt64: Section} {
        return self.getDataManager().getStore()
    }

    pub fun getProduct(productId: UInt64): Product? {
        return self.getDataManager().getProduct(productId: productId)
    }

    pub fun getProducts(productIds: [UInt64]): [Product] {
        return self.getDataManager().getProducts(productIds: productIds)
    }

    pub fun getAllProducts(): {UInt64: Product} {
        return self.getDataManager().getAllProducts()
    }

    pub resource DataManager {
        access(contract) let products: {UInt64: Product}
        access(contract) let store: {UInt64: Section}

        pub fun getStore(): {UInt64: Section} {
            let products = self.products
            let store = self.store
            let currentBlock = getCurrentBlock()

            store.forEachKey(fun (sectionId: UInt64): Bool {
                if let section = store[sectionId] {
                    section.sectionItems.forEachKey(fun (sectionItemId: UInt64): Bool {
                        if let sectionItem = section.sectionItems[sectionItemId] {
                            if let product = products[sectionItem.productId] {
                                if product.releaseDate <= currentBlock.timestamp {
                                    section.addProductToSectionItem(sectionItemId: sectionItem.id, product: product)
                                }
                            }
                        }

                        return true
                    })

                    store[sectionId] = section
                }

                return true
            })

            return store
        }

        pub fun addProduct(
            id: UInt64,
            description: String,
            level: FantastecSwapDataProperties.Level?,
            numberOfOptionalNfts: UInt64,
            numberOfPacks: UInt64,
            numberOfRegularNfts: UInt64,
            partner: FantastecSwapDataProperties.Partner?,
            season: FantastecSwapDataProperties.Season?,
            shortTitle: String,
            sku: FantastecSwapDataProperties.Sku?,
            sport: FantastecSwapDataProperties.Sport?,
            team: FantastecSwapDataProperties.Team?,
            themeType: String,
            title: String,
            releaseDate: UFix64,
            volumeForSale: UInt64,
            productImageUrl: String,
            productVideoUrl: String,
            backgroundImageSmallUrl: String,
            backgroundImageLargeUrl: String,
            featuredImageUrl: String,
            featuredVideoUrl: String,
            metadata: {String: [AnyStruct{FantastecSwapDataProperties.MetadataElement}]}
        ) {
            let product = Product(
                id: id,
                description: description,
                level: level,
                numberOfOptionalNfts: numberOfOptionalNfts,
                numberOfPacks: numberOfPacks,
                numberOfRegularNfts: numberOfRegularNfts,
                partner: partner,
                season: season,
                shortTitle: shortTitle,
                sku: sku,
                sport: sport,
                team: team,
                themeType: themeType,
                title: title,
                releaseDate: releaseDate,
                volumeForSale: volumeForSale,
                productImageUrl: productImageUrl,
                productVideoUrl: productVideoUrl,
                backgroundImageSmallUrl: backgroundImageSmallUrl,
                backgroundImageLargeUrl: backgroundImageLargeUrl,
                featuredImageUrl: featuredImageUrl,
                featuredVideoUrl: featuredVideoUrl,
                metadata: metadata
            )
            self.products[product.id] = product
            emit ProductAdded(id: product.id)
        }

        pub fun decrementProductVolumeForSale(productId: UInt64) {
            let newVolumeForSale = self.products[productId]?.decrementProductVolumeForSale()
            if (newVolumeForSale != nil) {
                emit ProductVolumeForSaleDecremented(id: productId, newVolumeForSale: newVolumeForSale!)
            }
        }

        pub fun getProduct(productId: UInt64): Product? {
            return self.products[productId]
        }

        pub fun getProducts(productIds: [UInt64]): [Product] {
            let products: [Product] = []
            for productId in productIds {
                let product = self.getProduct(productId: productId)
                if (product != nil) {
                    products.append(product!)
                }
            }
            return products
        }

        pub fun getAllProducts(): {UInt64: Product} {
            return self.products
        }

        pub fun removeProduct(productId: UInt64) {
            let store = self.store
            let sectionItemsToRemove: {UInt64: UInt64} = {}
            store.forEachKey(fun (sectionId: UInt64): Bool {
                if let section = store[sectionId] {
                    section.sectionItems.forEachKey(fun (sectionItemId: UInt64): Bool {
                        if let sectionItem = section.sectionItems[sectionItemId] {
                            if sectionItem.productId == productId {
                                sectionItemsToRemove[section.id] = sectionItem.id
                            }
                        }

                        return true
                    })
                }

                return true
            })

            // Remove all section items that are associated with a removed product
            for sectionId in sectionItemsToRemove.keys {
                let sectionItemId = sectionItemsToRemove[sectionId]
                self.removeSectionItemFromSection(sectionId: sectionId, sectionItemId: sectionItemId!)
                // if the section is now empty, remove it
                let updatedSection = store[sectionId]
                if (updatedSection!.sectionItems.length == 0) {
                    self.removeSection(sectionId: sectionId)
                }
            }

            self.products.remove(key: productId)
            emit ProductUpdated(id: productId)
        }

        pub fun addSection(position: UInt64, title: String, type: String): UInt64 {
            let id = StoreManagerV5.nextSectionId
            let section = Section(id: id, position: position, title: title, type: type)

            self.store[section.id] = section

            emit SectionAdded(id: id)
            StoreManagerV5.nextSectionId = StoreManagerV5.nextSectionId + 1

            return id
        }

        pub fun getSection(sectionId: UInt64): Section? {
            return self.store[sectionId]
        }

        pub fun removeSection(sectionId: UInt64) {
            self.store.remove(key: sectionId)
            emit SectionRemoved(id: sectionId)
        }

        pub fun addSectionItemToSection(sectionId: UInt64, position: UInt64, productId: UInt64): UInt64 {
            let sectionItem = self.store[sectionId]?.addSectionItem(position: position, productId: productId)
            sectionItem ?? panic("no section found with ID ".concat(sectionId.toString()))
            emit SectionItemAdded(id: sectionItem!.id, sectionId: sectionId, productId: productId)

            return sectionItem!.id
        }

        pub fun removeSectionItemFromSection(sectionId: UInt64, sectionItemId: UInt64) {
            let sectionItem = self.store[sectionId]?.removeSectionItem(id: sectionItemId)
            sectionItem ?? panic("no section found with ID ".concat(sectionId.toString()))
            emit SectionItemRemoved(id: sectionItemId, sectionId: sectionId)
        }

        init(_ products: {UInt64: Product}, _ sections: {UInt64: Section}) {
            self.products = products
            self.store = sections
        }
    }

    /* Below are Data Migration functions */

    // pub fun migrateDataProducts(_ page: UInt64, _ size: UInt64) {

    //     // get this contract's DM
    //     var dataManagerV5: &StoreManagerV5.DataManager = self.getDataManager()

    //     // or add the DM if it doesn't exist
    //     if dataManagerV5 == nil {
    //         log("No DataManagerV5 found, creating a new one")

    //         // create the DM and save it
    //         let newProducts: {UInt64: Product} = {}
    //         let newSections: {UInt64: Section} = {}
    //         self.account.save<@StoreManagerV5.DataManager>(<- create DataManager(newProducts, newSections), to: self.StoreManagerDataPath)

    //         // get this contract's DM
    //         dataManagerV5 = self.getDataManager()
    //     } else {
    //         log("Existing DataManagerV5 borrowed")
    //     }

    //     // migrate V3 to V5
    //     var oldProducts = StoreManagerV3.getAllProducts()

    //     var newProducts: {UInt64: Product} = {}

    //     var min = page * size
    //     var max = min + size

    //     for index, product in oldProducts.values {
    //         if UInt64(index) < min {
    //             continue
    //         }
    //         if UInt64(index) > max {
    //             break
    //         }
    //         dataManagerV5.addProduct(
    //             id: product.id,
    //             description: product.description,
    //             level: product.level,
    //             numberOfOptionalNfts: product.numberOfOptionalNfts,
    //             numberOfPacks: product.numberOfPacks,
    //             numberOfRegularNfts: product.numberOfRegularNfts,
    //             partner: product.partner,
    //             season: product.season,
    //             shortTitle: product.shortTitle,
    //             sku: product.sku,
    //             sport: product.sport,
    //             team: product.team,
    //             themeType: product.themeType,
    //             title: product.title,
    //             releaseDate: product.releaseDate,
    //             volumeForSale: product.volumeForSale,
    //             productImageUrl: product.productImageUrl,
    //             productVideoUrl: product.productVideoUrl,
    //             backgroundImageSmallUrl: product.backgroundImageSmallUrl,
    //             backgroundImageLargeUrl: product.backgroundImageLargeUrl,
    //             featuredImageUrl: product.featuredImageUrl,
    //             featuredVideoUrl: product.featuredVideoUrl,
    //             metadata: {}
    //         )
    //     }
    // }

    // pub fun migrateDataSections() {
    //     // get dataManager
    //     var dataManagerV5: &StoreManagerV5.DataManager = self.getDataManager()
    //     var oldSections = StoreManagerV3.getStore()

    //     // migrate V3 to V5
    //     for oldSection in oldSections.values {
    //         let newSectionId = dataManagerV5.addSection(position: oldSection.position, title: oldSection.title, type: oldSection.type)
    //         for sectionItem in oldSection.sectionItems.values {
    //             dataManagerV5.addSectionItemToSection(sectionId: newSectionId, position: sectionItem.position, productId: sectionItem.productId)
    //         }
    //     }
    // }

    // pub fun removeDataManager() {
    //     let oldDataManager <- self.account.load<@DataManager>(from: self.StoreManagerDataPath)
    //     destroy oldDataManager
    // }

    // pub fun setDataManager() { // needs to be made public to permit access to dataManager during migrations
    access(contract) fun setDataManager() {
        let oldDataManager <- self.account.load<@DataManager>(from: self.StoreManagerDataPath)
        var oldProducts = oldDataManager?.products ?? {}
        var oldStore = oldDataManager?.store ?? {}
        self.account.save<@DataManager>(<- create DataManager(oldProducts, oldStore), to: self.StoreManagerDataPath)
        destroy oldDataManager
    }

    access(contract) fun getDataManager(): &DataManager {
        return self.account.borrow<&DataManager>(from: self.StoreManagerDataPath)!
    }

    init() {
        self.nextSectionItemId = 1
        self.nextSectionId = 1

        self.StoreManagerDataPath = /storage/StoreManagerV5Data

        // self.setDataManager()
        emit ContractInitiliazed()
    }
}

"
-------
"//  SPDX-License-Identifier: UNLICENSED
//
//
import NonFungibleToken from 0x1d7e57aa55817448
import Anique from 0xe2e1689b53e92a82

pub contract shield_hero: NonFungibleToken, Anique {
    // -----------------------------------------------------------------------
    // shield_hero contract Events
    // -----------------------------------------------------------------------

    // Events for Contract-Related actions
    //
    // Emitted when the shield_hero contract is created
    pub event ContractInitialized()

    // Events for Item-Related actions
    //
    // Emitted when a new Item struct is created
    pub event ItemCreated(id: UInt32, metadata: {String:String})

    // Events for Collectible-Related actions
    //
    // Emitted when an CollectibleData NFT is minted
    pub event CollectibleMinted(collectibleID: UInt64, itemID: UInt32, serialNumber: UInt32)
    // Emitted when an CollectibleData NFT is destroyed
    pub event CollectibleDestroyed(collectibleID: UInt64)

    // events for Collection-related actions
    //
    // Emitted when an CollectibleData is withdrawn from a Collection
    pub event Withdraw(id: UInt64, from: Address?)
    // Emitted when an CollectibleData is deposited into a Collection
    pub event Deposit(id: UInt64, to: Address?)

    // paths
    pub let collectionStoragePath: StoragePath
    pub let collectionPublicPath: PublicPath
    pub let collectionPrivatePath: PrivatePath
    pub let adminStoragePath: StoragePath
    pub let saleCollectionStoragePath: StoragePath
    pub let saleCollectionPublicPath: PublicPath

    // -----------------------------------------------------------------------
    // shield_hero contract-level fields.
    // These contain actual values that are stored in the smart contract.
    // -----------------------------------------------------------------------

    // fields for Item-related
    //
    // variable size dictionary of Item resources
    access(self) var items: @{UInt32: Item}

    // The ID that is used to create Items.
    pub var nextItemID: UInt32

    // fields for Collectible-related
    //
    // Total number of CollectibleData NFTs that have been minted ever.
    pub var totalSupply: UInt64

    // -----------------------------------------------------------------------
    // shield_hero contract-level Composite Type definitions
    // -----------------------------------------------------------------------

    // The structure that represents Item
    // each digital content which shield_hero deal with on Flow
    //
    pub struct ItemData {

        pub let itemID: UInt32

        pub let metadata: {String: String}

        init(itemID: UInt32) {
            let item = (&shield_hero.items[itemID] as &Item?)!

            self.itemID = item.itemID
            self.metadata = item.metadata
        }
   }

    // Item is a resource type that contains the functions to mint Collectibles.
    //
    // It is stored in a private field in the contract so that
    // the admin resource can call its methods and that there can be
    // public getters for some of its fields
    //
    // The admin can mint Collectibles that refer from Item.
    pub resource Item {

        // unique ID for the Item
        pub let itemID: UInt32

        // Stores all the metadata about the item as a string mapping
        // This is not the long term way NFT metadata will be stored. It's a temporary
        // construct while we figure out a better way to do metadata.
        //
        pub let metadata: {String: String}

        // The number of Collectibles that have been minted per Item.
        access(contract) var numberMintedPerItem: UInt32

        init(metadata: {String: String}) {
            pre {
                metadata.length != 0: "New Item metadata cannot be empty"
            }
            self.itemID = shield_hero.nextItemID
            self.metadata = metadata
            self.numberMintedPerItem = 0

            // increment the nextItemID so that it isn't used again
            shield_hero.nextItemID = shield_hero.nextItemID + 1

            emit ItemCreated(id: self.itemID, metadata: metadata)
        }

        // mintCollectible mints a new Collectible and returns the newly minted Collectible
        //
        // Returns: The NFT that was minted
        //
        pub fun mintCollectible(): @NFT {
            // get the number of Collectibles that have been minted for this Item
            // to use as this Collectible's serial number
            let numInItem = self.numberMintedPerItem

            // mint the new Collectible
            let newCollectible: @NFT <- create NFT(serialNumber: numInItem + 1,
                                              itemID: self.itemID)

            // Increment the count of Collectibles minted for this Item
            self.numberMintedPerItem = numInItem + 1

            return <-newCollectible
        }

        // batchMintCollectible mints an arbitrary quantity of Collectibles
        // and returns them as a Collection
        //
        // Parameters: itemID: the ID of the Item that the Collectibles are minted for
        //             quantity: The quantity of Collectibles to be minted
        //
        // Returns: Collection object that contains all the Collectibles that were minted
        //
        pub fun batchMintCollectible(quantity: UInt64): @Collection {
            let newCollection <- create Collection()

            var i: UInt64 = 0
            while i < quantity {
                newCollection.deposit(token: <-self.mintCollectible())
                i = i + 1
            }

            return <-newCollection
        }

        // Returns: the number of Collectibles
        pub fun getNumberMinted(): UInt32 {
            return self.numberMintedPerItem
        }
    }

    // The structure holds metadata of an Collectible
    pub struct CollectibleData {
        // The ID of the Item that the Collectible references
        pub let itemID: UInt32

        // The place in the Item that this Collectible was minted
        pub let serialNumber: UInt32

        init(itemID: UInt32, serialNumber: UInt32) {
            self.itemID = itemID
            self.serialNumber = serialNumber
        }
    }

    // The resource that represents the CollectibleData NFTs
    //
    pub resource NFT: NonFungibleToken.INFT, Anique.INFT {

        // Global unique collectibleData ID
        pub let id: UInt64

        // Struct of Collectible metadata
        pub let data: CollectibleData

        init(serialNumber: UInt32, itemID: UInt32) {
            // Increment the global Collectible IDs
            shield_hero.totalSupply = shield_hero.totalSupply + 1

            // set id
            self.id = shield_hero.totalSupply

            // Set the metadata struct
            self.data = CollectibleData(itemID: itemID, serialNumber: serialNumber)

            emit CollectibleMinted(collectibleID: self.id, itemID: itemID, serialNumber: self.data.serialNumber)
        }

        destroy() {
            emit CollectibleDestroyed(collectibleID: self.id)
        }
    }

    // interface that represents shield_hero collections to public
    // extends of NonFungibleToken.CollectionPublic
    pub resource interface CollectionPublic {

        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT

        // deposit multi tokens
        pub fun batchDeposit(tokens: @Anique.Collection)

        // contains NFT
        pub fun contains(id: UInt64): Bool

        // borrow NFT as shield_hero token
        pub fun borrowshield_heroCollectible(id: UInt64): auth &NFT
    }

    // Collection is a resource that every user who owns NFTs
    // will store in their account to manage their NFTs
    //
    pub resource Collection: CollectionPublic, NonFungibleToken.Receiver, NonFungibleToken.Provider, NonFungibleToken.CollectionPublic {
        // Dictionary of CollectibleData conforming tokens
        // NFT is a resource type with a UInt64 ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init() {
            self.ownedNFTs <- {}
        }

        // withdraw removes a Collectible from the Collection and moves it to the caller
        //
        // Parameters: withdrawID: The ID of the NFT
        // that is to be removed from the Collection
        //
        // returns: @NonFungibleToken.NFT the token that was withdrawn
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {

            // Remove the nft from the Collection
            let token <- self.ownedNFTs.remove(key: withdrawID)
                ?? panic("Cannot withdraw: Collectible does not exist in the collection")

            emit Withdraw(id: token.id, from: self.owner?.address)

            // Return the withdrawn token
            return <- token
        }

        // batchWithdraw withdraws multiple tokens and returns them as a Collection
        //
        // Parameters: collectibleIds: An array of IDs to withdraw
        //
        // Returns: @NonFungibleToken.Collection: A collection that contains
        //                                        the withdrawn collectibles
        //
        pub fun batchWithdraw(collectibleIds: [UInt64]): @Anique.Collection {
            // Create a new empty Collection
            var batchCollection <- create Collection()

            // Iterate through the collectibleIds and withdraw them from the Collection
            for collectibleID in collectibleIds {
                batchCollection.deposit(token: <-self.withdraw(withdrawID: collectibleID))
            }

            // Return the withdrawn tokens
            return <-batchCollection
        }

        // deposit takes a Collectible and adds it to the Collections dictionary
        //
        // Parameters: token: the NFT to be deposited in the collection
        //
        pub fun deposit(token: @NonFungibleToken.NFT) {

            // Cast the deposited token as an shield_hero NFT to make sure
            // it is the correct type
            let token <- token as! @shield_hero.NFT

            // Get the token's ID
            let id = token.id

            // Add the new token to the dictionary
            let oldToken <- self.ownedNFTs[id] <- token

            // Only emit a deposit event if the Collection
            // is in an account's storage
            if self.owner?.address != nil {
                emit Deposit(id: id, to: self.owner?.address)
            }

            // Destroy the empty old token that was "removed"
            destroy oldToken
        }

        // batchDeposit takes a Collection object as an argument
        // and deposits each contained NFT into this Collection
        pub fun batchDeposit(tokens: @Anique.Collection) {

            // Get an array of the IDs to be deposited
            let keys = tokens.getIDs()

            // Iterate through the keys in the collection and deposit each one
            for key in keys {
                self.deposit(token: <-tokens.withdraw(withdrawID: key))
            }

            // Destroy the empty Collection
            destroy tokens
        }

        // getIDs returns an array of the IDs that are in the Collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // contains returns whether ID is in the Collection
        pub fun contains(id: UInt64): Bool {
            return self.ownedNFTs[id] != nil
        }

        // borrowNFT Returns a borrowed reference to a Collectible in the Collection
        // so that the caller can read its ID
        //
        // Parameters: id: The ID of the NFT to get the reference for
        //
        // Returns: A reference to the NFT
        //
        // Note: This only allows the caller to read the ID of the NFT,
        // not any shield_hero specific data. Please use borrowCollectible to
        // read Collectible data.
        //
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowAniqueNFT(id: UInt64): auth &Anique.NFT {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            return nft as! auth &Anique.NFT
        }

        // borrowshield_heroCollectible returns a borrowed reference
        // to an shield_hero Collectible
        pub fun borrowshield_heroCollectible(id: UInt64): auth &NFT {
            pre {
                self.ownedNFTs[id] != nil: "NFT does not exist in the collection!"
            }
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            return nft as! auth &NFT
        }

        // If a transaction destroys the Collection object,
        // All the NFTs contained within are also destroyed!
        //
        destroy() {
            destroy self.ownedNFTs
        }
    }

    // Admin is a special authorization resource that
    // allows the owner to perform important functions to modify the
    // various aspects of the Items, CollectibleDatas, etc.
    //
    pub resource Admin {

        // createItem creates a new Item struct
        // and stores it in the Items dictionary field in the shield_hero smart contract
        //
        // Parameters: metadata: A dictionary mapping metadata titles to their data
        //                       example: {"Title": "Excellent Anime", "Author": "John Smith"}
        //
        // Returns: the ID of the new Item object
        //
        pub fun createItem(metadata: {String: String}): UInt32 {
            // Create the new Item
            var newItem <- create Item(metadata: metadata)
            let itemId = newItem.itemID

            // Store it in the contract storage
            shield_hero.items[newItem.itemID] <-! newItem

            return itemId
        }

        // borrowItem returns a reference to a Item in the shield_hero
        // contract so that the admin can call methods on it
        //
        // Parameters: itemID: The ID of the Item that you want to
        // get a reference to
        //
        // Returns: A reference to the Item with all of the fields
        // and methods exposed
        //
        pub fun borrowItem(itemID: UInt32): &Item {
            pre {
                shield_hero.items[itemID] != nil: "Cannot borrow Item: The Item doesn't exist"
            }

            return (&shield_hero.items[itemID] as &Item?)!
        }

        // createNewAdmin creates a new Admin resource
        //
        pub fun createNewAdmin(): @Admin {
            return <-create Admin()
        }
    }

    // -----------------------------------------------------------------------
    // shield_hero contract-level function definitions
    // -----------------------------------------------------------------------

    // createEmptyCollection creates a new, empty Collection object so that
    // a user can store it in their account storage.
    // Once they have a Collection in their storage, they are able to receive
    // Collectibles in transactions.
    //
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <-create shield_hero.Collection()
    }

    // getNumCollectiblesInItem return the number of Collectibles that have been
    //                        minted from a certain Item.
    //
    // Parameters: itemID: The id of the Item that is being searched
    //
    // Returns: The total number of Collectibles
    //          that have been minted from a Item
    pub fun getNumCollectiblesInItem(itemID: UInt32): UInt32 {
        let item = (&shield_hero.items[itemID] as &Item?)!
        return item.numberMintedPerItem
    }

    // -----------------------------------------------------------------------
    // shield_hero initialization function
    // -----------------------------------------------------------------------
    //
    init() {
        // Initialize contract fields
        self.items <- {}
        self.nextItemID = 1
        self.totalSupply = 0

        self.collectionStoragePath     = /storage/shield_heroCollection
        self.collectionPublicPath      =  /public/shield_heroCollection
        self.collectionPrivatePath     = /private/shield_heroCollection
        self.adminStoragePath          = /storage/shield_heroAdmin
        self.saleCollectionStoragePath = /storage/shield_heroSaleCollection
        self.saleCollectionPublicPath  =  /public/shield_heroSaleCollection

        // Put a new Collection in storage
        self.account.save<@Collection>(<- create Collection(), to: self.collectionStoragePath)

        // Create a public capability for the Collection
        self.account.link<&{CollectionPublic}>(self.collectionPublicPath, target: self.collectionStoragePath)

        // Put the Admin in storage
        self.account.save<@Admin>(<- create Admin(), to: self.adminStoragePath)

        emit ContractInitialized()
    }
}
"
-------
"/*
 * Copyright (c) 2021 24Karat. All rights reserved.
 *
 * SPDX-License-Identifier: MIT
 *
 * This file is part of Project: 24karat flow contract (https://github.com/24karat-io/flow-contract)
 *
 * This source code is licensed under the MIT License found in the
 * LICENSE file in the root directory of this source tree or at
 * https://opensource.org/licenses/MIT.
 */

import FungibleToken from 0xf233dcee88fe0abe

pub contract VO_SALES: FungibleToken {
    // TokensInitialized
    //
    // The event that is emitted when the contract is created
    pub event TokensInitialized(initialSupply: UFix64)

    // TokensWithdrawn
    //
    // The event that is emitted when tokens are withdrawn from a Vault
    pub event TokensWithdrawn(amount: UFix64, from: Address?)

    // TokensDeposited
    //
    // The event that is emitted when tokens are deposited to a Vault
    pub event TokensDeposited(amount: UFix64, to: Address?)

    // TokensMinted
    //
    // The event that is emitted when new tokens are minted
    pub event TokensMinted(amount: UFix64)

    // TokensBurned
    //
    // The event that is emitted when tokens are destroyed
    pub event TokensBurned(amount: UFix64)

    // MinterCreated
    //
    // The event that is emitted when a new minter resource is created
    pub event MinterCreated(allowedAmount: UFix64)

    // Named paths
    //
    pub let VaultStoragePath: StoragePath
    pub let ReceiverPublicPath: PublicPath
    pub let BalancePublicPath: PublicPath
    pub let AdminStoragePath: StoragePath

    // Total supply of token in existence
    pub var totalSupply: UFix64

    // Vault
    //
    // Each user stores an instance of only the Vault in their storage
    // The functions in the Vault and governed by the pre and post conditions
    // in FungibleToken when they are called.
    // The checks happen at runtime whenever a function is called.
    //
    // Resources can only be created in the context of the contract that they
    // are defined in, so there is no way for a malicious user to create Vaults
    // out of thin air. A special Minter resource needs to be defined to mint
    // new tokens.
    //
    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {

        // The total balance of this vault
        pub var balance: UFix64

        // initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        // withdraw
        //
        // Function that takes an amount as an argument
        // and withdraws that amount from the Vault.
        //
        // It creates a new temporary Vault that is used to hold
        // the money that is being transferred. It returns the newly
        // created Vault to the context that called so it can be deposited
        // elsewhere.
        //
        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)
            return <-create Vault(balance: amount)
        }

        // deposit
        //
        // Function that takes a Vault object as an argument and adds
        // its balance to the balance of the owners Vault.
        //
        // It is allowed to destroy the sent Vault because the Vault
        // was a temporary holder of the tokens. The Vault's balance has
        // been consumed and therefore can be destroyed.
        //
        pub fun deposit(from: @FungibleToken.Vault) {
            let vault <- from as! @VO_SALES.Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)
            vault.balance = 0.0
            destroy vault
        }

        destroy() {
            VO_SALES.totalSupply = VO_SALES.totalSupply - self.balance
            if(self.balance > 0.0) {
                emit TokensBurned(amount: self.balance)
            }
        }
    }

    // createEmptyVault
    //
    // Function that creates a new Vault with a balance of zero
    // and returns it to the calling context. A user must call this function
    // and store the returned Vault in their storage in order to allow their
    // account to be able to receive deposits of this token type.
    //
    pub fun createEmptyVault(): @Vault {
        return <-create Vault(balance: 0.0)
    }

    pub resource Administrator {

        // createNewMinter
        //
        // Function that creates and returns a new minter resource
        //
        pub fun createNewMinter(allowedAmount: UFix64): @Minter {
            emit MinterCreated(allowedAmount: allowedAmount)
            return <-create Minter(allowedAmount: allowedAmount)
        }
    }

    // Minter
    //
    // Resource object that token admin accounts can hold to mint new tokens.
    //
    pub resource Minter {

        // The amount of tokens that the minter is allowed to mint
        pub var allowedAmount: UFix64

        // mintTokens
        //
        // Function that mints new tokens, adds them to the total supply,
        // and returns them to the calling context.
        //
        pub fun mintTokens(amount: UFix64): @VO_SALES.Vault {
            pre {
                amount > 0.0: "Amount minted must be greater than zero"
                amount <= self.allowedAmount: "Amount minted must be less than the allowed amount"
            }
            VO_SALES.totalSupply = VO_SALES.totalSupply + amount
            self.allowedAmount = self.allowedAmount - amount
            emit TokensMinted(amount: amount)
            return <-create Vault(balance: amount)
        }

        init(allowedAmount: UFix64) {
            self.allowedAmount = allowedAmount
        }
    }

    init() {
        // Set our named paths.
        self.VaultStoragePath = /storage/VO_SALESVault
        self.ReceiverPublicPath = /public/VO_SALESReceiver
        self.BalancePublicPath = /public/VO_SALESBalance
        self.AdminStoragePath = /storage/VO_SALESAdmin

        // Initialize contract state.
        self.totalSupply = 0.0

        // Create the one true Admin object and deposit it into the conttract account.
        let admin <- create Administrator()
        self.account.save(<-admin, to: self.AdminStoragePath)

        // Emit an event that shows that the contract was initialized.
        emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
"
-------
"import JoyridePayments from 0xecfad18ba9582d4f

pub contract JoyrideGameShim {
    pub event PlayerTransaction(gameID: String)
    pub event FinalizeTransaction(gameID: String)
    pub event RefundTransaction(gameID: String)

    //Fake Token Events for User Mapping
    pub event TokensWithdrawn(amount: UFix64, from: Address?)
    pub event TokensDeposited(amount: UFix64, to: Address?)

    pub fun GameIDtoStoragePath(_ gameID:String) : StoragePath {
      return StoragePath(identifier: "JoyrideGame_".concat(gameID))!
    }

    pub fun GameIDtoCapabilityPath(_ gameID:String) : PrivatePath {
      return PrivatePath(identifier: "JoyrideGame_".concat(gameID))!
    }

    pub fun CreateJoyrideGame(paymentsAdmin: Capability<&{JoyridePayments.WalletAdmin}>,gameID:String) : @JoyrideGameShim.JoyrideGame {
      return <- create JoyrideGameShim.JoyrideGame(paymentsAdmin:paymentsAdmin, gameID:gameID)
    }

    pub resource interface JoyrideGameData {
      pub fun readGameInfo(_ key:String) : AnyStruct
      pub fun setGameInfo(_ key:String, value:AnyStruct)
    }

    pub resource JoyrideGame: JoyrideGameData, JoyridePayments.WalletAdmin
    {
      access(self) let gameInfo:{String:AnyStruct}
      access(self) var paymentsAdmin: Capability<&{JoyridePayments.WalletAdmin}>

      init(paymentsAdmin: Capability<&{JoyridePayments.WalletAdmin}>, gameID:String) {
        self.gameInfo = {"gameID":gameID}
        self.paymentsAdmin = paymentsAdmin
      }

      pub fun readGameInfo(_ key:String) : AnyStruct {
        return self.gameInfo[key]
      }

      pub fun setGameInfo(_ key:String, value:AnyStruct) {
        self.gameInfo[key] = value
      }

      pub fun PlayerTransaction(playerID: String, tokenContext: String, amount:Fix64, gameID: String, txID: String, reward: Bool, notes: String) : Bool {
        if(!self.gameInfo.containsKey("gameID")) {
            panic("gameID not set")
        }
        let _gameID = self.readGameInfo("gameID")! as! String
        if(gameID != _gameID) { panic("Incorrect GameID for Shim") }

        emit JoyrideGameShim.PlayerTransaction(gameID: gameID)
        return self.paymentsAdmin.borrow()!.PlayerTransaction(playerID: playerID, tokenContext: tokenContext, amount: amount, gameID: gameID, txID: txID, reward: reward, notes: notes)
      }

      pub fun FinalizeTransactionWithDevPercentage(txID: String, profit: UFix64, devPercentage: UFix64) : Bool {
        emit JoyrideGameShim.FinalizeTransaction(gameID: self.readGameInfo("gameID")! as! String)
        return self.paymentsAdmin.borrow()!.FinalizeTransactionWithDevPercentage(txID: txID, profit: profit, devPercentage: devPercentage)
      }

      pub fun RefundTransaction(txID: String) : Bool {
        emit JoyrideGameShim.RefundTransaction(gameID: self.readGameInfo("gameID")! as! String)
        return self.paymentsAdmin.borrow()!.RefundTransaction(txID: txID)
      }
    }
}
"
-------
"//  SPDX-License-Identifier: UNLICENSED
//
//
import NonFungibleToken from 0x1d7e57aa55817448
import Anique from 0xe2e1689b53e92a82

pub contract SGKCLDR_bk_pbd_khb: NonFungibleToken, Anique {
    // -----------------------------------------------------------------------
    // SGKCLDR_bk_pbd_khb contract Events
    // -----------------------------------------------------------------------

    // Events for Contract-Related actions
    //
    // Emitted when the SGKCLDR_bk_pbd_khb contract is created
    pub event ContractInitialized()

    // Events for Item-Related actions
    //
    // Emitted when a new Item struct is created
    pub event ItemCreated(id: UInt32, metadata: {String:String})

    // Events for Collectible-Related actions
    //
    // Emitted when an CollectibleData NFT is minted
    pub event CollectibleMinted(collectibleID: UInt64, itemID: UInt32, serialNumber: UInt32)
    // Emitted when an CollectibleData NFT is destroyed
    pub event CollectibleDestroyed(collectibleID: UInt64)

    // events for Collection-related actions
    //
    // Emitted when an CollectibleData is withdrawn from a Collection
    pub event Withdraw(id: UInt64, from: Address?)
    // Emitted when an CollectibleData is deposited into a Collection
    pub event Deposit(id: UInt64, to: Address?)

    // paths
    pub let collectionStoragePath: StoragePath
    pub let collectionPublicPath: PublicPath
    pub let collectionPrivatePath: PrivatePath
    pub let adminStoragePath: StoragePath
    pub let saleCollectionStoragePath: StoragePath
    pub let saleCollectionPublicPath: PublicPath

    // -----------------------------------------------------------------------
    // SGKCLDR_bk_pbd_khb contract-level fields.
    // These contain actual values that are stored in the smart contract.
    // -----------------------------------------------------------------------

    // fields for Item-related
    //
    // variable size dictionary of Item resources
    access(self) var items: @{UInt32: Item}

    // The ID that is used to create Items.
    pub var nextItemID: UInt32

    // fields for Collectible-related
    //
    // Total number of CollectibleData NFTs that have been minted ever.
    pub var totalSupply: UInt64

    // -----------------------------------------------------------------------
    // SGKCLDR_bk_pbd_khb contract-level Composite Type definitions
    // -----------------------------------------------------------------------

    // The structure that represents Item
    // each digital content which SGKCLDR_bk_pbd_khb deal with on Flow
    //
    pub struct ItemData {

        pub let itemID: UInt32

        pub let metadata: {String: String}

        init(itemID: UInt32) {
            let item = (&SGKCLDR_bk_pbd_khb.items[itemID] as &Item?)!

            self.itemID = item.itemID
            self.metadata = item.metadata
        }
   }

    // Item is a resource type that contains the functions to mint Collectibles.
    //
    // It is stored in a private field in the contract so that
    // the admin resource can call its methods and that there can be
    // public getters for some of its fields
    //
    // The admin can mint Collectibles that refer from Item.
    pub resource Item {

        // unique ID for the Item
        pub let itemID: UInt32

        // Stores all the metadata about the item as a string mapping
        // This is not the long term way NFT metadata will be stored. It's a temporary
        // construct while we figure out a better way to do metadata.
        //
        pub let metadata: {String: String}

        // The number of Collectibles that have been minted per Item.
        access(contract) var numberMintedPerItem: UInt32

        init(metadata: {String: String}) {
            pre {
                metadata.length != 0: "New Item metadata cannot be empty"
            }
            self.itemID = SGKCLDR_bk_pbd_khb.nextItemID
            self.metadata = metadata
            self.numberMintedPerItem = 0

            // increment the nextItemID so that it isn't used again
            SGKCLDR_bk_pbd_khb.nextItemID = SGKCLDR_bk_pbd_khb.nextItemID + 1

            emit ItemCreated(id: self.itemID, metadata: metadata)
        }

        // mintCollectible mints a new Collectible and returns the newly minted Collectible
        //
        // Returns: The NFT that was minted
        //
        pub fun mintCollectible(): @NFT {
            // get the number of Collectibles that have been minted for this Item
            // to use as this Collectible's serial number
            let numInItem = self.numberMintedPerItem

            // mint the new Collectible
            let newCollectible: @NFT <- create NFT(serialNumber: numInItem + 1,
                                              itemID: self.itemID)

            // Increment the count of Collectibles minted for this Item
            self.numberMintedPerItem = numInItem + 1

            return <-newCollectible
        }

        // batchMintCollectible mints an arbitrary quantity of Collectibles
        // and returns them as a Collection
        //
        // Parameters: itemID: the ID of the Item that the Collectibles are minted for
        //             quantity: The quantity of Collectibles to be minted
        //
        // Returns: Collection object that contains all the Collectibles that were minted
        //
        pub fun batchMintCollectible(quantity: UInt64): @Collection {
            let newCollection <- create Collection()

            var i: UInt64 = 0
            while i < quantity {
                newCollection.deposit(token: <-self.mintCollectible())
                i = i + 1
            }

            return <-newCollection
        }

        // Returns: the number of Collectibles
        pub fun getNumberMinted(): UInt32 {
            return self.numberMintedPerItem
        }
    }

    // The structure holds metadata of an Collectible
    pub struct CollectibleData {
        // The ID of the Item that the Collectible references
        pub let itemID: UInt32

        // The place in the Item that this Collectible was minted
        pub let serialNumber: UInt32

        init(itemID: UInt32, serialNumber: UInt32) {
            self.itemID = itemID
            self.serialNumber = serialNumber
        }
    }

    // The resource that represents the CollectibleData NFTs
    //
    pub resource NFT: NonFungibleToken.INFT, Anique.INFT {

        // Global unique collectibleData ID
        pub let id: UInt64

        // Struct of Collectible metadata
        pub let data: CollectibleData

        init(serialNumber: UInt32, itemID: UInt32) {
            // Increment the global Collectible IDs
            SGKCLDR_bk_pbd_khb.totalSupply = SGKCLDR_bk_pbd_khb.totalSupply + 1

            // set id
            self.id = SGKCLDR_bk_pbd_khb.totalSupply

            // Set the metadata struct
            self.data = CollectibleData(itemID: itemID, serialNumber: serialNumber)

            emit CollectibleMinted(collectibleID: self.id, itemID: itemID, serialNumber: self.data.serialNumber)
        }

        destroy() {
            emit CollectibleDestroyed(collectibleID: self.id)
        }
    }

    // interface that represents SGKCLDR_bk_pbd_khb collections to public
    // extends of NonFungibleToken.CollectionPublic
    pub resource interface CollectionPublic {

        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT

        // deposit multi tokens
        pub fun batchDeposit(tokens: @Anique.Collection)

        // contains NFT
        pub fun contains(id: UInt64): Bool

        // borrow NFT as SGKCLDR_bk_pbd_khb token
        pub fun borrowSGKCLDR_bk_pbd_khbCollectible(id: UInt64): auth &NFT
    }

    // Collection is a resource that every user who owns NFTs
    // will store in their account to manage their NFTs
    //
    pub resource Collection: CollectionPublic, NonFungibleToken.Receiver, NonFungibleToken.Provider, NonFungibleToken.CollectionPublic {
        // Dictionary of CollectibleData conforming tokens
        // NFT is a resource type with a UInt64 ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init() {
            self.ownedNFTs <- {}
        }

        // withdraw removes a Collectible from the Collection and moves it to the caller
        //
        // Parameters: withdrawID: The ID of the NFT
        // that is to be removed from the Collection
        //
        // returns: @NonFungibleToken.NFT the token that was withdrawn
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {

            // Remove the nft from the Collection
            let token <- self.ownedNFTs.remove(key: withdrawID)
                ?? panic("Cannot withdraw: Collectible does not exist in the collection")

            emit Withdraw(id: token.id, from: self.owner?.address)

            // Return the withdrawn token
            return <- token
        }

        // batchWithdraw withdraws multiple tokens and returns them as a Collection
        //
        // Parameters: collectibleIds: An array of IDs to withdraw
        //
        // Returns: @NonFungibleToken.Collection: A collection that contains
        //                                        the withdrawn collectibles
        //
        pub fun batchWithdraw(collectibleIds: [UInt64]): @Anique.Collection {
            // Create a new empty Collection
            var batchCollection <- create Collection()

            // Iterate through the collectibleIds and withdraw them from the Collection
            for collectibleID in collectibleIds {
                batchCollection.deposit(token: <-self.withdraw(withdrawID: collectibleID))
            }

            // Return the withdrawn tokens
            return <-batchCollection
        }

        // deposit takes a Collectible and adds it to the Collections dictionary
        //
        // Parameters: token: the NFT to be deposited in the collection
        //
        pub fun deposit(token: @NonFungibleToken.NFT) {

            // Cast the deposited token as an SGKCLDR_bk_pbd_khb NFT to make sure
            // it is the correct type
            let token <- token as! @SGKCLDR_bk_pbd_khb.NFT

            // Get the token's ID
            let id = token.id

            // Add the new token to the dictionary
            let oldToken <- self.ownedNFTs[id] <- token

            // Only emit a deposit event if the Collection
            // is in an account's storage
            if self.owner?.address != nil {
                emit Deposit(id: id, to: self.owner?.address)
            }

            // Destroy the empty old token that was "removed"
            destroy oldToken
        }

        // batchDeposit takes a Collection object as an argument
        // and deposits each contained NFT into this Collection
        pub fun batchDeposit(tokens: @Anique.Collection) {

            // Get an array of the IDs to be deposited
            let keys = tokens.getIDs()

            // Iterate through the keys in the collection and deposit each one
            for key in keys {
                self.deposit(token: <-tokens.withdraw(withdrawID: key))
            }

            // Destroy the empty Collection
            destroy tokens
        }

        // getIDs returns an array of the IDs that are in the Collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // contains returns whether ID is in the Collection
        pub fun contains(id: UInt64): Bool {
            return self.ownedNFTs[id] != nil
        }

        // borrowNFT Returns a borrowed reference to a Collectible in the Collection
        // so that the caller can read its ID
        //
        // Parameters: id: The ID of the NFT to get the reference for
        //
        // Returns: A reference to the NFT
        //
        // Note: This only allows the caller to read the ID of the NFT,
        // not any SGKCLDR_bk_pbd_khb specific data. Please use borrowCollectible to
        // read Collectible data.
        //
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowAniqueNFT(id: UInt64): auth &Anique.NFT {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            return nft as! auth &Anique.NFT
        }

        // borrowSGKCLDR_bk_pbd_khbCollectible returns a borrowed reference
        // to an SGKCLDR_bk_pbd_khb Collectible
        pub fun borrowSGKCLDR_bk_pbd_khbCollectible(id: UInt64): auth &NFT {
            pre {
                self.ownedNFTs[id] != nil: "NFT does not exist in the collection!"
            }
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            return nft as! auth &NFT
        }

        // If a transaction destroys the Collection object,
        // All the NFTs contained within are also destroyed!
        //
        destroy() {
            destroy self.ownedNFTs
        }
    }

    // Admin is a special authorization resource that
    // allows the owner to perform important functions to modify the
    // various aspects of the Items, CollectibleDatas, etc.
    //
    pub resource Admin {

        // createItem creates a new Item struct
        // and stores it in the Items dictionary field in the SGKCLDR_bk_pbd_khb smart contract
        //
        // Parameters: metadata: A dictionary mapping metadata titles to their data
        //                       example: {"Title": "Excellent Anime", "Author": "John Smith"}
        //
        // Returns: the ID of the new Item object
        //
        pub fun createItem(metadata: {String: String}): UInt32 {
            // Create the new Item
            var newItem <- create Item(metadata: metadata)
            let itemId = newItem.itemID

            // Store it in the contract storage
            SGKCLDR_bk_pbd_khb.items[newItem.itemID] <-! newItem

            return itemId
        }

        // borrowItem returns a reference to a Item in the SGKCLDR_bk_pbd_khb
        // contract so that the admin can call methods on it
        //
        // Parameters: itemID: The ID of the Item that you want to
        // get a reference to
        //
        // Returns: A reference to the Item with all of the fields
        // and methods exposed
        //
        pub fun borrowItem(itemID: UInt32): &Item {
            pre {
                SGKCLDR_bk_pbd_khb.items[itemID] != nil: "Cannot borrow Item: The Item doesn't exist"
            }

            return (&SGKCLDR_bk_pbd_khb.items[itemID] as &Item?)!
        }

        // createNewAdmin creates a new Admin resource
        //
        pub fun createNewAdmin(): @Admin {
            return <-create Admin()
        }
    }

    // -----------------------------------------------------------------------
    // SGKCLDR_bk_pbd_khb contract-level function definitions
    // -----------------------------------------------------------------------

    // createEmptyCollection creates a new, empty Collection object so that
    // a user can store it in their account storage.
    // Once they have a Collection in their storage, they are able to receive
    // Collectibles in transactions.
    //
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <-create SGKCLDR_bk_pbd_khb.Collection()
    }

    // getNumCollectiblesInItem return the number of Collectibles that have been
    //                        minted from a certain Item.
    //
    // Parameters: itemID: The id of the Item that is being searched
    //
    // Returns: The total number of Collectibles
    //          that have been minted from a Item
    pub fun getNumCollectiblesInItem(itemID: UInt32): UInt32 {
        let item = (&SGKCLDR_bk_pbd_khb.items[itemID] as &Item?)!
        return item.numberMintedPerItem
    }

    // -----------------------------------------------------------------------
    // SGKCLDR_bk_pbd_khb initialization function
    // -----------------------------------------------------------------------
    //
    init() {
        // Initialize contract fields
        self.items <- {}
        self.nextItemID = 1
        self.totalSupply = 0

        self.collectionStoragePath     = /storage/SGKCLDR_bk_pbd_khbCollection
        self.collectionPublicPath      =  /public/SGKCLDR_bk_pbd_khbCollection
        self.collectionPrivatePath     = /private/SGKCLDR_bk_pbd_khbCollection
        self.adminStoragePath          = /storage/SGKCLDR_bk_pbd_khbAdmin
        self.saleCollectionStoragePath = /storage/SGKCLDR_bk_pbd_khbSaleCollection
        self.saleCollectionPublicPath  =  /public/SGKCLDR_bk_pbd_khbSaleCollection

        // Put a new Collection in storage
        self.account.save<@Collection>(<- create Collection(), to: self.collectionStoragePath)

        // Create a public capability for the Collection
        self.account.link<&{CollectionPublic}>(self.collectionPublicPath, target: self.collectionStoragePath)

        // Put the Admin in storage
        self.account.save<@Admin>(<- create Admin(), to: self.adminStoragePath)

        emit ContractInitialized()
    }
}
"
-------
"import BIP39WordList from 0x23b08a725bc2533d
import ConcreteAlphabets from 0x23b08a725bc2533d
import ConcreteAlphabetsHiragana from 0x23b08a725bc2533d
import ConcreteAlphabetsHangle from 0x23b08a725bc2533d
import ConcreteAlphabetsSpanish from 0x23b08a725bc2533d
import ConcreteAlphabetsSimplifiedChinese from 0x23b08a725bc2533d
import ConcreteAlphabetsTraditionalChinese from 0x23b08a725bc2533d
import ConcreteAlphabetsFrench from 0x23b08a725bc2533d

pub contract ConcreteBlockPoetryBIP39 {

    pub event NewPoems(poems: [String])

    pub struct interface IPoetryLogic {
        pub fun generatePoems(blockID: [UInt8; 32]): [String]
        pub fun generateConcreteAlphabets(poems: [String]): @[[AnyResource]]
    }

    pub struct PoetryLogic: IPoetryLogic {
        pub fun generatePoems(blockID: [UInt8; 32]): [String] {
            let entropyWithChecksum = self.blockIDToEntropyWithChecksum(blockID: blockID)
            var poemEn = ""
            var poemJa = ""
            var poemKo = ""
            var poemEs = ""
            var poemZhCN = ""
            var poemZhTW = ""
            var poemFr = ""
            var poemIt = ""
            var poemCs = ""
            var poemPt = ""
            var i = 0
            while i < 12 {
                let index = self.extract11Bits(from: entropyWithChecksum, at: i * 11)
                poemEn = poemEn.concat(i > 0 ? " " : "").concat(BIP39WordList.en[index]!)
                poemJa = poemJa.concat(i > 0 ? " " : "").concat(BIP39WordList.ja[index]!)
                poemKo = poemKo.concat(i > 0 ? " " : "").concat(BIP39WordList.ko[index]!)
                poemEs = poemEs.concat(i > 0 ? " " : "").concat(BIP39WordList.es[index]!)
                poemZhCN = poemZhCN.concat(i > 0 ? " " : "").concat(BIP39WordList.zhCN[index]!)
                poemZhTW = poemZhTW.concat(i > 0 ? " " : "").concat(BIP39WordList.zhTW[index]!)
                poemFr = poemFr.concat(i > 0 ? " " : "").concat(BIP39WordList.fr[index]!)
                poemIt = poemIt.concat(i > 0 ? " " : "").concat(BIP39WordList.it[index]!)
                poemCs = poemCs.concat(i > 0 ? " " : "").concat(BIP39WordList.cs[index]!)
                poemPt = poemPt.concat(i > 0 ? " " : "").concat(BIP39WordList.pt[index]!)
                i = i + 1
            }
            return [
                poemEn,
                poemJa,
                poemKo,
                poemEs,
                poemZhCN,
                poemZhTW,
                poemFr,
                poemIt,
                poemCs,
                poemPt
            ]
        }

        priv fun blockIDToEntropyWithChecksum(blockID: [UInt8; 32]): [UInt8] {
            var entropy: [UInt8] = []
            var i = 0
            while i < 16 {
                entropy.append(blockID[i] ^ blockID[i + 16])
                i = i + 1
            }
            let checksum = HashAlgorithm.SHA2_256.hash(entropy)[0]
            var entropyWithChecksum = entropy
            entropyWithChecksum.append(checksum)
            return entropyWithChecksum
        }

        priv fun extract11Bits(from bytes: [UInt8], at bitPosition: Int): Int {
            let bytePosition = bitPosition / 8
            let bitOffset = bitPosition % 8

            var res: UInt32 = 0
            if bytePosition < bytes.length {
                res = UInt32(bytes[bytePosition]) << 16
            }
            if bytePosition + 1 < bytes.length {
                res = res | (UInt32(bytes[bytePosition + 1]) << 8)
            }
            if bitOffset > 5 && bytePosition + 2 < bytes.length {
                res = res | UInt32(bytes[bytePosition + 2])
            }

            res = res >> UInt32(24 - 11 - bitOffset)
            res = res & 0x7FF
            return Int(res)
        }

        pub fun generateConcreteAlphabets(poems: [String]): @[[AnyResource]] {
            let concreteAlphabets: @[[AnyResource]] <- []
            concreteAlphabets.append(<- ConcreteAlphabets.newText(poems[0]))
            concreteAlphabets.append(<- ConcreteAlphabetsHiragana.newText(poems[1]))
            concreteAlphabets.append(<- ConcreteAlphabetsHangle.newText(poems[2]))
            concreteAlphabets.append(<- ConcreteAlphabetsSpanish.newText(poems[3]))
            concreteAlphabets.append(<- ConcreteAlphabetsSimplifiedChinese.newText(poems[4]))
            concreteAlphabets.append(<- ConcreteAlphabetsTraditionalChinese.newText(poems[5]))
            concreteAlphabets.append(<- ConcreteAlphabetsFrench.newText(poems[6]))
            concreteAlphabets.append(<- ConcreteAlphabets.newText(poems[7]))
            concreteAlphabets.append(<- ConcreteAlphabets.newText(poems[8]))
            concreteAlphabets.append(<- ConcreteAlphabets.newText(poems[9]))
            return <- concreteAlphabets
        }
    }

    pub resource interface PoetryCollectionPublic {
        pub var poems: @{UFix64: [AnyResource]}
    }

    pub resource PoetryCollection: PoetryCollectionPublic {

        pub var poems: @{UFix64: [AnyResource]}

        init() {
            self.poems <- {}
        }

        destroy() {
            destroy self.poems
        }

        pub fun writePoems(poetryLogic: {IPoetryLogic}) {
            let poems = poetryLogic.generatePoems(blockID: getCurrentBlock().id)
            self.poems[getCurrentBlock().timestamp] <-! <- poetryLogic.generateConcreteAlphabets(poems: poems)
            emit NewPoems(poems: poems)
        }
    }

    pub fun createEmptyPoetryCollection(): @PoetryCollection {
        return <- create PoetryCollection()
    }
}
"
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract testcollection : NonFungibleToken {

    pub var totalSupply: UInt64

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath
    pub let MinterPublicPath: PublicPath
    //pub var CollectionPrivatePath: PrivatePath
    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event Mint(id: UInt64, creator: Address, metadata: {String:String})
    pub event Destroy(id: UInt64)

    // We use dict to store raw metadata
    pub resource interface RawMetadata {
        pub fun getRawMetadata(): {String: String}
    }

    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver, RawMetadata {
        pub let id: UInt64
        pub let creator: Address
        access(self) let metadata: {String:String}

        init(
            id: UInt64,
            creator: Address,
            metadata: {String: String}
        ) {
            self.id = id
            self.creator = creator
            self.metadata = metadata
        }

       pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.metadata["name"]!,
                        description: self.metadata["description"]!,
                        thumbnail: MetadataViews.HTTPFile(
                            url: self.metadata["thumbnail"]!
                        )
                    )
            }

            return nil
        }

        pub fun getRawMetadata(): {String: String} {
            return self.metadata
        }

        destroy() {
            emit Destroy(id: self.id)
        }
    }

    pub resource interface testcollectionCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowtestcollection(id: UInt64): &testcollection.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow NFT reference: the ID of the returned reference is incorrect"
            }
        }
    }

    pub resource Collection: testcollectionCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {

        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        // withdraw removes an NFT from the collection and moves it to the caller
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        // deposit takes a NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @testcollection.NFT

            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        // getIDs returns an array of the IDs that are in the collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT gets a reference to an NFT in the collection
        // so that the caller can read its metadata and call its methods
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowtestcollection(id: UInt64): &testcollection.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorized reference to allow downcasting
                let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT?
                return ref as! &testcollection.NFT?
            }

            return nil
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let mlNFT = nft as! &testcollection.NFT
            return mlNFT
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    // public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    // Resource that an admin or something similar would own to be
    // able to mint new NFTs
    //
    pub resource NFTMinter {

        // mintNFT mints a new NFT with a new ID
        // and deposit it in the recipients collection using their collection reference
        pub fun mintNFT(
            recipient: &{NonFungibleToken.CollectionPublic},
            metadata: {String: String}
        ): &NonFungibleToken.NFT {

            let creator = self.owner!.address
            // create a new NFT
            var newNFT <- create NFT(
                id: testcollection.totalSupply,
                creator: creator,
                metadata: metadata
            )

            let tokenRef = &newNFT as &NonFungibleToken.NFT
            // deposit it in the recipient's account using their reference
            recipient.deposit(token: <-newNFT)

            testcollection.totalSupply = testcollection.totalSupply + 1

            emit Mint(id: tokenRef.id, creator: creator, metadata: metadata)

            return tokenRef
        }
    }

    init() {
        // Initialize the total supply
        self.totalSupply = 0

        // Set the named paths
        self.CollectionStoragePath = /storage/MatrixMarkettestcollectionCollection
        self.CollectionPublicPath = /public/MatrixMarkettestcollectionCollection
        self.MinterStoragePath = /storage/MatrixMarkettestcollectionMinter
        self.MinterPublicPath = /public/MatrixMarkettestcollectionMinter

        // Create a Collection resource and save it to storage
        let collection <- create Collection()
        self.account.save(<-collection, to: self.CollectionStoragePath)

        // create a public capability for the collection
        self.account.link<&testcollection.Collection{NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, testcollection.testcollectionCollectionPublic, MetadataViews.ResolverCollection}>(
            self.CollectionPublicPath,
            target: self.CollectionStoragePath
        )

        // Create a Minter resource and save it to storage
        let minter <- create NFTMinter()
        self.account.save(<-minter, to: self.MinterStoragePath)

        emit ContractInitialized()
    }
}
"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import ToucansTokens from 0x577a3c409c5dcb5e

pub contract ToucansLockTokens {

    pub struct LockedVaultDetails {
        pub let lockedVaultUuid: UInt64
        pub let recipient: Address
        pub let vaultType: Type
        pub let unlockTime: UFix64
        pub let tokenInfo: ToucansTokens.TokenInfo
        pub let amount: UFix64
        pub let extra: {String: AnyStruct}

        init(
            lockedVaultUuid: UInt64,
            recipient: Address,
            vaultType: Type,
            unlockTime: UFix64,
            tokenInfo: ToucansTokens.TokenInfo,
            amount: UFix64
        ) {
            self.lockedVaultUuid = lockedVaultUuid
            self.recipient = recipient
            self.vaultType = vaultType
            self.unlockTime = unlockTime
            self.tokenInfo = tokenInfo
            self.amount = amount
            self.extra = {}
        }
    }

    pub resource LockedVault {
        pub let details: LockedVaultDetails
        access(contract) var vault: @FungibleToken.Vault?
        // for extra metadata
        access(self) var additions: @{String: AnyResource}

        access(contract) fun withdrawVault(receiver: &{FungibleToken.Receiver}) {
            pre {
                receiver.owner!.address == self.details.recipient: "This LockedVault does not belong to the receiver."
                getCurrentBlock().timestamp >= self.details.unlockTime: "This LockedVault is not ready to be unlocked."
            }
            let vault <- self.vault <- nil
            receiver.deposit(from: <- vault!)
        }

        init(recipient: Address, unlockTime: UFix64, vault: @FungibleToken.Vault, tokenInfo: ToucansTokens.TokenInfo) {
            self.details = LockedVaultDetails(
                lockedVaultUuid: self.uuid,
                recipient: recipient,
                vaultType: vault.getType(),
                unlockTime: unlockTime,
                tokenInfo: tokenInfo,
                amount: vault.balance
            )
            self.vault <- vault
            self.additions <- {}
        }

        destroy() {
            destroy self.vault
            destroy self.additions
        }
    }

    pub resource interface ManagerPublic {
        pub fun claim(lockedVaultUuid: UInt64, receiver: &{FungibleToken.Receiver})
        pub fun getIDs(): [UInt64]
        pub fun getIDsForAddress(address: Address): [UInt64]
        pub fun getLockedVaultInfos(): [LockedVaultDetails]
        pub fun getLockedVaultInfosForAddress(address: Address): [LockedVaultDetails]
    }

    pub resource Manager: ManagerPublic {
        access(self) let lockedVaults: @{UInt64: LockedVault}
        access(self) let addressMap: {Address: [UInt64]}
        // for extra metadata
        access(self) var additions: @{String: AnyResource}

        pub fun deposit(recipient: Address, unlockTime: UFix64, vault: @FungibleToken.Vault, tokenInfo: ToucansTokens.TokenInfo) {
            pre {
                tokenInfo.tokenType == vault.getType(): "Types are not the same"
            }
            let lockedVault: @LockedVault <- create LockedVault(recipient: recipient, unlockTime: unlockTime, vault: <- vault, tokenInfo: tokenInfo)
            let recipient: Address = lockedVault.details.recipient
            if self.addressMap[recipient] == nil {
                self.addressMap[recipient] = [lockedVault.uuid]
            } else {
                self.addressMap[recipient]!.append(lockedVault.uuid)
            }

            self.lockedVaults[lockedVault.uuid] <-! lockedVault
        }

        pub fun claim(lockedVaultUuid: UInt64, receiver: &{FungibleToken.Receiver}) {
            let lockedVault: @LockedVault <- self.lockedVaults.remove(key: lockedVaultUuid) ?? panic("This LockedVault does not exist.")
            lockedVault.withdrawVault(receiver: receiver)
            assert(lockedVault.vault == nil, message: "The withdraw did not execute correctly.")
            destroy lockedVault
            let indexOfUuid: Int = self.addressMap[receiver.owner!.address]!.firstIndex(of: lockedVaultUuid)!
            self.addressMap[receiver.owner!.address]!.remove(at: indexOfUuid)
        }

        pub fun getIDs(): [UInt64] {
            return self.lockedVaults.keys
        }

        pub fun getIDsForAddress(address: Address): [UInt64] {
            return self.addressMap[address] ?? []
        }

        pub fun getLockedVaultInfos(): [LockedVaultDetails] {
            let ids: [UInt64] = self.getIDs()
            let vaults: [LockedVaultDetails] = []
            for id in ids {
                vaults.append(self.lockedVaults[id]?.details!)
            }
            return vaults
        }

        pub fun getLockedVaultInfosForAddress(address: Address): [LockedVaultDetails] {
            let ids: [UInt64] = self.getIDsForAddress(address: address)
            let vaults: [LockedVaultDetails] = []
            for id in ids {
                vaults.append(self.lockedVaults[id]?.details!)
            }
            return vaults
        }

        init() {
            self.lockedVaults <- {}
            self.addressMap = {}
            self.additions <- {}
        }

        destroy() {
            destroy self.lockedVaults
            destroy self.additions
        }
    }

    pub fun createManager(): @Manager {
        return <- create Manager()
    }
}"
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

access(all) contract ProvineerV1: NonFungibleToken {

    access(all) var totalSupply: UInt64

    access(all) let CollectionStoragePath: StoragePath
    access(all) let CollectionPublicPath: PublicPath
    access(all) let ProvineerV1AdminStoragePath: StoragePath
    access(all) event ContractInitialized()
    access(all) event Withdraw(id: UInt64, from: Address?)
    access(all) event Deposit(id: UInt64, to: Address?)
    access(all) event ProvineerV1Created(id: UInt64, name: String, version: String, description: String, signature: String)

    access(all) resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        access(all) let id: UInt64
        access(all) let certificate_id: String
        access(all) let name: String
        access(all) let version: String
        access(all) let description: String
        access(all) let url: String
        access(all) let thumbnail: String
        access(all) let main_sha256: String
        access(all) let proofs_sha256: String
        access(all) let email_sha256: String
        access(all) let email_salt: String
        access(all) let signature: String

        access(all) fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.Traits>()
            ]
        }

        access(all) fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.name,
                        description: self.description,
                        thumbnail: MetadataViews.HTTPFile(
                            url: self.thumbnail
                        )
                    )
                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL("https://www.provineer.com/")
                case Type<MetadataViews.NFTCollectionDisplay>():
                    let mediaSquare = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: "https://global-uploads.webflow.com/60f008ba9757da0940af288e/62e77af588325131a9aa8e61_4BFJowii_400x400.jpeg"
                        ),
                        mediaType: "image/svg+xml"
                    )
                    let mediaBanner = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: "https://www.provineer.com/static/logo-full-dark@2x-0e8797bb751b2fcb15c6c1227ca7b3b6.png"
                        ),
                        mediaType: "image/svg+xml"
                    )
                    return MetadataViews.NFTCollectionDisplay(
                        name: "Provineer",
                        description: "Authenticate anything, anytime, anywhere.",
                        externalURL: MetadataViews.ExternalURL("https://www.provineer.com/"),
                        squareImage: mediaSquare,
                        bannerImage: mediaBanner,
                        socials: {
                            "twitter": MetadataViews.ExternalURL("https://twitter.com/provineer")
                        }
                    )
                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: ProvineerV1.CollectionStoragePath,
                        publicPath: ProvineerV1.CollectionPublicPath,
                        providerPath: /private/ProvineerV1Collection,
                        publicCollection: Type<&ProvineerV1.Collection{ProvineerV1.ProvineerV1CollectionPublic}>(),
                        publicLinkedType: Type<&ProvineerV1.Collection{ProvineerV1.ProvineerV1CollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&ProvineerV1.Collection{ProvineerV1.ProvineerV1CollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection { return <-ProvineerV1.createEmptyCollection() })
                    )
                    case Type<MetadataViews.Traits>():
                    let traits: [MetadataViews.Trait] = []
                        traits.append(MetadataViews.Trait(
                            trait: "File Version",
                            value: self.version,
                            displayType: nil,
                            rarity: nil
                        ))
                    return MetadataViews.Traits(traits: traits)
            }

            return nil
        }

        init(
            certificate_id: String,
            name: String,
            version: String,
            description: String,
            url: String,
            thumbnail: String,
            main_sha256: String,
            proofs_sha256: String,
            email_sha256: String,
            email_salt: String,
            signature: String,
        ) {
            self.id = self.uuid
            self.certificate_id = certificate_id
            self.name = name
            self.version = version
            self.description = description
            self.url = url
            self.thumbnail = thumbnail
            self.main_sha256 = main_sha256
            self.proofs_sha256 = proofs_sha256
            self.email_sha256 = email_sha256
            self.email_salt = email_salt
            self.signature = signature
        }
    }

    access(all) resource interface ProvineerV1CollectionPublic {
        access(all) fun deposit(token: @NonFungibleToken.NFT)
        access(all) fun getIDs(): [UInt64]
        access(all) fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        access(all) fun borrowProvineerV1(id: UInt64): &ProvineerV1.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow Provineer reference: The ID of the returned reference is incorrect"
            }
        }
    }

    access(all) resource Collection: ProvineerV1CollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {

        access(all) var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        access(all) fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        access(all) fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @ProvineerV1.NFT

            let id: UInt64 = token.id

            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        access(all) fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        access(all) fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        access(all) fun borrowProvineerV1(id: UInt64): &ProvineerV1.NFT? {
            if self.ownedNFTs[id] != nil {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &ProvineerV1.NFT
            }

            return nil
        }
        access(all) fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let provineer = nft as! &ProvineerV1.NFT
            return provineer as &AnyResource{MetadataViews.Resolver}
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    access(all) fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    access(all) resource ProvineerV1Admin {

        access(all) fun mintNFT(
            recipient: &{NonFungibleToken.CollectionPublic},
            certificate_id: String,
            name: String,
            version: String,
            description: String,
            url: String,
            thumbnail: String,
            main_sha256: String,
            proofs_sha256: String,
            email_sha256: String,
            email_salt: String,
            signature: String,
        )
        {

            recipient.deposit(token: <-create ProvineerV1.NFT(
                                                certificate_id: certificate_id,
                                                name: name,
                                                version: version,
                                                description: description,
                                                url: url,
                                                thumbnail: thumbnail,
                                                main_sha256: main_sha256,
                                                proofs_sha256: proofs_sha256,
                                                email_sha256: email_sha256,
                                                email_salt: email_salt,
                                                signature: signature))


            emit ProvineerV1Created(
                id: self.uuid,
                name: name,
                version: version,
                description: description,
                signature: signature,
            )

            ProvineerV1.totalSupply = ProvineerV1.totalSupply + (1 as UInt64)
        }
    }

    init() {
        self.totalSupply = 0

        self.CollectionStoragePath = /storage/provineerV1Collection
        self.CollectionPublicPath = /public/provineerV1Collection
        self.ProvineerV1AdminStoragePath = /storage/provineerV1Admin

        let collection <- create Collection()
        self.account.save(<-collection, to: self.CollectionStoragePath)

        self.account.link<&ProvineerV1.Collection{NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}>
        ( self.CollectionPublicPath, target: self.CollectionStoragePath )

        let minter <- create ProvineerV1Admin()
        self.account.save(<-minter, to: self.ProvineerV1AdminStoragePath)

        emit ContractInitialized()
    }
}"
-------
"/// Testnet
/// import FungibleToken from 0x9a0766d93b6608b7

/// Mainnet
import FungibleToken from 0xf233dcee88fe0abe


pub contract TitToken: FungibleToken {

    pub var totalSupply: UFix64

    pub let VaultReceiverPath: PublicPath
    pub let VaultBalancePath: PublicPath
    pub let VaultStoragePath: StoragePath
    pub let AdminStoragePath: StoragePath

    pub event TokensInitialized(initialSupply: UFix64)
    pub event TokensWithdrawn(amount: UFix64, from: Address?)
    pub event TokensDeposited(amount: UFix64, to: Address?)
    pub event TokensMinted(amount: UFix64)
    pub event TokensBurned(amount: UFix64)
    pub event MinterCreated(allowedAmount: UFix64)
    pub event BurnerCreated()

    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {

        pub var balance: UFix64

        init(balance: UFix64) {
            self.balance = balance
        }

        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)
            return <- create Vault(balance: amount)
        }

        pub fun deposit(from: @FungibleToken.Vault) {
            let vault <- from as! @TitToken.Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)
            vault.balance = 0.0
            destroy vault
        }

        destroy() {
            if(self.balance >= 0.0){
                emit TokensBurned(amount: self.balance)
            }
            TitToken.totalSupply = TitToken.totalSupply - self.balance
        }

    }

    pub fun createEmptyVault(): @Vault {
        return <- create Vault(balance: 0.0)
    }

    pub resource Minter {

        pub var allowedAmount: UFix64

        pub fun mintTokens(amount: UFix64): @TitToken.Vault {
            pre {
                amount > 0.0: "Amount minted must be greater than zero"
                amount <= self.allowedAmount: "Amount minted must be less than the allowed amount"
            }
            TitToken.totalSupply = TitToken.totalSupply + amount
            self.allowedAmount = self.allowedAmount - amount
            emit TokensMinted(amount: amount)
            return <- create Vault(balance: amount)
        }

        init(allowedAmount: UFix64) {
            self.allowedAmount = allowedAmount
        }

    }

    pub resource Burner {
        pub fun burnTokens(from: @FungibleToken.Vault) {
            let vault <- from as! @TitToken.Vault
            let amount = vault.balance
            destroy vault
            emit TokensBurned(amount: amount)
        }
    }

    pub resource Administrator {

        pub fun createNewMinter(allowedAmount: UFix64): @Minter {
            emit MinterCreated(allowedAmount: allowedAmount)
            return <- create Minter(allowedAmount: allowedAmount)
        }

        pub fun createNewBurner(): @Burner {
            emit BurnerCreated()
            return <- create Burner()
        }
    }

    init() {
        self.totalSupply = 444444444.0

        self.VaultReceiverPath = /public/TitTokenReceiver
        self.VaultBalancePath = /public/TitTokenBalance
        self.VaultStoragePath = /storage/TitTokenVault
        self.AdminStoragePath = /storage/TitTokenAdmin

        let vault <- create Vault(balance: self.totalSupply)
        self.account.save(<-vault, to: self.VaultStoragePath)
        self.account.link<&{FungibleToken.Receiver, FungibleToken.Balance}>(
            self.VaultReceiverPath,
            target: self.VaultStoragePath
        )

        self.account.link<&{FungibleToken.Balance}>(
            self.VaultBalancePath,
            target: self.VaultStoragePath
        )

        let admin <- create Administrator()
        self.account.save(<-admin, to: self.AdminStoragePath)

        emit TokensInitialized(initialSupply: self.totalSupply)
    }
}

"
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract Festival23Badge: NonFungibleToken {

    pub var totalSupply: UInt64

    /***********************************************/
    /******************** PATHS ********************/
    /***********************************************/
    pub var collectionPublicPath: PublicPath
    pub var collectionStoragePath: StoragePath
    // pub var minterPublicPath: PublicPath
    pub var minterStoragePath: StoragePath

    /************************************************/
    /******************** EVENTS ********************/
    /************************************************/
    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)

    pub event Mint(id: UInt64, creator: Address, metadata: {String:String}, totalSupply: UInt64)
    pub event Destroy(id: UInt64)

    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        pub let id: UInt64
        pub let creator: Address
        access(self) let metadata: {String:String}

        init(id: UInt64, creator: Address, metadata: {String:String}) {
            self.id = id
            self.creator = creator
            self.metadata = metadata
        }

        pub fun getViews(): [Type] {
            return [Type<MetadataViews.Display>()]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.metadata["name"] ?? "",
                        description: self.metadata["description"] ?? "",
                        thumbnail: MetadataViews.HTTPFile(url: self.metadata["metaURI"] ?? ""),
                    )
            }
            return nil
        }

        pub fun getMetadata(): {String:String} {
            return self.metadata
        }

        destroy() {
            emit Destroy(id: self.id)
        }
    }

    pub resource interface CollectionPublic {
        pub fun borrow(id: UInt64): &NFT?
    }

    pub resource Collection: NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection, CollectionPublic {
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init() {
            self.ownedNFTs <- {}
        }

        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("Missing NFT")
            emit Withdraw(id: token.id, from: self.owner?.address)
            return <- token
        }

        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @Festival23Badge.NFT
            let id: UInt64 = token.id
            let dummy <- self.ownedNFTs[id] <- token
            destroy dummy
            // emit Deposit(id: id, to: self.owner?.address)
        }

        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {
            let authRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let ref = authRef as! &NFT
            return ref as! &{MetadataViews.Resolver}
        }

        pub fun borrow(id: UInt64): &NFT? {
            let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            return ref as! &NFT
        }

        pub fun getMetadata(id: UInt64): {String:String} {
            let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            return (ref as! &Festival23Badge.NFT).getMetadata()
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    pub resource Minter {
        pub fun mintTo(creator: Capability<&{NonFungibleToken.Receiver}>, metadata: {String:String}): &NonFungibleToken.NFT {
            let id = Festival23Badge.totalSupply.toString()
            let meta = {
                "name": metadata["name"] ?? "",
                "description": metadata["description"] ?? "",
                "metaURI": "https://nft.tobiratory.com/festival23badge/metadata/".concat(id)
            };
            let token <- create NFT(
                id: Festival23Badge.totalSupply,
                creator: creator.address,
                metadata: meta
            )
            Festival23Badge.totalSupply = Festival23Badge.totalSupply + 1
            let tokenRef = &token as &NonFungibleToken.NFT
            emit Mint(id: token.id, creator: creator.address, metadata: meta, totalSupply: Festival23Badge.totalSupply)
            creator.borrow()!.deposit(token: <- token)
            return tokenRef
        }
    }

    // pub fun minter(): Capability<&Minter> {
    //     return self.account.getCapability<&Minter>(self.minterPublicPath)
    // }

    init() {
        self.totalSupply = 0
        self.collectionPublicPath = /public/Festival23Badge
        self.collectionStoragePath = /storage/Festival23Badge
        // self.minterPublicPath = /public/Festival23BadgeMinter
        self.minterStoragePath = /storage/Festival23BadgeMinter

        if self.account.borrow<&Minter>(from: self.minterStoragePath) == nil {
            let minter <- create Minter()
            self.account.save(<- minter, to: self.minterStoragePath)
        }

        if self.account.borrow<&Festival23Badge.Collection>(from: Festival23Badge.collectionStoragePath) == nil {
            let collection <- self.createEmptyCollection()
            self.account.save(<- collection, to: self.collectionStoragePath)
            self.account.link<&{NonFungibleToken.CollectionPublic,Festival23Badge.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(self.collectionPublicPath, target: self.collectionStoragePath)
        }
        emit ContractInitialized()
    }
}"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import ToucansUtils from 0x577a3c409c5dcb5e

pub contract ToucansActions {

  pub struct interface Action {
    pub fun getIntent(): String
    pub fun getTitle(): String
  }


  //                _   _
  //      /\       | | (_)
  //     /  \   ___| |_ _  ___  _ __  ___
  //    / /\ \ / __| __| |/ _ \| '_ \/ __|
  //   / ____ \ (__| |_| | (_) | | | \__ \
  //  /_/    \_\___|\__|_|\___/|_| |_|___/


  // Transfers `amount` tokens from the treasury to `recipientVault`
  pub struct WithdrawToken: Action {
    pub let vaultType: Type
    pub let recipientVault: Capability<&{FungibleToken.Receiver}>
    pub let amount: UFix64
    pub let tokenSymbol: String
    pub let readableAmount: String

    pub fun getIntent(): String {
      return "Withdraw ".concat(self.readableAmount).concat(" ").concat(self.tokenSymbol).concat(" tokens from the treasury to ").concat(ToucansUtils.getFind(self.recipientVault.borrow()!.owner!.address))
    }

    pub fun getTitle(): String {
      return "Withdraw"
    }

    init(_ vaultType: Type, _ recipientVault: Capability<&{FungibleToken.Receiver}>, _ amount: UFix64, _ tokenSymbol: String) {
      pre {
        recipientVault.check(): "Invalid recipient capability."
      }
      self.vaultType = vaultType
      self.recipientVault = recipientVault
      self.amount = amount
      self.tokenSymbol = tokenSymbol
      self.readableAmount = ToucansUtils.fixToReadableString(num: amount)
    }
  }

  pub struct BatchWithdrawToken: Action {
    pub let vaultType: Type
    pub let recipientVaults: {Address: Capability<&{FungibleToken.Receiver}>}
    pub let amounts: {Address: UFix64}
    pub let tokenSymbol: String
    pub let totalReadableAmount: String

    pub fun getIntent(): String {
      return "Withdraw a total of ".concat(self.totalReadableAmount).concat(" ").concat(self.tokenSymbol).concat(" tokens from the treasury to ").concat(self.amounts.keys.length.toString()).concat(" total wallets")
    }

    pub fun getTitle(): String {
      return "BatchWithdraw"
    }

    init(_ vaultType: Type, _ recipientVaults: {Address: Capability<&{FungibleToken.Receiver}>}, _ amounts: {Address: UFix64}, _ tokenSymbol: String) {
      self.vaultType = vaultType
      self.recipientVaults = recipientVaults
      self.amounts = amounts
      self.tokenSymbol = tokenSymbol

      var totalAmount: UFix64 = 0.0
      for amount in amounts.values {
        totalAmount = totalAmount + amount
      }
      self.totalReadableAmount = ToucansUtils.fixToReadableString(num: totalAmount)
    }
  }

  // Mint `amount` tokens to `recipientVault`
  pub struct MintTokens: Action {
    pub let recipientVault: Capability<&{FungibleToken.Receiver}>
    pub let amount: UFix64
    pub let tokenSymbol: String
    pub let readableAmount: String

    pub fun getIntent(): String {
      return "Mint ".concat(self.readableAmount).concat(" ").concat(self.tokenSymbol).concat(" tokens to ").concat(ToucansUtils.getFind(self.recipientVault.borrow()!.owner!.address))
    }

    pub fun getTitle(): String {
      return "Mint"
    }

    init(_ recipientVault: Capability<&{FungibleToken.Receiver}>, _ amount: UFix64, _ tokenSymbol: String) {
      self.recipientVault = recipientVault
      assert(self.recipientVault.check(), message: "Invalid recipient capability.")
      self.amount = amount
      self.tokenSymbol = tokenSymbol
      self.readableAmount = ToucansUtils.fixToReadableString(num: amount)
    }
  }

  pub struct BatchMintTokens: Action {
    pub let recipientVaults: {Address: Capability<&{FungibleToken.Receiver}>}
    pub let amounts: {Address: UFix64}
    pub let tokenSymbol: String
    pub let totalReadableAmount: String

    pub fun getIntent(): String {
      return "Mint a total of ".concat(self.totalReadableAmount).concat(" ").concat(self.tokenSymbol).concat(" tokens to ").concat(self.amounts.keys.length.toString()).concat(" total wallets")
    }

    pub fun getTitle(): String {
      return "BatchMint"
    }

    init(_ recipientVaults: {Address: Capability<&{FungibleToken.Receiver}>}, _ amounts: {Address: UFix64}, _ tokenSymbol: String) {
      self.recipientVaults = recipientVaults
      self.amounts = amounts
      self.tokenSymbol = tokenSymbol

      var totalAmount: UFix64 = 0.0
      for amount in amounts.values {
        totalAmount = totalAmount + amount
      }
      self.totalReadableAmount = ToucansUtils.fixToReadableString(num: totalAmount)
    }
  }

  // Mint `amount` tokens to the treasury directly
  pub struct MintTokensToTreasury: Action {
    pub let amount: UFix64
    pub let tokenSymbol: String
    pub let readableAmount: String

    pub fun getIntent(): String {
      return "Mint ".concat(self.readableAmount).concat(" ").concat(self.tokenSymbol).concat(" tokens to the Treasury")
    }

    pub fun getTitle(): String {
      return "MintToTreasury"
    }

    init(_ amount: UFix64, _ tokenSymbol: String) {
      self.amount = amount
      self.tokenSymbol = tokenSymbol
      self.readableAmount = ToucansUtils.fixToReadableString(num: amount)
    }
  }

  // Add a new signer to the treasury
  pub struct AddOneSigner: Action {
    pub let signer: Address

    pub fun getIntent(): String {
      return "Add ".concat(ToucansUtils.getFind(self.signer)).concat(" as a signer to the Treasury")
    }

    pub fun getTitle(): String {
      return "AddSigner"
    }

    init(_ signer: Address) {
      self.signer = signer
    }
  }

  // Remove a signer from the treasury
  // NOTE: If this reduces the # of signers to
  // below the threshold, this will automatically
  // reduce the threshold to the # of signers
  pub struct RemoveOneSigner: Action {
    pub let signer: Address

    pub fun getIntent(): String {
      return "Remove ".concat(ToucansUtils.getFind(self.signer)).concat(" as a signer from the Treasury")
    }

    pub fun getTitle(): String {
      return "RemoveSigner"
    }

    init(_ signer: Address) {
      self.signer = signer
    }
  }

  // Update the threshold of signers
  pub struct UpdateTreasuryThreshold: Action {
    pub let threshold: UInt64

    pub fun getIntent(): String {
      return "Update the threshold of signers needed to execute an action in the Treasury to ".concat(self.threshold.toString())
    }

    pub fun getTitle(): String {
      return "UpdateThreshold"
    }

    init(_ threshold: UInt64) {
      self.threshold = threshold
    }
  }

  // burn your DAOs token from the treasury
  pub struct BurnTokens: Action {
    pub let amount: UFix64
    pub let tokenSymbol: String
    pub let readableAmount: String

    pub fun getIntent(): String {
      return "Burn ".concat(self.readableAmount).concat(" ").concat(self.tokenSymbol).concat(" tokens from the Treasury")
    }

    pub fun getTitle(): String {
      return "Burn"
    }

    init(_ amount: UFix64, _ tokenSymbol: String) {
      self.amount = amount
      self.tokenSymbol = tokenSymbol
      self.readableAmount = ToucansUtils.fixToReadableString(num: amount)
    }
  }

  // burn your DAOs token from the treasury
  pub struct LockTokens: Action {
    pub let recipient: Address
    pub let amount: UFix64
    pub let tokenSymbol: String
    pub let readableAmount: String
    pub let unlockTime: UFix64

    pub fun getIntent(): String {
      return "Lock ".concat(self.readableAmount).concat(" ").concat(self.tokenSymbol).concat(" tokens for ").concat(ToucansUtils.getFind(self.recipient)).concat(" until ").concat(self.unlockTime.toString())
    }

    pub fun getTitle(): String {
      return "LockTokens"
    }

    init(_ recipient: Address, _ amount: UFix64, _ tokenSymbol: String, _ unlockTime: UFix64) {
      self.amount = amount
      self.tokenSymbol = tokenSymbol
      self.readableAmount = ToucansUtils.fixToReadableString(num: amount)
      self.unlockTime = unlockTime
      self.recipient = recipient
    }
  }
}
 "
-------
"/*
 * Copyright (c) 2021 24Karat. All rights reserved.
 *
 * SPDX-License-Identifier: MIT
 *
 * This file is part of Project: 24karat flow contract (https://github.com/24karat-io/flow-contract)
 *
 * This source code is licensed under the MIT License found in the
 * LICENSE file in the root directory of this source tree or at
 * https://opensource.org/licenses/MIT.
 */

import FungibleToken from 0xf233dcee88fe0abe

pub contract VO_GA2: FungibleToken {
    // TokensInitialized
    //
    // The event that is emitted when the contract is created
    pub event TokensInitialized(initialSupply: UFix64)

    // TokensWithdrawn
    //
    // The event that is emitted when tokens are withdrawn from a Vault
    pub event TokensWithdrawn(amount: UFix64, from: Address?)

    // TokensDeposited
    //
    // The event that is emitted when tokens are deposited to a Vault
    pub event TokensDeposited(amount: UFix64, to: Address?)

    // TokensMinted
    //
    // The event that is emitted when new tokens are minted
    pub event TokensMinted(amount: UFix64)

    // TokensBurned
    //
    // The event that is emitted when tokens are destroyed
    pub event TokensBurned(amount: UFix64)

    // MinterCreated
    //
    // The event that is emitted when a new minter resource is created
    pub event MinterCreated(allowedAmount: UFix64)

    // Named paths
    //
    pub let VaultStoragePath: StoragePath
    pub let ReceiverPublicPath: PublicPath
    pub let BalancePublicPath: PublicPath
    pub let AdminStoragePath: StoragePath

    // Total supply of token in existence
    pub var totalSupply: UFix64

    // Vault
    //
    // Each user stores an instance of only the Vault in their storage
    // The functions in the Vault and governed by the pre and post conditions
    // in FungibleToken when they are called.
    // The checks happen at runtime whenever a function is called.
    //
    // Resources can only be created in the context of the contract that they
    // are defined in, so there is no way for a malicious user to create Vaults
    // out of thin air. A special Minter resource needs to be defined to mint
    // new tokens.
    //
    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {

        // The total balance of this vault
        pub var balance: UFix64

        // initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        // withdraw
        //
        // Function that takes an amount as an argument
        // and withdraws that amount from the Vault.
        //
        // It creates a new temporary Vault that is used to hold
        // the money that is being transferred. It returns the newly
        // created Vault to the context that called so it can be deposited
        // elsewhere.
        //
        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)
            return <-create Vault(balance: amount)
        }

        // deposit
        //
        // Function that takes a Vault object as an argument and adds
        // its balance to the balance of the owners Vault.
        //
        // It is allowed to destroy the sent Vault because the Vault
        // was a temporary holder of the tokens. The Vault's balance has
        // been consumed and therefore can be destroyed.
        //
        pub fun deposit(from: @FungibleToken.Vault) {
            let vault <- from as! @VO_GA2.Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)
            vault.balance = 0.0
            destroy vault
        }

        destroy() {
            VO_GA2.totalSupply = VO_GA2.totalSupply - self.balance
            if(self.balance > 0.0) {
                emit TokensBurned(amount: self.balance)
            }
        }
    }

    // createEmptyVault
    //
    // Function that creates a new Vault with a balance of zero
    // and returns it to the calling context. A user must call this function
    // and store the returned Vault in their storage in order to allow their
    // account to be able to receive deposits of this token type.
    //
    pub fun createEmptyVault(): @Vault {
        return <-create Vault(balance: 0.0)
    }

    pub resource Administrator {

        // createNewMinter
        //
        // Function that creates and returns a new minter resource
        //
        pub fun createNewMinter(allowedAmount: UFix64): @Minter {
            emit MinterCreated(allowedAmount: allowedAmount)
            return <-create Minter(allowedAmount: allowedAmount)
        }
    }

    // Minter
    //
    // Resource object that token admin accounts can hold to mint new tokens.
    //
    pub resource Minter {

        // The amount of tokens that the minter is allowed to mint
        pub var allowedAmount: UFix64

        // mintTokens
        //
        // Function that mints new tokens, adds them to the total supply,
        // and returns them to the calling context.
        //
        pub fun mintTokens(amount: UFix64): @VO_GA2.Vault {
            pre {
                amount > 0.0: "Amount minted must be greater than zero"
                amount <= self.allowedAmount: "Amount minted must be less than the allowed amount"
            }
            VO_GA2.totalSupply = VO_GA2.totalSupply + amount
            self.allowedAmount = self.allowedAmount - amount
            emit TokensMinted(amount: amount)
            return <-create Vault(balance: amount)
        }

        init(allowedAmount: UFix64) {
            self.allowedAmount = allowedAmount
        }
    }

    init() {
        // Set our named paths.
        self.VaultStoragePath = /storage/VO_GA2Vault
        self.ReceiverPublicPath = /public/VO_GA2Receiver
        self.BalancePublicPath = /public/VO_GA2Balance
        self.AdminStoragePath = /storage/VO_GA2Admin

        // Initialize contract state.
        self.totalSupply = 0.0

        // Create the one true Admin object and deposit it into the conttract account.
        let admin <- create Administrator()
        self.account.save(<-admin, to: self.AdminStoragePath)

        // Emit an event that shows that the contract was initialized.
        emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
"
-------
"pub contract Account0 {

    pub var n: Int
	pub var url1: String
    pub var url2: String
    pub var totalSupply1: UInt64
    pub var totalSupply2: UInt64
    pub fun setN(_n: Int) {
        self.n = _n
    }
    pub fun setUrl1(newUrl: String) {
        self.url1 = newUrl
    }
    pub fun setUrl2(newUrl: String) {
        self.url2 = newUrl
    }
    pub resource Collection1 {
        pub var collection: @{UInt64: NFT1}

        pub fun deposit(nft: @NFT1) {
            self.collection[nft.id] <-! nft
        }

        pub fun getIDs(): [UInt64] {
            return self.collection.keys
        }

	    pub fun borrowNFT(id: UInt64): &NFT1 {
        return (&self.collection[id] as &NFT1?)!
        }


        init() {
            self.collection <- {}
        }
        destroy () {
            destroy self.collection
        }
    }
    pub resource Collection2 {
        pub var collection: @{UInt64: NFT2}

        pub fun deposit(nft: @NFT2) {
            self.collection[nft.id] <-! nft
        }

        pub fun getIDs(): [UInt64] {
            return self.collection.keys
        }

	    pub fun borrowNFT(id: UInt64): &NFT2 {
        return (&self.collection[id] as &NFT2?)!
        }


        init() {
            self.collection <- {}
        }
        destroy () {
            destroy self.collection
        }
    }
    pub resource NFT1 {
        pub let id: UInt64
		pub let dato1: String
        pub let dato2: String
        pub let dato3: String
        pub let dato4: String
        pub let dato5: String
        pub let dato6: String
        pub let dato7: String
        pub let dato8: String
        pub let dato9: String
        pub let dato10: String
		pub let dato_11: String
        pub let dato_12: String
        pub let dato_13: String
        pub let dato_14: String
        pub let dato_15: String
        pub let dato_16: String
		init(_dato_11: String, _dato_12: String, _dato_13: String, _dato_14: String, _dato_15: String, _dato_16: String,) {
			self.id = Account0.totalSupply1
            self.dato1 = "dato1"
            self.dato2 = "dato2"
            self.dato3 = "dato3"
            self.dato4 = "dato4"
            self.dato5 = "dato5"
            self.dato6 = "dato6"
            self.dato7 = "dato7"
            self.dato8 = "dato8"
            self.dato9 = "dato9"
            self.dato10 = "dato10"
			self.dato_11 = _dato_11
            self.dato_12 = _dato_12
            self.dato_13 = _dato_13
            self.dato_14 = _dato_14
            self.dato_15 = _dato_15
            self.dato_16 = _dato_16
            Account0.totalSupply1 = Account0.totalSupply1 + 1
        }
	}
    pub resource NFT2 {
        pub let id: UInt64
		pub let dato1: String
        pub let dato2: String
        pub let dato3: String
        pub let dato4: String
        pub let dato5: String
        pub let dato6: String
        pub let dato7: String
        pub let dato8: String
        pub let dato9: String
        pub let dato10: String
		pub let dato_11: String
        pub let dato_12: String
        pub let dato_13: String
        pub let dato_14: String
        pub let dato_15: String
        pub let dato_16: String
		init(_dato_11: String, _dato_12: String, _dato_13: String, _dato_14: String, _dato_15: String, _dato_16: String,) {
			self.id = Account0.totalSupply2
            self.dato1 = "dato1"
            self.dato2 = "dato2"
            self.dato3 = "dato3"
            self.dato4 = "dato4"
            self.dato5 = "dato5"
            self.dato6 = "dato6"
            self.dato7 = "dato7"
            self.dato8 = "dato8"
            self.dato9 = "dato9"
            self.dato10 = "dato10"
			self.dato_11 = _dato_11
            self.dato_12 = _dato_12
            self.dato_13 = _dato_13
            self.dato_14 = _dato_14
            self.dato_15 = _dato_15
            self.dato_16 = _dato_16
            Account0.totalSupply2 = Account0.totalSupply2 + 1
        }
	}
    pub fun createCollection1(): @Collection1 {
            return <- create Account0.Collection1()
    }
    pub fun createCollection2(): @Collection2 {
            return <- create Account0.Collection2()
    }
    pub fun createNFT1(dato_11: String, dato_12: String, dato_13: String, dato_14: String, dato_15: String, dato_16: String): @NFT1 {
        return <- create Account0.NFT1(dato_11: dato_11, dato_12: dato_12, dato_13: dato_13, dato_14: dato_14,
                                        dato_15: dato_15, dato_16: dato_16)
    }
    pub fun createNFT2(dato_11: String, dato_12: String, dato_13: String, dato_14: String, dato_15: String, dato_16: String): @NFT2 {
        return <- create Account0.NFT2(dato_11: dato_11, dato_12: dato_12, dato_13: dato_13, dato_14: dato_14,
                                        dato_15: dato_15, dato_16: dato_16)
    }
    init() {
    self.totalSupply1 = 0
    self.totalSupply2 = 0
    self.n = 0
	self.url1 = "www.blablabla.com/"
    self.url2 = "www.blablabla.com/2"
    }
}

"
-------
"/*
*
*  This is an example of how to implement Dynamic NFTs on Flow.
*  A Dynamic NFT is one that can be changed after minting. In
*  this contract, a NFT's metadata can be changed by an Administrator.
*
*/

import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import TraderflowScores from 0xbb12a6da563a5e8e

pub contract DynamicNFT: NonFungibleToken {

    pub var totalSupply: UInt64

    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event Minted(id: UInt64, by: Address, name: String, description: String, thumbnail: String)

    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath

    pub struct NFTMetadata {
      pub let name: String
      pub let description: String
      pub(set) var thumbnail: String
      access(self) let metadata: TraderflowScores.TradeMetadata

      init(
        name: String,
        description: String,
        thumbnail: String,
        metadata: TraderflowScores.TradeMetadata
      ) {
        self.name = name
        self.description = description
        self.thumbnail = thumbnail
        self.metadata = metadata
      }
    }

    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        pub let id: UInt64
        pub let sequence: UInt64
        pub var metadata: NFTMetadata
        access(self) let trades: TraderflowScores.TradeScores

        pub fun getViews(): [Type] {
          return [
            Type<MetadataViews.Display>()
          ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
          let template: NFTMetadata = self.getMetadata()
          switch view {
            case Type<MetadataViews.Display>():
              return MetadataViews.Display(
                name: template.name,
                description: template.description,
                thumbnail: MetadataViews.HTTPFile(
                  url: template.thumbnail
                )
              )
          }
          return nil
        }

        pub fun getTrades(): TraderflowScores.TradeScores {
          return self.trades
        }

        pub fun getMetadata(): NFTMetadata {
          return NFTMetadata(name: self.metadata.name, description: self.metadata.description, thumbnail: self.metadata.thumbnail, metadata: self.trades.metadata())
        }

        access(contract) fun borrowTradesRef(): &TraderflowScores.TradeScores {
          return &self.trades as &TraderflowScores.TradeScores
        }

        access(contract) fun updateArtwork(ipfs: String) {
          self.metadata.thumbnail = ipfs
        }

        init(_name: String, _description: String, _thumbnail: String) {
          self.id = self.uuid
          self.sequence = DynamicNFT.totalSupply
          self.trades = TraderflowScores.TradeScores()
          self.metadata = NFTMetadata(name: _name, description: _description, thumbnail: _thumbnail, metadata: self.trades.metadata())
          DynamicNFT.totalSupply = DynamicNFT.totalSupply + 1
        }
    }

    pub resource interface CollectionPublic {
      pub fun deposit(token: @NonFungibleToken.NFT)
      pub fun getIDs(): [UInt64]
      pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
      pub fun borrowAuthNFT(id: UInt64): &DynamicNFT.NFT? {
        post {
            (result == nil) || (result?.id == id):
                "Cannot borrow DynamicNFT reference: the ID of the returned reference is incorrect"
        }
      }
    }

    pub resource Collection: CollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
      pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

      pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
        let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")
        emit Withdraw(id: token.id, from: self.owner?.address)
        return <- token
      }

      pub fun deposit(token: @NonFungibleToken.NFT) {
        let token <- token as! @DynamicNFT.NFT
        emit Deposit(id: token.id, to: self.owner?.address)
        self.ownedNFTs[token.id] <-! token
      }

      pub fun getIDs(): [UInt64] {
        return self.ownedNFTs.keys
      }

      pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
        return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
      }

      pub fun borrowAuthNFT(id: UInt64): &DynamicNFT.NFT? {
        if self.ownedNFTs[id] != nil {
          let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
          return ref as! &DynamicNFT.NFT
        }
        return nil
      }

      pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
        let token = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
        let nft = token as! &DynamicNFT.NFT
        return nft as &AnyResource{MetadataViews.Resolver}
      }

      init () {
        self.ownedNFTs <- {}
      }

      destroy() {
        destroy self.ownedNFTs
      }
    }

    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
      return <- create Collection()
    }

    pub event rebuildNFT(id: UInt64, owner: Address, metadata: TraderflowScores.TradeMetadataRebuild)

    pub resource Administrator {

      pub fun mintNFT(
        recipient: &Collection{NonFungibleToken.Receiver},
        name: String,
        description: String,
        thumbnail: String
      ) {
        let nft <- create NFT(_name: name, _description: description, _thumbnail: thumbnail)
        emit Minted(id: nft.id, by: self.owner!.address, name: name, description: description, thumbnail: thumbnail)
        recipient.deposit(token: <- nft)
      }

      pub fun pushTrade(
        id: UInt64,
        currentOwner: Address,
        trade: TraderflowScores.Trade
      ) {
        let ownerCollection = getAccount(currentOwner).getCapability(DynamicNFT.CollectionPublicPath)
                                .borrow<&Collection{CollectionPublic}>()
                                ?? panic("This person does not have a DynamicNFT Collection set up properly.")
        let nftRef = ownerCollection.borrowAuthNFT(id: id) ?? panic("This account does not own an NFT with this id.")
        let tradeRef = nftRef.borrowTradesRef()
        let update = tradeRef.pushTrade(_trade: trade)
        emit rebuildNFT(id:id, owner:currentOwner, metadata:update)
      }

      pub fun pushEquity(
        id: UInt64,
        currentOwner: Address,
        equity: UFix64
      ) {
        let ownerCollection = getAccount(currentOwner).getCapability(DynamicNFT.CollectionPublicPath)
                                .borrow<&Collection{CollectionPublic}>()
                                ?? panic("This person does not have a DynamicNFT Collection set up properly.")
        let nftRef = ownerCollection.borrowAuthNFT(id: id) ?? panic("This account does not own an NFT with this id.")
        let tradeRef = nftRef.borrowTradesRef()
        let update = tradeRef.pushEquity(_equity: equity)
        emit rebuildNFT(id:id, owner:currentOwner, metadata:update)
      }

      pub fun updateArtwork(
        id: UInt64,
        currentOwner: Address,
        ipfs: String
      ) {
        let ownerCollection = getAccount(currentOwner).getCapability(DynamicNFT.CollectionPublicPath)
                                .borrow<&Collection{CollectionPublic}>()
                                ?? panic("This person does not have a DynamicNFT Collection set up properly.")
        let nftRef = ownerCollection.borrowAuthNFT(id: id) ?? panic("This account does not own an NFT with this id.")

        nftRef.metadata.thumbnail = ipfs
      }
    }

    init() {
        self.totalSupply = 0

        self.CollectionStoragePath = /storage/DynamicNFTCollection
        self.CollectionPublicPath = /public/DynamicNFTCollection
        self.MinterStoragePath = /storage/DynamicNFTMinter

        self.account.save(<- create Administrator(), to: self.MinterStoragePath)

        emit ContractInitialized()
    }
}
 "
-------
"/*

    The TradeScores object creates a append only store for historical trade and equity data.
    This data can be processed to determine performance information for a given trade account.
 */

pub contract TraderflowScores {

    pub enum TradeType: UInt8 {
        pub case Short
        pub case Long
    }

    pub struct Equity {
        pub let timestamp: UFix64
        pub let value: UFix64

        init(_value: UFix64) {
            self.timestamp = getCurrentBlock().timestamp
            self.value = _value
        }
    }

    pub struct TradeMetadata {
        pub let score: UInt32
        pub let drawdown: UInt32
        pub let winrate: UInt32
        pub let tradeCount: UInt64
        pub let equity: UFix64
        pub let average_profit: UFix64
        pub let average_loss: UFix64
        pub let average_long_profit_ema150: UFix64
        pub let average_long_loss_ema150: UFix64
        pub let average_short_profit_ema150: UFix64
        pub let average_short_loss_ema150: UFix64
        pub let achievement_provisional: Bool
        pub let achievement_bear: Bool
        pub let achievement_bull: Bool
        pub let achievement_piggyban: Bool
        pub let achievement_scales: Bool
        pub let achievement_robot: Bool
        pub let achievement_bank: Bool
        pub let achievement_moneybags: Bool
        pub let achievement_safe: Bool
        pub let achievement_crown1: Bool
        pub let achievement_crown2: Bool
        pub let achievement_diamond1: Bool
        pub let achievement_diamond2: Bool
        pub let achievement_onfire: Bool

        init (_score: UFix64, _drawdown: UFix64, _winrate: UFix64, _tradeCount: UInt64, _equity: UFix64, _average_profit:UFix64, _average_loss:UFix64, _average_long_profit_ema150:UFix64, _average_long_loss_ema150:UFix64, _average_short_profit_ema150:UFix64, _average_short_loss_ema150:UFix64, _achievement_provisional: Bool, _achievement_bear: Bool, _achievement_bull: Bool, _achievement_piggyban: Bool, _achievement_scales: Bool, _achievement_robot: Bool, _achievement_bank: Bool, _achievement_moneybags: Bool, _achievement_safe: Bool, _achievement_crown1: Bool, _achievement_crown2: Bool, _achievement_diamond1: Bool, _achievement_diamond2: Bool, _achievement_onfire: Bool) {
            self.score = UInt32(_score*100.0)
            self.drawdown = UInt32(_drawdown*100.0)
            self.winrate = UInt32(_winrate*100.0)
            self.tradeCount = _tradeCount
            self.equity = _equity
            self.average_profit = _average_profit
            self.average_loss = _average_loss
            self.average_long_profit_ema150 = _average_long_profit_ema150
            self.average_long_loss_ema150 = _average_long_loss_ema150
            self.average_short_profit_ema150 = _average_short_profit_ema150
            self.average_short_loss_ema150 = _average_short_loss_ema150
            self.achievement_provisional = _achievement_provisional
            self.achievement_bear = _achievement_bear
            self.achievement_bull = _achievement_bull
            self.achievement_piggyban = _achievement_piggyban
            self.achievement_scales = _achievement_scales
            self.achievement_robot = _achievement_robot
            self.achievement_bank = _achievement_bank
            self.achievement_moneybags = _achievement_moneybags
            self.achievement_safe = _achievement_safe
            self.achievement_crown1 = _achievement_crown1
            self.achievement_crown2 = _achievement_crown2
            self.achievement_diamond1 = _achievement_diamond1
            self.achievement_diamond2 = _achievement_diamond2
            self.achievement_onfire = _achievement_onfire
        }

        pub fun equal(md:TradeMetadata):Bool {
            if self.score != md.score { return false }
            if self.drawdown != md.drawdown { return false }
            if self.winrate != md.winrate { return false }
            if self.achievement_provisional != md.achievement_provisional { return false }
            if self.achievement_bear != md.achievement_bear { return false }
            if self.achievement_bull != md.achievement_bull { return false }
            if self.achievement_piggyban != md.achievement_piggyban { return false }
            if self.achievement_scales != md.achievement_scales { return false }
            if self.achievement_robot != md.achievement_robot { return false }
            if self.achievement_bank != md.achievement_bank { return false }
            if self.achievement_moneybags != md.achievement_moneybags { return false }
            if self.achievement_safe != md.achievement_safe { return false }
            if self.achievement_crown1 != md.achievement_crown1 { return false }
            if self.achievement_crown2 != md.achievement_crown2 { return false }
            if self.achievement_diamond1 != md.achievement_diamond1 { return false }
            if self.achievement_diamond2 != md.achievement_diamond2 { return false }
            if self.achievement_onfire != md.achievement_onfire { return false }
            return true
        }
    }

    pub struct TradeMetadataRebuild {
        pub let tbv: TradeMetadata
        pub let rebuild: Bool
        init(_metadata: TradeMetadata, _rebuild: Bool) {
            self.tbv = _metadata
            self.rebuild = _rebuild
        }
    }

    pub struct Trade {
        pub let onchain: UFix64
        pub let symbol: String
        pub let tradeType: TradeType
        pub let openPrice: Fix64
        pub let openTime: UInt64
        pub let closePrice: Fix64
        pub let closeTime: UInt64
        pub let stopLoss: Fix64
        pub let takeProfit: Fix64
        pub let profit: Fix64
        pub let equity: UFix64
        pub let ticket: UInt64
        pub(set) var openEquity: UFix64?
        pub(set) var minEquity: UFix64?
        pub(set) var maxEquity: UFix64?

        init(_symbol: String, _tradeType: TradeType, _openPrice: Fix64, _openTime: UInt64, _closePrice: Fix64, _closeTime: UInt64, _stopLoss: Fix64, _takeProfit: Fix64, _profit: Fix64, _equity: UFix64, _ticket: UInt64) {
            self.onchain = getCurrentBlock().timestamp
            self.symbol = _symbol
            self.tradeType = _tradeType
            self.openPrice = _openPrice
            self.openTime = _openTime
            self.closePrice = _closePrice
            self.closeTime = _closeTime
            self.stopLoss = _stopLoss
            self.takeProfit = _takeProfit
            self.profit = _profit
            self.equity = _equity
            self.ticket = _ticket
            self.openEquity = nil
            self.minEquity = nil
            self.maxEquity = nil
        }
    }

    pub struct TradeScores {
        /* Log of trades and counts */
        access(self) var historical: [Trade]
        access(contract) var positive_long_total: UInt
        access(contract) var negative_long_total: UInt
        access(contract) var positive_long_run: UInt
        access(contract) var negative_long_run: UInt
        access(contract) var positive_short_total: UInt
        access(contract) var negative_short_total: UInt
        access(contract) var positive_short_run: UInt
        access(contract) var negative_short_run: UInt

        /* Moving average of % profit */
        access(contract) var average_long_profit_ema150: UFix64
        access(contract) var average_long_loss_ema150: UFix64
        access(contract) var average_short_profit_ema150: UFix64
        access(contract) var average_short_loss_ema150: UFix64

        /* Log of equity and totals */
        access(self) var historical_equity: [Equity]
        access(contract) var equity_max: UFix64


        init() {
            self.historical=[]
            self.historical_equity=[]
            self.positive_long_total = 0
            self.negative_long_total = 0
            self.positive_long_run = 0
            self.negative_long_run = 0
            self.positive_short_total = 0
            self.negative_short_total = 0
            self.positive_short_run = 0
            self.negative_short_run = 0
            self.equity_max = 0.0
            self.average_long_profit_ema150 = 0.0
            self.average_long_loss_ema150 = 0.0
            self.average_short_profit_ema150 = 0.0
            self.average_short_loss_ema150 = 0.0
        }

        pub fun findOpen(_symbol: String, _ticket: UInt64):Trade? {
            var pos:Int = self.historical.length-1
            var openTrade: Trade? = nil

            while (pos>0) {
                var trade:Trade = self.historical[pos]

                if (_symbol == trade.symbol && trade.ticket == _ticket) {
                    if trade.closeTime == 0 {
                        return trade
                    }
                }
                pos = pos - 1
            }
            return nil
        }

        pub fun equityMinMaxBetween( start:UFix64, end:UFix64 ): [UFix64] {
            var min:UFix64 = UFix64.max
            var max:UFix64 = 0.0
            var cnt:Int = self.historical_equity.length

            while (cnt>0) {
                cnt = cnt - 1
                var eq = self.historical_equity[cnt]
                if (eq.timestamp < end) {
                    if (eq.timestamp < start) {
                        cnt=0
                        break
                    } else {
                        if eq.value < max  {
                            max = eq.value
                        }
                        if min > eq.value {
                            min = eq.value
                        }
                    }
                }
            }

            return [min,max]
        }

        pub fun pushEquity(_equity: UFix64): TradeMetadataRebuild {
            let oldMetadata = self.metadata();
            var eq:Equity = Equity(_value:_equity)

            self.historical_equity.append(eq)

            if (self.equity_max < _equity) {
                self.equity_max = _equity
            }

            /* Determine if the NFT needs to be rebuilt */
            let newMetadata = self.metadata()
            return TradeMetadataRebuild(_metadata: newMetadata, _rebuild: !oldMetadata.equal(md:newMetadata))
        }

        pub fun pushTrade(_trade: Trade): TradeMetadataRebuild {
            let oldMetadata = self.metadata();

            self.pushEquity(_equity: _trade.equity)

            /* Calculate the running totals for completed trades */
            if (_trade.closeTime != 0) { // Has the trade completed
                if (_trade.tradeType == TradeType.Long) { // Is the trade long
                    if (_trade.profit > 0.0) {
                        self.positive_long_total = self.positive_long_total +1
                        self.positive_long_run = self.positive_long_run + 1
                        self.negative_long_run = 0
                    } else {
                        self.negative_long_total = self.negative_long_total +1
                        self.negative_long_run = self.positive_long_run + 1
                        self.positive_long_run = 0
                    }
                } else if (_trade.tradeType == TradeType.Short) {
                    if (_trade.profit > 0.0) {
                        self.positive_short_total = self.positive_short_total +1
                        self.positive_short_run = self.positive_short_run + 1
                        self.negative_short_run = 0
                    } else {
                        self.negative_short_total = self.negative_short_total +1
                        self.negative_short_run = self.positive_short_run + 1
                        self.positive_short_run = 0
                    }
                }

                var open: Trade? = self.findOpen(_symbol: _trade.symbol, _ticket: _trade.ticket)
                if ( open != nil ) {
                    var start: UFix64 = open!.onchain // Start timestamp
                    var end: UFix64 = _trade.onchain // End timestamp

                    /* Find minimum and maximum equity value for the duration of the open trade */
                    var minmax :[UFix64]= self.equityMinMaxBetween(start: start, end: end)
                    _trade.minEquity = minmax[0]
                    _trade.maxEquity = minmax[1]

                    /* Calculate 150 trade exponential moving average percentage for profit and loss */
                    let ema = 2.0/150.0
                    let invEma = 1.0-ema
                    var profitPercent:Fix64 = _trade.profit / Fix64(open!.equity)
                    if _trade.profit>0.0 {
                        if _trade.tradeType == TradeType.Short {
                            if (self.positive_short_total==1) {
                                self.average_short_profit_ema150 = UFix64(profitPercent)
                            } else {
                                self.average_short_profit_ema150 = self.average_short_profit_ema150*invEma + UFix64(profitPercent)*ema
                            }
                        } else if _trade.tradeType == TradeType.Long {
                            if (self.positive_long_total==1) {
                                self.average_long_profit_ema150 = UFix64(profitPercent)
                            } else {
                                self.average_long_profit_ema150 = self.average_long_profit_ema150*invEma + UFix64(profitPercent)*ema
                            }
                        }

                    } else if _trade.profit<0.0 {
                        var lossPercent:UFix64 = UFix64(-profitPercent)
                        if _trade.tradeType == TradeType.Short {
                            if (self.negative_short_total==1) {
                                self.average_short_loss_ema150 = lossPercent
                            } else {
                                self.average_short_loss_ema150 = self.average_short_loss_ema150*invEma + lossPercent*ema
                            }
                        } else if _trade.tradeType == TradeType.Long {
                            if (self.negative_long_total == 1) {
                                self.average_long_loss_ema150 = lossPercent
                            } else {
                                self.average_long_loss_ema150 = self.average_long_loss_ema150*invEma + lossPercent*ema
                            }
                        }
                    }
                }
            }

            /* Every trade is added to the historical data to allow for verification */
            self.historical.append(_trade)

            /* Determine if the NFT needs to be rebuilt */
            let newMetadata = self.metadata()
            return TradeMetadataRebuild(_metadata: newMetadata, _rebuild: !oldMetadata.equal(md:newMetadata))
        }



        /* INTERMEDIATE CALCULATIONS */

        /* Return last recorded equity value */
        pub fun Equity(): UFix64 {
            let len: Int = self.historical_equity.length
            if len == 0 { return 0.0 }
            else { return self.historical_equity[len-1].value }
        }

        pub fun DrawDown(): UFix64 {
            let equity = self.Equity()
            if equity == 0.0 { return 0.0 }
            else { return self.equity_max / equity }
        }

        pub fun WinRate(): UFix64 {
            var ptotal: UFix64 = UFix64(self.positive_long_total+self.positive_short_total)
            var total: UFix64 = ptotal + UFix64(self.negative_long_total+self.negative_short_total)
            if total == 0.0 || ptotal == 0.0 { return 0.0 }
            else { return ptotal / total }
        }

        pub fun AverageProfitAndLoss(): [UFix64] {
            var aveP: Fix64 = 0.0
            var aveL: Fix64 = 0.0
            var avePC: Fix64 = 0.0
            var aveLC: Fix64 = 0.0

            for trade in self.historical {
                if trade.profit>0.0 {
                    aveP = aveP + trade.profit
                    avePC = avePC + 1.0
                } else if trade.profit<0.0 {
                    aveL = aveL - trade.profit
                    aveLC = aveLC + 1.0
                }
            }
            var avePnL:[UFix64] = []
            if avePC == 0.0 { avePnL.append(0.0) }
            else { avePnL.append(UFix64(aveP/avePC)) }
            if aveLC == 0.0 { avePnL.append(0.0) }
            else { avePnL.append(UFix64(aveL/aveLC)) }
            return avePnL
        }

        pub fun Score(): UFix64 {
            var pl: [UFix64] = self.AverageProfitAndLoss()
            var win: UFix64 = self.WinRate()
            if (pl[0]==0.0) { pl[0]=1.0 }
            if (pl[1]==0.0) { pl[1]=1.0 }
            var score: UFix64 = (pl[0]/pl[1])*win;
            if (score > 79.999999) {

            }
            return score
        }

        /* ACHIEVEMENTS */
        pub fun Provisional_Achievement(): Bool {
            /* Duration of 60 days in seconds */
            let sixty_days:UFix64 = 60.0*24.0*60.0*60.0

            /* If a user has less than 50 trades they are provisional */
            if self.historical.length < 50 { return true }

            /* Additionally if they have less than 60 days of trades on chain they are provisional */
            if self.historical[0].onchain + sixty_days < getCurrentBlock().timestamp { return true }

            return false
        }

        pub fun Bear_Achievement(): Bool {
            return self.positive_short_total > 25
        }

        pub fun Bull_Achievement(): Bool {
            return self.positive_long_total > 25
        }

        pub fun Piggybank_Achievement(): Bool {
            return (self.positive_long_total + self.positive_short_total) > 50
        }

        pub fun Scales_Achievement(): Bool {
            return (self.positive_short_total>25) && (self.positive_long_total>25)
        }

        pub fun Robot_Achievement(): Bool {
            return (self.positive_long_total + self.positive_short_total) > 100
        }

        pub fun Bank_Achievement(): Bool {
            return self.Equity() > 1000.0
        }

        pub fun Moneybags_Achievement(): Bool {
            return self.Equity() > 10000.0
        }

        pub fun Safe_Achievement(): Bool {
            return self.DrawDown() < 0.10
        }

        pub fun Crown1_Achievement(): Bool {
            return true
        }

        pub fun Crown2_Achievement(): Bool {
            return false
        }

        pub fun Diamond1_Achievement(): Bool {
            return true
        }

        pub fun Diamond2_Achievement(): Bool {
            return false
        }

        pub fun OnFire_Achievement(): Bool {
            return self.positive_long_run > 10 || self.positive_short_run > 10
        }

        pub fun metadata(): TradeMetadata {
            var pl: [UFix64] = self.AverageProfitAndLoss()
            return TradeMetadata(
                _score: self.Score(),
                _drawdown: self.DrawDown(),
                _winrate: self.WinRate(),
                _tradeCount: UInt64(self.historical.length),
                _equity: self.Equity(),
                _average_profit: pl[0],
                _average_loss: pl[1],
                _average_long_profit_ema150: self.average_long_profit_ema150,
                _average_long_loss_ema150: self.average_long_loss_ema150,
                _average_short_profit_ema150: self.average_short_profit_ema150,
                _average_short_loss_ema150: self.average_short_loss_ema150,
                _achievement_provisional: self.Provisional_Achievement(),
                _achievement_bear: self.Bear_Achievement(),
                _achievement_bull: self.Bull_Achievement(),
                _achievement_piggyban: self.Piggybank_Achievement(),
                _achievement_scales: self.Scales_Achievement(),
                _achievement_robot: self.Robot_Achievement(),
                _achievement_bank: self.Bank_Achievement(),
                _achievement_moneybags: self.Moneybags_Achievement(),
                _achievement_safe: self.Safe_Achievement(),
                _achievement_crown1: self.Crown1_Achievement(),
                _achievement_crown2: self.Crown2_Achievement(),
                _achievement_diamond1: self.Diamond1_Achievement(),
                _achievement_diamond2: self.Diamond2_Achievement(),
                _achievement_onfire: self.OnFire_Achievement()
            )
        }
    }
}
 "
-------
"//import FungibleToken from 0xf233dcee88fe0abe
import FungibleToken from 0xf233dcee88fe0abe

pub contract FlovatarDustToken: FungibleToken {

    /// Total supply of FlovatarDustTokens in existence
    pub var totalSupply: UFix64

    /// Name of the path
    pub let VaultReceiverPath: PublicPath
    pub let VaultBalancePath: PublicPath
    pub let VaultStoragePath: StoragePath
    pub let AdminStoragePath: StoragePath

    /// TokensInitialized
    ///
    /// The event that is emitted when the contract is created
    pub event TokensInitialized(initialSupply: UFix64)

    /// TokensWithdrawn
    ///
    /// The event that is emitted when tokens are withdrawn from a Vault
    pub event TokensWithdrawn(amount: UFix64, from: Address?)

    /// TokensDeposited
    ///
    /// The event that is emitted when tokens are deposited to a Vault
    pub event TokensDeposited(amount: UFix64, to: Address?)

    /// TokensMinted
    ///
    /// The event that is emitted when new tokens are minted
    pub event TokensMinted(amount: UFix64)

    /// TokensBurned
    ///
    /// The event that is emitted when tokens are destroyed
    pub event TokensBurned(amount: UFix64)

    /// MinterCreated
    ///
    /// The event that is emitted when a new minter resource is created
    pub event MinterCreated(allowedAmount: UFix64)

    /// BurnerCreated
    ///
    /// The event that is emitted when a new burner resource is created
    pub event BurnerCreated()

    /// Vault
    ///
    /// Each user stores an instance of only the Vault in their storage
    /// The functions in the Vault and governed by the pre and post conditions
    /// in FungibleToken when they are called.
    /// The checks happen at runtime whenever a function is called.
    ///
    /// Resources can only be created in the context of the contract that they
    /// are defined in, so there is no way for a malicious user to create Vaults
    /// out of thin air. A special Minter resource needs to be defined to mint
    /// new tokens.
    ///
    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {

        /// The total balance of this vault
        pub var balance: UFix64

        // initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        /// withdraw
        ///
        /// Function that takes an amount as an argument
        /// and withdraws that amount from the Vault.
        ///
        /// It creates a new temporary Vault that is used to hold
        /// the money that is being transferred. It returns the newly
        /// created Vault to the context that called so it can be deposited
        /// elsewhere.
        ///
        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)
            return <-create Vault(balance: amount)
        }

        /// deposit
        ///
        /// Function that takes a Vault object as an argument and adds
        /// its balance to the balance of the owners Vault.
        ///
        /// It is allowed to destroy the sent Vault because the Vault
        /// was a temporary holder of the tokens. The Vault's balance has
        /// been consumed and therefore can be destroyed.
        ///
        pub fun deposit(from: @FungibleToken.Vault) {
            let vault <- from as! @FlovatarDustToken.Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)
            vault.balance = 0.0
            destroy vault
        }

        destroy() {
            if(self.balance > 0.0){
                emit TokensBurned(amount: self.balance)
            }
            FlovatarDustToken.totalSupply = FlovatarDustToken.totalSupply - self.balance
        }
    }

    /// createEmptyVault
    ///
    /// Function that creates a new Vault with a balance of zero
    /// and returns it to the calling context. A user must call this function
    /// and store the returned Vault in their storage in order to allow their
    /// account to be able to receive deposits of this token type.
    ///
    pub fun createEmptyVault(): @Vault {
        return <-create Vault(balance: 0.0)
    }

    pub resource Administrator {

        /// createNewMinter
        ///
        /// Function that creates and returns a new minter resource
        ///
        pub fun createNewMinter(allowedAmount: UFix64): @Minter {
            emit MinterCreated(allowedAmount: allowedAmount)
            return <-create Minter(allowedAmount: allowedAmount)
        }

        /// createNewBurner
        ///
        /// Function that creates and returns a new burner resource
        ///
        pub fun createNewBurner(): @Burner {
            emit BurnerCreated()
            return <-create Burner()
        }
    }

    /// Minter
    ///
    /// Resource object that token admin accounts can hold to mint new tokens.
    ///
    pub resource Minter {

        /// The amount of tokens that the minter is allowed to mint
        pub var allowedAmount: UFix64

        /// mintTokens
        ///
        /// Function that mints new tokens, adds them to the total supply,
        /// and returns them to the calling context.
        ///
        pub fun mintTokens(amount: UFix64): @FlovatarDustToken.Vault {
            pre {
                amount > 0.0: "Amount minted must be greater than zero"
                amount <= self.allowedAmount: "Amount minted must be less than the allowed amount"
            }
            FlovatarDustToken.totalSupply = FlovatarDustToken.totalSupply + amount
            self.allowedAmount = self.allowedAmount - amount
            emit TokensMinted(amount: amount)
            return <-create Vault(balance: amount)
        }

        init(allowedAmount: UFix64) {
            self.allowedAmount = allowedAmount
        }
    }

    /// Burner
    ///
    /// Resource object that token admin accounts can hold to burn tokens.
    ///
    pub resource Burner {

        /// burnTokens
        ///
        /// Function that destroys a Vault instance, effectively burning the tokens.
        ///
        /// Note: the burned tokens are automatically subtracted from the
        /// total supply in the Vault destructor.
        ///
        pub fun burnTokens(from: @FungibleToken.Vault) {
            let vault <- from as! @FlovatarDustToken.Vault
            let amount = vault.balance
            destroy vault
            emit TokensBurned(amount: amount)
        }
    }

    init() {
        self.totalSupply = 500000000.0

        self.VaultReceiverPath = /public/FlovatarDustTokenReceiver
        self.VaultBalancePath = /public/FlovatarDustTokenBalance
        self.VaultStoragePath = /storage/FlovatarDustTokenVault
        self.AdminStoragePath = /storage/FlovatarDustTokenAdmin

        // Create the Vault with the total supply of tokens and save it in storage
        //
        let vault <- create Vault(balance: self.totalSupply)
        self.account.save(<-vault, to: self.VaultStoragePath)

        // Create a public capability to the stored Vault that only exposes
        // the `deposit` method through the `Receiver` interface
        //
        self.account.link<&{FungibleToken.Receiver, FungibleToken.Balance}>(
            self.VaultReceiverPath,
            target: self.VaultStoragePath
        )

        // Create a public capability to the stored Vault that only exposes
        // the `balance` field through the `Balance` interface
        //
        self.account.link<&FlovatarDustToken.Vault{FungibleToken.Balance}>(
            self.VaultBalancePath,
            target: self.VaultStoragePath
        )

        let admin <- create Administrator()
        self.account.save(<-admin, to: self.AdminStoragePath)

        // Emit an event that shows that the contract was initialized
        //
        emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
"
-------
"access(all) contract Foo {

            access(all) resource Vault {}

            access(all) var temp: @Vault?

            init() {
                self.temp <- nil
            }

            access(all) fun doubler(): @Vault {
                destroy  <- create R()
                var doubled <- self.temp <- nil
                return <- doubled!
            }

            access(all) resource R {
                access(all) var bounty: @Vault
                access(all) var dummy: @Vault

                init() {
                     self.bounty <- create Vault()
                     self.dummy <- create Vault()
                }

                access(all) fun swap() {
                    self.bounty <-> self.dummy
                }

                destroy() {
                    // Nested resource is moved here once
                    var bounty <- self.bounty

                    // Nested resource is again moved here. This one should fail.
                    self.swap()

                    destroy bounty
                    destroy self.dummy
                }
            }
        }
"
-------
"/*
    Contract for Pinnacle NFTs and metadata
*/

import NonFungibleToken from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import MetadataViews from 0x1d7e57aa55817448
import ViewResolver from 0x1d7e57aa55817448

/*
The Pinnacle contract introduces five entities that establish the requirements for minting Pinnacle Pin NFTs and
organizing their metadata: Edition Types, Series, Sets, Shapes, and Editions.

These entities are defined as struct types, created by the Admin, and stored in arrays in the contract state.
Edition Types and Series are independent from other entities. Sets, Shapes, and Editions are linked to a
parent entity: a Series, Set, or Shape, respectively. Sets are also linked to a parent Edition Type.

Pinnacle Pin NFTs are minted from Editions. Owners have the option to add an Inscription to their NFT. The NFTs
adhere to the Flow NFT standard. Any Flow account can create a Collection to store Pinnacle Pin NFTs, which
includes functionality for Inscriptions and XP balance.

An Admin resource is created in the contract's init function. It is meant to be saved in the Admin's account
and provides the following key abilities:

- Create new entities (Edition Types, Series, Sets, Shapes, and Editions).
- Lock Series and Sets, preventing the creation of new child Sets and Shapes, respectively.
- Close Shapes, preventing the creation of new child Editions, Open/Unlimited Editions, preventing the
minting of new NFTs from those Editions, and Edition Types, preventing the creation of new child Sets, Shapes,
and Editions.
- Unlock or reopen entities within the undo period.
- Update the name of Series, Sets, and Shapes, as well as the description of Editions.
- Increment the current printing of Shapes unless they are closed.
- Mint NFTs, subject to the conditions defined in the contract, and deposit them in any account.
- Update an Inscription's note with owner co-signing if the owner has added an Inscription to their NFT.
- Update an NFT's XP balance unless the owner has revoked this ability.
- Create new Admins.

Notes:

- All functions will fail if an invalid argument is provided or one of the pre- or post-conditions are not
met. For getter functions, calls to non-existing objects are considered valid and will return nil so that they
can be handled differently by the caller. The borrowNFT function in the Collection resource is an exception to
that pattern, the borrowNFTSafe or borrowPinNFT function can be used instead.
- All dates specified in the contract are Unix timestamps.
 */

/// The Pinnacle Pin NFTs and metadata contract
///
pub contract Pinnacle: NonFungibleToken, ViewResolver {
    //------------------------------------------------------------
    // Events
    //------------------------------------------------------------

    // Contract Events
    //
    pub event ContractInitialized()

    // Series Events
    //
    /// Emitted when a new Series has been created, meaning new Sets can be created with the Series
    pub event SeriesCreated(id: Int, name: String)
    /// Emitted when a Series is locked, meaning new Sets cannot be created with the Series anymore
    pub event SeriesLocked(id: Int, name: String)
    /// Emitted when a Series's name is updated
    pub event SeriesNameUpdated(id: Int, name: String)

    // Set Events
    //
    /// Emitted when a new Set has been created, meaning new Shapes can be created with the Set
    pub event SetCreated(id: Int, renderID: String, name: String, seriesID: Int, editionType: String)
    /// Emitted when a Set is locked, meaning new Shapes cannot be created with the Set anymore
    pub event SetLocked(id: Int, renderID: String, name: String, seriesID: Int, editionType: String)
    /// Emitted when a Set's name is updated
    pub event SetNameUpdated(id: Int, renderID: String, name: String, seriesID: Int, editionType: String)

    // Shape Events
    //
    /// Emitted when a new Shape has been created, meaning new Editions can be created with the Shape
    pub event ShapeCreated(
        id: Int,
        renderID: String,
        setID: Int,
        name: String,
        editionType: String,
        metadata: {String: [String]}
    )
    /// Emitted when a Shape is closed, meaning new Editions cannot be created with the Shape anymore
    pub event ShapeClosed(
        id: Int,
        renderID: String,
        setID: Int,
        name: String,
        currentPrinting: UInt64,
        editionType: String
    )
    /// Emitted when a Shape's name is updated
    pub event ShapeNameUpdated(
        id: Int,
        renderID: String,
        setID: Int,
        name: String,
        currentPrinting: UInt64,
        editionType: String
    )
    /// Emitted when a Shape's current printing is incremented
    pub event ShapeCurrentPrintingIncremented(
        id: Int,
        renderID: String,
        setID: Int,
        name: String,
        currentPrinting: UInt64,
        editionType: String
    )

    // Edition Events
    //
    /// Emitted when a new Edition has been created, meaning new NFTs can be minted with the Edition
    pub event EditionCreated(
        id: Int,
        renderID: String,
        seriesID: Int,
        setID: Int,
        shapeID: Int,
        variant: String?,
        printing: UInt64,
        editionTypeID: Int,
        description: String,
        isChaser: Bool,
        maxMintSize: UInt64?,
        maturationPeriod: UInt64?,
        traits: {String: [String]}
    )
    /// Emitted when an Edition is either closed by the Admin or the maximum amount of pins have been minted
    pub event EditionClosed(
        id: Int,
        maxMintSize: UInt64
    )
    /// Emitted when an Edition's description is updated
    pub event EditionDescriptionUpdated(
        id: Int,
        description: String
    )

    /// Emitted when an Edition's renderID is updated
    pub event EditionRenderIDUpdated(
        id: Int,
        renderID: String
    )

    /// Emitted when an Edition has been removed from the contract by the Admin, this can only be done if the
    /// Edition is the last one that was created in the contract and no NFTs were minted from it
    pub event EditionRemoved(
        id: Int
    )

    // Edition Type Events
    //
    /// Emitted when a new Edition Type has been created
    pub event EditionTypeCreated(id: Int, name: String, isLimited: Bool, isMaturing: Bool)
    /// Emitted when an Edition Type has been closed, meaning new Editions cannot be created with the Edition
    /// Type anymore
    pub event EditionTypeClosed(id: Int, name: String, isLimited: Bool, isMaturing: Bool)

    // NFT Events
    //
    /// Emitted when a Pin NFT is withdrawn from the Collection
    pub event Withdraw(id: UInt64, from: Address?)
    /// Emitted when a Pin NFT is deposited into the Collection
    pub event Deposit(id: UInt64, to: Address?)
    /// Emitted when a Pin NFT is minted
    pub event PinNFTMinted(id: UInt64, renderID: String, editionID: Int, serialNumber: UInt64?, maturityDate: UInt64?)
    /// Emitted when a Pin NFT is destroyed
    pub event PinNFTBurned(id: UInt64, editionID: Int, serialNumber: UInt64?, xp: UInt64?)
    /// Emitted when a Pin NFT's XP is updated
    pub event NFTXPUpdated(id: UInt64, editionID: Int, xp: UInt64?)
    /// Emitted when an Inscription is added to a Pin NFT
    pub event NFTInscriptionAdded(
        id: Int,
        owner: Address,
        note: String?,
        nftID: UInt64,
        editionID: Int
    )
    /// Emitted when an NFT's Inscription is updated
    pub event NFTInscriptionUpdated(
        id: Int,
        owner: Address,
        note: String?,
        nftID: UInt64,
        editionID: Int
    )
    /// Emitted when an NFT's Inscription is removed by the owner. This can only be done during the undo
    /// period and if the Inscription is the last one that was added to the NFT - meaning the Inscription is
    /// permanent after the undo period has expired or if the NFT is transferred to another owner and the new
    /// owner adds a new Inscription to the NFT
    pub event NFTInscriptionRemoved(id: Int, owner: Address, nftID: UInt64, editionID: Int)

    // Other Events
    //
    /// Emitted when a Series, Set, Shape, or Edition Type is reopened or unlocked by the Admin during the
    /// undo period. Editions cannot be reopened even during the undo period.
    pub event EntityReactivated(entity: String, id: Int, name: String?)
    /// Emitted when a new Variant has been inserted
    pub event VariantInserted(name: String)
    /// Emitted when the wrapper emitPurchasedEvent Admin function is called
    pub event Purchased(
        purchaseIntentID: String,
        buyerAddress: Address,
        countPurchased: UInt64,
        totalSalePrice: UFix64
    )
    /// Emitted when an Open/Unlimited Edition NFT is destroyed by the Admin
    pub event OpenEditionNFTBurned(id: UInt64, editionID: Int)

    //------------------------------------------------------------
    // Named values
    //------------------------------------------------------------

    /// Named Paths
    ///
    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let CollectionPrivatePath: PrivatePath
    pub let AdminStoragePath: StoragePath
    pub let MinterPrivatePath: PrivatePath

    //------------------------------------------------------------
    // Publicly readable contract state
    //------------------------------------------------------------

    /// The total supply of Pin NFTs in existence (those have been minted minus those that have been burned)
    pub var totalSupply: UInt64

    /// The period in seconds during which entities can be unlocked or reopened in case they are locked or
    /// closed by mistake. Entities become permanently locked or closed after the undo period has passed.
    pub let undoPeriod: UInt64

    /// The address returned by the Royalties MetadataView to indicate where royalties should be deposited
    pub var royaltyAddress: Address

    /// The end user license URL and statement, it gets added to every Shape's metadata dictionary
    pub var endUserLicenseURL: String

    //------------------------------------------------------------
    // Internal contract state
    //------------------------------------------------------------

    /// The arrays that store the entities in the contract state.
    ///
    /// Each array index corresponds to the entity's ID - 1. See how entities are added to the contract arrays
    /// in the entity creation functions defined in the Admin resource. The entities are stored in arrays
    /// rather than dictionaries so that they can be returned in slices at scale (no need to call the .keys
    /// built-in dictionary function that can cause a computation exceed limit error if the dictionary is too
    /// large).
    access(self) let series: [Series]
    access(self) let sets: [Set]
    access(self) let shapes: [Shape]
    access(self) let editions: [Edition]
    access(self) let editionTypes: [EditionType]

    /// The dictionaries that allow entities to be looked up by unique name
    access(self) let seriesIDsByName: {String: Int}
    access(self) let setIDsByName: {String: Int}
    access(self) let editionTypeIDsByName: {String: Int}

    /// The dictionary that stores the Variant strings that are allowed to be used when creating a new Edition
    ///
    /// Variants are defined as String dictionary entries rather than structs because they do not have any
    /// other properties than their name.
    access(self) let variants: {String: Bool}

    /// The dictionary that stores the maximum number of Inscriptions that can be added to each NFT. By
    /// default (no entry in the dictionary), an NFT can have up to 100 Inscriptions.
    access(self) let inscriptionsLimits: {UInt64: Int}

    /// The dictionary that stores any additional data that needs to be stored in the contract. This field
    /// has been added to accommodate potential future contract updates and facilitate new functionalities.
    /// It is not in use currently.
    access(self) let extension: {String: AnyStruct}

    //------------------------------------------------------------
    // Series
    //------------------------------------------------------------

    /// Struct that defines a Series
    ///
    /// Each Series is created independently of any other entity.
    ///
    pub struct Series {
        /// This Series' unique ID
        pub let id: Int

        /// This Series' unique name. It can be updated by the Admin.
        pub var name: String

        /// This field indicates whether the Series is currently unlocked (lockedDate is nil) or locked (has
        /// actual date).
        ///
        /// Initially, when a Series is created, it is in an unlocked state, allowing the creation of Sets.
        /// Once a Series is locked, it is no longer possible to create Sets linked to that Series. However,
        /// it is still possible to create Shapes and Editions within those Shapes using the Sets already
        /// created from the Series. Locking a Series takes immediate effect, but it can be undone during the
        /// undo period. The lockedDate field indicates the date when the Series is permanently locked,
        /// including the undo period.
        pub var lockedDate: UInt64?

        /// Struct initializer
        ///
        init(id: Int, name: String) {
            self.id = id
            self.name = name
            self.lockedDate = nil
        }

        /// Close this Series
        ///
        access(contract) fun lock() {
            pre {
                self.lockedDate == nil: "Series is already locked"
            }
            // Set the locked date to the current block timestamp plus the undo period
            self.lockedDate = UInt64(getCurrentBlock().timestamp) + Pinnacle.undoPeriod
            emit SeriesLocked(id: self.id, name: self.name)
        }

        /// Unlock this Series
        ///
        /// This will fail if the undo period has expired.
        ///
        access(contract) fun unlock() {
            pre {
                self.lockedDate != nil: "Series is already unlocked"
                self.lockedDate! >= UInt64(getCurrentBlock().timestamp):
                    "Undo period has expired, Series is permanently locked"
            }
            self.lockedDate = nil
            emit EntityReactivated(entity: "Series", id: self.id, name: self.name)
        }

        /// Update this Series' name
        ///
        access(contract) fun updateName(_ name: String) {
            pre {
                name != "": "The name of a Series cannot be an empty string"
                Pinnacle.seriesIDsByName.containsKey(name) == false: "A Series with that name already exists"
            }
            Pinnacle.seriesIDsByName.remove(key: self.name)
            self.name = name
            Pinnacle.seriesIDsByName[name] = self.id
            emit SeriesNameUpdated(id: self.id, name: self.name)
        }
    }

    /// Return the ID of the latest Series created in the contract
    ///
    /// The ID is an incrementing integer equal to the length of the series array.
    ///
    pub fun getLatestSeriesID(): Int {
        return Pinnacle.series.length
    }

    /// Return a Series struct containing the data of the Series with the given ID, if it exists in the
    /// contract
    ///
    pub fun getSeries(id: Int): Series? {
        pre {
            id > 0: "The ID of a Series must be greater than 0"
        }
        return Pinnacle.getLatestSeriesID() >= id ? Pinnacle.series[id - 1] : nil
    }

    /// Return all Series in the contract
    ///
    pub fun getAllSeries(): [Series] {
        return Pinnacle.series
    }

    /// Return a Series struct containing the data of the Series with the given name, if it exists in the
    /// contract
    ///
    pub fun getSeriesByName(_ name: String): Series? {
        if let id = Pinnacle.seriesIDsByName[name] {
            return Pinnacle.getSeries(id: id)
        }
        return nil
    }

    /// Return the ID of the Series with the given name, if it exists in the contract
    ///
    pub fun getSeriesIDByName(_ name: String): Int? {
        return Pinnacle.seriesIDsByName[name]
    }

    /// Allow iterating over Series names in the contract without allocating an array
    ///
    pub fun forEachSeriesName(_ function: ((String): Bool)) {
        Pinnacle.seriesIDsByName.forEachKey(function)
    }

    /// Return the contract's seriesIDsByName dictionary
    ///
    pub fun getAllSeriesIDsByNames(): {String: Int} {
        return Pinnacle.seriesIDsByName
    }

    //------------------------------------------------------------
    // Set
    //------------------------------------------------------------

    /// Struct that defines a Set
    ///
    /// Each Set is linked to a parent Series and Edition Type.
    ///
    pub struct Set {
        /// This Set's unique ID
        pub let id: Int

        /// This Set's RenderID. The uniqueness of renderID is NOT required.
        pub var renderID: String

        /// This Set's unique name. It can be updated by the Admin.
        pub var name: String

        /// The ID of the Series that this Set belongs to
        pub let seriesID: Int

        /// This field indicates whether the Set is currently unlocked (lockedDate is nil) or locked (has
        /// actual date).
        ///
        /// Initially, when a Set is created, it is in an unlocked state, allowing the creation of Shapes.
        /// Once a Set is locked, it is no longer possible to create Shapes linked to that Set. However, it is
        /// still possible to create Editions using the Shapes already created from the Set. Locking a Set
        /// takes immediate effect, but it can be undone during the undo period. The lockedDate field
        /// indicates the date when the Set is permanently locked, including the undo period.
        pub var lockedDate: UInt64?

        /// The type of Editions that can be created from this Set's Shapes
        pub let editionType: String

        /// The dictionary that stores all the Shape names inside the Set to ensure there can be at most one
        /// Shape with a given name in a Set
        access(self) let shapeNames: {String: Bool}

        /// Struct initializer
        ///
        init(id: Int, renderID: String, name: String, editionType: String, seriesID: Int) {
            self.id = id
            self.renderID = renderID
            self.name = name
            self.seriesID = seriesID
            self.lockedDate = nil
            self.editionType = editionType
            self.shapeNames = {}
        }

        /// Insert a new Shape name to the shapeNames dictionary
        ///
        access(contract) fun insertShapeName(_ name: String) {
            self.shapeNames[name] = true
        }

        /// Remove a Shape name from the shapeNames dictionary
        ///
        access(contract) fun removeShapeName(_ name: String) {
            self.shapeNames.remove(key: name)
        }

        /// Check if the Set contains the given Shape name
        ///
        access(contract) fun shapeNameExistsInSet(_ name: String): Bool {
            return self.shapeNames.containsKey(name)
        }

        /// Lock the Set so that no more Editions can be created with it
        ///
        access(contract) fun lock() {
            pre {
                self.lockedDate == nil: "Set is already locked"
            }
            // Set the locked date to the current block timestamp plus the undo period
            self.lockedDate = UInt64(getCurrentBlock().timestamp) + Pinnacle.undoPeriod
            emit SetLocked(
                id: self.id,
                renderID: self.renderID,
                name: self.name,
                seriesID: self.seriesID,
                editionType: self.editionType
            )
        }

        /// Unlock this Set
        ///
        /// This will fail if the undo period has expired.
        ///
        access(contract) fun unlock() {
            pre {
                self.lockedDate != nil: "Set is already unlocked"
                self.lockedDate! >= UInt64(getCurrentBlock().timestamp):
                    "Undo period has expired, Set is permanently locked"
            }
            self.lockedDate = nil
            emit EntityReactivated(entity: "Set", id: self.id, name: self.name)
        }

        /// Update this Set's name
        ///
        access(contract) fun updateName(_ name: String) {
            pre {
                name != "": "The name of a Set cannot be an empty string"
                Pinnacle.setIDsByName.containsKey(name) == false: "A Set with that name already exists"
            }
            Pinnacle.setIDsByName.remove(key: self.name)
            self.name = name
            Pinnacle.setIDsByName[name] = self.id
            emit SetNameUpdated(
                id: self.id,
                renderID: self.renderID,
                name: self.name,
                seriesID: self.seriesID,
                editionType: self.editionType
            )
        }

        /// Return this Set's shapeNames dictionary
        ///
        pub fun getShapeNames(): {String: Bool} {
            return self.shapeNames
        }
    }

    /// Return the ID of the latest Set created in the contract
    ///
    /// The ID is an incrementing integer equal to the length of the sets array.
    ///
    pub fun getLatestSetID(): Int {
        return Pinnacle.sets.length
    }

    /// Return a Set struct containing the data of the Set with the given ID, if it exists in the contract
    ///
    pub fun getSet(id: Int): Set? {
        pre {
            id > 0: "The ID of a Set must be greater than zero"
        }
        return Pinnacle.getLatestSetID() >= id ? Pinnacle.sets[id - 1] : nil
    }

    /// Return all Sets in the contract
    ///
    pub fun getAllSets(): [Set] {
        return Pinnacle.sets
    }

    /// Return a Set struct containing the data of the Set with the given name, if it exists in the contract
    ///
    pub fun getSetByName(_ name: String): Set? {
        if let id = Pinnacle.setIDsByName[name] {
            return Pinnacle.getSet(id: id)
        }
        return nil
    }

    /// Return the ID of the Set with the given name, if it exists in the contract
    ///
    pub fun getSetIDByName(_ name: String): Int? {
        return Pinnacle.setIDsByName[name]
    }

    /// Allow iterating over Set names in the contract without allocating an array
    ///
    pub fun forEachSetName(_ function: ((String): Bool)) {
        Pinnacle.setIDsByName.forEachKey(function)
    }

    /// Return the contract's setIDsByName dictionary
    ///
    pub fun getAllSetIDsByNames(): {String: Int} {
        return Pinnacle.setIDsByName
    }

    //------------------------------------------------------------
    // Shape
    //------------------------------------------------------------

    /// Struct that defines a Shape
    ///
    /// Each Shape is linked to a parent Set.
    ///
    pub struct Shape {
        /// This Shapes's unique ID
        pub let id: Int

        /// This Shape's renderID. The uniqueness of renderID is NOT required.
        pub let renderID: String

        /// The ID of the Set that this Shape belongs to
        pub let setID: Int

        /// This Shape's name, unique inside a Set. It can be updated by the Admin.
        pub var name: String

        /// This field indicates whether the Shape is currently open (closedDate is nil) or closed (has actual
        /// date).
        ///
        /// Initially, when a Shape is created, it is in an open state, allowing the creation of Editions.
        /// Once a Shape is closed, it is no longer possible to create Editions linked to that Shape or
        /// incrementing its current printing. However, it is still possible to mint NFTs using the Editions
        /// already created from the Shape. Locking a Shape takes immediate effect, but it can be undone
        /// during the undo period. The closedDate field indicates the date when the Shape is permanently
        /// closed, including the undo period.
        pub var closedDate: UInt64?

        /// The current printing of the Shape, determining the printing of the Editions linked to the Shape.
        /// It can be incremented by the Admin.
        pub var currentPrinting: UInt64

        /// The type of Editions that can be created from this Shape, it is determined by that of this Shape's
        /// parent Set (cached here to avoid repeated lookups when iterating over Shapes)
        pub let editionType: String

        /// This Shape's metadata dictionary, which stores agreed-upon fields and generally any additional
        /// data that needs to be stored in the Shape
        access(contract) let metadata: {String: AnyStruct}

        /// The dictionary that stores the Variant-Printing pairs inside Editions to ensure there can be
        /// at most one Edition with a given Variant-Printing pair
        access(self) let variantPrintingPairsInEditions: {String: UInt64}

        /// Struct initializer
        ///
        init(
            id: Int,
            renderID: String,
            setID: Int,
            name: String,
            metadata: {String: AnyStruct}
            ) {
            self.id = id
            self.renderID = renderID
            self.setID = setID
            self.name = name
            self.closedDate = nil
            // Initialize the currentPrinting to 1, this can be incremented by the Admin
            self.currentPrinting = 1
            // Get the Edition Type from the parent Set
            self.editionType = Pinnacle.getSet(id: setID)!.editionType
            self.metadata = metadata
            self.variantPrintingPairsInEditions = {}
        }

        /// Insert the given Variant for the current printing
        ///
        access(contract) fun insertVariantPrintingPair(_ variant: String) {
            self.variantPrintingPairsInEditions[variant] = self.currentPrinting
        }

        /// Remove the given Variant
        ///
        access(contract) fun removeVariantPrintingPair(_ variant: String) {
            self.variantPrintingPairsInEditions.remove(key: variant)
        }

        /// Check if an Edition exists with the given Variant for this Shape's current printing
        ///
        access(contract) fun variantPrintingPairExistsInEdition(_ variant: String): Bool {
            return self.variantPrintingPairsInEditions[variant] == self.currentPrinting
        }

        /// Close this Shape
        ///
        access(contract) fun close() {
            pre {
                self.closedDate == nil: "Shape is already closed"
            }
            // Set the closed date to the current block timestamp plus the undo period
            self.closedDate = UInt64(getCurrentBlock().timestamp) + Pinnacle.undoPeriod
            emit ShapeClosed(
                id: self.id,
                renderID: self.renderID,
                setID: self.setID,
                name: self.name,
                currentPrinting: self.currentPrinting,
                editionType: self.editionType
            )
        }

        /// Reopen this Shape
        ///
        /// This will fail if the undo period has expired.
        ///
        access(contract) fun reopen() {
            pre {
                self.closedDate != nil: "Shape is already open"
                self.closedDate! >= UInt64(getCurrentBlock().timestamp):
                    "Undo period has expired, Shape is permanently closed"
            }
            self.closedDate = nil
            emit EntityReactivated(entity: "Shape", id: self.id, name: self.name)
        }

        /// Update this Shape's name
        ///
        access(contract) fun updateName(_ name: String, _ setRef: &Set) {
            pre {
                name != "": "The name of a Shape cannot be an empty string"
                Pinnacle.getSet(id: self.setID)!.shapeNameExistsInSet(name) == false:
                    "A Shape with that name already exists in the Set"
            }
            // Remove the old name from the parent Set's shapes dictionary
            setRef.removeShapeName(self.name)
            // Update the name
            self.name = name
            // Add the new name to the parent Set's shapes dictionary
            setRef.insertShapeName(self.name)
            emit ShapeNameUpdated(
                id: self.id,
                renderID: self.renderID,
                setID: self.setID,
                name: self.name,
                currentPrinting: self.currentPrinting,
                editionType: self.editionType
            )
        }

        /// Increment this Shape's current printing and return the new value
        ///
        access(contract) fun incrementCurrentPrinting(): UInt64 {
            pre {
                self.closedDate == nil: "Cannot increment the current printing of a closed Shape"
            }
            self.currentPrinting = self.currentPrinting + 1
            emit ShapeCurrentPrintingIncremented(
                id: self.id,
                renderID: self.renderID,
                setID: self.setID,
                name: self.name,
                currentPrinting: self.currentPrinting,
                editionType: self.editionType
            )
            return self.currentPrinting
        }

        /// Return this Shape's metadata dictionary
        ///
        pub fun getMetadata(): {String: AnyStruct} {
            return self.metadata
        }

        /// Return this Shape's variantPrintingPairsInEditions dictionary
        ///
        pub fun getVariantPrintingPairsInEditions(): {String: UInt64} {
            return self.variantPrintingPairsInEditions
        }
    }

    /// Return the ID of the latest Shape created in the contract
    ///
    /// The ID is an incrementing integer equal to the length of the shapes array.
    ///
    pub fun getLatestShapeID(): Int {
        return Pinnacle.shapes.length
    }

    /// Return a Shape struct containing the data of the Shape with the given ID, if it exists in the contract
    ///
    pub fun getShape(id: Int): Shape? {
        pre {
            id > 0: "The ID of a Shape must be greater than zero"
        }
        return Pinnacle.getLatestShapeID() >= id ? Pinnacle.shapes[id - 1] : nil
    }

    /// Return all Shapes in the contract
    ///
    pub fun getAllShapes(): [Shape] {
        return Pinnacle.shapes
    }

    //------------------------------------------------------------
    // Edition
    //------------------------------------------------------------

    /// Struct that defines an Edition
    ///
    /// Each Edition is linked to a parent Shape.
    ///
    pub struct Edition {
        /// This Edition's unique ID
        pub let id: Int

        /// This Edition's renderID. The uniqueness of renderID is NOT required.
        pub var renderID: String

        /// The ID of the Series that this Edition's is linked to, it is determined by that of this Edition's
        /// parent Set (cached here to avoid repeated lookups when iterating over Editions)
        pub let seriesID: Int

        /// The ID of the Set that this Edition's is linked to, it is determined by that of this Edition's
        /// parent Shape's (cached here to avoid repeated lookups when iterating over Editions)
        pub let setID: Int

        /// The ID of the Shape that this Edition belongs to
        pub let shapeID: Int

        /// This Edition's Variant
        pub let variant: String?

        /// This Edition's Printing, determined by the current printing value of the parent Shape when the
        /// Edition is created
        pub let printing: UInt64

        /// The ID of the Edition Type that this Edition's is linked to, it is determined by that of this
        /// Edition's parent Shape (cached here to avoid repeated lookups when iterating over Editions)
        pub let editionTypeID: Int

        /// This Edition's description. It can be updated by the Admin.
        pub var description: String

        /// Attribute to denote an alternative class of Editions
        pub let isChaser: Bool

        /// This Edition's traits dictionary, which stores agreed-upon fields and generally any additional
        /// data that needs to be stored in the Edition
        access(contract) let traits: {String: AnyStruct}

        /// If the Edition is a Limited Edition, this value is the maximum number of NFTs that can be minted
        /// in the Edition - otherwise, this value is nil
        pub var maxMintSize: UInt64?

        /// The number of NFTs that have been minted in the Edition, this value is incremented every time a
        /// new NFT is minted
        pub var numberMinted: UInt64

        /// If the Edition is a Maturing Edition, this value is the time period that must pass starting from
        /// the Edition's creation date before the NFTs minted in the Edition can be withdrawn from the
        /// collection - otherwise, this value is nil
        pub let maturationPeriod: UInt64?

        /// This field indicates whether the Edition is currently open (closedDate is nil) or closed (has
        /// actual date).
        ///
        /// Initially, when an Edition is created, it is in an open state, allowing the minting of NFTs. Once
        /// an Edition is closed, it is no longer possible to mint NFTs from that Edition. Limited Editions
        /// are closed permanently when an Edition's number minted reaches the Edition's max mint size. On the
        /// other hand, Open/Unlimited Editions are closed by the Admin. Closing an Open/Unlimited Edition
        /// takes immediate effect, but it can be undone during the undo period. The closedDate field
        /// indicates the date when the Edition is permanently closed. This includes the undo period for
        /// Open/Unlimited Editions, but not for Limited Editions.
        pub var closedDate: UInt64?

        /// The date that the Edition was created (Unix timestamp)
        pub let creationDate: UInt64

        /// Struct initializer
        ///
        init(
            id: Int,
            renderID: String,
            shapeID: Int,
            variant: String?,
            description: String,
            isChaser: Bool,
            maxMintSize: UInt64?,
            maturationPeriod: UInt64?,
            traits: {String: AnyStruct}
        ) {
            self.id = id
            self.renderID = renderID
            self.shapeID = shapeID
            // Get setID from the parent Shape
            self.setID = Pinnacle.getShape(id: shapeID)!.setID
            // Get seriesID from the parent Set
            self.seriesID = Pinnacle.getSet(id: self.setID)!.seriesID
            self.variant = variant
            // Get the printing from the parent Shape
            self.printing = Pinnacle.getShape(id: shapeID)!.currentPrinting
            // Get editionTypeID from the parent Shape
            self.editionTypeID = Pinnacle.getEditionTypeByName(Pinnacle.getShape(id: shapeID)!.editionType)!.id
            self.description = description
            self.isChaser = isChaser
            self.traits = traits
            self.maxMintSize = maxMintSize
            self.numberMinted = 0
            self.maturationPeriod = maturationPeriod
            self.closedDate = nil
            self.creationDate = UInt64(getCurrentBlock().timestamp)
        }

        /// Check if this Edition's max mint size has been reached
        ///
        pub fun isMaxEditionMintSizeReached(): Bool {
            return self.numberMinted == self.maxMintSize
        }

        /// Close this Edition so that no more Pin NFTs can be minted in it
        ///
        /// This will fail if the Edition is already closed or if the Edition is a Limited Edition.
        ///
        access(contract) fun close() {
            pre {
                self.numberMinted != self.maxMintSize:
                    "This Edition is already closed, number of pins minted: "
                        .concat(self.maxMintSize!.toString())
                Pinnacle.getEditionType(id: self.editionTypeID)!.isLimited == false:
                    "The Edition must be an Open/Unlimited Edition"
            }
            // Set the max mint size to the number minted
            self.maxMintSize = self.numberMinted
            // Set the closed date to the current block timestamp plus the undo period
            self.closedDate = UInt64(getCurrentBlock().timestamp) + Pinnacle.undoPeriod
            emit EditionClosed(
                id: self.id,
                maxMintSize: self.maxMintSize!
            )
        }

        /// Reopen this Edition
        ///
        /// This will fail if the Edition if a Limited Edition or if the undo period has expired.
        ///
        access(contract) fun reopen() {
            pre {
                self.closedDate != nil: "Edition is already open"
                self.closedDate! >= UInt64(getCurrentBlock().timestamp):
                    "Undo period has expired, Edition Type is permanently closed"
                Pinnacle.getEditionType(id: self.editionTypeID)!.isLimited == false:
                    "The Edition must be an Open/Unlimited Edition"
            }
            self.maxMintSize = nil
            self.closedDate = nil
            emit EntityReactivated(entity: "Edition", id: self.id, name: nil)
        }

        /// Increment this Edition's number minted
        ///
        /// This is only called when a Pin NFT is minted in the Edition.
        ///
        access(contract) fun incrementNumberMinted() {
            self.numberMinted = self.numberMinted + 1
            // If the Edition reaches the max mint size (i.e., it is a Limited Edition), set the closed date
            // and emit the EditionClosed event
            if self.isMaxEditionMintSizeReached() {
                // Set the closed date to the current block timestamp. The undo period is not included because
                // it doesn't apply for Limited Editions.
                self.closedDate = UInt64(getCurrentBlock().timestamp)
                emit EditionClosed(
                    id: self.id,
                    maxMintSize: self.maxMintSize!
                )
            }
        }

        /// Decrement this Edition's number minted
        ///
        /// This is only called from the burnOpenEditionNFT Admin function.
        ///
        access(contract) fun decrementNumberMinted() {
            pre {
                self.numberMinted != self.maxMintSize:
                    "This Edition must not have been closed"
                Pinnacle.getEditionType(id: self.editionTypeID)!.isLimited == false:
                    "The Edition must be an Open/Unlimited Edition"
            }
            self.numberMinted = self.numberMinted - 1
        }

        /// Return the serial number of the NFT to be minted, the Edition's number minted + 1 if the Edition
        /// is limited, nil otherwise.
        ///
        access(contract) fun getNextSerialNumber(): UInt64? {
            return Pinnacle.getEditionType(id: self.editionTypeID)!.isLimited ? self.numberMinted + 1 : nil
        }

        /// Update this Edition's description
        ///
        access(contract) fun updateDescription(_ description: String) {
            self.description = description
            emit EditionDescriptionUpdated(
                id: self.id,
                description: self.description
            )
        }

        /// Update this Edition's Render ID
        ///
        access(contract) fun updateRenderID(_ renderID: String) {
            self.renderID = renderID
            emit EditionRenderIDUpdated(
                id: self.id,
                renderID: self.renderID
            )
        }

        /// Return this Edition's traits dictionary
        ///
        pub fun getTraits(): {String: AnyStruct} {
            return self.traits
        }
    }

    /// Return the ID of the latest Edition created in the contract.
    ///
    /// The ID is an incrementing integer equal to the length of the editions array.
    ///
    pub fun getLatestEditionID(): Int {
        return Pinnacle.editions.length
    }

    /// Return an Edition struct containing the data of the Edition with the given ID, if it exists in the
    /// contract
    ///
    pub fun getEdition(id: Int): Edition? {
        pre {
            id > 0: "The ID of an Edition must be greater than 0"
        }
        return Pinnacle.getLatestEditionID() >= id ? Pinnacle.editions[id - 1] : nil
    }

    /// Return all Editions in the contract
    ///
    pub fun getAllEditions(): [Edition] {
        return Pinnacle.editions
    }

    //------------------------------------------------------------
    // Edition Type
    //------------------------------------------------------------

    /// Struct that defines an Edition Type
    ///
    /// Each Edition Type is created independently of any other entity.
    ///
    /// The contract creates the following default Edition Types during initialization: "Genesis Edition",
    /// "Unique Edition", "Limited Edition", "Open Edition", "Starter Edition", and "Event Edition".
    ///
    pub struct EditionType {
        /// This Edition Type's unique ID
        pub let id: Int

        /// This Edition Type's unique name
        pub let name: String

        /// Indicate if the Edition Type is Limited (true) or Open/Unlimited (false)
        pub let isLimited: Bool

        /// Indicate if the Edition Type is Maturing (true) or Non-Maturing (false)
        pub let isMaturing: Bool

        /// This field indicates whether the Edition Type is currently open (closedDate is nil) or closed (has
        /// actual date).
        ///
        /// Initially, when an Edition Type is created, it is in an open state, allowing the creation of Sets.
        /// Once an Edition Type is closed, it is no longer possible to create Sets linked to that Edition
        /// Type as well as Shapes linked to those Sets and Editions linked to those Shapes. However, it is
        /// still possible to mint NFTs using the Editions already created from any Shapes. Locking an Edition
        /// Type takes immediate effect, but it can be undone during the undo period. The closedDate field
        /// indicates the date when the Edition Type is permanently closed, including the undo period.
        pub var closedDate: UInt64?

        /// Struct initializer
        ///
        init(id: Int, name: String, isLimited: Bool, isMaturing: Bool) {
            self.id = id
            self.name = name
            self.isLimited = isLimited
            self.isMaturing = isMaturing
            self.closedDate = nil
        }

        /// Close this Edition Type
        ///
        access(contract) fun close() {
            pre {
                self.closedDate == nil: "Edition type is already closed"
            }
            // Set the closed date to the current block timestamp plus the undo period
            self.closedDate = UInt64(getCurrentBlock().timestamp) + Pinnacle.undoPeriod
            emit EditionTypeClosed(
                id: self.id,
                name: self.name,
                isLimited: self.isLimited,
                isMaturing: self.isMaturing
            )
        }

        /// Reopen this Edition Type
        ///
        /// This will fail if the undo period has expired.
        ///
        access(contract) fun reopen() {
            pre {
                self.closedDate != nil: "Edition Type is already open"
                self.closedDate! >= UInt64(getCurrentBlock().timestamp):
                    "Undo period has expired, Edition Type is permanently closed"
            }
            self.closedDate = nil
            emit EntityReactivated(entity: "EditionType", id: self.id, name: self.name)
        }
    }

    /// Return the ID of the latest Edition Type created in the contract
    ///
    /// The ID is an incrementing integer equal to the length of the editionTypes array.
    ///
    pub fun getLatestEditionTypeID(): Int {
        return Pinnacle.editionTypes.length
    }

    /// Return an EditionType struct containing the data of the EditionType with the given ID, if it exists
    /// in the contract
    ///
    pub fun getEditionType(id: Int): EditionType? {
        pre {
            id > 0: "The ID of an Edition Type must be greater than 0"
        }
        return Pinnacle.getLatestEditionTypeID() >= id ? Pinnacle.editionTypes[id - 1] : nil
    }

    /// Return all Edition Types in the contract
    ///
    pub fun getAllEditionTypes(): [EditionType] {
        return Pinnacle.editionTypes
    }

    /// Return an EditionType struct containing the data of the EditionType with the given name, if it exists
    /// in the contract
    ///
    pub fun getEditionTypeByName(_ name: String): EditionType? {
        if let id = Pinnacle.editionTypeIDsByName[name] {
            return Pinnacle.getEditionType(id: id)
        }
        return nil
    }

    /// Return the ID of the Edition Type with the given name, if it exists in the contract
    ///
    pub fun getEditionTypeIDByName(_ name: String): Int? {
        return Pinnacle.editionTypeIDsByName[name]
    }

    //------------------------------------------------------------
    // Inscription
    //------------------------------------------------------------

    /// Struct that defines an Inscription
    ///
    /// Inscriptions are stored in NFTs.
    ///
    pub struct Inscription {
        /// This Inscription's ID, unique inside an NFT
        pub let id: Int

        /// The address of the account that added the Inscription, unique inside an NFT
        pub let thenOwner: Address

        /// The note that can be added to the Inscription
        pub var note: String?

        /// The date the Inscription was added to the NFT
        pub let dateAdded: UInt64

        /// This Inscription's extension dictionary, which stores any additional data that needs to be stored
        /// in the Inscription. This field has been added to accommodate potential future contract updates and
        /// facilitate new functionalities. It is not in use currently.
        access(self) let extension: {String: AnyStruct}

        /// Struct initializer
        ///
        init(
            id: Int,
            owner: Address,
            extension: {String: AnyStruct}?
        ) {
            self.id = id
            self.thenOwner = owner
            self.note = nil
            self.dateAdded = UInt64(getCurrentBlock().timestamp)
            self.extension = extension ?? {}
        }

        /// Set this Inscription's note
        ///
        access(contract) fun setNote(_ note: String?) {
            self.note = note
        }

        /// Return this Inscription's extension dictionary
        ///
        pub fun getExtension(): {String: AnyStruct} {
            return self.extension
        }
    }

    //------------------------------------------------------------
    // NFT
    //------------------------------------------------------------

    /// Resource that defines a Pin NFT
    ///
    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        /// This NFT's unique ID
        pub let id: UInt64

        /// This NFT's unique renderID. The uniqueness of renderID is not required.
        pub let renderID: String

        /// The ID of the Edition that this NFT belongs to
        pub let editionID: Int

        /// This NFT' serial number - nil if the NFT has not been minted from a Limited Edition
        pub let serialNumber: UInt64?

        /// The date that this NFT was minted (Unix timestamp)
        pub let mintingDate: UInt64

        /// This NFT's experience points balance - nil if the NFT's owner has opted out
        pub var xp: UInt64?

        /// The array where this NFT's Inscriptions are stored
        access(self) let inscriptions: [Inscription]

        /// The dictionary that allows Inscriptions to be looked up by address
        access(self) let inscriptionIDsByAddress: {Address: Int}

        /// This NFT's extension dictionary, which stores any additional data that needs to be stored in the
        /// NFT. This field has been added to accommodate potential future contract updates and facilitate new
        /// functionalities. It is not in use currently.
        access(self) let extension: {String: AnyStruct}

        /// NFT initializer
        ///
        init(editionID: Int, extension: {String: AnyStruct}?) {
            pre {
                // Check that the Edition exists and has not reached its max mint size
                Pinnacle.getLatestEditionID() >= editionID: "editionID does not exist"
                Pinnacle.getEdition(id: editionID)!.isMaxEditionMintSizeReached() == false:
                    "Max mint size (".concat(Pinnacle.getEdition(id: editionID)!.maxMintSize!.toString())
                        .concat(") reached for Edition ID = ").concat(editionID.toString())
            }
            self.id = self.uuid
            self.renderID = Pinnacle.getEdition(id: editionID)!.renderID
            self.editionID = editionID
            self.serialNumber = Pinnacle.getEdition(id: editionID)!.getNextSerialNumber()
            self.mintingDate = UInt64(getCurrentBlock().timestamp)
            self.xp = 0
            self.inscriptions = []
            self.inscriptionIDsByAddress = {}
            self.extension = extension ?? {}
            Pinnacle.totalSupply = Pinnacle.totalSupply + 1
            emit PinNFTMinted(
                id: self.id,
                renderID: self.renderID,
                editionID: self.editionID,
                serialNumber: self.serialNumber,
                maturityDate: self.getMaturityDate()
            )
        }

        /// NFT destructor
        ///
        destroy() {
            Pinnacle.totalSupply = Pinnacle.totalSupply - 1
            emit PinNFTBurned(
                id: self.id,
                editionID: self.editionID,
                serialNumber: self.serialNumber,
                xp: self.xp
            )
        }

        /// Return this NFT's maturity date if it is a Maturing Edition NFT, nil otherwise
        ///
        pub fun getMaturityDate(): UInt64? {
            let edition = Pinnacle.getEdition(id: self.editionID)!
            return edition.maturationPeriod != nil ? edition.creationDate + edition.maturationPeriod! : nil
        }

        /// Return if this NFT's is locked by maturity date.
        /// Return true if the current block timestamp is less than the lock expiry, false otherwise.
        pub fun isLocked(): Bool {
            if let maturityDate = self.getMaturityDate() {
                return maturityDate > UInt64(getCurrentBlock().timestamp)
            }
            return false
        }


        /// Return this NFT's inscriptions limit
        ///
        pub fun getInscriptionsLimit(): Int {
            return Pinnacle.inscriptionsLimits[self.id] ?? 100
        }

        /// Add an Inscription in this NFT tied to the current owner address and return its ID
        ///
        /// This function can only be called from the Collection resource that contains this NFT. It will
        /// fail if the Inscription was already added by the current owner or if the NFT has reached its
        /// max inscriptions size, which is 100 by default and can be set to a higher value by the Admin.
        ///
        access(contract) fun addCurrentOwnerInscription(_ currentOwner: Address): Int {
            pre {
                self.inscriptionIDsByAddress.containsKey(currentOwner) == false:
                    "The Inscription was already added by the current owner, date added: "
                        .concat(self.inscriptions[self.inscriptionIDsByAddress[currentOwner]!]!.dateAdded.toString())
                self.getLatestInscriptionID() < self.getInscriptionsLimit():
                    "Max Inscriptions size (".concat((self.getInscriptionsLimit()).toString())
                        .concat(") reached for NFT ID = ").concat(self.id.toString())
            }
            let inscription = Inscription(
                id: self.getLatestInscriptionID() + 1,
                owner: currentOwner,
                extension: nil
            )
            self.inscriptions.append(inscription)
            self.inscriptionIDsByAddress[currentOwner] = inscription.id
            emit NFTInscriptionAdded(
                id: inscription.id,
                owner: inscription.thenOwner,
                note: inscription.note,
                nftID: self.id,
                editionID: self.editionID
            )
            return inscription.id
        }

        /// Return a reference to the Inscription with the given ID, if it exists in the NFT
        ///
        access(contract) fun borrowInscription(id: Int): &Inscription? {
            pre {
                id > 0: "The ID of an Inscription must be greater than 0"
            }
            return self.getLatestInscriptionID() >= id ? &self.inscriptions[id - 1] as &Inscription : nil
        }

        /// Remove the current owner's Inscription from this NFT
        ///
        /// This will fail if the undo period has expired or if another Inscription has been added after the
        /// current owner's.
        ///
        access(contract) fun removeCurrentOwnerInscription(_ currentOwner: Address) {
            pre {
                self.inscriptionIDsByAddress.containsKey(currentOwner) == true:
                    "No Inscription added by the current owner"
                self.getInscriptionByAddress(currentOwner)!.id == self.getLatestInscriptionID():
                    "The Inscription to remove must be the last one added"
                self.getInscriptionByAddress(currentOwner)!.dateAdded + Pinnacle.undoPeriod >=
                    UInt64(getCurrentBlock().timestamp):
                    "Undo period has expired, Inscription is permanently added"
            }
            let inscriptionID = self.getInscriptionIDsByAddress(currentOwner)!
            self.inscriptions.removeLast()
            self.inscriptionIDsByAddress.remove(key: currentOwner)
            emit NFTInscriptionRemoved(
                id: inscriptionID,
                owner: currentOwner,
                nftID: self.id,
                editionID: self.editionID
            )
        }

        /// Update the current owner's Inscription note in this NFT
        ///
        /// This function can only be called from the Collection resource that contains this NFT and requires
        /// Admin co-signing.
        ///
        access(contract) fun updateCurrentOwnerInscriptionNote(currentOwner: Address, note: String) {
            pre {
                self.inscriptionIDsByAddress.containsKey(currentOwner) == true:
                    "Inscription must have been added by the current owner"
            }
            let inscriptionRef = self.borrowInscription(
                id: self.getInscriptionIDsByAddress(currentOwner)!
            )!
            inscriptionRef.setNote(note)
            emit NFTInscriptionUpdated(
                id: inscriptionRef.id,
                owner: currentOwner,
                note: inscriptionRef.note,
                nftID: self.id,
                editionID: self.editionID
            )
        }

        /// Toggle this NFT's ability to hold a XP balance (turned on by default) and return the XP's new value
        ///
        /// This function can only be called from the Collection resource that contains this NFT.
        ///
        /// This allows opting in or out of the NFT's ability to hold XP. If XP is nil, this will set it to 0.
        /// If XP is 0, this will set it to nil.
        ///
        access(contract) fun toggleXP(): UInt64? {
            self.xp = self.xp == nil ? 0 : nil
            emit NFTXPUpdated(id: self.id, editionID: self.editionID, xp: self.xp)
            return self.xp
        }

        /// Add experience points to this NFT and return the new XP balance
        ///
        /// This function can only be called from the Admin resource with the condition that the NFT owner
        /// has not opted out of the NFT's ability to hold XP with the toggleXP function.
        ///
        access(contract) fun addXP(_ value: UInt64): UInt64 {
            pre {
                self.xp != nil: "XP must have been previously set by the owner"
            }
            self.xp = self.xp! + value
            emit NFTXPUpdated(id: self.id, editionID: self.editionID, xp: self.xp)
            return self.xp!
        }

        /// Subtract experience points from this NFT and return the new XP balance
        ///
        /// This function can only be called from the Admin resource with the condition that the NFT owner
        /// has not opted out of the NFT's ability to hold XP with the toggleXP function.
        ///
        access(contract) fun subtractXP(_ value: UInt64): UInt64 {
            pre {
                self.xp != nil: "XP must have been previously set by the owner"
                self.xp! >= value:
                    "Cannot subtract below minimum XP of 0, current XP: ".concat(self.xp!.toString())
            }
            self.xp = self.xp! - value
            emit NFTXPUpdated(id: self.id, editionID: self.editionID, xp: self.xp)
            return self.xp!
        }

        /// Return the ID of the latest Inscription added in the NFT
        ///
        /// The ID is an incrementing integer equal to the length of the inscriptions array.
        ///
        pub fun getLatestInscriptionID(): Int {
            return self.inscriptions.length
        }

        /// Return an Inscription struct containing the data of the Inscription with the given ID, if it
        /// exists in the NFT
        ///
        pub fun getInscription(id: Int): Inscription? {
            pre {
                id > 0: "The ID of an Inscription must be greater than 0"
            }
            return self.getLatestInscriptionID() >= id ? self.inscriptions[id - 1] : nil
        }

        /// Return all Inscriptions in the NFT
        ///
        pub fun getAllInscriptions(): [Inscription] {
            return self.inscriptions
        }

        /// Return an Inscription struct containing the data of the Inscription with the given address if it
        /// exists in the NFT
        ///
        pub fun getInscriptionByAddress(_ address: Address): Inscription? {
            if let id = self.inscriptionIDsByAddress[address] {
                return self.getInscription(id: id)
            }
            return nil
        }

        /// Return the ID of the Inscription with the given address, if it exists in the NFT
        ///
        pub fun getInscriptionIDsByAddress(_ address: Address): Int? {
            return self.inscriptionIDsByAddress[address]
        }

        /// Return this NFT's inscriptionIDsByAddress dictionary
        ///
        pub fun getAllInscriptionIDsByAddresses(): {Address: Int} {
            return self.inscriptionIDsByAddress
        }

        /// Return this NFT's extension dictionary
        ///
        pub fun getExtension(): {String: AnyStruct} {
            return self.extension
        }

        /// Return the metadata view types available for this NFT
        ///
        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.Traits>(),
                Type<MetadataViews.Medias>(),
                Type<MetadataViews.Editions>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.NFTCollectionData>()
            ]
        }

        /// Resolve this NFT's metadata views
        ///
        pub fun resolveView(_ view: Type): AnyStruct? {
            post {
                result == nil || result!.getType() == view:
                    "The returned view must be of the given type or nil"
            }
            switch view {
                case Type<MetadataViews.Display>(): return self.resolveDisplayView()
                case Type<MetadataViews.ExternalURL>(): return self.resolveExternalURLView()
                case Type<MetadataViews.Traits>(): return self.resolveTraitsView()
                case Type<MetadataViews.Medias>(): return self.resolveMediasView()
                case Type<MetadataViews.Editions>(): return self.resolveEditionsView()
                case Type<MetadataViews.Serial>(): return self.resolveSerialView()
                case Type<MetadataViews.Royalties>(): return self.resolveRoyaltiesView()
                case Type<MetadataViews.NFTCollectionDisplay>(): return Pinnacle.resolveNFTCollectionDisplayView()
                case Type<MetadataViews.NFTCollectionData>(): return Pinnacle.resolveNFTCollectionDataView()
            }
            return nil
        }

        /// Resolve this NFT's Display view
        ///
        pub fun resolveDisplayView(): MetadataViews.Display {
            return MetadataViews.Display(
                name: self.getName(),
                description: self.getDescription(),
                thumbnail: self.getThumbnailPath()
            )
        }

        /// Resolve this NFT's ExternalURL view
        ///
        pub fun resolveExternalURLView(): MetadataViews.ExternalURL {
            return MetadataViews.ExternalURL("placeholder_external_url")
        }

        /// Resolve this NFT's Traits view
        ///
        pub fun resolveTraitsView(): MetadataViews.Traits {
            // Retrieve this NFT's parent Edition, Shape, Set, and Series data
            let edition = Pinnacle.getEdition(id: self.editionID)!
            let shape = Pinnacle.getShape(id: edition.shapeID)!
            let set = Pinnacle.getSet(id: edition.setID)!
            let series = Pinnacle.getSeries(id: edition.seriesID)!
            // Create a dictionary of this NFT's traits with the default metadata entries
            let traits: {String: AnyStruct} = {
                "EditionType" : Pinnacle.getEditionType(id: edition.editionTypeID)!.name,
                "SeriesName" : series.name,
                "SetName" : set.name,
                "IsChaser" : edition.isChaser,
                "Printing": edition.printing,
                "MintingDate": self.mintingDate
            }
            // If the Edition has a Variant, add the Variant trait
            if edition.variant != nil {
                traits["Variant"] = edition.variant!
            }
            // If the NFT is a Limited Edition NFT, add the SerialNumber trait
            if self.serialNumber != nil {
                traits["SerialNumber"] = self.serialNumber!
            }
            // If the NFT's Edition is a Maturing Edition, add the MaturityDate trait
            if edition.maturationPeriod != nil {
                traits["MaturityDate"] = self.getMaturityDate()!
            }
            // Add the Shape's metadata entries
            for key in shape.metadata.keys {
                traits[key] = shape.metadata[key]
            }
            // Add the Edition's traits entries
            for key in edition.traits.keys {
                traits[key] = edition.traits[key]
            }
            // Return the traits dictionary
            return MetadataViews.dictToTraits(dict: traits, excludedNames: nil)
        }

        /// Resolve this NFT's Medias view
        ///
        pub fun resolveMediasView(): MetadataViews.Medias {
            return MetadataViews.Medias(
                items: [
                    MetadataViews.Media(
                        file: MetadataViews.HTTPFile(url: "placeholder_media_url"),
                        mediaType: "image/jpeg"
                    )
                ]
            )
        }

        /// Resolve this NFT's Editions view
        ///
        pub fun resolveEditionsView(): MetadataViews.Editions {
            let edition = Pinnacle.getEdition(id: self.editionID)!
            let shape = Pinnacle.getShape(id: edition.shapeID)!
            let set = Pinnacle.getSet(id: edition.setID)!
            // Assemble the name
            let editionName = shape.name.concat(" [").concat(set.name)
                .concat(edition.variant != nil ? ", ".concat(edition.variant!) : "")
                .concat(edition.printing > 1 ? ", Printing #".concat(edition.printing.toString()) : "")
                .concat("]")
            // Create and return the Editions view
            return MetadataViews.Editions(
                [MetadataViews.Edition(
                    name: editionName,
                    number: self.serialNumber ?? 0,
                    max: edition.maxMintSize
                    )
                ]
            )
        }

        /// Resolve this NFT's Serial view if it is a Limited Edition NFT - return nil otherwise
        ///
        pub fun resolveSerialView(): MetadataViews.Serial? {
            return Pinnacle.getEditionType(id: Pinnacle.getEdition(id: self.editionID)!.editionTypeID)!.isLimited ?
                MetadataViews.Serial(self.serialNumber!) : nil
        }

        /// Resolve this NFT's Royalties view
        ///
        pub fun resolveRoyaltiesView(): MetadataViews.Royalties {
            let royaltyReceiver: Capability<&AnyResource{FungibleToken.Receiver}> =
                getAccount(Pinnacle.royaltyAddress).getCapability<&AnyResource{FungibleToken.Receiver}>(
                    MetadataViews.getRoyaltyReceiverPublicPath())
            return MetadataViews.Royalties(
                royalties: [
                    MetadataViews.Royalty(
                        receiver: royaltyReceiver,
                        cut: 0.05,
                        description: "placeholder_royalty_description"
                    )
                ]
            )
        }

        /// Return this NFT's name
        ///
        pub fun getName(): String {
            // Retrieve this NFT's parent Edition, Shape, and Set data
            let edition = Pinnacle.getEdition(id: self.editionID)!
            let shape = Pinnacle.getShape(id: edition.shapeID)!
            let set = Pinnacle.getSet(id: edition.setID)!
            // Assemble and return the name
            return shape.name.concat(self.serialNumber != nil ? " [#".concat(self.serialNumber!.toString())
                .concat("/").concat(edition.maxMintSize!.toString()).concat("] [") : " [").concat(set.name)
                .concat(edition.variant != nil ? ", ".concat(edition.variant!) : "")
                .concat(edition.printing > 1 ? ", Printing #".concat(edition.printing.toString()) : "")
                .concat("]")
        }

        /// Return this NFT's description
        ///
        /// The description is composed of the end-user license URL, the description of this NFT's Edition,
        /// and this NFT's concatenated Inscription notes if there any, ordered by the date they have been
        /// added. It is generally intended that the Inscription notes are human-readable and that they are
        /// written in a way that makes sense when concatenated, avoiding escape chars and with each
        /// Inscription's details included as needed. Inscription notes require both the owner's and the
        /// Admin's approval to be updated (see the updateNFTInscriptionNote function in the Collection
        /// resource).
        ///
        pub fun getDescription(): String {
            var notes = ""
            for inscription in self.inscriptions {
                // If the Inscription is permanently added and has a note, add it to the notes string
                if inscription.dateAdded + Pinnacle.undoPeriod < UInt64(getCurrentBlock().timestamp) {
                    if let note = inscription.note {
                        notes.concat("\n\n").concat(note)
                    }
                }
            }
            return Pinnacle.endUserLicenseURL.concat("\n\n")
                .concat(Pinnacle.getEdition(id: self.editionID)!.description)
                .concat(notes != "" ? "\n\n".concat(notes) : "")
        }

        /// Return this NFT's thumbnail path
        ///
        pub fun getThumbnailPath(): MetadataViews.HTTPFile {
            return MetadataViews.HTTPFile(url:"placeholder_thumbnail_path")
        }

        /// Return an asset path
        ///
        pub fun getAssetPath(): String {
            return "placeholder_pinnacle_base_asset_path"
        }

        /// Return an image path
        ///
        pub fun getImagePath(): String {
            return "placeholder_image_path"
        }

        /// Return a video path
        ///
        pub fun getVideoPath(): String {
            return "placeholder_video_path"
        }

        /// Return a Pin path
        ///
        pub fun getPinPath(): String {
            return "placeholder_pinnacle_pin_path"
        }
    }

    //------------------------------------------------------------
    // Collection
    //------------------------------------------------------------

    /// A public Collection interface that allows Pin NFTs to be borrowed
    ///
    pub resource interface PinNFTCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowNFTSafe(id: UInt64): &NonFungibleToken.NFT?
        pub fun borrowPinNFT(id: UInt64): &Pinnacle.NFT?
    }

    /// Resource that defines a Pinnacle NFT Collection
    ///
    pub resource Collection:
        NonFungibleToken.Provider,
        NonFungibleToken.Receiver,
        NonFungibleToken.CollectionPublic,
        MetadataViews.ResolverCollection,
        PinNFTCollectionPublic
    {
        /// Dictionary of NFT conforming tokens
        /// NFT is a resource type with a UInt64 ID field
        ///
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        /// Collection initializer
        ///
        init() {
            self.ownedNFTs <- {}
        }

        /// Collection destructor
        ///
        destroy() {
            destroy self.ownedNFTs
        }

        /// Remove an NFT from the Collection and move it to the caller
        ///
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID)
                ?? panic("No NFT with such ID in the Collection")
            let nft <- token as! @NFT
            // If the NFT was minted from a Maturing Edition, check that the Edition's maturation period has
            // expired counting from the Edition's creation date - if not, the NFT cannot be withdrawn yet.
            // The Edition's maturation period is a parameter provided when creating the Edition that cannot
            // be changed later and the creation date is set to the timestamp of the block where the Edition
            // is created.
            if let maturityDate = nft.getMaturityDate() {
                assert(maturityDate <= UInt64(getCurrentBlock().timestamp),
                    message: "This is a Maturing Edition NFT for which the maturation period has not expired yet, maturity date: "
                        .concat(maturityDate.toString()).concat(", current timestamp: ")
                        .concat(UInt64(getCurrentBlock().timestamp).toString()))
            }
            emit Withdraw(id: nft.id, from: self.owner?.address)
            return <- nft
        }

        /// Withdraw the tokens with given IDs and returns them as a Collection
        ///
        pub fun batchWithdraw(ids: [UInt64]): @NonFungibleToken.Collection {
            // Create an empty Collection
            var batchCollection <- create Collection()
            // Iterate through the ids and withdraw them from the Collection
            for id in ids {
                batchCollection.deposit(token: <-self.withdraw(withdrawID: id))
            }
            // Return the withdrawn tokens
            return <- batchCollection
        }

        /// Deposit an NFT into this Collection
        ///
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @Pinnacle.NFT
            let id: UInt64 = token.id
            // Add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token
            emit Deposit(id: id, to: self.owner?.address)
            destroy oldToken
        }

        /// Deposit the NFTs from a Collection into this Collection
        ///
        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {
            self.batchDepositWorker(self.deposit, tokens.withdraw, <- tokens)
        }

        /// Worker function for batchDeposit
        ///
        access(self) fun batchDepositWorker(
            _ deposit: ((@NonFungibleToken.NFT): Void),
            _ withdraw: ((UInt64): @NonFungibleToken.NFT),
            _ collection: @NonFungibleToken.Collection) {
            // Iterate through the NFT IDs in the Collection without allocating an array as is the case when
            // calling .keys (more scalable)
            collection.ownedNFTs.forEachKey(
                fun(key: UInt64): Bool {
                    deposit(token: <- withdraw(withdrawID: key))
                    return true
                }
            )
            // Destroy the empty Collection
            destroy collection
        }

        /// Add an Inscription in the NFT with the specified ID for the current owner and return the
        /// Inscription ID. The Inscription becomes permanent after the undo period has expired.
        ///
        pub fun addNFTInscription(id: UInt64): Int {
            pre {
                self.owner != nil: "Collection must be owned by an account"
            }
            return self.borrowPinNFT(id: id)!.addCurrentOwnerInscription(self.owner!.address)
        }

        /// Remove the current owner's Inscription from the NFT with the specified ID
        ///
        /// This will fail if the undo period has expired or if another Inscription has been added after the
        /// current owner's.
        ///
        pub fun removeNFTInscription(id: UInt64) {
            self.borrowPinNFT(id: id)!.removeCurrentOwnerInscription(self.owner!.address)
        }

        /// Update the note in the current owner's Inscription in the NFT with the specified ID. This requires
        /// Admin co-signing in the form of passing a reference to the Admin resource, and is generally
        /// intended to be called only when adding a note to the Inscription for the first time or appending
        /// to an existing note, with the content of the note being human-readable and sanitized off-chain.
        /// The note is part of the NFT's description returned in the Display view (see the getDescription
        /// function in the NFT resource).
        ///
        /// This will fail if the Inscription was not previously added by the current owner.
        ///
        pub fun updateNFTInscriptionNote(id: UInt64, note: String, adminRef: &Admin) {
            self.borrowPinNFT(id: id)!.updateCurrentOwnerInscriptionNote(
                currentOwner: self.owner!.address,
                note: note
            )
        }

        /// Toggle the XP of the NFT with the specified ID and return the new XP value.
        ///
        /// If this NFT's XP has been previously activated, this will deactivate it. It will remain possible
        /// to reactivate XP but XP will be reinitialized to 0.
        ///
        pub fun toggleNFTXP(id: UInt64): UInt64? {
            return self.borrowPinNFT(id: id)!.toggleXP()
        }

        /// Activate or deactivate the XP of all the NFTs in this Collection
        ///
        pub fun batchToggleXP(_ activateAll: Bool) {
            self.batchToggleXPWorker(self.borrowPinNFT, activateAll)
        }

        /// Worker function for batchToggleXP
        ///
        access(self) fun batchToggleXPWorker(_ borrowPinNFT: ((UInt64): &Pinnacle.NFT?), _ activateAll: Bool) {
            // Iterate through the NFT IDs in the Collection without allocating an array as is the case when
            // calling .keys (more scalable)
            self.ownedNFTs.forEachKey(
                fun(key: UInt64): Bool {
                    let nftRef = borrowPinNFT(id: key)!
                    if activateAll && nftRef.xp == nil || !activateAll && nftRef.xp != nil {
                        nftRef.toggleXP()
                    }
                    return true
                }
            )
        }

        /// Return an array of the NFT IDs that are in the Collection
        ///
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        /// Return a reference to an NFT in the Collection
        ///
        /// This function panics if the NFT does not exist in this Collection.
        ///
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            let nftRef = self.borrowNFTSafe(id: id)
                ?? panic("Could not borrow a reference to the NFT with the specified ID")
            return nftRef
        }

        /// Return a reference to an NFT in the Collection
        ///
        /// This function returns nil if the NFT does not exist in this Collection.
        ///
        pub fun borrowNFTSafe(id: UInt64): &NonFungibleToken.NFT? {
            return &self.ownedNFTs[id] as &NonFungibleToken.NFT?
        }

        /// Return a reference to an NFT in the Collection typed as Pinnacle.NFT
        ///
        /// This function returns nil if the NFT does not exist in this Collection.
        ///
        /// This function exposes all Pinnacle.NFT's fields and functions, though there are functions that
        /// modify the xp and inscriptions fields and those functions are declared with the access(contract)
        /// modifier so that they can only be called in the scope of this contract through the corresponding
        /// wrapper functions defined in the Collection and Admin resources.
        ///
        pub fun borrowPinNFT(id: UInt64): &Pinnacle.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorized reference to allow downcasting
                let nftRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return nftRef as! &Pinnacle.NFT
            }
            return nil
        }

        /// Return a reference to an NFT in this Collection typed as MetadataViews.Resolver
        ///
        /// This function panics if the NFT does not exist in this Collection.
        ///
        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nftRef = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            return nftRef as! &Pinnacle.NFT
        }
    }

    /// Create an empty Collection for Pinnacle NFTs and return it to the caller
    ///
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    /// Return a Collection Public reference to the Collection owned by the account with the specified address
    ///
    pub fun borrowCollectionPublic(
        owner: Address,
        _ publicPathID: String?
    ): &Pinnacle.Collection{Pinnacle.PinNFTCollectionPublic}? {
        return getAccount(owner).getCapability(
            publicPathID != nil ? PublicPath(identifier: publicPathID!)! : Pinnacle.CollectionPublicPath)
                .borrow<&Pinnacle.Collection{Pinnacle.PinNFTCollectionPublic}>()
    }

    //------------------------------------------------------------
    // Admin
    //------------------------------------------------------------

    /// Interface to mediate NFT minting from the Admin resource
    ///
    pub resource interface NFTMinter {
        pub fun mintNFT(editionID: Int, extension: {String: String}?): @Pinnacle.NFT
    }

    /// Resource that defines an Admin
    ///
    /// The Admin allows managing entities in the contract and minting Pinnacle NFTs.
    ///
    pub resource Admin: NFTMinter {
        /// Create a Series and return its ID
        ///
        /// This is irreversible, it will not be possible to remove the Series once it is created
        /// (no undo period).
        ///
        pub fun createSeries(name: String): Int {
            pre {
                name != "": "The name of a Series cannot be an empty string"
                Pinnacle.seriesIDsByName.containsKey(name) == false: "A Series with that name already exists"
            }
            let series = Series(id: Pinnacle.getLatestSeriesID() + 1, name: name)
            Pinnacle.series.append(series)
            Pinnacle.seriesIDsByName[name] = series.id
            emit SeriesCreated(id: series.id, name: series.name)
            return series.id
        }

        /// Return a reference to the Series with the given ID, if it exists in the contract
        ///
        access(self) fun borrowSeries(id: Int): &Series? {
            pre {
                id > 0: "The ID of a Series must be greater than 0"
            }
            return Pinnacle.getLatestSeriesID() >= id ? &Pinnacle.series[id - 1] as &Series : nil
        }

        /// Lock a Series
        ///
        /// This is irreversible after the undo period is over. It will not be possible to create new Sets in
        /// the Series.
        ///
        /// @param id: The ID of the Series to lock.
        /// @param undo: A boolean to indicate whether to unlock the Series within the undo period.
        ///
        pub fun lockSeries(id: Int, undo: Bool) {
            undo ? self.borrowSeries(id: id)!.unlock() : self.borrowSeries(id: id)!.lock()
        }

        /// Update a Series's name
        ///
        pub fun updateSeriesName(id: Int, name: String) {
            self.borrowSeries(id: id)!.updateName(name)
        }

        /// Create a Set and return its ID
        ///
        /// This is irreversible, it will not be possible to remove the Set once it is created
        /// (no undo period).
        ///
        pub fun createSet(renderID: String, name: String, editionType: String, seriesID: Int): Int {
            pre {
                // Check that renderID is valid
                (renderID != ""): "The renderID of a Set cannot be an empty string"
                // Check that name is valid
                name != "": "The name of a Set cannot be an empty string"
                Pinnacle.setIDsByName.containsKey(name) == false: "A Set with that name already exists"
                // Check that editionType is valid
                Pinnacle.editionTypeIDsByName.containsKey(editionType): "No such Edition Type"
                Pinnacle.getEditionTypeByName(editionType)!.closedDate == nil: "Edition Type is closed"
                // Check that seriesID is valid
                Pinnacle.getLatestSeriesID() >= seriesID: "seriesID does not exist"
                Pinnacle.getSeries(id: seriesID)!.lockedDate == nil:
                    "Cannot create a Set linked to a locked Series"
            }
            let set = Set(
                id: Pinnacle.getLatestSetID() + 1,
                renderID: renderID,
                name: name,
                editionType: editionType,
                seriesID: seriesID
            )

            emit SetCreated(id: set.id, renderID: set.renderID, name: set.name, seriesID: set.seriesID, editionType: set.editionType)
            Pinnacle.sets.append(set)
            Pinnacle.setIDsByName[name] = set.id
            emit SetCreated(id: set.id, renderID: set.renderID, name: set.name, seriesID: set.seriesID, editionType: set.editionType)
            return set.id
        }

        /// Return a reference to the Set with the given ID, if it exists in the contract
        ///
        access(self) fun borrowSet(id: Int): &Set? {
            pre {
                id > 0: "The ID of a Set must be greater than 0"
            }
            return Pinnacle.getLatestSetID() >= id ? &Pinnacle.sets[id - 1] as &Set : nil
        }

        /// Lock a Set
        ///
        /// This is irreversible after the undo period is over. It will not be possible to create new Shapes
        /// in the Set.
        ///
        /// @param id: The ID of the Set to lock.
        /// @param undo: A boolean to indicate whether to unlock the Set within the undo period.
        ///
        pub fun lockSet(id: Int, undo: Bool) {
            undo ? self.borrowSet(id: id)!.unlock() : self.borrowSet(id: id)!.lock()
        }

        /// Update a Set's name
        ///
        pub fun updateSetName(id: Int, name: String) {
            self.borrowSet(id: id)!.updateName(name)
        }

        /// Create a Shape and return its ID
        ///
        /// This is irreversible, it will not be possible to remove the Shape once it is created
        /// (no undo period).
        ///
        pub fun createShape(
            renderID: String,
            setID: Int,
            name: String,
            metadata: {String: AnyStruct}): Int {
            pre {
                // Check that renderID is valid
                (renderID != ""): "The renderID of a Shape cannot be an empty string"

                // Check that setID is valid
                (Pinnacle.getLatestSetID() >= setID): "setID does not exist"
                (Pinnacle.getSet(id: setID)!.lockedDate == nil): "Cannot create a Shape with a locked Set"
                (Pinnacle.getEditionTypeByName(Pinnacle.getSet(id: setID)!.editionType)!.closedDate == nil):
                    "Edition Type is closed"
                // Check that name is valid
                (name != ""): "The name of a Shape cannot be an empty string"
                (Pinnacle.getSet(id: setID)!.shapeNameExistsInSet(name) == false):
                    "A Shape with that name already exists in the Set"
                // Check that metadata is valid
                (metadata.containsKey("Franchises") == true
                    && metadata["Franchises"]!.isInstance(Type<[String]>())):
                    "Franchises is required and must be a string array"
                (metadata.containsKey("Studios") == true && metadata["Studios"]!.isInstance(Type<[String]>())):
                    "Studios is required and must be a string array"
                (metadata.containsKey("RoyaltyCodes") == true &&
                    metadata["RoyaltyCodes"]!.isInstance(Type<[String]>())):
                    "RoyaltyCodes is required and must be a string array"
                (metadata.containsKey("Characters") == false || metadata["Characters"]!.isInstance(Type<[String]>())):
                    "Characters must be a string array"
                (metadata.containsKey("Location") == false || metadata["Location"]!.isInstance(Type<String>())):
                    "Location must a string"
                (metadata.containsKey("EventName") == false || metadata["EventName"]!.isInstance(Type<String>())):
                    "EventName must a string"
            }
            // Check that metadata contains only strings or string arrays, that the keys are valid, and
            // convert strings to string arrays for the ShapeCreated event because events don't support
            // {String: AnyStruct} parameters
            let convertedMetadata: {String: [String]} = {}
            let defaultTraits = {"EditionType" : true, "SeriesName" : true, "SetName" : true,
                "SerialNumber" : true, "IsChaser" : true, "Variant": true, "Printing": true,
                "MintingDate": true, "MaturityDate": true}
            for key in metadata.keys {
                assert(metadata[key]!.isInstance(Type<String>()) || metadata[key]!.isInstance(Type<[String]>()),
                    message: "Metadata values must be strings or string arrays")
                assert(defaultTraits.containsKey(key) == false,
                    message: "Metadata key cannot already exist in the default traits dictionary")
                convertedMetadata[key] = metadata[key]!.isInstance(Type<String>()) == true ?
                    [metadata[key]! as! String] : metadata[key]! as! [String]
            }
            // Create the Shape
            let shape = Shape(
                id: Pinnacle.getLatestShapeID() + 1,
                renderID: renderID,
                setID: setID,
                name: name,
                metadata: metadata
            )
            Pinnacle.shapes.append(shape)
            // Insert the new Shape's name in the parent Set's shapeNames dictionary
            self.borrowSet(id: setID)!.insertShapeName(name)
            // Emit the ShapeCreated event with the converted metadata {String: [String]} dictionary
            emit ShapeCreated(
                id: shape.id,
                renderID: shape.renderID,
                setID: shape.setID,
                name: shape.name,
                editionType: shape.editionType,
                metadata: convertedMetadata
            )
            return shape.id
        }

        /// Return a reference to the Shape with the given ID, if it exists in the contract
        ///
        access(self) fun borrowShape(id: Int): &Shape? {
            pre {
                id > 0: "The ID of a Shape must be greater than 0"
            }
            return Pinnacle.getLatestShapeID() >= id ? &Pinnacle.shapes[id - 1] as &Shape : nil
        }

        /// Close a Shape
        ///
        /// This is irreversible after the undo period is over. It will not be possible to create new Editions
        /// in the Shape.
        ///
        /// @param id: The ID of the Shape to close.
        /// @param undo: A boolean to indicate whether to reopen the Shape within the undo period.
        ///
        pub fun closeShape(id: Int, undo: Bool) {
            undo ? self.borrowShape(id: id)!.reopen() : self.borrowShape(id: id)!.close()
        }

        /// Update a Series's name
        ///
        pub fun updateShapeName(id: Int, name: String) {
            let shapeRef = self.borrowShape(id: id)!
            shapeRef.updateName(name, self.borrowSet(id: shapeRef.setID)!)
        }

        /// Increment a Shape's current printing
        ///
        pub fun incrementShapeCurrentPrinting(id: Int): UInt64 {
            return self.borrowShape(id: id)!.incrementCurrentPrinting()
        }

        /// Create an Edition and return its ID
        ///
        /// This becomes irreversible once NFTs have been minted from the Edition or another Edition has been
        /// created in the contract.
        ///
        pub fun createEdition(
            renderID: String,
            shapeID: Int,
            variant: String?,
            description: String,
            isChaser: Bool,
            maxMintSize: UInt64?,
            maturationPeriod: UInt64?,
            traits: {String: AnyStruct}): Int {
            pre {
                // Check that renderID is valid
                (renderID != ""): "The renderID of a Shape cannot be an empty string"
                // Check that shapeID is valid
                (Pinnacle.getLatestShapeID() >= shapeID): "shapeID does not exist"
                (Pinnacle.getShape(id: shapeID)!.closedDate == nil):
                    "Cannot create an Edition with a closed Shape"
                (Pinnacle.getEditionTypeByName(Pinnacle.getShape(id: shapeID)!.editionType)!.closedDate == nil):
                    "Edition type is closed"
                // Check that description is valid
                (description != ""): "The description of an Edition cannot be an empty string"
                // Check that variant is valid
                (variant == nil || Pinnacle.variants.containsKey(variant!) == true):
                    "Variant does not exist"
                (Pinnacle.getShape(id: shapeID)!.variantPrintingPairExistsInEdition(
                    variant ?? "Standard") == false):
                    "Variant - printing pair already exists in an Edition"
                // Check that maxMintSize is not zero
                (maxMintSize != 0): "Max mint size cannot be equal to zero"
                // Check that traits is valid
                (traits.containsKey("Materials") == true && traits["Materials"]!.isInstance(Type<[String]>())):
                    "Materials is required and must be a string array"
                (traits.containsKey("Size") == true && traits["Size"]!.isInstance(Type<String>())):
                    "Size is required and must be a string"
                (traits.containsKey("Thickness") == true && traits["Thickness"]!.isInstance(Type<String>())):
                    "Thickness is required and must be a string"
                (traits.containsKey("Effects") == false || traits["Effects"]!.isInstance(Type<[String]>())):
                    "Effects must be a string array"
                (traits.containsKey("Color") == false || traits["Color"]!.isInstance(Type<String>())):
                    "Color must be a string"
            }
            let editionType = Pinnacle.getEditionTypeByName(
                Pinnacle.getShape(id: shapeID)!.editionType)!
            // Check that max mint size is valid
            if editionType.isLimited {
                assert(maxMintSize != nil,
                    message: "Only Limited Editions can be created in this Shape, maxMintSize cannot be nil")
            } else {
                assert(maxMintSize == nil,
                    message: "Limited Editions cannot be created in this Shape, maxMintSize must be nil")
            }
            // Check that the maturation period is not nil for Maturing Editions and nil otherwise. Note that
            // it may be set to zero, which is beneficial for creating Editions that don't undergo maturation
            // but still fall under the Maturing Edition category (for example, this might apply to certain
            // Event Editions).
            if editionType.isMaturing {
                assert(maturationPeriod != nil,
                    message: "Only Maturing Editions can be created in this Shape, maturationPeriod cannot be nil")
            } else {
                assert(maturationPeriod == nil,
                    message: "Maturing Editions cannot be created in this Shape, maturationPeriod must be nil")
            }
            // Check that traits contains only strings or string arrays, that the keys are valid, and convert
            // strings to string arrays for the EditionCreated event because events don't support
            // {String: AnyStruct} parameters
            let convertedTraits: {String: [String]} = {}
            let shapeMetadata = Pinnacle.getShape(id: shapeID)!.metadata
            let defaultTraits = {"EditionType" : true, "SeriesName" : true, "SetName" : true,
                "SerialNumber" : true, "IsChaser" : true, "Variant": true, "Printing": true,
                "MintingDate": true, "MaturityDate": true}
            for key in traits.keys {
                assert(traits[key]!.isInstance(Type<String>()) || traits[key]!.isInstance(Type<[String]>()),
                    message: "Trait values must be strings or string arrays")
                assert(defaultTraits.containsKey(key) == false,
                    message: "Trait key cannot already exist in the default traits dictionary")
                assert(shapeMetadata.containsKey(key) == false,
                    message: "Trait key cannot already exist in the Shape's metadata dictionary")
                convertedTraits[key] = traits[key]!.isInstance(Type<String>()) == true ?
                    [traits[key]! as! String] : traits[key]! as! [String]
            }
            // Create the Edition
            let edition = Edition(
                id: Pinnacle.getLatestEditionID() + 1,
                renderID: renderID,
                shapeID: shapeID,
                variant: variant,
                description: description,
                isChaser: isChaser,
                maxMintSize: maxMintSize,
                maturationPeriod: maturationPeriod,
                traits: traits,
            )
            Pinnacle.editions.append(edition)
            // Insert the Variant in the parent Shape for the current printing
            self.borrowShape(id: shapeID)!.insertVariantPrintingPair(variant ?? "Standard")
            // Emit the EditionCreated event with the converted traits {String: [String]} dictionary
            emit EditionCreated(
                id: edition.id,
                renderID: edition.renderID,
                seriesID: edition.seriesID,
                setID: edition.setID,
                shapeID: edition.shapeID,
                variant: edition.variant,
                printing: edition.printing,
                editionTypeID: edition.editionTypeID,
                description: edition.description,
                isChaser: edition.isChaser,
                maxMintSize: edition.maxMintSize,
                maturationPeriod: edition.maturationPeriod,
                traits: convertedTraits
            )
            return edition.id
        }

        /// Return a reference to the Edition with the given ID, if it exists in the contract
        ///
        access(self) fun borrowEdition(id: Int): &Edition? {
            pre {
                id > 0: "The ID of an Edition must be greater than zero"
            }
            return Pinnacle.getLatestEditionID() >= id ? &Pinnacle.editions[id - 1] as &Edition : nil
        }

        /// Close or remove an Open/Unlimited Edition
        ///
        /// This is irreversible after the undo period is over. It will no longer be possible to mint NFTs
        /// from the Edition. This will fail if the Edition is Limited.
        ///
        pub fun closeEdition(id: Int) {
            self.borrowEdition(id: id)!.close()
        }

        /// Remove an Edition
        ///
        /// This will fail if NFTs have been minted from the Edition or the Edition is not the last one that
        /// was created in the contract.
        ///
        pub fun removeEdition(id: Int) {
            let editionRef = self.borrowEdition(id: id)!
            assert(editionRef.numberMinted == 0 && id == Pinnacle.getLatestEditionID(),
                message: "Cannot remove an Edition that has minted NFTs and is not the last one created")
            self.borrowShape(id: editionRef.shapeID)!
                .removeVariantPrintingPair(editionRef.variant ?? "Standard")
            emit EditionRemoved(
                id: id
            )
            Pinnacle.editions.removeLast()
        }

        /// Reopen an Open/Unlimited Edition
        ///
        /// This will fail if the Edition is a Limited Edition or if the undo period has expired.
        ///
        pub fun reopenEdition(id: Int) {
            self.borrowEdition(id: id)!.reopen()
        }

        /// Update an Edition's description
        ///
        pub fun updateEditionDescription(id: Int, description: String) {
            self.borrowEdition(id: id)!.updateDescription(description)
        }

        /// Update an Edition's renderID
        ///
        pub fun updateEditionRenderID(id: Int, renderID: String) {
            self.borrowEdition(id: id)!.updateRenderID(renderID)
        }

        /// Create an Edition Type and return its ID
        ///
        /// This is irreversible, it will not be possible to remove the Edition Type once it is created
        /// (no undo period).
        ///
        pub fun createEditionType(name: String, isLimited: Bool, isMaturing: Bool): Int {
            pre {
                name != "": "The name of an Edition Type cannot be an empty string"
                Pinnacle.editionTypeIDsByName.containsKey(name) == false:
                    "An Edition Type with that name already exists"
            }
            let editionType = EditionType(
                id: Pinnacle.getLatestEditionTypeID() + 1,
                name: name,
                isLimited: isLimited,
                isMaturing: isMaturing
            )
            Pinnacle.editionTypes.append(editionType)
            Pinnacle.editionTypeIDsByName[name] = editionType.id
            emit EditionTypeCreated(
                id: editionType.id,
                name: name,
                isLimited: isLimited,
                isMaturing: isMaturing
            )
            return editionType.id
        }

        /// Return a reference to the Edition Type with the given ID, if it exists in the contract
        ///
        access(self) fun borrowEditionType(id: Int): &EditionType? {
            pre {
                id > 0: "The ID of an Edition Type must be greater than zero"
            }
            return Pinnacle.getLatestEditionTypeID() >= id ? &Pinnacle.editionTypes[id - 1] as &EditionType : nil
        }

        /// Close an Edition Type
        ///
        /// This is irreversible after the undo period is over. It will not be possible to create new Shapes
        /// and Editions with the dependent Sets and Shapes, even if they are unlocked/open. The dependent
        /// Sets and Shapes should thus be locked/closed to avoid confusion. This can be done automatically
        /// by setting the proper flags to true when calling the closeEditionType function. All the Sets and
        /// Shapes stored in the contract are iterated over rather than just the dependent ones. This is
        /// because closing an Edition Type is a rare operation and it is anticipated that the decreased
        /// contract size and gas consumption of the more frequent create entity operations are preferable to
        /// maintaining separate Sets and Shapes arrays in each Edition Type. It is also possible to lock or
        /// close the dependent Sets and Shapes individually by calling the lock or close function on each of
        /// them after determining the IDs off-chain.
        ///
        /// @param id: The ID of the Edition Type to close.
        /// @param lockDependentSets: A boolean to indicate whether dependent Sets should be closed
        /// automatically.
        /// @param closeDependentShapes: Same purpose as the lockDependentSets param but for Shapes.
        ///
        pub fun closeEditionType(
            id: Int,
            lockDependentSets: Bool,
            closeDependentShapes: Bool
        ): {String: [Int]} {
            let editionTypeRef = self.borrowEditionType(id: id)!
            editionTypeRef.close()
            let setsLocked: [Int] = []
            if lockDependentSets {
                for index, set in Pinnacle.sets {
                let setRef = self.borrowSet(id: index + 1)!
                    if setRef.lockedDate == nil && setRef.editionType == editionTypeRef.name {
                        setRef.lock()
                        setsLocked.append(setRef.id)
                    }
                }
            }
            let shapesClosed: [Int] = []
            if closeDependentShapes {
                for index, shape in Pinnacle.shapes {
                    let shapeRef = self.borrowShape(id: index + 1)!
                    if shapeRef.closedDate == nil && shapeRef.editionType == editionTypeRef.name {
                        shapeRef.close()
                        shapesClosed.append(shapeRef.id)
                    }
                }
            }
            return {"DependentSetsLocked": setsLocked, "DependentShapesClosed": shapesClosed}
        }

        /// Reopen an Edition Type
        ///
        /// This will fail if the undo period has expired. This will not unlock dependent Sets or reopen
        /// dependent Shapes that may have been locked or closed when closing the Edition Type. This can be
        /// done separately using the lockSet and reopenShape functions with the undo flag set to true, if
        /// the undo period has not expired.
        ///
        pub fun reopenEditionType(id: Int) {
            self.borrowEditionType(id: id)!.reopen()
        }

        /// Insert a Variant in the variants dictionary
        ///
        /// This is irreversible, it will not be possible to remove the Variant once it is inserted
        /// (no undo period). Furthermore, Variants cannot be closed.
        ///
        pub fun insertVariant(name: String) {
            pre {
                name != "": "The name of a Variant cannot be an empty string"
                Pinnacle.variants.containsKey(name) == false: "A Variant with that name already exists"
            }
            Pinnacle.variants[name] = true
            emit VariantInserted(name: name)
        }

        /// Mint a Pin NFT in the Edition with the given ID and return it to the caller
        ///
        pub fun mintNFT(editionID: Int, extension: {String: String}?): @Pinnacle.NFT {
            let pinNFT <- create NFT(editionID: editionID, extension: extension)
            self.borrowEdition(id: editionID)!.incrementNumberMinted()
            return <- pinNFT
        }

        /// Burn an Open/Unlimited Edition Pin NFT and decrement the Edition's number minted
        ///
        /// Any account can burn an NFT it owns with the destroy keyword, the purpose of this function is to
        /// allow the Admin to decrement the Edition's number minted while burning an Open Edition NFT in an
        /// Edition that has not been closed.
        ///
        pub fun burnOpenEditionNFT(_ nft: @NonFungibleToken.NFT) {
            let nft <- nft as! @Pinnacle.NFT
            // Decrement the number minted in the Edition. This will fail if the Edition is a Limited Edition.
            self.borrowEdition(id: nft.editionID)!.decrementNumberMinted()
            emit OpenEditionNFTBurned(id: nft.id, editionID: nft.editionID)
            destroy nft
        }

        /// Set a limit on the number entries that can be added to the inscriptions of the NFT with the given
        /// ID (default is 100)
        ///
        pub fun setNFTInscriptionsLimit(
            nftID: UInt64,
            limit: Int,
            owner: Address,
            collectionPublicPathID: String?
        ) {
            pre {
                limit > 100: "The limit must be greater than the default value of 100"
            }
            let collectionPublicRef =  Pinnacle.borrowCollectionPublic(
                owner: owner,
                collectionPublicPathID
            )
            assert(collectionPublicRef!.borrowPinNFT(id: nftID) != nil,
                message: "No NFT with such ID in the Collection")
            Pinnacle.inscriptionsLimits[nftID] = limit
        }

        /// Add XP to an NFT and return the NFT's new XP balance
        ///
        pub fun addXPtoNFT(
            nftID: UInt64,
            owner: Address,
            collectionPublicPathID: String?,
            value: UInt64
        ): UInt64 {
            return Pinnacle.borrowCollectionPublic(owner: owner, collectionPublicPathID)!
                .borrowPinNFT(id: nftID)!
                .addXP(value)
        }

        /// Remove XP from an NFT and return the NFT's new XP balance
        ///
        pub fun subtractXPfromNFT(
            nftID: UInt64,
            owner: Address,
            collectionPublicPathID: String?,
            value: UInt64
        ): UInt64 {
            return Pinnacle.borrowCollectionPublic(owner: owner, collectionPublicPathID)!
                .borrowPinNFT(id: nftID)!
                .subtractXP(value)
        }

        /// When conducting primary release sales, emit a "Purchased" event to facilitate purchase tracking
        /// off-chain. The parameters are passed through to the event and are not used by the contract.
        ///
        pub fun emitPurchasedEvent(
            purchaseIntentID: String,
            buyerAddress: Address,
            countPurchased: UInt64,
            totalSalePrice: UFix64
        ) {
            emit Purchased(
                purchaseIntentID: purchaseIntentID,
                buyerAddress: buyerAddress,
                countPurchased: countPurchased,
                totalSalePrice: totalSalePrice
            )
        }

        /// Create an Admin resource and return it to the caller
        ///
        pub fun createAdmin(): @Admin {
            return <- create Admin()
        }

        /// Set the contract's royalty address
        ///
        pub fun setRoyaltyAddress(_ address: Address) {
            Pinnacle.royaltyAddress = address
        }

        /// Set the contract's end user license URL
        ///
        pub fun setEndUserLicenseURL(_ url: String) {
            Pinnacle.endUserLicenseURL = url
        }
    }

    //------------------------------------------------------------
    // Variants, Path, and Utils Functions
    //------------------------------------------------------------

    /// Return the contract's variants dictionary
    ///
    pub fun getAllVariants(): {String: Bool} {
        return Pinnacle.variants
    }

    /// Allow iterating over Variants in the contract without allocating an array
    ///
    pub fun forEachVariant(_ function: ((String): Bool)) {
        Pinnacle.variants.forEachKey(function)
    }

    /// Return this contract's extension dictionary
    ///
    pub fun getExtension(): {String: AnyStruct} {
        return Pinnacle.extension
    }

    /// Return a public path that is scoped to this contract
    ///
    pub fun getPublicPath(suffix: String): PublicPath {
        return PublicPath(identifier: "Pinnacle".concat(suffix))!
    }

    /// Return a private path that is scoped to this contract
    ///
    pub fun getPrivatePath(suffix: String): PrivatePath {
        return PrivatePath(identifier: "Pinnacle".concat(suffix))!
    }

    /// Return a storage path that is scoped to this contract
    ///
    pub fun getStoragePath(suffix: String): StoragePath {
        return StoragePath(identifier: "Pinnacle".concat(suffix))!
    }

    /// Return a Collection name with an optional bucket suffix
    ///
    pub fun makeCollectionName(bucketName maybeBucketName: String?): String {
        if let bucketName = maybeBucketName {
            return "Collection_".concat(bucketName)
        }
        return "Collection"
    }

    /// Return a queue name with an optional bucket suffix
    ///
    pub fun makeQueueName(bucketName maybeBucketName: String?): String {
        if let bucketName = maybeBucketName {
            return "Queue_".concat(bucketName)
        }
        return "Queue"
    }

    /// Check if the contract is deployed to mainnet
    ///
    /// The function relies on checking the type of the imported NonFungibleToken contract.
    /// 0x1d7e57aa55817448 is the address of the known NonFungibleToken contract standard on mainnet.
    /// This is a workaround for the fact that there is no way to check the network ID in Cadence yet.
    ///
    pub fun isContractDeployedToMainnet(): Bool {
        return Type<NonFungibleToken>().identifier == "A.1d7e57aa55817448.NonFungibleToken"
    }

    //------------------------------------------------------------
    // Contract MetadataViews
    //------------------------------------------------------------

    /// Return the metadata view types available for this contract
    ///
    pub fun getViews(): [Type] {
        return [Type<MetadataViews.NFTCollectionData>(), Type<MetadataViews.NFTCollectionDisplay>()]
    }

    /// Resolve this contract's metadata views
    ///
    pub fun resolveView(_ view: Type): AnyStruct? {
        post {
            result == nil || result!.getType() == view: "The returned view must be of the given type or nil"
        }
        switch view {
            case Type<MetadataViews.NFTCollectionData>(): return Pinnacle.resolveNFTCollectionDataView()
            case Type<MetadataViews.NFTCollectionDisplay>(): return Pinnacle.resolveNFTCollectionDisplayView()
        }
        return nil
    }

    /// Resolve this contract's NFTCollectionData view
    ///
    pub fun resolveNFTCollectionDataView(): MetadataViews.NFTCollectionData {
        return MetadataViews.NFTCollectionData(
            storagePath: Pinnacle.CollectionStoragePath,
            publicPath: Pinnacle.CollectionPublicPath,
            providerPath: Pinnacle.CollectionPrivatePath,
            publicCollection: Type<&Pinnacle.Collection{Pinnacle.PinNFTCollectionPublic}>(),
            publicLinkedType: Type<&Pinnacle.Collection{Pinnacle.PinNFTCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
            providerLinkedType: Type<&Pinnacle.Collection{Pinnacle.PinNFTCollectionPublic, NonFungibleToken.CollectionPublic, NonFungibleToken.Provider, MetadataViews.ResolverCollection}>(),
            createEmptyCollectionFunction: (fun(): @NonFungibleToken.Collection {return <- Pinnacle.createEmptyCollection()})
        )
    }

    /// Resolve this contract's NFTCollectionDisplay view
    ///
    pub fun resolveNFTCollectionDisplayView(): MetadataViews.NFTCollectionDisplay {
        let squareImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
                url: "placeholder_square_url"
            ),
            mediaType: "image/png"
        )
        let bannerImage = MetadataViews.Media(
            file: MetadataViews.HTTPFile(
                url: "placeholder_banner_url"
            ),
            mediaType: "image/png"
        )
        return MetadataViews.NFTCollectionDisplay(
            name: "Pinnacle",
            description: "placeholder_description",
            externalURL: MetadataViews.ExternalURL("https://disneypinnacle.com"),
            squareImage: squareImage,
            bannerImage: bannerImage,
            socials : {
                "instagram": MetadataViews.ExternalURL("https://www.instagram.com/disneypinnacle/"),
                "twitter": MetadataViews.ExternalURL("https://twitter.com/DisneyPinnacle"),
                "discord": MetadataViews.ExternalURL("https://discord.gg/DisneyPinnacle"),
                "facebook": MetadataViews.ExternalURL("https://www.facebook.com/groups/disneypinnacle/")
            }
        )
    }

    //------------------------------------------------------------
    // Contract lifecycle
    //------------------------------------------------------------

    /// Pinnacle contract initializer
    ///
    /// The undo period is specified as a parameter to facilitate automated tests.
    ///
    init(undoPeriod: UInt64) {
        pre {
            // Check that the contract is properly configured on mainnet as part of the contract's code
            Pinnacle.isContractDeployedToMainnet() == false || undoPeriod == 259200:
                "The undo period must be set to 259200 (3 days) if the contract is deployed to mainnet"
        }

        // Set the named paths
        self.CollectionStoragePath = Pinnacle.getStoragePath(suffix: "Collection")
        self.CollectionPublicPath = Pinnacle.getPublicPath(suffix: "Collection")
        self.CollectionPrivatePath = Pinnacle.getPrivatePath(suffix: "Collection")
        self.AdminStoragePath = Pinnacle.getStoragePath(suffix: "Admin")
        self.MinterPrivatePath = Pinnacle.getPrivatePath(suffix: "Minter")

        // Initialize the non-container fields
        self.totalSupply = 0
        self.undoPeriod = undoPeriod
        self.royaltyAddress = self.account.address
        self.endUserLicenseURL = "https://disneypinnacle.com/terms"

        // Initialize the entity arrays
        self.series = []
        self.sets = []
        self.shapes = []
        self.editions = []
        self.editionTypes = []

        // Initialize the dictionaries
        self.seriesIDsByName = {}
        self.setIDsByName = {}
        self.editionTypeIDsByName = {}
        self.variants = {}
        self.inscriptionsLimits = {}
        self.extension = {}

        // Create an Admin resource
        let admin <- create Admin()

        // Create the default Edition Types
        admin.createEditionType(name: "Genesis Edition", isLimited: true, isMaturing: false)
        admin.createEditionType(name: "Unique Edition", isLimited: true, isMaturing: false)
        admin.createEditionType(name: "Limited Edition", isLimited: true, isMaturing: false)
        admin.createEditionType(name: "Open Edition", isLimited: false, isMaturing: false)
        admin.createEditionType(name: "Starter Edition", isLimited: false, isMaturing: true)
        admin.createEditionType(name: "Event Edition", isLimited: false, isMaturing: true)

        // Save the Admin resource to storage and create Minter capability
        self.account.save(<- admin, to: self.AdminStoragePath)
        self.account.link<&Admin{NFTMinter}>(self.MinterPrivatePath, target: self.AdminStoragePath)

        // Let the world know we are here
        emit ContractInitialized()
    }
}
"
-------
"//  SPDX-License-Identifier: UNLICENSED
//
//
import NonFungibleToken from 0x1d7e57aa55817448
import Anique from 0xe2e1689b53e92a82

pub contract s_witch: NonFungibleToken, Anique {
    // -----------------------------------------------------------------------
    // s_witch contract Events
    // -----------------------------------------------------------------------

    // Events for Contract-Related actions
    //
    // Emitted when the s_witch contract is created
    pub event ContractInitialized()

    // Events for Item-Related actions
    //
    // Emitted when a new Item struct is created
    pub event ItemCreated(id: UInt32, metadata: {String:String})

    // Events for Collectible-Related actions
    //
    // Emitted when an CollectibleData NFT is minted
    pub event CollectibleMinted(collectibleID: UInt64, itemID: UInt32, serialNumber: UInt32)
    // Emitted when an CollectibleData NFT is destroyed
    pub event CollectibleDestroyed(collectibleID: UInt64)

    // events for Collection-related actions
    //
    // Emitted when an CollectibleData is withdrawn from a Collection
    pub event Withdraw(id: UInt64, from: Address?)
    // Emitted when an CollectibleData is deposited into a Collection
    pub event Deposit(id: UInt64, to: Address?)

    // paths
    pub let collectionStoragePath: StoragePath
    pub let collectionPublicPath: PublicPath
    pub let collectionPrivatePath: PrivatePath
    pub let adminStoragePath: StoragePath
    pub let saleCollectionStoragePath: StoragePath
    pub let saleCollectionPublicPath: PublicPath

    // -----------------------------------------------------------------------
    // s_witch contract-level fields.
    // These contain actual values that are stored in the smart contract.
    // -----------------------------------------------------------------------

    // fields for Item-related
    //
    // variable size dictionary of Item resources
    access(self) var items: @{UInt32: Item}

    // The ID that is used to create Items.
    pub var nextItemID: UInt32

    // fields for Collectible-related
    //
    // Total number of CollectibleData NFTs that have been minted ever.
    pub var totalSupply: UInt64

    // -----------------------------------------------------------------------
    // s_witch contract-level Composite Type definitions
    // -----------------------------------------------------------------------

    // The structure that represents Item
    // each digital content which s_witch deal with on Flow
    //
    pub struct ItemData {

        pub let itemID: UInt32

        pub let metadata: {String: String}

        init(itemID: UInt32) {
            let item = (&s_witch.items[itemID] as &Item?)!

            self.itemID = item.itemID
            self.metadata = item.metadata
        }
   }

    // Item is a resource type that contains the functions to mint Collectibles.
    //
    // It is stored in a private field in the contract so that
    // the admin resource can call its methods and that there can be
    // public getters for some of its fields
    //
    // The admin can mint Collectibles that refer from Item.
    pub resource Item {

        // unique ID for the Item
        pub let itemID: UInt32

        // Stores all the metadata about the item as a string mapping
        // This is not the long term way NFT metadata will be stored. It's a temporary
        // construct while we figure out a better way to do metadata.
        //
        pub let metadata: {String: String}

        // The number of Collectibles that have been minted per Item.
        access(contract) var numberMintedPerItem: UInt32

        init(metadata: {String: String}) {
            pre {
                metadata.length != 0: "New Item metadata cannot be empty"
            }
            self.itemID = s_witch.nextItemID
            self.metadata = metadata
            self.numberMintedPerItem = 0

            // increment the nextItemID so that it isn't used again
            s_witch.nextItemID = s_witch.nextItemID + 1

            emit ItemCreated(id: self.itemID, metadata: metadata)
        }

        // mintCollectible mints a new Collectible and returns the newly minted Collectible
        //
        // Returns: The NFT that was minted
        //
        pub fun mintCollectible(): @NFT {
            // get the number of Collectibles that have been minted for this Item
            // to use as this Collectible's serial number
            let numInItem = self.numberMintedPerItem

            // mint the new Collectible
            let newCollectible: @NFT <- create NFT(serialNumber: numInItem + 1,
                                              itemID: self.itemID)

            // Increment the count of Collectibles minted for this Item
            self.numberMintedPerItem = numInItem + 1

            return <-newCollectible
        }

        // batchMintCollectible mints an arbitrary quantity of Collectibles
        // and returns them as a Collection
        //
        // Parameters: itemID: the ID of the Item that the Collectibles are minted for
        //             quantity: The quantity of Collectibles to be minted
        //
        // Returns: Collection object that contains all the Collectibles that were minted
        //
        pub fun batchMintCollectible(quantity: UInt64): @Collection {
            let newCollection <- create Collection()

            var i: UInt64 = 0
            while i < quantity {
                newCollection.deposit(token: <-self.mintCollectible())
                i = i + 1
            }

            return <-newCollection
        }

        // Returns: the number of Collectibles
        pub fun getNumberMinted(): UInt32 {
            return self.numberMintedPerItem
        }
    }

    // The structure holds metadata of an Collectible
    pub struct CollectibleData {
        // The ID of the Item that the Collectible references
        pub let itemID: UInt32

        // The place in the Item that this Collectible was minted
        pub let serialNumber: UInt32

        init(itemID: UInt32, serialNumber: UInt32) {
            self.itemID = itemID
            self.serialNumber = serialNumber
        }
    }

    // The resource that represents the CollectibleData NFTs
    //
    pub resource NFT: NonFungibleToken.INFT, Anique.INFT {

        // Global unique collectibleData ID
        pub let id: UInt64

        // Struct of Collectible metadata
        pub let data: CollectibleData

        init(serialNumber: UInt32, itemID: UInt32) {
            // Increment the global Collectible IDs
            s_witch.totalSupply = s_witch.totalSupply + 1

            // set id
            self.id = s_witch.totalSupply

            // Set the metadata struct
            self.data = CollectibleData(itemID: itemID, serialNumber: serialNumber)

            emit CollectibleMinted(collectibleID: self.id, itemID: itemID, serialNumber: self.data.serialNumber)
        }

        destroy() {
            emit CollectibleDestroyed(collectibleID: self.id)
        }
    }

    // interface that represents s_witch collections to public
    // extends of NonFungibleToken.CollectionPublic
    pub resource interface CollectionPublic {

        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT

        // deposit multi tokens
        pub fun batchDeposit(tokens: @Anique.Collection)

        // contains NFT
        pub fun contains(id: UInt64): Bool

        // borrow NFT as s_witch token
        pub fun borrows_witchCollectible(id: UInt64): auth &NFT
    }

    // Collection is a resource that every user who owns NFTs
    // will store in their account to manage their NFTs
    //
    pub resource Collection: CollectionPublic, NonFungibleToken.Receiver, NonFungibleToken.Provider, NonFungibleToken.CollectionPublic {
        // Dictionary of CollectibleData conforming tokens
        // NFT is a resource type with a UInt64 ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init() {
            self.ownedNFTs <- {}
        }

        // withdraw removes a Collectible from the Collection and moves it to the caller
        //
        // Parameters: withdrawID: The ID of the NFT
        // that is to be removed from the Collection
        //
        // returns: @NonFungibleToken.NFT the token that was withdrawn
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {

            // Remove the nft from the Collection
            let token <- self.ownedNFTs.remove(key: withdrawID)
                ?? panic("Cannot withdraw: Collectible does not exist in the collection")

            emit Withdraw(id: token.id, from: self.owner?.address)

            // Return the withdrawn token
            return <- token
        }

        // batchWithdraw withdraws multiple tokens and returns them as a Collection
        //
        // Parameters: collectibleIds: An array of IDs to withdraw
        //
        // Returns: @NonFungibleToken.Collection: A collection that contains
        //                                        the withdrawn collectibles
        //
        pub fun batchWithdraw(collectibleIds: [UInt64]): @Anique.Collection {
            // Create a new empty Collection
            var batchCollection <- create Collection()

            // Iterate through the collectibleIds and withdraw them from the Collection
            for collectibleID in collectibleIds {
                batchCollection.deposit(token: <-self.withdraw(withdrawID: collectibleID))
            }

            // Return the withdrawn tokens
            return <-batchCollection
        }

        // deposit takes a Collectible and adds it to the Collections dictionary
        //
        // Parameters: token: the NFT to be deposited in the collection
        //
        pub fun deposit(token: @NonFungibleToken.NFT) {

            // Cast the deposited token as an s_witch NFT to make sure
            // it is the correct type
            let token <- token as! @s_witch.NFT

            // Get the token's ID
            let id = token.id

            // Add the new token to the dictionary
            let oldToken <- self.ownedNFTs[id] <- token

            // Only emit a deposit event if the Collection
            // is in an account's storage
            if self.owner?.address != nil {
                emit Deposit(id: id, to: self.owner?.address)
            }

            // Destroy the empty old token that was "removed"
            destroy oldToken
        }

        // batchDeposit takes a Collection object as an argument
        // and deposits each contained NFT into this Collection
        pub fun batchDeposit(tokens: @Anique.Collection) {

            // Get an array of the IDs to be deposited
            let keys = tokens.getIDs()

            // Iterate through the keys in the collection and deposit each one
            for key in keys {
                self.deposit(token: <-tokens.withdraw(withdrawID: key))
            }

            // Destroy the empty Collection
            destroy tokens
        }

        // getIDs returns an array of the IDs that are in the Collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // contains returns whether ID is in the Collection
        pub fun contains(id: UInt64): Bool {
            return self.ownedNFTs[id] != nil
        }

        // borrowNFT Returns a borrowed reference to a Collectible in the Collection
        // so that the caller can read its ID
        //
        // Parameters: id: The ID of the NFT to get the reference for
        //
        // Returns: A reference to the NFT
        //
        // Note: This only allows the caller to read the ID of the NFT,
        // not any s_witch specific data. Please use borrowCollectible to
        // read Collectible data.
        //
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowAniqueNFT(id: UInt64): auth &Anique.NFT {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            return nft as! auth &Anique.NFT
        }

        // borrows_witchCollectible returns a borrowed reference
        // to an s_witch Collectible
        pub fun borrows_witchCollectible(id: UInt64): auth &NFT {
            pre {
                self.ownedNFTs[id] != nil: "NFT does not exist in the collection!"
            }
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            return nft as! auth &NFT
        }

        // If a transaction destroys the Collection object,
        // All the NFTs contained within are also destroyed!
        //
        destroy() {
            destroy self.ownedNFTs
        }
    }

    // Admin is a special authorization resource that
    // allows the owner to perform important functions to modify the
    // various aspects of the Items, CollectibleDatas, etc.
    //
    pub resource Admin {

        // createItem creates a new Item struct
        // and stores it in the Items dictionary field in the s_witch smart contract
        //
        // Parameters: metadata: A dictionary mapping metadata titles to their data
        //                       example: {"Title": "Excellent Anime", "Author": "John Smith"}
        //
        // Returns: the ID of the new Item object
        //
        pub fun createItem(metadata: {String: String}): UInt32 {
            // Create the new Item
            var newItem <- create Item(metadata: metadata)
            let itemId = newItem.itemID

            // Store it in the contract storage
            s_witch.items[newItem.itemID] <-! newItem

            return itemId
        }

        // borrowItem returns a reference to a Item in the s_witch
        // contract so that the admin can call methods on it
        //
        // Parameters: itemID: The ID of the Item that you want to
        // get a reference to
        //
        // Returns: A reference to the Item with all of the fields
        // and methods exposed
        //
        pub fun borrowItem(itemID: UInt32): &Item {
            pre {
                s_witch.items[itemID] != nil: "Cannot borrow Item: The Item doesn't exist"
            }

            return (&s_witch.items[itemID] as &Item?)!
        }

        // createNewAdmin creates a new Admin resource
        //
        pub fun createNewAdmin(): @Admin {
            return <-create Admin()
        }
    }

    // -----------------------------------------------------------------------
    // s_witch contract-level function definitions
    // -----------------------------------------------------------------------

    // createEmptyCollection creates a new, empty Collection object so that
    // a user can store it in their account storage.
    // Once they have a Collection in their storage, they are able to receive
    // Collectibles in transactions.
    //
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <-create s_witch.Collection()
    }

    // getNumCollectiblesInItem return the number of Collectibles that have been
    //                        minted from a certain Item.
    //
    // Parameters: itemID: The id of the Item that is being searched
    //
    // Returns: The total number of Collectibles
    //          that have been minted from a Item
    pub fun getNumCollectiblesInItem(itemID: UInt32): UInt32 {
        let item = (&s_witch.items[itemID] as &Item?)!
        return item.numberMintedPerItem
    }

    // -----------------------------------------------------------------------
    // s_witch initialization function
    // -----------------------------------------------------------------------
    //
    init() {
        // Initialize contract fields
        self.items <- {}
        self.nextItemID = 1
        self.totalSupply = 0

        self.collectionStoragePath     = /storage/s_witchCollection
        self.collectionPublicPath      =  /public/s_witchCollection
        self.collectionPrivatePath     = /private/s_witchCollection
        self.adminStoragePath          = /storage/s_witchAdmin
        self.saleCollectionStoragePath = /storage/s_witchSaleCollection
        self.saleCollectionPublicPath  =  /public/s_witchSaleCollection

        // Put a new Collection in storage
        self.account.save<@Collection>(<- create Collection(), to: self.collectionStoragePath)

        // Create a public capability for the Collection
        self.account.link<&{CollectionPublic}>(self.collectionPublicPath, target: self.collectionStoragePath)

        // Put the Admin in storage
        self.account.save<@Admin>(<- create Admin(), to: self.adminStoragePath)

        emit ContractInitialized()
    }
}
"
-------
"/**
    NGPrimarySale.cdc

    Description: Facilitates the exchange of Fungible Tokens for NFTs.
**/

import NonFungibleToken from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe

pub contract NGPrimarySale {

    pub let PrimarySaleStoragePath: StoragePath
    pub let PrimarySalePublicPath: PublicPath
    pub let PrimarySalePrivatePath: PrivatePath

    pub event PrimarySaleCreated(
        externalID: String,
        name: String,
        description: String,
        imageURI: String,
        nftType: Type,
        prices: {String: UFix64}
    )
    pub event PrimarySaleStatusChanged(externalID: String, status: String)
    pub event PriceSet(externalID: String, type: String, price: UFix64)
    pub event PriceRemoved(externalID: String, type: String)
    pub event AssetAdded(externalID: String, assetID: UInt64)
    pub event NFTPurchased(externalID: String, nftType: Type, assetID: UInt64, nftID: UInt64, purchaserAddress: Address, priceType: String, price: UFix64)
    pub event ContractInitialized()

    access(contract) let primarySaleIDs: [String]

    pub resource interface IMinter {
        pub fun mint(assetID: UInt64, creator: Address): @NonFungibleToken.NFT
    }

    // Data struct signed by account with specified "adminPublicKey."
    //
    // Permits accounts to purchase specific NFTs for some period of time.
    pub struct AdminSignedData {
        pub let externalID: String
        pub let priceType: String
        pub let primarySaleAddress: Address
        pub let purchaserAddress: Address
        pub let assetIDs: [UInt64]
        pub let expiration: UInt64 // unix timestamp

        init(externalID: String, primarySaleAddress: Address, purchaserAddress: Address, assetIDs: [UInt64], priceType: String, expiration: UInt64){
            self.externalID = externalID
            self.primarySaleAddress = primarySaleAddress
            self.purchaserAddress = purchaserAddress
            self.assetIDs = assetIDs
            self.priceType = priceType
            self.expiration = expiration
        }

        pub fun toString(): String {
            var assetIDs = ""
            var i = 0
            while (i < self.assetIDs.length) {
                if (i > 0) {
                    assetIDs = assetIDs.concat(",")
                }
                assetIDs = assetIDs.concat(self.assetIDs[i].toString())
                i = i + 1
            }
            return self.externalID.concat(":")
                .concat(self.primarySaleAddress.toString()).concat(":")
                .concat(self.purchaserAddress.toString()).concat(":")
                .concat(assetIDs).concat(":")
                .concat(self.priceType).concat(":")
                .concat(self.expiration.toString())
        }
    }

    pub enum PrimarySaleStatus: UInt8 {
        pub case PAUSED
        pub case OPEN
        pub case CLOSED
    }

    pub resource interface PrimarySalePublic {
        pub fun getDetails(): PrimarySaleDetails
        pub fun getSupply(): Int
        pub fun getPrices(): {String: UFix64}
        pub fun getStatus(): String
        pub fun purchaseNFTs(
            payment: @FungibleToken.Vault,
            data: AdminSignedData,
            sig: String
        ): @[NonFungibleToken.NFT]
        pub fun claimNFTs(
            data: AdminSignedData,
            sig: String
        ): @[NonFungibleToken.NFT]
    }

    pub resource interface PrimarySalePrivate {
        pub fun pause()
        pub fun open()
        pub fun close()
        pub fun setDetails(
            name: String,
            description: String,
            imageURI: String
        )
        pub fun setPrice(priceType: String, price: UFix64)
        pub fun setAdminPublicKey(adminPublicKey: String)
        pub fun addAsset(assetID: UInt64)
    }

    pub struct PrimarySaleDetails {
        pub var name: String
        pub var description: String
        pub var imageURI: String

        init(
            name: String,
            description: String,
            imageURI: String
        ) {
            self.name = name
            self.description = description
            self.imageURI = imageURI
        }
    }

    pub resource PrimarySale: PrimarySalePublic, PrimarySalePrivate {
        access(self) var externalID: String
        pub let nftType: Type
        access(self) var status: PrimarySaleStatus
        access(self) var prices: {String: UFix64}
        access(self) var availableAssetIDs: {UInt64: Bool}

        // primary sale metadata
        access(self) var details: PrimarySaleDetails

        access(self) let minterCap: Capability<&{IMinter}>
        access(self) let paymentReceiverCap: Capability<&{FungibleToken.Receiver}>

        // pub key used to verify signatures from a specified admin
        access(self) var adminPublicKey: String

        init(
            externalID: String,
            name: String,
            description: String,
            imageURI: String,
            nftType: Type,
            prices: {String: UFix64},
            minterCap: Capability<&{IMinter}>,
            paymentReceiverCap: Capability<&{FungibleToken.Receiver}>,
            adminPublicKey: String
        ) {
            self.externalID = externalID
            self.details = PrimarySaleDetails(
                name: name,
                description: description,
                imageURI: imageURI
            )
            self.nftType = nftType
            self.status = PrimarySaleStatus.PAUSED // primary sale is paused initially
            self.availableAssetIDs = {} // no asset IDs assigned to primary sale initially
            self.prices = prices

            self.minterCap = minterCap
            self.paymentReceiverCap = paymentReceiverCap

            self.adminPublicKey = adminPublicKey

            emit PrimarySaleCreated(
                externalID: externalID,
                name: name,
                description: description,
                imageURI: imageURI,
                nftType: nftType,
                prices: prices
            )
        }

        pub fun getStatus(): String {
            if (self.status == PrimarySaleStatus.PAUSED) {
                return "PAUSED"
            } else if (self.status == PrimarySaleStatus.OPEN) {
                return "OPEN"
            } else if (self.status == PrimarySaleStatus.CLOSED) {
                return "CLOSED"
            } else {
                return ""
            }
        }

        pub fun setDetails(
            name: String,
            description: String,
            imageURI: String
        ) {
            self.details = PrimarySaleDetails(
                name: name,
                description: description,
                imageURI: imageURI
            )
        }

        pub fun getDetails(): PrimarySaleDetails {
            return self.details
        }

        pub fun setPrice(priceType: String, price: UFix64) {
            self.prices[priceType] = price
            emit PriceSet(externalID: self.externalID, type: priceType, price: price)
        }

        pub fun removePrice(priceType: String) {
            self.prices.remove(key: priceType)
            emit PriceRemoved(externalID: self.externalID, type: priceType)
        }

        pub fun getPrices(): {String: UFix64} {
            return self.prices
        }

        pub fun getSupply(): Int {
            return self.availableAssetIDs.length
        }

        pub fun setAdminPublicKey(adminPublicKey: String) {
            self.adminPublicKey = adminPublicKey
        }

        pub fun addAsset(assetID: UInt64) {
            self.availableAssetIDs[assetID] = true
            emit AssetAdded(externalID: self.externalID, assetID: assetID)
        }

        pub fun pause() {
            self.status = PrimarySaleStatus.PAUSED
            emit PrimarySaleStatusChanged(externalID: self.externalID, status: self.getStatus())
        }

        pub fun open() {
            pre {
                self.status != PrimarySaleStatus.OPEN : "Primary sale is already open"
                self.status != PrimarySaleStatus.CLOSED : "Cannot resume primary sale that is closed"
            }

            self.status = PrimarySaleStatus.OPEN
            emit PrimarySaleStatusChanged(externalID: self.externalID, status: self.getStatus())
        }

        pub fun close() {
            self.status = PrimarySaleStatus.CLOSED
            emit PrimarySaleStatusChanged(externalID: self.externalID, status: self.getStatus())
        }

        access(self) fun verifyAdminSignedData(data: AdminSignedData, sig: String): Bool {
            let publicKey = PublicKey(
                publicKey: self.adminPublicKey.decodeHex(),
                signatureAlgorithm: SignatureAlgorithm.ECDSA_P256
            )

            return publicKey.verify(
                signature: sig.decodeHex(),
                signedData: data.toString().utf8,
                domainSeparationTag: "FLOW-V0.0-user",
                hashAlgorithm: HashAlgorithm.SHA3_256
            )
        }

        pub fun purchaseNFTs(
            payment: @FungibleToken.Vault,
            data: AdminSignedData,
            sig: String
        ): @[NonFungibleToken.NFT] {
            pre {
                self.externalID == data.externalID: "externalID mismatch"
                self.status == PrimarySaleStatus.OPEN: "primary sale is not open"
                data.assetIDs.length > 0: "must purchase at least one NFT"
                self.verifyAdminSignedData(data: data, sig: sig): "invalid admin signature for data"
                data.expiration >= UInt64(getCurrentBlock().timestamp): "expired signature"
            }

            let price = self.prices[data.priceType] ?? panic("Invalid price type")

            assert(payment.balance == price * UFix64(data.assetIDs.length), message: "payment vault does not contain requested price")

            let receiver = self.paymentReceiverCap.borrow()!
            receiver.deposit(from: <- payment)

            let minter = self.minterCap.borrow() ?? panic("cannot borrow minter")

            var i: Int = 0
            let nfts: @[NonFungibleToken.NFT] <- []
            while i < data.assetIDs.length {
                let assetID = data.assetIDs[i]
                assert(self.availableAssetIDs.containsKey(assetID), message: "NFT is not available for purchase: ".concat(assetID.toString()))
                self.availableAssetIDs.remove(key: assetID)
                let nft <- minter.mint(assetID: assetID, creator: data.purchaserAddress)
                emit NFTPurchased(externalID: self.externalID, nftType: nft.getType(), assetID: assetID, nftID: nft.id, purchaserAddress: data.purchaserAddress, priceType: data.priceType, price: price)
                nfts.append(<-nft)
                i = i + 1
            }
            assert(nfts.length == data.assetIDs.length, message: "nft count mismatch")

            return <- nfts
        }

        pub fun claimNFTs(
            data: AdminSignedData,
            sig: String
        ): @[NonFungibleToken.NFT] {
            pre {
                self.externalID == data.externalID: "externalID mismatch"
                self.status == PrimarySaleStatus.OPEN: "primary sale is not open"
                data.assetIDs.length > 0: "must purchase at least one NFT"
                self.verifyAdminSignedData(data: data, sig: sig): "invalid admin signature for data"
                data.expiration >= UInt64(getCurrentBlock().timestamp): "expired signature"
            }

            let price = self.prices[data.priceType] ?? panic("Invalid price type")

            assert(price == 0.0, message: "Can only claim zero price assets")

            let minter = self.minterCap.borrow() ?? panic("cannot borrow minter")

            var i: Int = 0
            let nfts: @[NonFungibleToken.NFT] <- []
            while i < data.assetIDs.length {
                let assetID = data.assetIDs[i]
                assert(self.availableAssetIDs.containsKey(assetID), message: "NFT is not available for purchase: ".concat(assetID.toString()))
                self.availableAssetIDs.remove(key: assetID)
                let nft <- minter.mint(assetID: assetID, creator: data.purchaserAddress)
                emit NFTPurchased(externalID: self.externalID, nftType: nft.getType(), assetID: assetID, nftID: nft.id, purchaserAddress: data.purchaserAddress, priceType: data.priceType, price: price)
                nfts.append(<-nft)
                i = i + 1
            }
            assert(nfts.length == data.assetIDs.length, message: "nft count mismatch")

            return <- nfts
        }
    }

    pub fun createPrimarySale(
        externalID: String,
        name: String,
        description: String,
        imageURI: String,
        nftType: Type,
        prices: {String: UFix64},
        minterCap: Capability<&{IMinter}>,
        paymentReceiverCap: Capability<&{FungibleToken.Receiver}>,
        adminPublicKey: String
    ): @PrimarySale {
        assert(!self.primarySaleIDs.contains(externalID), message: "Primary sale external ID is already in use")

        self.primarySaleIDs.append(externalID)

        return <- create PrimarySale(
            externalID: externalID,
            name: name,
            description: description,
            imageURI: imageURI,
            nftType: nftType,
            prices: prices,
            minterCap: minterCap,
            paymentReceiverCap: paymentReceiverCap,
            adminPublicKey: adminPublicKey
        )
    }

    init() {
        // default paths but not intended for multiple primary sales on same acct
        self.PrimarySaleStoragePath = /storage/NGPrimarySale001
        self.PrimarySalePublicPath = /public/NGPrimarySale001
        self.PrimarySalePrivatePath = /private/NGPrimarySale001

        self.primarySaleIDs = []

        emit ContractInitialized()
    }
}
"
-------
"// Testnet
// import NonFungibleToken from 0x631e88ae7f1d7c20
// import MetadataViews from 0x631e88ae7f1d7c20
// import FungibleToken from 0x9a0766d93b6608b7

// Mainnet
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
// import Crypto

pub contract NastyGirlz: NonFungibleToken {

  // Events
  //
  // This contract is initialized
  pub event ContractInitialized()

  // NFT is minted
  pub event NFTMinted(
    nftID: UInt64,
    setID: UInt64,
    templateID: UInt64,
    displayName: String,
    displayDescription: String,
    displayURI: String,
    creator: Address,
  )

  // NFT is withdrawn from a collection
  pub event Withdraw(id: UInt64, from: Address?)

  // NFT is deposited from a collection
  pub event Deposit(id: UInt64, to: Address?)

  // NFT is destroyed
  pub event NFTDestroyed(id: UInt64)

  // NFT template metadata is revealed
  pub event NFTRevealed(
    nftID: UInt64,
    setID: UInt64,
    templateID: UInt64,
    displayName: String,
    displayDescription: String,
    displayURI: String,
    metadata: {String: String},
  )

  // Set has been created
  pub event SetCreated(setID: UInt64, metadata: SetMetadata)

  // Template has been added
  pub event TemplateAdded(setID: UInt64, templateID: UInt64, displayName: String, displayDescription: String, displayURI: String)

  // Set has been marked Locked
  pub event SetLocked(setID: UInt64, numTemplates: UInt64)

  // Paths
  //
  pub let CollectionStoragePath: StoragePath
  pub let CollectionPublicPath: PublicPath
  pub let CollectionPrivatePath: PrivatePath
  pub let AdminStoragePath: StoragePath

  // Total NFT supply
  pub var totalSupply: UInt64

  pub fun externalURL(): MetadataViews.ExternalURL {
    return MetadataViews.ExternalURL("https://ongaia.com/driverz")
  }

  pub fun royaltyAddress(): Address {
    return 0xa039bd7d55a96c0c
  }

  pub fun squareImageCID(): String {
    return "QmV4FsnFiU7QY8ybwd5uuXwogVo9wcRExQLwedh7HU1mrU"
  }

  pub fun bannerImageCID(): String {
    return "QmYn6vg1pCuKb6jWT3SDHuyX4NDyJB4wvcYarmsyppoGDS"
  }

  // Total number of sets
  access(self) var totalSets: UInt64

  // Dictionary mapping from set IDs to Set resources
  access(self) var sets: @{UInt64: Set}

  // Template metadata can have custom definitions but must have the
  // following implemented in order to power all the features of the
  // NFT contract.
  pub struct interface TemplateMetadata {

    // Hash representation of implementing structs.
    pub fun hash(): [UInt8]

    // Representative Display
    pub fun display(): MetadataViews.Display

    // Representative {string: string} serialization
    pub fun repr(): {String: String}
  }

  pub struct DynamicTemplateMetadata: TemplateMetadata {
    access(self) let _display: MetadataViews.Display
    access(self) let _metadata: {String: String}

    pub fun hash(): [UInt8] {
      return []
    }

    pub fun display(): MetadataViews.Display {
      return self._display
    }

    pub fun repr(): {String: String} {
      return self.metadata()
    }

    pub fun metadata(): {String: String} {
      return self._metadata
    }

    init(display: MetadataViews.Display, metadata: {String: String}) {
      self._display = display
      self._metadata = metadata
    }
  }

  // NFT
  //
  // "Standard" NFTs that implement MetadataViews and point
  // to a Template struct that give information about the NFTs metadata
  pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {

    // id is unique among all NastyGirlz NFTs on Flow, ordered sequentially from 0
    pub let id: UInt64

    // setID and templateID help us locate the specific template in the
    // specific set which stores this NFTs metadata
    pub let setID: UInt64
    pub let templateID: UInt64

    // The creator of the NFT
    pub let creator: Address

    // Fetch the metadata Template represented by this NFT
    pub fun template(): {NFTTemplate} {
      return NastyGirlz.getTemplate(setID: self.setID, templateID: self.templateID)
    }

    // Proxy for MetadataViews.Resolver.getViews implemented by Template
    pub fun getViews(): [Type] {
      return [
        Type<MetadataViews.NFTView>(),
        Type<MetadataViews.Display>(),
        Type<MetadataViews.Royalties>(),
        Type<MetadataViews.ExternalURL>(),
        Type<MetadataViews.NFTCollectionDisplay>(),
        Type<MetadataViews.NFTCollectionData>()
      ]
    }

    pub fun resolveView(_ view: Type): AnyStruct? {
      switch view {
        case Type<MetadataViews.NFTView>():
          let viewResolver = &self as &{MetadataViews.Resolver}
          return MetadataViews.NFTView(
              id : self.id,
              uuid: self.uuid,
              display: MetadataViews.getDisplay(viewResolver),
              externalURL : MetadataViews.getExternalURL(viewResolver),
              collectionData : MetadataViews.getNFTCollectionData(viewResolver),
              collectionDisplay : MetadataViews.getNFTCollectionDisplay(viewResolver),
              royalties : MetadataViews.getRoyalties(viewResolver),
              traits : MetadataViews.getTraits(viewResolver)
          )
        case Type<MetadataViews.Display>():
          let template = self.template()
          if template.revealed() {
            return template.metadata!.display()
          }
          return template.defaultDisplay
        case Type<MetadataViews.Royalties>():
          let royalties: [MetadataViews.Royalty] = []
          let royaltyReceiverCap =
            getAccount(NastyGirlz.royaltyAddress()).getCapability<&{FungibleToken.Receiver}>(/public/dapperUtilityCoinReceiver)
          if royaltyReceiverCap.check() {
            royalties.append(
              MetadataViews.Royalty(
                  receiver: royaltyReceiverCap,
                  cut:  0.05,
                  description: "Creator royalty fee."
              )
            )
          }
          return MetadataViews.Royalties(royalties)
        case Type<MetadataViews.ExternalURL>():
          return NastyGirlz.externalURL()
        case Type<MetadataViews.NFTCollectionData>():
          return MetadataViews.NFTCollectionData(
            storagePath: NastyGirlz.CollectionStoragePath,
            publicPath: NastyGirlz.CollectionPublicPath,
            providerPath: NastyGirlz.CollectionPrivatePath,
            publicCollection: Type<@NastyGirlz.Collection>(),
            publicLinkedType: Type<&NastyGirlz.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
            providerLinkedType: Type<&NastyGirlz.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}>(),
            createEmptyCollectionFunction: fun(): @NonFungibleToken.Collection{
              return <- NastyGirlz.createEmptyCollection()
            }
          )
        case Type<MetadataViews.NFTCollectionDisplay>():
          return MetadataViews.NFTCollectionDisplay(
            name: "Driverz",
            description: "An exclusive collection of energetic Driverz ready to vroom vroom on FLOW.",
            externalURL: NastyGirlz.externalURL(),
            squareImage:
              MetadataViews.Media(
                file: MetadataViews.IPFSFile(cid: NastyGirlz.squareImageCID(), path: nil),
                mediaType: "image/svg+xml"
              ),
            bannerImage:
              MetadataViews.Media(
                file: MetadataViews.IPFSFile(cid: NastyGirlz.bannerImageCID(), path: nil),
                mediaType: "image/svg+xml"
              ),
            socials: {
              "twitter": MetadataViews.ExternalURL("https://twitter.com/NastyGirlz"),
              "instagram": MetadataViews.ExternalURL("https://www.instagram.com/NastyGirlz/")
            }
          )
      }
      return nil
    }

    // NFT needs to be told which Template it follows
    init(setID: UInt64, templateID: UInt64, creator: Address) {
      self.id = NastyGirlz.totalSupply
      NastyGirlz.totalSupply = NastyGirlz.totalSupply + 1
      self.setID = setID
      self.templateID = templateID
      self.creator = creator
      let defaultDisplay = self.template().defaultDisplay
      emit NFTMinted(
        nftID: self.id,
        setID: self.setID,
        templateID: self.templateID,
        displayName: defaultDisplay.name,
        displayDescription: defaultDisplay.description,
        displayURI: defaultDisplay.thumbnail.uri(),
        creator: self.creator
      )
    }

    // Emit NFTDestroyed when destroyed
    destroy() {
      emit NFTDestroyed(
        id: self.id,
      )
    }
  }

  // Collection
  //
  // Collections provide a way for collectors to store NastyGirlz NFTs in their
  // Flow account.

  // Exposing this interface allows external parties to inspect a Flow
  // account's NastyGirlz Collection and deposit NFTs
  pub resource interface CollectionPublic {
    pub fun deposit(token: @NonFungibleToken.NFT)
    pub fun getIDs(): [UInt64]
    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
    pub fun borrowNastyGirlz(id: UInt64): &NFT
  }

  pub resource Collection: CollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {

    // NFTs are indexed by its globally assigned id
    pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

    // Deposit a NastyGirlz into the collection. Safe to assume id's are unique.
    pub fun deposit(token: @NonFungibleToken.NFT) {
      // Required to ensure this is a NastyGirlz
      let token <- token as! @NastyGirlz.NFT
      let id: UInt64 = token.id
      let oldToken <- self.ownedNFTs[id] <- token
      emit Deposit(id: id, to: self.owner?.address)
      destroy oldToken
    }

    // Withdraw an NFT from the collection.
    // Panics if NFT does not exist in the collection
    pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
      pre {
        self.ownedNFTs.containsKey(withdrawID)
          : "NFT does not exist in collection."
      }
      let token <- self.ownedNFTs.remove(key: withdrawID)!
      emit Withdraw(id: token.id, from: self.owner?.address)
      return <-token
    }

    // Return all the IDs from the collection.
    pub fun getIDs(): [UInt64] {
      return self.ownedNFTs.keys
    }

    // Borrow a reference to the specified NFT
    // Panics if NFT does not exist in the collection
    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
      pre {
        self.ownedNFTs.containsKey(id)
          : "NFT does not exist in collection."
      }
      return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
    }

    // Borrow a reference to the specified NFT as a NastyGirlz.
    // Panics if NFT does not exist in the collection
    pub fun borrowNastyGirlz(id: UInt64): &NFT {
      pre {
        self.ownedNFTs.containsKey(id)
          : "NFT does not exist in collection."
      }
      let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      return ref as! &NFT
    }

    // Return the MetadataViews.Resolver of the specified NFT
    // Panics if NFT does not exist in the collection
    pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {
      pre {
        self.ownedNFTs.containsKey(id)
          : "NFT does not exist in collection."
      }
      let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let typedNFT = nft as! &NFT
      return typedNFT
    }

    init() {
      self.ownedNFTs <- {}
    }

    // If the collection is destroyed, destroy the NFTs it holds, as well
    destroy() {
      destroy self.ownedNFTs
    }
  }

  // Anyone can make and store collections
  pub fun createEmptyCollection(): @Collection {
    return <-create Collection()
  }

  pub resource Set {

    // Globally assigned id based on number of created Sets.
    pub let id: UInt64

    pub var isLocked: Bool

    // Metadata for the Set
    pub var metadata: SetMetadata

    // Templates configured to be minted from this Set
    access(contract) var templates: [Template]

    // Number of NFTs that have minted from this Set
    pub var minted: UInt64

    // Add a new Template to the Set, only if the Set is Open
    pub fun addTemplate(template: Template) {
      pre {
        !self.isLocked : "Set is locked. It cannot be modified"
      }
      let templateID = self.templates.length
      self.templates.append(template)

      let display = template.defaultDisplay
      emit TemplateAdded(setID: self.id, templateID: UInt64(templateID), displayName: display.name, displayDescription: display.description, displayURI: display.thumbnail.uri())
    }

    // Lock the Set if it is Open. This signals that this Set
    // will mint NFTs based only on the Templates configured in this Set.
    pub fun lock() {
      pre {
        !self.isLocked : "Only an Open set can be locked."
        self.templates.length > 0
          : "Set must be configured with at least one Template."
      }
      self.isLocked = true
      emit SetLocked(setID: self.id, numTemplates: UInt64(self.templates.length))
    }

    // Mint numToMint NFTs with the supplied creator attribute. The NFT will
    // be minted into the provided receiver
    pub fun mint(
      templateID: UInt64,
      creator: Address
    ): @NFT {
      pre {
        templateID < UInt64(self.templates.length)
          : "templateID does not exist in Set."
        self.templates[templateID].mintID == nil
          : "Template has already been marked as minted."
      }
      let nft <-create NFT(
          setID: self.id,
          templateID: templateID,
          creator: creator
        )
      self.templates[templateID].markMinted(nftID: nft.id)
      self.minted = self.minted + 1
      return <- nft
    }

    // Reveal a specified Template in a Set.
    pub fun revealTemplate(
      templateID: UInt64,
      metadata: {TemplateMetadata},
      salt: [UInt8]
    ) {
      pre {
        templateID < UInt64(self.templates.length)
          : "templateId does not exist in Set."
        self.templates[templateID].mintID != nil
          : "Template has not been marked as minted."
      }
      let template = &self.templates[templateID] as &Template
      template.reveal(metadata: metadata, salt: salt)

      let display = metadata.display()
      emit NFTRevealed(
        nftID: template.mintID!,
        setID: self.id,
        templateID: templateID,
        displayName: display.name,
        displayDescription: display.description,
        displayURI: display.thumbnail.uri(),
        metadata: metadata.repr(),
      )
    }

    init(id: UInt64, metadata: SetMetadata) {
      self.id = id
      self.metadata = metadata

      self.isLocked = false
      self.templates = []

      self.minted = 0
      emit SetCreated(setID: id, metadata: metadata)
    }
  }

  // Create and store a new Set. Return the id of the new Set.
  access(contract) fun createSet(metadata: SetMetadata): UInt64 {
    let setID = NastyGirlz.totalSets

    let newSet <- create Set(
      id: setID,
      metadata: metadata
    )
    NastyGirlz.sets[setID] <-! newSet
    NastyGirlz.totalSets = NastyGirlz.totalSets + 1
    return setID
  }

  // Number of sets created by contract
  pub fun setsCount(): UInt64 {
    return NastyGirlz.totalSets
  }

  // Metadata for the Set
  pub struct SetMetadata {
    pub var name: String
    pub var description: String
    pub var externalID: String

    init(name: String, description: String, externalID: String) {
      self.name = name
      self.description = description
      self.externalID = externalID
    }
  }

  // A summary report of a Set
  pub struct SetReport {
    pub let id: UInt64
    pub let isLocked: Bool
    pub let metadata: SetMetadata
    pub let numTemplates: Int
    pub let numMinted: UInt64
    init(
      id: UInt64,
      isLocked: Bool,
      metadata: SetMetadata,
      numTemplates: Int,
      numMinted: UInt64
    ) {
      self.id = id
      self.isLocked = isLocked
      self.metadata = metadata
      self.numTemplates = numTemplates
      self.numMinted = numMinted
    }
  }

  // Generate a SetReport for informational purposes (to be used with scripts)
  pub fun generateSetReport(setID: UInt64): SetReport {
    let setRef = (&self.sets[setID] as &Set?)!
    return SetReport(
      id: setID,
      isLocked: setRef.isLocked,
      metadata: setRef.metadata,
      numTemplates: setRef.templates.length,
      numMinted: setRef.minted
    )
  }

  // Template
  //
  // Templates are mechanisms for handling NFT metadata. These should ideally
  // have a one to one mapping with NFTs, with the assumption that NFTs are
  // designed to be unique. Template allows the creator to commit to an NFTs
  // metadata without having to reveal the metadata itself. The constructor
  // accepts a byte array checksum. After construction, anyone with access
  // to this struct will be able to reveal the metadata, which must be any
  // struct which implements TemplateMetadata and MetadataViews.Resolver such that
  // SHA3_256(salt || metadata.hash()) == checksum.
  //
  // Templates can be seen as metadata managers for NFTs. As such, Templates
  // also implement the MetadataResolver interface to conform with standards.

  // Safe Template interface for anyone inspecting NFTs
  pub struct interface NFTTemplate {
    pub let defaultDisplay: MetadataViews.Display
    pub var metadata: {TemplateMetadata}?
    pub var mintID: UInt64?
    pub fun checksum(): [UInt8]
    pub fun salt(): [UInt8]?
    pub fun revealed(): Bool
  }

  pub struct Template: NFTTemplate {

    // checksum as described above
    access(self) let _checksum: [UInt8]

    // Default Display in case the Template has not yet been revealed
    pub let defaultDisplay: MetadataViews.Display

    // salt and metadata are optional so they can be revealed later, such that
    // SHA3_256(salt || metadata.hash()) == checksum
    access(self) var _salt: [UInt8]?
    pub var metadata: {TemplateMetadata}?

    // Convenience attribute to mark whether or not Template has minted NFT
    pub var mintID: UInt64?

    // Helper function to check if a proposed metadata and salt reveal would
    // produce the configured checksum in a Template
    pub fun validate(metadata: {TemplateMetadata}, salt: [UInt8]): Bool {
      let hash = String.encodeHex(
        HashAlgorithm.SHA3_256.hash(
          salt.concat(metadata.hash())
        )
      )
      let checksum = String.encodeHex(self.checksum())
      return hash == checksum
    }

    // Reveal template metadata and salt. validate() is called as a precondition
    // so collector can be assured metadata was not changed
    pub fun reveal(metadata: AnyStruct{TemplateMetadata}, salt: [UInt8]) {
      pre {
        self.mintID != nil
          : "Template has not yet been minted."
        !self.revealed()
          : "NFT Template has already been revealed"
        self.validate(metadata: metadata, salt: salt)
          : "salt || metadata.hash() does not hash to checksum"
      }
      self.metadata = metadata
      self._salt = salt
    }

    pub fun checksum(): [UInt8] {
      return self._checksum
    }

    pub fun salt(): [UInt8]? {
      return self._salt
    }

    // Check to see if metadata has been revealed
    pub fun revealed(): Bool {
      return self.metadata != nil
    }

    // Mark the NFT as minted
    pub fun markMinted(nftID: UInt64) {
      self.mintID = nftID
    }

    init(checksum: [UInt8], defaultDisplay: MetadataViews.Display) {
      self._checksum = checksum
      self.defaultDisplay = defaultDisplay

      self._salt = nil
      self.metadata = nil
      self.mintID = nil
    }
  }

  // Public helper function to be able to inspect any Template
  pub fun getTemplate(setID: UInt64, templateID: UInt64): {NFTTemplate} {
    let setRef = (&self.sets[setID] as &Set?)!
    return setRef.templates[templateID]
  }

  pub resource SetMinter {
    pub let setID: UInt64

    init(setID: UInt64) {
      self.setID = setID
    }

    pub fun mint(templateID: UInt64, creator: Address): @NFT {
      let set = (&NastyGirlz.sets[self.setID] as &Set?)!
      return <- set.mint(templateID: templateID, creator: creator)
    }
  }

  // Admin
  //
  // The Admin is meant to be a singleton superuser of the contract. The Admin
  // is responsible for creating Sets and SetManagers for managing the sets.
  pub resource Admin {

    // Create a set with the provided SetMetadata.
    pub fun createSet(metadata: SetMetadata): UInt64 {
      return NastyGirlz.createSet(metadata: metadata)
    }

    pub fun borrowSet(setID: UInt64): &Set {
      return (&NastyGirlz.sets[setID] as &Set?)!
    }

    pub fun createSetMinter(setID: UInt64): @SetMinter {
      return <- create SetMinter(setID: setID)
    }
  }

  // Contract constructor
  init() {

    // Collection Paths
    self.CollectionStoragePath = /storage/NastyGirlzCollection
    self.CollectionPublicPath = /public/NastyGirlzCollection
    self.CollectionPrivatePath = /private/NastyGirlzCollection

    // Admin Storage Path. Save the singleton Admin resource to contract
    // storage.
    self.AdminStoragePath = /storage/NastyGirlzAdmin
    self.account.save<@Admin>(<- create Admin(), to: self.AdminStoragePath)

    // Initializations
    self.totalSupply = 0
    self.totalSets = 0
    self.sets <- {}

    emit ContractInitialized()
  }
}



"
-------
"// BasicToken.cdc
//
// The BasicToken contract is a sample implementation of a fungible token on Flow.
//
// Fungible tokens behave like everyday currencies -- they can be minted, transferred or
// traded for digital goods.
//
// Follow the fungible tokens tutorial to learn more: https://developers.flow.com/cadence/tutorial/06-fungible-tokens
//
// This is a basic implementation of a Fungible Token and is NOT meant to be used in production
// See the Flow Fungible Token standard for real examples: https://github.com/onflow/flow-ft

pub contract BasicToken {

    // Vault
    //
    // Each user stores an instance of only the Vault in their storage
    // The functions in the Vault and governed by the pre and post conditions
    // in the interfaces when they are called.
    // The checks happen at runtime whenever a function is called.
    //
    // Resources can only be created in the context of the contract that they
    // are defined in, so there is no way for a malicious user to create Vaults
    // out of thin air. A special Minter resource or constructor function needs to be defined to mint
    // new tokens.
    //
    pub resource Vault {

		// keeps track of the total balance of the account's tokens
        pub var balance: UFix64

        // initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        // withdraw
        //
        // Function that takes an integer amount as an argument
        // and withdraws that amount from the Vault.
        //
        // It creates a new temporary Vault that is used to hold
        // the money that is being transferred. It returns the newly
        // created Vault to the context that called so it can be deposited
        // elsewhere.
        //
        pub fun withdraw(amount: UFix64): @Vault {
            self.balance = self.balance - amount
            return <-create Vault(balance: amount)
        }

        // deposit
        //
        // Function that takes a Vault object as an argument and adds
        // its balance to the balance of the owners Vault.
        //
        // It is allowed to destroy the sent Vault because the Vault
        // was a temporary holder of the tokens. The Vault's balance has
        // been consumed and therefore can be destroyed.
        pub fun deposit(from: @Vault) {
            self.balance = self.balance + from.balance
            destroy from
        }
    }

    // createVault
    //
    // Function that creates a new Vault with an initial balance
    // and returns it to the calling context. A user must call this function
    // and store the returned Vault in their storage in order to allow their
    // account to be able to receive deposits of this token type.
    //
    pub fun createVault(): @Vault {
        return <-create Vault(balance: 30.0)
    }

    // The init function for the contract. All fields in the contract must
    // be initialized at deployment. This is just an example of what
    // an implementation could do in the init function. The numbers are arbitrary.
    init() {
        // create the Vault with the initial balance and put it in storage
        // account.save saves an object to the specified `to` path
        // The path is a literal path that consists of a domain and identifier
        // The domain must be `storage`, `private`, or `public`
        // the identifier can be any name
        let vault <- self.createVault()
        self.account.save(<-vault, to: /storage/CadenceFungibleTokenTutorialVault)
    }
}

"
-------
"// MADE BY: Emerald City, Jacob Tucker

// This contract is probably the most confusing element of the FLOAT
// platform. Listed here is a bunch of Structs which all implement
// FLOAT.IVerifier.

// This pattern allows us to define arbitrary "restrictions" or "verifiers"
// on our FLOAT Events. For example, Timelock is a verifier that makes sure
// the current time is within the start and end date that the FLOAT Event host
// specified when they created an event.

// The cool part is all of these verifiers are totally optional, and are only
// passed in with the newly created event if the host wanted to enable them.
// You can mix and match them however you want. For example, one event I could
// use both Timelock and Limited, and for another event I could just use Secret.

// Each verifier must have a `verify` function that takes in a generalized `params`
// argument so we can pass user data through as well as info about the event itself.
// This is important for Secret for example because we want to pass the users guess
// of the secret code through. For Limited, we need to know the totalSupply of the event,
// so we pass it through as well.

import FLOAT from 0x2d4c3caffbeab845
import FungibleToken from 0xf233dcee88fe0abe
import FlowToken from 0x1654653399040a61
import Crypto
import FLOATEventSeries from 0x1dd5caae66e2c440

pub contract FLOATVerifiers {

    // The "verifiers" to be used

    //
    // Timelock
    //
    // Specifies a time range in which the
    // FLOAT from an event can be claimed
    pub struct Timelock: FLOAT.IVerifier {
        // An automatic switch handled by the contract
        // to stop people from claiming after a certain time.
        pub let dateStart: UFix64
        pub let dateEnding: UFix64

        pub fun verify(_ params: {String: AnyStruct}) {
            assert(
                getCurrentBlock().timestamp >= self.dateStart,
                message: "This FLOAT Event has not started yet."
            )
            assert(
                getCurrentBlock().timestamp <= self.dateEnding,
                message: "Sorry! The time has run out to mint this FLOAT."
            )
        }

        init(_dateStart: UFix64, _timePeriod: UFix64) {
            self.dateStart = _dateStart
            self.dateEnding = self.dateStart + _timePeriod
        }
    }

    //
    // Secret
    //
    // Specifies a secret code in order
    // to claim a FLOAT (not very secure, but cool feature)
    pub struct Secret: FLOAT.IVerifier {
        // The secret code, set by the owner of this event.
        access(self) let secretPhrase: String

        pub fun verify(_ params: {String: AnyStruct}) {
            let secretPhrase = params["secretPhrase"]! as! String
            assert(
                self.secretPhrase == secretPhrase,
                message: "You did not input the correct secret phrase."
            )
        }

        init(_secretPhrase: String) {
            self.secretPhrase = _secretPhrase
        }
    }

    //
    // Limited
    //
    // Specifies a limit for the amount of people
    // who can CLAIM. Not to be confused with how many currently
    // hold a FLOAT from this event, since users can
    // delete their FLOATs.
    pub struct Limited: FLOAT.IVerifier {
        pub var capacity: UInt64

        pub fun verify(_ params: {String: AnyStruct}) {
            let event = params["event"]! as! &FLOAT.FLOATEvent{FLOAT.FLOATEventPublic}
            let currentCapacity = event.totalSupply
            assert(
                currentCapacity < self.capacity,
                message: "This FLOAT Event is at capacity."
            )
        }

        init(_capacity: UInt64) {
            self.capacity = _capacity
        }
    }

    //
    // MultipleSecret
    //
    // Allows for Multiple Secret codes
    // Everytime a secret gets used, it gets removed
    // from the list.
    pub struct MultipleSecret: FLOAT.IVerifier {
        access(self) let secrets: {String: Bool}

        pub fun verify(_ params: {String: AnyStruct}) {
            let secretPhrase = params["secretPhrase"]! as! String
            assert(
                self.secrets[secretPhrase] != nil,
                message: "You did not input a correct secret phrase."
            )
            self.secrets.remove(key: secretPhrase)
        }

        init(_secrets: [String]) {
            self.secrets = {}
            for secret in _secrets {
                self.secrets[secret] = true
            }
        }
    }

    //
    // SecretV2
    //
    // Much more secure than Secret
    pub struct SecretV2: FLOAT.IVerifier {
        pub let publicKey: String

        pub fun verify(_ params: {String: AnyStruct}) {
            let data: [UInt8] = (params["claimee"]! as! Address).toString().utf8
            let sig: [UInt8] = (params["secretSig"]! as! String).decodeHex()
            let publicKey = PublicKey(publicKey: self.publicKey.decodeHex(), signatureAlgorithm: SignatureAlgorithm.ECDSA_P256)
            // validates that the "sig" was what was produced by signing "data" using the private key paired to "publicKey"
            let valid = publicKey.verify(signature: sig, signedData: data, domainSeparationTag: "FLOW-V0.0-user", hashAlgorithm: HashAlgorithm.SHA3_256)

            assert(
                valid,
                message: "You did not input the correct secret phrase."
            )
        }

        init(_publicKey: String) {
            self.publicKey = _publicKey
        }
    }

    //
    // MinimumBalance
    //
    // Requires a minimum Flow Balance to succeed
    pub struct MinimumBalance: FLOAT.IVerifier {
        pub let amount: UFix64

        pub fun verify(_ params: {String: AnyStruct}) {
            let claimee: Address = params["claimee"]! as! Address
            let flowVault = getAccount(claimee).getCapability(/public/flowTokenBalance)
                                .borrow<&FlowToken.Vault{FungibleToken.Balance}>()
                                ?? panic("Could not borrow the Flow Token Vault")

            assert(
                flowVault.balance >= self.amount,
                message: "You do not meet the minimum required Flow Token balance."
            )
        }

        init(_amount: UFix64) {
            self.amount = _amount
        }
    }

    //
    // ChallengeAchievementPoint
    //
    // Specifies a FLOAT Challenge to limit who accomplished
    // a number of achievement point can claim the FLOAT
    pub struct ChallengeAchievementPoint: FLOAT.IVerifier {
        pub let challengeIdentifier: FLOATEventSeries.EventSeriesIdentifier
        pub let challengeThresholdPoints: UInt64

        pub fun verify(_ params: {String: AnyStruct}) {
            let claimee: Address = params["claimee"]! as! Address
            if let achievementBoard = getAccount(claimee)
                .getCapability(FLOATEventSeries.FLOATAchievementBoardPublicPath)
                .borrow<&FLOATEventSeries.AchievementBoard{FLOATEventSeries.AchievementBoardPublic}>()
            {
                // build goal status by different ways
                if let record = achievementBoard.borrowAchievementRecordRef(
                    host: self.challengeIdentifier.host,
                    seriesId: self.challengeIdentifier.id
                ) {
                    assert(
                        record.score >= self.challengeThresholdPoints,
                        message: "You do not meet the minimum required Achievement Point for Challenge#".concat(self.challengeIdentifier.id.toString())
                    )
                } else {
                    panic("You do not have Challenge Achievement Record for Challenge#".concat(self.challengeIdentifier.id.toString()))
                }
            } else {
                panic("You do not have Challenge Achievement Board")
            }
        }

        init(_challengeHost: Address, _challengeId: UInt64, thresholdPoints: UInt64) {
            self.challengeThresholdPoints = thresholdPoints
            self.challengeIdentifier = FLOATEventSeries.EventSeriesIdentifier(_challengeHost, _challengeId)
            // ensure challenge exists
            self.challengeIdentifier.getEventSeriesPublic()
        }
    }

    //
    // Email
    //
    // Requires an admin to sign off that a user
    // address provided their email
    pub struct Email: FLOAT.IVerifier {
        pub let publicKey: String

        pub fun verify(_ params: {String: AnyStruct}) {
            let event = params["event"]! as! &FLOAT.FLOATEvent{FLOAT.FLOATEventPublic}
            let claimeeAddressAsString: String = (params["claimee"]! as! Address).toString()
            let messageString: String = claimeeAddressAsString.concat(" provided email for eventId ").concat(event.eventId.toString())
            let data: [UInt8] = messageString.utf8
            let sig: [UInt8] = (params["emailSig"]! as! String).decodeHex()
            let publicKey = PublicKey(publicKey: self.publicKey.decodeHex(), signatureAlgorithm: SignatureAlgorithm.ECDSA_P256)
            // validates that the "sig" was what was produced by signing "data" using the private key paired to "publicKey"
            let valid = publicKey.verify(signature: sig, signedData: data, domainSeparationTag: "FLOW-V0.0-user", hashAlgorithm: HashAlgorithm.SHA3_256)

            assert(
                valid,
                message: "You did not input the correct secret phrase."
            )
        }

        init(_publicKey: String) {
            self.publicKey = _publicKey
        }
    }

}"
-------
"import FUSD from 0x3c5959b568896393
import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import FantastecSwapDataV2 from 0x4bbff461fa8f6192
import FantastecSwapDataProperties from 0x4bbff461fa8f6192
import ViewResolver from 0x1d7e57aa55817448

pub contract FantastecNFT: NonFungibleToken, ViewResolver {

  // Events
  //
  pub event ContractInitialized()
  pub event Withdraw(id: UInt64, from: Address?)
  pub event Deposit(id: UInt64, to: Address?)
  pub event Minted(id: UInt64)
  pub event Destroyed(id: UInt64, reason: String)

  // Named Paths
  //
  pub let CollectionStoragePath: StoragePath
  pub let CollectionPublicPath: PublicPath
  pub let MinterStoragePath: StoragePath

  // totalSupply
  // The total number of FantastecNFT that have ever been minted
  pub var totalSupply: UInt64

  pub struct Item {
    pub let id: UInt64
    pub let cardId: UInt64
    pub let edition: UInt64
    pub let mintNumber: UInt64
    pub let licence: String
    pub let dateMinted: String
    pub let metadata: {String: String}
    init(
        id: UInt64,
        cardId: UInt64,
        edition: UInt64,
        mintNumber: UInt64,
        licence: String,
        dateMinted: String,
        metadata: {String: String}){
      self.id = id
      self.cardId = cardId
      self.edition = edition
      self.mintNumber = mintNumber
      self.licence = licence
      self.dateMinted = dateMinted
      self.metadata = metadata
    }
  }

  // NFT: FantastecNFT.NFT
  // Raw NFT, doesn't currently restrict the caller instantiating an NFT
  //
  pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
    // The token's ID
    pub let id: UInt64
    pub let cardId: UInt64
    pub let edition: UInt64
    pub let mintNumber: UInt64
    pub let licence: String
    pub let dateMinted: String
    pub let metadata: {String: String}

    // initializer
    //
    init(item: Item) {
      self.id = item.id
      self.cardId = item.cardId
      self.edition = item.edition
      self.mintNumber = item.mintNumber
      self.licence = item.licence
      self.dateMinted = item.dateMinted
      self.metadata = item.metadata
    }

    access(self) fun concatenateStrings(_ strings: [String?]): String {
      var res = ""
      for string in strings {
        if (string != nil) {
          if (res.length > 0) {
            res = res.concat(", ")
          }
          res = res.concat(string!)
        }
      }
      return res
    }

    access(self) fun getCard(): FantastecSwapDataV2.CardData? {
      let card = FantastecSwapDataV2.getCardById(id: self.cardId)
      return card
    }

    access(self) fun getCardCollection(): FantastecSwapDataV2.CardCollectionData? {
      let card = self.getCard()
      if (card != nil) {
        let cardCollection = FantastecSwapDataV2.getCardCollectionById(id: card!.collectionId)
        return cardCollection
      }
      return nil
    }

    access(self) fun getCardRoyalties(): [MetadataViews.Royalty] {
      let card = self.getCard()
      let cardMetadata = card?.metadata ?? {}
      let royaltiesMetadata = cardMetadata["royalties"]
      var royalties: [MetadataViews.Royalty] = []
      if (royaltiesMetadata != nil) {
        for royaltyElement in royaltiesMetadata! {
          let royalty = royaltyElement as! FantastecSwapDataProperties.Royalty
          let receiver = getAccount(royalty.address).getCapability<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdBalance)
          let cut = royalty.percentage / 100.0
          let description = royalty.id.toString()
          royalties.append(
            MetadataViews.Royalty(receiver: receiver, cut: cut, description: description)
          )
        }
      }
      return royalties
    }

    access(self) fun getCardMintVolume(): FantastecSwapDataProperties.MintVolume? {
      let card = self.getCard()
      let cardMetadata = card?.metadata ?? {}
      let mintVolumeMetadata = cardMetadata["mintVolume"]
      if (mintVolumeMetadata != nil && mintVolumeMetadata!.length > 0) {
        let mintVolume = mintVolumeMetadata![0] as? FantastecSwapDataProperties.MintVolume
        return mintVolume
      }
      return nil
    }

    access(self) fun getCardMediaFile(_ mediaType: String): MetadataViews.HTTPFile {
      let card = self.getCard()
      let cardMetadata = card?.metadata ?? {}
      let mediaMetadata = cardMetadata["media"]
      if (mediaMetadata != nil) {
        for mediaElement in mediaMetadata! {
          let media = mediaElement as! FantastecSwapDataProperties.Media
          if (media.mediaType == mediaType) {
            return MetadataViews.HTTPFile(url: media.url)
          }
        }
      }
      return MetadataViews.HTTPFile(url: "")
    }

    access(self) fun getCardCollectionMediaFile(_ mediaType: String): MetadataViews.HTTPFile {
      let cardCollection = self.getCardCollection()
      let cardCollectionMetadata = cardCollection?.metadata ?? {}
      let mediaMetadata = cardCollectionMetadata["media"]
      if (mediaMetadata != nil) {
        for mediaElement in mediaMetadata! {
          let media = mediaElement as! FantastecSwapDataProperties.Media
          if (media.mediaType == mediaType) {
            return MetadataViews.HTTPFile(url: media.url)
          }
        }
      }
      return MetadataViews.HTTPFile(url: "")
    }

    access(self) fun getCardCollectionSocials(): {String: MetadataViews.ExternalURL} {
      let cardCollection = self.getCardCollection()
      let cardCollectionMetadata = cardCollection?.metadata ?? {}
      let socialsMetadata = cardCollectionMetadata["socials"]
      var socialsDictionary: {String: MetadataViews.ExternalURL} = {}
      if (socialsMetadata != nil) {
        for socialElement in socialsMetadata! {
          let social = socialElement as! FantastecSwapDataProperties.Social
          socialsDictionary[social.type] = MetadataViews.ExternalURL(social.url)
        }
      }
      return socialsDictionary
    }

    access(self) fun getCardCollectionPartner(): FantastecSwapDataProperties.Partner? {
      let cardCollection = self.getCardCollection()
      let cardCollectionMetadata = cardCollection?.metadata ?? {}
      let partnerMetadata = cardCollectionMetadata["partner"]
      if (partnerMetadata != nil && partnerMetadata!.length > 0) {
        let partner = partnerMetadata![0] as? FantastecSwapDataProperties.Partner
        return partner
      }
      return nil
    }

    access(self) fun getCardCollectionTeam(): FantastecSwapDataProperties.Team? {
      let cardCollection = self.getCardCollection()
      let cardCollectionMetadata = cardCollection?.metadata ?? {}
      let teamMetadata = cardCollectionMetadata["team"]
      if (teamMetadata != nil && teamMetadata!.length > 0) {
        let team = teamMetadata![0] as? FantastecSwapDataProperties.Team
        return team
      }
      return nil
    }

    access(self) fun getCardCollectionSeason(): FantastecSwapDataProperties.Season? {
      let cardCollection = self.getCardCollection()
      let cardCollectionMetadata = cardCollection?.metadata ?? {}
      let seasonMetadata = cardCollectionMetadata["season"]
      if (seasonMetadata != nil && seasonMetadata!.length > 0) {
        let season = seasonMetadata![0] as? FantastecSwapDataProperties.Season
        return season
      }
      return nil
    }

    access(self) fun getCardCollectionPlayer(): FantastecSwapDataProperties.Player? {
      let card = self.getCard()
      let cardMetadata = card?.metadata ?? {}
      let playerMetadata = cardMetadata["player"]
      if (playerMetadata != nil && playerMetadata!.length > 0) {
        let player = playerMetadata![0] as? FantastecSwapDataProperties.Player
        return player
      }
      return nil
    }

    access(self) fun getCardCollectionRedeemInfo(): FantastecSwapDataProperties.RedeemInfoV2? {
      let card = self.getCard()
      let cardMetadata = card?.metadata ?? {}
      let redeemInfoMetadata = cardMetadata["redeemInfo"]
      if (redeemInfoMetadata != nil && redeemInfoMetadata!.length > 0) {
        let redeemInfo = redeemInfoMetadata![0] as? FantastecSwapDataProperties.RedeemInfoV2
        return redeemInfo
      }
      return nil
    }

    access(self) fun getNFTCollectionDisplayDescription(): String {
      let cardCollection = self.getCardCollection()
      var description = cardCollection?.description
      if (description == nil) {
        let season = self.getCardCollectionSeason()
        let partner = self.getCardCollectionPartner()
        let team = self.getCardCollectionTeam()
        let level = self.getNFTLevel()
        description = self.concatenateStrings([season?.name, partner?.name, team?.name, level?.name])
      }
      return description!
    }

    access(self) fun extractLevelFromMetadata(
      metadata: {String: [AnyStruct{FantastecSwapDataProperties.MetadataElement}]}
    ): FantastecSwapDataProperties.Level? {
      let levelMetadata = metadata["level"]
      if (levelMetadata != nil && levelMetadata!.length > 0) {
        let level = levelMetadata![0] as? FantastecSwapDataProperties.Level
        return level
      }
      return nil
    }

    access(self) fun getNFTLevel(): FantastecSwapDataProperties.Level? {
      // If the card has a level, use that - otherwise use the collection level
      let card = self.getCard()
      let cardMetadata = card?.metadata ?? {}
      var level = self.extractLevelFromMetadata(metadata: cardMetadata)

      if (level == nil) {
        let cardCollection = self.getCardCollection()
        let cardCollectionMetadata = cardCollection?.metadata ?? {}
        level = self.extractLevelFromMetadata(metadata: cardCollectionMetadata)
      }
      return level
    }

    access(self) fun getNFTMintVolume(): UInt64? {
      // If the card has a mint volume, use that - otherwise use the collection mint volume
      let cardMintVolume = self.getCardMintVolume()
      // Card mint volume is stored in metadata
      if (cardMintVolume != nil) {
        return cardMintVolume!.value
      }
      let cardCollection = self.getCardCollection()
      if (cardCollection != nil) {
        return cardCollection!.mintVolume
      }
      return nil
    }

    access(self) fun getTraits(): MetadataViews.Traits {
      let traits = MetadataViews.dictToTraits(dict: self.metadata, excludedNames: [])

      let dateMintedTrait = MetadataViews.Trait(name: "DateMinted", value: self.dateMinted, displayType: nil, rarity: nil)
      traits.addTrait(dateMintedTrait)

      let partner = self.getCardCollectionPartner()
      if (partner != nil) {
        let partnerTrait = MetadataViews.Trait(name: "Partner", value: partner!.name, displayType: nil, rarity: nil)
        traits.addTrait(partnerTrait)
      }
      let season = self.getCardCollectionSeason()
      if (season != nil) {
        let year = season!.startDate.concat("-").concat(season!.endDate)
        let yearTrait = MetadataViews.Trait(name: "Year", value: year, displayType: nil, rarity: nil)
        traits.addTrait(yearTrait)
      }
      let team = self.getCardCollectionTeam()
      if (team != nil) {
        let teamTrait = MetadataViews.Trait(name: "TeamName", value: team!.name, displayType: nil, rarity: nil)
        traits.addTrait(teamTrait)

        let teamGenderTrait = MetadataViews.Trait(name: "TeamGender", value: team!.gender, displayType: nil, rarity: nil)
        traits.addTrait(teamGenderTrait)
      }
      let player = self.getCardCollectionPlayer()
      if (player != nil) {
        let playerNameTrait = MetadataViews.Trait(name: "PlayerName", value: player!.name, displayType: nil, rarity: nil)
        traits.addTrait(playerNameTrait)

        let playerGenderTrait = MetadataViews.Trait(name: "PlayerGender", value: player!.gender, displayType: nil, rarity: nil)
        traits.addTrait(playerGenderTrait)

        if (player!.shirtNumber != nil) {
          let shirtNumberTrait = MetadataViews.Trait(name: "PlayerShirtNumber", value: player!.shirtNumber, displayType: nil, rarity: nil)
          traits.addTrait(shirtNumberTrait)
        }

        if (player!.position != nil) {
          let positionTrait = MetadataViews.Trait(name: "PlayerPosition", value: player!.position, displayType: nil, rarity: nil)
          traits.addTrait(positionTrait)
        }
      }
      let redeemInfo = self.getCardCollectionRedeemInfo()
      if (redeemInfo != nil) {
        let retailerIdTrait = MetadataViews.Trait(name: "RetailerId", value: redeemInfo!.id, displayType: nil, rarity: nil)
        traits.addTrait(retailerIdTrait)

        let retailerNameTrait = MetadataViews.Trait(name: "RetailerName", value: redeemInfo!.retailerName, displayType: nil, rarity: nil)
        traits.addTrait(retailerNameTrait)

        let retailerPinHashTrait = MetadataViews.Trait(name: "RetailerPinHash", value: redeemInfo!.retailerPinHash, displayType: nil, rarity: nil)
        traits.addTrait(retailerPinHashTrait)

        let retailerAddressTrait = MetadataViews.Trait(name: "RetailerAddress", value: redeemInfo!.retailerAddress, displayType: nil, rarity: nil)
        traits.addTrait(retailerAddressTrait)

        if redeemInfo!.validFrom != nil {
          let validFromTrait = MetadataViews.Trait(name: "ValidFrom", value: redeemInfo!.validFrom, displayType: nil, rarity: nil)
          traits.addTrait(validFromTrait)
        }

        if redeemInfo!.validTo != nil {
          let validFromTrait = MetadataViews.Trait(name: "ValidTo", value: redeemInfo!.validFrom, displayType: nil, rarity: nil)
          traits.addTrait(validFromTrait)
        }

        if redeemInfo!.type != nil {
          let redeemTypeTrait = MetadataViews.Trait(name: "RedeemType", value: redeemInfo!.type, displayType: nil, rarity: nil)
          traits.addTrait(redeemTypeTrait)
        }

        if redeemInfo!.t_and_cs != nil {
          let tAndCsTrait = MetadataViews.Trait(name: "TAndCs", value: redeemInfo!.t_and_cs, displayType: nil, rarity: nil)
          traits.addTrait(tAndCsTrait)
        }

        if redeemInfo!.description != nil {
          let descriptionTrait = MetadataViews.Trait(name: "Description", value: redeemInfo!.description, displayType: nil, rarity: nil)
          traits.addTrait(descriptionTrait)
        }
      }
      let card = self.getCard()
      if (card != nil) {
        let cardIdTrait = MetadataViews.Trait(name: "CardId", value: card!.id, displayType: nil, rarity: nil)
        traits.addTrait(cardIdTrait)

        let cardTypeTrait = MetadataViews.Trait(name: "CardType", value: card!.type, displayType: nil, rarity: nil)
        traits.addTrait(cardTypeTrait)

        let cardAspectRatioTrait = MetadataViews.Trait(name: "CardAspectRatio", value: card!.aspectRatio, displayType: nil, rarity: nil)
        traits.addTrait(cardAspectRatioTrait)

        let collectionIdTrait = MetadataViews.Trait(name: "CollectionId", value: card!.collectionId, displayType: nil, rarity: nil)
        traits.addTrait(collectionIdTrait)
      }
      let mintVolume = self.getNFTMintVolume()
      if (mintVolume != nil) {
        let mintVolumeTrait = MetadataViews.Trait(name: "MintVolume", value: mintVolume!, displayType: nil, rarity: nil)
        traits.addTrait(mintVolumeTrait)
      }

      return traits
    }

    pub fun getViews(): [Type] {
      return [
        Type<MetadataViews.Display>(),
        Type<MetadataViews.Editions>(),
        Type<MetadataViews.ExternalURL>(),
        Type<MetadataViews.NFTCollectionData>(),
        Type<MetadataViews.NFTCollectionDisplay>(),
        Type<MetadataViews.Serial>(),
        Type<MetadataViews.Traits>(),
        Type<MetadataViews.Royalties>()
      ]
    }

    pub fun resolveView(_ view: Type): AnyStruct? {
      switch (view) {
        case Type<MetadataViews.Display>():
          let card = self.getCard()
          if (card == nil) {
            return nil
          }
          let name = card!.name
          let cardCollection = self.getCardCollection()
          var description = cardCollection != nil ? name.concat(", ").concat(cardCollection!.title) : name
          let level = self.getNFTLevel()
          if (level != nil) {
            description = description.concat(", ").concat(level!.name)
          }
          var thumbnail = self.getCardMediaFile("CARD_THUMBNAIL")

          let display = MetadataViews.Display(
            name: name,
            description: description,
            thumbnail: thumbnail
          )
          return display

        case Type<MetadataViews.Medias>():
          let items: [MetadataViews.Media] = []
          let animation = self.getCardMediaFile("CARD_ANIMATION")
          if (animation.uri() != "") {
            let animationMedia = MetadataViews.Media(
              file: animation,
              type: "video/mp4"
            )
            items.append(animationMedia)
          }
          let frame = self.getCardMediaFile("CARD_FRAME")
          if (frame.uri() != "") {
            let frameMedia = MetadataViews.Media(
              file: frame,
              type: "video/mp4"
            )
            items.append(frameMedia)
          }
          let image = self.getCardMediaFile("CARD_IMAGE")
          if (image.uri() != "") {
            let imageMedia = MetadataViews.Media(
              file: image,
              type: "image/png" // TODO: get file extensiuon
            )
            items.append(imageMedia)
          }
          let thumbnail = self.getCardMediaFile("CARD_THUMBNAIL")
          if (thumbnail.uri() != "") {
            let thumbnailMedia = MetadataViews.Media(
              file: thumbnail,
              type: "image/jpeg"
            )
            items.append(thumbnailMedia)
          }
          let medias = MetadataViews.Medias(items)
          return medias

        case Type<MetadataViews.Editions>():
          let card = self.getCard()
          if (card == nil) {
            return nil
          }
          let name = card!.name
          let number = self.mintNumber
          let cardCollection = self.getCardCollection()
          var max: UInt64? = self.getNFTMintVolume() ?? 0
          if max! < number {
            max = nil
          }
          let editionInfo = MetadataViews.Edition(name: name, number: number, max: max)
          return MetadataViews.Editions([editionInfo])

        case Type<MetadataViews.ExternalURL>():
          return MetadataViews.ExternalURL("https://www.fantastec-swap.io/nft/view?id=".concat(self.id.toString()))

        case Type<MetadataViews.NFTCollectionData>():
          return MetadataViews.NFTCollectionData(
            storagePath: FantastecNFT.CollectionStoragePath,
            publicPath: FantastecNFT.CollectionPublicPath,
            providerPath: /private/FantastecNFTCollection,
            publicCollection: Type<&FantastecNFT.Collection{FantastecNFT.FantastecNFTCollectionPublic}>(),
            publicLinkedType: Type<&FantastecNFT.Collection{FantastecNFT.FantastecNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
            providerLinkedType: Type<&FantastecNFT.Collection{NonFungibleToken.CollectionPublic, FantastecNFT.FantastecNFTCollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(),
            createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                return <- FantastecNFT.createEmptyCollection()
            })
          )

        case Type<MetadataViews.NFTCollectionDisplay>():
          let cardCollection = self.getCardCollection()
          let name = cardCollection?.title ?? ""
          let description = self.getNFTCollectionDisplayDescription()
          let squareImageMedia = MetadataViews.Media(
            file: self.getCardCollectionMediaFile("COLLECTION_LOGO_IMAGE"),
            type: "image/png"
          )
          let bannerImageMedia = MetadataViews.Media(
            file: self.getCardCollectionMediaFile("COLLECTION_HEADER_IMAGE"),
            type: "image/png"
          )
          return MetadataViews.NFTCollectionDisplay(
            name: name,
            description: description,
            externalURL: MetadataViews.ExternalURL(""),
            squareImage: squareImageMedia,
            bannerImage: bannerImageMedia,
            socials: self.getCardCollectionSocials()
          )

        case Type<MetadataViews.Serial>():
          return MetadataViews.Serial(self.uuid)

        case Type<MetadataViews.Traits>():
          return self.getTraits()

        case Type<MetadataViews.Royalties>():
          return MetadataViews.Royalties(self.getCardRoyalties())
      }

      return nil
    }
  }

  // This is the interface that users can cast their FantastecNFT Collection as
  // to allow others to deposit FantastecNFTs into their Collection. It also allows for reading
  // the details of FantastecNFTs in the Collection.
  pub resource interface FantastecNFTCollectionPublic {
    pub fun deposit(token: @NonFungibleToken.NFT)
    pub fun getIDs(): [UInt64]
    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
    pub fun borrowFantastecNFT(id: UInt64): &FantastecNFT.NFT? {
      post {
        (result == nil) || (result?.id == id):
          "Cannot borrow FantastecNFT reference: The ID of the returned reference is incorrect"
      }
    }
  }

  // Collection
  // A collection of Moment NFTs owned by an account
  //
  pub resource Collection: FantastecNFTCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
    // dictionary of NFT conforming tokens
    // NFT is a resource type with an UInt64 ID field
    // metadataObjs is a dictionary of metadata mapped to NFT IDs
    //
    pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

    // deposit
    // Takes a NFT and adds it to the collections dictionary
    // and adds the ID to the id array
    //
    pub fun deposit(token: @NonFungibleToken.NFT) {
      let token <- token as! @FantastecNFT.NFT

      let id: UInt64 = token.id

      // add the new token to the dictionary which removes the old one
      // TODO: This should never happen
      let oldToken <- self.ownedNFTs[id] <- token

      emit Deposit(id: id, to: self.owner?.address)

      if (oldToken != nil){
        emit Destroyed(id: id, reason: "replaced existing resource with the same id")
      }

      destroy oldToken
    }

    // getIDs
    // Returns an array of the IDs that are in the collection
    //
    pub fun getIDs(): [UInt64] {
      return self.ownedNFTs.keys
    }

    // borrowNFT
    // Gets a reference to an NFT in the collection
    // so that the caller can read its metadata and call its methods
    //
    pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
      return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
    }

    // borrowFantastecNFT
    // Gets a reference to an NFT in the collection as a FantastecNFT,
    // exposing all of its fields.
    // This is safe as there are no functions that can be called on the FantastecNFT.
    //
    pub fun borrowFantastecNFT(id: UInt64): &FantastecNFT.NFT? {
      if self.ownedNFTs[id] != nil {
        let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT?
        return ref! as! &FantastecNFT.NFT
      } else {
        return nil
      }
    }

    // withdraw
    // Removes an NFT from the collection and moves it to the caller
    //
    pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
      let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

      emit Withdraw(id: token.id, from: self.owner?.address)

      return <-token
    }

    pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
      let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
      let fantastecNFT = nft as! &FantastecNFT.NFT
      return fantastecNFT as &AnyResource{MetadataViews.Resolver}
    }

    // destructor
    destroy() {
      destroy self.ownedNFTs
    }

    // initializer
    //
    init () {
      self.ownedNFTs <- {}
    }
  }

  // createEmptyCollection
  // public function that anyone can call to create a new empty collection
  //
  pub fun createEmptyCollection(): @NonFungibleToken.Collection {
    return <- create Collection()
  }

  // NFTMinter
  // Resource that an admin or something similar would own to be
  // able to mint new NFTs
  //
  pub resource NFTMinter {
    // Mints a new NFTs
    // Increments mintNumber
    // returns the newly minted NFT
    //
    pub fun mintAndReturnNFT(
        cardId: UInt64,
        edition: UInt64,
        mintNumber: UInt64,
        licence: String,
        dateMinted: String,
        metadata: {String: String}): @FantastecNFT.NFT {

      let newId = FantastecNFT.totalSupply + (1 as UInt64)

      let nftData: Item = Item(
        id: FantastecNFT.totalSupply,
        cardId: cardId,
        edition: edition,
        mintNumber: mintNumber,
        licence: licence,
        dateMinted: dateMinted,
        metadata: metadata,
      )
      var newNFT <-create FantastecNFT.NFT(item: nftData)

      // emit and update contract
      emit Minted(id: nftData.id)

      // update contracts
      FantastecNFT.totalSupply = newId

      return <- newNFT
    }

    // Mints a new NFTs
    // Increments mintNumber
    // deposits the NFT into the recipients collection using their collection reference
    //
    pub fun mintNFT(
        recipient: &{NonFungibleToken.CollectionPublic},
        cardId: UInt64,
        edition: UInt64,
        mintNumber: UInt64,
        licence: String,
        dateMinted: String,
        metadata: {String: String}) {

      var newNFT <- self.mintAndReturnNFT(
        cardId: cardId,
        edition: edition,
        mintNumber: mintNumber,
        licence: licence,
        dateMinted: dateMinted,
        metadata: metadata
      )

      // deposit it in the recipient's account using their reference
      recipient.deposit(token: <- newNFT)
    }
  }

    /// Function that resolves a metadata view for this contract.
    ///
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    pub fun resolveView(_ view: Type): AnyStruct? {
        switch view {
            case Type<MetadataViews.NFTCollectionData>():
                return MetadataViews.NFTCollectionData(
                    storagePath: FantastecNFT.CollectionStoragePath,
                    publicPath: FantastecNFT.CollectionPublicPath,
                    providerPath: /private/FantastecNFTCollection,
                    publicCollection: Type<&FantastecNFT.Collection{FantastecNFT.FantastecNFTCollectionPublic}>(),
                    publicLinkedType: Type<&FantastecNFT.Collection{FantastecNFT.FantastecNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
                    providerLinkedType: Type<&FantastecNFT.Collection{FantastecNFT.FantastecNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(),
                    createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                        return <-FantastecNFT.createEmptyCollection()
                    })
                )
            case Type<MetadataViews.NFTCollectionDisplay>():
                return MetadataViews.NFTCollectionDisplay(
                        name: "Fantastec SWAP",
                        description: "Collect and Swap NFTs created exclusively for European Football clubs Real Madrid Mens and Womens, Arsenal Mens and Womens, Borussia Dortmund, and US College Athletes at Michigan State University, University of Michigan, University of Illinois, and Syracuse University.",
                        externalURL: MetadataViews.ExternalURL("https://fantastec-swap.io"),
                        squareImage: MetadataViews.Media(
                            file: MetadataViews.HTTPFile(
                                url: "https://bafkreihvx3vfgnpn4ygfdcq4w7pdlamw4maasok7xuzcfoutm3lbitwprm.ipfs.nftstorage.link/"
                            ),
                            mediaType: "image/jpeg"
                        ),
                        bannerImage: MetadataViews.Media(
                            file: MetadataViews.HTTPFile(
                                url: "https://bafybeicadjtenkcpdts3rf43a7dgcjjfasihcaed46yxkdgvehj4m33ate.ipfs.nftstorage.link/"
                            ),
                            mediaType: "image/jpeg"
                        ),
                        socials: {
                            "twitter": MetadataViews.ExternalURL("https://twitter.com/fantastecSWAP")
                        }
                    )
        }
        return nil
    }

    /// Function that returns all the Metadata Views implemented by a Non Fungible Token
    ///
    /// @return An array of Types defining the implemented views. This value will be used by
    ///         developers to know which parameter to pass to the resolveView() method.
    ///
    pub fun getViews(): [Type] {
        return [
            Type<MetadataViews.NFTCollectionData>(),
            Type<MetadataViews.NFTCollectionDisplay>()
        ]
    }

  pub fun getTotalSupply(): UInt64 {
    return FantastecNFT.totalSupply;
  }

  init(){
    // Set our named paths
    self.CollectionStoragePath = /storage/FantastecNFTCollection
    self.CollectionPublicPath = /public/FantastecNFTCollection
    self.MinterStoragePath = /storage/FantastecNFTMinter

    // Initialize the total supply
    self.totalSupply = 0

    // Create a Minter resource and save it to storage
    let minter <- create NFTMinter()
    let oldMinter <- self.account.load<@NFTMinter>(from: self.MinterStoragePath)
    self.account.save(<-minter, to: self.MinterStoragePath)
    destroy oldMinter

    emit ContractInitialized()
  }
}
"
-------
"pub contract HelloFlownaut {
   pub var greeting: String

   pub fun changeGreeting(newGreeting: String) {
      self.greeting = newGreeting
   }

   init() {
      self.greeting = "Hello World!"
   }
}"
-------
"import NonFungibleToken from 0x1d7e57aa55817448

access(all) contract QuestReward: NonFungibleToken {

    // -----------------------------------------------------------------------
    // NonFungibleToken Standard Events
    // -----------------------------------------------------------------------
    access(all) event ContractInitialized()
    access(all) event Withdraw(id: UInt64, from: Address?)
    access(all) event Deposit(id: UInt64, to: Address?)

    // -----------------------------------------------------------------------
    // Contract Events
    // -----------------------------------------------------------------------
    access(all) event Minted(id: UInt64, minterID: UInt64, rewardTemplateID: UInt32, rewardTemplate: RewardTemplate, minterAddress: Address?)
    access(all) event RewardTemplateAdded(minterID: UInt64, minterAddress: Address?, rewardTemplateID: UInt32, name: String, description: String, image: String)
    access(all) event RewardTemplateUpdated(minterID: UInt64, minterAddress: Address?, rewardTemplateID: UInt32, name: String, description: String, image: String)

    // -----------------------------------------------------------------------
    // Named Paths
    // -----------------------------------------------------------------------
    access(all) let CollectionStoragePath: StoragePath
    access(all) let CollectionPublicPath: PublicPath
    access(all) let CollectionPrivatePath: PrivatePath

    // -----------------------------------------------------------------------
    // Contract Fields
    // -----------------------------------------------------------------------
    access(all) var totalSupply: UInt64
    access(all) var rewardTemplateSupply: UInt32
    access(all) var minterSupply: UInt64
    access(self) var numberMintedPerRewardTemplate: {UInt32: UInt64}

    // -----------------------------------------------------------------------
    // Future Contract Extensions
    // -----------------------------------------------------------------------
    access(self) var metadata: {String: AnyStruct}
    access(self) var resources: @{String: AnyResource}

    access(all) struct RewardTemplate {
        access(all) let minterID: UInt64
        access(all) let id: UInt32
        access(all) let name: String
        access(all) let description: String
        access(all) let image: String

        init(minterID: UInt64, id: UInt32, name: String, description: String, image: String) {
            self.minterID = minterID
            self.id = id
            self.name = name
            self.description = description
            self.image = image
        }
    }

    access(all) resource interface Public {
        access(all) let id: UInt64
        access(all) let minterID: UInt64
        access(all) let rewardTemplateID: UInt32
        access(all) let dateMinted: UFix64
        access(all) var revealed: Bool
    }

    access(all) resource NFT: Public, NonFungibleToken.INFT {

        access(all) let id: UInt64
        access(all) let minterID: UInt64
        access(all) let rewardTemplateID: UInt32
        access(all) let dateMinted: UFix64
        access(all) var revealed: Bool
        access(self) var metadata: {String: AnyStruct}
        access(self) var resources: @{String: AnyResource}

        init(minterID: UInt64, rewardTemplateID: UInt32, rewardTemplate: RewardTemplate, minterAddress: Address?) {
            self.id = self.uuid
            self.minterID = minterID
            self.rewardTemplateID = rewardTemplateID
            self.dateMinted = getCurrentBlock().timestamp
            self.revealed = false
            self.metadata = {}
            self.resources <- {}

            QuestReward.totalSupply = QuestReward.totalSupply + 1

            QuestReward.numberMintedPerRewardTemplate[rewardTemplateID] = QuestReward.numberMintedPerRewardTemplate[rewardTemplateID]! + 1

            emit Minted(id: self.id, minterID: self.minterID, rewardTemplateID: self.rewardTemplateID, rewardTemplate: rewardTemplate, minterAddress: minterAddress)
        }

        access(all) fun reveal() {
            self.revealed = true
        }

        destroy() {
            destroy self.resources
        }
    }

    access(all) resource interface CollectionPublic {
        access(all) fun getIDs(): [UInt64]
        access(all) fun borrowQuestReward(id: UInt64): &QuestReward.NFT{Public}? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow QuestReward reference: The ID of the returned reference is incorrect"
            }
        }
    }

    access(all) resource Collection: CollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic {

        access(all) var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init() {
            self.ownedNFTs <- {}
        }

        access(all) fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("Cannot withdraw QuestReward from Collection: Missing NFT")

            emit Withdraw(id: withdrawID, from: self.owner?.address)

            return <-token
        }

        access(all) fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @QuestReward.NFT

            let id: UInt64 = token.id

            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        access(all) fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        access(all) fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        access(all) fun borrowQuestReward(id: UInt64): &QuestReward.NFT{Public}? {
            let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT?
            return (ref as! &QuestReward.NFT{Public}?)!
        }

        access(all) fun borrowEntireQuestReward(id: UInt64): &QuestReward.NFT? {
            let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT?
            return (ref as! &QuestReward.NFT?)!
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    access(all) resource interface MinterPublic {
        access(all) let id: UInt64
        access(all) let name: String
        access(all) fun getRewardTemplate(id: UInt32): RewardTemplate?
        access(all) fun getRewardTemplates(): {UInt32: RewardTemplate}
    }

    access(all) resource Minter: MinterPublic {
        access(all) let id: UInt64
        access(all) let name: String
        access(self) var rewardTemplates: {UInt32: RewardTemplate}
        access(self) var metadata: {String: AnyStruct}
        access(self) var resources: @{String: AnyResource}

        init(name: String) {
            self.id = QuestReward.minterSupply
            self.name = name
            self.rewardTemplates = {}
            self.metadata = {}
            self.resources <- {}

            QuestReward.minterSupply = QuestReward.minterSupply + 1
        }

        access(all) fun mintReward(rewardTemplateID: UInt32): @NFT {
            pre {
                self.rewardTemplates[rewardTemplateID] != nil: "Reward Template does not exist"
            }

            return <- create NFT(minterID: self.id, rewardTemplateID: rewardTemplateID, rewardTemplate: self.getRewardTemplate(id: rewardTemplateID)!, minterAddress: self.owner?.address)
        }

        access(all) fun addRewardTemplate(name: String, description: String, image: String) {
            let id: UInt32 = QuestReward.rewardTemplateSupply

            self.rewardTemplates[id] = RewardTemplate(minterID: self.id, id: id, name: name, description: description, image: image)

            QuestReward.rewardTemplateSupply = QuestReward.rewardTemplateSupply + 1

            QuestReward.numberMintedPerRewardTemplate[id] = 0

            emit RewardTemplateAdded(minterID: self.id, minterAddress: self.owner?.address, rewardTemplateID: id, name: name, description: description, image: image)

        }

        access(all) fun updateRewardTemplate(id: UInt32, name: String, description: String, image: String) {
            pre {
                self.rewardTemplates[id] != nil: "Reward Template does not exist"
            }
            self.rewardTemplates[id] = RewardTemplate(minterID: self.id, id: id, name: name, description: description, image: image)

            emit RewardTemplateUpdated(minterID: self.id, minterAddress: self.owner?.address, rewardTemplateID: id, name: name, description: description, image: image)
        }

        access(all) fun getRewardTemplate(id: UInt32): RewardTemplate? {
            return self.rewardTemplates[id]
        }

        access(all) fun getRewardTemplates(): {UInt32: RewardTemplate} {
            return self.rewardTemplates
        }

        destroy() {
            destroy self.resources
        }
    }

    access(all) fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    access(all) fun createMinter(name: String): @Minter {
        return <- create Minter(name: name)
    }

    access(all) fun getNumberMintedPerRewardTemplateKeys(): [UInt32] {
        return self.numberMintedPerRewardTemplate.keys
    }

    access(all) fun getNumberMintedPerRewardTemplate(id: UInt32): UInt64? {
        return self.numberMintedPerRewardTemplate[id]
    }

    access(all) fun getNumberMintedPerRewardTemplates(): {UInt32: UInt64} {
        return self.numberMintedPerRewardTemplate
    }

    init() {
        self.CollectionStoragePath = /storage/WonderlandQuestRewardCollection_2
        self.CollectionPublicPath = /public/WonderlandQuestRewardCollection_2
        self.CollectionPrivatePath = /private/WonderlandQuestRewardCollection_2

        self.totalSupply = 0
        self.rewardTemplateSupply = 0
        self.minterSupply = 0
        self.numberMintedPerRewardTemplate = {}

        self.metadata = {}
        self.resources <- {}

        emit ContractInitialized()
    }
}"
-------
"access(all) contract interface RewardAlgorithm {
    access(all) event ContractInitialized()
    access(all) resource interface Algorithm {
        access(all) fun randomAlgorithm(): Int
    }
}"
-------
"// HelloWorld.cdc
//
// Welcome to Cadence! This is one of the simplest programs you can deploy on Flow.
//
// The HelloWorld contract contains a single string field and a public getter function.
//
// Follow the "Hello, World!" tutorial to learn more: https://docs.onflow.org/cadence/tutorial/02-hello-world/

access(all) contract HelloWorld {

    // Declare a public field of type String.
    //
    // All fields must be initialized in the init() function.
    access(all) let greeting: String

    // The init() function is required if the contract contains any fields.
    init() {
        self.greeting = "Hello, World!"
    }

    // Public function that returns our friendly greeting!
    access(all) fun hello(): String {
        return self.greeting
    }
}
"
-------
"/*
*
*  This is forked from the exampleNFT contract:
*  https://github.com/onflow/flow-nft/blob/master/contracts/ExampleNFT.cdc
*
*/

import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import ViewResolver from 0x1d7e57aa55817448

pub contract CC0Roulette: NonFungibleToken, ViewResolver {

    /// Total supply of CC0Roulette NFTs in existence
    pub var totalSupply: UInt64

    /// The event that is emitted when the contract is created
    pub event ContractInitialized()

    /// The event that is emitted when an NFT is withdrawn from a Collection
    pub event Withdraw(id: UInt64, from: Address?)

    /// The event that is emitted when an NFT is deposited to a Collection
    pub event Deposit(id: UInt64, to: Address?)

    /// Storage and Public Paths
    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let MinterStoragePath: StoragePath

    pub let royaltyAccount: Address

    /// The core resource that represents a Non Fungible Token.
    /// New instances will be created using the NFTMinter resource
    /// and stored in the Collection resource
    ///
    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {

        /// The unique ID that each NFT has
        pub let id: UInt64

        /// Metadata fields
        pub let name: String
        pub let description: String
        pub let thumbnail: String
        access(self) let metadata: {String: AnyStruct}

        init(
            id: UInt64,
            name: String,
            description: String,
            thumbnail: String,
            metadata: {String: AnyStruct}
        ) {
            self.id = id
            self.name = name
            self.description = description
            self.thumbnail = thumbnail
            self.metadata = metadata
        }

        /// Function that returns all the Metadata Views implemented by a Non Fungible Token
        ///
        /// @return An array of Types defining the implemented views. This value will be used by
        ///         developers to know which parameter to pass to the resolveView() method.
        ///
        pub fun getViews(): [Type] {
            return [
                Type<MetadataViews.Display>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.Serial>()
            ]
        }

        /// Function that resolves a metadata view for this token.
        ///
        /// @param view: The Type of the desired view.
        /// @return A structure representing the requested view.
        ///
        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.name,
                        description: self.description,
                        thumbnail: MetadataViews.HTTPFile(
                            url: self.thumbnail
                        )
                    )
                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(
                        self.id
                    )
                case Type<MetadataViews.Royalties>():
                    return MetadataViews.Royalties(
                        [
                            MetadataViews.Royalty(
                                receiver: getAccount(CC0Roulette.royaltyAccount).getCapability<&{FungibleToken.Receiver}>(/public/GenericFTReceiver),
                                cut: 0.03,
                                description: "3% cut to contract account"
                            )
                        ]
                    )
                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL("https://chat.openai.com/g/g-ldzjWGPdV-cc0-roulette")
                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: CC0Roulette.CollectionStoragePath,
                        publicPath: CC0Roulette.CollectionPublicPath,
                        providerPath: /private/CC0RouletteCollection,
                        publicCollection: Type<&CC0Roulette.Collection{CC0Roulette.CC0RouletteCollectionPublic}>(),
                        publicLinkedType: Type<&CC0Roulette.Collection{CC0Roulette.CC0RouletteCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&CC0Roulette.Collection{CC0Roulette.CC0RouletteCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(),
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                            return <-CC0Roulette.createEmptyCollection()
                        })
                    )
                case Type<MetadataViews.NFTCollectionDisplay>():
                    let squareMedia = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: "https://www.dropbox.com/scl/fi/0exd1zmpx4b419q26j88i/roulette.png?rlkey=x4csng9lqr7ao5o5s9zxx0dvu&dl=0"
                        ),
                        mediaType: "image/png"
                    )
                    let bannerMedia = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: "https://www.dropbox.com/scl/fi/i78x9jno2gycmz8lecfpa/green-banner.png?rlkey=zc2o2qlzu8o63s7elf03z1dkb&dl=0"
                        ),
                        mediaType: "image/png"
                    )
                    return MetadataViews.NFTCollectionDisplay(
                        name: "CC0 Roulette",
                        description: "A combination of many green backgrounded CC0 projects in a single collection. First free NFT mint to be done exclusively through ChatGPT.",
                        externalURL: MetadataViews.ExternalURL("https://chat.openai.com/g/g-ldzjWGPdV-cc0-roulette"),
                        squareImage: squareMedia,
                        bannerImage: bannerMedia,
                        socials: {
                            "twitter": MetadataViews.ExternalURL("https://twitter.com/legitamit")
                        }
                    )
                case Type<MetadataViews.Traits>():
                    let traitsView = MetadataViews.dictToTraits(dict: self.metadata, excludedNames: nil)
                    return traitsView

            }
            return nil
        }
    }

    /// Defines the methods that are particular to this NFT contract collection
    ///
    pub resource interface CC0RouletteCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowCC0RouletteNFT(id: UInt64): &CC0Roulette.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow CC0Roulette reference: the ID of the returned reference is incorrect"
            }
        }
    }

    /// The resource that will be holding the NFTs inside any account.
    /// In order to be able to manage NFTs any account will need to create
    /// an empty collection first
    ///
    pub resource Collection: CC0RouletteCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with an `UInt64` ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        /// Removes an NFT from the collection and moves it to the caller
        ///
        /// @param withdrawID: The ID of the NFT that wants to be withdrawn
        /// @return The NFT resource that has been taken out of the collection
        ///
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        /// Adds an NFT to the collections dictionary and adds the ID to the id array
        ///
        /// @param token: The NFT resource to be included in the collection
        ///
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @CC0Roulette.NFT

            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token

            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        /// Helper method for getting the collection IDs
        ///
        /// @return An array containing the IDs of the NFTs in the collection
        ///
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        /// Gets a reference to an NFT in the collection so that
        /// the caller can read its metadata and call its methods
        ///
        /// @param id: The ID of the wanted NFT
        /// @return A reference to the wanted NFT resource
        ///
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        /// Gets a reference to an NFT in the collection so that
        /// the caller can read its metadata and call its methods
        ///
        /// @param id: The ID of the wanted NFT
        /// @return A reference to the wanted NFT resource
        ///
        pub fun borrowCC0RouletteNFT(id: UInt64): &CC0Roulette.NFT? {
            if self.ownedNFTs[id] != nil {
                // Create an authorized reference to allow downcasting
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &CC0Roulette.NFT
            }

            return nil
        }

        /// Gets a reference to the NFT only conforming to the `{MetadataViews.Resolver}`
        /// interface so that the caller can retrieve the views that the NFT
        /// is implementing and resolve them
        ///
        /// @param id: The ID of the wanted NFT
        /// @return The resource reference conforming to the Resolver interface
        ///
        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let cc0Roulette = nft as! &CC0Roulette.NFT
            return cc0Roulette as &AnyResource{MetadataViews.Resolver}
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    /// Allows anyone to create a new empty collection
    ///
    /// @return The new Collection resource
    ///
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    /// Resource that an admin or something similar would own to be
    /// able to mint new NFTs
    ///
    pub resource NFTMinter {

        // Prevent an already minted user from minting again
        access(all) let mintedUsers: {String: Bool}

        access(all) fun hasUserMinted(_ userID: String): Bool {
            return self.mintedUsers.containsKey(userID)
        }

        access(all) fun markUserMinted(_ userID: String) {
            self.mintedUsers[userID] = true
        }

        /// Mints a new NFT with a new ID and deposit it in the
        /// recipients collection using their collection reference
        ///
        /// @param recipient: A capability to the collection where the new NFT will be deposited
        /// @param name: The name for the NFT metadata
        /// @param description: The description for the NFT metadata
        /// @param thumbnail: The thumbnail for the NFT metadata
        ///
        pub fun mintNFT(
            recipient: &{NonFungibleToken.CollectionPublic},
            name: String,
            description: String,
            thumbnail: String,
            metadata: {String: AnyStruct},
        ) {
            assert(CC0Roulette.totalSupply <= 5000, message: "Max amount of NFTs allowed is 5,000")
            let currentBlock = getCurrentBlock()

            // create a new NFT
            var newNFT <- create NFT(
                id: CC0Roulette.totalSupply,
                name: name,
                description: description,
                thumbnail: thumbnail,
                metadata: metadata,
            )

            // deposit it in the recipient's account using their reference
            recipient.deposit(token: <-newNFT)

            CC0Roulette.totalSupply = CC0Roulette.totalSupply + UInt64(1)
        }

        init() {
            self.mintedUsers = {}
        }
    }

    /// Function that resolves a metadata view for this contract.
    ///
    /// @param view: The Type of the desired view.
    /// @return A structure representing the requested view.
    ///
    pub fun resolveView(_ view: Type): AnyStruct? {
        switch view {
            case Type<MetadataViews.NFTCollectionData>():
                return MetadataViews.NFTCollectionData(
                    storagePath: CC0Roulette.CollectionStoragePath,
                    publicPath: CC0Roulette.CollectionPublicPath,
                    providerPath: /private/CC0RouletteCollection,
                    publicCollection: Type<&CC0Roulette.Collection{CC0Roulette.CC0RouletteCollectionPublic}>(),
                    publicLinkedType: Type<&CC0Roulette.Collection{CC0Roulette.CC0RouletteCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(),
                    providerLinkedType: Type<&CC0Roulette.Collection{CC0Roulette.CC0RouletteCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(),
                    createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                        return <-CC0Roulette.createEmptyCollection()
                    })
                )
            case Type<MetadataViews.NFTCollectionDisplay>():
                let media = MetadataViews.Media(
                    file: MetadataViews.HTTPFile(
                        url: "https://assets.website-files.com/5f6294c0c7a8cdd643b1c820/5f6294c0c7a8cda55cb1c936_Flow_Wordmark.svg"
                    ),
                    mediaType: "image/svg+xml"
                )
                return MetadataViews.NFTCollectionDisplay(
                    name: "The Example Collection",
                    description: "This collection is used as an example to help you develop your next Flow NFT.",
                    externalURL: MetadataViews.ExternalURL("https://chat.openai.com/g/g-ldzjWGPdV-cc0-roulette"),
                    squareImage: media,
                    bannerImage: media,
                    socials: {
                        "twitter": MetadataViews.ExternalURL("https://twitter.com/flow_blockchain")
                    }
                )
        }
        return nil
    }

    /// Function that returns all the Metadata Views implemented by a Non Fungible Token
    ///
    /// @return An array of Types defining the implemented views. This value will be used by
    ///         developers to know which parameter to pass to the resolveView() method.
    ///
    pub fun getViews(): [Type] {
        return [
            Type<MetadataViews.NFTCollectionData>(),
            Type<MetadataViews.NFTCollectionDisplay>()
        ]
    }

    init() {
        // Initialize the total supply
        self.totalSupply = 0

        // Set the named paths
        self.CollectionStoragePath = /storage/CC0RouletteNFTCollection
        self.CollectionPublicPath = /public/CC0RouletteNFTCollection
        self.MinterStoragePath = /storage/CC0RouletteNFTMinter

        self.royaltyAccount = self.account.address

        // Create a Collection resource and save it to storage
        let collection <- create Collection()
        self.account.save(<-collection, to: self.CollectionStoragePath)

        // Create a Minter resource and save it to storage
        let minter <- create NFTMinter()
        self.account.save(<-minter, to: self.MinterStoragePath)

        emit ContractInitialized()
    }
}"
-------
"import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import FlowversePrimarySaleV2 from 0x9212a87501a8a6a2
import FindViews from 0x097bafa4e0b48eef

pub contract FlowverseShirt: NonFungibleToken {

    // Events
    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event EntityCreated(id: UInt64, metadata: {String:String})
    pub event EntityUpdated(id: UInt64, metadata: {String:String})
    pub event NFTMinted(nftID: UInt64, nftUUID: UInt64, entityID: UInt64, minterAddress: Address)
    pub event NFTDestroyed(nftID: UInt64)

    // Named Paths
    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let AdminStoragePath: StoragePath

    access(self) var entityDatas: {UInt64: Entity}
    access(self) var numMintedPerEntity: {UInt64: UInt64}

    // Total number of FlowverseShirt NFTs that have been minted
    // Incremented ID used to create nfts
    pub var totalSupply: UInt64

    // Incremented ID used to create entities
    pub var nextEntityID: UInt64

    // Entity is a blueprint that holds metadata associated with an NFT
    pub struct Entity {
        // Unique ID for the entity
        pub let entityID: UInt64

        // Stores all the metadata about the entity as a string mapping
        pub(set) var metadata: {String: String}

        init(metadata: {String: String}) {
            pre {
                metadata.length != 0: "New Entity metadata cannot be empty"
            }
            self.entityID = FlowverseShirt.nextEntityID
            self.metadata = metadata
        }

        access(contract) fun removeMetadata(key: String) {
            self.metadata.remove(key: key)
        }

        access(contract) fun setMetadata(key: String, value: String) {
            self.metadata[key] = value
        }
    }

    // NFT Resource that represents the Entity instances
    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {
        // Global unique NFT ID
        pub let id: UInt64

        // The ID of the Entity that the NFT references
        pub let entityID: UInt64

        // The minterAddress of the NFT
        pub let minterAddress: Address

        init(entityID: UInt64, minterAddress: Address) {
            self.id = FlowverseShirt.totalSupply
            self.entityID = entityID
            self.minterAddress = minterAddress

            emit NFTMinted(nftID: self.id, nftUUID: self.uuid, entityID: entityID, minterAddress: self.minterAddress)
        }

        // If the NFT is destroyed, emit an event to indicate
        // to outside observers that it has been destroyed
        destroy() {
            emit NFTDestroyed(nftID: self.id)
        }

        pub fun checkSoulbound(): Bool {
            return FlowverseShirt.getEntityMetaDataByField(entityID: self.entityID, field: "soulbound") == "true"
        }

        pub fun getViews(): [Type] {
            let supportedViews = [
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.Display>(),
                Type<MetadataViews.Royalties>(),
                Type<MetadataViews.Edition>(),
                Type<MetadataViews.Traits>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.Rarity>()
            ]
            if self.checkSoulbound() == true {
                supportedViews.append(Type<FindViews.SoulBound>())
            }
            return supportedViews
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: FlowverseShirt.CollectionStoragePath,
                        publicPath: FlowverseShirt.CollectionPublicPath,
                        providerPath: /private/FlowverseShirtCollection,
                        publicCollection: Type<&FlowverseShirt.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, FlowverseShirt.CollectionPublic, MetadataViews.ResolverCollection}>(),
                        publicLinkedType: Type<&FlowverseShirt.Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, FlowverseShirt.CollectionPublic, MetadataViews.ResolverCollection}>(),
                        providerLinkedType: Type<&FlowverseShirt.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, FlowverseShirt.CollectionPublic, NonFungibleToken.Receiver, MetadataViews.ResolverCollection}>(),
                        createEmptyCollection: (fun(): @NonFungibleToken.Collection {return <- FlowverseShirt.createEmptyCollection()})
                    )
                case Type<MetadataViews.NFTCollectionDisplay>():
                    return MetadataViews.NFTCollectionDisplay(
                        name: "Flowverse Shirt",
                        description: "Flowverse Shirt",
                        externalURL: MetadataViews.ExternalURL("https://twitter.com/flowverse_"),
                        squareImage: MetadataViews.Media(
                            file: MetadataViews.HTTPFile(
                                url: "https://pbs.twimg.com/profile_images/1480354080123867138/66piiWGx_400x400.jpg"
                            ),
                            mediaType: "image/jpg"
                        ),
                        bannerImage: MetadataViews.Media(
                            file: MetadataViews.HTTPFile(
                                url: "https://pbs.twimg.com/profile_banners/1409359424989196292/1694063128/1500x500"
                            ),
                            mediaType: "image/jpg"
                        ),
                        socials: {
                            "twitter": MetadataViews.ExternalURL("https://twitter.com/flowverse_")
                        }
                    )
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: FlowverseShirt.getEntityMetaDataByField(entityID: self.entityID, field: "name") ?? "",
                        description: FlowverseShirt.getEntityMetaDataByField(entityID: self.entityID, field: "description") ?? "",
                        thumbnail: MetadataViews.HTTPFile(
                          url: FlowverseShirt.getEntityMetaDataByField(entityID: self.entityID, field: "thumbnailURL") ?? ""
                        )
                    )
                case Type<MetadataViews.Royalties>():
                    let royalties : [MetadataViews.Royalty] = [
                        MetadataViews.Royalty(
                            receiver: getAccount(0x604b63bcbef5974f).getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)!,
                            cut: 0.05,
                            description: "Creator Royalty Fee")
                    ]
                    return MetadataViews.Royalties(cutInfos: royalties)
                case Type<MetadataViews.Traits>():
                    let traits: [MetadataViews.Trait] = []
                    if let rarity = FlowverseShirt.getEntityMetaDataByField(entityID: self.entityID, field: "rarity") {
                        traits.append(MetadataViews.Trait(
                            type: "Rarity",
                            value: rarity,
                            displayType: nil,
                            rarity: nil
                        ))
                    }
                    return MetadataViews.Traits(traits)
                case Type<MetadataViews.ExternalURL>():
                    let baseURL = "https://nft.flowverse.co/collections/FlowverseShirt/"
                    return MetadataViews.ExternalURL(baseURL.concat(self.owner!.address.toString()).concat("/".concat(self.id.toString())))
                case Type<FindViews.SoulBound>():
                    if self.checkSoulbound() == true {
                        return FindViews.SoulBound(
                            "This NFT cannot be transferred."
                        )
                    }
                    return nil
            }
            return nil
        }
    }

    access(self) fun mint(entityID: UInt64, minterAddress: Address): @NFT {
        pre {
            FlowverseShirt.entityDatas[entityID] != nil: "Cannot mint: the entity doesn't exist."
        }

        // Gets the number of NFTs that have been minted for this Entity
        let entityMintNumber = FlowverseShirt.numMintedPerEntity[entityID]!

        // Increment the global NFT ID
        FlowverseShirt.totalSupply = FlowverseShirt.totalSupply + UInt64(1)

        // Mint the new NFT
        let newNFT: @NFT <- create NFT(entityID: entityID, minterAddress: minterAddress)

        // Increment the number of copies minted for this NFT
        FlowverseShirt.numMintedPerEntity[entityID] = entityMintNumber + UInt64(1)
        return <-newNFT
    }

    pub resource NFTMinter: FlowversePrimarySaleV2.IMinter {
        init() {}
        pub fun mint(entityID: UInt64, minterAddress: Address): @NFT {
            return <-FlowverseShirt.mint(entityID: entityID, minterAddress: minterAddress)
        }
    }

    // Admin is a special authorization resource that
    // allows the owner to perform important functions to modify the
    // various aspects of the Entities, Sets, and NFTs
    //
    pub resource Admin {

        // createEntity creates a new Entity struct
        // and stores it in the Entities dictionary in the FlowverseShirt smart contract
        pub fun createEntity(metadata: {String: String}): UInt64 {
            // Create the new Entity
            var newEntity = Entity(metadata: metadata)
            let newID = newEntity.entityID

            // Increment the ID so that it isn't used again
            FlowverseShirt.nextEntityID = FlowverseShirt.nextEntityID + UInt64(1)

            // Store it in the contract storage
            FlowverseShirt.entityDatas[newID] = newEntity

            // Initialise numMintedPerEntity
            FlowverseShirt.numMintedPerEntity[newID] = UInt64(0)

            emit EntityCreated(id: newID, metadata: metadata)

            return newID
        }

        // updateEntity updates an existing Entity
        pub fun updateEntity(entityID: UInt64, metadata: {String: String}) {
            let updatedEntity = FlowverseShirt.entityDatas[entityID]!
            updatedEntity.metadata = metadata
            FlowverseShirt.entityDatas[entityID] = updatedEntity

            emit EntityUpdated(id: entityID, metadata: metadata)
        }

        pub fun setEntitySoulbound(entityID: UInt64, soulbound: Bool) {
            assert(FlowverseShirt.entityDatas[entityID] != nil, message: "Cannot set soulbound: the entity doesn't exist.")
            if soulbound {
                FlowverseShirt.entityDatas[entityID]!.setMetadata(key: "soulbound", value: "true")
            } else {
                FlowverseShirt.entityDatas[entityID]!.removeMetadata(key: "soulbound")
            }
        }

        pub fun mint(entityID: UInt64, minterAddress: Address): @NFT {
            return <-FlowverseShirt.mint(entityID: entityID, minterAddress: minterAddress)
        }

        // createNFTMinter creates a new NFTMinter resource
        pub fun createNFTMinter(): @NFTMinter {
            return <-create NFTMinter()
        }

        // createNewAdmin creates a new Admin resource
        pub fun createNewAdmin(): @Admin {
            return <-create Admin()
        }
    }

    // Public interface for the FlowverseShirt Collection that allows users access to certain functionalities
    pub resource interface CollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun batchDeposit(tokens: @NonFungibleToken.Collection)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowFlowverseShirtNFT(id: UInt64): &FlowverseShirt.NFT? {
            // If the result isn't nil, the id of the returned reference
            // should be the same as the argument to the function
            post {
                (result == nil) || (result?.id == id):
                    "Cannot borrow FlowverseShirt reference: The ID of the returned reference is incorrect"
            }
        }
        pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver}
    }

    // Collection of FlowverseShirt NFTs owned by an account
    pub resource Collection: CollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {
        // Dictionary of entity instances conforming tokens
        // NFT is a resource type with a UInt64 ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")
            let nft <- token as! @NFT

            // Check if the NFT is soulbound. Secondary marketplaces will use the
            // withdraw function, so if the NFT is soulbound, it will not be transferrable,
            // and hence cannot be sold.
            if nft.checkSoulbound() == true {
                panic("This NFT is not transferrable.")
            }

            emit Withdraw(id: withdrawID, from: self.owner?.address)
            return <- nft
        }

        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @FlowverseShirt.NFT
            let id: UInt64 = token.id
            let oldToken <- self.ownedNFTs[id] <- token
            emit Deposit(id: id, to: self.owner?.address)
            destroy oldToken
        }

        pub fun batchDeposit(tokens: @NonFungibleToken.Collection) {
            let keys = tokens.getIDs()
            for key in keys {
                self.deposit(token: <-tokens.withdraw(withdrawID: key))
            }
            destroy tokens
        }

        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowFlowverseShirtNFT(id: UInt64): &FlowverseShirt.NFT? {
            if self.ownedNFTs[id] != nil {
                let ref = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
                return ref as! &FlowverseShirt.NFT
            } else {
                return nil
            }
        }

        pub fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let nftRef = nft as! &FlowverseShirt.NFT
            return nftRef as &{MetadataViews.Resolver}
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    // -----------------------------------------------------------------------
    // FlowverseShirt contract-level function definitions
    // -----------------------------------------------------------------------

    // createEmptyCollection
    // public function that anyone can call to create a new empty collection
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create FlowverseShirt.Collection()
    }

    // getAllEntities returns all the entities available
    pub fun getAllEntities(): [FlowverseShirt.Entity] {
        return FlowverseShirt.entityDatas.values
    }

    // getEntity returns an entity by ID
    pub fun getEntity(entityID: UInt64): FlowverseShirt.Entity? {
        return self.entityDatas[entityID]
    }

    // getEntityMetaData returns all the metadata associated with a specific Entity
    pub fun getEntityMetaData(entityID: UInt64): {String: String}? {
        return self.entityDatas[entityID]?.metadata
    }

    pub fun getEntityMetaDataByField(entityID: UInt64, field: String): String? {
        if let entity = FlowverseShirt.entityDatas[entityID] {
            return entity.metadata[field]
        } else {
            return nil
        }
    }

    pub fun getNumMintedPerEntity(): {UInt64: UInt64} {
        return self.numMintedPerEntity
    }

    // -----------------------------------------------------------------------
    // FlowverseShirt initialization function
    // -----------------------------------------------------------------------
    //
    init() {
        self.CollectionStoragePath = /storage/FlowverseShirtCollection
        self.CollectionPublicPath = /public/FlowverseShirtCollection
        self.AdminStoragePath = /storage/FlowverseShirtAdmin

        // Initialize contract fields
        self.entityDatas = {}
        self.numMintedPerEntity = {}
        self.nextEntityID = 1
        self.totalSupply = 0

        // Put a new Collection in storage
        self.account.save<@Collection>(<- create Collection(), to: self.CollectionStoragePath)

        // Create a public capability for the Collection
        self.account.link<&Collection{NonFungibleToken.CollectionPublic, NonFungibleToken.Receiver, CollectionPublic, MetadataViews.ResolverCollection}>(self.CollectionPublicPath, target: self.CollectionStoragePath)

        // Put the Admin resource in storage
        self.account.save<@Admin>(<- create Admin(), to: self.AdminStoragePath)

        emit ContractInitialized()
    }
}
 "
-------
"/*
 * Copyright (c) 2021 24Karat. All rights reserved.
 *
 * SPDX-License-Identifier: MIT
 *
 * This file is part of Project: 24karat flow contract (https://github.com/24karat-io/flow-contract)
 *
 * This source code is licensed under the MIT License found in the
 * LICENSE file in the root directory of this source tree or at
 * https://opensource.org/licenses/MIT.
 */

import FungibleToken from 0xf233dcee88fe0abe

pub contract DWLC: FungibleToken {
    // TokensInitialized
    //
    // The event that is emitted when the contract is created
    pub event TokensInitialized(initialSupply: UFix64)

    // TokensWithdrawn
    //
    // The event that is emitted when tokens are withdrawn from a Vault
    pub event TokensWithdrawn(amount: UFix64, from: Address?)

    // TokensDeposited
    //
    // The event that is emitted when tokens are deposited to a Vault
    pub event TokensDeposited(amount: UFix64, to: Address?)

    // TokensMinted
    //
    // The event that is emitted when new tokens are minted
    pub event TokensMinted(amount: UFix64)

    // TokensBurned
    //
    // The event that is emitted when tokens are destroyed
    pub event TokensBurned(amount: UFix64)

    // MinterCreated
    //
    // The event that is emitted when a new minter resource is created
    pub event MinterCreated(allowedAmount: UFix64)

    // Named paths
    //
    pub let VaultStoragePath: StoragePath
    pub let ReceiverPublicPath: PublicPath
    pub let BalancePublicPath: PublicPath
    pub let AdminStoragePath: StoragePath

    // Total supply of token in existence
    pub var totalSupply: UFix64

    // Vault
    //
    // Each user stores an instance of only the Vault in their storage
    // The functions in the Vault and governed by the pre and post conditions
    // in FungibleToken when they are called.
    // The checks happen at runtime whenever a function is called.
    //
    // Resources can only be created in the context of the contract that they
    // are defined in, so there is no way for a malicious user to create Vaults
    // out of thin air. A special Minter resource needs to be defined to mint
    // new tokens.
    //
    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {

        // The total balance of this vault
        pub var balance: UFix64

        // initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        // withdraw
        //
        // Function that takes an amount as an argument
        // and withdraws that amount from the Vault.
        //
        // It creates a new temporary Vault that is used to hold
        // the money that is being transferred. It returns the newly
        // created Vault to the context that called so it can be deposited
        // elsewhere.
        //
        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)
            return <-create Vault(balance: amount)
        }

        // deposit
        //
        // Function that takes a Vault object as an argument and adds
        // its balance to the balance of the owners Vault.
        //
        // It is allowed to destroy the sent Vault because the Vault
        // was a temporary holder of the tokens. The Vault's balance has
        // been consumed and therefore can be destroyed.
        //
        pub fun deposit(from: @FungibleToken.Vault) {
            let vault <- from as! @DWLC.Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)
            vault.balance = 0.0
            destroy vault
        }

        destroy() {
            DWLC.totalSupply = DWLC.totalSupply - self.balance
            if(self.balance > 0.0) {
                emit TokensBurned(amount: self.balance)
            }
        }
    }

    // createEmptyVault
    //
    // Function that creates a new Vault with a balance of zero
    // and returns it to the calling context. A user must call this function
    // and store the returned Vault in their storage in order to allow their
    // account to be able to receive deposits of this token type.
    //
    pub fun createEmptyVault(): @Vault {
        return <-create Vault(balance: 0.0)
    }

    pub resource Administrator {

        // createNewMinter
        //
        // Function that creates and returns a new minter resource
        //
        pub fun createNewMinter(allowedAmount: UFix64): @Minter {
            emit MinterCreated(allowedAmount: allowedAmount)
            return <-create Minter(allowedAmount: allowedAmount)
        }
    }

    // Minter
    //
    // Resource object that token admin accounts can hold to mint new tokens.
    //
    pub resource Minter {

        // The amount of tokens that the minter is allowed to mint
        pub var allowedAmount: UFix64

        // mintTokens
        //
        // Function that mints new tokens, adds them to the total supply,
        // and returns them to the calling context.
        //
        pub fun mintTokens(amount: UFix64): @DWLC.Vault {
            pre {
                amount > 0.0: "Amount minted must be greater than zero"
                amount <= self.allowedAmount: "Amount minted must be less than the allowed amount"
            }
            DWLC.totalSupply = DWLC.totalSupply + amount
            self.allowedAmount = self.allowedAmount - amount
            emit TokensMinted(amount: amount)
            return <-create Vault(balance: amount)
        }

        init(allowedAmount: UFix64) {
            self.allowedAmount = allowedAmount
        }
    }

    init() {
        // Set our named paths.
        self.VaultStoragePath = /storage/DWLCVault
        self.ReceiverPublicPath = /public/DWLCReceiver
        self.BalancePublicPath = /public/DWLCBalance
        self.AdminStoragePath = /storage/DWLCAdmin

        // Initialize contract state.
        self.totalSupply = 0.0

        // Create the one true Admin object and deposit it into the conttract account.
        let admin <- create Administrator()
        self.account.save(<-admin, to: self.AdminStoragePath)

        // Emit an event that shows that the contract was initialized.
        emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
"
-------
"import Crypto

/// Defines a xorsift128+ pseudo random generator (PRG) struct used to generate random numbers given some
/// sourceOfRandomness and salt.
///
/// See FLIP 123 for more details: https://github.com/onflow/flips/blob/main/protocol/20230728-commit-reveal.md
/// And the onflow/random-coin-toss repo for implementation context: https://github.com/onflow/random-coin-toss
///
access(all) contract Xorshift128plus {

    /// While not limited to 128 bits of state, this PRG is largely informed by xorshift128+
    ///
    access(all) struct PRG {

        // The states below are of type Word64 (instead of UInt64) to prevent overflow/underflow as state evolves
        //
        access(all) var state0: Word64
        access(all) var state1: Word64

        /// Initializer for PRG struct
        ///
        /// @param sourceOfRandomness: The entropy bytes used to seed the PRG. It is recommended to use at least 16
        /// bytes of entropy.
        /// @param salt: The bytes used to salt the source of randomness
        ///
        init(sourceOfRandomness: [UInt8], salt: [UInt8]) {
            pre {
                sourceOfRandomness.length >= 16: "At least 16 bytes of entropy should be used"
            }

            let tmp: [UInt8] = sourceOfRandomness.concat(salt)
            // Hash is 32 bytes
            let hash: [UInt8] = Crypto.hash(tmp, algorithm: HashAlgorithm.SHA3_256)
            // Reduce the seed to 16 bytes
            let seed: [UInt8] = hash.slice(from: 0, upTo: 16)

            // Convert the seed bytes to two Word64 values for state initialization
            let segment0: Word64 = Xorshift128plus.bigEndianBytesToWord64(bytes: seed, start: 0)
            let segment1: Word64 = Xorshift128plus.bigEndianBytesToWord64(bytes: seed, start: 8)

            // Ensure the initial state is non-zero
            assert(segment0 != 0 || segment1 != 0, message: "PRG initial state must be initialized as non-zero")

            self.state0 = segment0
            self.state1 = segment1
        }

        /// Advances the PRG state and generates the next UInt64 value
        /// See https://arxiv.org/pdf/1404.0390.pdf for implementation details and reasoning for triplet selection.
        /// Note that state only advances when this function is called from a transaction. Calls from within a script
        /// will not advance state and will return the same value.
        ///
        /// @return The next UInt64 value
        ///
        access(all) fun nextUInt64(): UInt64 {
            var a: Word64 = self.state0
            let b: Word64 = self.state1

            self.state0 = b
            a = a ^ (a << 23) // a
            a = a ^ (a >> 17) // b
            a = a ^ b ^ (b >> 26) // c
            self.state1 = a

            let randUInt64: UInt64 = UInt64(Word64(a) + Word64(b))
            return randUInt64
        }
    }

    /// Helper function to convert an array of big endian bytes to Word64
    ///
    /// @param bytes: The bytes to convert
    /// @param start: The index of the first byte to convert
    ///
    /// @return The Word64 value
    ///
    access(contract) fun bigEndianBytesToWord64(bytes: [UInt8], start: Int): Word64 {
        pre {
            start + 8 <= bytes.length: "At least 8 bytes from the start are required for conversion"
        }
        var value: UInt64 = 0
        var i: Int = 0
        while i < 8 {
            value = value << 8 | UInt64(bytes[start + i])
            i = i + 1
        }
        return Word64(value)
    }
}
"
-------
"import FungibleToken from 0xf233dcee88fe0abe
import NonFungibleToken from 0x1d7e57aa55817448
import TopShot from 0x0b2a3299cc857e29

pub contract TopShotEscrow {

    // -----------------------------------------------------------------------
    // TopShotEscrow contract Events
    // -----------------------------------------------------------------------

    pub event ContractInitialized()
    pub event Escrowed(id: UInt64, owner: Address, NFTIds: [UInt64], duration: UFix64, startTime: UFix64)
    pub event Redeemed(id: UInt64, owner: Address, NFTIds: [UInt64], partial: Bool, time: UFix64)
    pub event EscrowCancelled(id: UInt64, owner: Address, NFTIds: [UInt64], partial: Bool, time: UFix64)
    pub event EscrowWithdraw(id: UInt64, from: Address?)
    pub event EscrowUpdated(id: UInt64, owner: Address, NFTIds: [UInt64])

    // -----------------------------------------------------------------------
    // TopShotEscrow contract-level fields.
    // These contain actual values that are stored in the smart contract.
    // -----------------------------------------------------------------------

    // The total amount of EscrowItems that have been created
    pub var totalEscrows: UInt64

    // Escrow Storage Path
    pub let escrowStoragePath: StoragePath

    /// Escrow Public Path
    pub let escrowPublicPath: PublicPath

    // -----------------------------------------------------------------------
    // TopShotEscrow contract-level Composite Type definitions
    // -----------------------------------------------------------------------
    // These are just *definitions* for Types that this contract
    // and other accounts can use. These definitions do not contain
    // actual stored values, but an instance (or object) of one of these Types
    // can be created by this contract that contains stored values.
    // -----------------------------------------------------------------------

    // This struct contains the status of the escrow
    // and is exposed so websites can use escrow information
    pub struct EscrowDetails {
        pub let owner: Address
        pub let escrowID: UInt64
        pub let NFTIds: [UInt64]?
        pub let starTime: UFix64
        pub let duration : UFix64
        pub let isRedeemable : Bool

        init(_owner: Address,
            _escrowID: UInt64,
            _NFTIds: [UInt64]?,
            _startTime: UFix64,
            _duration: UFix64,
            _isRedeemable: Bool
        ) {
            self.owner = _owner
            self.escrowID = _escrowID
            self.NFTIds = _NFTIds
            self.starTime = _startTime
            self.duration = _duration
            self.isRedeemable = _isRedeemable
        }
    }

    // An interface that exposes public fields and functions
    // of the EscrowItem resource
    pub resource interface EscrowItemPublic {
        pub let escrowID: UInt64
        pub var redeemed: Bool
        pub fun hasBeenRedeemed(): Bool
        pub fun isRedeemable(): Bool
        pub fun getEscrowDetails(): EscrowDetails
        pub fun redeem(NFTIds: [UInt64])
        pub fun addNFTs(NFTCollection: @TopShot.Collection)
    }

    // EscrowItem contains a NFT Collection (single or several NFTs) for a single escrow
    // Fields and functions are defined as private by default
    // to access escrow details, one can call getEscrowDetails()
    pub resource EscrowItem: EscrowItemPublic {

        // The id of this individual escrow
        pub let escrowID: UInt64
        access(self) var NFTCollection: [UInt64]?
        pub let startTime:  UFix64
        access(self) var duration: UFix64
        pub var redeemed: Bool
        access(self) let receiverCap : Capability<&{NonFungibleToken.Receiver}>

        init(
            _NFTCollection: @TopShot.Collection,
            _duration: UFix64,
            _receiverCap : Capability<&{NonFungibleToken.Receiver}>
        ) {
            TopShotEscrow.totalEscrows = TopShotEscrow.totalEscrows + 1
            self.escrowID =  TopShotEscrow.totalEscrows
            self.NFTCollection = _NFTCollection.getIDs()
            assert(self.NFTCollection != nil, message: "NFT Collection is empty")
            self.startTime = getCurrentBlock().timestamp
            self.duration = _duration
            assert(_receiverCap.borrow() != nil, message: "Cannot borrow receiver")
            self.receiverCap = _receiverCap
            self.redeemed = false

            let adminTopShotReceiverRef = TopShotEscrow.account.getCapability(/public/MomentCollection).borrow<&{NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, TopShot.MomentCollectionPublic}>()
            ?? panic("Cannot borrow collection")

            for tokenId in self.NFTCollection! {
                    let token <- _NFTCollection.withdraw(withdrawID: tokenId)
                    adminTopShotReceiverRef.deposit(token: <-token)
            }

            assert(_NFTCollection.getIDs().length == 0, message: "can't destroy resources")
            destroy _NFTCollection
        }

        pub fun isRedeemable(): Bool {
            return getCurrentBlock().timestamp > self.startTime + self.duration
        }

        pub fun hasBeenRedeemed(): Bool {
            return self.redeemed
        }


        pub fun redeem(NFTIds: [UInt64]) {

            pre {
                self.isRedeemable() : "Not redeemable yet"
                !self.hasBeenRedeemed() : "Has already been redeemed"
            }

            let collectionRef = self.receiverCap.borrow()
                                ?? panic("Cannot borrow receiver")

            let providerTopShotProviderRef: &TopShot.Collection? = TopShotEscrow.account.borrow<&TopShot.Collection>(from: /storage/MomentCollection)
                    ?? panic("Cannot borrow collection")

            if (NFTIds.length == 0 || NFTIds.length == self.NFTCollection?.length){
                // Iterate through the keys in the collection and deposit each one
                for tokenId in self.NFTCollection! {
                    let token <- providerTopShotProviderRef?.withdraw(withdrawID: tokenId)!
                    collectionRef.deposit(token: <-token)
                }

                self.redeemed = true;

                emit Redeemed(id: self.escrowID, owner: self.receiverCap.address, NFTIds: self.NFTCollection!, partial: false, time: getCurrentBlock().timestamp)
            } else {
                for NFTId in NFTIds {
                    let token <- providerTopShotProviderRef?.withdraw(withdrawID: NFTId)!
                    collectionRef.deposit(token: <-token)
                    let index = self.NFTCollection?.firstIndex(of: NFTId) ?? panic("NFT ID not found")
                    let removedId = self.NFTCollection?.remove(at: index !) ?? panic("NFT ID not found")
                    assert(removedId == NFTId, message: "NFT ID mismatch")
                }

                if (self.NFTCollection?.length == 0){
                    self.redeemed = true;
                }

                emit Redeemed(id: self.escrowID, owner: self.receiverCap.address, NFTIds: NFTIds, partial: !self.redeemed, time: getCurrentBlock().timestamp)
            }
        }

        pub fun getEscrowDetails(): EscrowDetails{
            return EscrowDetails(
                    _owner: self.receiverCap.address,
                    _escrowID: self.escrowID,
                    _NFTIds: self.NFTCollection,
                    _startTime: self.startTime,
                    _duration: self.duration,
                    _isRedeemable: self.isRedeemable()
                    )
        }

        pub fun setEscrowDuration(_ newDuration: UFix64) {
            post {
                newDuration < self.duration : "Can only decrease duration"
            }
            self.duration = newDuration
        }

        pub fun cancelEscrow(NFTIds: [UInt64]) {
            pre {
                !self.hasBeenRedeemed() : "Has already been redeemed"
            }
            let collectionRef = self.receiverCap.borrow()
                                ?? panic("Cannot borrow receiver")

            let providerTopShotProviderRef: &TopShot.Collection? = TopShotEscrow.account.borrow<&TopShot.Collection>(from: /storage/MomentCollection)
                    ?? panic("Cannot borrow collection")

            if (NFTIds.length == 0 || NFTIds.length == self.NFTCollection?.length){
                // Iterate through the keys in the collection and deposit each one
                for tokenId in self.NFTCollection! {
                    let token <- providerTopShotProviderRef?.withdraw(withdrawID: tokenId)!
                    collectionRef.deposit(token: <-token)
                }

                self.redeemed = true;

                emit EscrowCancelled(id: self.escrowID, owner: self.receiverCap.address, NFTIds: self.NFTCollection!, partial: false, time: getCurrentBlock().timestamp)
            } else {
                for NFTId in NFTIds {
                    let token <- providerTopShotProviderRef?.withdraw(withdrawID: NFTId)!
                    collectionRef.deposit(token: <-token)
                    let index = self.NFTCollection?.firstIndex(of: NFTId) ?? panic("NFT ID not found")
                    let removedId = self.NFTCollection?.remove(at: index !) ?? panic("NFT ID not found")
                    assert(removedId == NFTId, message: "NFT ID mismatch")
                }

                if (self.NFTCollection?.length == 0){
                    self.redeemed = true;
                }

                emit EscrowCancelled(id: self.escrowID, owner: self.receiverCap.address, NFTIds: NFTIds, partial: !self.redeemed, time: getCurrentBlock().timestamp)
            }
        }

        pub fun addNFTs(NFTCollection: @TopShot.Collection) {
            pre {
                !self.hasBeenRedeemed() : "Has already been redeemed"
            }
            let NFTIds = NFTCollection.getIDs()
            let adminTopShotReceiverRef = TopShotEscrow.account.getCapability(/public/MomentCollection).borrow<&{NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, TopShot.MomentCollectionPublic}>()
            ?? panic("Cannot borrow collection")

            for NFTId in NFTIds {
                    let token <- NFTCollection.withdraw(withdrawID: NFTId)
                    adminTopShotReceiverRef.deposit(token: <-token)
            }

            assert(NFTCollection.getIDs().length == 0, message: "can't destroy resources")
            destroy NFTCollection

            self.NFTCollection!.appendAll(NFTIds)
            emit EscrowUpdated(id: self.escrowID, owner: self.receiverCap.address, NFTIds: self.NFTCollection!)
        }

        destroy() {
            assert(self.redeemed, message: "Escrow not redeemed")
        }
    }

    // An interface to interact publicly with the Escrow Collection
    pub resource interface EscrowCollectionPublic {
        pub fun createEscrow(
                NFTCollection: @TopShot.Collection,
                duration: UFix64,
                receiverCap : Capability<&{NonFungibleToken.Receiver}>)

        pub fun borrowEscrow(escrowID: UInt64): &EscrowItem{EscrowItemPublic}?
        pub fun getEscrowIDs() : [UInt64]
    }

    // EscrowCollection contains a dictionary of EscrowItems
    // and provides methods for manipulating the EscrowItems
    pub resource EscrowCollection: EscrowCollectionPublic {

        // Escrow Items
        access(self) var escrowItems: @{UInt64: EscrowItem}

        // withdraw
        // Removes an escrow from the collection and moves it to the caller
        pub fun withdraw(escrowID: UInt64): @TopShotEscrow.EscrowItem {
            let escrow <- self.escrowItems.remove(key: escrowID) ?? panic("missing NFT")

            emit EscrowWithdraw(id: escrow.escrowID, from: self.owner?.address)

            return <-escrow
        }


        init() {
            self.escrowItems <- {}
        }

        pub fun getEscrowIDs() : [UInt64] {
            return self.escrowItems.keys
        }

        pub fun createEscrow(
                NFTCollection: @TopShot.Collection,
                duration: UFix64,
                receiverCap : Capability<&{NonFungibleToken.Receiver}>) {

            let TopShotIds = NFTCollection.getIDs()

            assert(receiverCap.check(), message : "Non Valid Receiver Capability")

            // create a new escrow item resource container
            let item <- create EscrowItem(
                _NFTCollection: <- NFTCollection,
                _duration: duration,
                _receiverCap: receiverCap)

            let escrowID = item.escrowID
            let startTime = item.startTime
            // update the escrow items dictionary with the new resources
            let oldItem <- self.escrowItems[escrowID] <- item
            destroy oldItem

            let owner = receiverCap.address

            emit Escrowed(id: escrowID, owner: owner, NFTIds: TopShotIds, duration: duration, startTime: startTime)
        }

        pub fun borrowEscrow(escrowID: UInt64): &EscrowItem{EscrowItemPublic}? {
            // Get the escrow item resources
            if let escrowRef = (&self.escrowItems[escrowID] as &EscrowItem{EscrowItemPublic}?) {
                return escrowRef
            }
            return nil
        }

        pub fun createEscrowRef(escrowID: UInt64): &EscrowItem {
            // Get the escrow item resources
            let escrowRef = (&self.escrowItems[escrowID] as &EscrowItem?)!
            return escrowRef
        }

        destroy() {
            assert(self.escrowItems.length == 0, message: "Escrow items still exist")
            destroy self.escrowItems
        }
    }

    // -----------------------------------------------------------------------
    // TopShotEscrow contract-level function definitions
    // -----------------------------------------------------------------------

    // createEscrowCollection returns a new EscrowCollection resource to the caller
    pub fun createEscrowCollection(): @EscrowCollection {
        let escrowCollection <- create EscrowCollection()

        return <- escrowCollection
    }

    // createEscrow
    pub fun createEscrow(
                _ NFTCollection: @TopShot.Collection,
                _ duration: UFix64,
                _ receiverCap : Capability<&{NonFungibleToken.Receiver}>) {
        let escrowCollectionRef = self.account.borrow<&TopShotEscrow.EscrowCollection>(from: self.escrowStoragePath) ??
                                                                    panic("Couldn't borrow escrow collection")
        escrowCollectionRef.createEscrow(NFTCollection: <- NFTCollection, duration: duration, receiverCap: receiverCap)
    }

    // redeem tokens
    pub fun redeem(_ escrowID: UInt64, _ NFTIds: [UInt64]) {
        let escrowCollectionRef = self.account.borrow<&TopShotEscrow.EscrowCollection>(from: self.escrowStoragePath) ??
                                                                    panic("Couldn't borrow escrow collection")
        let escrowRef = escrowCollectionRef.borrowEscrow(escrowID: escrowID)!
        escrowRef.redeem(NFTIds: NFTIds)
        if (escrowRef.redeemed){
            destroy <- escrowCollectionRef.withdraw(escrowID: escrowID)
        }
    }

    // batch redeem tokens
    pub fun batchRedeem(_ escrowIDs: [UInt64]) {

        for escrowID in escrowIDs {
            let escrowCollectionRef = self.account.borrow<&TopShotEscrow.EscrowCollection>(from: self.escrowStoragePath) ??
                                                                        panic("Couldn't borrow escrow collection")
            let escrowRef = escrowCollectionRef.borrowEscrow(escrowID: escrowID)!
            escrowRef.redeem(NFTIds: [])
            if (escrowRef.redeemed){
            destroy <- escrowCollectionRef.withdraw(escrowID: escrowID)
            }
        }
    }

    // -----------------------------------------------------------------------
    // TopShotEscrow initialization function
    // -----------------------------------------------------------------------
    //

    init() {
        self.totalEscrows = 0
        self.escrowStoragePath= /storage/TopShotEscrow
        self.escrowPublicPath= /public/TopShotEscrow

        // Setup collection onto Deployer's account
        let escrowCollection <- self.createEscrowCollection()
        self.account.save(<- escrowCollection, to: self.escrowStoragePath)
        self.account.link<&TopShotEscrow.EscrowCollection{TopShotEscrow.EscrowCollectionPublic}>(self.escrowPublicPath, target: self.escrowStoragePath)
    }
}
 "
-------
"import FungibleToken from 0xf233dcee88fe0abe
import Toucans from 0x577a3c409c5dcb5e
import ToucansTokens from 0x577a3c409c5dcb5e

pub contract FlovatarConfrariaToken: FungibleToken {
    pub var totalSupply: UFix64

    pub let VaultReceiverPath: PublicPath
    pub let VaultBalancePath: PublicPath
    pub let VaultStoragePath: StoragePath
    pub let AdminStoragePath: StoragePath

    pub event TokensInitialized(initialSupply: UFix64)
    pub event TokensWithdrawn(amount: UFix64, from: Address?)
    pub event TokensDeposited(amount: UFix64, to: Address?)
    pub event TokensMinted(amount: UFix64)
    pub event TokensBurned(amount: UFix64)
    pub event MinterCreated(allowedAmount: UFix64)
    pub event BurnerCreated()

    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {
        pub var balance: UFix64

        init(balance: UFix64) {
            self.balance = balance
        }

        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)
            return <-create Vault(balance: amount)
        }

        pub fun deposit(from: @FungibleToken.Vault) {
            let vault <- from as! @FlovatarConfrariaToken.Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)
            vault.balance = 0.0
            destroy vault
        }

        destroy() {
            if self.balance > 0.0 {
                emit TokensBurned(amount: self.balance)
            }
            FlovatarConfrariaToken.totalSupply = FlovatarConfrariaToken.totalSupply - self.balance
        }
    }

    pub fun createEmptyVault(): @Vault {
        return <-create Vault(balance: 0.0)
    }

    pub resource Administrator {
        pub fun createNewMinter(allowedAmount: UFix64): @Minter {
            emit MinterCreated(allowedAmount: allowedAmount)
            return <-create Minter(allowedAmount: allowedAmount)
        }

        pub fun createNewBurner(): @Burner {
            emit BurnerCreated()
            return <-create Burner()
        }
    }

    pub resource Minter {
        pub var allowedAmount: UFix64

        pub fun mintTokens(amount: UFix64): @FlovatarConfrariaToken.Vault {
            pre {
                amount > 0.0: "Amount minted must be greater than zero"
                amount <= self.allowedAmount: "Amount minted must be less than the allowed amount"
            }
            FlovatarConfrariaToken.totalSupply = FlovatarConfrariaToken.totalSupply + amount
            self.allowedAmount = self.allowedAmount - amount
            emit TokensMinted(amount: amount)
            return <-create Vault(balance: amount)
        }

        init(allowedAmount: UFix64) {
            self.allowedAmount = allowedAmount
        }
    }

    pub resource Burner {
        pub fun burnTokens(from: @FungibleToken.Vault) {
            let vault <- from as! @FlovatarConfrariaToken.Vault
            let amount = vault.balance
            destroy vault
            emit TokensBurned(amount: amount)
        }
    }

    init() {
        self.totalSupply = 100000.0

        self.VaultReceiverPath = /public/FlovatarConfrariaTokenReceiver
        self.VaultBalancePath = /public/FlovatarConfrariaTokenBalance
        self.VaultStoragePath = /storage/FlovatarConfrariaTokenVault
        self.AdminStoragePath = /storage/FlovatarConfrariaTokenAdmin

        let vault <- create Vault(balance: self.totalSupply)
        self.account.save(<-vault, to: self.VaultStoragePath)

        self.account.link<&{FungibleToken.Receiver, FungibleToken.Balance}>(
            self.VaultReceiverPath,
            target: self.VaultStoragePath
        )

        self.account.link<&FlovatarConfrariaToken.Vault{FungibleToken.Balance}>(
            self.VaultBalancePath,
            target: self.VaultStoragePath
        )

        let admin <- create Administrator()
        self.account.save(<-admin, to: self.AdminStoragePath)

        emit TokensInitialized(initialSupply: self.totalSupply)
    }
}
"
-------
"import NonFungibleToken from 0x1d7e57aa55817448


/// A contract to lock NFT for a given duration
/// Locked NFT are stored in a user owned collection
/// The collection owner can unlock the NFT after duration has been exceeded
///
pub contract NFTLocker {

    /// Contract events
    ///
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event NFTLocked(
        id: UInt64,
        to: Address?,
        lockedAt: UInt64,
        lockedUntil: UInt64,
        duration: UInt64,
        nftType: Type
    )
    pub event NFTUnlocked(
        id: UInt64,
        from: Address?,
        nftType: Type
    )

    /// Named Paths
    ///
    pub let CollectionStoragePath:  StoragePath
    pub let CollectionPublicPath:   PublicPath

    /// Contract variables
    ///
    pub var totalLockedTokens:      UInt64

    /// Metadata Dictionaries
    ///
    access(self) let lockedTokens:  {Type: {UInt64: LockedData}}

    /// Data describing characteristics of the locked NFT
    ///
    pub struct LockedData {
        pub let id: UInt64
        pub let owner: Address
        pub let lockedAt: UInt64
        pub let lockedUntil: UInt64
        pub let duration: UInt64
        pub let nftType: Type
        pub let extension: {String: AnyStruct}

        init (id: UInt64, owner: Address, duration: UInt64, nftType: Type) {
            if let lockedToken = (NFTLocker.lockedTokens[nftType]!)[id] {
                self.id = id
                self.owner = lockedToken.owner
                self.lockedAt = lockedToken.lockedAt
                self.lockedUntil = lockedToken.lockedUntil
                self.duration = lockedToken.duration
                self.nftType = lockedToken.nftType
                self.extension = lockedToken.extension
            } else {
                self.id = id
                self.owner = owner
                self.lockedAt = UInt64(getCurrentBlock().timestamp)
                self.lockedUntil = self.lockedAt + duration
                self.duration = duration
                self.nftType = nftType
                self.extension = {}
            }
        }
    }

    pub fun getNFTLockerDetails(id: UInt64, nftType: Type): NFTLocker.LockedData? {
        return (NFTLocker.lockedTokens[nftType]!)[id]
    }

    /// Determine if NFT can be unlocked
    ///
    pub fun canUnlockToken(id: UInt64, nftType: Type): Bool {
        if let lockedToken = (NFTLocker.lockedTokens[nftType]!)[id] {
            if lockedToken.lockedUntil < UInt64(getCurrentBlock().timestamp) {
                return true
            }
        }

        return false
    }

    /// A public collection interface that returns the ids
    /// of nft locked for a given type
    ///
    pub resource interface LockedCollection {
        pub fun getIDs(nftType: Type): [UInt64]?
    }

    /// A public collection interface allowing locking and unlocking of NFT
    ///
    pub resource interface LockProvider {
        pub fun lock(token: @NonFungibleToken.NFT, duration: UInt64)
        pub fun unlock(id: UInt64, nftType: Type): @NonFungibleToken.NFT
    }

    /// An NFT Collection
    ///
    pub resource Collection: LockedCollection, LockProvider {
        pub var lockedNFTs: @{Type: {UInt64: NonFungibleToken.NFT}}

        /// Unlock an NFT of a given type
        ///
        pub fun unlock(id: UInt64, nftType: Type): @NonFungibleToken.NFT {
            pre {
                NFTLocker.canUnlockToken(
                    id: id,
                    nftType: nftType
                ) == true : "locked duration has not been met"
            }

            let token <- self.lockedNFTs[nftType]?.remove(key: id)!!

            if let lockedToken = NFTLocker.lockedTokens[nftType] {
                lockedToken.remove(key: id)
            }
            NFTLocker.totalLockedTokens = NFTLocker.totalLockedTokens - 1

            emit NFTUnlocked(
                id: token.id,
                from: self.owner?.address,
                nftType: nftType
            )

            emit Withdraw(id: token.id, from: self.owner?.address)

            return <-token
        }

        /// Lock an NFT of a given type
        ///
        pub fun lock(token: @NonFungibleToken.NFT, duration: UInt64) {
            let id: UInt64 = token.id
            let nftType: Type = token.getType()

            if NFTLocker.lockedTokens[nftType] == nil {
                NFTLocker.lockedTokens[nftType] = {}
            }

            if self.lockedNFTs[nftType] == nil {
                self.lockedNFTs[nftType] <-! {}
            }
            let ref = &self.lockedNFTs[nftType] as &{UInt64: NonFungibleToken.NFT}?

            let oldToken <- ref!.insert(key: id, <- token)

            let nestedLock = NFTLocker.lockedTokens[nftType]!
            let lockedData = NFTLocker.LockedData(
                id: id,
                owner: self.owner!.address,
                duration: duration,
                nftType: nftType
            )
            nestedLock[id] = lockedData
            NFTLocker.lockedTokens[nftType] = nestedLock

            NFTLocker.totalLockedTokens = NFTLocker.totalLockedTokens + 1

            emit NFTLocked(
                id: id,
                to: self.owner?.address,
                lockedAt: lockedData.lockedAt,
                lockedUntil: lockedData.lockedUntil,
                duration: lockedData.duration,
                nftType: nftType
            )

            emit Deposit(id: id, to: self.owner?.address)
            destroy oldToken
        }

        pub fun getIDs(nftType: Type): [UInt64]? {
            return self.lockedNFTs[nftType]?.keys
        }

        destroy() {
            destroy self.lockedNFTs
        }

        init() {
            self.lockedNFTs <- {}
        }
    }

    pub fun createEmptyCollection(): @Collection {
        return <- create Collection()
    }

    init() {
        self.CollectionStoragePath = /storage/NFTLockerCollection
        self.CollectionPublicPath = /public/NFTLockerCollection

        self.totalLockedTokens = 0
        self.lockedTokens = {}
    }
}"
-------
"// MAINNET

/*
    FlowversePrimarySaleV2.cdc

    The contract handles the primary sale of NFTs, enabling purchasing and minting NFTs on-the-fly.

    Author: Brian Min brian@flowverse.co
*/

import NonFungibleToken from 0x1d7e57aa55817448
import FungibleToken from 0xf233dcee88fe0abe
import Crypto

pub contract FlowversePrimarySaleV2 {
    pub let AdminStoragePath: StoragePath

    // Incremented ID used to create entities
    pub var nextPrimarySaleID: UInt64

    access(contract) var primarySales: @{UInt64: PrimarySale}
    access(contract) var primarySaleIDs: {String: UInt64}

    pub event PurchaseComplete(primarySaleID: UInt64, orders: [Order], nftIDs: [UInt64], purchaserAddress: Address, pool: String, price: UFix64, salePaymentVaultType: String)
    pub event ContractInitialized()

    pub resource interface IMinter {
        pub fun mint(entityID: UInt64, minterAddress: Address): @NonFungibleToken.NFT
    }

    // Data struct signed by admin account - allows accounts to purchase from a primary sale for a period of time.
    pub struct AdminSignedPayload {
        pub let primarySaleID: UInt64
        pub let purchaserAddress: Address
        pub let expiration: UInt64 // unix timestamp

        init(primarySaleID: UInt64, purchaserAddress: Address, expiration: UInt64){
            self.primarySaleID = primarySaleID
            self.purchaserAddress = purchaserAddress
            self.expiration = expiration
        }

        pub fun toString(): String {
            return self.primarySaleID.toString().concat("-")
                .concat(self.purchaserAddress.toString()).concat("-")
                .concat(self.expiration.toString())
        }
    }

    pub struct PriceData {
        pub let price: {String: UFix64}
        pub let pool: String
        pub(set) var eligibleAddresses: [Address]?
        pub var maxMintsPerUser: UInt64?

        init(price: {String: UFix64}, pool: String, eligibleAddresses: [Address]?, maxMintsPerUser: UInt64?){
            self.price = price
            self.pool = pool
            self.eligibleAddresses = eligibleAddresses
            self.maxMintsPerUser = maxMintsPerUser
        }
    }

    pub struct PurchaseData {
        pub let primarySaleID: UInt64
        pub let purchaserAddress: Address
        pub let purchaserCollectionRef: &{NonFungibleToken.Receiver}
        pub let orders: [Order]
        pub let pool: String

        init(primarySaleID: UInt64, purchaserAddress: Address, purchaserCollectionRef: &{NonFungibleToken.Receiver}, orders: [Order], pool: String){
            self.primarySaleID = primarySaleID
            self.purchaserAddress = purchaserAddress
            self.purchaserCollectionRef = purchaserCollectionRef
            self.orders = orders
            self.pool = pool
        }
    }

    pub struct PurchaseDataSequential {
        pub let primarySaleID: UInt64
        pub let purchaserAddress: Address
        pub let purchaserCollectionRef: &{NonFungibleToken.Receiver}
        pub let quantity: UInt64
        pub let pool: String

        init(primarySaleID: UInt64, purchaserAddress: Address, purchaserCollectionRef: &{NonFungibleToken.Receiver}, quantity: UInt64, pool: String){
            self.primarySaleID = primarySaleID
            self.purchaserAddress = purchaserAddress
            self.purchaserCollectionRef = purchaserCollectionRef
            self.quantity = quantity
            self.pool = pool
        }
    }

    pub struct Order {
        pub let entityID: UInt64
        pub let quantity: UInt64

        init(entityID: UInt64, quantity: UInt64){
            self.entityID = entityID
            self.quantity = quantity
        }
    }

    pub enum PrimarySaleStatus: UInt8 {
        pub case PAUSED
        pub case OPEN
        pub case CLOSED
    }

    pub resource interface PrimarySalePublic {
        pub fun getSupply(pool: String?): UInt64
        pub fun getPrices(): {String: PriceData}
        pub fun getStatus(): String
        pub fun purchaseHeroesBox(
            payment: @FungibleToken.Vault,
            data: PurchaseDataSequential,
            adminSignedPayload: AdminSignedPayload,
            signature: String
        )
        pub fun purchaseSequentialNFTs(
            payment: @FungibleToken.Vault,
            data: PurchaseDataSequential,
            adminSignedPayload: AdminSignedPayload,
            signature: String
        )
        pub fun getNumMintedByUser(userAddress: Address, pool: String): UInt64
        pub fun getNumMintedPerUser(): {String: {Address: UInt64}}
        pub fun getAllAvailableEntities(pool: String): {UInt64: UInt64}
        pub fun getLaunchDate(): String
        pub fun getEndDate(): String
        pub fun getPaymentReceivers(): {String: Address}
        pub fun getContractName(): String
        pub fun getContractAddress(): Address
        pub fun getID(): UInt64
    }

    pub resource PrimarySale: PrimarySalePublic {
        access(self) var primarySaleID: UInt64
        access(self) var contractName: String
        access(self) var contractAddress: Address
        access(self) var status: PrimarySaleStatus
        access(self) var prices: {String: PriceData}
        access(self) var pooledEntities: {String: {UInt64: UInt64}}
        access(self) var numMintedPerUser: {String: {Address: UInt64}}
        access(self) var launchDate: String
        access(self) var endDate: String

        access(self) let minterCap: Capability<&{IMinter}>
        access(self) var paymentReceiverCaps: {String: Capability<&{FungibleToken.Receiver}>}

        init(
            contractName: String,
            contractAddress: Address,
            prices: {String: PriceData},
            minterCap: Capability<&{IMinter}>,
            paymentReceiverCaps: {String: Capability<&AnyResource{FungibleToken.Receiver}>},
            launchDate: String,
            endDate: String
        ) {
            self.contractName = contractName
            self.contractAddress = contractAddress
            self.status = PrimarySaleStatus.PAUSED // primary sale is paused initially
            self.pooledEntities = {}
            self.prices = prices

            self.minterCap = minterCap
            self.paymentReceiverCaps = paymentReceiverCaps

            self.launchDate = launchDate
            self.endDate = endDate

            self.primarySaleID = FlowversePrimarySaleV2.nextPrimarySaleID
            let key = contractName.concat(contractAddress.toString())
            FlowversePrimarySaleV2.primarySaleIDs[key] = self.primarySaleID

            self.numMintedPerUser = {}
            for pool in prices.keys {
                self.numMintedPerUser.insert(key: pool, {})
            }
        }

        pub fun getStatus(): String {
            if (self.status == PrimarySaleStatus.PAUSED) {
                return "PAUSED"
            } else if (self.status == PrimarySaleStatus.OPEN) {
                return "OPEN"
            } else if (self.status == PrimarySaleStatus.CLOSED) {
                return "CLOSED"
            } else {
                return ""
            }
        }

        pub fun setPrice(priceData: PriceData) {
            self.prices[priceData.pool] = priceData
            if !self.numMintedPerUser.containsKey(priceData.pool) {
                self.numMintedPerUser.insert(key: priceData.pool, {})
            }
        }

        pub fun removePrice(pool: String) {
            self.prices.remove(key: pool)
        }

        pub fun getPrices(): {String: PriceData} {
            return self.prices
        }

        pub fun addEligibleAddressesToPool(pool: String, eligibleAddresses: [Address]) {
            assert(self.prices.containsKey(pool), message: "Pool does not exist")
            let price = self.prices[pool]!
            if price.eligibleAddresses == nil {
                price.eligibleAddresses = eligibleAddresses
            } else {
                let updatedEligibleAddresses = price.eligibleAddresses!
                updatedEligibleAddresses.appendAll(eligibleAddresses)
                price.eligibleAddresses = updatedEligibleAddresses
            }
            self.prices[pool] = price
        }

        pub fun clearEligibleAddressesForPool(pool: String) {
            assert(self.prices.containsKey(pool), message: "Pool does not exist")
            let price = self.prices[pool]!
            price.eligibleAddresses = nil
            self.prices[pool] = price
        }

        pub fun getSupply(pool: String?): UInt64 {
            var supply = UInt64(0)
            for poolKey in self.pooledEntities.keys {
                if pool == nil || pool == poolKey {
                    let pooledDict = self.pooledEntities[poolKey]!
                    for entityID in pooledDict.keys {
                        supply = supply + pooledDict[entityID]!
                    }
                }
            }
            return supply
        }

        pub fun getLaunchDate(): String {
            return self.launchDate
        }

        pub fun getEndDate(): String {
            return self.endDate
        }

        pub fun getPaymentReceivers(): {String: Address}  {
            let paymentReceivers: {String: Address} = {}
            for salePaymentVaultType in self.paymentReceiverCaps.keys {
                let receiver = self.paymentReceiverCaps[salePaymentVaultType]!.borrow()!
                if receiver.owner != nil {
                    paymentReceivers[salePaymentVaultType] = receiver.owner!.address
                }
            }
            return paymentReceivers
        }

        pub fun getPaymentReceiverAddress(salePaymentVaultType: String): Address? {
            assert(self.paymentReceiverCaps.containsKey(salePaymentVaultType), message: "payment receiver does not exist for vault type: ".concat(salePaymentVaultType))
            let receiver = self.paymentReceiverCaps[salePaymentVaultType]!.borrow()!
            if receiver.owner != nil {
                return receiver.owner!.address
            }
            return nil
        }

        pub fun getNumMintedPerUser(): {String: {Address: UInt64}} {
            return self.numMintedPerUser
        }

        pub fun getNumMintedByUser(userAddress: Address, pool: String): UInt64 {
            assert(self.numMintedPerUser.containsKey(pool), message: "invalid pool")
            let numMintedDict = self.numMintedPerUser[pool]!
            return numMintedDict[userAddress] ?? 0
        }

        pub fun getContractName(): String {
            return self.contractName
        }

        pub fun getContractAddress(): Address {
            return self.contractAddress
        }

        pub fun getID(): UInt64 {
            return self.primarySaleID
        }

        pub fun addEntity(entityID: UInt64, pool: String, quantity: UInt64) {
            if !self.pooledEntities.containsKey(pool) {
                self.pooledEntities.insert(key: pool, {})
            }
            self.pooledEntities[pool]!.insert(key: entityID, quantity)
        }

        pub fun removeEntity(entityID: UInt64, pool: String) {
            if self.pooledEntities.containsKey(pool) {
                self.pooledEntities[pool]!.remove(key: entityID)
            }
        }

        pub fun addEntities(entityIDs: [UInt64], pool: String) {
            for id in entityIDs {
                self.addEntity(entityID: id, pool: pool, quantity: 1)
            }
        }

        pub fun pause() {
            self.status = PrimarySaleStatus.PAUSED
        }

        pub fun open() {
            pre {
                self.status != PrimarySaleStatus.OPEN : "Primary sale is already open"
                self.status != PrimarySaleStatus.CLOSED : "Cannot re-open primary sale that is closed"
            }

            self.status = PrimarySaleStatus.OPEN
        }

        pub fun close() {
            self.status = PrimarySaleStatus.CLOSED
        }

        access(self) fun verifyAdminSignedPayload(signedPayloadData: AdminSignedPayload, signature: String): Bool {
            // Gets the Crypto.KeyList and the public key of the collection's owner
            let keyList = Crypto.KeyList()
            let accountKey = self.owner!.keys.get(keyIndex: 0)!.publicKey

            let publicKey = PublicKey(
                publicKey: accountKey.publicKey,
                signatureAlgorithm: accountKey.signatureAlgorithm
            )

            return publicKey.verify(
                signature: signature.decodeHex(),
                signedData: signedPayloadData.toString().utf8,
                domainSeparationTag: "FLOW-V0.0-user",
                hashAlgorithm: HashAlgorithm.SHA3_256
            )
        }

        pub fun purchaseHeroesBox(
            payment: @FungibleToken.Vault,
            data: PurchaseDataSequential,
            adminSignedPayload: AdminSignedPayload,
            signature: String
        ) {
            pre {
                self.primarySaleID == data.primarySaleID: "primarySaleID mismatch"
                self.status == PrimarySaleStatus.OPEN: "primary sale is not open"
                data.quantity > 0: "must purchase at least one NFT"
                self.minterCap.borrow() != nil: "cannot borrow minter"
                adminSignedPayload.expiration >= UInt64(getCurrentBlock().timestamp): "expired signature"
                self.verifyAdminSignedPayload(signedPayloadData: adminSignedPayload, signature: signature): "failed to validate signature for the primary sale purchase"
                self.contractName == "HeroesOfTheFlow": "only supports heroes of the flow contract"
            }

            let pool = data.pool
            let supply = self.getSupply(pool: pool)
            let totalQuantity = data.quantity * 3
            assert(totalQuantity <= supply, message: "insufficient supply")

            let orders: [Order] = []
            var quantityNeeded = totalQuantity
            var availableEntities = self.getAllAvailableEntities(pool: pool)
            for entityID in availableEntities.keys {
                if quantityNeeded > 0 {
                    var quantityToAdd: UInt64 = availableEntities[entityID]!
                    if quantityToAdd > quantityNeeded {
                        quantityToAdd = quantityNeeded
                    }
                    orders.append(Order(entityID: entityID, quantity: quantityToAdd))
                    quantityNeeded = quantityNeeded - quantityToAdd
                } else {
                    break
                }
            }

            let purchaseData = PurchaseData(
                primarySaleID: data.primarySaleID,
                purchaserAddress: data.purchaserAddress,
                purchaserCollectionRef: data.purchaserCollectionRef,
                orders: orders,
                pool: data.pool
            )

            self.purchase(payment: <-payment, data: purchaseData)
        }

        pub fun purchaseSequentialNFTs(
            payment: @FungibleToken.Vault,
            data: PurchaseDataSequential,
            adminSignedPayload: AdminSignedPayload,
            signature: String
        ) {
            pre {
                self.primarySaleID == data.primarySaleID: "primarySaleID mismatch"
                self.status == PrimarySaleStatus.OPEN: "primary sale is not open"
                data.quantity > 0: "must purchase at least one NFT"
                self.minterCap.borrow() != nil: "cannot borrow minter"
                adminSignedPayload.expiration >= UInt64(getCurrentBlock().timestamp): "expired signature"
                self.verifyAdminSignedPayload(signedPayloadData: adminSignedPayload, signature: signature): "failed to validate signature for the primary sale purchase"
                self.contractName != "HeroesOfTheFlow": "HeroesOfTheFlow does not support sequential purchase"
            }

            let pool = data.pool
            let supply = self.getSupply(pool: pool)
            assert(data.quantity <= supply, message: "insufficient supply")

            let orders: [Order] = []
            var quantityNeeded = data.quantity
            var availableEntities = self.getAllAvailableEntities(pool: pool)
            for entityID in availableEntities.keys {
                if quantityNeeded > 0 {
                    var quantityToAdd: UInt64 = availableEntities[entityID]!
                    if quantityToAdd > quantityNeeded {
                        quantityToAdd = quantityNeeded
                    }
                    orders.append(Order(entityID: entityID, quantity: quantityToAdd))
                    quantityNeeded = quantityNeeded - quantityToAdd
                } else {
                    break
                }
            }

            let purchaseData = PurchaseData(
                primarySaleID: data.primarySaleID,
                purchaserAddress: data.purchaserAddress,
                purchaserCollectionRef: data.purchaserCollectionRef,
                orders: orders,
                pool: data.pool
            )

            self.purchase(payment: <-payment, data: purchaseData)
        }

        access(self) fun purchase(
            payment: @FungibleToken.Vault,
            data: PurchaseData,
        ) {
            pre {
                self.primarySaleID == data.primarySaleID: "primarySaleID mismatch"
                self.status == PrimarySaleStatus.OPEN: "primary sale is not open"
                data.orders.length > 0: "must purchase at least one NFT"
                self.minterCap.borrow() != nil: "cannot borrow minter"
                self.pooledEntities.containsKey(data.pool):"Pool does not exist")
            }

            let priceData = self.prices[data.pool] ?? panic("Invalid pool")

            if priceData.eligibleAddresses != nil {
                // check if purchaser is in eligible address list
                if !priceData.eligibleAddresses!.contains(data.purchaserAddress) {
                     panic("Address is ineligible for purchase")
                }
            }

            // Check if payment type is supported
            let salePaymentVaultType: String = payment.getType().identifier
            let price: UFix64 = priceData.price[salePaymentVaultType] ?? panic("payment type not supported")


            // Gets the number of NFTs minted by this user
            let numMintedByUser = self.getNumMintedByUser(userAddress: data.purchaserAddress, pool: data.pool)

            // Check payment amount is correct
            var totalQuantity: UInt64 = 0
            for order in data.orders {
                totalQuantity = totalQuantity + order.quantity
            }

            // Heroes Of The Flow is sold in a box of 3 NFTs
            if self.contractName == "HeroesOfTheFlow" {
                totalQuantity = totalQuantity / 3
            }

            assert(payment.balance == price * UFix64(totalQuantity), message: "payment vault does not contain requested price")

            // Check maxMintsPerUser limit
            if priceData.maxMintsPerUser != nil {
                assert(totalQuantity + UInt64(numMintedByUser) <= priceData.maxMintsPerUser!, message: "maximum number of mints exceeded")
            }

            // Deposit payment to payment receiver based on vault type
            assert(self.paymentReceiverCaps.containsKey(salePaymentVaultType), message: "payment receiver capability does not exist for vault type: ".concat(salePaymentVaultType))
            let receiver = self.paymentReceiverCaps[salePaymentVaultType]!.borrow()!
            receiver.deposit(from: <- payment)

            let minter = self.minterCap.borrow()!
            var i: Int = 0
            let purchasedNFTIds: [UInt64] = []
            while i < data.orders.length {
                let entityID = data.orders[i].entityID
                let quantity = data.orders[i].quantity
                let pooledDict = self.pooledEntities[data.pool]!
                assert(pooledDict.containsKey(entityID) && pooledDict[entityID]! >= quantity, message: "NFT is not available for purchase, entityID: ".concat(entityID.toString()))
                if pooledDict[entityID]! > quantity {
                    self.pooledEntities[data.pool]!.insert(key: entityID, pooledDict[entityID]! - quantity)
                } else {
                    self.pooledEntities[data.pool]!.remove(key: entityID)
                }

                var n: UInt64 = 0
                while n < quantity {
                    let nft <- minter.mint(entityID: entityID, minterAddress: data.purchaserAddress)
                    purchasedNFTIds.append(nft.id)
                    data.purchaserCollectionRef.deposit(token: <-nft)
                    n = n + 1
                }
                i = i + 1
            }
            emit PurchaseComplete(primarySaleID: self.primarySaleID, orders: data.orders, nftIDs: purchasedNFTIds, purchaserAddress: data.purchaserAddress, pool: data.pool, price: price, salePaymentVaultType: salePaymentVaultType)
            // Increments the number of NFTs minted by the user
            self.numMintedPerUser[data.pool]!.insert(key: data.purchaserAddress, numMintedByUser + totalQuantity)
        }

        pub fun getAllAvailableEntities(pool: String): {UInt64: UInt64} {
            var availableEntities: {UInt64: UInt64} = {}
            assert(self.pooledEntities.containsKey(pool), message: "Pool does not exist")
            let pooledDict = self.pooledEntities[pool]!
            for entityID in pooledDict.keys {
                availableEntities[entityID] = pooledDict[entityID]!
            }
            return availableEntities
        }

        pub fun getPooledEntities(): {String: {UInt64: UInt64}} {
            return self.pooledEntities
        }

        pub fun updateLaunchDate(date: String) {
            self.launchDate = date
        }

        pub fun updateEndDate(date: String) {
            self.endDate = date
        }

        pub fun updatePaymentReceiver(salePaymentVaultType: String, paymentReceiverCap: Capability<&{FungibleToken.Receiver}>) {
            pre {
                paymentReceiverCap.borrow() != nil: "Could not borrow payment receiver capability"
            }
            self.paymentReceiverCaps[salePaymentVaultType] = paymentReceiverCap
        }
    }

    // Admin is a special authorization resource that
    // allows the owner to create primary sales
    //
    pub resource Admin {
        pub fun createPrimarySale(
            contractName: String,
            contractAddress: Address,
            prices: {String: PriceData},
            minterCap: Capability<&{IMinter}>,
            paymentReceiverCaps: {String: Capability<&{FungibleToken.Receiver}>},
            launchDate: String,
            endDate: String
        ) {
            pre {
                minterCap.borrow() != nil: "Could not borrow minter capability"
            }

            let key = contractName.concat(contractAddress.toString())
            assert(!FlowversePrimarySaleV2.primarySaleIDs.containsKey(key), message: "Primary sale with contractName, contractAddress already exists")

            var primarySale <- create PrimarySale(
                contractName: contractName,
                contractAddress: contractAddress,
                prices: prices,
                minterCap: minterCap,
                paymentReceiverCaps: paymentReceiverCaps,
                launchDate: launchDate,
                endDate: endDate
            )

            let primarySaleID = FlowversePrimarySaleV2.nextPrimarySaleID

            FlowversePrimarySaleV2.nextPrimarySaleID = FlowversePrimarySaleV2.nextPrimarySaleID + UInt64(1)

            FlowversePrimarySaleV2.primarySales[primarySaleID] <-! primarySale
        }

        pub fun getPrimarySale(primarySaleID: UInt64): &PrimarySale? {
            if FlowversePrimarySaleV2.primarySales.containsKey(primarySaleID) {
                return (&FlowversePrimarySaleV2.primarySales[primarySaleID] as &PrimarySale?)!
            }
            return nil
        }

        pub fun createNewAdmin(): @Admin {
            return <-create Admin()
        }
    }

    pub struct PrimarySaleData {
        pub let primarySaleID: UInt64
        pub let contractName: String
        pub let contractAddress: Address
        pub let supply: UInt64
        pub let prices: {String: FlowversePrimarySaleV2.PriceData}
        pub let status: String
        pub let pooledEntities: {String: {UInt64: UInt64}}
        pub let launchDate: String
        pub let endDate: String
        pub let numMintedPerUser: {String: {Address: UInt64}}
        pub let paymentReceivers: {String: Address}

        init(
            primarySaleID: UInt64,
            contractName: String,
            contractAddress: Address,
            supply: UInt64,
            prices: {String: FlowversePrimarySaleV2.PriceData},
            status: String,
            pooledEntities: {String: {UInt64: UInt64}},
            launchDate: String,
            endDate: String,
            numMintedPerUser: {String: {Address: UInt64}},
            paymentReceivers: {String: Address} ,
        ) {
            self.primarySaleID = primarySaleID
            self.contractName = contractName
            self.contractAddress = contractAddress
            self.supply = supply
            self.prices = prices
            self.status = status
            self.pooledEntities = pooledEntities
            self.launchDate = launchDate
            self.endDate = endDate
            self.numMintedPerUser = numMintedPerUser
            self.paymentReceivers = paymentReceivers
        }
    }

    pub fun getPrimarySaleData(primarySaleID: UInt64): PrimarySaleData {
        pre {
            FlowversePrimarySaleV2.primarySales.containsKey(primarySaleID): "Primary sale does not exist"
        }
        let primarySale = (&FlowversePrimarySaleV2.primarySales[primarySaleID] as &PrimarySale?)!
        return PrimarySaleData(
            primarySaleID: primarySale.getID(),
            contractName: primarySale.getContractName(),
            contractAddress: primarySale.getContractAddress(),
            supply: primarySale.getSupply(pool: nil),
            prices: primarySale.getPrices(),
            status: primarySale.getStatus(),
            pooledEntities: primarySale.getPooledEntities(),
            launchDate: primarySale.getLaunchDate(),
            endDate: primarySale.getEndDate(),
            numMintedPerUser: primarySale.getNumMintedPerUser(),
            paymentReceivers: primarySale.getPaymentReceivers()
        )
    }

    pub fun getPrice(primarySaleID: UInt64, pool: String, salePaymentVaultType: String): UFix64 {
        pre {
            FlowversePrimarySaleV2.primarySales.containsKey(primarySaleID): "Primary sale does not exist"
        }
        let primarySale = (&FlowversePrimarySaleV2.primarySales[primarySaleID] as &PrimarySale?)!
        let prices = primarySale.getPrices()
        assert(prices.containsKey(pool), message: "pool does not exist")
        assert(prices[pool]!.price.containsKey(salePaymentVaultType), message: "salePaymentVaultType not supported")
        return prices[pool]!.price[salePaymentVaultType]!
    }

    pub fun purchaseHeroesBox(
        payment: @FungibleToken.Vault,
        data: PurchaseDataSequential,
        adminSignedPayload: AdminSignedPayload,
        signature: String
    ) {
        pre {
            FlowversePrimarySaleV2.primarySales.containsKey(data.primarySaleID): "Primary sale does not exist"
        }
        let primarySale = (&FlowversePrimarySaleV2.primarySales[data.primarySaleID] as &PrimarySale?)!
        primarySale.purchaseHeroesBox(payment: <-payment, data: data, adminSignedPayload: adminSignedPayload, signature: signature)
    }

    pub fun purchaseSequentialNFTs(
        payment: @FungibleToken.Vault,
        data: PurchaseDataSequential,
        adminSignedPayload: AdminSignedPayload,
        signature: String
    ) {
        pre {
            FlowversePrimarySaleV2.primarySales.containsKey(data.primarySaleID): "Primary sale does not exist"
        }
        let primarySale = (&FlowversePrimarySaleV2.primarySales[data.primarySaleID] as &PrimarySale?)!
        primarySale.purchaseSequentialNFTs(payment: <-payment, data: data, adminSignedPayload: adminSignedPayload, signature: signature)
    }

    pub fun getID(contractName: String, contractAddress: Address): UInt64 {
        let key = contractName.concat(contractAddress.toString())
        assert(FlowversePrimarySaleV2.primarySaleIDs.containsKey(key), message: "primary sale does not exist")
        return FlowversePrimarySaleV2.primarySaleIDs[key]!
    }

    init() {
        self.AdminStoragePath = /storage/FlowversePrimarySaleV2AdminStoragePath

        self.primarySales <- {}
        self.primarySaleIDs = {}

        self.nextPrimarySaleID = 1

        self.account.save<@Admin>(<- create Admin(), to: self.AdminStoragePath)

        emit ContractInitialized()
    }
}
"
-------
"import Crypto
import NonFungibleToken from 0x1d7e57aa55817448
import MetadataViews from 0x1d7e57aa55817448

pub contract PackNFT: NonFungibleToken {

    pub var totalSupply: UInt64
    pub let itemEditions: {UInt64: UInt32}
    pub var version: String
    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let CollectionPrivatePath: PrivatePath
    pub var CollectionPublicType: Type
    pub var CollectionPrivateType: Type
    pub let OperatorStoragePath: StoragePath
    pub let OperatorPrivPath: PrivatePath

    pub var defaultCollectionMetadata: CollectionMetadata?
    access(contract) let itemMetadata: {String: Metadata}
    access(contract) let itemCollectionMetadata: {String: CollectionMetadata}

    pub var metadataOpenedWarning: String

    // representation of the NFT in this contract to keep track of states
    access(contract) let packs: @{UInt64: Pack}

    pub event RevealRequest(id: UInt64, openRequest: Bool)
    pub event OpenRequest(id: UInt64)
    pub event Revealed(id: UInt64, salt: String, nfts: String)
    pub event Opened(id: UInt64)
    pub event MetadataUpdated(distId: UInt64, edition: UInt32?, metadata: Metadata)
    pub event CollectionMetadataUpdated(distId: UInt64, edition: UInt32?, metadata: CollectionMetadata)
    pub event Mint(id: UInt64, edition: UInt32, commitHash: String, distId: UInt64, nftCount: UInt16?, lockTime: UFix64?, additionalInfo: {String: String}?)
    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)

    pub enum Status: UInt8 {
        pub case Sealed
        pub case Revealed
        pub case Opened
    }

    pub resource interface IOperator {
        pub fun setMetadata(
            distId: UInt64,
            edition: UInt32?,
            metadata: Metadata,
            overwrite: Bool
         )
         pub fun setCollectionMetadata(
             distId: UInt64,
             edition: UInt32?,
             metadata: CollectionMetadata,
             overwrite: Bool
          )
         pub fun mint(
            distId: UInt64,
            additionalInfo: {String: String}?,
            commitHash: String,
            issuer: Address,
            nftCount: UInt16?,
            lockTime: UFix64?
         ): @NFT
        pub fun reveal(id: UInt64, nfts: [&NonFungibleToken.NFT], salt: String)
        pub fun open(id: UInt64, nfts: [&NonFungibleToken.NFT])
    }

    pub resource PackNFTOperator: IOperator {

         pub fun setMetadata(
            distId: UInt64,
            edition: UInt32?,
            metadata: Metadata,
            overwrite: Bool
         ) {
            let fullId = edition != nil ? distId.toString().concat(":").concat(edition!.toString()) : distId.toString()
            if !overwrite && PackNFT.itemMetadata[fullId] != nil {
                return
            }
            PackNFT.itemMetadata[fullId] = metadata
            emit MetadataUpdated(distId: distId, edition: edition, metadata: metadata)

         }

         pub fun setCollectionMetadata(
            distId: UInt64,
            edition: UInt32?,
            metadata: CollectionMetadata,
            overwrite: Bool
         ) {
            let fullId = edition != nil ? distId.toString().concat(":").concat(edition!.toString()) : distId.toString()
            if !overwrite && PackNFT.itemCollectionMetadata[fullId] != nil {
                return
            }
            PackNFT.itemCollectionMetadata[fullId] = metadata
            emit CollectionMetadataUpdated(distId: distId, edition: edition, metadata: metadata)

         }

         pub fun mint(
            distId: UInt64,
            additionalInfo: {String: String}?,
            commitHash: String,
            issuer: Address,
            nftCount: UInt16?,
            lockTime: UFix64?
         ): @NFT{
            assert(PackNFT.defaultCollectionMetadata != nil, message: "Please set the default collection metadata before minting")

            let totalEditions = PackNFT.itemEditions[distId] ?? UInt32(0)
            let edition = totalEditions + UInt32(1)
            let id = PackNFT.totalSupply + 1
            let nft <- create NFT(id: id, distId: distId, edition: edition, additionalInfo: additionalInfo, commitHash: commitHash, issuer: issuer, nftCount: nftCount, lockTime: lockTime)
            PackNFT.itemEditions[distId] = edition
            PackNFT.totalSupply = PackNFT.totalSupply + 1
            let p  <-create Pack(commitHash: commitHash, issuer: issuer, nftCount: nftCount, lockTime: lockTime)
            PackNFT.packs[id] <-! p
            emit Mint(id: id, edition: edition, commitHash: commitHash, distId: distId, nftCount: nftCount, lockTime: lockTime, additionalInfo: additionalInfo)
            return <- nft
         }

        pub fun reveal(id: UInt64, nfts: [&NonFungibleToken.NFT], salt: String) {
            let p <- PackNFT.packs.remove(key: id) ?? panic("no such pack")
            p.reveal(id: id, nfts: nfts, salt: salt)
            PackNFT.packs[id] <-! p
        }

        pub fun open(id: UInt64, nfts: [&NonFungibleToken.NFT]) {
            let p <- PackNFT.packs.remove(key: id) ?? panic("no such pack")
            p.open(id: id, nfts: nfts)
            PackNFT.packs[id] <-! p
        }

        pub fun createOperator(): @PackNFTOperator {
            return <- create PackNFTOperator()
        }

        pub fun setDefaultCollectionMetadata(defaultCollectionMetadata: CollectionMetadata) {
            PackNFT.defaultCollectionMetadata = defaultCollectionMetadata
        }

        pub fun setVersion(version: String) {
            PackNFT.version = version
        }

        init(){}
    }

    pub resource Pack {
        pub let commitHash: String
        pub let issuer: Address
        pub let nftCount: UInt16?
        pub let lockTime: UFix64?
        pub var status: Status
        pub var salt: String?

        pub fun verify(nftString: String): Bool {
            assert(self.status as! PackNFT.Status != PackNFT.Status.Sealed, message: "Pack not revealed yet")
            var hashString = self.salt!
            hashString = hashString.concat(",").concat(nftString)
            let hash = HashAlgorithm.SHA2_256.hash(hashString.utf8)
            assert(self.commitHash == String.encodeHex(hash), message: "CommitHash was not verified")
            return true
        }

        access(self) fun _hashNft(nft: &NonFungibleToken.NFT): String {
            return nft.getType().identifier.concat(".").concat(nft.id.toString())
        }

        access(self) fun _verify(nfts: [&NonFungibleToken.NFT], salt: String, commitHash: String): String {
            assert(self.nftCount == nil || self.nftCount! == (UInt16(nfts.length)), message: "nftCount doesn't match nfts length")
            var hashString = salt.concat(",").concat(nfts.length.toString())
            var nftString = nfts.length > 0 ? self._hashNft(nft: nfts[0]) : ""
            var i = 1
            while i < nfts.length {
                let s = self._hashNft(nft: nfts[i])
                nftString = nftString.concat(",").concat(s)
                i = i + 1
            }
            hashString = hashString.concat(",").concat(nftString)
            let hash = HashAlgorithm.SHA2_256.hash(hashString.utf8)
            assert(self.commitHash == String.encodeHex(hash), message: "CommitHash was not verified")
            return nftString
        }

        access(contract) fun reveal(id: UInt64, nfts: [&NonFungibleToken.NFT], salt: String) {
            assert(self.status as! PackNFT.Status == PackNFT.Status.Sealed, message: "Pack status is not Sealed")
            let v = self._verify(nfts: nfts, salt: salt, commitHash: self.commitHash)
            self.salt = salt
            self.status = PackNFT.Status.Revealed
            emit Revealed(id: id, salt: salt, nfts: v)
        }

        access(contract) fun open(id: UInt64, nfts: [&NonFungibleToken.NFT]) {
            pre {
                (self.lockTime == nil) || (getCurrentBlock().timestamp > self.lockTime!): "Pack is locked until ".concat(self.lockTime!.toString())
            }
            assert(self.status as! PackNFT.Status == PackNFT.Status.Revealed, message: "Pack status is not Revealed")
            self._verify(nfts: nfts, salt: self.salt!, commitHash: self.commitHash)
            self.status = PackNFT.Status.Opened
            emit Opened(id: id)
        }

        init(commitHash: String, issuer: Address, nftCount: UInt16?, lockTime: UFix64?) {
            self.commitHash = commitHash
            self.issuer = issuer
            self.status = PackNFT.Status.Sealed
            self.salt = nil
            self.nftCount = nftCount
            self.lockTime = lockTime
        }
    }

    pub struct Metadata {
        pub let title: String
        pub let description: String
        pub let creator: String
        pub let asset: String
        pub let assetMimeType: String
        pub let assetHash: String
        pub let artwork: String
        pub let artworkMimeType: String
        pub let artworkHash: String
        pub let artworkAlternate: String?
        pub let artworkAlternateMimeType: String?
        pub let artworkAlternateHash: String?
        pub let artworkOpened: String?
        pub let artworkOpenedMimeType: String?
        pub let artworkOpenedHash: String?
        pub let thumbnail: String
        pub let thumbnailMimeType: String
        pub let thumbnailOpened: String?
        pub let thumbnailOpenedMimeType: String?
        pub let termsUrl: String
        pub let externalUrl: String?
        pub let rarity: String?
        pub let credits: String?

        pub fun toDict(): {String: AnyStruct?} {
            let rawMetadata: {String: AnyStruct?} = {}
            rawMetadata.insert(key: "title", self.title)
            rawMetadata.insert(key: "description", self.description)
            rawMetadata.insert(key: "creator", self.creator)
            if(self.asset.length == 0){
                rawMetadata.insert(key: "asset", nil)
                rawMetadata.insert(key: "assetMimeType", nil)
                rawMetadata.insert(key: "assetHash", nil)
            }else{
                rawMetadata.insert(key: "asset", self.asset)
                rawMetadata.insert(key: "assetMimeType", self.assetMimeType)
                rawMetadata.insert(key: "assetHash", self.assetHash)
            }
            rawMetadata.insert(key: "artwork", self.artwork)
            rawMetadata.insert(key: "artworkMimeType", self.artworkMimeType)
            rawMetadata.insert(key: "artworkHash", self.artworkHash)
            rawMetadata.insert(key: "artworkAlternate", self.artworkAlternate)
            rawMetadata.insert(key: "artworkAlternateMimeType", self.artworkAlternateMimeType)
            rawMetadata.insert(key: "artworkAlternateHash", self.artworkAlternateHash)
            rawMetadata.insert(key: "artworkOpened", self.artworkOpened)
            rawMetadata.insert(key: "artworkOpenedMimeType", self.artworkOpenedMimeType)
            rawMetadata.insert(key: "artworkOpenedHash", self.artworkOpenedHash)
            rawMetadata.insert(key: "thumbnail", self.thumbnail)
            rawMetadata.insert(key: "thumbnailMimeType", self.thumbnailMimeType)
            rawMetadata.insert(key: "thumbnailOpened", self.thumbnailOpened)
            rawMetadata.insert(key: "thumbnailOpenedMimeType", self.thumbnailOpenedMimeType)
            rawMetadata.insert(key: "termsUrl", self.termsUrl)
            rawMetadata.insert(key: "externalUrl", self.externalUrl)
            rawMetadata.insert(key: "rarity", self.rarity)
            rawMetadata.insert(key: "credits", self.credits)

            return rawMetadata
        }

        pub fun toStringDict(): {String: String?} {
            let rawMetadata: {String: String?} = {}
            rawMetadata.insert(key: "title", self.title)
            rawMetadata.insert(key: "description", self.description)
            rawMetadata.insert(key: "creator", self.creator)
            if(self.asset.length == 0){
                rawMetadata.insert(key: "asset", nil)
                rawMetadata.insert(key: "assetMimeType", nil)
                rawMetadata.insert(key: "assetHash", nil)
            }else{
                rawMetadata.insert(key: "asset", self.asset)
                rawMetadata.insert(key: "assetMimeType", self.assetMimeType)
                rawMetadata.insert(key: "assetHash", self.assetHash)
            }
            rawMetadata.insert(key: "artwork", self.artwork)
            rawMetadata.insert(key: "artworkMimeType", self.artworkMimeType)
            rawMetadata.insert(key: "artworkHash", self.artworkHash)
            rawMetadata.insert(key: "artworkAlternate", self.artworkAlternate)
            rawMetadata.insert(key: "artworkAlternateMimeType", self.artworkAlternateMimeType)
            rawMetadata.insert(key: "artworkAlternateHash", self.artworkAlternateHash)
            rawMetadata.insert(key: "artworkOpened", self.artworkOpened)
            rawMetadata.insert(key: "artworkOpenedMimeType", self.artworkOpenedMimeType)
            rawMetadata.insert(key: "artworkOpenedHash", self.artworkOpenedHash)
            rawMetadata.insert(key: "thumbnail", self.thumbnail)
            rawMetadata.insert(key: "thumbnailMimeType", self.thumbnailMimeType)
            rawMetadata.insert(key: "thumbnailOpened", self.thumbnailOpened)
            rawMetadata.insert(key: "thumbnailOpenedMimeType", self.thumbnailOpenedMimeType)
            rawMetadata.insert(key: "termsUrl", self.termsUrl)
            rawMetadata.insert(key: "externalUrl", self.externalUrl)
            rawMetadata.insert(key: "rarity", self.rarity)
            rawMetadata.insert(key: "credits", self.credits)

            return rawMetadata
        }

        pub fun patchedForOpened(): Metadata {
            return Metadata(
                title: PackNFT.metadataOpenedWarning.concat(self.title),
                description: PackNFT.metadataOpenedWarning.concat(self.description),
                creator: self.creator,
                asset: self.asset,
                assetMimeType: self.assetMimeType,
                assetHash: self.assetHash,
                artwork: self.artworkOpened ?? self.artwork,
                artworkMimeType: self.artworkOpenedMimeType ?? self.artworkMimeType,
                artworkHash: self.artworkOpenedHash ?? self.artworkHash,
                artworkAlternate: self.artworkAlternate,
                artworkAlternateMimeType: self.artworkAlternateMimeType,
                artworkAlternateHash: self.artworkAlternateHash,
                artworkOpened: self.artworkOpened,
                artworkOpenedMimeType: self.artworkOpenedMimeType,
                artworkOpenedHash: self.artworkOpenedHash,
                thumbnail: self.thumbnailOpened ?? self.thumbnail,
                thumbnailMimeType: self.thumbnailOpenedMimeType ?? self.thumbnailMimeType,
                thumbnailOpened: self.thumbnailOpened,
                thumbnailOpenedMimeType: self.thumbnailOpenedMimeType,
                termsUrl: self.termsUrl,
                externalUrl: self.externalUrl,
                rarity: self.rarity,
                credits: self.credits
            )
        }


        init(
            title: String,
            description: String,
            creator: String,
            asset: String,
            assetMimeType: String,
            assetHash: String,
            artwork: String,
            artworkMimeType: String,
            artworkHash: String,
            artworkAlternate: String?,
            artworkAlternateMimeType: String?,
            artworkAlternateHash: String?,
            artworkOpened: String?,
            artworkOpenedMimeType: String?,
            artworkOpenedHash: String?,
            thumbnail: String,
            thumbnailMimeType: String,
            thumbnailOpened: String?,
            thumbnailOpenedMimeType: String?,
            termsUrl: String,
            externalUrl: String?,
            rarity: String?,
            credits: String?
        ) {

            self.title = title
            self.description = description
            self.creator = creator
            self.asset = asset
            self.assetMimeType = assetMimeType
            self.assetHash = assetHash
            self.artwork = artwork
            self.artworkMimeType = artworkMimeType
            self.artworkHash = artworkHash
            self.artworkAlternate = artworkAlternate
            self.artworkAlternateMimeType = artworkAlternateMimeType
            self.artworkAlternateHash = artworkAlternateHash
            self.artworkOpened = artworkOpened
            self.artworkOpenedMimeType = artworkOpenedMimeType
            self.artworkOpenedHash = artworkOpenedHash
            self.thumbnail = thumbnail
            self.thumbnailMimeType = thumbnailMimeType
            self.thumbnailOpened = thumbnailOpened
            self.thumbnailOpenedMimeType = thumbnailOpenedMimeType
            self.termsUrl = termsUrl
            self.externalUrl = externalUrl
            self.credits = credits
            self.rarity = rarity
        }
    }


    pub struct CollectionMetadata {
        pub let name: String
        pub let description: String
        pub let URL: String
        pub let media: String
        pub let mediaMimeType: String
        pub let mediaBanner: String?
        pub let mediaBannerMimeType: String?
        pub let socials: {String:String}


        pub fun toDict(): {String: AnyStruct?} {
            let rawMetadata: {String: AnyStruct?} = {}

            rawMetadata.insert(key: "name", self.name)
            rawMetadata.insert(key: "description", self.description)
            rawMetadata.insert(key: "URL", self.URL)
            rawMetadata.insert(key: "media", self.media)
            rawMetadata.insert(key: "mediaMimeType", self.mediaMimeType)
            rawMetadata.insert(key: "mediaBanner", self.mediaBanner)
            rawMetadata.insert(key: "mediaBannerMimeType", self.mediaBanner)
            rawMetadata.insert(key: "socials", self.socials)

            return rawMetadata
        }

        init(
            name: String,
            description: String,
            URL: String,
            media: String,
            mediaMimeType: String,
            mediaBanner: String?,
            mediaBannerMimeType: String?,
            socials: {String:String}?,
        ) {
            self.name = name
            self.description = description
            self.URL = URL
            self.media = media
            self.mediaMimeType = mediaMimeType
            self.mediaBanner = mediaBanner
            self.mediaBannerMimeType = mediaBannerMimeType
            self.socials = socials ?? {}
        }
    }

    pub resource interface IPackNFTToken {
        pub let id: UInt64
        pub let edition: UInt32
        pub let commitHash: String
        pub let issuer: Address
        pub let nftCount: UInt16?
        pub let lockTime: UFix64?
    }

    pub resource interface IPackNFTOwnerOperator {
        pub fun reveal(openRequest: Bool)
        pub fun open()
    }

    pub resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver, IPackNFTToken, IPackNFTOwnerOperator {
        pub let id: UInt64
        pub let distId: UInt64
        pub let edition: UInt32
        pub let commitHash: String
        pub let issuer: Address
        pub let nftCount: UInt16?
        pub let lockTime: UFix64?

        access(self) let additionalInfo: {String: String}
        pub let mintedBlock: UInt64
        pub let mintedTime: UFix64

        pub fun reveal(openRequest: Bool){
            PackNFT.revealRequest(id: self.id, openRequest: openRequest)
        }

        pub fun open(){
            pre {
                (self.lockTime == nil) || (getCurrentBlock().timestamp > self.lockTime!): "Pack is locked until ".concat(self.lockTime!.toString())
            }
            PackNFT.openRequest(id: self.id)
        }

        pub fun getAdditionalInfo(): {String: String} {
            return self.additionalInfo
        }

        pub fun totalEditions(): UInt32 {
            return PackNFT.itemEditions[self.distId] ?? UInt32(0)
        }

        pub fun getViews(): [Type] {
            return [
                Type<Metadata>(),
                Type<MetadataViews.Display>(),
                Type<MetadataViews.Editions>(),
                Type<MetadataViews.ExternalURL>(),
                Type<MetadataViews.NFTCollectionData>(),
                Type<MetadataViews.NFTCollectionDisplay>(),
                Type<MetadataViews.Serial>(),
                Type<MetadataViews.Traits>()
            ]
        }

        pub fun resolveView(_ view: Type): AnyStruct? {
            switch view {
                case Type<Metadata>():
                    return self.metadata()
                case Type<MetadataViews.Display>():
                    return MetadataViews.Display(
                        name: self.metadata().title,
                        description: self.metadata().description,
                        thumbnail: MetadataViews.HTTPFile(
                            url: self.metadata().thumbnail
                        )
                    )
                case Type<MetadataViews.Serial>():
                    return MetadataViews.Serial(
                        UInt64(self.edition)
                    )
                case Type<MetadataViews.Editions>():
                    let name = self.collectionMetadata()?.name ?? PackNFT.defaultCollectionMetadata!.name
                    let editionInfo = MetadataViews.Edition(name: name, number: UInt64(self.edition), max: nil)
                    let editionList: [MetadataViews.Edition] = [editionInfo]
                    return MetadataViews.Editions(
                        editionList
                    )
                case Type<MetadataViews.ExternalURL>():
                    return MetadataViews.ExternalURL(
                        self.metadata().externalUrl ?? "https://www.tunegonft.com/view-pack-collectible/".concat(self.uuid.toString())
                    )
                case Type<MetadataViews.NFTCollectionData>():
                    return MetadataViews.NFTCollectionData(
                        storagePath: PackNFT.CollectionStoragePath,
                        publicPath: PackNFT.CollectionPublicPath,
                        providerPath: PackNFT.CollectionPrivatePath,
                        publicCollection: PackNFT.CollectionPublicType,
                        publicLinkedType: PackNFT.CollectionPublicType,
                        providerLinkedType: PackNFT.CollectionPrivateType,
                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {
                            return <-PackNFT.createEmptyCollection()
                        })
                    )
                case Type<MetadataViews.NFTCollectionDisplay>():
                    let collectionMetadata = self.collectionMetadata() ?? PackNFT.defaultCollectionMetadata!
                    let media = MetadataViews.Media(
                        file: MetadataViews.HTTPFile(
                            url: collectionMetadata.media
                        ),
                        mediaType: collectionMetadata.mediaMimeType
                    )
                    let mediaBanner = collectionMetadata.mediaBanner != nil ?
                        MetadataViews.Media(
                            file: MetadataViews.HTTPFile(
                                url: collectionMetadata.mediaBanner!
                            ),
                            mediaType: collectionMetadata.mediaBannerMimeType!
                        )
                        : media
                    let socials: {String:MetadataViews.ExternalURL} = {}
                    collectionMetadata.socials.forEachKey(fun (key: String): Bool {
                        socials.insert(key: key,MetadataViews.ExternalURL(collectionMetadata.socials[key]!))
                        return false
                    })
                    return MetadataViews.NFTCollectionDisplay(
                        name: collectionMetadata.name,
                        description: collectionMetadata.description,
                        externalURL: MetadataViews.ExternalURL(collectionMetadata.URL),
                        squareImage: media,
                        bannerImage: mediaBanner,
                        socials: socials
                    )
                case Type<MetadataViews.Traits>():
                    let excludedTraits = ["mintedTime"]
                    let dict = self.metadataDict()
                    dict.forEachKey(fun (key: String): Bool {
                        if (dict[key] == nil) {
                            dict.remove(key: key)
                        }
                        return false
                    })
                    let traitsView = MetadataViews.dictToTraits(dict: dict, excludedNames: excludedTraits)

                    // mintedTime is a unix timestamp, we should mark it with a displayType so platforms know how to show it.
                    let mintedTimeTrait = MetadataViews.Trait(name: "mintedTime", value: self.mintedTime!, displayType: "Date", rarity: nil)
                    traitsView.addTrait(mintedTimeTrait)

                    return traitsView
            }

            return nil
        }

        pub fun _metadata(): Metadata  {
            let fullId = self.distId.toString().concat(":").concat(self.edition.toString())
            let editionMetadata = PackNFT.itemMetadata[fullId]
            if editionMetadata != nil {
                return editionMetadata!
            }
            let distMetadata = PackNFT.itemMetadata[self.distId.toString()]
            if distMetadata != nil {
                return distMetadata!
            }
            panic("Metadata not found for collectible ".concat(fullId))
        }

        pub fun metadata(): Metadata {
            let metadata = self._metadata()
            let p = PackNFT.borrowPackRepresentation(id: self.id) ?? panic ("Pack representation not found")
            if p.status as! PackNFT.Status == PackNFT.Status.Opened {
                return metadata.patchedForOpened()
            }
            return metadata
        }

        pub fun collectionMetadata(): CollectionMetadata?  {
            let fullId = self.distId.toString().concat(":").concat(self.edition.toString())
            let editionMetadata = PackNFT.itemCollectionMetadata[fullId]
            if editionMetadata != nil {
                return editionMetadata!
            }
            let distMetadata = PackNFT.itemCollectionMetadata[self.distId.toString()]
            return distMetadata
        }

        pub fun metadataDict(): {String: AnyStruct?} {
            let dict = self.metadata().toDict()
            let collectionDict = self.collectionMetadata()?.toDict()
            if (collectionDict != nil) {
                collectionDict!.forEachKey(fun (key: String): Bool {
                    dict.insert(key: "collection_".concat(key), collectionDict![key])
                    return false
                })
            }

            dict.insert(key: "mintedBlock", self.mintedBlock)
            dict.insert(key: "mintedTime", self.mintedTime)

            return dict
        }

        init(
            id: UInt64,
            distId: UInt64,
            edition: UInt32,
            additionalInfo: {String: String}?,
            commitHash: String,
            issuer: Address,
            nftCount: UInt16?,
            lockTime: UFix64?
        ) {
            self.id = id
            self.distId = distId
            self.edition = edition
            self.additionalInfo = additionalInfo ?? {}
            self.commitHash = commitHash
            self.issuer = issuer
            self.nftCount = nftCount
            self.lockTime = lockTime
            let currentBlock = getCurrentBlock()
            self.mintedBlock = currentBlock.height
            self.mintedTime = currentBlock.timestamp

            // asserts metadata exists for distribution / edition
            self._metadata()
        }

        destroy(){
            let p = PackNFT.borrowPackRepresentation(id: self.id) ?? panic ("No such pack")
            assert(p.status as! PackNFT.Status == PackNFT.Status.Opened, message: "Pack status must be Opened in order to destroy the PackNFT")
        }

    }


    pub resource interface IPackNFTCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowPackNFT(id: UInt64): &NFT{IPackNFTToken, NonFungibleToken.INFT, MetadataViews.Resolver}? {
            // If the result isn't nil, the id of the returned reference
            // should be the same as the argument to the function
            post {
                (result == nil) || (result!.id == id):
                    "Cannot borrow PackNFT reference: The ID of the returned reference is incorrect"
            }
        }
    }
    pub resource interface IPackNFTCollectionPrivate {
        pub fun borrowPackNFT(id: UInt64): &NFT{IPackNFTToken, NonFungibleToken.INFT, MetadataViews.Resolver, IPackNFTOwnerOperator}? {
            // If the result isn't nil, the id of the returned reference
            // should be the same as the argument to the function
            post {
                (result == nil) || (result!.id == id):
                    "Cannot borrow PackNFT reference: The ID of the returned reference is incorrect"
            }
        }
    }

    pub resource Collection:
        NonFungibleToken.Provider,
        NonFungibleToken.Receiver,
        NonFungibleToken.CollectionPublic,
        MetadataViews.ResolverCollection,
        IPackNFTCollectionPublic,
        IPackNFTCollectionPrivate
    {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with an `UInt64` ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        init () {
            self.ownedNFTs <- {}
        }

        // withdraw removes an NFT from the collection and moves it to the caller
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic("missing NFT")
            emit Withdraw(id: token.id, from: self.owner?.address)
            return <- token
        }

        // deposit takes a NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @PackNFT.NFT

            let id: UInt64 = token.id

            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token
            emit Deposit(id: id, to: self.owner?.address)

            destroy oldToken
        }

        // getIDs returns an array of the IDs that are in the collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT gets a reference to an NFT in the collection
        // so that the caller can read its metadata and call its methods
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!
        }

        pub fun borrowPackNFT(id: UInt64): &NFT? {
            let nft<- self.ownedNFTs.remove(key: id)
            if(nft == nil){
                destroy nft
                return nil
            }
            let token <- nft! as! @PackNFT.NFT
            let ref = &token as &NFT
            self.ownedNFTs[id] <-! token as! @PackNFT.NFT
            return ref
        }

        pub fun borrowViewResolver(id: UInt64): &AnyResource{MetadataViews.Resolver} {
            let nft = (&self.ownedNFTs[id] as auth &NonFungibleToken.NFT?)!
            let ref = nft as! &PackNFT.NFT
            return ref as &AnyResource{MetadataViews.Resolver}
        }

        destroy() {
            destroy self.ownedNFTs
        }
    }

    access(contract) fun revealRequest(id: UInt64, openRequest: Bool ) {
        let p = PackNFT.borrowPackRepresentation(id: id) ?? panic ("No such pack")
        assert(p.status == PackNFT.Status.Sealed, message: "Pack status must be Sealed for reveal request")
        emit RevealRequest(id: id, openRequest: openRequest)
    }

    access(contract) fun openRequest(id: UInt64) {
        let p = PackNFT.borrowPackRepresentation(id: id) ?? panic ("No such pack")
        assert(p.status == PackNFT.Status.Revealed, message: "Pack status must be Revealed for open request")
        emit OpenRequest(id: id)
    }

    pub fun publicReveal(id: UInt64, nfts: [&NonFungibleToken.NFT], salt: String) {
        let p = PackNFT.borrowPackRepresentation(id: id) ?? panic ("No such pack")
        p.reveal(id: id, nfts: nfts, salt: salt)
    }

    pub fun borrowPackRepresentation(id: UInt64):  &Pack? {
        return &self.packs[id] as &Pack?
    }

    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    init() {
        self.totalSupply = 0
        self.itemEditions = {}
        self.packs <- {}
        self.CollectionStoragePath = /storage/tunegoPack
        self.CollectionPublicPath = /public/tunegoPack
        self.CollectionPrivatePath = /private/tunegoPackPriv
        self.OperatorStoragePath = /storage/tunegoPackOperator
        self.OperatorPrivPath = /private/tunegoPackOperator
        self.defaultCollectionMetadata = nil
        self.version = "1.0"

        self.itemMetadata = {}
        self.itemCollectionMetadata = {}
        self.metadataOpenedWarning = "WARNING this pack has already been opened! \n"

        self.CollectionPublicType = Type<&Collection{NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection, IPackNFTCollectionPublic}>()
        self.CollectionPrivateType = Type<&Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, IPackNFTCollectionPrivate}>()

        // Create a collection to receive Pack NFTs
        let collection <- create Collection()
        self.account.save(<-collection, to: self.CollectionStoragePath)
        self.account.link<&Collection{NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection, IPackNFTCollectionPublic}>(self.CollectionPublicPath, target: self.CollectionStoragePath)
        self.account.link<&Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic, IPackNFTCollectionPrivate}>(self.CollectionPrivatePath, target: self.CollectionStoragePath)

        // Create a operator to share mint capability with proxy
        let operator <- create PackNFTOperator()
        self.account.save(<-operator, to: self.OperatorStoragePath)
        self.account.link<&PackNFTOperator{IOperator}>(self.OperatorPrivPath, target: self.OperatorStoragePath)
    }

}

"
